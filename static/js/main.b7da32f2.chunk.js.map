{"version":3,"sources":["../../../src/base64.ts","../../../src/error.ts","../../../src/async.ts","../../../src/decoder.ts","../../../src/mapSet.ts","../../../src/packageJson.ts","../../../src/path.ts","../../../src/uri.ts","../../../src/memoryStrategy.ts","velcro/monaco.ts","velcro/types.ts","velcro/velcroWorker.ts","../../../node_modules/sourcemap-codec/dist/sourcemap-codec.es.js","../../../src/graph/errors.ts","../../../src/build/sourceMap.ts","../../../src/build/sourceMapTree.ts","../../../src/graph/sourceModuleDependency.ts","../../../src/plugins/pluginManager.ts","../../../src/graph/commonjs/ast.ts","../../../src/graph/commonjs/traverse.ts","../../../src/graph/commonjs/parser.ts","../../../src/build/chunkOutput.ts","../../../src/build/chunk.ts","../../../src/code.ts","../../../src/graph/graph.ts","../../../src/graph/shims.ts","../../../src/graph/sourceModule.ts","../../../src/graph/graphBuilder.ts","../../../src/cdnStrategy.ts","../../../src/compoundStrategy.ts","../../../src/execute.ts","lib/svelte.language.ts","lib/EditorManager.ts","playground/Editor.tsx","playground/Preview.tsx","lib/hooks.ts","playground/Sidebar.tsx","playground/Playground.tsx","templates/svelte.ts","useServiceWorker.tsx","App.tsx","serviceWorker.ts","index.tsx","../../../src/bareModules.ts","../../../src/shims.ts","../../../src/strategy.ts","../../../src/context.ts","../../../src/resolver.ts"],"names":["Base64","name","uri","parentUri","err","shouldAwait","result","values","element","isThenable","checkCancellation","Promise","a","token","object","decode","global","data","atob","decodeURIComponent","escape","_data","Error","encode","btoa","unescape","encodeURIComponent","TextDecoder","this","Buffer","str","decoder","get","value","ret","delete","has","key","hasInvalidBrowserField","json","error","browser","hasInvalidRequiredStringField","hasInvalidOptionalStringField","hasInvalidDependenciesField","Object","parseTextAsPartialPackageJson","text","isValidPackageJson","parseTextAsPackageJson","JSON","isValidPartialPackageJson","expected","determiner","type","msg","validateString","ErrorInvalidArgType","isPosixPathSeparator","code","normalizeString","res","lastSegmentLength","lastSlash","dots","i","path","isPathSeparator","lastSlashIndex","posix","resolve","resolvedPath","resolvedAbsolute","process","normalize","isAbsolute","trailingSeparator","join","arg","joined","relative","from","to","fromEnd","fromLen","toLen","length","lastCommonSep","fromCode","out","toNamespacedPath","dirname","hasRoot","end","matchedSlash","basename","ext","start","extIdx","firstNonSlashEnd","extname","startDot","startPart","preDotState","format","sep","pathObject","dir","base","parse","root","delimiter","win32","_schemePattern","_singleSlashStart","_doubleSlashStart","_validateUri","_schemeFix","scheme","_referenceResolution","_slash","_regexp","_strict","schemeOrData","authority","query","fragment","_URI","skipEncoding","_asFormatted","uriToFsPath","trailingSlash","l","r","childHref","child","parentHref","parent","parentOffset","prefix","thing","match","percentDecode","idx","components","newPath","_pathSepMarker","_formatted","_fsPath","$mid","encodeTable","encodeURIComponentFast","uriComponent","nativeEncodePos","pos","allowSlash","escaped","encodeURIComponentMinimal","encoder","userinfo","String","_rEncodedAsHex","decodeURIComponentGraceful","TRAILING_SLASH_RX","FileEncoding","encodeText","TextEncoder","rootUri","children","file","files","encoding","segments","Array","pathname","overwrite","filename","entry","content","urlPathname","basePathname","fsPathname","getEntryAtPath","entries","binSting","binArray","Uint8Array","_el","arr","buffer","trackMonaco","monaco","disposer","DisposableStore","worker","Worker","trackModel","model","onWillDispose","message","event","href","toString","postMessage","disposerReference","dispose","add","onDidChangeContent","getValue","postMessageEmitter","Emitter","postMessageQueue","Event","debounce","last","Map","set","events","fire","editor","getModels","forEach","onDidCreateModel","terminate","emitter","addEventListener","e","WorkerState","is","FileCreateEvent","z","FileRemoveEvent","FileUpdateEvent","EditorEvent","BuiltState","state","int","BuildingState","completed","pending","ErrorState","InitialState","module","exports","charToInteger","chars","charCodeAt","mappings","decoded","line","segment","j","shift","c","segmentify","push","integer","undefined","fromCharCode","hasContinuationBit","shouldNegate","sourceFileIndex","sourceCodeLine","sourceCodeColumn","nameIndex","generatedCodeColumn","lineMappings","_i","line_1","segmentMappings","encodeInteger","num","clamped","input","getSourceMappingUrlMatch","re","lastMatch","names","sources","sourcesContent","column","source","map","loadLink","link","tracedLine","traced","sourceIndex","tracedSegment","m","plugins","load","readReturn","ctx","readResult","visited","resolveDependency","resolveReturn","dependency","fromSourceModule","resolveResult","resolveEntrypoint","transform","createMagicString","id","magicString","sourceMap","loadReturn","plugin","loadResult","fromModule","pluginCtx","sourceMapTree","sourceMapRef","getSourceMappingUrl","decodeDataUriAsSourceMap","sourceMapUri","updateSourceMappingUrl","baseSources","transformReturn","transformResult","SourceModuleDependencyKind","options","kind","spec","locations","SourceModuleDependency","exportName","node","isLiteral","_shouldSkip","shouldSkip","enter","skipped","keys","childKeys","b","leave","ast","skip","visitorCtx","unboundSymbols","locals","indentExclusionRanges","nodeEnv","replacedSymbols","requires","requireResolves","skipTransform","Set","dependencies","allowReturnOutsideFunction","sourceType","parseAst","traverse","requiresBySpec","requireDependency","requireResolvesBySpec","shim","location","scopingAndRequiresVisitor","isVariableDeclaration","nextParent","isScope","isBlockScope","declarePattern","isFunctionDeclaration","declareFunction","isFunctionExpression","isArrowFunctionExpression","isFunction","isClassDeclaration","isTryStatement","visitAndCaptureScoping","isIfStatement","isBinaryExpression","test","isStringLiteral","isMemberExpression","memberExpressionMatches","rootObject","isIdentifier","visitAndSkipBranches","isCallExpression","callee","firstArg","isTemplateLiteral","console","raw","visitRequires","nextCheck","contentOnly","storeName","collectGlobalsVisitor","isPropertyOfMemberExpression","isProperty","isKeyOfProperty","isMethodDefinition","isKeyOfMethodDefinition","isBindingIdentifier","isUnaryExpression","isArgumentOfTypeOf","foundBinding","declaresArguments","isThisExpression","declaresThis","isObjectPattern","isRestElement","isArrayPattern","isAssignmentPattern","isProgram","isBlockStatement","memberParts","pattern","property","bundle","sourceMapTreeMappings","version","edgesFrom","edgesTo","sourceModules","sourceModule","fromHref","edge","toHref","separator","moduleScopes","importMap","scopes","sourceModuleCode","defs","inputMap","includeContent","hires","sourceHref","edges","DEFAULT_SHIM_GLOBALS","export","globalThis","sourceMapsTree","visits","errors","seen","pendingModuleOperations","onCompletedEmitter","onErrorEmitter","onProgressEmitter","done","graph","reject","onError","fn","progress","size","tokenSource","edgesByDependency","edgesByInvalidation","sourceModulesByInvalidation","build","external","dep","resolver","existingSourceModule","visitSourceModule","parseResult","globalModules","existingEdge","fromUri","fromRootUri","toUri","toRootUri","isValidEntry","isValidFile","isValidDirectory","specToString","specRx","url","JSDelivrCdn","mapChildEntry","matches","protocol","host","dataHost","UNPKG_SPEC_RX","UnpkgCdn","cdn","contentCache","locks","packageEntriesCache","packageJsonCache","unresolvedUri","urlForPackageFile","_withRootUriCheck","unresolvedSpec","packageJsonReturn","packageJson","results","resolveRootUri","canonicalizedSpec","traversalSegments","parentEntry","uriStr","cached","wrappedReturn","constructor","_withLock","packageEntriesCacheForModule","exactMatch","range","rootDir","urlForPackageList","readUrlFn","dataStr","normalizePackageListing","packageJsonCacheForModule","visit","contentReturn","contentResult","manifest","canonicalHref","lock","runCriticalSection","locked","CdnStrategy","strategy","_delegateToStrategy","found","defaultExtensions","defaultPackageMain","cdnStrategy","memoryStrategy","Math","entrypointUri","compoundStrategy","strategies","extensions","packageMain","graphBuilder","output","chunk","injectRuntime","injectedModuleSpecs","optionsExternal","isExternal","codeWithStart","runtimeCode","runtimeFn","Function","velcro","EMPTY_ELEMENTS","conf","wordPattern","comments","blockComment","brackets","autoClosingPairs","open","close","surroundingPairs","onEnterRules","beforeText","RegExp","afterText","action","indentAction","Monaco","IndentAction","IndentOutdent","Indent","language","defaultToken","tokenPostfix","ignoreCase","tokenizer","next","doctype","comment","otherTag","script","nextEmbedded","scriptAfterType","scriptAfterTypeEquals","switchTo","scriptWithCustomType","scriptEmbedded","style","styleAfterType","styleAfterTypeEquals","styleWithCustomType","styleEmbedded","readUrl","fetch","then","arrayBuffer","EditorManager","disposableStore","initialPath","viewState","WeakMap","onWillFocusModelEmitter","onDidChangeEmitter","typescript","typescriptDefaults","setEagerModelSync","setMaximumWorkerIdleTime","setCompilerOptions","allowJs","allowNonTsExtensions","allowSyntheticDefaultImports","baseUrl","checkJs","esModuleInterop","experimentalDecorators","inlineSourceMap","inlineSources","isolatedModules","jsx","JsxEmit","React","lib","ModuleKind","CommonJS","moduleResolution","ModuleResolutionKind","NodeJs","noEmit","outDir","resolveJsonModule","target","ScriptTarget","ES2015","typeRoots","setDiagnosticsOptions","noSemanticValidation","noSyntaxValidation","register","mimetypes","setLanguageConfiguration","SvelteLanguage","setMonarchTokensProvider","createPrettierFormattingProvider","prettierPromise","loadPrettier","execute","prettier","svelte","injectModules","prettierPluginSvelte","catch","provideDocumentFormattingEdits","isCancellationRequested","formatted","filepath","fsPath","singleQuote","tabWidth","getFullModelRange","codeFormattingEditProvider","registerDocumentFormattingEditProvider","createModel","inferLanguage","getModel","getModelByHref","focusModel","setModel","lineNumber","revealLineInCenter","ScrollType","Smooth","setPosition","columnNumber","markers","setModelMarkers","focus","getModelByPath","_","el","create","automaticLayout","minimap","enabled","showUnused","scrollBeyondLastLine","theme","wordWrap","wrappingIndent","onDidDispose","onDidChangeModel","newModelUrl","restoreViewState","onDidBlurEditorText","saveViewState","focusPath","EditorManagerContext","createContext","Editor","className","useRef","editorManager","useContext","useEffect","current","mount","ref","EntryKind","PreviewProgress","props","total","round","PreviewIframeWrap","PreviewWrap","PreviewMessageError","PreviewMessageErrorText","isInternal","PreviewMessages","PreviewMessageLine","PreviewMessage","lines","Preview","previewWrapRef","previewIframeRef","useState","buildState","setBuildState","buildProgress","setBuildProgress","onMessage","contentWindow","Uri","window","removeEventListener","monacoIntegration","onStateChange","debug","Date","now","iframe","document","createElement","display","src","appendChild","onLoad","remove","once","Entry","modelFocused","color","cursor","backgroundColor","CreateEntry","SidebarFileDelete","Button","StyledTooltip","SidebarFile","activeModel","workbench","setActiveModel","disposable","trackEditor","onDidFocusEditorText","hasTextFocus","onDidCreateEditor","useActiveModel","tooltip","useTooltipState","gutter","onClick","slice","TooltipReference","as","role","aria-label","Tooltip","Sidebar","replace","sortEntries","models","sort","initialEntries","reduce","modelUri","startsWith","nestedPath","nextDirIdx","indexOf","Directory","File","setEntries","find","onWillDisposeModel","findIndex","splice","useDirectory","prompt","onClickCreate","PlaygroundCmp","project","Provider","Playground","stringify","trim","ServiceWorkerContext","ServiceWorkerProvider","waitingServiceWorker","assetsUpdateReady","assetsCached","useMemo","updateAssets","reload","PlaygroundWrapper","StatusBarItem","StatusBarStyles","AppWrapper","Title","Subtitle","Link","Links","Header","globalCss","css","App","CssBaseline","styles","rel","Boolean","hostname","navigator","serviceWorker","ready","registration","unregister","ReactDOM","render","getElementById","SPEC_RX","bareModuleSpec","nameSpec","ResolverStrategy","NODE_CORE_SHIMS","string_decoder","parseBareModuleSpec","punycode","settings","CACHE","Symbol","Visits","cmp","mapResultWithVisits","encodedOperation","encodePathNode","operationName","includes","formattedPath","decodePathNode","_wrapError","ResolverContext","cache","cacheInvalidations","concat","method","receiver","runInChildContext","invalidations","invalidated","operationCache","runWithCache","runInContext","resetPath","resetVisits","forOperation","contextFn","mappedResult","cacheEntries","cacheKey","cacheResult","createStoreResultFn","promiseRet","wrappedRet","args","repeat","parts","bothResolved","resolveRootResult","rootUriWithoutTrailingSlash","canonicalizationResult","resolveAsDirectory","settingsResult","resolveAsFile","readParentPackageJsonReturn","resolveAndPackageJson","parentPackageJson","readParentPackageJsonResult","parsedSpec","resolveBareModule","relativeUri","locatorName","locatorSpec","locatorPath","resolveRootReturn","nextUri","maxIterations","parentPackageJsonReturn","parentPackageJsonResult","directoryUri","builtIn","bareModuleUriReturn","bareModuleUriResult","listEntriesReturn","listEntriesResult","mainPathname","packageJsonUri","packageJsonEntry","packageJsonContentReturn","packageJsonContentResult","fileUri","ignoreBrowserOverrides","TypeError","browserOverrides","readParentPackageJsonInternal","uriIsCanonicalized","browserMap","packageJsonDir","impliedUri","targetSpec","containingDirUri","entriesReturn","entriesResult","entryDirectoryMap","entryFileMap","childFilename","hrefWithExtensionUri","hrefWithExtension","mapping","canonicalizationReturn","visitedDirs","hostRootHref","containingDirUrl","readPackageJsonOrRecurse","parentPackageJsonContentReturn","parentPackageJsonContentResult","parentDir","VisitKind","disposed","buf","rootCtx","runInIsolatedContext"],"mappings":"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","file":"static/js/main.b7da32f2.chunk.js","sourcesContent":["type Buffer = {\n  from(\n    buf: BufferSource | string,\n    encoding?: 'base64'\n  ): {\n    toString(encoding: 'base64' | 'utf-8'): string;\n  };\n};\n\nexport namespace Base64 {\n  export const decode =\n    typeof global === 'object' && typeof global['Buffer'] === 'function'\n      ? (data: string) => (global['Buffer'] as Buffer).from(data, 'base64').toString('utf-8')\n      : typeof atob === 'function'\n      ? (data: string) => decodeURIComponent(escape(atob(data)))\n      : (_data: string) => {\n          throw new Error(\n            'The environment has neither the Buffer nor btoa functions. Please consider polyfilling one of these apis.'\n          );\n        };\n\n  export const encode =\n    typeof global === 'object' && typeof global['Buffer'] === 'function'\n      ? (data: string) => (global['Buffer'] as Buffer).from(data).toString('base64')\n      : typeof btoa === 'function'\n      ? (data: string) => btoa(unescape(encodeURIComponent(data)))\n      : (_data: string) => {\n          throw new Error(\n            'The environment has neither the Buffer nor btoa functions. Please consider polyfilling one of these apis.'\n          );\n        };\n}\n","import type { Uri } from './uri';\n\nabstract class BaseError extends Error {\n  readonly name = this.constructor.name;\n}\n\nexport class AmbiguousModuleError extends BaseError {}\n\nexport class CanceledError extends BaseError {}\n\nexport class EntryExcludedError extends BaseError {\n  constructor(uri: { toString(): string }) {\n    super(`Entry was excluded by current configuration '${uri.toString()}'`);\n  }\n}\n\nexport class EntryNotFoundError extends BaseError {\n  constructor(uri: { toString(): string }) {\n    super(`Unable to resolve '${uri.toString()}'`);\n  }\n}\n\nexport class DependencyNotFoundError extends EntryNotFoundError {\n  constructor(spec: string, parentUri: { toString(): string }) {\n    super(`The dependency '${spec}' of '${parentUri.toString()}' was not found`);\n  }\n}\n\nexport class NotResolvableError extends BaseError {}\n\nexport class ParseError extends BaseError {\n  constructor(readonly uri: Uri, message: string) {\n    super(`Parsing failed for '${uri.toString()}': ${message}`);\n  }\n}\n\nexport function isCanceledError(err: unknown): err is CanceledError {\n  return err instanceof CanceledError || (err && (err as any).name === 'CanceledError');\n}\n","import type { CancellationToken } from 'ts-primitives';\nimport { CanceledError } from './error';\n\nexport type Awaited<T> = T extends Thenable<infer U> ? U : T;\n\nexport interface Thenable<T> {\n  /**\n   * Attaches callbacks for the resolution and/or rejection of the Promise.\n   * @param onfulfilled The callback to execute when the Promise is resolved.\n   * @param onrejected The callback to execute when the Promise is rejected.\n   * @returns A Promise for the completion of which ever callback is executed.\n   */\n  then<TResult>(\n    onfulfilled?: (value: T) => TResult | Thenable<TResult>,\n    onrejected?: (reason: any) => TResult | Thenable<TResult>\n  ): Thenable<TResult>;\n  then<TResult>(\n    onfulfilled?: (value: T) => TResult | Thenable<TResult>,\n    onrejected?: (reason: any) => void\n  ): Thenable<TResult>;\n}\n\n// See: https://github.com/microsoft/TypeScript/pull/26063#issuecomment-461576933\nexport function all<T extends [unknown] | unknown[]>(values: T, token: CancellationToken) {\n  let shouldAwait = false;\n\n  const result = values.map((element) => {\n    if (isThenable(element)) {\n      shouldAwait = true;\n\n      return checkCancellation(element, token);\n    }\n\n    return element;\n  }) as T;\n\n  if (shouldAwait) {\n    return (Promise.all(result) as unknown) as Promise<{ [P in keyof T]: Awaited<T[P]> }>;\n  }\n\n  return values as { [P in keyof T]: Awaited<T[P]> };\n}\n\nexport async function checkCancellation<T>(promise: Thenable<T>, token: CancellationToken) {\n  try {\n    const result = await promise;\n    if (token.isCancellationRequested) {\n      return Promise.reject(new CanceledError());\n    }\n\n    return result;\n  } catch (err) {\n    if (token.isCancellationRequested) {\n      return Promise.reject(new CanceledError());\n    }\n\n    throw err;\n  }\n}\n\nexport function isThenable<T = unknown>(object: unknown): object is Thenable<T> {\n  return (\n    object &&\n    // Detection of 'normal' thenable\n    (typeof (object as any).then === 'function' ||\n      // Detection for regenerator runtime state\n      (typeof (object as any).done === 'boolean' &&\n        typeof (object as any).next === 'number' &&\n        typeof (object as any).pre === 'number'))\n  );\n}\n","export class Decoder {\n  private readonly decoder: TextDecoder | undefined;\n\n  constructor() {\n    if (typeof TextDecoder !== 'undefined') {\n      this.decoder = new TextDecoder();\n    } else if (typeof Buffer !== 'function' || typeof Buffer['from'] !== 'function') {\n      throw new Error(\n        'The environment supports neither the TextDecoder nor Buffer API. Please consider polyfilling one of these.'\n      );\n    }\n  }\n\n  decode(buf: BufferSource): string {\n    const str = this.decoder\n      ? this.decoder.decode(buf)\n      : (Buffer as any).from(buf).toString('utf-8');\n\n    return str.charCodeAt(0) === 0xfeff ? str.slice(1) : str;\n  }\n}\n","export class MapSet<K, V> {\n  private readonly _data = new Map<K, Set<V>>();\n\n  get size() {\n    return this._data.size;\n  }\n\n  add(key: K, value: V) {\n    let values = this._data.get(key);\n\n    if (!values) {\n      values = new Set();\n      this._data.set(key, values);\n    }\n\n    values.add(value);\n\n    return this;\n  }\n\n  clear() {\n    this._data.clear();\n  }\n\n  delete(key: K, value: V) {\n    const values = this._data.get(key);\n\n    if (values) {\n      const ret = values.delete(value);\n\n      if (!values.size) {\n        this._data.delete(key);\n      }\n\n      return ret;\n    }\n\n    return false;\n  }\n\n  deleteAll(key: K) {\n    return this._data.delete(key);\n  }\n\n  get(key: K) {\n    return this._data.get(key);\n  }\n\n  has(key: K) {\n    return this._data.has(key);\n  }\n\n  hasValue(key: K, value: V) {\n    const values = this._data.get(key);\n\n    return values ? values.has(value) : false;\n  }\n\n  *entries(): IterableIterator<[K, V]> {\n    for (const [key, values] of this._data.entries()) {\n      for (const value of values) {\n        yield [key, value];\n      }\n    }\n  }\n\n  *values(): IterableIterator<V> {\n    for (const values of this._data.values()) {\n      yield* values.values();\n    }\n  }\n}\n","import type { Decoder } from './decoder';\n\nexport type PackageMainField = 'browser' | 'module' | 'jsnext:main' | 'main' | 'unpkg';\n\nexport interface PartialPackageJson {\n  name?: string;\n  version?: string;\n  browser?: string | { [key: string]: false | string };\n  main?: string;\n  module?: string;\n  'jsnext:main'?: string;\n  dependencies?: { [key: string]: string };\n  devDependencies?: { [key: string]: string };\n  peerDependencies?: { [key: string]: string };\n  unpkg?: string;\n}\nexport interface PackageJson extends PartialPackageJson {\n  name: string;\n  version: string;\n}\n\nexport function isValidPartialPackageJson(json: unknown): json is PartialPackageJson {\n  return (\n    typeof json === 'object' &&\n    json !== null &&\n    !hasInvalidOptionalStringField(json as any, 'name') &&\n    !hasInvalidOptionalStringField(json as any, 'version') &&\n    !hasInvalidBrowserField(json as any) &&\n    !hasInvalidOptionalStringField(json as any, 'main') &&\n    !hasInvalidOptionalStringField(json as any, 'module') &&\n    !hasInvalidOptionalStringField(json as any, 'jsnext:main') &&\n    !hasInvalidOptionalStringField(json as any, 'unpkg') &&\n    !hasInvalidDependenciesField(json as any, 'dependencies') &&\n    !hasInvalidDependenciesField(json as any, 'devDependencies') &&\n    !hasInvalidDependenciesField(json as any, 'peerDependencies')\n  );\n}\n\nexport function isValidPackageJson(json: unknown): json is PackageJson {\n  return (\n    typeof json === 'object' &&\n    json !== null &&\n    !hasInvalidRequiredStringField(json as any, 'name') &&\n    !hasInvalidRequiredStringField(json as any, 'version') &&\n    !hasInvalidBrowserField(json as any) &&\n    !hasInvalidOptionalStringField(json as any, 'main') &&\n    !hasInvalidOptionalStringField(json as any, 'module') &&\n    !hasInvalidOptionalStringField(json as any, 'jsnext:main') &&\n    !hasInvalidOptionalStringField(json as any, 'unpkg') &&\n    !hasInvalidDependenciesField(json as any, 'dependencies') &&\n    !hasInvalidDependenciesField(json as any, 'devDependencies') &&\n    !hasInvalidDependenciesField(json as any, 'peerDependencies')\n  );\n}\n\nfunction hasInvalidBrowserField(json: any) {\n  let error = '';\n\n  const browser = json.browser;\n  if (browser) {\n    if (typeof browser === 'object') {\n      for (const key in browser) {\n        if (typeof key !== 'string') {\n          error = `The key ${key} of .browser must be a string`;\n          break;\n        }\n        if (typeof browser[key] !== 'string' && browser[key] !== false) {\n          error = `The value ${key} of .browser must be a string or false`;\n          break;\n        }\n      }\n    }\n  }\n\n  return error;\n}\n\nfunction hasInvalidRequiredStringField(json: any, field: string) {\n  return typeof json[field] !== 'string';\n}\n\nfunction hasInvalidOptionalStringField(json: any, field: string) {\n  return json[field] !== undefined && typeof json[field] !== 'string';\n}\n\nfunction hasInvalidDependenciesField(json: any, field: string) {\n  return (\n    json[field] !== undefined &&\n    typeof json[field] === 'object' &&\n    json[field] !== null &&\n    !Object.keys(json[field]).every(\n      (key) => typeof key === 'string' && typeof json[field][key] === 'string'\n    )\n  );\n}\n\nexport function parseBufferAsPartialPackageJson(\n  decoder: Decoder,\n  content: ArrayBuffer,\n  spec: string\n): PartialPackageJson {\n  try {\n    const text = decoder.decode(content);\n\n    return parseTextAsPartialPackageJson(text, spec);\n  } catch (err) {\n    throw new Error(`Error decoding manifest buffer for package ${spec}: ${err.message}`);\n  }\n}\n\nexport function parseBufferAsPackageJson(\n  decoder: Decoder,\n  content: ArrayBuffer,\n  spec: string\n): PackageJson {\n  try {\n    const text = decoder.decode(content);\n\n    return parseTextAsPackageJson(text, spec);\n  } catch (err) {\n    throw new Error(`Error decoding manifest buffer for package ${spec}: ${err.message}`);\n  }\n}\n\nfunction parseTextAsPartialPackageJson(text: string, spec: string): PartialPackageJson {\n  let json: unknown;\n\n  try {\n    json = JSON.parse(text);\n  } catch (err) {\n    throw new Error(`Error parsing manifest as json for package ${spec}: ${err.message}`);\n  }\n\n  if (!isValidPartialPackageJson(json)) {\n    throw new Error(`Invalid manifest for the package ${spec}`);\n  }\n\n  return json;\n}\n\nfunction parseTextAsPackageJson(text: string, spec: string): PackageJson {\n  const json = parseTextAsPartialPackageJson(text, spec);\n\n  if (!isValidPackageJson(json)) {\n    throw new Error(`Invalid manifest for the package ${spec}`);\n  }\n\n  return json;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n// NOTE: VSCode's copy of nodejs path library to be usable in common (non-node) namespace\n// Copied from: https://github.com/nodejs/node/blob/v12.8.1/lib/path.js\n\n/**\n * Copyright Joyent, Inc. and other Node contributors.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to permit\n * persons to whom the Software is furnished to do so, subject to the\n * following conditions:\n *\n * The above copyright notice and this permission notice shall be included\n * in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n * NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n * USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\nconst CHAR_DOT = 46; /* . */\nconst CHAR_FORWARD_SLASH = 47; /* / */\n\nclass ErrorInvalidArgType extends Error {\n  code: 'ERR_INVALID_ARG_TYPE';\n  constructor(name: string, expected: string, actual: any) {\n    // determiner: 'must be' or 'must not be'\n    let determiner;\n    if (typeof expected === 'string' && expected.indexOf('not ') === 0) {\n      determiner = 'must not be';\n      expected = expected.replace(/^not /, '');\n    } else {\n      determiner = 'must be';\n    }\n\n    const type = name.indexOf('.') !== -1 ? 'property' : 'argument';\n    let msg = `The \"${name}\" ${type} ${determiner} of type ${expected}`;\n\n    msg += `. Received type ${typeof actual}`;\n    super(msg);\n\n    this.code = 'ERR_INVALID_ARG_TYPE';\n  }\n}\n\nfunction validateString(value: string, name: string) {\n  if (typeof value !== 'string') {\n    throw new ErrorInvalidArgType(name, 'string', value);\n  }\n}\n\nfunction isPosixPathSeparator(code: number | undefined) {\n  return code === CHAR_FORWARD_SLASH;\n}\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeString(\n  path: string,\n  allowAboveRoot: boolean,\n  separator: string,\n  isPathSeparator: (code?: number) => boolean\n) {\n  let res = '';\n  let lastSegmentLength = 0;\n  let lastSlash = -1;\n  let dots = 0;\n  let code = 0;\n  for (let i = 0; i <= path.length; ++i) {\n    if (i < path.length) {\n      code = path.charCodeAt(i);\n    } else if (isPathSeparator(code)) {\n      break;\n    } else {\n      code = CHAR_FORWARD_SLASH;\n    }\n\n    if (isPathSeparator(code)) {\n      if (lastSlash === i - 1 || dots === 1) {\n        // NOOP\n      } else if (dots === 2) {\n        if (\n          res.length < 2 ||\n          lastSegmentLength !== 2 ||\n          res.charCodeAt(res.length - 1) !== CHAR_DOT ||\n          res.charCodeAt(res.length - 2) !== CHAR_DOT\n        ) {\n          if (res.length > 2) {\n            const lastSlashIndex = res.lastIndexOf(separator);\n            if (lastSlashIndex === -1) {\n              res = '';\n              lastSegmentLength = 0;\n            } else {\n              res = res.slice(0, lastSlashIndex);\n              lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);\n            }\n            lastSlash = i;\n            dots = 0;\n            continue;\n          } else if (res.length !== 0) {\n            res = '';\n            lastSegmentLength = 0;\n            lastSlash = i;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          res += res.length > 0 ? `${separator}..` : '..';\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (res.length > 0) {\n          res += `${separator}${path.slice(lastSlash + 1, i)}`;\n        } else {\n          res = path.slice(lastSlash + 1, i);\n        }\n        lastSegmentLength = i - lastSlash - 1;\n      }\n      lastSlash = i;\n      dots = 0;\n    } else if (code === CHAR_DOT && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\n\nfunction _format(sep: string, pathObject: ParsedPath) {\n  if (pathObject === null || typeof pathObject !== 'object') {\n    throw new ErrorInvalidArgType('pathObject', 'Object', pathObject);\n  }\n  const dir = pathObject.dir || pathObject.root;\n  const base = pathObject.base || `${pathObject.name || ''}${pathObject.ext || ''}`;\n  if (!dir) {\n    return base;\n  }\n  return dir === pathObject.root ? `${dir}${base}` : `${dir}${sep}${base}`;\n}\n\nexport interface ParsedPath {\n  root: string;\n  dir: string;\n  base: string;\n  ext: string;\n  name: string;\n}\n\nexport interface IPath {\n  normalize(path: string): string;\n  isAbsolute(path: string): boolean;\n  join(...paths: string[]): string;\n  resolve(...pathSegments: string[]): string;\n  relative(from: string, to: string): string;\n  dirname(path: string): string;\n  basename(path: string, ext?: string): string;\n  extname(path: string): string;\n  format(pathObject: ParsedPath): string;\n  parse(path: string): ParsedPath;\n  toNamespacedPath(path: string): string;\n  sep: '\\\\' | '/';\n  delimiter: string;\n  win32: IPath | null;\n  posix: IPath | null;\n}\n\n// export const win32: IPath = {\n// \t// path.resolve([from ...], to)\n// \tresolve(...pathSegments: string[]): string {\n// \t\tlet resolvedDevice = '';\n// \t\tlet resolvedTail = '';\n// \t\tlet resolvedAbsolute = false;\n\n// \t\tfor (let i = pathSegments.length - 1; i >= -1; i--) {\n// \t\t\tlet path;\n// \t\t\tif (i >= 0) {\n// \t\t\t\tpath = pathSegments[i];\n// \t\t\t\tvalidateString(path, 'path');\n\n// \t\t\t\t// Skip empty entries\n// \t\t\t\tif (path.length === 0) {\n// \t\t\t\t\tcontinue;\n// \t\t\t\t}\n// \t\t\t} else if (resolvedDevice.length === 0) {\n// \t\t\t\tpath = process.cwd();\n// \t\t\t} else {\n// \t\t\t\t// Windows has the concept of drive-specific current working\n// \t\t\t\t// directories. If we've resolved a drive letter but not yet an\n// \t\t\t\t// absolute path, get cwd for that drive, or the process cwd if\n// \t\t\t\t// the drive cwd is not available. We're sure the device is not\n// \t\t\t\t// a UNC path at this points, because UNC paths are always absolute.\n// \t\t\t\tpath = (process.env as any)[`=${resolvedDevice}`] || process.cwd();\n\n// \t\t\t\t// Verify that a cwd was found and that it actually points\n// \t\t\t\t// to our drive. If not, default to the drive's root.\n// \t\t\t\tif (path === undefined ||\n// \t\t\t\t\tpath.slice(0, 2).toLowerCase() !== resolvedDevice.toLowerCase() &&\n// \t\t\t\t\tpath.charCodeAt(2) === CHAR_BACKWARD_SLASH) {\n// \t\t\t\t\tpath = `${resolvedDevice}\\\\`;\n// \t\t\t\t}\n// \t\t\t}\n\n// \t\t\tconst len = path.length;\n// \t\t\tlet rootEnd = 0;\n// \t\t\tlet device = '';\n// \t\t\tlet isAbsolute = false;\n// \t\t\tconst code = path.charCodeAt(0);\n\n// \t\t\t// Try to match a root\n// \t\t\tif (len === 1) {\n// \t\t\t\tif (isPathSeparator(code)) {\n// \t\t\t\t\t// `path` contains just a path separator\n// \t\t\t\t\trootEnd = 1;\n// \t\t\t\t\tisAbsolute = true;\n// \t\t\t\t}\n// \t\t\t} else if (isPathSeparator(code)) {\n// \t\t\t\t// Possible UNC root\n\n// \t\t\t\t// If we started with a separator, we know we at least have an\n// \t\t\t\t// absolute path of some kind (UNC or otherwise)\n// \t\t\t\tisAbsolute = true;\n\n// \t\t\t\tif (isPathSeparator(path.charCodeAt(1))) {\n// \t\t\t\t\t// Matched double path separator at beginning\n// \t\t\t\t\tlet j = 2;\n// \t\t\t\t\tlet last = j;\n// \t\t\t\t\t// Match 1 or more non-path separators\n// \t\t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n// \t\t\t\t\t\tj++;\n// \t\t\t\t\t}\n// \t\t\t\t\tif (j < len && j !== last) {\n// \t\t\t\t\t\tconst firstPart = path.slice(last, j);\n// \t\t\t\t\t\t// Matched!\n// \t\t\t\t\t\tlast = j;\n// \t\t\t\t\t\t// Match 1 or more path separators\n// \t\t\t\t\t\twhile (j < len && isPathSeparator(path.charCodeAt(j))) {\n// \t\t\t\t\t\t\tj++;\n// \t\t\t\t\t\t}\n// \t\t\t\t\t\tif (j < len && j !== last) {\n// \t\t\t\t\t\t\t// Matched!\n// \t\t\t\t\t\t\tlast = j;\n// \t\t\t\t\t\t\t// Match 1 or more non-path separators\n// \t\t\t\t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n// \t\t\t\t\t\t\t\tj++;\n// \t\t\t\t\t\t\t}\n// \t\t\t\t\t\t\tif (j === len || j !== last) {\n// \t\t\t\t\t\t\t\t// We matched a UNC root\n// \t\t\t\t\t\t\t\tdevice = `\\\\\\\\${firstPart}\\\\${path.slice(last, j)}`;\n// \t\t\t\t\t\t\t\trootEnd = j;\n// \t\t\t\t\t\t\t}\n// \t\t\t\t\t\t}\n// \t\t\t\t\t}\n// \t\t\t\t} else {\n// \t\t\t\t\trootEnd = 1;\n// \t\t\t\t}\n// \t\t\t} else if (isWindowsDeviceRoot(code) &&\n// \t\t\t\tpath.charCodeAt(1) === CHAR_COLON) {\n// \t\t\t\t// Possible device root\n// \t\t\t\tdevice = path.slice(0, 2);\n// \t\t\t\trootEnd = 2;\n// \t\t\t\tif (len > 2 && isPathSeparator(path.charCodeAt(2))) {\n// \t\t\t\t\t// Treat separator following drive name as an absolute path\n// \t\t\t\t\t// indicator\n// \t\t\t\t\tisAbsolute = true;\n// \t\t\t\t\trootEnd = 3;\n// \t\t\t\t}\n// \t\t\t}\n\n// \t\t\tif (device.length > 0) {\n// \t\t\t\tif (resolvedDevice.length > 0) {\n// \t\t\t\t\tif (device.toLowerCase() !== resolvedDevice.toLowerCase()) {\n// \t\t\t\t\t\t// This path points to another device so it is not applicable\n// \t\t\t\t\t\tcontinue;\n// \t\t\t\t\t}\n// \t\t\t\t} else {\n// \t\t\t\t\tresolvedDevice = device;\n// \t\t\t\t}\n// \t\t\t}\n\n// \t\t\tif (resolvedAbsolute) {\n// \t\t\t\tif (resolvedDevice.length > 0) {\n// \t\t\t\t\tbreak;\n// \t\t\t\t}\n// \t\t\t} else {\n// \t\t\t\tresolvedTail = `${path.slice(rootEnd)}\\\\${resolvedTail}`;\n// \t\t\t\tresolvedAbsolute = isAbsolute;\n// \t\t\t\tif (isAbsolute && resolvedDevice.length > 0) {\n// \t\t\t\t\tbreak;\n// \t\t\t\t}\n// \t\t\t}\n// \t\t}\n\n// \t\t// At this point the path should be resolved to a full absolute path,\n// \t\t// but handle relative paths to be safe (might happen when process.cwd()\n// \t\t// fails)\n\n// \t\t// Normalize the tail path\n// \t\tresolvedTail = normalizeString(resolvedTail, !resolvedAbsolute, '\\\\',\n// \t\t\tisPathSeparator);\n\n// \t\treturn resolvedAbsolute ?\n// \t\t\t`${resolvedDevice}\\\\${resolvedTail}` :\n// \t\t\t`${resolvedDevice}${resolvedTail}` || '.';\n// \t},\n\n// \tnormalize(path: string): string {\n// \t\tvalidateString(path, 'path');\n// \t\tconst len = path.length;\n// \t\tif (len === 0) {\n// \t\t\treturn '.';\n// \t\t}\n// \t\tlet rootEnd = 0;\n// \t\tlet device;\n// \t\tlet isAbsolute = false;\n// \t\tconst code = path.charCodeAt(0);\n\n// \t\t// Try to match a root\n// \t\tif (len === 1) {\n// \t\t\t// `path` contains just a single char, exit early to avoid\n// \t\t\t// unnecessary work\n// \t\t\treturn isPosixPathSeparator(code) ? '\\\\' : path;\n// \t\t}\n// \t\tif (isPathSeparator(code)) {\n// \t\t\t// Possible UNC root\n\n// \t\t\t// If we started with a separator, we know we at least have an absolute\n// \t\t\t// path of some kind (UNC or otherwise)\n// \t\t\tisAbsolute = true;\n\n// \t\t\tif (isPathSeparator(path.charCodeAt(1))) {\n// \t\t\t\t// Matched double path separator at beginning\n// \t\t\t\tlet j = 2;\n// \t\t\t\tlet last = j;\n// \t\t\t\t// Match 1 or more non-path separators\n// \t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n// \t\t\t\t\tj++;\n// \t\t\t\t}\n// \t\t\t\tif (j < len && j !== last) {\n// \t\t\t\t\tconst firstPart = path.slice(last, j);\n// \t\t\t\t\t// Matched!\n// \t\t\t\t\tlast = j;\n// \t\t\t\t\t// Match 1 or more path separators\n// \t\t\t\t\twhile (j < len && isPathSeparator(path.charCodeAt(j))) {\n// \t\t\t\t\t\tj++;\n// \t\t\t\t\t}\n// \t\t\t\t\tif (j < len && j !== last) {\n// \t\t\t\t\t\t// Matched!\n// \t\t\t\t\t\tlast = j;\n// \t\t\t\t\t\t// Match 1 or more non-path separators\n// \t\t\t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n// \t\t\t\t\t\t\tj++;\n// \t\t\t\t\t\t}\n// \t\t\t\t\t\tif (j === len) {\n// \t\t\t\t\t\t\t// We matched a UNC root only\n// \t\t\t\t\t\t\t// Return the normalized version of the UNC root since there\n// \t\t\t\t\t\t\t// is nothing left to process\n// \t\t\t\t\t\t\treturn `\\\\\\\\${firstPart}\\\\${path.slice(last)}\\\\`;\n// \t\t\t\t\t\t}\n// \t\t\t\t\t\tif (j !== last) {\n// \t\t\t\t\t\t\t// We matched a UNC root with leftovers\n// \t\t\t\t\t\t\tdevice = `\\\\\\\\${firstPart}\\\\${path.slice(last, j)}`;\n// \t\t\t\t\t\t\trootEnd = j;\n// \t\t\t\t\t\t}\n// \t\t\t\t\t}\n// \t\t\t\t}\n// \t\t\t} else {\n// \t\t\t\trootEnd = 1;\n// \t\t\t}\n// \t\t} else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {\n// \t\t\t// Possible device root\n// \t\t\tdevice = path.slice(0, 2);\n// \t\t\trootEnd = 2;\n// \t\t\tif (len > 2 && isPathSeparator(path.charCodeAt(2))) {\n// \t\t\t\t// Treat separator following drive name as an absolute path\n// \t\t\t\t// indicator\n// \t\t\t\tisAbsolute = true;\n// \t\t\t\trootEnd = 3;\n// \t\t\t}\n// \t\t}\n\n// \t\tlet tail = rootEnd < len ?\n// \t\t\tnormalizeString(path.slice(rootEnd), !isAbsolute, '\\\\', isPathSeparator) :\n// \t\t\t'';\n// \t\tif (tail.length === 0 && !isAbsolute) {\n// \t\t\ttail = '.';\n// \t\t}\n// \t\tif (tail.length > 0 && isPathSeparator(path.charCodeAt(len - 1))) {\n// \t\t\ttail += '\\\\';\n// \t\t}\n// \t\tif (device === undefined) {\n// \t\t\treturn isAbsolute ? `\\\\${tail}` : tail;\n// \t\t}\n// \t\treturn isAbsolute ? `${device}\\\\${tail}` : `${device}${tail}`;\n// \t},\n\n// \tisAbsolute(path: string): boolean {\n// \t\tvalidateString(path, 'path');\n// \t\tconst len = path.length;\n// \t\tif (len === 0) {\n// \t\t\treturn false;\n// \t\t}\n\n// \t\tconst code = path.charCodeAt(0);\n// \t\treturn isPathSeparator(code) ||\n// \t\t\t// Possible device root\n// \t\t\tlen > 2 &&\n// \t\t\tisWindowsDeviceRoot(code) &&\n// \t\t\tpath.charCodeAt(1) === CHAR_COLON &&\n// \t\t\tisPathSeparator(path.charCodeAt(2));\n// \t},\n\n// \tjoin(...paths: string[]): string {\n// \t\tif (paths.length === 0) {\n// \t\t\treturn '.';\n// \t\t}\n\n// \t\tlet joined;\n// \t\tlet firstPart: string | undefined;\n// \t\tfor (let i = 0; i < paths.length; ++i) {\n// \t\t\tconst arg = paths[i];\n// \t\t\tvalidateString(arg, 'path');\n// \t\t\tif (arg.length > 0) {\n// \t\t\t\tif (joined === undefined) {\n// \t\t\t\t\tjoined = firstPart = arg;\n// \t\t\t\t}\n// \t\t\t\telse {\n// \t\t\t\t\tjoined += `\\\\${arg}`;\n// \t\t\t\t}\n// \t\t\t}\n// \t\t}\n\n// \t\tif (joined === undefined) {\n// \t\t\treturn '.';\n// \t\t}\n\n// \t\t// Make sure that the joined path doesn't start with two slashes, because\n// \t\t// normalize() will mistake it for an UNC path then.\n// \t\t//\n// \t\t// This step is skipped when it is very clear that the user actually\n// \t\t// intended to point at an UNC path. This is assumed when the first\n// \t\t// non-empty string arguments starts with exactly two slashes followed by\n// \t\t// at least one more non-slash character.\n// \t\t//\n// \t\t// Note that for normalize() to treat a path as an UNC path it needs to\n// \t\t// have at least 2 components, so we don't filter for that here.\n// \t\t// This means that the user can use join to construct UNC paths from\n// \t\t// a server name and a share name; for example:\n// \t\t//   path.join('//server', 'share') -> '\\\\\\\\server\\\\share\\\\')\n// \t\tlet needsReplace = true;\n// \t\tlet slashCount = 0;\n// \t\tif (typeof firstPart === 'string' && isPathSeparator(firstPart.charCodeAt(0))) {\n// \t\t\t++slashCount;\n// \t\t\tconst firstLen = firstPart.length;\n// \t\t\tif (firstLen > 1 && isPathSeparator(firstPart.charCodeAt(1))) {\n// \t\t\t\t++slashCount;\n// \t\t\t\tif (firstLen > 2) {\n// \t\t\t\t\tif (isPathSeparator(firstPart.charCodeAt(2))) {\n// \t\t\t\t\t\t++slashCount;\n// \t\t\t\t\t} else {\n// \t\t\t\t\t\t// We matched a UNC path in the first part\n// \t\t\t\t\t\tneedsReplace = false;\n// \t\t\t\t\t}\n// \t\t\t\t}\n// \t\t\t}\n// \t\t}\n// \t\tif (needsReplace) {\n// \t\t\t// Find any more consecutive slashes we need to replace\n// \t\t\twhile (slashCount < joined.length &&\n// \t\t\t\tisPathSeparator(joined.charCodeAt(slashCount))) {\n// \t\t\t\tslashCount++;\n// \t\t\t}\n\n// \t\t\t// Replace the slashes if needed\n// \t\t\tif (slashCount >= 2) {\n// \t\t\t\tjoined = `\\\\${joined.slice(slashCount)}`;\n// \t\t\t}\n// \t\t}\n\n// \t\treturn win32.normalize(joined);\n// \t},\n\n// \t// It will solve the relative path from `from` to `to`, for instance:\n// \t//  from = 'C:\\\\orandea\\\\test\\\\aaa'\n// \t//  to = 'C:\\\\orandea\\\\impl\\\\bbb'\n// \t// The output of the function should be: '..\\\\..\\\\impl\\\\bbb'\n// \trelative(from: string, to: string): string {\n// \t\tvalidateString(from, 'from');\n// \t\tvalidateString(to, 'to');\n\n// \t\tif (from === to) {\n// \t\t\treturn '';\n// \t\t}\n\n// \t\tconst fromOrig = win32.resolve(from);\n// \t\tconst toOrig = win32.resolve(to);\n\n// \t\tif (fromOrig === toOrig) {\n// \t\t\treturn '';\n// \t\t}\n\n// \t\tfrom = fromOrig.toLowerCase();\n// \t\tto = toOrig.toLowerCase();\n\n// \t\tif (from === to) {\n// \t\t\treturn '';\n// \t\t}\n\n// \t\t// Trim any leading backslashes\n// \t\tlet fromStart = 0;\n// \t\twhile (fromStart < from.length &&\n// \t\t\tfrom.charCodeAt(fromStart) === CHAR_BACKWARD_SLASH) {\n// \t\t\tfromStart++;\n// \t\t}\n// \t\t// Trim trailing backslashes (applicable to UNC paths only)\n// \t\tlet fromEnd = from.length;\n// \t\twhile (fromEnd - 1 > fromStart &&\n// \t\t\tfrom.charCodeAt(fromEnd - 1) === CHAR_BACKWARD_SLASH) {\n// \t\t\tfromEnd--;\n// \t\t}\n// \t\tconst fromLen = fromEnd - fromStart;\n\n// \t\t// Trim any leading backslashes\n// \t\tlet toStart = 0;\n// \t\twhile (toStart < to.length &&\n// \t\t\tto.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {\n// \t\t\ttoStart++;\n// \t\t}\n// \t\t// Trim trailing backslashes (applicable to UNC paths only)\n// \t\tlet toEnd = to.length;\n// \t\twhile (toEnd - 1 > toStart &&\n// \t\t\tto.charCodeAt(toEnd - 1) === CHAR_BACKWARD_SLASH) {\n// \t\t\ttoEnd--;\n// \t\t}\n// \t\tconst toLen = toEnd - toStart;\n\n// \t\t// Compare paths to find the longest common path from root\n// \t\tconst length = fromLen < toLen ? fromLen : toLen;\n// \t\tlet lastCommonSep = -1;\n// \t\tlet i = 0;\n// \t\tfor (; i < length; i++) {\n// \t\t\tconst fromCode = from.charCodeAt(fromStart + i);\n// \t\t\tif (fromCode !== to.charCodeAt(toStart + i)) {\n// \t\t\t\tbreak;\n// \t\t\t} else if (fromCode === CHAR_BACKWARD_SLASH) {\n// \t\t\t\tlastCommonSep = i;\n// \t\t\t}\n// \t\t}\n\n// \t\t// We found a mismatch before the first common path separator was seen, so\n// \t\t// return the original `to`.\n// \t\tif (i !== length) {\n// \t\t\tif (lastCommonSep === -1) {\n// \t\t\t\treturn toOrig;\n// \t\t\t}\n// \t\t} else {\n// \t\t\tif (toLen > length) {\n// \t\t\t\tif (to.charCodeAt(toStart + i) === CHAR_BACKWARD_SLASH) {\n// \t\t\t\t\t// We get here if `from` is the exact base path for `to`.\n// \t\t\t\t\t// For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo\\\\bar\\\\baz'\n// \t\t\t\t\treturn toOrig.slice(toStart + i + 1);\n// \t\t\t\t}\n// \t\t\t\tif (i === 2) {\n// \t\t\t\t\t// We get here if `from` is the device root.\n// \t\t\t\t\t// For example: from='C:\\\\'; to='C:\\\\foo'\n// \t\t\t\t\treturn toOrig.slice(toStart + i);\n// \t\t\t\t}\n// \t\t\t}\n// \t\t\tif (fromLen > length) {\n// \t\t\t\tif (from.charCodeAt(fromStart + i) === CHAR_BACKWARD_SLASH) {\n// \t\t\t\t\t// We get here if `to` is the exact base path for `from`.\n// \t\t\t\t\t// For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo'\n// \t\t\t\t\tlastCommonSep = i;\n// \t\t\t\t} else if (i === 2) {\n// \t\t\t\t\t// We get here if `to` is the device root.\n// \t\t\t\t\t// For example: from='C:\\\\foo\\\\bar'; to='C:\\\\'\n// \t\t\t\t\tlastCommonSep = 3;\n// \t\t\t\t}\n// \t\t\t}\n// \t\t\tif (lastCommonSep === -1) {\n// \t\t\t\tlastCommonSep = 0;\n// \t\t\t}\n// \t\t}\n\n// \t\tlet out = '';\n// \t\t// Generate the relative path based on the path difference between `to` and\n// \t\t// `from`\n// \t\tfor (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n// \t\t\tif (i === fromEnd || from.charCodeAt(i) === CHAR_BACKWARD_SLASH) {\n// \t\t\t\tout += out.length === 0 ? '..' : '\\\\..';\n// \t\t\t}\n// \t\t}\n\n// \t\ttoStart += lastCommonSep;\n\n// \t\t// Lastly, append the rest of the destination (`to`) path that comes after\n// \t\t// the common path parts\n// \t\tif (out.length > 0) {\n// \t\t\treturn `${out}${toOrig.slice(toStart, toEnd)}`;\n// \t\t}\n\n// \t\tif (toOrig.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {\n// \t\t\t++toStart;\n// \t\t}\n\n// \t\treturn toOrig.slice(toStart, toEnd);\n// \t},\n\n// \ttoNamespacedPath(path: string): string {\n// \t\t// Note: this will *probably* throw somewhere.\n// \t\tif (typeof path !== 'string') {\n// \t\t\treturn path;\n// \t\t}\n\n// \t\tif (path.length === 0) {\n// \t\t\treturn '';\n// \t\t}\n\n// \t\tconst resolvedPath = win32.resolve(path);\n\n// \t\tif (resolvedPath.length <= 2) {\n// \t\t\treturn path;\n// \t\t}\n\n// \t\tif (resolvedPath.charCodeAt(0) === CHAR_BACKWARD_SLASH) {\n// \t\t\t// Possible UNC root\n// \t\t\tif (resolvedPath.charCodeAt(1) === CHAR_BACKWARD_SLASH) {\n// \t\t\t\tconst code = resolvedPath.charCodeAt(2);\n// \t\t\t\tif (code !== CHAR_QUESTION_MARK && code !== CHAR_DOT) {\n// \t\t\t\t\t// Matched non-long UNC root, convert the path to a long UNC path\n// \t\t\t\t\treturn `\\\\\\\\?\\\\UNC\\\\${resolvedPath.slice(2)}`;\n// \t\t\t\t}\n// \t\t\t}\n// \t\t} else if (isWindowsDeviceRoot(resolvedPath.charCodeAt(0)) &&\n// \t\t\tresolvedPath.charCodeAt(1) === CHAR_COLON &&\n// \t\t\tresolvedPath.charCodeAt(2) === CHAR_BACKWARD_SLASH) {\n// \t\t\t// Matched device root, convert the path to a long UNC path\n// \t\t\treturn `\\\\\\\\?\\\\${resolvedPath}`;\n// \t\t}\n\n// \t\treturn path;\n// \t},\n\n// \tdirname(path: string): string {\n// \t\tvalidateString(path, 'path');\n// \t\tconst len = path.length;\n// \t\tif (len === 0) {\n// \t\t\treturn '.';\n// \t\t}\n// \t\tlet rootEnd = -1;\n// \t\tlet offset = 0;\n// \t\tconst code = path.charCodeAt(0);\n\n// \t\tif (len === 1) {\n// \t\t\t// `path` contains just a path separator, exit early to avoid\n// \t\t\t// unnecessary work or a dot.\n// \t\t\treturn isPathSeparator(code) ? path : '.';\n// \t\t}\n\n// \t\t// Try to match a root\n// \t\tif (isPathSeparator(code)) {\n// \t\t\t// Possible UNC root\n\n// \t\t\trootEnd = offset = 1;\n\n// \t\t\tif (isPathSeparator(path.charCodeAt(1))) {\n// \t\t\t\t// Matched double path separator at beginning\n// \t\t\t\tlet j = 2;\n// \t\t\t\tlet last = j;\n// \t\t\t\t// Match 1 or more non-path separators\n// \t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n// \t\t\t\t\tj++;\n// \t\t\t\t}\n// \t\t\t\tif (j < len && j !== last) {\n// \t\t\t\t\t// Matched!\n// \t\t\t\t\tlast = j;\n// \t\t\t\t\t// Match 1 or more path separators\n// \t\t\t\t\twhile (j < len && isPathSeparator(path.charCodeAt(j))) {\n// \t\t\t\t\t\tj++;\n// \t\t\t\t\t}\n// \t\t\t\t\tif (j < len && j !== last) {\n// \t\t\t\t\t\t// Matched!\n// \t\t\t\t\t\tlast = j;\n// \t\t\t\t\t\t// Match 1 or more non-path separators\n// \t\t\t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n// \t\t\t\t\t\t\tj++;\n// \t\t\t\t\t\t}\n// \t\t\t\t\t\tif (j === len) {\n// \t\t\t\t\t\t\t// We matched a UNC root only\n// \t\t\t\t\t\t\treturn path;\n// \t\t\t\t\t\t}\n// \t\t\t\t\t\tif (j !== last) {\n// \t\t\t\t\t\t\t// We matched a UNC root with leftovers\n\n// \t\t\t\t\t\t\t// Offset by 1 to include the separator after the UNC root to\n// \t\t\t\t\t\t\t// treat it as a \"normal root\" on top of a (UNC) root\n// \t\t\t\t\t\t\trootEnd = offset = j + 1;\n// \t\t\t\t\t\t}\n// \t\t\t\t\t}\n// \t\t\t\t}\n// \t\t\t}\n// \t\t\t// Possible device root\n// \t\t} else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {\n// \t\t\trootEnd = len > 2 && isPathSeparator(path.charCodeAt(2)) ? 3 : 2;\n// \t\t\toffset = rootEnd;\n// \t\t}\n\n// \t\tlet end = -1;\n// \t\tlet matchedSlash = true;\n// \t\tfor (let i = len - 1; i >= offset; --i) {\n// \t\t\tif (isPathSeparator(path.charCodeAt(i))) {\n// \t\t\t\tif (!matchedSlash) {\n// \t\t\t\t\tend = i;\n// \t\t\t\t\tbreak;\n// \t\t\t\t}\n// \t\t\t} else {\n// \t\t\t\t// We saw the first non-path separator\n// \t\t\t\tmatchedSlash = false;\n// \t\t\t}\n// \t\t}\n\n// \t\tif (end === -1) {\n// \t\t\tif (rootEnd === -1) {\n// \t\t\t\treturn '.';\n// \t\t\t}\n\n// \t\t\tend = rootEnd;\n// \t\t}\n// \t\treturn path.slice(0, end);\n// \t},\n\n// \tbasename(path: string, ext?: string): string {\n// \t\tif (ext !== undefined) {\n// \t\t\tvalidateString(ext, 'ext');\n// \t\t}\n// \t\tvalidateString(path, 'path');\n// \t\tlet start = 0;\n// \t\tlet end = -1;\n// \t\tlet matchedSlash = true;\n// \t\tlet i;\n\n// \t\t// Check for a drive letter prefix so as not to mistake the following\n// \t\t// path separator as an extra separator at the end of the path that can be\n// \t\t// disregarded\n// \t\tif (path.length >= 2 &&\n// \t\t\tisWindowsDeviceRoot(path.charCodeAt(0)) &&\n// \t\t\tpath.charCodeAt(1) === CHAR_COLON) {\n// \t\t\tstart = 2;\n// \t\t}\n\n// \t\tif (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n// \t\t\tif (ext === path) {\n// \t\t\t\treturn '';\n// \t\t\t}\n// \t\t\tlet extIdx = ext.length - 1;\n// \t\t\tlet firstNonSlashEnd = -1;\n// \t\t\tfor (i = path.length - 1; i >= start; --i) {\n// \t\t\t\tconst code = path.charCodeAt(i);\n// \t\t\t\tif (isPathSeparator(code)) {\n// \t\t\t\t\t// If we reached a path separator that was not part of a set of path\n// \t\t\t\t\t// separators at the end of the string, stop now\n// \t\t\t\t\tif (!matchedSlash) {\n// \t\t\t\t\t\tstart = i + 1;\n// \t\t\t\t\t\tbreak;\n// \t\t\t\t\t}\n// \t\t\t\t} else {\n// \t\t\t\t\tif (firstNonSlashEnd === -1) {\n// \t\t\t\t\t\t// We saw the first non-path separator, remember this index in case\n// \t\t\t\t\t\t// we need it if the extension ends up not matching\n// \t\t\t\t\t\tmatchedSlash = false;\n// \t\t\t\t\t\tfirstNonSlashEnd = i + 1;\n// \t\t\t\t\t}\n// \t\t\t\t\tif (extIdx >= 0) {\n// \t\t\t\t\t\t// Try to match the explicit extension\n// \t\t\t\t\t\tif (code === ext.charCodeAt(extIdx)) {\n// \t\t\t\t\t\t\tif (--extIdx === -1) {\n// \t\t\t\t\t\t\t\t// We matched the extension, so mark this as the end of our path\n// \t\t\t\t\t\t\t\t// component\n// \t\t\t\t\t\t\t\tend = i;\n// \t\t\t\t\t\t\t}\n// \t\t\t\t\t\t} else {\n// \t\t\t\t\t\t\t// Extension does not match, so our result is the entire path\n// \t\t\t\t\t\t\t// component\n// \t\t\t\t\t\t\textIdx = -1;\n// \t\t\t\t\t\t\tend = firstNonSlashEnd;\n// \t\t\t\t\t\t}\n// \t\t\t\t\t}\n// \t\t\t\t}\n// \t\t\t}\n\n// \t\t\tif (start === end) {\n// \t\t\t\tend = firstNonSlashEnd;\n// \t\t\t} else if (end === -1) {\n// \t\t\t\tend = path.length;\n// \t\t\t}\n// \t\t\treturn path.slice(start, end);\n// \t\t}\n// \t\tfor (i = path.length - 1; i >= start; --i) {\n// \t\t\tif (isPathSeparator(path.charCodeAt(i))) {\n// \t\t\t\t// If we reached a path separator that was not part of a set of path\n// \t\t\t\t// separators at the end of the string, stop now\n// \t\t\t\tif (!matchedSlash) {\n// \t\t\t\t\tstart = i + 1;\n// \t\t\t\t\tbreak;\n// \t\t\t\t}\n// \t\t\t} else if (end === -1) {\n// \t\t\t\t// We saw the first non-path separator, mark this as the end of our\n// \t\t\t\t// path component\n// \t\t\t\tmatchedSlash = false;\n// \t\t\t\tend = i + 1;\n// \t\t\t}\n// \t\t}\n\n// \t\tif (end === -1) {\n// \t\t\treturn '';\n// \t\t}\n// \t\treturn path.slice(start, end);\n// \t},\n\n// \textname(path: string): string {\n// \t\tvalidateString(path, 'path');\n// \t\tlet start = 0;\n// \t\tlet startDot = -1;\n// \t\tlet startPart = 0;\n// \t\tlet end = -1;\n// \t\tlet matchedSlash = true;\n// \t\t// Track the state of characters (if any) we see before our first dot and\n// \t\t// after any path separator we find\n// \t\tlet preDotState = 0;\n\n// \t\t// Check for a drive letter prefix so as not to mistake the following\n// \t\t// path separator as an extra separator at the end of the path that can be\n// \t\t// disregarded\n\n// \t\tif (path.length >= 2 &&\n// \t\t\tpath.charCodeAt(1) === CHAR_COLON &&\n// \t\t\tisWindowsDeviceRoot(path.charCodeAt(0))) {\n// \t\t\tstart = startPart = 2;\n// \t\t}\n\n// \t\tfor (let i = path.length - 1; i >= start; --i) {\n// \t\t\tconst code = path.charCodeAt(i);\n// \t\t\tif (isPathSeparator(code)) {\n// \t\t\t\t// If we reached a path separator that was not part of a set of path\n// \t\t\t\t// separators at the end of the string, stop now\n// \t\t\t\tif (!matchedSlash) {\n// \t\t\t\t\tstartPart = i + 1;\n// \t\t\t\t\tbreak;\n// \t\t\t\t}\n// \t\t\t\tcontinue;\n// \t\t\t}\n// \t\t\tif (end === -1) {\n// \t\t\t\t// We saw the first non-path separator, mark this as the end of our\n// \t\t\t\t// extension\n// \t\t\t\tmatchedSlash = false;\n// \t\t\t\tend = i + 1;\n// \t\t\t}\n// \t\t\tif (code === CHAR_DOT) {\n// \t\t\t\t// If this is our first dot, mark it as the start of our extension\n// \t\t\t\tif (startDot === -1) {\n// \t\t\t\t\tstartDot = i;\n// \t\t\t\t}\n// \t\t\t\telse if (preDotState !== 1) {\n// \t\t\t\t\tpreDotState = 1;\n// \t\t\t\t}\n// \t\t\t} else if (startDot !== -1) {\n// \t\t\t\t// We saw a non-dot and non-path separator before our dot, so we should\n// \t\t\t\t// have a good chance at having a non-empty extension\n// \t\t\t\tpreDotState = -1;\n// \t\t\t}\n// \t\t}\n\n// \t\tif (startDot === -1 ||\n// \t\t\tend === -1 ||\n// \t\t\t// We saw a non-dot character immediately before the dot\n// \t\t\tpreDotState === 0 ||\n// \t\t\t// The (right-most) trimmed path component is exactly '..'\n// \t\t\t(preDotState === 1 &&\n// \t\t\t\tstartDot === end - 1 &&\n// \t\t\t\tstartDot === startPart + 1)) {\n// \t\t\treturn '';\n// \t\t}\n// \t\treturn path.slice(startDot, end);\n// \t},\n\n// \tformat: _format.bind(null, '\\\\'),\n\n// \tparse(path) {\n// \t\tvalidateString(path, 'path');\n\n// \t\tconst ret = { root: '', dir: '', base: '', ext: '', name: '' };\n// \t\tif (path.length === 0) {\n// \t\t\treturn ret;\n// \t\t}\n\n// \t\tconst len = path.length;\n// \t\tlet rootEnd = 0;\n// \t\tlet code = path.charCodeAt(0);\n\n// \t\tif (len === 1) {\n// \t\t\tif (isPathSeparator(code)) {\n// \t\t\t\t// `path` contains just a path separator, exit early to avoid\n// \t\t\t\t// unnecessary work\n// \t\t\t\tret.root = ret.dir = path;\n// \t\t\t\treturn ret;\n// \t\t\t}\n// \t\t\tret.base = ret.name = path;\n// \t\t\treturn ret;\n// \t\t}\n// \t\t// Try to match a root\n// \t\tif (isPathSeparator(code)) {\n// \t\t\t// Possible UNC root\n\n// \t\t\trootEnd = 1;\n// \t\t\tif (isPathSeparator(path.charCodeAt(1))) {\n// \t\t\t\t// Matched double path separator at beginning\n// \t\t\t\tlet j = 2;\n// \t\t\t\tlet last = j;\n// \t\t\t\t// Match 1 or more non-path separators\n// \t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n// \t\t\t\t\tj++;\n// \t\t\t\t}\n// \t\t\t\tif (j < len && j !== last) {\n// \t\t\t\t\t// Matched!\n// \t\t\t\t\tlast = j;\n// \t\t\t\t\t// Match 1 or more path separators\n// \t\t\t\t\twhile (j < len && isPathSeparator(path.charCodeAt(j))) {\n// \t\t\t\t\t\tj++;\n// \t\t\t\t\t}\n// \t\t\t\t\tif (j < len && j !== last) {\n// \t\t\t\t\t\t// Matched!\n// \t\t\t\t\t\tlast = j;\n// \t\t\t\t\t\t// Match 1 or more non-path separators\n// \t\t\t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n// \t\t\t\t\t\t\tj++;\n// \t\t\t\t\t\t}\n// \t\t\t\t\t\tif (j === len) {\n// \t\t\t\t\t\t\t// We matched a UNC root only\n// \t\t\t\t\t\t\trootEnd = j;\n// \t\t\t\t\t\t} else if (j !== last) {\n// \t\t\t\t\t\t\t// We matched a UNC root with leftovers\n// \t\t\t\t\t\t\trootEnd = j + 1;\n// \t\t\t\t\t\t}\n// \t\t\t\t\t}\n// \t\t\t\t}\n// \t\t\t}\n// \t\t} else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {\n// \t\t\t// Possible device root\n// \t\t\tif (len <= 2) {\n// \t\t\t\t// `path` contains just a drive root, exit early to avoid\n// \t\t\t\t// unnecessary work\n// \t\t\t\tret.root = ret.dir = path;\n// \t\t\t\treturn ret;\n// \t\t\t}\n// \t\t\trootEnd = 2;\n// \t\t\tif (isPathSeparator(path.charCodeAt(2))) {\n// \t\t\t\tif (len === 3) {\n// \t\t\t\t\t// `path` contains just a drive root, exit early to avoid\n// \t\t\t\t\t// unnecessary work\n// \t\t\t\t\tret.root = ret.dir = path;\n// \t\t\t\t\treturn ret;\n// \t\t\t\t}\n// \t\t\t\trootEnd = 3;\n// \t\t\t}\n// \t\t}\n// \t\tif (rootEnd > 0) {\n// \t\t\tret.root = path.slice(0, rootEnd);\n// \t\t}\n\n// \t\tlet startDot = -1;\n// \t\tlet startPart = rootEnd;\n// \t\tlet end = -1;\n// \t\tlet matchedSlash = true;\n// \t\tlet i = path.length - 1;\n\n// \t\t// Track the state of characters (if any) we see before our first dot and\n// \t\t// after any path separator we find\n// \t\tlet preDotState = 0;\n\n// \t\t// Get non-dir info\n// \t\tfor (; i >= rootEnd; --i) {\n// \t\t\tcode = path.charCodeAt(i);\n// \t\t\tif (isPathSeparator(code)) {\n// \t\t\t\t// If we reached a path separator that was not part of a set of path\n// \t\t\t\t// separators at the end of the string, stop now\n// \t\t\t\tif (!matchedSlash) {\n// \t\t\t\t\tstartPart = i + 1;\n// \t\t\t\t\tbreak;\n// \t\t\t\t}\n// \t\t\t\tcontinue;\n// \t\t\t}\n// \t\t\tif (end === -1) {\n// \t\t\t\t// We saw the first non-path separator, mark this as the end of our\n// \t\t\t\t// extension\n// \t\t\t\tmatchedSlash = false;\n// \t\t\t\tend = i + 1;\n// \t\t\t}\n// \t\t\tif (code === CHAR_DOT) {\n// \t\t\t\t// If this is our first dot, mark it as the start of our extension\n// \t\t\t\tif (startDot === -1) {\n// \t\t\t\t\tstartDot = i;\n// \t\t\t\t} else if (preDotState !== 1) {\n// \t\t\t\t\tpreDotState = 1;\n// \t\t\t\t}\n// \t\t\t} else if (startDot !== -1) {\n// \t\t\t\t// We saw a non-dot and non-path separator before our dot, so we should\n// \t\t\t\t// have a good chance at having a non-empty extension\n// \t\t\t\tpreDotState = -1;\n// \t\t\t}\n// \t\t}\n\n// \t\tif (end !== -1) {\n// \t\t\tif (startDot === -1 ||\n// \t\t\t\t// We saw a non-dot character immediately before the dot\n// \t\t\t\tpreDotState === 0 ||\n// \t\t\t\t// The (right-most) trimmed path component is exactly '..'\n// \t\t\t\t(preDotState === 1 &&\n// \t\t\t\t\tstartDot === end - 1 &&\n// \t\t\t\t\tstartDot === startPart + 1)) {\n// \t\t\t\tret.base = ret.name = path.slice(startPart, end);\n// \t\t\t} else {\n// \t\t\t\tret.name = path.slice(startPart, startDot);\n// \t\t\t\tret.base = path.slice(startPart, end);\n// \t\t\t\tret.ext = path.slice(startDot, end);\n// \t\t\t}\n// \t\t}\n\n// \t\t// If the directory is the root, use the entire root as the `dir` including\n// \t\t// the trailing slash if any (`C:\\abc` -> `C:\\`). Otherwise, strip out the\n// \t\t// trailing slash (`C:\\abc\\def` -> `C:\\abc`).\n// \t\tif (startPart > 0 && startPart !== rootEnd) {\n// \t\t\tret.dir = path.slice(0, startPart - 1);\n// \t\t} else {\n// \t\t\tret.dir = ret.root;\n// \t\t}\n\n// \t\treturn ret;\n// \t},\n\n// \tsep: '\\\\',\n// \tdelimiter: ';',\n// \twin32: null,\n// \tposix: null\n// };\n\nexport const posix: IPath = {\n  // path.resolve([from ...], to)\n  resolve(...pathSegments: string[]): string {\n    let resolvedPath = '';\n    let resolvedAbsolute = false;\n\n    for (let i = pathSegments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n      const path = i >= 0 ? pathSegments[i] : process.cwd();\n\n      validateString(path, 'path');\n\n      // Skip empty entries\n      if (path.length === 0) {\n        continue;\n      }\n\n      resolvedPath = `${path}/${resolvedPath}`;\n      resolvedAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n    }\n\n    // At this point the path should be resolved to a full absolute path, but\n    // handle relative paths to be safe (might happen when process.cwd() fails)\n\n    // Normalize the path\n    resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute, '/', isPosixPathSeparator);\n\n    if (resolvedAbsolute) {\n      return `/${resolvedPath}`;\n    }\n    return resolvedPath.length > 0 ? resolvedPath : '.';\n  },\n\n  normalize(path: string): string {\n    validateString(path, 'path');\n\n    if (path.length === 0) {\n      return '.';\n    }\n\n    const isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n    const trailingSeparator = path.charCodeAt(path.length - 1) === CHAR_FORWARD_SLASH;\n\n    // Normalize the path\n    path = normalizeString(path, !isAbsolute, '/', isPosixPathSeparator);\n\n    if (path.length === 0) {\n      if (isAbsolute) {\n        return '/';\n      }\n      return trailingSeparator ? './' : '.';\n    }\n    if (trailingSeparator) {\n      path += '/';\n    }\n\n    return isAbsolute ? `/${path}` : path;\n  },\n\n  isAbsolute(path: string): boolean {\n    validateString(path, 'path');\n    return path.length > 0 && path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n  },\n\n  join(...paths: string[]): string {\n    if (paths.length === 0) {\n      return '.';\n    }\n    let joined;\n    for (let i = 0; i < paths.length; ++i) {\n      const arg = paths[i];\n      validateString(arg, 'path');\n      if (arg.length > 0) {\n        if (joined === undefined) {\n          joined = arg;\n        } else {\n          joined += `/${arg}`;\n        }\n      }\n    }\n    if (joined === undefined) {\n      return '.';\n    }\n    return posix.normalize(joined);\n  },\n\n  relative(from: string, to: string): string {\n    validateString(from, 'from');\n    validateString(to, 'to');\n\n    if (from === to) {\n      return '';\n    }\n\n    // Trim leading forward slashes.\n    from = posix.resolve(from);\n    to = posix.resolve(to);\n\n    if (from === to) {\n      return '';\n    }\n\n    const fromStart = 1;\n    const fromEnd = from.length;\n    const fromLen = fromEnd - fromStart;\n    const toStart = 1;\n    const toLen = to.length - toStart;\n\n    // Compare paths to find the longest common path from root\n    const length = fromLen < toLen ? fromLen : toLen;\n    let lastCommonSep = -1;\n    let i = 0;\n    for (; i < length; i++) {\n      const fromCode = from.charCodeAt(fromStart + i);\n      if (fromCode !== to.charCodeAt(toStart + i)) {\n        break;\n      } else if (fromCode === CHAR_FORWARD_SLASH) {\n        lastCommonSep = i;\n      }\n    }\n    if (i === length) {\n      if (toLen > length) {\n        if (to.charCodeAt(toStart + i) === CHAR_FORWARD_SLASH) {\n          // We get here if `from` is the exact base path for `to`.\n          // For example: from='/foo/bar'; to='/foo/bar/baz'\n          return to.slice(toStart + i + 1);\n        }\n        if (i === 0) {\n          // We get here if `from` is the root\n          // For example: from='/'; to='/foo'\n          return to.slice(toStart + i);\n        }\n      } else if (fromLen > length) {\n        if (from.charCodeAt(fromStart + i) === CHAR_FORWARD_SLASH) {\n          // We get here if `to` is the exact base path for `from`.\n          // For example: from='/foo/bar/baz'; to='/foo/bar'\n          lastCommonSep = i;\n        } else if (i === 0) {\n          // We get here if `to` is the root.\n          // For example: from='/foo/bar'; to='/'\n          lastCommonSep = 0;\n        }\n      }\n    }\n\n    let out = '';\n    // Generate the relative path based on the path difference between `to`\n    // and `from`.\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n      if (i === fromEnd || from.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n        out += out.length === 0 ? '..' : '/..';\n      }\n    }\n\n    // Lastly, append the rest of the destination (`to`) path that comes after\n    // the common path parts.\n    return `${out}${to.slice(toStart + lastCommonSep)}`;\n  },\n\n  toNamespacedPath(path: string): string {\n    // Non-op on posix systems\n    return path;\n  },\n\n  dirname(path: string): string {\n    validateString(path, 'path');\n    if (path.length === 0) {\n      return '.';\n    }\n    const hasRoot = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n    let end = -1;\n    let matchedSlash = true;\n    for (let i = path.length - 1; i >= 1; --i) {\n      if (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n        if (!matchedSlash) {\n          end = i;\n          break;\n        }\n      } else {\n        // We saw the first non-path separator\n        matchedSlash = false;\n      }\n    }\n\n    if (end === -1) {\n      return hasRoot ? '/' : '.';\n    }\n    if (hasRoot && end === 1) {\n      return '//';\n    }\n    return path.slice(0, end);\n  },\n\n  basename(path: string, ext?: string): string {\n    if (ext !== undefined) {\n      validateString(ext, 'ext');\n    }\n    validateString(path, 'path');\n\n    let start = 0;\n    let end = -1;\n    let matchedSlash = true;\n    let i;\n\n    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n      if (ext === path) {\n        return '';\n      }\n      let extIdx = ext.length - 1;\n      let firstNonSlashEnd = -1;\n      for (i = path.length - 1; i >= 0; --i) {\n        const code = path.charCodeAt(i);\n        if (code === CHAR_FORWARD_SLASH) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            start = i + 1;\n            break;\n          }\n        } else {\n          if (firstNonSlashEnd === -1) {\n            // We saw the first non-path separator, remember this index in case\n            // we need it if the extension ends up not matching\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            // Try to match the explicit extension\n            if (code === ext.charCodeAt(extIdx)) {\n              if (--extIdx === -1) {\n                // We matched the extension, so mark this as the end of our path\n                // component\n                end = i;\n              }\n            } else {\n              // Extension does not match, so our result is the entire path\n              // component\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n\n      if (start === end) {\n        end = firstNonSlashEnd;\n      } else if (end === -1) {\n        end = path.length;\n      }\n      return path.slice(start, end);\n    }\n    for (i = path.length - 1; i >= 0; --i) {\n      if (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          start = i + 1;\n          break;\n        }\n      } else if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // path component\n        matchedSlash = false;\n        end = i + 1;\n      }\n    }\n\n    if (end === -1) {\n      return '';\n    }\n    return path.slice(start, end);\n  },\n\n  extname(path: string): string {\n    validateString(path, 'path');\n    let startDot = -1;\n    let startPart = 0;\n    let end = -1;\n    let matchedSlash = true;\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    let preDotState = 0;\n    for (let i = path.length - 1; i >= 0; --i) {\n      const code = path.charCodeAt(i);\n      if (code === CHAR_FORWARD_SLASH) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === CHAR_DOT) {\n        // If this is our first dot, mark it as the start of our extension\n        if (startDot === -1) {\n          startDot = i;\n        } else if (preDotState !== 1) {\n          preDotState = 1;\n        }\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (\n      startDot === -1 ||\n      end === -1 ||\n      // We saw a non-dot character immediately before the dot\n      preDotState === 0 ||\n      // The (right-most) trimmed path component is exactly '..'\n      (preDotState === 1 && startDot === end - 1 && startDot === startPart + 1)\n    ) {\n      return '';\n    }\n    return path.slice(startDot, end);\n  },\n\n  format: _format.bind(null, '/'),\n\n  parse(path: string): ParsedPath {\n    validateString(path, 'path');\n\n    const ret = { root: '', dir: '', base: '', ext: '', name: '' };\n    if (path.length === 0) {\n      return ret;\n    }\n    const isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n    let start;\n    if (isAbsolute) {\n      ret.root = '/';\n      start = 1;\n    } else {\n      start = 0;\n    }\n    let startDot = -1;\n    let startPart = 0;\n    let end = -1;\n    let matchedSlash = true;\n    let i = path.length - 1;\n\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    let preDotState = 0;\n\n    // Get non-dir info\n    for (; i >= start; --i) {\n      const code = path.charCodeAt(i);\n      if (code === CHAR_FORWARD_SLASH) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === CHAR_DOT) {\n        // If this is our first dot, mark it as the start of our extension\n        if (startDot === -1) {\n          startDot = i;\n        } else if (preDotState !== 1) {\n          preDotState = 1;\n        }\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (end !== -1) {\n      const start = startPart === 0 && isAbsolute ? 1 : startPart;\n      if (\n        startDot === -1 ||\n        // We saw a non-dot character immediately before the dot\n        preDotState === 0 ||\n        // The (right-most) trimmed path component is exactly '..'\n        (preDotState === 1 && startDot === end - 1 && startDot === startPart + 1)\n      ) {\n        ret.base = ret.name = path.slice(start, end);\n      } else {\n        ret.name = path.slice(start, startDot);\n        ret.base = path.slice(start, end);\n        ret.ext = path.slice(startDot, end);\n      }\n    }\n\n    if (startPart > 0) {\n      ret.dir = path.slice(0, startPart - 1);\n    } else if (isAbsolute) {\n      ret.dir = '/';\n    }\n\n    return ret;\n  },\n\n  sep: '/',\n  delimiter: ':',\n  win32: null,\n  posix: null,\n};\n\nexport const normalize = posix.normalize;\nexport const isAbsolute = posix.isAbsolute;\nexport const join = posix.join;\nexport const resolve = posix.resolve;\nexport const relative = posix.relative;\nexport const dirname = posix.dirname;\nexport const basename = posix.basename;\nexport const extname = posix.extname;\nexport const format = posix.format;\nexport const parse = posix.parse;\nexport const toNamespacedPath = posix.toNamespacedPath;\nexport const sep = posix.sep;\nexport const delimiter = posix.delimiter;\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from './charCode';\nimport { join } from './path';\n\nconst _schemePattern = /^\\w[\\w\\d+.-]*$/;\nconst _singleSlashStart = /^\\//;\nconst _doubleSlashStart = /^\\/\\//;\n\nfunction _validateUri(ret: Uri, _strict?: boolean): void {\n  // scheme, must be set\n  if (!ret.scheme && _strict) {\n    throw new Error(\n      `[UriError]: Scheme is missing: {scheme: \"\", authority: \"${ret.authority}\", path: \"${ret.path}\", query: \"${ret.query}\", fragment: \"${ret.fragment}\"}`\n    );\n  }\n\n  // scheme, https://tools.ietf.org/html/rfc3986#section-3.1\n  // ALPHA *( ALPHA / DIGIT / \"+\" / \"-\" / \".\" )\n  if (ret.scheme && !_schemePattern.test(ret.scheme)) {\n    throw new Error('[UriError]: Scheme contains illegal characters.');\n  }\n\n  // path, http://tools.ietf.org/html/rfc3986#section-3.3\n  // If a URI contains an authority component, then the path component\n  // must either be empty or begin with a slash (\"/\") character.  If a URI\n  // does not contain an authority component, then the path cannot begin\n  // with two slash characters (\"//\").\n  if (ret.path) {\n    if (ret.authority) {\n      if (!_singleSlashStart.test(ret.path)) {\n        throw new Error(\n          '[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash (\"/\") character'\n        );\n      }\n    } else {\n      if (_doubleSlashStart.test(ret.path)) {\n        throw new Error(\n          '[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters (\"//\")'\n        );\n      }\n    }\n  }\n}\n\n// for a while we allowed uris *without* schemes and this is the migration\n// for them, e.g. an uri without scheme and without strict-mode warns and falls\n// back to the file-scheme. that should cause the least carnage and still be a\n// clear warning\nfunction _schemeFix(scheme: string, _strict: boolean): string {\n  if (!scheme && !_strict) {\n    return 'file';\n  }\n  return scheme;\n}\n\n// implements a bit of https://tools.ietf.org/html/rfc3986#section-5\nfunction _referenceResolution(scheme: string, path: string): string {\n  // the slash-character is our 'default base' as we don't\n  // support constructing URIs relative to other URIs. This\n  // see https://tools.ietf.org/html/rfc3986#section-5.1.4\n  switch (scheme) {\n    case 'https':\n    case 'http':\n    case 'file':\n      if (!path) {\n        path = _slash;\n      } else if (path[0] !== _slash) {\n        path = _slash + path;\n      }\n      break;\n  }\n  return path;\n}\n\nconst _empty = '';\nconst _slash = '/';\nconst _regexp = /^(([^:/?#]+?):)?(\\/\\/([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?/;\n\n/**\n * Uniform Resource Identifier (URI) http://tools.ietf.org/html/rfc3986.\n * This class is a simple parser which creates the basic component parts\n * (http://tools.ietf.org/html/rfc3986#section-3) with minimal validation\n * and encoding.\n *\n * ```txt\n *       foo://example.com:8042/over/there?name=ferret#nose\n *       \\_/   \\______________/\\_________/ \\_________/ \\__/\n *        |           |            |            |        |\n *     scheme     authority       path        query   fragment\n *        |   _____________________|__\n *       / \\ /                        \\\n *       urn:example:animal:ferret:nose\n * ```\n */\nexport class Uri implements UriComponents {\n  static ensureTrailingSlash(uri: Uri, trailingSlash = '/') {\n    return uri.with({\n      path: uri.path.replace(TRAILING_SLASH_RX, trailingSlash),\n    });\n  }\n\n  static equals(l: Uri, r: Uri) {\n    return (\n      l.authority === r.authority &&\n      l.fragment === r.fragment &&\n      l.path === r.path &&\n      l.query === r.query &&\n      l.scheme === r.scheme\n    );\n  }\n\n  static getFirstPathSegmentAfterPrefix(child: Uri, parent: Uri): string {\n    const childHref = child.path;\n    const parentHref = parent.path;\n    const parentOffset = parentHref.charAt(parentHref.length - 1) === '/' ? -1 : 0;\n\n    for (let i = 0; i <= childHref.length; i++) {\n      if (i < parentHref.length) {\n        if (childHref.charAt(i) !== parentHref.charAt(i)) {\n          throw new Error(\n            `The child entry ${child.toString()} does not have the pathname of ${parent.toString()} as a prefix`\n          );\n        }\n      } else if (i === parentHref.length + parentOffset) {\n        if (childHref.charAt(i) !== '/') {\n          throw new Error(\n            `The child entry ${child.toString()} does not have the pathname of ${parent.toString()} as a prefix`\n          );\n        }\n      } else if (childHref.charAt(i) === '/') {\n        return childHref.slice(parentHref.length + 1 + parentOffset, i);\n      }\n    }\n\n    return childHref.slice(parentHref.length + 1 + parentOffset);\n  }\n\n  static isPrefixOf(prefix: Uri, uri: Uri) {\n    return (\n      prefix.authority === uri.authority &&\n      prefix.fragment === uri.fragment &&\n      prefix.query === uri.query &&\n      prefix.scheme === uri.scheme &&\n      uri.path.startsWith(prefix.path)\n    );\n  }\n\n  static isUri(thing: any): thing is Uri {\n    if (thing instanceof Uri) {\n      return true;\n    }\n    if (!thing) {\n      return false;\n    }\n    return (\n      typeof (<Uri>thing).authority === 'string' &&\n      typeof (<Uri>thing).fragment === 'string' &&\n      typeof (<Uri>thing).path === 'string' &&\n      typeof (<Uri>thing).query === 'string' &&\n      typeof (<Uri>thing).scheme === 'string' &&\n      typeof (<Uri>thing).fsPath === 'function' &&\n      typeof (<Uri>thing).with === 'function' &&\n      typeof (<Uri>thing).toString === 'function'\n    );\n  }\n\n  /**\n   * scheme is the 'http' part of 'http://www.msft.com/some/path?query#fragment'.\n   * The part before the first colon.\n   */\n  readonly scheme: string;\n\n  /**\n   * authority is the 'www.msft.com' part of 'http://www.msft.com/some/path?query#fragment'.\n   * The part between the first double slashes and the next slash.\n   */\n  readonly authority: string;\n\n  /**\n   * path is the '/some/path' part of 'http://www.msft.com/some/path?query#fragment'.\n   */\n  readonly path: string;\n\n  /**\n   * query is the 'query' part of 'http://www.msft.com/some/path?query#fragment'.\n   */\n  readonly query: string;\n\n  /**\n   * fragment is the 'fragment' part of 'http://www.msft.com/some/path?query#fragment'.\n   */\n  readonly fragment: string;\n\n  /**\n   * @internal\n   */\n  protected constructor(\n    scheme: string,\n    authority?: string,\n    path?: string,\n    query?: string,\n    fragment?: string,\n    _strict?: boolean\n  );\n\n  /**\n   * @internal\n   */\n  protected constructor(components: UriComponents);\n\n  /**\n   * @internal\n   */\n  protected constructor(\n    schemeOrData: string | UriComponents,\n    authority?: string,\n    path?: string,\n    query?: string,\n    fragment?: string,\n    _strict: boolean = false\n  ) {\n    if (typeof schemeOrData === 'object') {\n      this.scheme = schemeOrData.scheme || _empty;\n      this.authority = schemeOrData.authority || _empty;\n      this.path = schemeOrData.path || _empty;\n      this.query = schemeOrData.query || _empty;\n      this.fragment = schemeOrData.fragment || _empty;\n      // no validation because it's this URI\n      // that creates uri components.\n      // _validateUri(this);\n    } else {\n      this.scheme = _schemeFix(schemeOrData, _strict);\n      this.authority = authority || _empty;\n      this.path = _referenceResolution(this.scheme, path || _empty);\n      this.query = query || _empty;\n      this.fragment = fragment || _empty;\n\n      _validateUri(this, _strict);\n    }\n  }\n\n  // ---- filesystem path -----------------------\n\n  /**\n\t * Returns a string representing the corresponding file system path of this URI.\n\t * platform specific path separator.\n\t *\n\t * * Will *not* validate the path for invalid characters and semantics.\n\t * * Will *not* look at the scheme of this URI.\n\t * * The result shall *not* be used for display purposes but for accessing a file on disk.\n\t *\n\t *\n\t * The *difference* to `URI#path` is the use of the platform specific separator and the handling\n\t *\n\t * ```ts\n\t\tconst u = URI.parse('file://server/c$/folder/file.txt')\n\t\tu.authority === 'server'\n\t\tu.path === '/shares/c$/file.txt'\n\t\tu.fsPath === '\\\\server\\c$\\folder\\file.txt'\n\t```\n\t *\n\t * Using `URI#path` to read a file (using fs-apis) would not be enough because parts of the path,\n\t * namely the server name, would be missing. Therefore `URI#fsPath` exists - it's sugar to ease working\n\t * with URIs that represent files on disk (`file` scheme).\n\t */\n  get fsPath(): string {\n    // if (this.scheme !== 'file') {\n    // \tconsole.warn(`[UriError] calling fsPath with scheme ${this.scheme}`);\n    // }\n    return uriToFsPath(this, false);\n  }\n\n  // ---- modify to new -------------------------\n\n  with(change: {\n    scheme?: string;\n    authority?: string | null;\n    path?: string | null;\n    query?: string | null;\n    fragment?: string | null;\n  }): Uri {\n    if (!change) {\n      return this;\n    }\n\n    let { scheme, authority, path, query, fragment } = change;\n    if (scheme === undefined) {\n      scheme = this.scheme;\n    } else if (scheme === null) {\n      scheme = _empty;\n    }\n    if (authority === undefined) {\n      authority = this.authority;\n    } else if (authority === null) {\n      authority = _empty;\n    }\n    if (path === undefined) {\n      path = this.path;\n    } else if (path === null) {\n      path = _empty;\n    }\n    if (query === undefined) {\n      query = this.query;\n    } else if (query === null) {\n      query = _empty;\n    }\n    if (fragment === undefined) {\n      fragment = this.fragment;\n    } else if (fragment === null) {\n      fragment = _empty;\n    }\n\n    if (\n      scheme === this.scheme &&\n      authority === this.authority &&\n      path === this.path &&\n      query === this.query &&\n      fragment === this.fragment\n    ) {\n      return this;\n    }\n\n    return new _URI(scheme, authority, path, query, fragment);\n  }\n\n  // ---- parse & validate ------------------------\n\n  /**\n   * Creates a new URI from a string, e.g. `http://www.msft.com/some/path`,\n   * `file:///usr/home`, or `scheme:with/path`.\n   *\n   * @param value A string which represents an URI (see `URI#toString`).\n   */\n  static parse(value: string, _strict: boolean = false): Uri {\n    const match = _regexp.exec(value);\n    if (!match) {\n      return new _URI(_empty, _empty, _empty, _empty, _empty);\n    }\n    return new _URI(\n      match[2] || _empty,\n      percentDecode(match[4] || _empty),\n      percentDecode(match[5] || _empty),\n      percentDecode(match[7] || _empty),\n      percentDecode(match[9] || _empty),\n      _strict\n    );\n  }\n\n  /**\n\t * Creates a new URI from a file system path, e.g. `c:\\my\\files`,\n\t * `/usr/home`, or `\\\\server\\share\\some\\path`.\n\t *\n\t * The *difference* between `URI#parse` and `URI#file` is that the latter treats the argument\n\t * as path, not as stringified-uri. E.g. `URI.file(path)` is **not the same as**\n\t * `URI.parse('file://' + path)` because the path might contain characters that are\n\t * interpreted (# and ?). See the following sample:\n\t * ```ts\n\tconst good = URI.file('/coding/c#/project1');\n\tgood.scheme === 'file';\n\tgood.path === '/coding/c#/project1';\n\tgood.fragment === '';\n\tconst bad = URI.parse('file://' + '/coding/c#/project1');\n\tbad.scheme === 'file';\n\tbad.path === '/coding/c'; // path is now broken\n\tbad.fragment === '/project1';\n\t```\n\t *\n\t * @param path A file system path (see `URI#fsPath`)\n\t */\n  static file(path: string): Uri {\n    let authority = _empty;\n\n    // check for authority as used in UNC shares\n    // or use the path as given\n    if (path[0] === _slash && path[1] === _slash) {\n      const idx = path.indexOf(_slash, 2);\n      if (idx === -1) {\n        authority = path.substring(2);\n        path = _slash;\n      } else {\n        authority = path.substring(2, idx);\n        path = path.substring(idx) || _slash;\n      }\n    }\n\n    return new _URI('file', authority, path, _empty, _empty);\n  }\n\n  static from(components: {\n    scheme: string;\n    authority?: string;\n    path?: string;\n    query?: string;\n    fragment?: string;\n  }): Uri {\n    return new _URI(\n      components.scheme,\n      components.authority,\n      components.path,\n      components.query,\n      components.fragment\n    );\n  }\n\n  /**\n   * Join a URI path with path fragments and normalizes the resulting path.\n   *\n   * @param uri The input URI.\n   * @param pathFragment The path fragment to add to the URI path.\n   * @returns The resulting URI.\n   */\n  static joinPath(uri: Uri, ...pathFragment: string[]): Uri {\n    if (!uri.path) {\n      throw new Error(`[UriError]: cannot call joinPaths on URI without path`);\n    }\n    const newPath = join(uri.path, ...pathFragment);\n    return uri.with({ path: newPath });\n  }\n\n  // ---- printing/externalize ---------------------------\n\n  /**\n   * Creates a string representation for this URI. It's guaranteed that calling\n   * `URI.parse` with the result of this function creates an URI which is equal\n   * to this URI.\n   *\n   * * The result shall *not* be used for display purposes but for externalization or transport.\n   * * The result will be encoded using the percentage encoding and encoding happens mostly\n   * ignore the scheme-specific encoding rules.\n   *\n   * @param skipEncoding Do not encode the result, default is `false`\n   */\n  toString(skipEncoding: boolean = true): string {\n    return _asFormatted(this, skipEncoding);\n  }\n\n  toJSON(): UriComponents {\n    return this;\n  }\n\n  static revive(data: UriComponents | Uri): Uri;\n  static revive(data: UriComponents | Uri | undefined): Uri | undefined;\n  static revive(data: UriComponents | Uri | null): Uri | null;\n  static revive(data: UriComponents | Uri | undefined | null): Uri | undefined | null;\n  static revive(data: UriComponents | Uri | undefined | null): Uri | undefined | null {\n    if (!data) {\n      return data;\n    } else if (data instanceof Uri) {\n      return data;\n    } else {\n      const result = new _URI(data);\n      result._formatted = (<UriState>data).external;\n      result._fsPath = (<UriState>data)._sep === _pathSepMarker ? (<UriState>data).fsPath : null;\n      return result;\n    }\n  }\n}\n\nexport interface UriComponents {\n  scheme: string;\n  authority: string;\n  path: string;\n  query: string;\n  fragment: string;\n}\n\ninterface UriState extends UriComponents {\n  $mid: number;\n  external: string;\n  fsPath: string;\n  _sep: 1 | undefined;\n}\n\nconst _pathSepMarker = undefined;\n\n// eslint-disable-next-line @typescript-eslint/naming-convention\nclass _URI extends Uri {\n  _formatted: string | null = null;\n  _fsPath: string | null = null;\n\n  get fsPath(): string {\n    if (!this._fsPath) {\n      this._fsPath = uriToFsPath(this, false);\n    }\n    return this._fsPath;\n  }\n\n  toString(skipEncoding: boolean = true): string {\n    if (!skipEncoding) {\n      // we don't cache that\n      return _asFormatted(this, false);\n    } else {\n      if (!this._formatted) {\n        this._formatted = _asFormatted(this, true);\n      }\n      return this._formatted;\n    }\n  }\n\n  toJSON(): UriComponents {\n    const res = <UriState>{\n      $mid: 1,\n    };\n    // cached state\n    if (this._fsPath) {\n      res.fsPath = this._fsPath;\n      res._sep = _pathSepMarker;\n    }\n    if (this._formatted) {\n      res.external = this._formatted;\n    }\n    // uri components\n    if (this.path) {\n      res.path = this.path;\n    }\n    if (this.scheme) {\n      res.scheme = this.scheme;\n    }\n    if (this.authority) {\n      res.authority = this.authority;\n    }\n    if (this.query) {\n      res.query = this.query;\n    }\n    if (this.fragment) {\n      res.fragment = this.fragment;\n    }\n    return res;\n  }\n}\n\n// reserved characters: https://tools.ietf.org/html/rfc3986#section-2.2\nconst encodeTable: { [ch: number]: string } = {\n  [CharCode.Colon]: '%3A', // gen-delims\n  [CharCode.Slash]: '%2F',\n  [CharCode.QuestionMark]: '%3F',\n  [CharCode.Hash]: '%23',\n  [CharCode.OpenSquareBracket]: '%5B',\n  [CharCode.CloseSquareBracket]: '%5D',\n  [CharCode.AtSign]: '%40',\n\n  [CharCode.ExclamationMark]: '%21', // sub-delims\n  [CharCode.DollarSign]: '%24',\n  [CharCode.Ampersand]: '%26',\n  [CharCode.SingleQuote]: '%27',\n  [CharCode.OpenParen]: '%28',\n  [CharCode.CloseParen]: '%29',\n  [CharCode.Asterisk]: '%2A',\n  [CharCode.Plus]: '%2B',\n  [CharCode.Comma]: '%2C',\n  [CharCode.Semicolon]: '%3B',\n  [CharCode.Equals]: '%3D',\n\n  [CharCode.Space]: '%20',\n};\n\nfunction encodeURIComponentFast(uriComponent: string, allowSlash: boolean): string {\n  let res: string | undefined = undefined;\n  let nativeEncodePos = -1;\n\n  for (let pos = 0; pos < uriComponent.length; pos++) {\n    const code = uriComponent.charCodeAt(pos);\n\n    // unreserved characters: https://tools.ietf.org/html/rfc3986#section-2.3\n    if (\n      (code >= CharCode.a && code <= CharCode.z) ||\n      (code >= CharCode.A && code <= CharCode.Z) ||\n      (code >= CharCode.Digit0 && code <= CharCode.Digit9) ||\n      code === CharCode.Dash ||\n      code === CharCode.Period ||\n      code === CharCode.Underline ||\n      code === CharCode.Tilde ||\n      (allowSlash && code === CharCode.Slash)\n    ) {\n      // check if we are delaying native encode\n      if (nativeEncodePos !== -1) {\n        res += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));\n        nativeEncodePos = -1;\n      }\n      // check if we write into a new string (by default we try to return the param)\n      if (res !== undefined) {\n        res += uriComponent.charAt(pos);\n      }\n    } else {\n      // encoding needed, we need to allocate a new string\n      if (res === undefined) {\n        res = uriComponent.substr(0, pos);\n      }\n\n      // check with default table first\n      const escaped = encodeTable[code];\n      if (escaped !== undefined) {\n        // check if we are delaying native encode\n        if (nativeEncodePos !== -1) {\n          res += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));\n          nativeEncodePos = -1;\n        }\n\n        // append escaped variant to result\n        res += escaped;\n      } else if (nativeEncodePos === -1) {\n        // use native encode only when needed\n        nativeEncodePos = pos;\n      }\n    }\n  }\n\n  if (nativeEncodePos !== -1) {\n    res += encodeURIComponent(uriComponent.substring(nativeEncodePos));\n  }\n\n  return res !== undefined ? res : uriComponent;\n}\n\nfunction encodeURIComponentMinimal(path: string): string {\n  let res: string | undefined = undefined;\n  for (let pos = 0; pos < path.length; pos++) {\n    const code = path.charCodeAt(pos);\n    if (code === CharCode.Hash || code === CharCode.QuestionMark) {\n      if (res === undefined) {\n        res = path.substr(0, pos);\n      }\n      res += encodeTable[code];\n    } else {\n      if (res !== undefined) {\n        res += path[pos];\n      }\n    }\n  }\n  return res !== undefined ? res : path;\n}\n\n/**\n * Compute `fsPath` for the given uri\n */\nexport function uriToFsPath(uri: Uri, keepDriveLetterCasing: boolean): string {\n  let value: string;\n  if (uri.authority && uri.path.length > 1 && uri.scheme === 'file') {\n    // unc path: file://shares/c$/far/boo\n    value = `//${uri.authority}${uri.path}`;\n  } else if (\n    uri.path.charCodeAt(0) === CharCode.Slash &&\n    ((uri.path.charCodeAt(1) >= CharCode.A && uri.path.charCodeAt(1) <= CharCode.Z) ||\n      (uri.path.charCodeAt(1) >= CharCode.a && uri.path.charCodeAt(1) <= CharCode.z)) &&\n    uri.path.charCodeAt(2) === CharCode.Colon\n  ) {\n    if (!keepDriveLetterCasing) {\n      // windows drive letter: file:///c:/far/boo\n      value = uri.path[1].toLowerCase() + uri.path.substr(2);\n    } else {\n      value = uri.path.substr(1);\n    }\n  } else {\n    // other path\n    value = uri.path;\n  }\n  return value;\n}\n\n/**\n * Create the external version of a uri\n */\nfunction _asFormatted(uri: Uri, skipEncoding: boolean): string {\n  const encoder = !skipEncoding ? encodeURIComponentFast : encodeURIComponentMinimal;\n\n  let res = '';\n  let { scheme, authority, path, query, fragment } = uri;\n  if (scheme) {\n    res += scheme;\n    res += ':';\n  }\n  if (authority || scheme === 'file') {\n    res += _slash;\n    res += _slash;\n  }\n  if (authority) {\n    let idx = authority.indexOf('@');\n    if (idx !== -1) {\n      // <user>@<auth>\n      const userinfo = authority.substr(0, idx);\n      authority = authority.substr(idx + 1);\n      idx = userinfo.indexOf(':');\n      if (idx === -1) {\n        res += encoder(userinfo, false);\n      } else {\n        // <user>:<pass>@<auth>\n        res += encoder(userinfo.substr(0, idx), false);\n        res += ':';\n        res += encoder(userinfo.substr(idx + 1), false);\n      }\n      res += '@';\n    }\n    authority = authority.toLowerCase();\n    idx = authority.indexOf(':');\n    if (idx === -1) {\n      res += encoder(authority, false);\n    } else {\n      // <auth>:<port>\n      res += encoder(authority.substr(0, idx), false);\n      res += authority.substr(idx);\n    }\n  }\n  if (path) {\n    // lower-case windows drive letters in /C:/fff or C:/fff\n    if (\n      path.length >= 3 &&\n      path.charCodeAt(0) === CharCode.Slash &&\n      path.charCodeAt(2) === CharCode.Colon\n    ) {\n      const code = path.charCodeAt(1);\n      if (code >= CharCode.A && code <= CharCode.Z) {\n        path = `/${String.fromCharCode(code + 32)}:${path.substr(3)}`; // \"/c:\".length === 3\n      }\n    } else if (path.length >= 2 && path.charCodeAt(1) === CharCode.Colon) {\n      const code = path.charCodeAt(0);\n      if (code >= CharCode.A && code <= CharCode.Z) {\n        path = `${String.fromCharCode(code + 32)}:${path.substr(2)}`; // \"/c:\".length === 3\n      }\n    }\n    // encode the rest of the path\n    res += encoder(path, true);\n  }\n  if (query) {\n    res += '?';\n    res += encoder(query, false);\n  }\n  if (fragment) {\n    res += '#';\n    res += !skipEncoding ? encodeURIComponentFast(fragment, false) : fragment;\n  }\n  return res;\n}\n\n// --- decode\n\nfunction decodeURIComponentGraceful(str: string): string {\n  try {\n    return decodeURIComponent(str);\n  } catch {\n    if (str.length > 3) {\n      return str.substr(0, 3) + decodeURIComponentGraceful(str.substr(3));\n    } else {\n      return str;\n    }\n  }\n}\n\nconst _rEncodedAsHex = /(%[0-9A-Za-z][0-9A-Za-z])+/g;\n\nfunction percentDecode(str: string): string {\n  if (!str.match(_rEncodedAsHex)) {\n    return str;\n  }\n  return str.replace(_rEncodedAsHex, (match) => decodeURIComponentGraceful(match));\n}\n\nconst TRAILING_SLASH_RX = /\\/?$/;\n","import { Uri } from '@velcro/common';\nimport {\n  AbstractResolverStrategyWithRoot,\n  ResolverContext,\n  ResolverStrategy,\n} from '@velcro/resolver';\n\ninterface DirectoryEntry {\n  type: ResolverStrategy.EntryKind.Directory;\n  children: Record<string, Entry>;\n}\n\nenum FileEncoding {\n  Base64 = 'base64',\n  UTF8 = 'utf-8',\n}\n\ninterface FileEntry {\n  type: ResolverStrategy.EntryKind.File;\n  content: string;\n  encoding: FileEncoding;\n}\n\ninterface FileInputWithEncoding {\n  encoding: FileEncoding;\n  content: string;\n}\n\ntype Entry = DirectoryEntry | FileEntry;\ntype FileInput = string | FileInputWithEncoding;\n\nconst encodeText =\n  typeof TextEncoder === 'function'\n    ? (function () {\n        const encoder = new TextEncoder();\n\n        return function encodeText(data: string): ArrayBuffer {\n          return encoder.encode(data).buffer;\n        };\n      })()\n    : typeof Buffer === 'function'\n    ? function encodeText(data: string): ArrayBuffer {\n        return Buffer.from(data);\n      }\n    : function encodeText(_data: string): ArrayBuffer {\n        throw new Error(\n          'The environment provides neither TextEncoder nor Buffer. Please consider polyfilling one of these APIs.'\n        );\n      };\n\nexport class MemoryStrategy extends AbstractResolverStrategyWithRoot {\n  private readonly root: DirectoryEntry = {\n    type: ResolverStrategy.EntryKind.Directory,\n    children: {},\n  };\n\n  constructor(files: Record<string, FileInput>, rootUri = Uri.parse('memory:/')) {\n    super(Uri.ensureTrailingSlash(rootUri));\n\n    for (const pathname in files) {\n      const file = files[pathname];\n\n      if (typeof file === 'string') {\n        this.addFile(pathname, file);\n      } else {\n        this.addFile(pathname, file.content, { encoding: file.encoding });\n      }\n    }\n  }\n\n  getEntryAtPath(pathname: string) {\n    const segments = Array.isArray(pathname)\n      ? pathname.slice()\n      : pathname.split('/').filter(Boolean);\n\n    let parent: Entry = this.root;\n\n    for (const segment of segments) {\n      if (!parent || parent.type !== ResolverStrategy.EntryKind.Directory) {\n        throw new Error(`Failed to add ${pathname}`);\n      }\n\n      parent = parent.children[segment];\n    }\n\n    return parent;\n  }\n\n  addFile(\n    pathname: string,\n    content: string,\n    {\n      encoding = FileEncoding.UTF8,\n      overwrite = false,\n    }: { encoding?: FileEncoding; overwrite?: boolean } = {}\n  ) {\n    const segments = pathname.split('/').filter(Boolean);\n    const filename = segments.pop();\n\n    if (!filename) {\n      throw new Error(`Unable to add a file without a filename '${pathname}'`);\n    }\n\n    let parent: Entry = this.root;\n\n    for (const segment of segments) {\n      if (!parent || parent.type !== ResolverStrategy.EntryKind.Directory) {\n        throw new Error(`Failed to add ${pathname}`);\n      }\n\n      let dir: Entry = parent.children[segment];\n\n      if (!dir) {\n        dir = {\n          type: ResolverStrategy.EntryKind.Directory,\n          children: {},\n        };\n\n        parent.children[segment] = dir;\n      }\n\n      parent = dir;\n    }\n\n    if (parent.type !== ResolverStrategy.EntryKind.Directory) {\n      throw new Error(`Cannot add file to a non directory entry ${pathname}`);\n    }\n\n    if (parent.children[filename] && !overwrite) {\n      throw new Error(`Entry already exists at ${pathname}`);\n    }\n\n    const entry: FileEntry = {\n      type: ResolverStrategy.EntryKind.File,\n      content,\n      encoding,\n    };\n\n    parent.children[filename] = entry;\n\n    return entry;\n  }\n\n  removeFile(pathname: string) {\n    const segments = pathname.split('/').filter(Boolean);\n    const filename = segments.pop();\n\n    if (!filename) {\n      return false;\n    }\n\n    let parent: Entry = this.root;\n\n    for (const segment of segments) {\n      if (!parent || parent.type !== ResolverStrategy.EntryKind.Directory) {\n        return false;\n      }\n\n      parent = parent.children[segment];\n    }\n\n    if (!parent || parent.type !== ResolverStrategy.EntryKind.Directory) {\n      return false;\n    }\n\n    return delete parent.children[filename];\n  }\n\n  getResolveRoot() {\n    return {\n      uri: this.rootUri,\n    };\n  }\n\n  listEntries(_ctx: ResolverContext, uri: Uri) {\n    const urlPathname = Uri.ensureTrailingSlash(uri).fsPath;\n    const basePathname = this.rootUri.fsPath;\n    const fsPathname = urlPathname.startsWith(basePathname)\n      ? urlPathname.slice(basePathname.length - 1)\n      : urlPathname;\n    const parent = this.getEntryAtPath(fsPathname);\n\n    if (!parent) {\n      throw new Error(`No such directory ${uri.toString()}`);\n    }\n\n    if (parent.type !== ResolverStrategy.EntryKind.Directory) {\n      throw new Error(`Cannot list entries under a file at ${uri.toString()}`);\n    }\n\n    const entries = Object.keys(parent.children).map((filename) => {\n      const entry = parent.children[filename];\n\n      return {\n        uri: Uri.joinPath(this.rootUri, fsPathname, filename),\n        type: entry.type,\n      };\n    });\n\n    return {\n      entries,\n    };\n  }\n\n  readFileContent(_ctx: ResolverContext, uri: Uri) {\n    const urlPathname = Uri.ensureTrailingSlash(uri).fsPath;\n    const basePathname = this.rootUri.fsPath;\n    const fsPathname = urlPathname.startsWith(basePathname)\n      ? urlPathname.slice(basePathname.length - 1)\n      : urlPathname;\n    const entry = this.getEntryAtPath(fsPathname);\n\n    if (!entry) {\n      throw new Error(`No such file ${uri.toString()}`);\n    }\n\n    if (entry.type !== 'file') {\n      throw new Error(`Cannot read content of a non-file at ${uri.toString()}`);\n    }\n\n    switch (entry.encoding) {\n      case FileEncoding.Base64: {\n        const binSting = atob(entry.content);\n        const binArray = new Uint8Array(binSting.length);\n\n        Array.prototype.forEach.call(binArray, function (_el: any, idx: number, arr: number[]) {\n          arr[idx] = binSting.charCodeAt(idx);\n        });\n\n        return {\n          content: binArray.buffer,\n        };\n      }\n      case FileEncoding.UTF8: {\n        return {\n          content: encodeText(entry.content),\n        };\n      }\n      default:\n        throw new Error(`Unsupported encoding for ${uri.toString()}: ${entry.encoding}`);\n    }\n  }\n\n  uriForPath(pathname: string) {\n    return Uri.joinPath(this.rootUri, pathname);\n  }\n}\n","import { DisposableStore, Emitter, Event } from '@velcro/common';\nimport type * as Monaco from 'monaco-editor';\nimport {\n  EditorEvent,\n  FileCreateEvent,\n  FileRemoveEvent,\n  FileUpdateEvent,\n  WorkerState,\n} from './types';\n\nconst EDITOR_EVENT_THROTTLE_MS = (1000 / 16) | 0;\n\nexport function trackMonaco(monaco: typeof Monaco) {\n  const disposer = new DisposableStore();\n  const worker = new Worker('./velcroWorker.ts', { type: 'module' });\n\n  const trackModel = (model: Monaco.editor.ITextModel) => {\n    model.onWillDispose(() => {\n      const message: FileRemoveEvent = {\n        event: 'file_remove',\n        href: model.uri.toString(true),\n      };\n      postMessage(message);\n      disposerReference.dispose();\n    });\n\n    const disposerReference = disposer.add(\n      model.onDidChangeContent(() => {\n        const message: FileUpdateEvent = {\n          event: 'file_update',\n          content: model.getValue(),\n          href: model.uri.toString(true),\n        };\n        postMessage(message);\n      })\n    );\n\n    const message: FileCreateEvent = {\n      event: 'file_create',\n      content: model.getValue(),\n      href: model.uri.toString(true),\n    };\n    postMessage(message);\n  };\n\n  const postMessageEmitter = new Emitter<EditorEvent>();\n  const postMessageQueue = Event.debounce<EditorEvent, Map<string, EditorEvent>>(\n    postMessageEmitter.event,\n    (last, event) => {\n      if (!last) {\n        last = new Map();\n      }\n\n      last.set(event.href, event);\n\n      return last;\n    },\n    EDITOR_EVENT_THROTTLE_MS\n  )((events) => {\n    worker.postMessage([...events.values()]);\n  });\n\n  disposer.add(postMessageEmitter);\n  disposer.add(postMessageQueue);\n\n  const postMessage = (message: EditorEvent) => {\n    postMessageEmitter.fire(message);\n  };\n\n  // Track existing models\n  monaco.editor.getModels().forEach(trackModel);\n\n  // And future models\n  disposer.add(monaco.editor.onDidCreateModel(trackModel));\n  disposer.add({\n    dispose: () => worker.terminate(),\n  });\n\n  const emitter = new Emitter<WorkerState>();\n  disposer.add(emitter);\n\n  worker.addEventListener('message', (e) => {\n    if (WorkerState.is(e.data)) {\n      emitter.fire(e.data);\n    }\n  });\n\n  return {\n    dispose: () => disposer.dispose(),\n    get onStateChange() {\n      return emitter.event;\n    },\n  };\n}\n","import * as z from 'zod';\n\nexport const FileCreateEvent = z.object({\n  event: z.literal('file_create'),\n  content: z.string(),\n  href: z.string(),\n});\nexport type FileCreateEvent = z.infer<typeof FileCreateEvent>;\n\nexport const FileRemoveEvent = z.object({\n  event: z.literal('file_remove'),\n  href: z.string(),\n});\nexport type FileRemoveEvent = z.infer<typeof FileRemoveEvent>;\n\nexport const FileUpdateEvent = z.object({\n  event: z.literal('file_update'),\n  content: z.string(),\n  href: z.string(),\n});\nexport type FileUpdateEvent = z.infer<typeof FileUpdateEvent>;\n\nexport const EditorEvent = z.union([FileCreateEvent, FileRemoveEvent, FileUpdateEvent]);\nexport type EditorEvent = z.infer<typeof EditorEvent>;\n\nexport const EditorEvents = z.array(EditorEvent);\nexport type EditorEvents = z.infer<typeof EditorEvents>;\n\nexport const BuiltState = z.object({\n  state: z.literal('built'),\n  href: z.string(),\n  start: z.number().int(),\n  end: z.number().int(),\n});\nexport type BuiltState = z.infer<typeof BuiltState>;\n\nexport const BuildingState = z.object({\n  state: z.literal('building'),\n  completed: z.number(),\n  pending: z.number(),\n});\nexport type BuildingState = z.infer<typeof BuildingState>;\n\nexport const ErrorState = z.object({\n  state: z.literal('error'),\n  error: z.object({\n    message: z.string(),\n  }),\n});\nexport type ErrorState = z.infer<typeof ErrorState>;\n\nexport const InitialState = z.object({\n  state: z.literal('initial'),\n});\nexport type InitialState = z.infer<typeof InitialState>;\n\nexport const WorkerState = z.union([BuildingState, BuiltState, ErrorState, InitialState]);\nexport type WorkerState = z.infer<typeof WorkerState>;\n","module.exports = __webpack_public_path__ + \"static/js/0.26226417.chunk.worker.js\"","var charToInteger = {};\nvar chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\nfor (var i = 0; i < chars.length; i++) {\n    charToInteger[chars.charCodeAt(i)] = i;\n}\nfunction decode(mappings) {\n    var decoded = [];\n    var line = [];\n    var segment = [\n        0,\n        0,\n        0,\n        0,\n        0,\n    ];\n    var j = 0;\n    for (var i = 0, shift = 0, value = 0; i < mappings.length; i++) {\n        var c = mappings.charCodeAt(i);\n        if (c === 44) { // \",\"\n            segmentify(line, segment, j);\n            j = 0;\n        }\n        else if (c === 59) { // \";\"\n            segmentify(line, segment, j);\n            j = 0;\n            decoded.push(line);\n            line = [];\n            segment[0] = 0;\n        }\n        else {\n            var integer = charToInteger[c];\n            if (integer === undefined) {\n                throw new Error('Invalid character (' + String.fromCharCode(c) + ')');\n            }\n            var hasContinuationBit = integer & 32;\n            integer &= 31;\n            value += integer << shift;\n            if (hasContinuationBit) {\n                shift += 5;\n            }\n            else {\n                var shouldNegate = value & 1;\n                value >>>= 1;\n                if (shouldNegate) {\n                    value = value === 0 ? -0x80000000 : -value;\n                }\n                segment[j] += value;\n                j++;\n                value = shift = 0; // reset\n            }\n        }\n    }\n    segmentify(line, segment, j);\n    decoded.push(line);\n    return decoded;\n}\nfunction segmentify(line, segment, j) {\n    // This looks ugly, but we're creating specialized arrays with a specific\n    // length. This is much faster than creating a new array (which v8 expands to\n    // a capacity of 17 after pushing the first item), or slicing out a subarray\n    // (which is slow). Length 4 is assumed to be the most frequent, followed by\n    // length 5 (since not everything will have an associated name), followed by\n    // length 1 (it's probably rare for a source substring to not have an\n    // associated segment data).\n    if (j === 4)\n        line.push([segment[0], segment[1], segment[2], segment[3]]);\n    else if (j === 5)\n        line.push([segment[0], segment[1], segment[2], segment[3], segment[4]]);\n    else if (j === 1)\n        line.push([segment[0]]);\n}\nfunction encode(decoded) {\n    var sourceFileIndex = 0; // second field\n    var sourceCodeLine = 0; // third field\n    var sourceCodeColumn = 0; // fourth field\n    var nameIndex = 0; // fifth field\n    var mappings = '';\n    for (var i = 0; i < decoded.length; i++) {\n        var line = decoded[i];\n        if (i > 0)\n            mappings += ';';\n        if (line.length === 0)\n            continue;\n        var generatedCodeColumn = 0; // first field\n        var lineMappings = [];\n        for (var _i = 0, line_1 = line; _i < line_1.length; _i++) {\n            var segment = line_1[_i];\n            var segmentMappings = encodeInteger(segment[0] - generatedCodeColumn);\n            generatedCodeColumn = segment[0];\n            if (segment.length > 1) {\n                segmentMappings +=\n                    encodeInteger(segment[1] - sourceFileIndex) +\n                        encodeInteger(segment[2] - sourceCodeLine) +\n                        encodeInteger(segment[3] - sourceCodeColumn);\n                sourceFileIndex = segment[1];\n                sourceCodeLine = segment[2];\n                sourceCodeColumn = segment[3];\n            }\n            if (segment.length === 5) {\n                segmentMappings += encodeInteger(segment[4] - nameIndex);\n                nameIndex = segment[4];\n            }\n            lineMappings.push(segmentMappings);\n        }\n        mappings += lineMappings.join(',');\n    }\n    return mappings;\n}\nfunction encodeInteger(num) {\n    var result = '';\n    num = num < 0 ? (-num << 1) | 1 : num << 1;\n    do {\n        var clamped = num & 31;\n        num >>>= 5;\n        if (num > 0) {\n            clamped |= 32;\n        }\n        result += chars[clamped];\n    } while (num > 0);\n    return result;\n}\n\nexport { decode, encode };\n//# sourceMappingURL=sourcemap-codec.es.js.map\n","abstract class BaseError extends Error {\n  readonly name = this.constructor.name;\n}\n\nexport class GraphBuildError extends BaseError {\n  constructor(readonly errors: Error[]) {\n    super(\n      `Graph building failed with errors:\\n${errors.map((err) => `  ${err.message}`).join('\\n')}`\n    );\n  }\n}\n","import { Base64 } from '@velcro/common';\nimport type { DecodedSourceMap } from 'magic-string';\nimport { decode } from 'sourcemap-codec';\n\nexport class SourceMap {\n  readonly file?: string;\n  readonly mappings: string;\n  readonly sourceRoot?: string;\n  readonly names: string[];\n  readonly sources: (string | null)[];\n  readonly sourcesContent?: (string | null)[];\n  readonly version: number;\n\n  constructor(input: {\n    file?: string;\n    mappings: string;\n    sourceRoot?: string;\n    names: string[];\n    sources: (string | null)[];\n    sourcesContent?: (string | null)[];\n    version: string | number;\n  }) {\n    this.file = input.file;\n    this.mappings = input.mappings;\n    this.sourceRoot = input.sourceRoot;\n    this.names = input.names;\n    this.sources = input.sources;\n    this.sourcesContent = input.sourcesContent;\n    this.version = input.version as number | 0;\n  }\n\n  toString() {\n    return JSON.stringify(this);\n  }\n\n  toDataUri() {\n    return `data:application/json;charset=utf-8;base64,${Base64.encode(this.toString())}`;\n  }\n}\n\nfunction getSourceMappingUrlMatch(str: string) {\n  const re = /(?:(?:\\/\\/|\\/\\*)[@#][\\s]*(?:source)MappingURL=([^\\s'\"]+)[\\s]*$)|(?:\\/\\*[@#][\\s]*(?:source)MappingURL=([^\\s*'\"]+)[\\s]*(?:\\*\\/)[\\s]*$)/gm;\n  // Keep executing the search to find the *last* sourceMappingURL to avoid\n  // picking up sourceMappingURLs from comments, strings, etc.\n  let lastMatch: RegExpExecArray | null = null;\n  let match: RegExpExecArray | null;\n\n  while ((match = re.exec(str))) lastMatch = match;\n\n  return lastMatch;\n}\n\nexport function getSourceMappingUrl(str: string) {\n  const lastMatch = getSourceMappingUrlMatch(str);\n\n  if (!lastMatch) return '';\n\n  return lastMatch[1];\n}\n\nexport function updateSourceMappingUrl(str: string, url: string) {\n  const lastMatch = getSourceMappingUrlMatch(str);\n\n  if (!lastMatch) return str;\n\n  return str.slice(0, lastMatch.index) + str.slice(lastMatch.index).replace(lastMatch[1], url);\n}\n\nexport function decodeDataUriAsSourceMap(href: string): DecodedSourceMap | null {\n  const match = href.match(/^data:application\\/json;(?:charset=([^;]+);)?base64,(.*)$/);\n\n  if (match) {\n    if (match[1] && match[1] !== 'utf-8') {\n      return null;\n    }\n\n    try {\n      const decoded = JSON.parse(Base64.decode(match[2]));\n\n      if (decoded.mappings === '') {\n        return {\n          file: '',\n          mappings: [],\n          names: [],\n          sources: [],\n          sourcesContent: [],\n        };\n      }\n\n      if (typeof decoded.mappings === 'string') {\n        decoded.mappings = decode(decoded.mappings);\n      }\n\n      return decoded;\n    } catch (err) {\n      return null;\n    }\n  }\n\n  return null;\n}\n","import type { SourceMapSegment } from 'magic-string';\nimport { decode } from 'sourcemap-codec';\n\nexport interface ISourceMapper {\n  traceMappings(): ReturnType<typeof traceMappings>;\n}\n\n/**\n * Copyright (c) Rollup 2020 authors: https://github.com/rollup/rollup/graphs/contributors)\n *\n * Copied with light modifications from:\n * https://github.com/rollup/rollup/blob/36a4527473ea1fe678ed866c9f8dfd3c2542cd22/src/utils/collapseSourcemaps.ts\n */\n\nexport class Source {\n  content: string | null;\n  filename: string;\n\n  constructor(filename: string, content: string | null) {\n    this.filename = filename;\n    this.content = content;\n  }\n\n  traceSegment(line: number, column: number, name?: string): SourceMapSegmentObject {\n    return { line, column, name, source: this };\n  }\n}\n\ninterface SourceMapSegmentObject {\n  column: number;\n  line: number;\n  name?: string;\n  source: Source;\n}\n\nexport class Link {\n  mappings: SourceMapSegment[][];\n  names: string[];\n  sources: (Source | Link)[];\n\n  constructor(\n    map: { mappings: SourceMapSegment[][] | string; names: string[] },\n    sources: (Source | Link)[]\n  ) {\n    this.sources = sources;\n    this.names = map.names;\n    this.mappings = typeof map.mappings === 'string' ? decode(map.mappings) : map.mappings;\n  }\n\n  traceMappings() {\n    return traceMappings(this);\n  }\n\n  traceSegment(line: number, column: number, name: string): SourceMapSegmentObject | null {\n    return traceSegment(this, line, column, name);\n  }\n}\n\nexport class LazyLink {\n  private link?: Link = undefined;\n\n  constructor(private readonly loadLink: () => Link) {}\n\n  private getLink() {\n    let link = this.link;\n\n    if (!link) {\n      link = this.loadLink();\n      this.link = link;\n    }\n\n    return link;\n  }\n\n  traceMappings() {\n    return traceMappings(this.getLink());\n  }\n\n  traceSegment(line: number, column: number, name: string): SourceMapSegmentObject | null {\n    return traceSegment(this.getLink(), line, column, name);\n  }\n}\n\nfunction traceMappings(\n  this: void,\n  map: { mappings: SourceMapSegment[][]; names: string[]; sources: (Link | Source)[] }\n) {\n  const sources: string[] = [];\n  const sourcesContent: (string | null)[] = [];\n  const names: string[] = [];\n  const mappings = [];\n\n  for (const line of map.mappings) {\n    const tracedLine: SourceMapSegment[] = [];\n\n    for (const segment of line) {\n      if (segment.length == 1) continue;\n      const source = map.sources[segment[1]];\n      if (!source) continue;\n\n      const traced = source.traceSegment(\n        segment[2],\n        segment[3],\n        segment.length === 5 ? map.names[segment[4]] : ''\n      );\n\n      if (traced) {\n        // newer sources are more likely to be used, so search backwards.\n        let sourceIndex = sources.lastIndexOf(traced.source.filename);\n        if (sourceIndex === -1) {\n          sourceIndex = sources.length;\n          sources.push(traced.source.filename);\n          sourcesContent[sourceIndex] = traced.source.content;\n        } else if (sourcesContent[sourceIndex] == null) {\n          sourcesContent[sourceIndex] = traced.source.content;\n        } else if (\n          traced.source.content != null &&\n          sourcesContent[sourceIndex] !== traced.source.content\n        ) {\n          return new Error(\n            `Multiple conflicting contents for sourcemap source ${traced.source.filename}`\n          );\n        }\n\n        const tracedSegment: SourceMapSegment = [\n          segment[0],\n          sourceIndex,\n          traced.line,\n          traced.column,\n        ];\n\n        if (traced.name) {\n          let nameIndex = names.indexOf(traced.name);\n          if (nameIndex === -1) {\n            nameIndex = names.length;\n            names.push(traced.name);\n          }\n\n          (tracedSegment as SourceMapSegment)[4] = nameIndex;\n        }\n\n        tracedLine.push(tracedSegment);\n      }\n    }\n\n    mappings.push(tracedLine);\n  }\n\n  return { sources, sourcesContent, names, mappings };\n}\n\nfunction traceSegment(\n  this: void,\n  map: { mappings: SourceMapSegment[][]; names: string[]; sources: (Link | Source)[] },\n  line: number,\n  column: number,\n  name: string\n): SourceMapSegmentObject | null {\n  const segments = map.mappings[line];\n  if (!segments) return null;\n\n  // binary search through segments for the given column\n  let i = 0;\n  let j = segments.length - 1;\n\n  const checks = [];\n\n  while (i <= j) {\n    const m = (i + j) >> 1;\n    const segment = segments[m];\n    checks.push(segment);\n    if (segment[0] === column) {\n      if (segment.length == 1) return null;\n      const source = map.sources[segment[1]];\n      if (!source) return null;\n\n      return source.traceSegment(\n        segment[2],\n        segment[3],\n        segment.length === 5 ? map.names[segment[4]] : name\n      );\n    }\n    if (segment[0] > column) {\n      j = m - 1;\n    } else {\n      i = m + 1;\n    }\n  }\n\n  return null;\n}\n/**\n * This function attempts to compensate for the loss of precision when lower\n * layers of source maps have higher precision than upper layers, leading to\n * a loss of fidelity.\n *\n * The code was lifted from [Alec Larson](https://github.com/aleclarson)'s\n * [fork of sorcery](https://github.com/aleclarson/sorcery/blob/3934a3f38a6d8604fc9dbaa576cbb6e4d733040f/src/blend.js).\n *\n * NOTE: This function mutates the given node.\n *\n * @copyright [Alec Larson](https://github.com/aleclarson) 2018\n */\n// function blend(node: Link) {\n//   let mappings: SourceMapSegment[][] = []; // traced lines\n//   let sources: (Link | Source)[] = []; // traced sources\n//   let names: string[] = []; // traced symbols\n\n//   // Precompute which source/line/column triples are mapped by the given node.\n//   // These references are useful when interweaving old segments.\n//   const refs: number[][][] = Object.keys(node.sources).map(() => []);\n\n//   for (const segments of node.mappings) {\n//     let segment: SourceMapSegment;\n//     let lines: number[][];\n//     let columns: number[];\n//     for (let i = 0; i < segments.length; i++) {\n//       segment = segments[i];\n\n//       if (segment.length === 4 || segment.length === 5) {\n//         lines = refs[segment[1]];\n//         if (!lines) refs[segment[1]] = lines = [];\n\n//         columns = lines[segment[2]];\n//         if (columns) {\n//           uniqueAscendingInsert(columns, segment[3]);\n//         } else {\n//           lines[segment[2]] = [segment[3]];\n//         }\n//       }\n//     }\n//   }\n\n//   let traced: SourceMapSegment[] | undefined = undefined; // the traced line mapping\n//   let untraced: SourceMapSegment[] | undefined = undefined; // the untraced line mapping\n\n//   function addSegment(\n//     segment: SourceMapSegment,\n//     source?: { names: string[]; sources: (Link | Source)[] }\n//   ) {\n//     if (source) {\n//       segment[1] = uniq<Link | Source>(sources, source.sources[segment[1]!]);\n//       if (segment.length === 5) {\n//         segment[4] = uniq(names, source.names[segment[4]]);\n//       }\n//     } else if (segment.length === 5) {\n//       segment[4] = uniq(names, node.names[segment[4]]);\n//     }\n//     traced!.push(segment);\n//   }\n\n//   let tracedLine: number; // the last traced line\n//   let generatedLine = -1; // the current line\n//   let sourceIndex: number | undefined = -1; // source of last traced segment\n//   let sourceLine: number | undefined = undefined; // source line of last traced segment\n\n//   // Find the next line with segments.\n//   function nextLine() {\n//     tracedLine = generatedLine;\n//     while (++generatedLine < node.mappings.length) {\n//       untraced = node.mappings[generatedLine];\n//       if (untraced.length) return true;\n//     }\n//   }\n\n//   // Provide mappings for lines between the\n//   // last traced line and the current line.\n//   function fillSkippedLines() {\n//     const skipped = generatedLine - (tracedLine + 1);\n//     if (skipped !== 0) {\n//       let line = tracedLine;\n\n//       // Take line mappings from the current source.\n//       if (sourceIndex !== -1) {\n//         const source = node.sources[sourceIndex!];\n//         if (source instanceof Link) {\n//           while (line < generatedLine - 1) {\n//             if (++sourceLine! !== source.mappings.length) {\n//               mappings[++line] = traced = [];\n\n//               // Check referenced columns to avoid duplicate segments.\n//               const columns = refs[sourceIndex!][sourceLine!] || [];\n//               let prevColumn = -1;\n\n//               // Interweave old segments from the current source.\n//               const segments = source.mappings[sourceLine!];\n//               for (let i = 0; i < segments.length; i++) {\n//                 const segment = segments[i];\n//                 if (!hasValueBetween(columns, prevColumn, segment[0] + 1)) {\n//                   addSegment([...segment] as SourceMapSegment, source);\n//                   prevColumn = segment[0];\n//                 } else break;\n//               }\n//             } else {\n//               // End of source file.\n//               sourceIndex = -1;\n//               break;\n//             }\n//           }\n//         }\n//       }\n\n//       // Default to empty arrays for unmapped lines.\n//       while (++line < generatedLine) {\n//         mappings[line] = [];\n//       }\n//     }\n//   }\n\n//   while (nextLine()) {\n//     fillSkippedLines();\n\n//     // Trace the segments of this generated line.\n//     mappings[generatedLine] = traced = [];\n\n//     // Interweave old segments before the first mapped column of each line.\n//     const sourceColumn = untraced![0][3];\n//     if (sourceIndex !== -1 && sourceColumn !== 0) {\n//       const source = node.sources[sourceIndex];\n//       if (source instanceof Link) {\n//         const segments =\n//           sourceLine! < source.mappings.length - 1 ? source.mappings[++sourceLine!] : [];\n\n//         for (let i = 0; i < segments.length; i++) {\n//           const segment = segments[i];\n//           if (segment[0] < sourceColumn!) {\n//             addSegment(segment.slice(0) as SourceMapSegment, source);\n//           } else break;\n//         }\n//       }\n//     }\n\n//     const last = untraced!.length - 1;\n//     untraced!.forEach((curr: SourceMapSegment | null, i) => {\n//       [, sourceIndex, sourceLine] = curr!;\n\n//       const source = node.sources[sourceIndex!];\n//       if (source === null) {\n//         curr![1] = uniq(sources, null);\n//         return addSegment(curr!);\n//       }\n//       if (!(source instanceof Link)) {\n//         curr![1] = uniq(sources, source);\n//         return addSegment(curr!);\n//       }\n\n//       const next = i !== last ? untraced![i + 1] : null;\n//       const sourceColumn = curr![3];\n//       const generatedColumn = curr![0];\n\n//       // Find the first segment with a greater column.\n//       const segments = source.mappings[sourceLine!] || [];\n//       let j = findGreaterColumn(segments, sourceColumn!);\n\n//       // A \"base segment\" is required for tracing to a grand-parent.\n//       let base;\n//       if (--j !== -1) {\n//         base = segments[j];\n//         curr![1] = uniq(sources, source.sources[base[1]!]);\n//         curr![2] = base[2];\n//         curr![3] = base[3]! + sourceColumn! - base[0];\n//         if (base.length === 5) {\n//           // Inherit the names of aligned base segments.\n//           if (base[0] === sourceColumn) {\n//             curr![4] = uniq(names, source.names[base[4]!]);\n//           }\n//         } else if (curr!.length === 5) {\n//           // When our segment is named and the base segment is not,\n//           // assume this segment cannot be traced to its original source.\n//           if (base[0] !== sourceColumn) curr = null;\n//         }\n//       } else {\n//         curr![1] = uniq(sources, null);\n//       }\n\n//       curr && addSegment(curr);\n\n//       // Check referenced columns to avoid duplicate segments.\n//       const columns = refs[sourceIndex!][sourceLine!] || [];\n//       let baseColumn = base ? base[0] : -1;\n\n//       // Interweave old segments between our current and next segments.\n//       const nextColumn = next ? next[0] : 1 / 0;\n//       while (++j < segments.length) {\n//         let segment = segments[j];\n\n//         // The generated column is shifted to fit into the root source map.\n//         const column = segment[0] + generatedColumn - sourceColumn!;\n//         if (column >= nextColumn) break;\n\n//         // Avoid duplicates by checking if this segment goes elsewhere.\n//         if (!hasValueBetween(columns, baseColumn, segment[0] + 1)) {\n//           baseColumn = segment[0];\n//           segment = segment.slice(0) as SourceMapSegment;\n//           segment[0] = column;\n//           addSegment(segment, source);\n//         } else break;\n//       }\n//     });\n//   }\n//   fillSkippedLines();\n\n//   node.mappings = mappings;\n//   node.sources = sources;\n//   node.names = names;\n//   return node;\n// }\n\n// // Check if a value exists before pushing it to an array.\n// // Return the new or existing index of the value.\n// function uniq<T>(arr: T[], val: T): number {\n//   const i = arr.indexOf(val);\n//   return ~i ? i : arr.push(val) - 1;\n// }\n\n// // Get the first segment with a greater column.\n// function findGreaterColumn(segments: SourceMapSegment[], column: number) {\n//   let low = 0,\n//     high = segments.length;\n//   while (low < high) {\n//     const mid = (low + high) >>> 1;\n//     segments[mid][0] <= column ? (low = mid + 1) : (high = mid);\n//   }\n//   return low;\n// }\n\n// // The range is exclusive.\n// function hasValueBetween(arr: number[], start: number, end: number) {\n//   let low = 0,\n//     high = arr.length;\n//   while (low < high) {\n//     const mid = (low + high) >>> 1;\n//     const val = arr[mid];\n//     if (val <= start) {\n//       low = mid + 1;\n//     } else if (val >= end) {\n//       high = mid;\n//     } else {\n//       return true;\n//     }\n//   }\n//   return false;\n// }\n\n// // Insert unique values in ascending order.\n// function uniqueAscendingInsert(arr: number[], val: number) {\n//   let low = 0,\n//     high = arr.length;\n//   while (low < high) {\n//     const mid = (low + high) >>> 1;\n//     const x = arr[mid];\n//     if (x === val) return;\n//     if (x < val) {\n//       low = mid + 1;\n//     } else {\n//       high = mid;\n//     }\n//   }\n//   arr.splice(low, 0, val);\n// }\n","import type { Uri } from '@velcro/common';\n\nexport enum SourceModuleDependencyKind {\n  Entrypoint = 'Entrypoint',\n  Require = 'Require',\n  RequireResolve = 'RequireResolve',\n  GlobalObject = 'GlobalObject',\n}\n\ninterface SourceModuleOptions {\n  exportName?: string;\n}\n\ntype SourceLocation = { start: number; end: number };\n\nexport class SourceModuleDependency {\n  locator?: { name: string; spec: string; path: string; version?: string };\n\n  constructor(\n    readonly kind: SourceModuleDependencyKind,\n    readonly spec: string,\n    readonly locations: ReadonlyArray<SourceLocation>,\n    readonly options: SourceModuleOptions = {}\n  ) {}\n\n  static areIdentical(l: SourceModuleDependency, r: SourceModuleDependency) {\n    return l.kind === r.kind && l.spec === r.spec;\n  }\n\n  static fromEntrypoint(uri: Uri) {\n    return new SourceModuleDependency(SourceModuleDependencyKind.Entrypoint, uri.toString(), []);\n  }\n\n  static fromGlobalObject(spec: string, locations: SourceLocation[], exportName?: string) {\n    return new SourceModuleDependency(SourceModuleDependencyKind.GlobalObject, spec, locations, {\n      exportName,\n    });\n  }\n\n  static fromRequire(spec: string, locations: SourceLocation[]) {\n    return new SourceModuleDependency(SourceModuleDependencyKind.Require, spec, locations);\n  }\n\n  static fromRequireResolve(spec: string, locations: SourceLocation[]) {\n    return new SourceModuleDependency(SourceModuleDependencyKind.RequireResolve, spec, locations);\n  }\n}\n","import {\n  checkCancellation,\n  DependencyNotFoundError,\n  EntryExcludedError,\n  EntryNotFoundError,\n  isThenable,\n  Uri,\n} from '@velcro/common';\nimport type { ResolverContext } from '@velcro/resolver';\nimport MagicString from 'magic-string';\nimport type { DecodedSourceMap, SourceMap } from 'magic-string';\nimport {\n  decodeDataUriAsSourceMap,\n  getSourceMappingUrl,\n  updateSourceMappingUrl,\n} from '../build/sourceMap';\nimport { Link, Source } from '../build/sourceMapTree';\nimport type { SourceModule, SourceModuleDependency } from '../graph';\nimport type {\n  Plugin,\n  PluginLoadContext,\n  PluginResolveDependencyContext,\n  PluginResolveEntrypointContext,\n  PluginTransformContext,\n} from './plugin';\n\nexport class PluginManager {\n  constructor(private readonly plugins: Plugin[]) {\n    this.plugins.push({\n      name: 'builtIn',\n      load: async (ctx, id) => {\n        const uri = Uri.parse(id);\n        const readReturn = ctx.resolver.readFileContent(uri);\n        const readResult = isThenable(readReturn)\n          ? await checkCancellation(readReturn, ctx.token)\n          : readReturn;\n\n        return {\n          code: ctx.resolver.decode(readResult.content),\n          visited: readResult.visited,\n        };\n      },\n      resolveDependency: async (ctx, dependency, fromSourceModule) => {\n        const resolveReturn = ctx.resolver.resolve(dependency.spec, fromSourceModule.uri);\n        const resolveResult = isThenable(resolveReturn)\n          ? await checkCancellation(resolveReturn, ctx.token)\n          : resolveReturn;\n\n        if (!resolveResult.found) {\n          throw new DependencyNotFoundError(dependency.spec, fromSourceModule);\n        }\n\n        if (!resolveResult.uri) {\n          // TODO: Inject empty module\n          throw new EntryExcludedError(dependency.spec);\n        }\n\n        return {\n          uri: resolveResult.uri,\n          rootUri: resolveResult.rootUri,\n          visited: resolveResult.visited,\n        };\n      },\n      resolveEntrypoint: async (ctx, uri) => {\n        const resolveResult = await ctx.resolver.resolve(uri);\n\n        if (!resolveResult.found) {\n          throw new EntryNotFoundError(`Entry point not found: ${uri}`);\n        }\n\n        if (!resolveResult.uri) {\n          throw new EntryExcludedError(uri);\n        }\n\n        return resolveResult;\n      },\n      transform: async ({ createMagicString }, id) => {\n        if (id.path.endsWith('.json')) {\n          const magicString = createMagicString();\n          magicString.prepend('module.exports = ');\n\n          return {\n            code: magicString.toString(),\n            sourceMap: magicString.generateDecodedMap(),\n          };\n        }\n      },\n    });\n  }\n\n  async executeLoad(ctx: PluginLoadContext, uri: Uri) {\n    for (const plugin of this.plugins) {\n      if (typeof plugin.load === 'function') {\n        const loadReturn = plugin.load(ctx, uri.toString());\n        const loadResult = isThenable(loadReturn)\n          ? await checkCancellation(loadReturn, ctx.token)\n          : loadReturn;\n\n        if (!loadResult) {\n          continue;\n        }\n\n        return {\n          code: loadResult.code,\n          visited: loadResult.visited || [],\n        };\n      }\n    }\n\n    throw new Error(`No plugin was found that was able to load the uri ${uri.toString()}`);\n  }\n\n  async executeResolveDependency(\n    ctx: PluginResolveDependencyContext,\n    dependency: SourceModuleDependency,\n    fromModule: SourceModule\n  ) {\n    for (const plugin of this.plugins) {\n      if (typeof plugin.resolveDependency === 'function') {\n        const loadReturn = plugin.resolveDependency(ctx, dependency, fromModule);\n        const loadResult = isThenable(loadReturn)\n          ? await checkCancellation(loadReturn, ctx.token)\n          : loadReturn;\n\n        if (!loadResult) {\n          continue;\n        }\n\n        return {\n          uri: loadResult.uri,\n          rootUri: loadResult.rootUri,\n          visited: loadResult.visited || [],\n        };\n      }\n    }\n\n    throw new Error(\n      `No plugin was able to resolve the '${dependency.kind}' dependency, '${dependency.spec}' from '${fromModule.href}'`\n    );\n  }\n\n  async executeResolveEntrypoint(ctx: PluginResolveEntrypointContext, uri: Uri) {\n    for (const plugin of this.plugins) {\n      if (typeof plugin.resolveEntrypoint === 'function') {\n        const loadReturn = plugin.resolveEntrypoint(ctx, uri);\n        const loadResult = isThenable(loadReturn)\n          ? await checkCancellation(loadReturn, ctx.token)\n          : loadReturn;\n\n        if (!loadResult) {\n          continue;\n        }\n\n        return {\n          uri: loadResult.uri,\n          rootUri: loadResult.rootUri,\n          visited: loadResult.visited || [],\n        };\n      }\n    }\n\n    throw new Error(`No plugin was able to resolve the entrypoint '${uri.toString()}'`);\n  }\n\n  async executeTransform(\n    ctx: Omit<PluginTransformContext, 'createMagicString'>,\n    uri: Uri,\n    code: string | ArrayBuffer\n  ) {\n    if (typeof code !== 'string') {\n      code = ctx.resolver.decode(code);\n    }\n\n    const pluginCtx: PluginTransformContext = Object.assign(ctx, {\n      createMagicString() {\n        return new MagicString(code as string);\n      },\n    });\n\n    let sourceMapTree: Source | Link = new Source(uri.toString(), code);\n\n    // Figure out if our original code, itself has a sourcemap.\n    // For now, we will not recurse beyond that depth.\n    const sourceMapRef = getSourceMappingUrl(code);\n    if (sourceMapRef) {\n      let sourceMap: DecodedSourceMap | SourceMap | null = decodeDataUriAsSourceMap(sourceMapRef);\n\n      if (!sourceMap) {\n        const sourceMapUri = Uri.joinPath(uri, `../${sourceMapRef}`);\n\n        code = updateSourceMappingUrl(code, sourceMapUri.toString());\n      }\n\n      if (sourceMap) {\n        const sources = sourceMap.sources;\n        const sourcesContent = sourceMap.sourcesContent || [];\n        const baseSources = [] as Source[];\n\n        for (const idx in sources) {\n          if (sources[idx] && sourcesContent[idx]) {\n            baseSources.push(new Source(sources[idx]!, sourcesContent[idx]!));\n          }\n        }\n\n        sourceMapTree = new Link(sourceMap, baseSources);\n      }\n    }\n\n    const visited = [] as ResolverContext.Visit[];\n\n    for (const plugin of this.plugins) {\n      if (typeof plugin.transform === 'function') {\n        const transformReturn = plugin.transform(pluginCtx, uri, code);\n        const transformResult = isThenable(transformReturn)\n          ? await checkCancellation(transformReturn, ctx.token)\n          : transformReturn;\n\n        if (transformResult === null || transformResult === undefined) {\n          continue;\n        }\n\n        if (transformResult.sourceMap) {\n          sourceMapTree = new Link(transformResult.sourceMap, [sourceMapTree]);\n        }\n\n        code = transformResult.code;\n\n        if (transformResult.visited) {\n          visited.push(...transformResult.visited);\n        }\n      }\n    }\n\n    return {\n      code,\n      sourceMapTree,\n      visited,\n    };\n  }\n}\n","import * as Acorn from 'acorn';\nimport type {\n  ArrayPattern,\n  ArrowFunctionExpression,\n  AssignmentPattern,\n  BinaryExpression,\n  BlockStatement,\n  CallExpression,\n  ClassDeclaration,\n  Function,\n  FunctionDeclaration,\n  FunctionExpression,\n  Identifier,\n  IfStatement,\n  Literal,\n  MemberExpression,\n  Node,\n  ObjectPattern,\n  Program,\n  Property,\n  RestElement,\n  SimpleLiteral,\n  TemplateLiteral,\n  ThisExpression,\n  TryStatement,\n  UnaryExpression,\n  VariableDeclaration,\n} from 'estree';\n\nexport type NodeWithParent<TNode = Node> = TNode & {\n  parent: NodeWithParent | null;\n};\n\nexport interface StringLiteral extends SimpleLiteral {\n  value: string;\n}\n\nexport function isArrowFunctionExpression(node: Node): node is ArrowFunctionExpression {\n  return node.type === 'ArrowFunctionExpression';\n}\n\nexport function isArrayPattern(node: Node): node is ArrayPattern {\n  return node.type === 'ArrayPattern';\n}\n\nexport function isAssignmentPattern(node: Node): node is AssignmentPattern {\n  return node.type === 'AssignmentPattern';\n}\n\nexport function isBinaryExpression(node: Node): node is BinaryExpression {\n  return node.type === 'BinaryExpression';\n}\n\nexport function isBlockStatement(node: Node): node is BlockStatement {\n  return node.type === 'BlockStatement';\n}\n\nexport function isCallExpression(node: Node): node is CallExpression {\n  return node.type === 'CallExpression';\n}\n\nexport function isClassDeclaration(node: Node): node is ClassDeclaration {\n  return node.type === 'ClassDeclaration';\n}\n\nexport function isFunctionDeclaration(node: Node): node is FunctionDeclaration {\n  return node.type === 'FunctionDeclaration';\n}\n\nexport function isFunctionExpression(node: Node): node is FunctionExpression {\n  return node.type === 'FunctionExpression';\n}\n\nexport function isIdentifier(node: Node): node is Identifier {\n  return node.type === 'Identifier';\n}\n\nexport function isIfStatement(node: Node): node is IfStatement {\n  return node.type === 'IfStatement';\n}\n\nexport function isLiteral(node: Node): node is Literal {\n  return node.type === 'Literal';\n}\n\nexport function isMemberExpression(node: Node): node is MemberExpression {\n  return node.type === 'MemberExpression';\n}\n\nexport function isMethodDefinition(node: Node): node is MemberExpression {\n  return node.type === 'MethodDefinition';\n}\n\nexport function isObjectPattern(node: Node): node is ObjectPattern {\n  return node.type === 'ObjectPattern';\n}\n\nexport function isProperty(node: Node): node is Property {\n  return node.type === 'Property';\n}\n\nexport function isRestElement(node: Node): node is RestElement {\n  return node.type === 'RestElement';\n}\n\nexport function isProgram(node: Node): node is Program {\n  return node.type === 'Program';\n}\n\nexport function isTemplateLiteral(node: Node): node is TemplateLiteral {\n  return node.type === 'TemplateLiteral';\n}\n\nexport function isThisExpression(node: Node): node is ThisExpression {\n  return node.type === 'ThisExpression';\n}\n\nexport function isTryStatement(node: Node): node is TryStatement {\n  return node.type === 'TryStatement';\n}\n\nexport function isUnaryExpression(node: Node): node is UnaryExpression {\n  return node.type === 'UnaryExpression';\n}\n\nexport function isVariableDeclaration(node: Node): node is VariableDeclaration {\n  return node.type === 'VariableDeclaration';\n}\n\n// Refinements or groups\nexport function isFunction(node: Node): node is Function {\n  return (\n    isFunctionDeclaration(node) || isFunctionExpression(node) || isArrowFunctionExpression(node)\n  );\n}\n\nexport function isStringLiteral(node: Node): node is StringLiteral {\n  return isLiteral(node) && typeof node.value === 'string';\n}\n\nexport function parse(code: string, options?: acorn.Options) {\n  return (Acorn.parse(code, {\n    ...options,\n    allowReturnOutsideFunction: true,\n    sourceType: 'script',\n  }) as any) as Program;\n}\n","import type { Node } from 'estree';\nimport type { NodeWithParent } from './ast';\n\ntype VisitorContext = {\n  skip(): void;\n};\n\ntype EnterFunction<TContext> = (\n  this: VisitorContext,\n  node: NodeWithParent,\n  parent: NodeWithParent | null,\n  ctx: TContext,\n  prop?: string,\n  index?: number\n) => void;\ntype LeaveFunction<TContext> = (\n  node: NodeWithParent,\n  parent: NodeWithParent | null,\n  ctx: TContext,\n  prop?: string,\n  index?: number\n) => void;\n\nexport type Visitor<TContext> = {\n  enter?: EnterFunction<TContext>;\n  leave?: LeaveFunction<TContext>;\n};\n\nexport function traverse<TContext>(ast: Node, ctx: TContext, { enter, leave }: Visitor<TContext>) {\n  visit(ast as NodeWithParent, null, ctx, enter, leave);\n}\n\nlet shouldSkip = false;\nconst context = { skip: () => (shouldSkip = true) };\n\nexport const childKeys: {\n  [key: string]: string[];\n} = {};\n\nfunction visit<TContext>(\n  node: NodeWithParent,\n  parent: NodeWithParent | null,\n  ctx: TContext,\n  enter?: EnterFunction<TContext>,\n  leave?: LeaveFunction<TContext>\n  // prop?: string,\n  // index?: number\n) {\n  if (!node) return;\n\n  node.parent = parent;\n\n  if (enter) {\n    const _shouldSkip = shouldSkip;\n    shouldSkip = false;\n    enter.call(context, node, parent, ctx);\n    const skipped = shouldSkip;\n    shouldSkip = _shouldSkip;\n\n    if (skipped) return;\n  }\n\n  const keys =\n    childKeys[node.type] ||\n    (childKeys[node.type] = Object.keys(node).filter(\n      (key) => key !== 'parent' && typeof (node as any)[key] === 'object'\n    ));\n\n  const children = [] as NodeWithParent[];\n\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    const value = (node as any)[key] as NodeWithParent | NodeWithParent[];\n\n    if (Array.isArray(value)) {\n      for (let j = 0; j < value.length; j++) {\n        if (value[j]) children.push(value[j]);\n      }\n    } else if (value && value.type) {\n      children.push(value);\n    }\n  }\n\n  children.sort((a, b) => a.start - b.start);\n\n  for (const child of children) {\n    visit(child, node, ctx, enter, leave);\n  }\n\n  if (leave) {\n    leave(node, parent, ctx);\n  }\n}\n","import type { Uri } from '@velcro/common';\nimport type { BinaryOperator, Function, Identifier, MemberExpression, Node, Pattern } from 'estree';\nimport MagicString from 'magic-string';\nimport type { ParserFunction } from '../parsing';\nimport type { DEFAULT_SHIM_GLOBALS } from '../shims';\nimport { SourceModuleDependency } from '../sourceModuleDependency';\nimport {\n  isArrayPattern,\n  isArrowFunctionExpression,\n  isAssignmentPattern,\n  isBinaryExpression,\n  isBlockStatement,\n  isCallExpression,\n  isClassDeclaration,\n  isFunction,\n  isFunctionDeclaration,\n  isFunctionExpression,\n  isIdentifier,\n  isIfStatement,\n  isMemberExpression,\n  isMethodDefinition,\n  isObjectPattern,\n  isProgram,\n  isProperty,\n  isRestElement,\n  isStringLiteral,\n  isTemplateLiteral,\n  isThisExpression,\n  isTryStatement,\n  isUnaryExpression,\n  isVariableDeclaration,\n  NodeWithParent,\n  parse as parseAst,\n} from './ast';\nimport { traverse } from './traverse';\nimport type { Visitor } from './traverse';\n\ndeclare module 'estree' {\n  export interface BaseNodeWithoutComments {\n    start: number;\n    end: number;\n  }\n}\n\nexport const parse = function parseJavaScript(\n  uri: Uri,\n  code: string,\n  options: {\n    globalModules: typeof DEFAULT_SHIM_GLOBALS;\n    nodeEnv: string;\n  }\n): ReturnType<ParserFunction> {\n  const visitorCtx: DependencyVisitorContext = {\n    unboundSymbols: new Map(),\n    locals: new Map(),\n    magicString: new MagicString(code, { filename: uri.toString(), indentExclusionRanges: [] }),\n    nodeEnv: options.nodeEnv,\n    replacedSymbols: new Set<Identifier>(),\n    requires: [],\n    requireResolves: [],\n    skip: new Set(),\n    skipTransform: new Set(),\n  };\n  const dependencies = [] as SourceModuleDependency[];\n\n  try {\n    // let lastToken: Token | undefined;\n    const ast = parseAst(code, {\n      // onComment: (_isBlock, _test, start, end) => {\n      //   result.changes.push({ type: 'remove', start, end });\n      // },\n      // onInsertedSemicolon(lastTokEnd) {\n      //   result.changes.push({ type: 'appendRight', position: lastTokEnd, value: ';' });\n      // },\n      // onToken: (token) => {\n      //   const start = lastToken ? lastToken.end + 1 : 0;\n      //   const end = token.start;\n      //   if (end > start) {\n      //     result.changes.push({ type: 'remove', start, end });\n      //   }\n      //   lastToken = token;\n      // },\n    });\n\n    traverse(ast, visitorCtx, scopingAndRequiresVisitor);\n    traverse(ast, visitorCtx, collectGlobalsVisitor);\n  } catch (err) {\n    // console.debug(code);\n    // console.trace(err);\n    throw new Error(`Error parsing ${uri}: ${err.message}`);\n  }\n\n  // Handle explicit requires\n  const requiresBySpec = new Map<string, Array<{ start: number; end: number }>>();\n  for (const requireDependency of visitorCtx.requires) {\n    let locations = requiresBySpec.get(requireDependency.spec.value);\n    if (!locations) {\n      locations = [];\n      requiresBySpec.set(requireDependency.spec.value, locations);\n    }\n\n    locations.push({ start: requireDependency.spec.start, end: requireDependency.spec.end });\n  }\n  for (const [spec, locations] of requiresBySpec) {\n    dependencies.push(SourceModuleDependency.fromRequire(spec, locations));\n  }\n\n  // Handle require.resolve\n  const requireResolvesBySpec = new Map<string, Array<{ start: number; end: number }>>();\n  for (const requireDependency of visitorCtx.requireResolves) {\n    let locations = requiresBySpec.get(requireDependency.spec.value);\n    if (!locations) {\n      locations = [];\n      requiresBySpec.set(requireDependency.spec.value, locations);\n    }\n\n    locations.push({ start: requireDependency.spec.start, end: requireDependency.spec.end });\n  }\n  for (const [spec, locations] of requireResolvesBySpec) {\n    dependencies.push(SourceModuleDependency.fromRequireResolve(spec, locations));\n  }\n\n  for (const [symbolName, locations] of visitorCtx.unboundSymbols) {\n    const shim = options.globalModules[symbolName];\n\n    if (shim) {\n      dependencies.push(SourceModuleDependency.fromGlobalObject(shim.spec, locations, shim.export));\n\n      for (const location of locations) {\n        visitorCtx.magicString.overwrite(\n          location.start,\n          location.end,\n          `require(${JSON.stringify(`${shim.spec}`)})${shim.export ? `.${shim.export}` : ''}`\n        );\n      }\n    }\n  }\n\n  return {\n    code: visitorCtx.magicString,\n    dependencies,\n  };\n};\n\nexport type CommonJsRequire = {\n  callee: { start: number; end: number };\n  spec: { start: number; end: number; value: string };\n};\n\nexport type CommonJsRequireResolve = {\n  callee: { start: number; end: number };\n  spec: { start: number; end: number; value: string };\n};\n\nexport type DependencyVisitorContext = {\n  readonly unboundSymbols: Map<string, Node[]>;\n  readonly locals: Map<Node, { [identifier: string]: boolean }>;\n  readonly magicString: MagicString;\n  readonly nodeEnv: string;\n  readonly requires: CommonJsRequire[];\n  readonly replacedSymbols: Set<Identifier>;\n  readonly requireResolves: CommonJsRequireResolve[];\n  readonly skip: Set<Node>;\n  readonly skipTransform: Set<Node>;\n};\n\nexport const scopingAndRequiresVisitor: Visitor<DependencyVisitorContext> = {\n  enter(node, parent, ctx) {\n    // Get AST-node level locations in the source map\n    ctx.magicString.addSourcemapLocation(node.start);\n    ctx.magicString.addSourcemapLocation(node.end);\n\n    if (ctx.skip.has(node)) {\n      return this.skip();\n    }\n\n    visitAndCaptureScoping(node, parent, ctx);\n    visitAndSkipBranches(node, parent, ctx);\n    visitRequires(node, parent, ctx);\n  },\n  leave(node, _parent, ctx) {\n    let skipped = false;\n    let nextCheck: NodeWithParent<Node> | undefined = node;\n\n    while (nextCheck) {\n      if (ctx.skipTransform.has(nextCheck)) {\n        skipped = true;\n        break;\n      }\n\n      nextCheck = nextCheck.parent as NodeWithParent<Node> | undefined;\n    }\n\n    if (\n      !skipped &&\n      isMemberExpression(node) &&\n      memberExpressionMatches(node, 'process.env.NODE_ENV')\n    ) {\n      ctx.magicString.overwrite(node.start, node.end, JSON.stringify(ctx.nodeEnv), {\n        contentOnly: true,\n        storeName: true,\n      });\n      ctx.skip.add(node);\n      ctx.skipTransform.add(node);\n    }\n  },\n};\n\nexport const collectGlobalsVisitor: Visitor<DependencyVisitorContext> = {\n  enter(node, _parent, ctx) {\n    if (ctx.skip.has(node)) {\n      return this.skip();\n    }\n\n    if (isBindingIdentifier(node) && isIdentifier(node) && !isArgumentOfTypeOf(node)) {\n      var name = node.name;\n      if (name === 'undefined') return;\n      if (ctx.replacedSymbols.has(node)) {\n        return;\n      }\n\n      let foundBinding = false;\n      let nextParent = node.parent;\n\n      while (nextParent) {\n        if (name === 'arguments' && declaresArguments(nextParent)) {\n          foundBinding = true;\n          break;\n        }\n\n        const locals = ctx.locals.get(nextParent);\n\n        if (locals && locals[name]) {\n          foundBinding = true;\n          break;\n        }\n\n        nextParent = nextParent.parent;\n      }\n\n      if (!foundBinding) {\n        let unboundSymbols = ctx.unboundSymbols.get(name);\n        if (!unboundSymbols) {\n          unboundSymbols = [];\n          ctx.unboundSymbols.set(name, unboundSymbols);\n        }\n        unboundSymbols.push(node);\n      }\n    } else if (isThisExpression(node)) {\n      let foundBinding = false;\n      let nextParent = node.parent;\n\n      while (nextParent) {\n        if (declaresThis(nextParent)) {\n          foundBinding = true;\n          break;\n        }\n\n        nextParent = nextParent.parent;\n      }\n\n      if (!foundBinding) {\n        let unboundSymbols = ctx.unboundSymbols.get('this');\n        if (!unboundSymbols) {\n          unboundSymbols = [];\n          ctx.unboundSymbols.set('this', unboundSymbols);\n        }\n        unboundSymbols.push(node);\n      }\n    }\n  },\n};\n\nfunction visitAndCaptureScoping(\n  node: NodeWithParent,\n  _parent: NodeWithParent | null,\n  ctx: DependencyVisitorContext\n) {\n  if (isVariableDeclaration(node)) {\n    let parent: NodeWithParent | undefined;\n    let nextParent = node.parent;\n\n    while (nextParent) {\n      if (node.kind === 'var' ? isScope(nextParent) : isBlockScope(nextParent)) {\n        parent = nextParent;\n        break;\n      }\n\n      nextParent = nextParent.parent;\n    }\n\n    if (!parent) {\n      throw new Error(`Invariant violation: Failed to find a parent`);\n    }\n\n    let locals = ctx.locals.get(parent);\n\n    if (!locals) {\n      locals = {};\n      ctx.locals.set(parent, locals);\n    }\n\n    for (const declaration of node.declarations) {\n      declarePattern(declaration.id, locals);\n    }\n  } else if (isFunctionDeclaration(node)) {\n    let parent: NodeWithParent | undefined;\n    let nextParent = node.parent;\n\n    if (nextParent && nextParent.parent) {\n      nextParent = nextParent.parent;\n    }\n\n    while (nextParent) {\n      if (isScope(nextParent)) {\n        parent = nextParent;\n        break;\n      }\n\n      nextParent = nextParent.parent;\n    }\n\n    if (!parent) {\n      throw new Error(`Invariant violation: Failed to find a parent`);\n    }\n\n    let locals = ctx.locals.get(parent);\n\n    if (!locals) {\n      locals = {};\n      ctx.locals.set(parent, locals);\n    }\n\n    declareFunction(node, locals);\n  } else if (isFunction(node)) {\n    let locals = ctx.locals.get(node);\n\n    if (!locals) {\n      locals = {};\n      ctx.locals.set(node, locals);\n    }\n\n    declareFunction(node, locals);\n  } else if (isClassDeclaration(node) && node.id) {\n    let parent: NodeWithParent | undefined;\n    let nextParent = node.parent;\n\n    if (nextParent && nextParent.parent) {\n      nextParent = nextParent.parent;\n    }\n\n    while (nextParent) {\n      if (isScope(nextParent)) {\n        parent = nextParent;\n        break;\n      }\n\n      nextParent = nextParent.parent;\n    }\n\n    if (!parent) {\n      throw new Error(`Invariant violation: Failed to find a parent`);\n    }\n\n    let locals = ctx.locals.get(parent);\n\n    if (!locals) {\n      locals = {};\n      ctx.locals.set(parent, locals);\n    }\n\n    locals[node.id.name] = true;\n  } else if (isTryStatement(node)) {\n    if (node.handler) {\n      let locals = ctx.locals.get(node.handler);\n\n      if (!locals) {\n        locals = {};\n        ctx.locals.set(node.handler, locals);\n      }\n\n      if (node.handler.param) {\n        declarePattern(node.handler.param, locals);\n      }\n    }\n  }\n}\n\nfunction visitAndSkipBranches(\n  node: NodeWithParent,\n  _parent: NodeWithParent | null,\n  ctx: DependencyVisitorContext\n) {\n  if (isIfStatement(node) && isBinaryExpression(node.test)) {\n    const tests = {\n      '!=': (l: string, r: string) => l != r,\n      '!==': (l: string, r: string) => l !== r,\n      '==': (l: string, r: string) => l == r,\n      '===': (l: string, r: string) => l === r,\n    } as { [key in BinaryOperator]: (l: string, r: string) => boolean };\n    const test = tests[node.test.operator];\n\n    if (test) {\n      if (\n        isStringLiteral(node.test.left) &&\n        isMemberExpression(node.test.right) &&\n        memberExpressionMatches(node.test.right, 'process.env.NODE_ENV')\n      ) {\n        let rootObject = node.test.right;\n        while (isMemberExpression(rootObject.object)) {\n          rootObject = rootObject.object;\n        }\n        if (isIdentifier(rootObject.object)) {\n          ctx.replacedSymbols.add(rootObject.object);\n        }\n\n        ctx.skipTransform.add(node.test.right);\n\n        // if ('development' === process.env.NODE_ENV) {}\n\n        if (!test(node.test.left.value, ctx.nodeEnv)) {\n          ctx.skip.add(node.consequent);\n          // We can blow away the consequent\n          ctx.magicString.remove(\n            node.start,\n            node.alternate ? node.alternate.start : node.consequent.end\n          );\n        } else {\n          // We can blow away the test\n          ctx.magicString.remove(node.start, node.consequent.start - 1);\n\n          if (node.alternate) {\n            ctx.skip.add(node.alternate);\n            // We can blow away the alternate but we need to start and the end of the consequent + 1 char\n            ctx.magicString.remove(node.consequent.end + 1, node.alternate.end);\n          }\n        }\n      } else if (\n        isStringLiteral(node.test.right) &&\n        isMemberExpression(node.test.left) &&\n        memberExpressionMatches(node.test.left, 'process.env.NODE_ENV')\n      ) {\n        let rootObject = node.test.left;\n        while (isMemberExpression(rootObject.object)) {\n          rootObject = rootObject.object;\n        }\n        if (isIdentifier(rootObject.object)) {\n          ctx.replacedSymbols.add(rootObject.object);\n        }\n\n        ctx.skipTransform.add(node.test.left);\n\n        // if (process.env.NODE_ENV === 'development') {}\n\n        if (!test(node.test.right.value, ctx.nodeEnv)) {\n          ctx.skip.add(node.consequent);\n          // We can blow away the consequent\n          ctx.magicString.remove(\n            node.start,\n            node.alternate ? node.alternate.start : node.consequent.end\n          );\n        } else {\n          // We can blow away the test and the alternate\n          ctx.magicString.remove(node.start, node.consequent.start - 1);\n\n          if (node.alternate) {\n            ctx.skip.add(node.alternate);\n            // We can blow away the alternate but we need to start and the end of the consequent + 1 char\n            ctx.magicString.remove(node.consequent.end + 1, node.alternate.end);\n          }\n        }\n      }\n    }\n  }\n}\n\nfunction visitRequires(\n  node: NodeWithParent,\n  _parent: NodeWithParent | null,\n  ctx: DependencyVisitorContext\n) {\n  if (isCallExpression(node)) {\n    const callee = node.callee;\n    if (isIdentifier(callee) && callee.name === 'require') {\n      const firstArg = node.arguments[0];\n\n      if (isStringLiteral(firstArg)) {\n        ctx.requires.push({\n          spec: { start: firstArg.start, end: firstArg.end, value: firstArg.value },\n          callee: { start: callee.start, end: callee.end },\n        });\n      } else if (\n        isTemplateLiteral(firstArg) &&\n        firstArg.expressions.length === 0 &&\n        firstArg.quasis.length === 1\n      ) {\n        ctx.requires.push({\n          spec: {\n            start: firstArg.quasis[0].start,\n            end: firstArg.quasis[0].end,\n            value: firstArg.quasis[0].value.raw,\n          },\n          callee: { start: callee.start, end: callee.end },\n        });\n      } else {\n        console.warn('Non string-literal first arg to require', firstArg);\n      }\n    } else if (\n      isMemberExpression(callee) &&\n      isIdentifier(callee.object) &&\n      callee.object.name === 'require' &&\n      isIdentifier(callee.property) &&\n      callee.property.name === 'resolve'\n    ) {\n      const firstArg = node.arguments[0];\n\n      if (isStringLiteral(firstArg)) {\n        ctx.requireResolves.push({\n          spec: { start: firstArg.start, end: firstArg.end, value: firstArg.value },\n          callee: { start: callee.start, end: callee.end },\n        });\n      } else {\n        console.warn('Non string-literal first arg to require.resolve', firstArg);\n      }\n    }\n  }\n}\n\nfunction declareFunction(node: Function, locals: { [name: string]: boolean }) {\n  node.params.forEach(function (node) {\n    declarePattern(node, locals);\n  });\n  if ((node as any).id) {\n    locals[(node as any).id.name] = true;\n  }\n}\n\nfunction declarePattern(node: Pattern, locals: { [name: string]: boolean }) {\n  if (isIdentifier(node)) {\n    locals[node.name] = true;\n  } else if (isObjectPattern(node)) {\n    node.properties.forEach((node) =>\n      isRestElement(node)\n        ? declarePattern(node.argument, locals)\n        : declarePattern(node.value, locals)\n    );\n  } else if (isArrayPattern(node)) {\n    node.elements.forEach((node) => node && declarePattern(node, locals));\n  } else if (isRestElement(node)) {\n    declarePattern(node.argument, locals);\n  } else if (isAssignmentPattern(node)) {\n    declarePattern(node.left, locals);\n  } else {\n    throw new Error(`Invariant violation: Unexpected pattern type: ${node.type}`);\n  }\n}\n\nfunction isArgumentOfTypeOf(node: NodeWithParent) {\n  const parent = node.parent as Node;\n\n  return isUnaryExpression(parent) && parent.operator === 'typeof';\n}\n\nfunction isBindingIdentifier(node: NodeWithParent) {\n  return (\n    isIdentifier(node) &&\n    !isPropertyOfMemberExpression(node) &&\n    !isKeyOfProperty(node) &&\n    !isKeyOfMethodDefinition(node)\n  );\n}\n\nfunction isKeyOfProperty(node: NodeWithParent) {\n  return node.parent && isProperty(node.parent) && node.parent.key === node;\n}\n\nfunction isPropertyOfMemberExpression(node: NodeWithParent) {\n  return node.parent && isMemberExpression(node.parent) && node.parent.object !== node;\n}\n\nfunction isKeyOfMethodDefinition(node: NodeWithParent) {\n  return node.parent && isMethodDefinition(node.parent);\n}\n\nfunction isScope(node: NodeWithParent) {\n  return (\n    isFunctionDeclaration(node) ||\n    isFunctionExpression(node) ||\n    isArrowFunctionExpression(node) ||\n    isProgram(node)\n  );\n}\n\nfunction isBlockScope(node: NodeWithParent) {\n  return isBlockStatement(node) || isScope(node);\n}\n\nfunction declaresArguments(node: NodeWithParent) {\n  return isFunctionDeclaration(node) || isFunctionExpression(node);\n}\n\nfunction declaresThis(node: NodeWithParent) {\n  return isFunctionDeclaration(node) || isFunctionExpression(node);\n}\n\nfunction memberExpressionMatches(node: MemberExpression, pattern: string) {\n  const memberParts = pattern.split('.');\n\n  if (memberParts.length < 2) {\n    return false;\n  }\n\n  const object = memberParts.shift();\n  const property = memberParts.shift();\n\n  for (let i = memberParts.length - 1; i >= 0; i--) {\n    if (!isIdentifier(node.property) || node.property.name !== memberParts[i]) {\n      return false;\n    }\n\n    if (!isMemberExpression(node.object)) {\n      return false;\n    }\n\n    node = node.object;\n  }\n\n  if (!isIdentifier(node.object) || !isIdentifier(node.property)) {\n    return false;\n  }\n\n  return node.object.name === object && node.property.name === property;\n}\n","import type { Uri } from '@velcro/common';\nimport type { Bundle } from 'magic-string';\nimport { encode } from 'sourcemap-codec';\nimport { SourceMap } from './sourceMap';\nimport type { ISourceMapper } from './sourceMapTree';\n\nexport class ChunkOutput {\n  private cachedCode?: string;\n  private cachedSourceMap?: SourceMap;\n  private cachedSourceMapDataUri?: string;\n  private cachedSourceMapString?: string;\n\n  constructor(\n    private readonly bundle: Bundle,\n    private readonly sourceMapTree: ISourceMapper,\n    readonly uri: Uri\n  ) {}\n\n  get code() {\n    if (typeof this.cachedCode === 'undefined') {\n      this.cachedCode = this.bundle.toString();\n    }\n\n    return this.cachedCode!;\n  }\n\n  get href() {\n    return this.uri.toString();\n  }\n\n  get sourceMap() {\n    if (typeof this.cachedSourceMap === 'undefined') {\n      this.cachedSourceMap = this.generateSourceMap();\n    }\n\n    return this.cachedSourceMap!;\n  }\n\n  get sourceMapString() {\n    if (typeof this.cachedSourceMapString === 'undefined') {\n      this.cachedSourceMapString = this.sourceMap.toString();\n    }\n\n    return this.cachedSourceMapString!;\n  }\n\n  get sourceMapDataUri() {\n    if (typeof this.cachedSourceMapDataUri === 'undefined') {\n      this.cachedSourceMapDataUri = this.sourceMap.toDataUri();\n    }\n\n    return this.cachedSourceMapDataUri!;\n  }\n\n  private generateSourceMap() {\n    const sourceMapTreeMappings = this.sourceMapTree.traceMappings();\n\n    if (sourceMapTreeMappings instanceof Error) {\n      return new SourceMap({\n        file: this.href,\n        mappings: '',\n        names: [],\n        sources: [],\n        version: 3,\n        sourcesContent: [],\n      });\n    }\n\n    // Loop through generated mappings, removing mappings that are character-by-character increments\n    // from the previous mapping. Since we generated a hires bundle, this will shrink the resolution\n    // back down to something not unnecessarily large.\n    // for (const line of sourceMapTreeMappings.mappings) {\n    //   let lastSegment: SourceMapSegment | null = null;\n    //   const shrinkedLine: SourceMapSegment[] = [];\n\n    //   for (const segment of line) {\n    //     if (lastSegment && lastSegment.length >= 4 && lastSegment.length === segment.length) {\n    //       // We will only push the segment if it is not, effectively a direct cursor move of the\n    //       // last one.\n    //       // For example:\n    //       //   lastSegment = [1, 0, 0, 1] // Generated column 1, original column 1 of the 0th file, 0th line\n    //       //   segment = [2, 0, 0, 2] // Generated column 2, original column 2 of the 0th file, 0th line\n    //       // Given that, we can see that this segment is not adding any _new_ information so we can skip it.\n    //       if (\n    //         lastSegment.length >= 4 &&\n    //         (lastSegment[0] + 1 !== segment[0] ||\n    //           lastSegment[1] !== segment[1] ||\n    //           lastSegment[2] !== segment[2] ||\n    //           lastSegment[3]! + 1 !== segment[3] ||\n    //           lastSegment[4] !== segment[4])\n    //       ) {\n    //         shrinkedLine.push(segment);\n    //       }\n    //     } else {\n    //       shrinkedLine.push(segment);\n    //     }\n\n    //     lastSegment = segment;\n    //   }\n\n    //   // line.splice(0, line.length, ...shrinkedLine);\n    // }\n\n    const sourceMap = new SourceMap({\n      file: this.href,\n      mappings: encode(sourceMapTreeMappings.mappings),\n      names: sourceMapTreeMappings.names,\n      sources: sourceMapTreeMappings.sources,\n      version: 3,\n      sourcesContent: sourceMapTreeMappings.sourcesContent,\n    });\n\n    return sourceMap;\n  }\n}\n","import { MapSet, Uri } from '@velcro/common';\nimport { runtime } from '@velcro/runtime';\nimport { Bundle } from 'magic-string';\nimport type { DependencyEdge } from '../graph/dependencyEdge';\nimport type { SourceModule } from '../graph/sourceModule';\nimport type { VelcroImportMap, VelcroStaticRuntime } from '../runtime/types';\nimport { ChunkOutput } from './chunkOutput';\nimport { LazyLink, Link, Source } from './sourceMapTree';\n\ntype NotUndefined<T> = T extends undefined ? never : T;\n\nexport class Chunk {\n  private readonly edgesFrom = new MapSet<string, DependencyEdge>();\n  private readonly edgesTo = new MapSet<string, DependencyEdge>();\n  //@ts-ignore\n  private readonly rootUri: Uri;\n  private readonly sourceModules = new Map<string, SourceModule>();\n\n  constructor(options: Chunk.Options) {\n    this.rootUri = options.rootUri;\n\n    for (const sourceModule of options.sourceModules) {\n      this.sourceModules.set(sourceModule.href, sourceModule);\n    }\n\n    for (const edge of options.edges) {\n      const fromHref = edge.fromUri.toString();\n      const toHref = edge.toUri.toString();\n\n      this.edgesFrom.add(fromHref, edge);\n      this.edgesTo.add(toHref, edge);\n    }\n  }\n\n  buildForStaticRuntime(options?: Chunk.ToStringOptions) {\n    // const velcroModuleFactoryParts = velcroModuleFactory\n    //   .toString()\n    //   .split(velcroModuleFactory.splitString);\n    // const velcroChunkWrapperParts = velcroChunkWrapper\n    //   .toString()\n    //   .split(velcroChunkWrapper.splitString);\n\n    const bundle = new Bundle({\n      separator: '\\n',\n    });\n\n    for (const sourceModule of this.sourceModules.values()) {\n      const moduleScopes: NotUndefined<NotUndefined<VelcroImportMap['scopes']>[string]> = {};\n      const scopes: NotUndefined<VelcroImportMap['scopes']> = {\n        [sourceModule.href]: moduleScopes,\n      };\n      const importMap: VelcroImportMap = { scopes };\n      const edgesFrom = this.edgesFrom.get(sourceModule.href);\n\n      if (edgesFrom) {\n        for (const edge of edgesFrom) {\n          moduleScopes[edge.dependency.spec] = edge.toUri.toString();\n        }\n      }\n      const sourceModuleCode = sourceModule.source.clone();\n\n      sourceModuleCode.prepend(\n        `velcro.defs[${JSON.stringify(\n          sourceModule.uri.toString()\n        )}] = [function(module,exports,require,__dirname,__filename){\\n`\n      );\n      sourceModuleCode.append(`\\n},${JSON.stringify(importMap)}];`);\n      bundle.addSource(sourceModuleCode);\n    }\n\n    const velcroStaticRuntime: VelcroStaticRuntime = { defs: {} };\n\n    bundle.prepend(`(function(velcro){\\n`);\n    bundle.prepend(\n      `if (typeof Velcro === 'undefined') Velcro = Object.create(null);\\nif (typeof Velcro.registry === 'undefined') Velcro.registry = ${JSON.stringify(\n        velcroStaticRuntime\n      )};\\n`\n    );\n    bundle.append(`\\n})(Velcro.registry);\\n`);\n\n    if (options && options.injectRuntime) {\n      bundle.append(`\\n${runtime}(Velcro);\\n`);\n    }\n\n    if (options && options.invalidations) {\n      if (!options.injectRuntime) {\n        throw new Error(\n          'Setting injectRuntime to true is required when calling buildForStaticRuntime and specifying invalidations'\n        );\n      }\n\n      bundle.append(`\\nVelcro.runtime.invalidate(${JSON.stringify(options.invalidations)});\\n`);\n    }\n\n    const sourceMapTree = new LazyLink(() => {\n      const inputMap = bundle.generateDecodedMap({\n        includeContent: false,\n        hires: true,\n        source: this.rootUri.toString(),\n      });\n      return new Link(\n        inputMap,\n        inputMap.sources.map((sourceHref) => {\n          const sourceModule = this.sourceModules.get(sourceHref);\n\n          if (!sourceModule) {\n            return new Source(sourceHref, 'SOURCEMAP ERROR');\n          }\n\n          // All of the transformations included in the source module's magicString\n          // were baked into the bundle already. We just need to map these into any\n          // earlier sources.\n          return sourceModule.sourceMapsTree;\n        })\n      );\n    });\n\n    return new ChunkOutput(bundle, sourceMapTree, this.rootUri);\n  }\n}\n\nexport namespace Chunk {\n  export interface Options {\n    edges: Iterable<DependencyEdge>;\n    rootUri: Uri;\n    sourceModules: Iterable<SourceModule>;\n  }\n\n  export interface ToStringOptions {\n    /**\n     * Toggle whether to inject the runtime in the generated code.\n     *\n     * An instance of the runtime is important as it is what will actually schedule\n     * and execute code built for Velcro.\n     *\n     * When `injectRuntime` is `true`, the runtime code will be injected and the\n     * instance of it will be exposed as `Velcro.runtime`.\n     */\n    injectRuntime?: boolean;\n    invalidations?: string[];\n  }\n}\n","// This file is auto-generated. Do not edit.\n\nexport const runtime = \"(function(Velcro){var e=function(e,t,r){this.runtime=e,this.id=t,this.importMap=r,this.module={exports:{}},this.require=this.runtime.createRequire(this)},t=function(){function t(t){this.moduleDependents={},this.moduleInstances={},this.defs=t.defs,this.root=new e(this,\\\"velcro:/root\\\",{}),Object.defineProperty(this,\\\"require\\\",{enumerable:!0,value:this.root.require.bind(this.root)})}return t.prototype.createRequire=function(t){var r=this;function n(e){return r.resolveSpecAgainstImportMap(e,t)}return Object.assign((function(o){var i=n(o),s=r.moduleInstances[i];if(!s){var u=r.defs[i];if(!u)throw new Error(\\\"Unable to locate module '\\\"+i+\\\"' from '\\\"+t.id);var a=u[0],l=u[1];s=new e(r,i,l),r.moduleInstances[i]=s;var p=i.split(\\\"/\\\"),c=p.pop()||o,d=p.join(\\\"/\\\");a.call(s.module.exports,s.module,s.module.exports,s.require.bind(s),d,c)}return(r.moduleDependents[i]=r.moduleDependents[i]||[]).push(t),s.module.exports}),{resolve:n})},t.prototype.inject=function(t,r){var n=new e(this,t,Object.create(null));return n.module.exports=r,this.moduleInstances[t]=n,n},t.prototype.invalidate=function(e){for(var t=e.slice(),r=!1;t.length;){var n=t.shift();r=delete this.moduleInstances[n]||r;var o=this.moduleDependents[n];if(Array.isArray(o))for(var i=0;i<o.length;i++)t.push(o[i].id)}return r},t.prototype.resolveSpecAgainstImportMap=function(e,t){var r=t.importMap;if(!r.scopes)return e;var n=r.scopes[t.id];if(!n)return e;var o=n[e];return o||e},t.create=function(r){return r.runtime||(r.runtime=new t(r.registry)),r.Module=e,r.Runtime=t,r.runtime},t}();Velcro.runtime=t.create(Velcro);})\";\n","import { MapSet, Uri } from '@velcro/common';\nimport { Chunk } from '../build/chunk';\nimport type { DependencyEdge } from './dependencyEdge';\nimport type { SourceModule } from './sourceModule';\n\nexport class Graph {\n  private readonly edgesFrom = new MapSet<string, DependencyEdge>();\n  private readonly edgesTo = new MapSet<string, DependencyEdge>();\n  //@ts-ignore\n  private readonly rootUri: Uri;\n  private readonly sourceModules = new Map<string, SourceModule>();\n\n  constructor(options: Graph.Options) {\n    this.rootUri = options.rootUri;\n\n    for (const sourceModule of options.sourceModules) {\n      this.sourceModules.set(sourceModule.href, sourceModule);\n    }\n\n    for (const edge of options.edges) {\n      const fromHref = edge.fromUri.toString();\n      const toHref = edge.toUri.toString();\n\n      this.edgesFrom.add(fromHref, edge);\n      this.edgesTo.add(toHref, edge);\n    }\n  }\n\n  splitChunks(): Iterable<Chunk> {\n    return [\n      new Chunk({\n        edges: this.edgesFrom.values(),\n        rootUri: Uri.joinPath(this.rootUri, './chunk/0.js'),\n        sourceModules: this.sourceModules.values(),\n      }),\n    ];\n  }\n}\n\nexport namespace Graph {\n  export interface Options {\n    edges: Iterable<DependencyEdge>;\n    rootUri: Uri;\n    sourceModules: Iterable<SourceModule>;\n  }\n}\n","import { version as nodeLibsVersion } from '@velcro/node-libs/package.json';\n\nexport const DEFAULT_SHIM_GLOBALS: Record<\n  string,\n  { spec: string; export?: string } | undefined\n> = Object.assign(Object.create(null), {\n  Buffer: {\n    spec: `@velcro/node-libs@${nodeLibsVersion}/lib/buffer.js`,\n    export: 'Buffer',\n  },\n  global: {\n    spec: `@velcro/node-libs@${nodeLibsVersion}/lib/global.js`,\n  },\n  globalThis: {\n    spec: `@velcro/node-libs@${nodeLibsVersion}/lib/global.js`,\n  },\n  process: {\n    spec: `@velcro/node-libs@${nodeLibsVersion}/lib/process.js`,\n  },\n});\n","import type { Uri } from '@velcro/common';\nimport type { ResolverContext } from '@velcro/resolver';\nimport type MagicString from 'magic-string';\nimport type { Link, Source } from '../build/sourceMapTree';\nimport type { SourceModuleDependency } from './sourceModuleDependency';\n\nexport class SourceModule {\n  constructor(\n    readonly uri: Uri,\n    readonly rootUri: Uri,\n    readonly source: MagicString,\n    readonly dependencies: Set<SourceModuleDependency>,\n    readonly sourceMapsTree: Source | Link,\n    readonly visits: ResolverContext.Visit[]\n  ) {}\n\n  get href() {\n    return this.uri.toString();\n  }\n\n  get rootHref() {\n    return this.rootUri.toString();\n  }\n}\n","import {\n  CancellationToken,\n  CancellationTokenSource,\n  DisposableStore,\n  Emitter,\n  Event,\n  isCanceledError,\n  MapSet,\n  Uri,\n} from '@velcro/common';\nimport type { Resolver, ResolverContext } from '@velcro/resolver';\nimport { Plugin, PluginManager } from '../plugins';\nimport { parse } from './commonjs';\nimport type { DependencyEdge } from './dependencyEdge';\nimport { Graph } from './graph';\nimport { DEFAULT_SHIM_GLOBALS } from './shims';\nimport { SourceModule } from './sourceModule';\nimport { SourceModuleDependency } from './sourceModuleDependency';\n\ntype ExternalTestFunction = (\n  dependency: SourceModuleDependency,\n  fromSourceModule: SourceModule\n) => boolean;\n\nexport class Build {\n  private readonly disposer = new DisposableStore();\n  private readonly edges = new Set<DependencyEdge>();\n  readonly errors: Error[] = [];\n  readonly seen = new Set<unknown>();\n  private readonly sourceModules = new Map<string, SourceModule>();\n\n  private readonly pendingModuleOperations = new MapSet<string, Promise<unknown>>();\n  private readonly tokenSource: CancellationTokenSource;\n\n  private readonly onCompletedEmitter = new Emitter<{ graph: Graph }>();\n  private readonly onErrorEmitter = new Emitter<{ error: Error }>();\n  private readonly onProgressEmitter = new Emitter<{\n    progress: {\n      completed: number;\n      pending: number;\n    };\n  }>();\n\n  readonly done = new Promise<Graph>((resolve, reject) => {\n    this.disposer.add(this.onCompleted(({ graph }) => resolve(graph)));\n    this.disposer.add(this.onError(({ error }) => reject(error)));\n  });\n\n  constructor(readonly rootUri: Uri, options: { token?: CancellationToken } = {}) {\n    this.tokenSource = new CancellationTokenSource(options.token);\n\n    this.disposer.add(this.tokenSource);\n    this.done.catch(() => {\n      // Prevent uncaught rejection\n    });\n  }\n\n  get onCompleted(): Event<{ graph: Graph }> {\n    return this.onCompletedEmitter.event;\n  }\n\n  get onError(): Event<{ error: Error }> {\n    return this.onErrorEmitter.event;\n  }\n\n  get onProgress(): Event<{\n    progress: {\n      completed: number;\n      pending: number;\n    };\n  }> {\n    return this.onProgressEmitter.event;\n  }\n\n  get token() {\n    return this.tokenSource.token;\n  }\n\n  addEdge(edge: DependencyEdge) {\n    this.edges.add(edge);\n  }\n\n  addSourceModule(sourceModule: SourceModule) {\n    this.sourceModules.set(sourceModule.href, sourceModule);\n  }\n\n  cancel() {\n    this.tokenSource.cancel();\n  }\n\n  dispose() {\n    this.cancel();\n    this.disposer.dispose();\n  }\n\n  hasSourceModule(href: string) {\n    return this.sourceModules.has(href);\n  }\n\n  runAsync(key: string, fn: () => Promise<unknown>): void {\n    if (this.token.isCancellationRequested) {\n      return;\n    }\n\n    const onError = (err: Error) => {\n      if (ret) {\n        this.pendingModuleOperations.delete(key, ret);\n      }\n      this.cancel();\n\n      if (!isCanceledError(err)) {\n        this.errors.push(err);\n\n        this.onErrorEmitter.fire({ error: err });\n      }\n    };\n    const onSuccess = () => {\n      this.pendingModuleOperations.delete(key, ret);\n\n      if (!this.pendingModuleOperations.size) {\n        this.onCompletedEmitter.fire({\n          graph: new Graph({\n            edges: this.edges,\n            rootUri: this.rootUri,\n            sourceModules: this.sourceModules.values(),\n          }),\n        });\n      } else {\n        this.onProgressEmitter.fire({\n          progress: {\n            completed: this.sourceModules.size,\n            pending: this.pendingModuleOperations.size,\n          },\n        });\n      }\n    };\n\n    let ret: ReturnType<typeof fn>;\n\n    try {\n      ret = fn().then(onSuccess, onError);\n      this.pendingModuleOperations.add(key, ret);\n    } catch (err) {\n      onError(err);\n    }\n  }\n}\n\nexport class GraphBuilder {\n  private readonly edgesByDependency = new WeakMap<SourceModuleDependency, DependencyEdge>();\n  private readonly edgesByInvalidation = new MapSet<string, DependencyEdge>();\n  private readonly external?: ExternalTestFunction;\n  private readonly nodeEnv: string;\n  private readonly resolver: Resolver;\n  private readonly pluginManager: PluginManager;\n  private readonly sourceModules = new Map<string, SourceModule>();\n  private readonly sourceModulesByInvalidation = new MapSet<string, SourceModule>();\n\n  constructor(options: GraphBuilder.Options) {\n    this.resolver = options.resolver;\n    this.external = options.external;\n    this.nodeEnv = options.nodeEnv || 'development';\n    this.pluginManager = new PluginManager(options.plugins || []);\n  }\n\n  private loadDependency(build: Build, sourceModule: SourceModule, dep: SourceModuleDependency) {\n    if (build.seen.has(dep)) return;\n    build.seen.add(dep);\n\n    if (this.external && this.external(dep, sourceModule)) {\n      return;\n    }\n\n    // console.debug('loadDependency(%s, %s)', sourceModule.href, dep.spec);\n\n    build.runAsync(`${sourceModule.href}|${dep.spec}`, async () => {\n      const result = await this.pluginManager.executeResolveDependency(\n        {\n          nodeEnv: this.nodeEnv,\n          resolver: this.resolver,\n          token: build.token,\n        },\n        dep,\n        sourceModule\n      );\n      const edge = this.createEdge(\n        sourceModule.uri,\n        sourceModule.rootUri,\n        result.uri,\n        result.rootUri,\n        result.visited,\n        dep\n      );\n\n      build.addEdge(edge);\n\n      this.loadEdge(build, edge);\n    });\n  }\n\n  private loadEdge(build: Build, edge: DependencyEdge) {\n    const href = edge.toUri.toString();\n\n    if (build.hasSourceModule(href)) return;\n\n    const existingSourceModule = this.sourceModules.get(href);\n\n    if (existingSourceModule) {\n      build.addSourceModule(existingSourceModule);\n\n      return this.visitSourceModule(build, existingSourceModule);\n    }\n\n    // console.debug(\n    //   'loadEdge(%s, %s, %s)',\n    //   edge.fromUri.toString(),\n    //   edge.dependency.spec,\n    //   edge.toUri.toString()\n    // );\n\n    build.runAsync(href, async () => {\n      // We need to check again in case another 'thread' already produced this\n      // sourceModule\n      if (build.hasSourceModule(href)) return;\n\n      const loadResult = await this.pluginManager.executeLoad(\n        {\n          nodeEnv: this.nodeEnv,\n          resolver: this.resolver,\n          token: build.token,\n        },\n        edge.toUri\n      );\n\n      // We need to check again in case another 'thread' already produced this\n      // sourceModule\n      if (build.hasSourceModule(href)) return;\n\n      const transformResult = await this.pluginManager.executeTransform(\n        {\n          nodeEnv: this.nodeEnv,\n          resolver: this.resolver,\n          token: build.token,\n        },\n        edge.toUri,\n        loadResult.code\n      );\n\n      // We need to check again in case another 'thread' already produced this\n      // sourceModule\n      if (build.hasSourceModule(href)) return;\n\n      const parseResult = parse(edge.toUri, transformResult.code, {\n        globalModules: DEFAULT_SHIM_GLOBALS,\n        nodeEnv: this.nodeEnv,\n      });\n      const sourceModule = new SourceModule(\n        edge.toUri,\n        edge.toRootUri,\n        parseResult.code,\n        new Set(parseResult.dependencies),\n        transformResult.sourceMapTree,\n        [...transformResult.visited, ...loadResult.visited]\n      );\n\n      build.addSourceModule(sourceModule);\n      this.sourceModules.set(sourceModule.href, sourceModule);\n\n      for (const visit of sourceModule.visits) {\n        this.sourceModulesByInvalidation.add(visit.uri.toString(), sourceModule);\n      }\n\n      this.sourceModulesByInvalidation.add(sourceModule.href, sourceModule);\n\n      this.visitSourceModule(build, sourceModule);\n    });\n  }\n\n  private loadEntrypoint(build: Build, uri: Uri) {\n    const href = uri.toString();\n\n    // console.debug('loadEntrypoint(%s)', href);\n    build.runAsync(href, async () => {\n      const result = await this.pluginManager.executeResolveEntrypoint(\n        {\n          nodeEnv: this.nodeEnv,\n          resolver: this.resolver,\n          token: build.token,\n        },\n        uri\n      );\n      const edge = this.createEdge(\n        build.rootUri,\n        build.rootUri,\n        result.uri,\n        result.rootUri,\n        result.visited,\n        SourceModuleDependency.fromEntrypoint(uri)\n      );\n\n      this.loadEdge(build, edge);\n    });\n  }\n\n  private visitSourceModule(build: Build, sourceModule: SourceModule) {\n    if (build.seen.has(sourceModule)) return;\n    build.seen.add(sourceModule);\n\n    // console.debug('visitSourceModule(%s)', sourceModule.href);\n    for (const dep of sourceModule.dependencies) {\n      const existingEdge = this.edgesByDependency.get(dep);\n\n      if (existingEdge) {\n        build.addEdge(existingEdge);\n\n        this.loadEdge(build, existingEdge);\n      } else {\n        this.loadDependency(build, sourceModule, dep);\n      }\n    }\n  }\n\n  build(\n    entrypoints: (string | Uri)[],\n    options: { incremental?: boolean; token?: CancellationToken } = {}\n  ) {\n    const rootUri = Uri.parse('velcro:/');\n    const build = new Build(rootUri, { token: options.token });\n\n    for (const uri of entrypoints) {\n      this.loadEntrypoint(build, Uri.isUri(uri) ? uri : Uri.parse(uri));\n    }\n\n    return build;\n  }\n\n  invalidate(uri: Uri | string) {\n    const href = Uri.isUri(uri) ? uri.toString() : uri;\n    const sourceModules = this.sourceModulesByInvalidation.get(href);\n\n    if (sourceModules) {\n      for (const sourceModule of sourceModules) {\n        this.sourceModules.delete(sourceModule.href);\n      }\n      this.sourceModulesByInvalidation.deleteAll(href);\n    }\n\n    this.sourceModules.delete(href);\n\n    const edges = this.edgesByInvalidation.get(href);\n\n    if (edges) {\n      for (const edge of edges) {\n        this.edgesByDependency.delete(edge.dependency);\n      }\n      this.edgesByInvalidation.deleteAll(href);\n    }\n\n    this.resolver.invalidate(uri);\n  }\n\n  private createEdge(\n    fromUri: Uri,\n    fromRootUri: Uri,\n    toUri: Uri,\n    toRootUri: Uri,\n    visited: ResolverContext.Visit[],\n    dependency: SourceModuleDependency\n  ) {\n    const edge = { dependency, fromUri, fromRootUri, toUri, toRootUri, visited };\n\n    this.edgesByDependency.set(dependency, edge);\n\n    this.edgesByInvalidation.add(toUri.toString(), edge);\n    for (const visit of visited) {\n      this.edgesByInvalidation.add(visit.uri.toString(), edge);\n    }\n\n    return edge;\n  }\n}\n\nexport namespace GraphBuilder {\n  export interface Options {\n    external?: ExternalTestFunction;\n    nodeEnv?: string;\n    plugins?: Plugin[];\n    resolver: Resolver;\n  }\n}\n","import {\n  all,\n  basename,\n  CancellationToken,\n  checkCancellation,\n  EntryNotFoundError,\n  isThenable,\n  PackageJson,\n  parseBufferAsPackageJson,\n  Thenable,\n  Uri,\n} from '@velcro/common';\nimport {\n  AbstractResolverStrategyWithRoot,\n  ResolverContext,\n  ResolverStrategy,\n  ResolverStrategyWithRoot,\n} from '@velcro/resolver';\nimport { satisfies, validRange } from 'semver';\n\ninterface AbstractCdn {\n  name: string;\n\n  isValidUrl(url: Uri): boolean;\n  normalizePackageListing(result: unknown): CdnStrategy.Directory;\n  parseUrl(url: Uri | string): CdnStrategy.Spec;\n  urlForPackageFile(spec: string, pathname: string): Uri;\n  urlForPackageList(spec: string): Uri;\n}\n\nfunction isValidEntry(entry: unknown): entry is CdnStrategy.Entry {\n  if (!entry || typeof entry !== 'object') return false;\n\n  return isValidFile(entry) || isValidDirectory(entry);\n}\n\nfunction isValidDirectory(entry: unknown): entry is CdnStrategy.Directory {\n  return (\n    typeof entry === 'object' &&\n    entry &&\n    (entry as any).type === ResolverStrategy.EntryKind.Directory &&\n    typeof (entry as any).path === 'string' &&\n    (entry as any).path &&\n    (typeof (entry as any).files === 'undefined' ||\n      (Array.isArray((entry as any).files) && (entry as any).files.every(isValidEntry)))\n  );\n}\n\nfunction isValidFile(entry: unknown): entry is File {\n  return (\n    typeof entry === 'object' &&\n    entry &&\n    (entry as any).type === ResolverStrategy.EntryKind.File &&\n    typeof (entry as any).path === 'string' &&\n    (entry as any).path\n  );\n}\n\nfunction specToString(spec: CdnStrategy.Spec) {\n  return `${spec.spec}${spec.pathname}`;\n}\n\nclass JSDelivrCdn implements AbstractCdn {\n  name = 'jsdelivr';\n\n  private readonly specRx = /^\\/((@[^/]+\\/[^/@]+|[^/@]+)(?:@([^/]+))?)(.*)?$/;\n\n  isValidUrl(url: Uri) {\n    return url.scheme === JSDelivrCdn.protocol || url.authority === JSDelivrCdn.host;\n  }\n\n  normalizePackageListing(result: unknown): CdnStrategy.Directory {\n    if (!result || typeof result !== 'object') {\n      throw new Error(`Unexpected package listing contents`);\n    }\n\n    const files = (result as any).files;\n\n    if (!Array.isArray(files)) {\n      throw new Error(`Unexpected package listing contents`);\n    }\n\n    const mapChildEntry = (parent: string, child: unknown): CdnStrategy.Entry => {\n      if (!child || typeof child !== 'object') {\n        throw new Error(`Unexpected entry in package listing contents`);\n      }\n\n      const name = (child as any).name;\n\n      if (typeof name !== 'string') {\n        throw new Error(`Unexpected entry in package listing contents`);\n      }\n\n      const path = `${parent}/${name}`;\n\n      if ((child as any).type === ResolverStrategy.EntryKind.Directory) {\n        const files = (child as any).files;\n\n        if (!Array.isArray(files)) {\n          throw new Error(`Unexpected entry in package listing contents`);\n        }\n        return {\n          type: ResolverStrategy.EntryKind.Directory,\n          path,\n          files: files.map((file) => mapChildEntry(path, file)),\n        };\n      } else if ((child as any).type === ResolverStrategy.EntryKind.File) {\n        return {\n          type: ResolverStrategy.EntryKind.File,\n          path,\n        };\n      }\n\n      throw new Error(`Error mapping child entry in package file listing`);\n    };\n\n    return {\n      type: ResolverStrategy.EntryKind.Directory,\n      path: '/',\n      files: files.map((file) => mapChildEntry('', file)),\n    };\n  }\n\n  parseUrl(url: Uri | string) {\n    if (Uri.isUri(url)) {\n      url = url.path;\n    }\n\n    const prefix = `/npm`;\n\n    if (!url.startsWith(prefix)) {\n      throw new Error(`Unable to parse unexpected ${this.name} url: ${url}`);\n    }\n\n    url = url.slice(prefix.length);\n\n    /**\n     * 1: scope + name + version\n     * 2: scope + name\n     * 3: version?\n     * 4: pathname\n     */\n    const matches = url.match(this.specRx);\n\n    if (!matches) {\n      throw new Error(`Unable to parse unexpected unpkg url: ${url}`);\n    }\n\n    return {\n      spec: matches[1],\n      name: matches[2],\n      version: matches[3] || '',\n      pathname: matches[4] || '',\n    };\n  }\n\n  urlForPackageFile(spec: string, pathname: string): Uri {\n    return Uri.from({\n      scheme: JSDelivrCdn.protocol,\n      authority: JSDelivrCdn.host,\n      path: `/npm/${spec}${pathname}`,\n    });\n  }\n\n  urlForPackageList(spec: string): Uri {\n    return Uri.from({\n      scheme: JSDelivrCdn.protocol,\n      authority: JSDelivrCdn.dataHost,\n      path: `/v1/package/npm/${spec}/tree`,\n    });\n  }\n\n  static readonly protocol = 'https';\n  static readonly host = 'cdn.jsdelivr.net';\n  static readonly dataHost = 'data.jsdelivr.com';\n}\n\nclass UnpkgCdn implements AbstractCdn {\n  name = 'unpkg';\n\n  private readonly UNPKG_SPEC_RX = /^\\/((@[^/]+\\/[^/@]+|[^/@]+)(?:@([^/]+))?)(.*)?$/;\n\n  isValidUrl(url: Uri) {\n    return url.scheme === UnpkgCdn.protocol || url.authority === UnpkgCdn.host;\n  }\n\n  normalizePackageListing(result: unknown) {\n    if (!isValidDirectory(result)) {\n      throw new Error(`Error normalizing directory listing`);\n    }\n\n    return result;\n  }\n\n  parseUrl(url: Uri | string) {\n    if (Uri.isUri(url)) {\n      url = url.path;\n    }\n\n    /**\n     * 1: scope + name + version\n     * 2: scope + name\n     * 3: version?\n     * 4: pathname\n     */\n    const matches = url.match(this.UNPKG_SPEC_RX);\n\n    if (!matches) {\n      throw new Error(`Unable to parse unexpected unpkg url: ${url}`);\n    }\n\n    return {\n      spec: matches[1],\n      name: matches[2],\n      version: matches[3] || '',\n      pathname: matches[4] || '',\n    };\n  }\n\n  urlForPackageFile(spec: string, pathname: string): Uri {\n    return Uri.from({\n      scheme: UnpkgCdn.protocol,\n      authority: UnpkgCdn.host,\n      path: `/${spec}${pathname}`,\n    });\n  }\n\n  urlForPackageList(spec: string) {\n    return Uri.from({\n      scheme: UnpkgCdn.protocol,\n      authority: UnpkgCdn.host,\n      path: `/${spec}/`,\n      query: 'meta',\n    });\n  }\n\n  static readonly protocol = 'https';\n  static readonly host = 'unpkg.com';\n}\n\nexport namespace CdnStrategy {\n  export type Spec = {\n    spec: string;\n    name: string;\n    version: string;\n    pathname: string;\n  };\n\n  export type Directory = {\n    type: ResolverStrategy.EntryKind.Directory;\n    path: string;\n    files?: ReadonlyArray<Entry>;\n  };\n  export type File = {\n    type: ResolverStrategy.EntryKind.File;\n    path: string;\n  };\n  export type Entry = Directory | File;\n\n  export type UrlContentFetcher = (\n    href: string,\n    token: CancellationToken\n  ) => Thenable<ArrayBuffer | null>;\n}\n\nexport class CdnStrategy extends AbstractResolverStrategyWithRoot\n  implements ResolverStrategyWithRoot {\n  private readonly cdn: AbstractCdn;\n  private readonly contentCache = new Map<\n    string,\n    null | { content: ArrayBuffer } | Thenable<{ content: ArrayBuffer }>\n  >();\n  private readonly locks = new Map<string, unknown | Thenable<unknown>>();\n  private readonly packageEntriesCache = new Map<string, Map<string, CdnStrategy.Directory>>();\n  private readonly packageJsonCache = new Map<\n    string,\n    Map<string, { packageJson: PackageJson; visited: ResolverContext.Visit[] }>\n  >();\n  private readonly readUrlFn: CdnStrategy.UrlContentFetcher;\n\n  constructor(readUrlFn: CdnStrategy.UrlContentFetcher, cdn: AbstractCdn) {\n    super(cdn.urlForPackageFile('', ''));\n\n    this.cdn = cdn;\n    this.readUrlFn = readUrlFn;\n  }\n\n  private _withRootUriCheck<T extends unknown | Thenable<unknown>>(\n    uri: Uri,\n    fn: (rootUri: Uri) => T\n  ): T {\n    if (!Uri.isPrefixOf(this.rootUri, uri)) {\n      throw new Error(\n        `This strategy is only able to handle URIs under '${this.rootUri.toString()}' and is unable to handle '${uri.toString()}'`\n      );\n    }\n\n    return fn(this.rootUri);\n  }\n\n  async getUrlForBareModule(\n    ctx: ResolverContext,\n    name: string,\n    spec: string,\n    path: string\n  ): Promise<ResolverStrategy.BareModuleResult> {\n    const unresolvedUri = this.cdn.urlForPackageFile(`${name}@${spec}`, path);\n    const resolveReturn = await ctx.resolveUri(unresolvedUri);\n\n    return resolveReturn;\n  }\n\n  getCanonicalUrl(ctx: ResolverContext, uri: Uri): Promise<ResolverStrategy.CanonicalizeResult> {\n    return this._withRootUriCheck(uri, async () => {\n      const unresolvedSpec = this.cdn.parseUrl(uri);\n      const packageJsonReturn = ctx.runInChildContext(\n        'CdnStrategy._readPackageJsonWithCache',\n        specToString(unresolvedSpec),\n        (ctx) => this._readPackageJsonWithCache(ctx, unresolvedSpec)\n      );\n      const packageJson = isThenable(packageJsonReturn)\n        ? await packageJsonReturn\n        : packageJsonReturn;\n\n      return {\n        uri: this.cdn.urlForPackageFile(\n          `${packageJson.name}@${packageJson.version}`,\n          unresolvedSpec.pathname\n        ),\n      };\n    });\n    // const results = all([ctx.getRootUrl(uri), ctx.getResolveRoot(uri)], ctx.token);\n    // const [rootUriResult, resolveRootResult] = isThenable(results) ? await results : results;\n  }\n\n  getResolveRoot(ctx: ResolverContext, uri: Uri): Promise<ResolverStrategy.ResolveRootResult> {\n    return this._withRootUriCheck(uri, async () => {\n      const unresolvedSpec = this.cdn.parseUrl(uri);\n      const packageJsonReturn = this._readPackageJsonWithCache(ctx, unresolvedSpec);\n      const packageJson = isThenable(packageJsonReturn)\n        ? await packageJsonReturn\n        : packageJsonReturn;\n\n      return {\n        uri: this.cdn.urlForPackageFile(`${packageJson.name}@${packageJson.version}`, '/'),\n      };\n    });\n  }\n\n  getRootUrl() {\n    return {\n      uri: this.cdn.urlForPackageFile('', ''),\n    };\n  }\n\n  listEntries(ctx: ResolverContext, uri: Uri): Promise<ResolverStrategy.ListEntriesResult> {\n    return this._withRootUriCheck(\n      uri,\n      async (): Promise<ResolverStrategy.ListEntriesResult> => {\n        const unresolvedSpec = this.cdn.parseUrl(uri);\n        const results = all(\n          [\n            ctx.getResolveRoot(uri),\n            this._readPackageJsonWithCache(ctx, unresolvedSpec),\n            this._readPackageEntriesWithCache(ctx, unresolvedSpec),\n          ],\n          ctx.token\n        );\n\n        const [{ uri: resolveRootUri }, packageJson, entriesReturn] = isThenable(results)\n          ? await results\n          : results;\n        const canonicalizedSpec: CdnStrategy.Spec = {\n          name: packageJson.name,\n          pathname: unresolvedSpec.pathname,\n          spec: `${packageJson.name}@${packageJson.version}`,\n          version: packageJson.version,\n        };\n\n        // Proactively cache the canonicalized package entries\n        this.packageEntriesCache.get(packageJson.name)!.set(packageJson.version, entriesReturn);\n\n        const traversalSegments = canonicalizedSpec.pathname.split('/').filter(Boolean);\n\n        let parentEntry: CdnStrategy.Directory | undefined = entriesReturn;\n\n        while (parentEntry && traversalSegments.length) {\n          const segment = traversalSegments.shift() as string;\n\n          if (parentEntry.type !== ResolverStrategy.EntryKind.Directory || !parentEntry.files) {\n            throw new EntryNotFoundError(uri);\n          }\n\n          parentEntry = parentEntry.files.find(\n            (file) =>\n              file.type === ResolverStrategy.EntryKind.Directory && basename(file.path) === segment\n          ) as CdnStrategy.Directory | undefined;\n        }\n\n        if (!parentEntry) {\n          throw new EntryNotFoundError(uri);\n        }\n\n        if (!parentEntry.files) {\n          return {\n            entries: [],\n          };\n        }\n\n        return {\n          entries: parentEntry.files.map((entry) => {\n            return {\n              type: entry.type,\n              uri: Uri.joinPath(resolveRootUri, `.${entry.path}`),\n            };\n          }),\n        };\n      }\n    );\n  }\n\n  readFileContent(ctx: ResolverContext, uri: Uri) {\n    return this._withRootUriCheck(uri, () => {\n      const uriStr = uri.toString();\n      const cached = this.contentCache.get(uriStr);\n\n      if (cached === null) {\n        return Promise.reject(new EntryNotFoundError(uri));\n      }\n\n      if (cached) {\n        return cached;\n      }\n\n      ctx.recordVisit(uri, ResolverContext.VisitKind.File);\n      const readReturn = this.readUrlFn(uriStr, ctx.token);\n\n      if (readReturn === null) {\n        this.contentCache.set(uriStr, null);\n\n        return Promise.reject(new EntryNotFoundError(uri));\n      }\n\n      if (isThenable(readReturn)) {\n        const wrappedReturn = readReturn.then((data) => {\n          if (data === null) {\n            this.contentCache.delete(uriStr);\n\n            return Promise.reject(new EntryNotFoundError(uri));\n          }\n\n          const entry = { content: data };\n\n          this.contentCache.set(uriStr, entry);\n\n          return entry;\n        });\n\n        this.contentCache.set(uriStr, wrappedReturn);\n\n        return wrappedReturn;\n      }\n\n      const entry = { content: readReturn };\n      this.contentCache.set(uriStr, entry);\n\n      return entry;\n    });\n  }\n\n  private _readPackageEntriesWithCache(ctx: ResolverContext, spec: CdnStrategy.Spec) {\n    ctx.debug('%s._readPackageEntriesWithCache(%s)', this.constructor.name, specToString(spec));\n\n    return this._withLock(`packageEntries:${spec.name}`, () => {\n      let packageEntriesCacheForModule = this.packageEntriesCache.get(spec.name);\n\n      if (packageEntriesCacheForModule) {\n        const exactMatch = packageEntriesCacheForModule.get(spec.version);\n\n        if (exactMatch) {\n          // console.log('[HIT-EXACT] readPackageJsonWithCache(%s)', spec.spec);\n          return exactMatch;\n        }\n\n        const range = validRange(spec.version);\n\n        if (range) {\n          for (const [version, entries] of packageEntriesCacheForModule) {\n            if (satisfies(version, range)) {\n              return entries;\n            }\n          }\n        }\n      } else {\n        packageEntriesCacheForModule = new Map();\n        this.packageEntriesCache.set(spec.name, packageEntriesCacheForModule);\n      }\n\n      return this._readPackageEntries(ctx, spec).then((rootDir) => {\n        packageEntriesCacheForModule!.set(spec.version, rootDir);\n\n        return rootDir;\n      });\n    });\n  }\n\n  private async _readPackageEntries(ctx: ResolverContext, spec: CdnStrategy.Spec) {\n    ctx.debug('%s._readPackageEntries(%s)', this.constructor.name, specToString(spec));\n\n    const uri = this.cdn.urlForPackageList(spec.spec);\n    const href = uri.toString();\n    ctx.recordVisit(uri, ResolverContext.VisitKind.Directory);\n    const data = await checkCancellation(this.readUrlFn(href, ctx.token), ctx.token);\n\n    if (data === null) {\n      throw new EntryNotFoundError(spec);\n    }\n\n    const dataStr = ctx.decoder.decode(data);\n\n    return this.cdn.normalizePackageListing(JSON.parse(dataStr));\n  }\n\n  private _readPackageJsonWithCache(ctx: ResolverContext, spec: CdnStrategy.Spec) {\n    return this._withLock(`packageJson:${spec.name}`, () => {\n      let packageJsonCacheForModule = this.packageJsonCache.get(spec.name);\n\n      if (packageJsonCacheForModule) {\n        const exactMatch = packageJsonCacheForModule.get(spec.version);\n\n        if (exactMatch) {\n          // console.log('[HIT-EXACT] readPackageJsonWithCache(%s)', spec.spec);\n          for (const visit of exactMatch.visited) {\n            ctx.recordVisit(visit.uri, visit.type);\n          }\n          return exactMatch.packageJson;\n        }\n\n        const range = validRange(spec.version);\n\n        if (range) {\n          for (const [version, entry] of packageJsonCacheForModule) {\n            if (satisfies(version, range)) {\n              // console.log('[HIT] readPackageJsonWithCache(%s)', spec.spec);\n              for (const visit of entry.visited) {\n                ctx.recordVisit(visit.uri, visit.type);\n              }\n              return entry.packageJson;\n            }\n          }\n        }\n      } else {\n        packageJsonCacheForModule = new Map();\n        this.packageJsonCache.set(spec.name, packageJsonCacheForModule);\n      }\n\n      return this._readPackageJson(spec, ctx).then((packageJson) => {\n        packageJsonCacheForModule!.set(packageJson.version, { packageJson, visited: ctx.visited });\n\n        return packageJson;\n      });\n    });\n  }\n\n  private async _readPackageJson(\n    spec: CdnStrategy.Spec,\n    ctx: ResolverContext\n  ): Promise<PackageJson> {\n    ctx.debug('%s._readPackageJson(%s)', this.constructor.name, specToString(spec));\n    const uri = this.cdn.urlForPackageFile(spec.spec, '/package.json');\n    const contentReturn = ctx.readFileContent(uri);\n    const contentResult = isThenable(contentReturn) ? await contentReturn : contentReturn;\n\n    let manifest: PackageJson;\n\n    try {\n      manifest = parseBufferAsPackageJson(ctx.decoder, contentResult.content, spec.spec);\n    } catch (err) {\n      throw new Error(`Error parsing manifest as json for package ${spec}: ${err.message}`);\n    }\n\n    // Since we know what the canonicalized version is now (we didn't until the promise resolved)\n    // and the package.json was parsed), we can proactively seed the content cache for the\n    // canonical url.\n    const canonicalHref = this.cdn\n      .urlForPackageFile(`${manifest.name}@${manifest.version}`, '/package.json')\n      .toString();\n\n    this.contentCache.set(canonicalHref, contentResult);\n\n    return manifest;\n  }\n\n  private _withLock<T extends unknown | Promise<unknown>>(\n    lockKey: string,\n    fn: (...args: any[]) => T\n  ): T {\n    const lock = this.locks.get(lockKey);\n    const runCriticalSection = (): T => {\n      const ret = fn();\n\n      if (isThenable(ret)) {\n        const locked = ret.then(\n          (result) => {\n            this.locks.delete(lockKey);\n\n            return result;\n          },\n          (err) => {\n            this.locks.delete(lockKey);\n\n            return Promise.reject(err);\n          }\n        );\n\n        this.locks.set(lockKey, locked);\n\n        return ret;\n      }\n\n      // No need to lock in non-promise\n      return ret;\n    };\n\n    if (isThenable(lock)) {\n      return lock.then(runCriticalSection) as T;\n    }\n\n    return runCriticalSection();\n  }\n\n  static forJsDelivr(readUrlFn: CdnStrategy.UrlContentFetcher) {\n    return new CdnStrategy(readUrlFn, new JSDelivrCdn());\n  }\n\n  static forUnpkg(readUrlFn: CdnStrategy.UrlContentFetcher) {\n    return new CdnStrategy(readUrlFn, new UnpkgCdn());\n  }\n}\n","import {\n  ResolverContext,\n  AbstractResolverStrategy,\n  ResolverStrategy,\n  ResolverStrategyWithRoot,\n} from '@velcro/resolver';\nimport { Uri } from '@velcro/common';\n\ntype StrategyMethodsNames =\n  | 'getCanonicalUrl'\n  | 'getResolveRoot'\n  | 'getSettings'\n  | 'listEntries'\n  | 'readFileContent';\n\ninterface ResolverHostFsOptions {\n  strategies: ResolverStrategyWithRoot[];\n}\n\nexport class CompoundStrategy extends AbstractResolverStrategy implements ResolverStrategy {\n  private readonly strategies: Set<ResolverStrategyWithRoot>;\n\n  constructor(options: ResolverHostFsOptions) {\n    super();\n\n    this.strategies = new Set(options.strategies);\n  }\n\n  private _delegateToStrategy<\n    TMethodName extends StrategyMethodsNames,\n    TMethod extends (ctx: ResolverContext, uri: Uri) => any = ResolverStrategy[TMethodName]\n  >(method: TMethodName, ctx: ResolverContext, uri: Uri) {\n    for (const strategy of this.strategies) {\n      if (Uri.isPrefixOf(strategy.rootUri, uri)) {\n        return strategy[method](ctx, uri) as ReturnType<TMethod>;\n      }\n    }\n\n    return Promise.reject(\n      new Error(`No strategy found whose root is a prefix of ${uri}`)\n    ) as ReturnType<TMethod>;\n  }\n\n  getCanonicalUrl(ctx: ResolverContext, uri: Uri) {\n    return this._delegateToStrategy('getCanonicalUrl', ctx, uri);\n  }\n\n  getResolveRoot(ctx: ResolverContext, uri: Uri) {\n    return this._delegateToStrategy('getResolveRoot', ctx, uri);\n  }\n\n  getUrlForBareModule(ctx: ResolverContext, name: string, spec: string, path: string) {\n    for (const strategy of this.strategies) {\n      if (strategy.getUrlForBareModule) {\n        return strategy.getUrlForBareModule(ctx, name, spec, path);\n      }\n    }\n    return {\n      found: false,\n      uri: null,\n    };\n  }\n\n  listEntries(ctx: ResolverContext, uri: Uri) {\n    return this._delegateToStrategy('listEntries', ctx, uri);\n  }\n\n  readFileContent(ctx: ResolverContext, uri: Uri) {\n    return this._delegateToStrategy('readFileContent', ctx, uri);\n  }\n}\n","import { ChunkOutput, GraphBuilder, Plugin, VelcroRuntime } from '@velcro/bundler';\nimport { Uri } from '@velcro/common';\nimport { Resolver } from '@velcro/resolver';\nimport { CdnStrategy } from '@velcro/strategy-cdn';\nimport { CompoundStrategy } from '@velcro/strategy-compound';\nimport { MemoryStrategy } from '@velcro/strategy-memory';\n\nconst defaultExtensions: Resolver.Settings['extensions'] = ['.js', '.json'];\nconst defaultPackageMain: Resolver.Settings['packageMain'] = ['browser', 'main'];\n\nexport interface BuildOptions {\n  cdn?: 'jsdelivr' | 'unpkg';\n  dependencies?: { [key: string]: string };\n  extensions?: Resolver.Settings['extensions'];\n  external?: GraphBuilder.Options['external'];\n  nodeEnv?: string;\n  plugins?: Plugin[];\n  packageMain?: Resolver.Settings['packageMain'];\n  readUrl: CdnStrategy.UrlContentFetcher;\n}\n\nexport interface ExecuteOptions extends BuildOptions {\n  sourceMap?: boolean;\n  injectModules?: { [id: string]: unknown };\n}\n\nexport async function build(\n  code: string,\n  options: BuildOptions\n): Promise<{ entrypointUri: Uri; output: ChunkOutput }> {\n  const entrypointPath = `index.js`;\n  const cdnStrategy =\n    options.cdn === 'unpkg'\n      ? CdnStrategy.forUnpkg(options.readUrl)\n      : CdnStrategy.forJsDelivr(options.readUrl);\n  const memoryStrategy = new MemoryStrategy(\n    {\n      [entrypointPath]: code,\n      ['package.json']: JSON.stringify({\n        name: '@@velcro/execute',\n        version: '0.0.0',\n        dependencies: options.dependencies,\n      }),\n    },\n    Uri.parse(`velcro://${Math.random().toString(16).slice(2)}/`)\n  );\n  const entrypointUri = memoryStrategy.uriForPath(entrypointPath);\n  const compoundStrategy = new CompoundStrategy({ strategies: [cdnStrategy, memoryStrategy] });\n  const resolver = new Resolver(compoundStrategy, {\n    extensions: options.extensions || defaultExtensions,\n    packageMain: options.packageMain || defaultPackageMain,\n  });\n  const graphBuilder = new GraphBuilder({\n    external: options.external,\n    resolver,\n    nodeEnv: options.nodeEnv || 'development',\n    plugins: options.plugins,\n  });\n  const build = graphBuilder.build([entrypointUri]);\n  const graph = await build.done;\n  const [chunk] = graph.splitChunks();\n  const output = chunk.buildForStaticRuntime({\n    injectRuntime: true,\n  });\n\n  return { entrypointUri, output };\n}\n\nexport async function execute<T = unknown>(code: string, options: ExecuteOptions): Promise<T> {\n  if (options.injectModules) {\n    const injectedModuleSpecs = new Set(Object.keys(options.injectModules));\n    const optionsExternal = options.external;\n    const isExternal: GraphBuilder.Options['external'] = (dependency, fromSourceModule) => {\n      if (injectedModuleSpecs.has(dependency.spec)) {\n        return true;\n      }\n\n      return typeof optionsExternal === 'function'\n        ? optionsExternal(dependency, fromSourceModule)\n        : false;\n    };\n\n    options.external = isExternal;\n  }\n\n  const { entrypointUri, output } = await build(code, options);\n  const codeWithStart = `${output.code}\\n\\nreturn Velcro.runtime;\\n`;\n  const runtimeCode = options.sourceMap\n    ? `${codeWithStart}\\n//# sourceMappingURL=${output.sourceMapDataUri}`\n    : codeWithStart;\n\n  const runtimeFn = new Function(runtimeCode) as () => VelcroRuntime;\n  const velcro = runtimeFn();\n\n  if (options.injectModules) {\n    for (const id in options.injectModules) {\n      velcro.inject(id, options.injectModules[id]);\n    }\n  }\n\n  const result = velcro.require(entrypointUri.toString());\n\n  return result as T;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as Monaco from 'monaco-editor';\n\nconst EMPTY_ELEMENTS = [\n  'area',\n  'base',\n  'br',\n  'col',\n  'embed',\n  'hr',\n  'img',\n  'input',\n  'keygen',\n  'link',\n  'menuitem',\n  'meta',\n  'param',\n  'source',\n  'track',\n  'wbr',\n];\nexport const conf = {\n  wordPattern: /(-?\\d*\\.\\d\\w*)|([^`~!@$^&*()=+[{\\]}|;:'\",.<>/\\s]+)/g,\n  comments: {\n    blockComment: ['{!--', '--}'],\n  },\n  brackets: [\n    ['<!--', '-->'],\n    ['<', '>'],\n    ['{', '}'],\n    ['(', ')'],\n  ],\n  autoClosingPairs: [\n    { open: '{', close: '}' },\n    { open: '[', close: ']' },\n    { open: '(', close: ')' },\n    { open: '\"', close: '\"' },\n    { open: \"'\", close: \"'\" },\n  ],\n  surroundingPairs: [\n    { open: '{', close: '}' },\n    { open: '<', close: '>' },\n    { open: '\"', close: '\"' },\n    { open: \"'\", close: \"'\" },\n  ],\n  onEnterRules: [\n    {\n      beforeText: new RegExp(\n        '<(?!(?:' + EMPTY_ELEMENTS.join('|') + '))(\\\\w[\\\\w\\\\d]*)([^/>]*(?!/)>)[^<]*$',\n        'i'\n      ),\n      afterText: /^<\\/(\\w[\\w\\d]*)\\s*>$/i,\n      action: { indentAction: Monaco.languages.IndentAction.IndentOutdent },\n    },\n    {\n      beforeText: new RegExp(\n        '<(?!(?:' + EMPTY_ELEMENTS.join('|') + '))(\\\\w[\\\\w\\\\d]*)([^/>]*(?!/)>)[^<]*$',\n        'i'\n      ),\n      action: { indentAction: Monaco.languages.IndentAction.Indent },\n    },\n  ],\n};\n\nexport const language = {\n  defaultToken: '',\n  tokenPostfix: '.svelte',\n  ignoreCase: false,\n  tokenizer: {\n    root: [\n      [/<!DOCTYPE/, 'metatag', '@doctype'],\n      [/<!--/, 'comment', '@comment'],\n      [/(<)((?:[\\w-]+:)?[\\w-]+)(\\s*)(\\/>)/, ['delimiter', 'tag', '', 'delimiter']],\n      [/(<)(script)/, ['delimiter', { token: 'tag', next: '@script' }]],\n      [/(<)(style)/, ['delimiter', { token: 'tag', next: '@style' }]],\n      [/(<)((?:[\\w-]+:)?[\\w-]+)/, ['delimiter', { token: 'tag', next: '@otherTag' }]],\n      [/(<\\/)((?:[\\w-]+:)?[\\w-]+)/, ['delimiter', { token: 'tag', next: '@otherTag' }]],\n      [/</, 'delimiter'],\n      [/[^<]+/], // text\n    ],\n    doctype: [\n      [/[^>]+/, 'metatag.content'],\n      [/>/, 'metatag', '@pop'],\n    ],\n    comment: [\n      [/-->/, 'comment', '@pop'],\n      [/[^-]+/, 'comment.content'],\n      [/./, 'comment.content'],\n    ],\n    otherTag: [\n      [/\\/?>/, 'delimiter', '@pop'],\n      [/\"([^\"]*)\"/, 'attribute.value'],\n      [/'([^']*)'/, 'attribute.value'],\n      [/[\\w-]+/, 'attribute.name'],\n      [/=/, 'delimiter'],\n      [/[ \\t\\r\\n]+/], // whitespace\n    ],\n    script: [\n      [/type/, 'attribute.name', '@scriptAfterType'],\n      [/\"([^\"]*)\"/, 'attribute.value'],\n      [/'([^']*)'/, 'attribute.value'],\n      [/[\\w-]+/, 'attribute.name'],\n      [/=/, 'delimiter'],\n      [/>/, { token: 'delimiter', next: '@scriptEmbedded', nextEmbedded: 'text/javascript' }],\n      [/[ \\t\\r\\n]+/], // whitespace\n      [/(<\\/)(script\\s*)(>)/, ['delimiter', 'tag', { token: 'delimiter', next: '@pop' }]],\n    ],\n    scriptAfterType: [\n      [/=/, 'delimiter', '@scriptAfterTypeEquals'],\n      [/>/, { token: 'delimiter', next: '@scriptEmbedded', nextEmbedded: 'text/javascript' }], // cover invalid e.g. <script type>\n      [/[ \\t\\r\\n]+/], // whitespace\n      [/<\\/script\\s*>/, { token: '@rematch', next: '@pop' }],\n    ],\n    scriptAfterTypeEquals: [\n      [/\"([^\"]*)\"/, { token: 'attribute.value', switchTo: '@scriptWithCustomType.$1' }],\n      [/'([^']*)'/, { token: 'attribute.value', switchTo: '@scriptWithCustomType.$1' }],\n      [/>/, { token: 'delimiter', next: '@scriptEmbedded', nextEmbedded: 'text/javascript' }], // cover invalid e.g. <script type=>\n      [/[ \\t\\r\\n]+/], // whitespace\n      [/<\\/script\\s*>/, { token: '@rematch', next: '@pop' }],\n    ],\n    scriptWithCustomType: [\n      [/>/, { token: 'delimiter', next: '@scriptEmbedded.$S2', nextEmbedded: '$S2' }],\n      [/\"([^\"]*)\"/, 'attribute.value'],\n      [/'([^']*)'/, 'attribute.value'],\n      [/[\\w-]+/, 'attribute.name'],\n      [/=/, 'delimiter'],\n      [/[ \\t\\r\\n]+/], // whitespace\n      [/<\\/script\\s*>/, { token: '@rematch', next: '@pop' }],\n    ],\n    scriptEmbedded: [\n      [/<\\/script/, { token: '@rematch', next: '@pop', nextEmbedded: '@pop' }],\n      [/[^<]+/, ''],\n    ],\n    style: [\n      [/type/, 'attribute.name', '@styleAfterType'],\n      [/\"([^\"]*)\"/, 'attribute.value'],\n      [/'([^']*)'/, 'attribute.value'],\n      [/[\\w-]+/, 'attribute.name'],\n      [/=/, 'delimiter'],\n      [/>/, { token: 'delimiter', next: '@styleEmbedded', nextEmbedded: 'text/css' }],\n      [/[ \\t\\r\\n]+/], // whitespace\n      [/(<\\/)(style\\s*)(>)/, ['delimiter', 'tag', { token: 'delimiter', next: '@pop' }]],\n    ],\n    styleAfterType: [\n      [/=/, 'delimiter', '@styleAfterTypeEquals'],\n      [/>/, { token: 'delimiter', next: '@styleEmbedded', nextEmbedded: 'text/css' }], // cover invalid e.g. <style type>\n      [/[ \\t\\r\\n]+/], // whitespace\n      [/<\\/style\\s*>/, { token: '@rematch', next: '@pop' }],\n    ],\n    styleAfterTypeEquals: [\n      [/\"([^\"]*)\"/, { token: 'attribute.value', switchTo: '@styleWithCustomType.$1' }],\n      [/'([^']*)'/, { token: 'attribute.value', switchTo: '@styleWithCustomType.$1' }],\n      [/>/, { token: 'delimiter', next: '@styleEmbedded', nextEmbedded: 'text/css' }], // cover invalid e.g. <style type=>\n      [/[ \\t\\r\\n]+/], // whitespace\n      [/<\\/style\\s*>/, { token: '@rematch', next: '@pop' }],\n    ],\n    styleWithCustomType: [\n      [/>/, { token: 'delimiter', next: '@styleEmbedded.$S2', nextEmbedded: '$S2' }],\n      [/\"([^\"]*)\"/, 'attribute.value'],\n      [/'([^']*)'/, 'attribute.value'],\n      [/[\\w-]+/, 'attribute.name'],\n      [/=/, 'delimiter'],\n      [/[ \\t\\r\\n]+/], // whitespace\n      [/<\\/style\\s*>/, { token: '@rematch', next: '@pop' }],\n    ],\n    styleEmbedded: [\n      [/<\\/style/, { token: '@rematch', next: '@pop', nextEmbedded: '@pop' }],\n      [/[^<]+/, ''],\n    ],\n  },\n};\n","import { DisposableStore, Emitter, Event, IDisposable } from '@velcro/common';\nimport { execute } from '@velcro/runner';\nimport * as Monaco from 'monaco-editor';\nimport { createContext, useContext, useEffect, useState } from 'react';\nimport * as SvelteLanguage from './svelte.language';\n\nconst readUrl = (href: string) => fetch(href).then((res) => res.arrayBuffer());\n\nexport class EditorManager implements IDisposable {\n  editor: Monaco.editor.IStandaloneCodeEditor | null = null;\n\n  private readonly disposableStore = new DisposableStore();\n  private readonly initialPath: string | undefined;\n  private readonly viewState = new WeakMap<\n    Monaco.editor.ITextModel,\n    Monaco.editor.ICodeEditorViewState\n  >();\n\n  private readonly onWillFocusModelEmitter = new Emitter<Monaco.editor.ITextModel>();\n  private readonly onDidChangeEmitter = new Emitter<{ model: Monaco.editor.ITextModel }>();\n\n  constructor(options: { files?: Record<string, string>; initialPath?: string } = {}) {\n    this.disposableStore.add(this.onWillFocusModelEmitter);\n    this.disposableStore.add(this.onDidChangeEmitter);\n\n    Monaco.languages.typescript.typescriptDefaults.setEagerModelSync(true);\n    Monaco.languages.typescript.typescriptDefaults.setMaximumWorkerIdleTime(-1);\n    Monaco.languages.typescript.typescriptDefaults.setCompilerOptions({\n      allowJs: true,\n      allowNonTsExtensions: true,\n      allowSyntheticDefaultImports: true,\n      baseUrl: '.',\n      checkJs: true,\n      esModuleInterop: true,\n      experimentalDecorators: true,\n      inlineSourceMap: true,\n      inlineSources: true,\n      isolatedModules: false,\n      jsx: Monaco.languages.typescript.JsxEmit.React,\n      lib: ['dom'],\n      module: Monaco.languages.typescript.ModuleKind.CommonJS,\n      moduleResolution: Monaco.languages.typescript.ModuleResolutionKind.NodeJs,\n      noEmit: false,\n      outDir: `dist`,\n      resolveJsonModule: true,\n      rootDir: '/',\n      sourceMap: true,\n      target: Monaco.languages.typescript.ScriptTarget.ES2015,\n      typeRoots: ['node_modules/@types'],\n    });\n    Monaco.languages.typescript.typescriptDefaults.setDiagnosticsOptions({\n      noSemanticValidation: true,\n      noSyntaxValidation: false,\n    });\n\n    Monaco.languages.register({\n      id: 'svelte',\n      extensions: ['.svelte'],\n      mimetypes: ['text/x-svelte'],\n    });\n    Monaco.languages.setLanguageConfiguration(\n      'svelte',\n      SvelteLanguage.conf as Monaco.languages.LanguageConfiguration\n    );\n    Monaco.languages.setMonarchTokensProvider(\n      'svelte',\n      SvelteLanguage.language as Monaco.languages.IMonarchLanguage\n    );\n\n    const createPrettierFormattingProvider = (): Monaco.languages.DocumentFormattingEditProvider => {\n      let prettierPromise:\n        | Promise<{\n            prettier: typeof import('prettier/standalone');\n            plugins: import('prettier').Plugin[];\n          }>\n        | undefined = undefined;\n\n      const loadPrettier = async () => {\n        if (!prettierPromise) {\n          prettierPromise = execute(\n            'module.exports = { prettier: require(\"prettier/standalone\"), plugins: [require(\"prettier/parser-babel\"), require(\"prettier/parser-html\"), require(\"prettier/parser-postcss\")] };',\n            {\n              readUrl,\n              cdn: 'jsdelivr',\n              dependencies: {\n                prettier: '^2.0.5',\n                'prettier-plugin-svelte': '^1.1.0',\n              },\n              nodeEnv: 'production',\n              packageMain: ['browser', 'main'],\n              sourceMap: false,\n            }\n          );\n\n          // The Svelte plugin depends on 'prettier' but we're in a browser and so we need\n          // to inject the 'standalone' version of prettier. This means to need to defer\n          // loading the svelte plugin until we've gotten a reference to prettier from\n          // the previous logic.\n          prettierPromise = prettierPromise.then(async ({ prettier, plugins }) => {\n            const prettierPluginSvelte = await execute<import('prettier').Plugin>(\n              'module.exports = require(\"prettier-plugin-svelte\")',\n              {\n                readUrl,\n                cdn: 'jsdelivr',\n                dependencies: {\n                  'prettier-plugin-svelte': '^1.1.0',\n                  svelte: '^3.2.0',\n                },\n                injectModules: {\n                  prettier,\n                },\n                nodeEnv: 'production',\n                packageMain: ['browser', 'main'],\n                sourceMap: false,\n              }\n            );\n\n            return {\n              prettier,\n              plugins: [...plugins, prettierPluginSvelte],\n            };\n          });\n\n          prettierPromise.catch((e) => {\n            console.error(e);\n            debugger;\n          });\n        }\n\n        return prettierPromise;\n      };\n\n      return {\n        async provideDocumentFormattingEdits(model, options, token) {\n          const { prettier, plugins } = await loadPrettier();\n\n          if (token.isCancellationRequested) {\n            return [];\n          }\n\n          const formatted = prettier.format(model.getValue(), {\n            filepath: model.uri.fsPath,\n            singleQuote: true,\n            tabWidth: 2,\n            plugins,\n          });\n\n          return [\n            {\n              range: model.getFullModelRange(),\n              text: formatted,\n            },\n          ];\n        },\n      };\n    };\n\n    const codeFormattingEditProvider = createPrettierFormattingProvider();\n\n    Monaco.languages.registerDocumentFormattingEditProvider('css', codeFormattingEditProvider);\n\n    Monaco.languages.registerDocumentFormattingEditProvider('html', codeFormattingEditProvider);\n\n    Monaco.languages.registerDocumentFormattingEditProvider(\n      'javascript',\n      codeFormattingEditProvider\n    );\n\n    Monaco.languages.registerDocumentFormattingEditProvider('svelte', codeFormattingEditProvider);\n\n    Monaco.languages.registerDocumentFormattingEditProvider(\n      'typescript',\n      codeFormattingEditProvider\n    );\n\n    if (options.files) {\n      for (const pathname in options.files) {\n        const content = options.files[pathname];\n\n        this.createModel(pathname, content);\n      }\n    }\n\n    this.initialPath = options.initialPath;\n  }\n\n  get dispose() {\n    return this.disposableStore.dispose;\n  }\n\n  get onDidChange(): Event<{ model: Monaco.editor.ITextModel }> {\n    return this.onDidChangeEmitter.event;\n  }\n\n  get onWillFocusModel(): Event<Monaco.editor.ITextModel> {\n    return this.onWillFocusModelEmitter.event;\n  }\n\n  createModel(pathname: string, content = '') {\n    const language = this.inferLanguage(pathname);\n\n    let uri: Monaco.Uri;\n\n    try {\n      uri = Monaco.Uri.file(pathname);\n    } catch (err) {\n      throw new Error(`Invalid path '${pathname}': ${err && err.message}`);\n    }\n\n    if (Monaco.editor.getModel(uri)) {\n      throw new Error(`Cannot create file because it exists '${pathname}'`);\n    }\n\n    return Monaco.editor.createModel(content, language, uri);\n  }\n\n  focusHref(\n    href: string,\n    options: {\n      lineNumber?: number;\n      columnNumber?: number;\n      markers?: Monaco.editor.IMarkerData[];\n    } = {}\n  ) {\n    const model = this.getModelByHref(href);\n\n    if (model) {\n      this.focusModel(model, options);\n    }\n  }\n\n  focusModel(\n    model: Monaco.editor.ITextModel,\n    options: {\n      lineNumber?: number;\n      columnNumber?: number;\n      markers?: Monaco.editor.IMarkerData[];\n    } = {}\n  ) {\n    if (this.editor) {\n      this.editor.setModel(model);\n      if (options.lineNumber) {\n        this.editor.revealLineInCenter(options.lineNumber, Monaco.editor.ScrollType.Smooth);\n        this.editor.setPosition({\n          column: options.columnNumber || 0,\n          lineNumber: options.lineNumber,\n        });\n      }\n      if (options.markers) {\n        Monaco.editor.setModelMarkers(model, 'editorManager', options.markers);\n      }\n      this.editor.focus();\n    }\n  }\n\n  focusPath(\n    path: string,\n    options: {\n      lineNumber?: number;\n      columnNumber?: number;\n      markers?: Monaco.editor.IMarkerData[];\n    } = {}\n  ) {\n    const model = this.getModelByPath(path);\n\n    if (model) {\n      this.focusModel(model, options);\n    }\n  }\n\n  getModelByHref(href: string) {\n    try {\n      const uri = Monaco.Uri.parse(href);\n      return Monaco.editor.getModel(uri);\n    } catch (_) {\n      return null;\n    }\n  }\n\n  getModelByPath(path: string) {\n    return Monaco.editor.getModel(Monaco.Uri.file(path));\n  }\n\n  mount(el: HTMLElement) {\n    if (this.editor) {\n      throw new Error('Invariant violation: Editor already mounted');\n    }\n\n    this.editor = Monaco.editor.create(el, {\n      model: null,\n      automaticLayout: true,\n      minimap: {\n        enabled: false,\n      },\n      showUnused: true,\n      scrollBeyondLastLine: false,\n      theme: 'vs',\n      wordWrap: 'bounded',\n      wrappingIndent: 'same',\n    });\n\n    this.editor.onDidDispose(() => {\n      this.editor = null;\n    });\n\n    this.editor.onDidChangeModel((e) => {\n      if (e.newModelUrl && this.editor) {\n        const model = Monaco.editor.getModel(e.newModelUrl)!;\n        const viewState = this.viewState.get(model);\n\n        if (viewState) {\n          this.editor.restoreViewState(viewState);\n        }\n      }\n    });\n\n    this.editor.onDidBlurEditorText(() => {\n      if (this.editor) {\n        const model = this.editor.getModel();\n        const viewState = this.editor.saveViewState();\n\n        if (model && viewState) {\n          this.viewState.set(model, viewState);\n        }\n      }\n    });\n\n    this.disposableStore.add(this.editor);\n\n    if (this.initialPath) {\n      this.focusPath(this.initialPath);\n    }\n\n    return this.editor;\n  }\n\n  inferLanguage(pathname: string) {\n    return pathname.match(/\\.(?:tsx?|jsx?)$/) ? 'typescript' : undefined;\n  }\n}\n\nexport const EditorManagerContext = createContext<EditorManager>(undefined as any);\n\nexport function useActiveModel() {\n  const workbench = useContext(EditorManagerContext);\n  const [activeModel, setActiveModel] = useState<Monaco.editor.ITextModel | null>(\n    workbench.editor ? workbench.editor.getModel() : null\n  );\n\n  useEffect(() => {\n    const disposable = new DisposableStore();\n\n    const trackEditor = (editor: Monaco.editor.ICodeEditor) => {\n      editor.onDidChangeModel((e) => {\n        const model = e.newModelUrl ? Monaco.editor.getModel(e.newModelUrl) : null;\n\n        setActiveModel(model);\n      });\n\n      disposable.add(\n        editor.onDidBlurEditorText(() => {\n          setActiveModel(null);\n        })\n      );\n\n      disposable.add(\n        editor.onDidFocusEditorText(() => {\n          setActiveModel(editor.getModel());\n        })\n      );\n\n      if (editor.hasTextFocus()) {\n        setActiveModel(editor.getModel());\n      }\n    };\n\n    disposable.add(Monaco.editor.onDidCreateEditor(trackEditor));\n    if (workbench.editor) {\n      trackEditor(workbench.editor);\n    }\n\n    return () => disposable.dispose();\n  }, [workbench.editor, activeModel]);\n\n  return activeModel;\n}\n","import styled from '@emotion/styled/macro';\nimport React, { useRef, useEffect, useContext } from 'react';\nimport { EditorManagerContext } from '../lib/EditorManager';\n\nconst Editor: React.FC<{\n  className?: string;\n}> = ({ className }) => {\n  const el = useRef<HTMLDivElement | null>(null);\n  const editorManager = useContext(EditorManagerContext);\n\n  useEffect(() => {\n    if (!el.current) {\n      return;\n    }\n\n    const editor = editorManager.mount(el.current);\n\n    return () => {\n      editor.dispose();\n    };\n  }, [editorManager, el]);\n\n  return (\n    <div className={className} ref={el}>\n      <div></div>\n    </div>\n  );\n};\n\nexport default styled(Editor)``;\n","import styled from '@emotion/styled/macro';\nimport { Uri } from '@velcro/common';\nimport * as Monaco from 'monaco-editor';\nimport React, { useContext, useEffect, useRef, useState } from 'react';\nimport { EditorManagerContext } from '../lib/EditorManager';\nimport { trackMonaco } from '../velcro/monaco';\nimport { WorkerState } from '../velcro/types';\n\nexport interface DeferredExecutionModuleRecord {\n  code: string;\n  dependencies: Record<string, string>;\n}\n\nexport interface DeferredExecutionManifest {\n  aliases: Record<string, string>;\n  entrypoints: Record<string, string>;\n  modules: Record<string, DeferredExecutionModuleRecord>;\n}\n\ninterface MessageLine {\n  isInternal: boolean;\n  text: string;\n}\ninterface Message {\n  lines: MessageLine[];\n}\n\nconst PreviewProgress = styled.div<{ completed: number; total: number }>`\n  z-index: 1;\n  position: absolute;\n  top: 0;\n  width: ${(props) => (props.total ? `${Math.round((100 * props.completed) / props.total)}%` : 0)};\n  left: 0;\n  height: ${(props) => (props.total ? '2px' : '0')};\n  background-color: #008cba;\n  transition: width 0.5s 0s cubic-bezier(0.455, 0.03, 0.515, 0.955);\n`;\nconst PreviewIframeWrap = styled.div`\n  position: relative;\n  overflow: hidden;\n\n  & > iframe {\n    position: absolute;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n    border: none;\n    width: 100%;\n    height: 100%;\n  }\n`;\nconst PreviewWrap = styled.div`\n  position: relative;\n  background: white;\n\n  ${PreviewIframeWrap} {\n    position: absolute;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n  }\n`;\nconst PreviewMessageError = styled.ul`\n  margin: 0;\n  padding: 1em 2em;\n  font-family: monospace;\n  font-size: 16px;\n  background-color: rgba(255, 0, 0, 0.5);\n  backdrop-filter: brightness(50%);\n  color: white;\n  list-style: none;\n`;\nconst PreviewMessageErrorText = styled.li<{ isInternal: boolean }>`\n  white-space: pre-wrap;\n  opacity: ${(props) => (props.isInternal ? 0.7 : 1.0)};\n`;\nconst PreviewMessages = styled.div`\n  z-index: 1;\n  position: absolute;\n  bottom: 0;\n  right: 0;\n  left: 0;\n  display: flex;\n  flex-direction: column-reverse;\n`;\nconst PreviewMessageLine: React.FC<{ line: MessageLine }> = ({ line }) => {\n  return (\n    <PreviewMessageErrorText isInternal={line.isInternal}>{line.text}</PreviewMessageErrorText>\n  );\n};\nconst PreviewMessage: React.FC<{ message: Message }> = ({ message }) => {\n  return message.lines.length ? (\n    <PreviewMessageError>\n      {message.lines.map((line, i) => (\n        <PreviewMessageLine key={i} line={line}></PreviewMessageLine>\n      ))}\n    </PreviewMessageError>\n  ) : null;\n};\n\nconst Preview: React.FC<{ className?: string }> = (props) => {\n  const editorManager = useContext(EditorManagerContext);\n  const previewWrapRef = useRef<HTMLDivElement | null>(null);\n  const previewIframeRef = useRef<HTMLIFrameElement | null>(null);\n  const [buildState, setBuildState] = useState<WorkerState>({\n    state: 'initial',\n  });\n  const [buildProgress, setBuildProgress] = useState({ completed: 0, total: 0 });\n\n  useEffect(() => {\n    const onMessage = (e: MessageEvent) => {\n      if (\n        previewIframeRef.current &&\n        previewIframeRef.current.contentWindow === e.source &&\n        e.data.event === 'click_error'\n      ) {\n        editorManager.focusPath(Uri.parse(e.data.entry.file).fsPath, {\n          columnNumber: e.data.entry.column,\n          lineNumber: e.data.entry.line,\n        });\n      }\n    };\n\n    window.addEventListener('message', onMessage);\n\n    return () => window.removeEventListener('message', onMessage);\n  });\n\n  useEffect(() => {\n    const monacoIntegration = trackMonaco(Monaco);\n\n    monacoIntegration.onStateChange((state) => {\n      setBuildState(state);\n\n      switch (state.state) {\n        case 'building': {\n          setBuildProgress({\n            completed: state.completed,\n            total: state.completed + state.pending,\n          });\n          break;\n        }\n        case 'built': {\n          console.debug(\n            'Rebuild finished, build latency: %d, end-to-end latency: %d',\n            state.end - state.start,\n            Date.now() - state.start\n          );\n\n          const iframe = document.createElement('iframe');\n          iframe.style.display = 'none';\n          iframe.src = state.href;\n\n          if (previewWrapRef.current) {\n            previewWrapRef.current.appendChild(iframe);\n          }\n\n          const onLoad = () => {\n            iframe.removeEventListener('error', onError);\n            iframe.style.display = '';\n\n            if (previewIframeRef.current) {\n              previewIframeRef.current.remove();\n            }\n\n            previewIframeRef.current = iframe;\n          };\n          const onError = () => {\n            iframe.removeEventListener('load', onLoad);\n            iframe.remove();\n          };\n\n          iframe.addEventListener('load', onLoad, { once: true });\n          iframe.addEventListener('error', onError, { once: true });\n\n          break;\n        }\n      }\n    });\n\n    return () => {\n      monacoIntegration.dispose();\n    };\n  }, [setBuildProgress, setBuildState]);\n\n  return (\n    <PreviewWrap className={props.className}>\n      {buildState.state === 'building' ? (\n        <PreviewProgress\n          completed={buildProgress.completed}\n          total={buildProgress.total}\n        ></PreviewProgress>\n      ) : null}\n      <PreviewIframeWrap ref={previewWrapRef}></PreviewIframeWrap>\n      <PreviewMessages>\n        {buildState.state === 'error' ? (\n          <PreviewMessage\n            message={{ lines: [{ isInternal: true, text: buildState.error.message }] }}\n          ></PreviewMessage>\n        ) : null}\n      </PreviewMessages>\n    </PreviewWrap>\n  );\n};\n\nexport default styled(Preview)``;\n","import { DisposableStore } from '@velcro/common';\nimport * as Monaco from 'monaco-editor';\nimport { useEffect, useState } from 'react';\n\n// import { EditorContext } from './context';\n\nexport enum EntryKind {\n  Directory = 'directory',\n  File = 'file',\n}\n\nexport interface IDirectory {\n  type: EntryKind.Directory;\n  uri: Monaco.Uri;\n}\nexport interface IFile {\n  type: EntryKind.File;\n  uri: Monaco.Uri;\n  model: Monaco.editor.ITextModel;\n}\n\nexport type DirectoryEntry = IDirectory | IFile;\n\nexport function useDirectory(uri: Monaco.Uri) {\n  // Make sure the URI always ends with a trailing slash\n  const prefix = uri.toString(true).replace(/\\/?$/, '/');\n  const sortEntries = (models: DirectoryEntry[]) => {\n    return [...models].sort((a, b) => (a.uri.fsPath > b.uri.fsPath ? 1 : -1));\n  };\n\n  const initialEntries = sortEntries(\n    Monaco.editor.getModels().reduce((entries, model) => {\n      const modelUri = model.uri.toString(true);\n\n      if (modelUri.startsWith(prefix)) {\n        const nestedPath = modelUri.slice(prefix.length);\n        const nextDirIdx = nestedPath.indexOf('/');\n\n        if (nextDirIdx === 0) {\n          throw new Error('Invariant error: WAT?');\n        }\n\n        if (nextDirIdx > 0) {\n          // This is an intermediate directory\n          const uri = Monaco.Uri.parse(`${prefix}${nestedPath.slice(0, nextDirIdx + 1)}`);\n\n          entries.push({\n            type: EntryKind.Directory,\n            uri,\n          });\n        } else {\n          entries.push({\n            type: EntryKind.File,\n            uri: model.uri,\n            model,\n          });\n        }\n      }\n\n      return entries;\n    }, [] as DirectoryEntry[])\n  );\n  const [entries, setEntries] = useState(initialEntries);\n\n  useEffect(() => {\n    const disposable = new DisposableStore();\n    const prefix = uri.toString(true).replace(/\\/?$/, '/');\n\n    disposable.add(\n      Monaco.editor.onDidCreateModel((model: Monaco.editor.ITextModel) => {\n        const modelUri = model.uri.toString(true);\n\n        if (modelUri.startsWith(prefix)) {\n          const nestedPath = modelUri.slice(prefix.length);\n          const nextDirIdx = nestedPath.indexOf('/');\n\n          if (nextDirIdx === 0) {\n            throw new Error('Invariant error: WAT?');\n          }\n\n          if (nextDirIdx > 0) {\n            // This is an intermediate directory\n            const uri = Monaco.Uri.parse(`${prefix}${nestedPath.slice(0, nextDirIdx)}`);\n\n            // It is possible that we already have this directory\n            const entry = entries.find((entry) => entry.uri.toString(true) === uri.toString(true));\n\n            if (entry) {\n              if (entry.type !== EntryKind.Directory) {\n                throw new Error(\n                  `Invariant violation: A file in '${prefix}' conflicts with the path of the new file '${modelUri}'`\n                );\n              }\n\n              return;\n            }\n\n            entries.push({ type: EntryKind.Directory, uri });\n\n            return setEntries(sortEntries(entries));\n          }\n\n          if (\n            !entries.find(\n              (entry) =>\n                entry.type === EntryKind.File &&\n                entry.uri.toString(true) === model.uri.toString(true)\n            )\n          ) {\n            entries.push({ type: EntryKind.File, uri: model.uri, model });\n\n            setEntries(sortEntries(entries));\n          }\n        }\n      })\n    );\n\n    disposable.add(\n      Monaco.editor.onWillDisposeModel((model) => {\n        const idx = entries.findIndex(\n          (entry) => entry.type === EntryKind.File && entry.model === model\n        );\n\n        if (idx === -1) {\n          throw new Error(\n            `Invariant violation: Removing an untracked model: '${model.uri.fsPath}'`\n          );\n        }\n\n        entries.splice(idx, 1);\n\n        setEntries(sortEntries(entries));\n      })\n    );\n\n    return () => disposable.dispose();\n  }, [entries, uri]);\n\n  return entries;\n}\n","import styled from '@emotion/styled/macro';\nimport * as Monaco from 'monaco-editor';\nimport React, { useContext, useRef } from 'react';\nimport { Button } from 'reakit/Button';\nimport { Tooltip, TooltipReference, useTooltipState } from 'reakit/Tooltip';\nimport { useDirectory, EntryKind } from '../lib/hooks';\nimport { useActiveModel, EditorManagerContext } from '../lib/EditorManager';\n\nconst Entry = styled.div<{ modelFocused: boolean }>`\n  background-color: ${props => (props.modelFocused ? '#008cba' : 'inherit')};\n  text-decoration: none;\n  color: ${props => (props.modelFocused ? '#fff' : '#262626')};\n\n  height: 25px;\n  padding: 0 0 0 8px;\n  display: flex;\n  flex-direction: row;\n  align-items: center;\n\n  & > span {\n    flex: 1;\n  }\n\n  & > button {\n    display: none;\n  }\n\n  &:hover > button {\n    display: block;\n  }\n\n  ${props =>\n    props.modelFocused\n      ? {\n          ':hover': {\n            color: '#f5f5f5',\n            cursor: 'pointer',\n          },\n        }\n      : {\n          ':hover': {\n            backgroundColor: '#eee',\n            color: '#262626',\n            cursor: 'pointer',\n          },\n        }}\n`;\n\nconst CreateEntry = styled.div`\n  text-decoration: none;\n  color: '#262626';\n\n  height: 25px;\n  padding: 0 0 0 8px;\n  display: flex;\n  align-items: center;\n\n  :hover {\n    background-color: #eee;\n    cursor: pointer;\n  }\n`;\n\nconst SidebarFileDelete = styled(Button)`\n  border: none;\n  background: none;\n\n  :hover {\n    cursor: pointer;\n  }\n`;\n\nconst StyledTooltip = styled.div`\n  font-family: Open Sans, Helvetica Neue, Helvetica, Arial, sans-serif;\n  font-size: 14px;\n  line-height: 1.4;\n  background-color: #333;\n  color: #fff;\n  border-radius: 4px;\n  opacity: 0.9;\n  padding: 0.2em 0.4em;\n`;\n\nconst SidebarFile: React.FC<{ className?: string; model: Monaco.editor.ITextModel }> = ({ className, model }) => {\n  const activeModel = useActiveModel();\n  const editorManager = useContext(EditorManagerContext);\n  const tooltip = useTooltipState({ gutter: 0 });\n\n  const onClickDelete = () => {\n    model.dispose();\n  };\n\n  return (\n    <Entry className={className} modelFocused={model === activeModel}>\n      <span onClick={() => editorManager.focusModel(model)}>{model.uri.fsPath.slice(1)}</span>\n      <TooltipReference {...tooltip} as={SidebarFileDelete} onClick={() => onClickDelete()}>\n        <span role=\"img\" aria-label=\"Delete file\">\n          ❌\n        </span>\n      </TooltipReference>\n      <Tooltip {...tooltip} as={StyledTooltip}>\n        Delete file\n      </Tooltip>\n    </Entry>\n  );\n};\n\nconst Sidebar: React.FC<{ className?: string }> = props => {\n  const rootDir = useRef(Monaco.Uri.file('/'));\n  const entries = useDirectory(rootDir.current);\n  const editorManager = useContext(EditorManagerContext);\n\n  const onClickCreate = () => {\n    const filename = prompt('Filename?');\n\n    if (filename) {\n      editorManager.createModel(filename);\n    }\n  };\n\n  return (\n    <div className={props.className}>\n      {entries.map(entry =>\n        entry.type === EntryKind.Directory ? (\n          <div>{entry.uri.fsPath.slice(1)}</div>\n        ) : (\n          <SidebarFile key={entry.uri.toString(true)} model={entry.model}></SidebarFile>\n        )\n      )}\n      <CreateEntry onClick={() => onClickCreate()}>Create...</CreateEntry>\n    </div>\n  );\n};\n\nexport default styled(Sidebar)`\n  display: flex;\n  flex-direction: column;\n`;\n","import styled from '@emotion/styled/macro';\nimport React from 'react';\n\nimport Editor from './Editor';\nimport Preview from './Preview';\nimport Sidebar from './Sidebar';\nimport { EditorManager, EditorManagerContext } from '../lib/EditorManager';\n\nconst PlaygroundCmp: React.FC<{\n  className?: string;\n  initialPath: string;\n  project: Record<string, string>;\n}> = ({ className, initialPath, project }) => {\n  const editorManager = new EditorManager({ files: project, initialPath: initialPath });\n\n  return (\n    <div className={className}>\n      <EditorManagerContext.Provider value={editorManager}>\n        <Sidebar></Sidebar>\n        <Editor></Editor>\n        <Preview></Preview>\n      </EditorManagerContext.Provider>\n    </div>\n  );\n};\n\nexport const Playground = styled(PlaygroundCmp)`\n  display: flex;\n  flex-direction: row;\n\n  font-family: Open Sans, Helvetica Neue, Helvetica, Arial, sans-serif;\n  font-size: 14px;\n  line-height: 1.4;\n\n  color: #222;\n\n  ${Sidebar} {\n    flex: 1 1 100px;\n    min-width: 100px;\n    max-width: 400px;\n    border-right: 1px solid #ccc;\n  }\n\n  ${Editor} {\n    border-right: 1px solid #ccc;\n  }\n\n  ${Editor}, ${Preview} {\n    flex: 10;\n  }\n`;\n","export const files = {\n  'package.json':\n    JSON.stringify(\n      {\n        name: 'test',\n        version: '0.0.0',\n        dependencies: {\n          'github-markdown-css': '^3.0.1',\n          svelte: '^3.24.0',\n        },\n      },\n      null,\n      2\n    ) + '\\n',\n  'index.jsx':\n    `\nimport App from './App.svelte';\n\nnew App({\n  target: document.body,\n});\n    `.trim() + '\\n',\n  'App.svelte':\n    `\n<script>\n  import Explanation from './Explanation.svelte';\n  import 'github-markdown-css';\n</script>\n\n<main class=\"markdown-body\">\n  <h1>Velcro Playground</h1>\n  <blockquote>Example of 💯 % browser module loading and bundling.</blockquote>\n  <Explanation />\n</main>\n  `.trim() + '\\n',\n  'Explanation.svelte':\n    `\n<section>\n  <h2>Give it a try</h2>\n  <p>Here's what you should try:</p>\n  <ul>\n    <li>✍️ Change any of the code you see.</li>\n    <li>\n      📦 Change any of the dependencies versions or introduce your own in the\n      <code>package.json</code>\n      file.\n    </li>\n    <li>💄 Try writing some css, or maybe making a TypeScript file...</li>\n    <li>\n      🕵🏼‍♂️ Checking out the action in the network tab of Developer Tools or seeing\n      the generated source maps in the sources tab.\n    </li>\n  </ul>\n</section>\n<section>\n  <h2>How does it work</h2>\n  <p>\n    Velcro is a fully web-based dependency resolver, loader and bundler. In this\n    playground, it has been configured to treat files in the editor as being at\n    <code>file://</code>\n    , and npm modules as being at\n    <code>https://cdn.jsdelivr.net</code>\n    . Inter-module dependencies are all resolved to satisfy the requested ranges\n    and are loaded at maximum concurrency from jsDelivr.\n  </p>\n  <p>\n    As each file is resolved and read, it is run through a series of plugin\n    hooks that are heavily inspired by Rollup. Each hook has a default fallback\n    implementation that allows us to resolve, load and transform individual\n    files. In the playground, Velcro has been configured with a css plugin and a\n    <a\n      href=\"https://github.com/alangpierce/sucrase\"\n      target=\"blank\"\n      rel=\"noopener\">\n      sucrase\n    </a>\n    plugin (for ESM and TypeScript).\n  </p>\n  <p>\n    After processing each individual file, we parse it so that its AST can be\n    traversed to:\n  </p>\n  <ul>\n    <li>Calculate scope metadata and identifier bindings</li>\n    <li>\n      Identify calls to\n      <code>require</code>\n    </li>\n    <li>Identify calls Node.js global objects so that shims can be injected</li>\n    <li>\n      Prune branches based on\n      <code>process.env.NODE_ENV</code>\n    </li>\n  </ul>\n  <p>\n    This work allows us to build out a full dependency graph of modules. This\n    graph has information about every url consulted at each step of the process,\n    so small parts of it can be efficiently invalidated. Once the graph is\n    complete, it can be serialized into a bundle of JavaScript code. At this\n    point, we can decide if we want to include source maps or not.\n  </p>\n  <p>\n    The bundled code is written to browser-internal storage using the\n    <code>File</code>\n    API and an\n    <code>iframe</code>\n    is constructed dynamically that links to this. Every new generation of\n    bundle will cause the\n    <code>iframe</code>\n    to be replaced.\n  </p>\n</section>\n  `.trim() + '\\n',\n};\n","import React from 'react';\n\n// import * as serviceWorker from './serviceWorker';\n\ninterface ServiceWorkerEvent extends Event {\n  target: (Partial<ServiceWorker> & EventTarget) | null;\n}\n\ninterface ServiceWorkerContextValue {\n  assetsUpdateReady: boolean;\n  assetsCached: boolean;\n  updateAssets(): void;\n}\n\nconst ServiceWorkerContext = React.createContext<ServiceWorkerContextValue | undefined>(undefined);\n\nexport function ServiceWorkerProvider(props: React.PropsWithChildren<{}>) {\n  const [waitingServiceWorker, setWaitingServiceWorker] = React.useState<ServiceWorker | null>(\n    null\n  );\n  const [assetsUpdateReady, setAssetsUpdateReady] = React.useState(false);\n  const [assetsCached, setAssetsCached] = React.useState(false);\n\n  const value = React.useMemo(() => {\n    return {\n      assetsUpdateReady,\n      assetsCached,\n      // Call when the user confirm update of application and reload page\n      updateAssets: () => {\n        if (waitingServiceWorker) {\n          waitingServiceWorker.addEventListener('statechange', (event: ServiceWorkerEvent) => {\n            if (event.target && event.target.state === 'activated') {\n              window.location.reload();\n            }\n          });\n\n          waitingServiceWorker.postMessage({ type: 'SKIP_WAITING' });\n        }\n      },\n    };\n  }, [assetsUpdateReady, assetsCached, waitingServiceWorker]);\n\n  // Once on component mounted subscribe to Update and Succes events in\n  // CRA's service worker wrapper\n  // React.useEffect(() => {\n  //   serviceWorker.register({\n  //     onUpdate: (registration) => {\n  //       setWaitingServiceWorker(registration.waiting);\n  //     },\n  //     onUpdateAvailable: () => {\n  //       setAssetsUpdateReady(true);\n  //     },\n  //     onSuccess: (registration) => {\n  //       setAssetsCached(true);\n  //       setAssetsUpdateReady(false);\n\n  //       if (registration.active) {\n  //         registration.active.addEventListener('statechange', (event: ServiceWorkerEvent) => {\n  //           if (!navigator.serviceWorker.controller) {\n  //             setAssetsCached(false);\n  //           }\n  //         });\n  //       }\n  //     },\n  //   });\n  // }, []);\n\n  return <ServiceWorkerContext.Provider value={value} {...props} />;\n}\n\nexport function useServiceWorker() {\n  const context = React.useContext(ServiceWorkerContext);\n\n  if (!context) {\n    throw new Error('useServiceWorker must be used within a ServiceWorkerProvider');\n  }\n\n  return context;\n}\n","//@ts-nocheck\nimport { Global, css } from '@emotion/core';\nimport styled from '@emotion/styled/macro';\nimport CssBaseline from '@material-ui/core/CssBaseline';\nimport { OfflineBolt, Update } from '@material-ui/icons';\nimport React from 'react';\nimport { Tooltip, TooltipReference, useTooltipState } from 'reakit/Tooltip';\n\nimport { Playground } from './playground';\nimport { files } from './templates/svelte';\nimport { useServiceWorker, ServiceWorkerProvider } from './useServiceWorker';\nimport { Button } from 'reakit/Button';\n\nconst PlaygroundWrapper = styled.div`\n  background: white;\n  color: #666;\n  display: flex;\n  flex-direction: column;\n\n  ${Playground} {\n    border-bottom: 1px solid #ccc;\n    flex: 1;\n  }\n`;\n\nconst StatusBarItem = styled.span`\n  display: inline-flex;\n  flex-direction: row;\n  align-items: center;\n`;\n\nconst ReloadButton = styled(Button)`\n  border: 0;\n  background: #008cba;\n  margin: 0 0.5em;\n  color: white;\n  border-radius: 2px;\n  font-weight: 600;\n\n  :hover {\n    cursor: pointer;\n    text-decoration: underline;\n  }\n`;\n\nconst StyledTooltip = styled.div`\n  font-family: Open Sans, Helvetica Neue, Helvetica, Arial, sans-serif;\n  font-size: 14px;\n  line-height: 1.4;\n  background-color: #333;\n  color: #fff;\n  border-radius: 4px;\n  opacity: 0.9;\n  padding: 0.2em 0.4em;\n`;\n\nconst StatusBar: React.FC = () => {\n  const serviceWorker = useServiceWorker();\n  const offlineTooltip = useTooltipState({ gutter: 0 });\n  const reloadTooltip = useTooltipState({ gutter: 0 });\n\n  return (\n    <StatusBarStyles>\n      {serviceWorker.assetsCached ? (\n        <TooltipReference {...offlineTooltip} as={StatusBarItem}>\n          <OfflineBolt color=\"inherit\" fontSize=\"small\" />\n          &nbsp;Offline ready\n        </TooltipReference>\n      ) : null}\n      <Tooltip {...offlineTooltip} as={StyledTooltip}>\n        This application has been fully cached and can now be used offline.\n      </Tooltip>\n\n      {serviceWorker.assetsUpdateReady ? (\n        <TooltipReference {...reloadTooltip} as={StatusBarItem}>\n          <Update color=\"inherit\" fontSize=\"small\" />\n          &nbsp;Update ready:\n          <ReloadButton onClick={() => serviceWorker.updateAssets()}>Reload</ReloadButton>\n        </TooltipReference>\n      ) : null}\n      <Tooltip {...reloadTooltip} as={StyledTooltip}>\n        There is an update of this application ready to install. Click install reload to install the\n        update and reload the page.\n      </Tooltip>\n    </StatusBarStyles>\n  );\n};\n\nconst StatusBarStyles = styled.div`\n  display: flex;\n  flex-direction: row;\n\n  font-size: 90%;\n\n  height: 24px;\n  padding: 0 0.5em;\n\n  ${StatusBarItem} {\n    margin-left: 0.5em;\n    margin-right: 0.5em;\n  }\n`;\n\nconst AppWrapper = styled.div`\n  width: 100%;\n  min-width: 200px;\n  max-width: 80vw;\n  margin: 0 auto;\n  padding: 0 0 45px 0;\n\n  @media (max-width: 960px) {\n    padding: 0 15px 15px 15px;\n    max-width: initial;\n  }\n\n  display: flex;\n  flex-direction: column;\n\n  ${PlaygroundWrapper} {\n    flex: 1;\n    background: #f5f5f5;\n    border-radius: 2px;\n    box-shadow: 0 10px 20px rgba(0, 0, 0, 0.19), 0 6px 6px rgba(0, 0, 0, 0.23);\n\n    ${StatusBarStyles} {\n    }\n  }\n`;\n\nconst Title = styled.div`\n  font-family: 'Raleway', sans-serif;\n  font-size: 250%;\n  font-weight: 800;\n  font-variant: small-caps;\n  font-variant-caps: small-caps;\n  color: #00bfff;\n`;\n\nconst Subtitle = styled.div`\n  color: #ddd;\n  font-size: 120%;\n  font-weight: 400;\n`;\n\nconst Link = styled.a`\n  color: white;\n  text-decoration: none;\n\n  :hover {\n    text-decoration: underline;\n  }\n`;\n\nconst Links = styled.div`\n  display: flex;\n  flex-direction: row;\n\n  & > *:not(:last-child):after {\n    padding: 0 0.5em;\n    content: '｜';\n    color: #aaa;\n    text-decoration: none;\n  }\n\n  ${Link} {\n    color: #ccc;\n  }\n`;\n\nconst Header = styled.div`\n  display: flex;\n  flex-direction: row;\n  align-items: baseline;\n  padding: 0.8em 0 0.3em 0;\n  text-shadow: #000 1px 1px 5px;\n\n  ${Title} {\n    margin-right: 0.5em;\n  }\n\n  ${Subtitle} {\n    margin-right: 0.5em;\n  }\n\n  ${Links} {\n    flex: 1;\n    justify-content: flex-end;\n  }\n`;\n\nconst globalCss = css`\n  @import url('https://fonts.googleapis.com/css?family=Raleway:900&display=swap');\n\n  *,\n  *::before,\n  *::after {\n    box-sizing: border-box;\n  }\n\n  html,\n  body {\n    margin: 0;\n    padding: 0;\n    min-height: 100vh;\n\n    font-family: Open Sans, Helvetica Neue, Helvetica, Arial, sans-serif;\n    font-size: 14px;\n    line-height: 1.4;\n\n    background: #333;\n    color: #fff;\n\n    display: flex;\n    flex-direction: column;\n\n    #root {\n      flex: 1;\n      display: flex;\n      flex-direction: column;\n\n      ${AppWrapper} {\n        flex: 1;\n      }\n    }\n  }\n`;\n\nexport const App: React.FC = () => {\n  return (\n    <ServiceWorkerProvider>\n      <CssBaseline />\n      <AppWrapper>\n        <Global styles={globalCss}></Global>\n        <Header>\n          <Title>Velcro</Title>\n          <Subtitle>The client-side bundler and playground</Subtitle>\n          <Links>\n            <div>\n              <Link href=\"https://twitter.com/filearts\" target=\"_blank\" rel=\"nofollow noreferrer\">\n                @filearts\n              </Link>\n            </div>\n            <div>\n              <Link\n                href=\"https://github.com/ggoodman/velcro\"\n                target=\"_blank\"\n                rel=\"nofollow noreferrer\"\n              >\n                View on GitHub\n              </Link>\n            </div>\n          </Links>\n        </Header>\n        <PlaygroundWrapper>\n          <Playground project={files} initialPath=\"index.jsx\"></Playground>\n        </PlaygroundWrapper>\n      </AppWrapper>\n    </ServiceWorkerProvider>\n  );\n};\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://cra.link/PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(/^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/)\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://cra.link/PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://cra.link/PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch((error) => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log('No internet connection found. App is running in offline mode.');\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then((registration) => {\n        registration.unregister();\n      })\n      .catch((error) => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\n\nimport { App } from './App';\nimport * as serviceWorker from './serviceWorker';\n\nserviceWorker.unregister();\n\nReactDOM.render(<App />, document.getElementById('root'));\n","const SPEC_RX = /^((@[^/]+\\/[^/@]+|[^./@][^/@]*)(?:@([^/]+))?)(.*)?$/;\n\ntype _BareModuleSpec<T = ReturnType<typeof parseBareModuleSpec>> = T extends null | undefined\n  ? never\n  : T;\nexport type BareModuleSpec = _BareModuleSpec;\n\nexport function parseBareModuleSpec(bareModuleSpec: string) {\n  const matches = bareModuleSpec.match(SPEC_RX);\n\n  if (matches) {\n    const [, nameSpec, name, spec, path = ''] = matches;\n\n    return {\n      nameSpec,\n      name,\n      spec,\n      path,\n    };\n  }\n\n  return null;\n}\n","import { version as nodeLibsVersion } from '@velcro/node-libs/package.json';\nimport { BareModuleSpec, parseBareModuleSpec } from './bareModules';\n\nexport const NODE_CORE_SHIMS: Record<string, BareModuleSpec | undefined> = Object.assign(\n  Object.create(null),\n  {\n    string_decoder: parseBareModuleSpec('string_decoder@1.2.0'),\n    punycode: parseBareModuleSpec('punycode@2.1.1'),\n  }\n);\n\nfor (const name of [\n  'assert',\n  'buffer',\n  'constants',\n  'crypto',\n  'events',\n  'fs',\n  'http',\n  'https',\n  'net',\n  'os',\n  'path',\n  'process',\n  'querystring',\n  'stream',\n  'tls',\n  'url',\n  'util',\n  'vm',\n  'zlib',\n]) {\n  NODE_CORE_SHIMS[name] = parseBareModuleSpec(\n    `@velcro/node-libs@${nodeLibsVersion}/lib/${name}.js`\n  )!;\n}\n","import type { Thenable, Uri } from '@velcro/common';\nimport type { ResolverContext } from './context';\nimport type { Resolver } from './resolver';\n\ntype MaybeThenable<T> = T | Thenable<T>;\n\nexport interface ResolverStrategy {\n  /**\n   * Produce a url given the components of a bare module specifier.\n   *\n   * @param ctx A `ResolverContext` that should be used for making calls to other strategy methods\n   * @param name The name of a bare module\n   * @param spec The optional `@version` of a bare module specifier\n   * @param path The optional path at the end of the bare module specifier\n   */\n  getUrlForBareModule?(\n    ctx: ResolverContext,\n    name: string,\n    spec: string,\n    path: string\n  ): MaybeThenable<ResolverStrategy.BareModuleResult>;\n\n  /**\n   * Determine the canonical uri for a given uri.\n   *\n   * For example, you might consider symlink targets their canonicalized path or you might\n   * consider the canonicalized path of https://unpkg.com/react to be\n   * https://unpkg.com/react@16.13.1/index.js.\n   *\n   * Dealing only in canonical uris means that anything produced from those can be cached.\n   *\n   * @param ctx A `ResolverContext` that should be used for making calls to other strategy methods\n   * @param uri The uri to canonicalize\n   */\n  getCanonicalUrl(\n    ctx: ResolverContext,\n    uri: Uri\n  ): MaybeThenable<ResolverStrategy.CanonicalizeResult>;\n\n  /**\n   * Get the logical resolve root for a given uri.\n   *\n   * For example, a filesystem-based strategy might consider the root to be `file:///`. Or,\n   * if it was scoped to /home/filearts, the root might be `file:///home/filearts/`.\n   *\n   * Any uri that is not a 'child' of the resolve root should be considered out of scope for a given\n   * strategy.\n   *\n   * @param ctx A `ResolverContext` that should be used for making calls to other strategy methods\n   * @param uri The uri for which the logical resolve root uri should be found\n   */\n  getResolveRoot(ctx: ResolverContext, uri: Uri): MaybeThenable<ResolverStrategy.ResolveRootResult>;\n\n  /**\n   * Get the settings for a given uri\n   *\n   * This indirection allows resolver strategies to have per-strategy or even per-uri settings.\n   *\n   * @param ctx A `ResolverContext` that should be used for making calls to other strategy methods\n   * @param uri The uri for which to load settings\n   */\n  getSettings(ctx: ResolverContext, uri: Uri): MaybeThenable<ResolverStrategy.SettingsResult>;\n\n  /**\n   * Produce a list of resolved entries that are direct children of the given uri.\n   *\n   * This is the moral equivalent to something like non-recursive `fs.readdir()`. It is only\n   * designed to show files and folders (for now).\n   *\n   * @param ctx A `ResolverContext` that should be used for making calls to other strategy methods\n   * @param uri The uri at which to list entries\n   */\n  listEntries(ctx: ResolverContext, uri: Uri): MaybeThenable<ResolverStrategy.ListEntriesResult>;\n\n  /**\n   * Read the content at the uri as an `ArrayBuffer`\n   *\n   * ArrayBuffers are the lowest-common-denominator across the web and node and can easily be\n   * decoded with standard web apis like `StringDecoder`. In Node.js, `Buffer` objects are also\n   * `ArrayBuffer`s, allowing the tooling to be built on that primitive.\n   *\n   * This is helpful for the understanding that not all uris are expected to produce meaningful\n   * text representations.\n   *\n   * @param ctx A `ResolverContext` that should be used for making calls to other strategy methods\n   * @param uri The uri at which to read the content\n   */\n  readFileContent(\n    ctx: ResolverContext,\n    uri: Uri\n  ): MaybeThenable<ResolverStrategy.ReadFileContentResult>;\n}\n\nexport interface ResolverStrategyWithRoot extends ResolverStrategy {\n  /**\n   * The root uri of the strategy.\n   *\n   * A common parent to all uris that this strategy can handle.\n   *\n   * This may sometimes be the same value as would be returned by `getResolveRoot` but will\n   * sometimes be a parent of that. Take, for example Unpkg; there, we may want to express\n   * that a strategy should 'own' all uris under https://unpkg.com/ even though the resolve\n   * root for https://unpkg.com/react@16.13.1/index.js will actually be\n   * https://unpkg.com/react@16.13.1/.\n   *\n   * Notably, the `CompoundResolverStrategy` requires all child strategies implement the\n   * `ResolverStrategyWithRoot` interface because it dispatches operations on different\n   * uris according to each strategy's `rootUri`.\n   */\n  rootUri: Uri;\n}\n\nexport namespace ResolverStrategy {\n  export enum EntryKind {\n    File = 'file',\n    Directory = 'directory',\n  }\n\n  export interface Entry<TKind extends EntryKind = EntryKind> {\n    uri: Uri;\n    type: TKind;\n  }\n\n  export type BareModuleResult = {\n    found: boolean;\n    uri: Uri | null;\n  };\n\n  export interface CanonicalizeResult {\n    uri: Uri;\n  }\n\n  export interface ResolveRootResult {\n    uri: Uri;\n  }\n\n  export interface SettingsResult {\n    settings: Resolver.Settings;\n  }\n\n  export interface ListEntriesResult {\n    entries: Entry[];\n  }\n\n  export interface ReadFileContentResult {\n    content: ArrayBuffer;\n  }\n}\n\nexport abstract class AbstractResolverStrategy implements ResolverStrategy {\n  getCanonicalUrl(\n    _ctx: ResolverContext,\n    uri: Uri\n  ): ReturnType<ResolverStrategy['getCanonicalUrl']> {\n    return {\n      uri,\n    };\n  }\n\n  getSettings(ctx: ResolverContext, _uri: Uri): ReturnType<ResolverStrategy['getSettings']> {\n    return {\n      settings: ctx.settings,\n    };\n  }\n\n  /**\n   * Create a new ResolverStrategy having one or more methods overridden.\n   *\n   * You might use this if you want to override specific behaviour of another strategy without\n   * wanting to re-implement the whole strategy.\n   *\n   * If you need to invoke an overridden method, the overridden strategy will be available\n   * on `this.parent`.\n   *\n   * @param overrides A map of ResolverStrategy methods that you would like to override\n   */\n  withOverrides(\n    overrides: {\n      [TMethodName in keyof ResolverStrategy]?: ResolverStrategy[TMethodName];\n    }\n  ): ResolverStrategy {\n    const strategy = { ...overrides, parent: this };\n\n    return Object.setPrototypeOf(Object.assign(Object.create(null), strategy), this);\n  }\n\n  abstract getResolveRoot(\n    ctx: ResolverContext,\n    uri: Uri\n  ): ReturnType<ResolverStrategy['getResolveRoot']>;\n  abstract listEntries(ctx: ResolverContext, uri: Uri): ReturnType<ResolverStrategy['listEntries']>;\n  abstract readFileContent(\n    ctx: ResolverContext,\n    uri: Uri\n  ): ReturnType<ResolverStrategy['readFileContent']>;\n}\n\nexport abstract class AbstractResolverStrategyWithRoot extends AbstractResolverStrategy\n  implements ResolverStrategyWithRoot {\n  constructor(readonly rootUri: Uri) {\n    super();\n  }\n}\n","import {\n  all,\n  Awaited,\n  basename,\n  CanceledError,\n  CancellationToken,\n  CancellationTokenSource,\n  checkCancellation,\n  Decoder,\n  DependencyNotFoundError,\n  dirname,\n  EntryExcludedError,\n  EntryNotFoundError,\n  isThenable,\n  MapSet,\n  PackageJson,\n  parseBufferAsPackageJson,\n  parseBufferAsPartialPackageJson,\n  PartialPackageJson,\n  Thenable,\n  Uri,\n} from '@velcro/common';\nimport { BareModuleSpec, parseBareModuleSpec } from './bareModules';\nimport type { Resolver } from './resolver';\nimport { NODE_CORE_SHIMS } from './shims';\nimport { ResolverStrategy } from './strategy';\n\ntype ReturnTypeWithVisits<\n  T extends (...args: any[]) => any,\n  TReturn = ReturnType<T>\n> = TReturn extends Thenable<infer U>\n  ? Promise<U & { visited: ResolverContext.Visit[] }>\n  : TReturn & { visited: ResolverContext.Visit[] };\n\n// type UncachedReturnType<T> = { [K in keyof T] : K extends typeof CACHE ? never : T[K] };\n// type UncachedReturn<\n//   T extends (...any: any[]) => any,\n//   TReturn = ReturnType<T>\n// > = TReturn extends Thenable<infer U>\n//   ? Thenable<UncachedReturnType<U>>\n//   : UncachedReturnType<TReturn>;\n\nconst CACHE = Symbol('Context.cache');\n\ntype InvalidationRecord = {\n  cacheKey: string;\n  operationCache: Map<string, unknown>;\n};\n\ntype ResolveResult =\n  | {\n      found: false;\n      uri: null;\n      parentPackageJson?: { packageJson: PackageJson; uri: Uri };\n    }\n  | {\n      found: true;\n      uri: null;\n      parentPackageJson?: { packageJson: PackageJson; uri: Uri };\n      rootUri: Uri;\n    }\n  | {\n      found: true;\n      uri: Uri;\n      parentPackageJson?: { packageJson: PackageJson; uri: Uri };\n      rootUri: Uri;\n    };\n\ntype ReadParentPackageJsonResultInternal =\n  | {\n      found: true;\n      packageJson: PackageJson;\n      uri: Uri;\n      visitedDirs: Uri[];\n    }\n  | {\n      found: false;\n      packageJson: null;\n      uri: null;\n    };\n\ntype StrategyResult<T> =\n  | Promise<T & { visited: ResolverContext.Visit[] }>\n  | (T & { visited: ResolverContext.Visit[] });\n\nclass Visits {\n  private readonly parent?: Visits;\n  private readonly visits = [] as ResolverContext.Visit[];\n\n  constructor(readonly uri: { toString(): string }, parent?: Visits) {\n    this.parent = parent;\n  }\n\n  child(uri: { toString(): string }): Visits {\n    return new Visits(uri, this);\n  }\n\n  push(visit: ResolverContext.Visit) {\n    if (!this.visits.find((cmp) => cmp.type == visit.type && Uri.equals(cmp.uri, visit.uri))) {\n      this.visits.push(visit);\n      if (this.parent) {\n        this.parent.push(visit);\n      }\n    }\n  }\n\n  toArray(): ResolverContext.Visit[] {\n    return this.parent ? this.parent.toArray() : this.visits.slice();\n  }\n}\n\nexport class ResolverContext {\n  static create(\n    resolver: Resolver,\n    strategy: ResolverStrategy,\n    settings: Resolver.Settings,\n    token: CancellationToken,\n    options: { debug?: boolean } = {}\n  ) {\n    return new ResolverContext({\n      cache: new Map(),\n      cacheInvalidations: new MapSet(),\n      debug: !!options.debug,\n      decoder: new Decoder(),\n      path: [],\n      resolver,\n      settings,\n      strategy,\n      token,\n      visits: new Visits(Uri.parse('velcro:/root')),\n    });\n  }\n\n  private readonly cache: ResolverContext.Options['cache'];\n  private readonly cacheInvalidations: ResolverContext.Options['cacheInvalidations'];\n  private readonly debugMode: boolean;\n  readonly decoder: ResolverContext.Options['decoder'];\n  private readonly mapResultWithVisits = <T>(result: T) =>\n    Object.assign(result, { visited: this.visits.toArray() });\n  readonly path: ReadonlyArray<string>;\n  private readonly resolver: ResolverContext.Options['resolver'];\n  readonly settings: Readonly<ResolverContext.Options['settings']>;\n  private readonly strategy: ResolverContext.Options['strategy'];\n  private readonly tokenSource: CancellationTokenSource;\n  private readonly visits: Visits;\n\n  protected constructor(options: ResolverContext.Options) {\n    this.cache = options.cache;\n    this.cacheInvalidations = options.cacheInvalidations;\n    this.debugMode = options.debug;\n    this.decoder = options.decoder;\n    this.path = options.path;\n    this.resolver = options.resolver;\n    this.settings = options.settings;\n    this.strategy = options.strategy;\n    this.tokenSource = new CancellationTokenSource(options.token);\n    this.visits = options.visits;\n  }\n\n  get token() {\n    return this.tokenSource.token;\n  }\n\n  get visited() {\n    return this.visits.toArray();\n  }\n\n  dispose() {\n    this.tokenSource.dispose(true);\n  }\n\n  forOperation(\n    operationName: string,\n    uri: { toString(): string },\n    options: { resetPath?: boolean; resetVisits?: boolean } = {}\n  ) {\n    const encodedOperation = encodePathNode(operationName, uri);\n\n    if (this.path.includes(encodedOperation)) {\n      const formattedPath = this.path\n        .map((segment) => {\n          const { operationName, uri } = decodePathNode(segment);\n\n          return `${operationName}(${uri.toString()})`;\n        })\n        .join(' -> ');\n\n      throw this._wrapError(\n        new Error(\n          `Detected a recursive call to the operation '${operationName}' for '${uri.toString()}' at path '${formattedPath}'`\n        )\n      );\n    }\n\n    return new ResolverContext({\n      cache: this.cache,\n      cacheInvalidations: this.cacheInvalidations,\n      debug: this.debugMode,\n      decoder: this.decoder,\n      path: options.resetPath ? [] : this.path.concat(encodedOperation),\n      resolver: this.resolver,\n      settings: this.settings,\n      strategy: this.strategy,\n      token: this.tokenSource.token,\n      visits: options.resetVisits ? new Visits(uri) : this.visits.child(uri),\n    });\n  }\n\n  getCanonicalUrl(uri: Uri): StrategyResult<ResolverStrategy.CanonicalizeResult> {\n    const method = this.strategy.getCanonicalUrl;\n    const receiver = this.strategy;\n    const operationName = 'Strategy.getCanonicalUrl';\n    const href = uri.toString();\n\n    return this.runInChildContext(operationName, uri, (ctx) =>\n      ctx.runWithCache(operationName, href, method, receiver, ctx, uri)\n    );\n  }\n\n  getResolveRoot(uri: Uri): StrategyResult<ResolverStrategy.ResolveRootResult> {\n    const method = this.strategy.getResolveRoot;\n    const receiver = this.strategy;\n    const operationName = 'Strategy.getResolveRoot';\n    const href = uri.toString();\n\n    return this.runInChildContext(operationName, uri, (ctx) =>\n      ctx.runWithCache(operationName, href, method, receiver, ctx, uri)\n    );\n  }\n\n  getSettings(uri: Uri): StrategyResult<ResolverStrategy.SettingsResult> {\n    const method = this.strategy.getSettings;\n    const receiver = this.strategy;\n    const operationName = 'Strategy.getSettings';\n    const href = uri.toString();\n\n    return this.runInChildContext(operationName, uri, (ctx) =>\n      ctx.runWithCache(operationName, href, method, receiver, ctx, uri)\n    );\n  }\n\n  getUrlForBareModule(\n    name: string,\n    spec: string,\n    path: string\n  ): StrategyResult<ResolverStrategy.BareModuleResult> {\n    const method = this.strategy.getUrlForBareModule;\n\n    if (!method) {\n      return Promise.reject(\n        new Error(\n          `Unable to resolve bare module spec '${name}@${spec}${path}' because no strategy was found that supports resolving bare modules`\n        )\n      );\n    }\n\n    const receiver = this.strategy;\n    const operationName = 'Strategy.getUrlForBareModule';\n    const href = `${name}@${spec}${path}`;\n\n    return this.runInChildContext(operationName, href, (ctx) =>\n      ctx.runWithCache(operationName, href, method, receiver, ctx, name, spec, path)\n    );\n  }\n\n  invalidate(uri: Uri) {\n    const href = uri.toString();\n    const invalidations = this.cacheInvalidations.get(href);\n    let invalidated = false;\n\n    if (invalidations) {\n      for (const { cacheKey, operationCache } of invalidations) {\n        invalidated = operationCache.delete(cacheKey) || invalidated;\n      }\n    }\n\n    this.cacheInvalidations.deleteAll(href);\n\n    return invalidated;\n  }\n\n  listEntries(uri: Uri): StrategyResult<ResolverStrategy.ListEntriesResult> {\n    const method = this.strategy.listEntries;\n    const receiver = this.strategy;\n    const operationName = 'Strategy.listEntries';\n    const href = uri.toString();\n\n    return this.runInChildContext(operationName, uri, (ctx) =>\n      ctx.runWithCache(operationName, href, method, receiver, ctx, uri)\n    );\n  }\n\n  readFileContent(uri: Uri): StrategyResult<ResolverStrategy.ReadFileContentResult> {\n    const method = this.strategy.readFileContent;\n    const receiver = this.strategy;\n    const operationName = 'Strategy.readFileContent';\n    const href = uri.toString();\n\n    this.recordVisit(uri, ResolverContext.VisitKind.File);\n\n    return this.runInChildContext(operationName, uri, (ctx) =>\n      ctx.runWithCache(operationName, href, method, receiver, ctx, uri)\n    );\n  }\n\n  readParentPackageJson(uri: Uri): StrategyResult<ReadParentPackageJsonResultInternal> {\n    return this.runWithCache(\n      'readParentPackageJson',\n      uri.toString(),\n      readParentPackageJson,\n      null,\n      this,\n      uri\n    );\n  }\n\n  recordVisit(uri: Uri, type: ResolverContext.VisitKind = ResolverContext.VisitKind.File) {\n    this.visits.push({ type, uri });\n  }\n\n  resolve(spec: string, fromUri: Uri): StrategyResult<ResolveResult> {\n    const method = resolveDependency;\n    const receiver = null;\n    const operationName = 'resolve';\n    const href = `${fromUri}|${spec}`;\n\n    return this.runInChildContext(operationName, href, (ctx) =>\n      ctx.runWithCache(operationName, href, method, receiver, ctx, fromUri, spec)\n    );\n  }\n\n  resolveUri(uri: Uri): StrategyResult<ResolveResult> {\n    const method = resolve;\n    const receiver = null;\n    const operationName = 'resolveUri';\n    const href = uri.toString();\n\n    return this.runInChildContext(operationName, uri, (ctx) =>\n      ctx.runWithCache(operationName, href, method, receiver, ctx, uri)\n    );\n  }\n\n  runInChildContext<T>(\n    operationName: string,\n    uri: { toString(): string },\n    contextFn: (ctx: ResolverContext) => T\n  ): T {\n    return this.runInContext(\n      operationName,\n      uri,\n      { resetPath: false, resetVisits: false },\n      contextFn\n    );\n  }\n\n  runInIsolatedContext<T>(\n    operationName: string,\n    uri: { toString(): string },\n    contextFn: (ctx: ResolverContext) => T\n  ): T {\n    return this.runInContext(operationName, uri, { resetPath: true, resetVisits: true }, contextFn);\n  }\n\n  private runInContext<T>(\n    operationName: string,\n    uri: { toString(): string },\n    options: { resetPath: boolean; resetVisits: boolean },\n    contextFn: (ctx: ResolverContext) => T\n  ) {\n    const ctx = this.forOperation(operationName, uri, options);\n\n    ctx.debug('%s(%s)', operationName, uri.toString());\n\n    return contextFn(ctx);\n  }\n\n  private createStoreResultFn<TMethod extends (...args: any[]) => any>(\n    operationCache: Map<string, ReturnTypeWithVisits<TMethod>>,\n    cacheKey: string\n  ) {\n    return (result: ReturnTypeWithVisits<TMethod>) => {\n      const mappedResult = this.mapResultWithVisits(result);\n      const visited = mappedResult.visited as ResolverContext.Visit[];\n\n      if (mappedResult[CACHE]) {\n        const cacheEntries = mappedResult[CACHE] as [string, ReturnTypeWithVisits<TMethod>][];\n        delete mappedResult[CACHE];\n\n        for (const [cacheKey, value] of cacheEntries) {\n          operationCache.set(cacheKey, value);\n\n          for (const visit of visited) {\n            this.cacheInvalidations.add(visit.uri.toString(), { cacheKey, operationCache });\n          }\n        }\n      }\n\n      // Override the pending value with the resolved value\n      operationCache.set(cacheKey, mappedResult);\n\n      for (const visit of visited) {\n        this.cacheInvalidations.add(visit.uri.toString(), { cacheKey, operationCache });\n      }\n\n      return mappedResult;\n    };\n  }\n\n  private runWithCache<TMethod extends (...args: any[]) => any>(\n    cacheSegment: string,\n    cacheKey: string,\n    fn: TMethod,\n    target: unknown,\n    ...args: Parameters<TMethod>\n  ): ReturnTypeWithVisits<TMethod> {\n    let operationCache = this.cache.get(cacheSegment) as\n      | Map<string, ReturnTypeWithVisits<TMethod>>\n      | undefined;\n\n    if (!operationCache) {\n      operationCache = new Map();\n      this.cache.set(cacheSegment, operationCache);\n    }\n\n    const cached = operationCache.get(cacheKey);\n\n    if (cached) {\n      this.debug('%s(%s) [HIT]', cacheSegment, cacheKey);\n\n      // We either have a cached result or a cached promise for a result. Either way, the value\n      // is suitable as a return.\n      return cached;\n    }\n\n    const cacheResult = this.createStoreResultFn(operationCache, cacheKey);\n\n    this.debug('%s(%s) [MISS]', cacheSegment, cacheKey);\n\n    // Nothing is cached\n    const ret = fn.apply(target, args);\n\n    if (isThenable(ret)) {\n      const promiseRet = ret as Thenable<ReturnTypeWithVisits<TMethod>>;\n\n      // Produce a promise that will only be settled once the cache has been updated accordingly.\n      const wrappedRet = promiseRet.then(cacheResult, (err) => {\n        // Delete the entry from the cache in case it was a transient failure\n        operationCache!.delete(cacheKey);\n\n        return Promise.reject(err);\n      });\n\n      // Set the pending value in the cache for now\n      operationCache.set(cacheKey, wrappedRet as Awaited<Thenable<ReturnTypeWithVisits<TMethod>>>);\n\n      return wrappedRet as Awaited<Thenable<ReturnTypeWithVisits<TMethod>>>;\n    }\n\n    return cacheResult(ret);\n  }\n\n  private _wrapError<T extends Error>(\n    err: T\n  ): T & { path: { operationName: string; uri: Uri | string }[] } {\n    return Object.assign(err, {\n      path: this.path.map(decodePathNode),\n    });\n  }\n\n  debug(...args: Parameters<Console['warn']>) {\n    if (this.debugMode) {\n      if (typeof args[0] === 'string') {\n        args[0] = ' '.repeat(this.path.length) + args[0];\n      }\n      console.warn(...args);\n    }\n  }\n}\n\nfunction encodePathNode(operationName: string, uri: { toString(): string }) {\n  return `${operationName}:${uri.toString()}`;\n}\n\nfunction decodePathNode(node: string) {\n  const parts = node.split(':', 2);\n\n  if (parts.length !== 2) {\n    console.log('WTF', { node, parts });\n    throw new Error(`Invariant violation: Unexpected path node: '${node}'`);\n  }\n\n  return {\n    operationName: parts[0],\n    uri: parts[1].includes(':') ? Uri.parse(parts[1]) : parts[1],\n  };\n}\n\nasync function resolve(ctx: ResolverContext, uri: Uri): Promise<ResolveResult> {\n  const bothResolved = all(\n    [ctx.getCanonicalUrl(uri), ctx.getResolveRoot(uri), ctx.getSettings(uri)],\n    ctx.token\n  );\n\n  const [canonicalizationResult, resolveRootResult, settingsResult] = isThenable(bothResolved)\n    ? await checkCancellation(bothResolved, ctx.token)\n    : bothResolved;\n\n  const rootUri = resolveRootResult.uri;\n  const rootUriWithoutTrailingSlash = Uri.ensureTrailingSlash(rootUri, '');\n\n  if (!Uri.isPrefixOf(rootUriWithoutTrailingSlash, canonicalizationResult.uri)) {\n    throw new Error(\n      `Unable to resolve a module whose path ${canonicalizationResult.uri.toString(\n        true\n      )} is above the host's root ${rootUri.toString()}`\n    );\n  }\n\n  const resolveReturn =\n    Uri.equals(rootUriWithoutTrailingSlash, canonicalizationResult.uri) ||\n    Uri.equals(rootUri, canonicalizationResult.uri)\n      ? ctx.runInChildContext('resolveAsDirectory', canonicalizationResult.uri, (ctx) =>\n          resolveAsDirectory(\n            ctx,\n            Uri.ensureTrailingSlash(canonicalizationResult.uri),\n            resolveRootResult.uri,\n            settingsResult.settings\n          )\n        )\n      : ctx.runInChildContext('resolveAsFile', canonicalizationResult.uri, (ctx) =>\n          resolveAsFile(\n            ctx,\n            canonicalizationResult.uri,\n            resolveRootResult.uri,\n            settingsResult.settings,\n            null\n          )\n        );\n  const readParentPackageJsonReturn = ctx.readParentPackageJson(uri);\n  const resolveAndPackageJson = all([resolveReturn, readParentPackageJsonReturn], ctx.token);\n  const [resolveResult, readParentPackageJsonResult] = isThenable(resolveAndPackageJson)\n    ? await resolveAndPackageJson\n    : resolveAndPackageJson;\n\n  return {\n    ...resolveResult,\n    parentPackageJson: readParentPackageJsonResult.found\n      ? {\n          packageJson: readParentPackageJsonResult.packageJson,\n          uri: readParentPackageJsonResult.uri,\n        }\n      : undefined,\n  };\n}\n\nasync function resolveDependency(ctx: ResolverContext, fromUri: Uri, spec: string) {\n  const parsedSpec = parseBareModuleSpec(spec);\n\n  if (parsedSpec) {\n    return ctx.runInChildContext('resolveBareModule', fromUri, (ctx) =>\n      resolveBareModule(ctx, fromUri, parsedSpec)\n    );\n  }\n\n  const relativeUri = Uri.joinPath(\n    Uri.from({\n      ...fromUri,\n      path: dirname(fromUri.path),\n    }),\n    spec\n  );\n\n  return ctx.runInChildContext('resolveUri', relativeUri, (ctx) => resolve(ctx, relativeUri));\n}\n\nasync function resolveBareModule(ctx: ResolverContext, uri: Uri, parsedSpec: BareModuleSpec) {\n  let locatorName = parsedSpec.name;\n  let locatorSpec = parsedSpec.spec;\n  let locatorPath = parsedSpec.path;\n\n  if (!locatorSpec) {\n    const resolveRootReturn = ctx.getResolveRoot(uri);\n    const resolveRootResult = isThenable(resolveRootReturn)\n      ? await checkCancellation(resolveRootReturn, ctx.token)\n      : resolveRootReturn;\n\n    let nextUri = uri;\n    let maxIterations = 10;\n\n    while (Uri.isPrefixOf(resolveRootResult.uri, nextUri)) {\n      if (--maxIterations <= 0) {\n        throw new Error('Max iterations reached');\n      }\n\n      const parentPackageJsonReturn = ctx.readParentPackageJson(uri);\n      const parentPackageJsonResult = isThenable(parentPackageJsonReturn)\n        ? await checkCancellation(parentPackageJsonReturn, ctx.token)\n        : parentPackageJsonReturn;\n\n      if (!parentPackageJsonResult.found) {\n        throw new DependencyNotFoundError(parsedSpec.nameSpec, uri);\n      }\n      ctx.recordVisit(parentPackageJsonResult.uri, ResolverContext.VisitKind.File);\n\n      if (parentPackageJsonResult.packageJson.name === parsedSpec.name) {\n        // We found a parent directory that *IS* the module we're looking for\n        const directoryUri = Uri.ensureTrailingSlash(\n          Uri.joinPath(parentPackageJsonResult.uri, '../')\n        );\n        return ctx.runInChildContext('resolveAsDirectory', directoryUri, (ctx) =>\n          resolveAsDirectory(ctx, directoryUri, resolveRootResult.uri, ctx.settings)\n        );\n      }\n\n      const dependencies = {\n        ...(parentPackageJsonResult.packageJson.devDependencies || {}),\n        ...(parentPackageJsonResult.packageJson.peerDependencies || {}),\n        ...(parentPackageJsonResult.packageJson.dependencies || {}),\n      };\n\n      locatorSpec = dependencies[parsedSpec.name];\n\n      if (locatorSpec) {\n        break;\n      }\n\n      nextUri = Uri.joinPath(parentPackageJsonResult.uri, '..');\n\n      if (Uri.equals(nextUri, resolveRootResult.uri)) {\n        break;\n      }\n    }\n  }\n\n  if (!locatorSpec) {\n    const builtIn = NODE_CORE_SHIMS[parsedSpec.name];\n\n    if (builtIn) {\n      locatorName = builtIn.name;\n      locatorSpec = builtIn.spec;\n      locatorPath = builtIn.path;\n    }\n  }\n\n  if (!locatorSpec) {\n    throw new DependencyNotFoundError(parsedSpec.nameSpec, uri);\n  }\n\n  const bareModuleUriReturn = ctx.getUrlForBareModule(locatorName, locatorSpec, locatorPath);\n  const bareModuleUriResult = isThenable(bareModuleUriReturn)\n    ? await checkCancellation(bareModuleUriReturn, ctx.token)\n    : bareModuleUriReturn;\n\n  if (!bareModuleUriResult.found) {\n    throw new DependencyNotFoundError(parsedSpec.nameSpec, uri);\n  }\n\n  if (!bareModuleUriResult.uri) {\n    // TODO: Inject empty module\n    throw new EntryExcludedError(parsedSpec.nameSpec);\n  }\n\n  const resolveReturn = ctx.resolveUri(bareModuleUriResult.uri);\n  const resolveResult = isThenable(resolveReturn)\n    ? await checkCancellation(resolveReturn, ctx.token)\n    : resolveReturn;\n\n  return resolveResult;\n}\nexport namespace ResolverContext {\n  export interface Options {\n    cache: Map<string, Map<string, unknown>>;\n    cacheInvalidations: MapSet<string, InvalidationRecord>;\n    debug: boolean;\n    decoder: Decoder;\n    path: string[];\n    resolver: Resolver;\n    settings: Resolver.Settings;\n    strategy: ResolverStrategy;\n    token: CancellationToken;\n    visits: Visits;\n  }\n\n  export enum VisitKind {\n    Directory = 'Directory',\n    File = 'File',\n  }\n\n  export type Visit =\n    | {\n        type: VisitKind.Directory;\n        uri: Uri;\n      }\n    | {\n        type: VisitKind.File;\n        uri: Uri;\n      };\n}\n\nasync function resolveAsDirectory(\n  ctx: ResolverContext,\n  uri: Uri,\n  rootUri: Uri,\n  settings: Resolver.Settings\n): Promise<ResolveResult> {\n  ctx.recordVisit(uri, ResolverContext.VisitKind.Directory);\n\n  const listEntriesReturn = ctx.listEntries(uri);\n  const listEntriesResult = isThenable(listEntriesReturn)\n    ? await checkCancellation(listEntriesReturn, ctx.token)\n    : listEntriesReturn;\n\n  let mainPathname = 'index';\n\n  // Step 1: Look for a package.json with an main field\n  const packageJsonUri = Uri.joinPath(uri, './package.json');\n\n  ctx.recordVisit(packageJsonUri, ResolverContext.VisitKind.File);\n\n  const packageJsonEntry = listEntriesResult.entries.find(\n    (entry) =>\n      entry.type === ResolverStrategy.EntryKind.File && Uri.equals(packageJsonUri, entry.uri)\n  );\n\n  let packageJson: PartialPackageJson | null = null;\n\n  if (packageJsonEntry) {\n    const packageJsonContentReturn = ctx.readFileContent(packageJsonUri);\n    const packageJsonContentResult = isThenable(packageJsonContentReturn)\n      ? await checkCancellation(packageJsonContentReturn, ctx.token)\n      : packageJsonContentReturn;\n\n    packageJson = parseBufferAsPartialPackageJson(\n      ctx.decoder,\n      packageJsonContentResult.content,\n      uri.toString()\n    );\n\n    for (const packageMain of settings.packageMain) {\n      const pathname = packageJson[packageMain];\n      if (typeof pathname === 'string') {\n        mainPathname = pathname;\n        break;\n      }\n    }\n  }\n\n  const fileUri = Uri.joinPath(uri, mainPathname);\n\n  return ctx.runInChildContext('resolveAsFile', uri, (ctx) =>\n    resolveAsFile(ctx, fileUri, rootUri, settings, packageJson)\n  );\n}\n\nasync function resolveAsFile(\n  ctx: ResolverContext,\n  uri: Uri,\n  rootUri: Uri,\n  settings: Resolver.Settings,\n  packageJson: PartialPackageJson | null,\n  ignoreBrowserOverrides = false\n): Promise<ResolveResult> {\n  if (uri.path === '' || uri.path === '/') {\n    throw new TypeError(`Unable to resolve the root as a file: ${uri.toString()}`);\n  }\n\n  ctx.recordVisit(uri, ResolverContext.VisitKind.File);\n\n  const browserOverrides = new Map<string, Uri | false>();\n\n  if (packageJson === null) {\n    // The parent package.json is only interesting if we are going to look at the `browser`\n    // field and then consider browser mapping overrides in there.\n    const parentPackageJsonResult =\n      settings.packageMain.includes('browser') && !ignoreBrowserOverrides\n        ? await checkCancellation(\n            ctx.runInChildContext('readParentPackageJsonInternal', uri, (ctx) =>\n              readParentPackageJsonInternal(ctx, uri, rootUri, { uriIsCanonicalized: true })\n            ),\n            ctx.token\n          )\n        : undefined;\n    if (parentPackageJsonResult && parentPackageJsonResult.found) {\n      ctx.recordVisit(parentPackageJsonResult.uri, ResolverContext.VisitKind.File);\n\n      packageJson = parentPackageJsonResult.packageJson;\n\n      if (\n        parentPackageJsonResult.packageJson.browser &&\n        typeof parentPackageJsonResult.packageJson.browser === 'object'\n      ) {\n        const browserMap = parentPackageJsonResult.packageJson.browser;\n        const packageJsonDir = Uri.joinPath(parentPackageJsonResult.uri, '..');\n\n        for (const entry in browserMap) {\n          const impliedUri = Uri.joinPath(packageJsonDir, entry);\n          const targetSpec = browserMap[entry];\n          const target = targetSpec === false ? false : Uri.joinPath(packageJsonDir, targetSpec);\n\n          if (Uri.equals(impliedUri, uri)) {\n            if (target === false) {\n              return {\n                found: false,\n                uri: null,\n              };\n            }\n\n            // console.warn('REMAPPED %s to %s', url, target);\n\n            // We found an exact match so let's make sure we resolve the re-mapped file but\n            // also that we don't go through the browser overrides rodeo again.\n            return ctx.runInChildContext('resolveAsFile', target, (ctx) =>\n              resolveAsFile(ctx, target, rootUri, settings, packageJson, true)\n            );\n          }\n\n          browserOverrides.set(impliedUri.toString(), target);\n        }\n      }\n    }\n  }\n\n  const containingDirUri = Uri.ensureTrailingSlash(Uri.joinPath(uri, '..'));\n\n  const filename = basename(uri.path);\n  const entriesReturn = ctx.listEntries(containingDirUri);\n  const entriesResult = isThenable(entriesReturn)\n    ? await checkCancellation(entriesReturn, ctx.token)\n    : entriesReturn;\n  const entryDirectoryMap = new Map<string, ResolverStrategy.Entry>();\n  const entryFileMap = new Map<string, ResolverStrategy.Entry<ResolverStrategy.EntryKind.File>>();\n\n  for (const entry of entriesResult.entries) {\n    if (Uri.equals(entry.uri, uri) && entry.type == ResolverStrategy.EntryKind.File) {\n      // Found an exact match\n      return {\n        found: true,\n        rootUri,\n        uri,\n      };\n    }\n\n    if (entry.type === ResolverStrategy.EntryKind.Directory) {\n      const childFilename = Uri.getFirstPathSegmentAfterPrefix(entry.uri, containingDirUri);\n\n      entryDirectoryMap.set(childFilename, entry);\n    } else if (entry.type === ResolverStrategy.EntryKind.File) {\n      const childFilename = basename(entry.uri.path);\n\n      entryFileMap.set(\n        childFilename,\n        entry as ResolverStrategy.Entry<ResolverStrategy.EntryKind.File>\n      );\n    }\n  }\n\n  // Look for browser overrides\n  for (const ext of settings.extensions) {\n    const hrefWithExtensionUri = uri.with({ path: `${uri.path}${ext}` });\n    const hrefWithExtension = hrefWithExtensionUri.toString();\n    const mapping = browserOverrides.get(hrefWithExtension);\n\n    ctx.recordVisit(hrefWithExtensionUri, ResolverContext.VisitKind.File);\n\n    if (mapping === false) {\n      // console.warn('REMAPPED %s to undefined', url);\n      return {\n        found: true,\n        rootUri,\n        uri: null,\n      };\n    } else if (mapping) {\n      // console.warn('REMAPPED %s to %s', url, mapping);\n\n      return ctx.runInChildContext('resolveAsFile', mapping, (ctx) =>\n        resolveAsFile(ctx, mapping, rootUri, settings, packageJson, true)\n      );\n    }\n\n    const match = entryFileMap.get(`${filename}${ext}`);\n    if (match) {\n      if (match.type !== ResolverStrategy.EntryKind.File) {\n        continue;\n      }\n\n      return {\n        found: true,\n        rootUri,\n        uri: match.uri,\n      };\n    }\n  }\n\n  // First, attempt to find a matching file or directory\n  const match = entryDirectoryMap.get(filename);\n  if (match) {\n    if (match.type !== ResolverStrategy.EntryKind.Directory) {\n      throw new Error(`Invariant violation ${match.type} is unexpected`);\n    }\n\n    return ctx.runInChildContext('resolveAsDirectory', match.uri, (ctx) =>\n      resolveAsDirectory(ctx, Uri.ensureTrailingSlash(match.uri), rootUri, settings)\n    );\n  }\n\n  throw new EntryNotFoundError(uri);\n}\n\nasync function readParentPackageJson(ctx: ResolverContext, uri: Uri) {\n  const canonicalizationReturn = ctx.getCanonicalUrl(uri);\n  const resolveRootReturn = ctx.getResolveRoot(uri);\n  const bothResolved = all([canonicalizationReturn, resolveRootReturn], ctx.token);\n  const [canonicalizationResult, resolveRootResult] = isThenable(bothResolved)\n    ? await checkCancellation(bothResolved, ctx.token)\n    : bothResolved;\n  const readReturn = ctx.runInChildContext(\n    'readParentPackageJsonInternal',\n    canonicalizationResult.uri,\n    (ctx) =>\n      readParentPackageJsonInternal(ctx, canonicalizationResult.uri, resolveRootResult.uri, {\n        uriIsCanonicalized: true,\n      })\n  );\n  const readResult = isThenable(readReturn) ? await readReturn : readReturn;\n\n  if (readResult.found && readResult.visitedDirs) {\n    const visitedDirs = readResult.visitedDirs;\n    delete readResult.visitedDirs;\n\n    (readResult as any)[CACHE] = visitedDirs.map((uri) => [uri.toString(), { ...readResult, uri }]);\n  }\n\n  return readResult as ReadParentPackageJsonResultInternal;\n}\n\nasync function readParentPackageJsonInternal(\n  ctx: ResolverContext,\n  uri: Uri,\n  rootUri: Uri,\n  options: { uriIsCanonicalized: boolean }\n): Promise<ReadParentPackageJsonResultInternal> {\n  if (!options.uriIsCanonicalized) {\n    const canonicalizationReturn = ctx.getCanonicalUrl(uri);\n    const canonicalizationResult = isThenable(canonicalizationReturn)\n      ? await checkCancellation(canonicalizationReturn, ctx.token)\n      : canonicalizationReturn;\n\n    uri = canonicalizationResult.uri;\n  }\n\n  const hostRootHref = Uri.ensureTrailingSlash(rootUri);\n  const containingDirUrl = Uri.ensureTrailingSlash(Uri.joinPath(uri, '..'));\n  const visitedDirs = [] as Uri[];\n\n  const readPackageJsonOrRecurse = async (\n    ctx: ResolverContext,\n    dir: Uri\n  ): Promise<ReadParentPackageJsonResultInternal> => {\n    if (!Uri.isPrefixOf(hostRootHref, dir)) {\n      // Terminal condition for recursion\n      return {\n        found: false,\n        packageJson: null,\n        uri: null,\n      };\n    }\n\n    ctx.recordVisit(dir, ResolverContext.VisitKind.Directory);\n\n    const entriesReturn = ctx.listEntries(dir);\n    const entriesResult = isThenable(entriesReturn)\n      ? await checkCancellation(entriesReturn, ctx.token)\n      : entriesReturn;\n    const packageJsonUri = Uri.joinPath(dir, 'package.json');\n    const packageJsonEntry = entriesResult.entries.find(\n      (entry) =>\n        entry.type === ResolverStrategy.EntryKind.File && Uri.equals(entry.uri, packageJsonUri)\n    );\n\n    ctx.recordVisit(packageJsonUri, ResolverContext.VisitKind.File);\n\n    if (packageJsonEntry) {\n      // Found! Let's try to parse\n      try {\n        const parentPackageJsonContentReturn = ctx.readFileContent(packageJsonUri);\n        const parentPackageJsonContentResult = isThenable(parentPackageJsonContentReturn)\n          ? await checkCancellation(parentPackageJsonContentReturn, ctx.token)\n          : parentPackageJsonContentReturn;\n\n        const packageJson = parseBufferAsPackageJson(\n          ctx.decoder,\n          parentPackageJsonContentResult.content,\n          packageJsonUri.toString()\n        );\n\n        return { found: true, packageJson, uri: packageJsonUri, visitedDirs };\n      } catch (err) {\n        if (err instanceof CanceledError || (err && err.name === 'CanceledError')) {\n          throw err;\n        }\n\n        // TODO: Maybe issue some warning?\n      }\n    }\n\n    // Not found here, let's try one up\n    const parentDir = Uri.ensureTrailingSlash(Uri.joinPath(dir, '..'));\n\n    // Skip infinite recursion\n    if (Uri.equals(dir, parentDir) || Uri.isPrefixOf(dir, parentDir)) {\n      return {\n        found: false,\n        packageJson: null,\n        uri: null,\n      };\n    }\n\n    visitedDirs.push(dir);\n\n    return ctx.runInChildContext('readPackageJsonOrRecurse', parentDir, (ctx) =>\n      readPackageJsonOrRecurse(ctx, parentDir)\n    );\n  };\n\n  if (Uri.equals(uri, containingDirUrl) || Uri.isPrefixOf(uri, containingDirUrl)) {\n    return {\n      found: false,\n      packageJson: null,\n      uri: null,\n    };\n  }\n  return ctx.runInChildContext('readPackageJsonOrRecurse', containingDirUrl, (ctx) =>\n    readPackageJsonOrRecurse(ctx, containingDirUrl)\n  );\n}\n","import { CancellationTokenSource, PackageMainField, Uri } from '@velcro/common';\nimport { ResolverContext } from './context';\nimport type { ResolverStrategy } from './strategy';\n\nexport class Resolver {\n  private disposed = false;\n  readonly rootCtx: ResolverContext;\n  private readonly settings: Resolver.Settings;\n  private readonly strategy: ResolverStrategy;\n  private readonly tokenSource = new CancellationTokenSource();\n\n  constructor(strategy: ResolverStrategy, settings: Resolver.Settings) {\n    this.settings = settings;\n    this.strategy = strategy;\n    this.rootCtx = ResolverContext.create(\n      this,\n      this.strategy,\n      this.settings,\n      this.tokenSource.token,\n      { debug: settings.debug }\n    );\n  }\n\n  decode(buf: BufferSource | string): string {\n    if (typeof buf === 'string') {\n      return buf;\n    }\n\n    return this.rootCtx.decoder.decode(buf);\n  }\n\n  dispose() {\n    this.disposed = true;\n    return this.rootCtx.dispose();\n  }\n\n  getCanonicalUrl(uri: string | Uri) {\n    if (this.disposed) {\n      throw new Error('Resolver has been disposed');\n    }\n\n    return this.rootCtx.runInIsolatedContext('Resolver.getCanonicalUrl', uri, (ctx) =>\n      ctx.getCanonicalUrl(typeof uri === 'string' ? Uri.parse(uri) : uri)\n    );\n  }\n\n  getResolveRoot(uri: string | Uri) {\n    if (this.disposed) {\n      throw new Error('Resolver has been disposed');\n    }\n\n    return this.rootCtx.runInIsolatedContext('Resolver.getResolveRoot', uri, (ctx) =>\n      ctx.getResolveRoot(typeof uri === 'string' ? Uri.parse(uri) : uri)\n    );\n  }\n\n  getSettings(uri: string | Uri) {\n    if (this.disposed) {\n      throw new Error('Resolver has been disposed');\n    }\n\n    return this.rootCtx.runInIsolatedContext('Resolver.getSettings', uri, (ctx) =>\n      ctx.getSettings(typeof uri === 'string' ? Uri.parse(uri) : uri)\n    );\n  }\n\n  getUrlForBareModule(name: string, spec: string, path: string) {\n    if (this.disposed) {\n      throw new Error('Resolver has been disposed');\n    }\n\n    return this.rootCtx.runInIsolatedContext(\n      'Resolver.getUrlForBareModule',\n      `${name}|${spec}|${path}`,\n      (ctx) => ctx.getUrlForBareModule(name, spec, path)\n    );\n  }\n\n  invalidate(uri: string | Uri) {\n    if (this.disposed) {\n      throw new Error('Resolver has been disposed');\n    }\n\n    return this.rootCtx.runInIsolatedContext('Resolver.invalidate', uri, (ctx) =>\n      ctx.invalidate(typeof uri === 'string' ? Uri.parse(uri) : uri)\n    );\n  }\n\n  listEntries(uri: Uri) {\n    if (this.disposed) {\n      throw new Error('Resolver has been disposed');\n    }\n\n    return this.rootCtx.runInIsolatedContext('Resolver.listEntries', uri, (ctx) =>\n      ctx.listEntries(typeof uri === 'string' ? Uri.parse(uri) : uri)\n    );\n  }\n\n  readFileContent(uri: Uri) {\n    if (this.disposed) {\n      throw new Error('Resolver has been disposed');\n    }\n\n    return this.rootCtx.runInIsolatedContext('Resolver.readFileContent', uri, (ctx) =>\n      ctx.readFileContent(typeof uri === 'string' ? Uri.parse(uri) : uri)\n    );\n  }\n\n  readParentPackageJson(uri: Uri) {\n    if (this.disposed) {\n      throw new Error('Resolver has been disposed');\n    }\n\n    return this.rootCtx.runInIsolatedContext('Resolver.readParentPackageJson', uri, (ctx) =>\n      ctx.readParentPackageJson(typeof uri === 'string' ? Uri.parse(uri) : uri)\n    );\n  }\n\n  resolve(spec: Uri): ReturnType<ResolverContext['resolve']>;\n  resolve(spec: string, fromUri: Uri): ReturnType<ResolverContext['resolve']>;\n  resolve(spec: string | Uri, fromUri?: Uri): ReturnType<ResolverContext['resolve']> {\n    if (this.disposed) {\n      throw new Error('Resolver has been disposed');\n    }\n\n    if (Uri.isUri(spec)) {\n      return this.rootCtx.runInIsolatedContext('Resolver.resolveUri', spec, (ctx) =>\n        ctx.resolveUri(spec)\n      );\n    }\n\n    if (!fromUri) {\n      throw new Error(\n        'When calling Resolver.resolve with a string spec, a second \"fromUri\" argument is required'\n      );\n    }\n\n    return this.rootCtx.runInIsolatedContext(\n      'Resolver.resolve',\n      `${fromUri ? fromUri.toString() : ''}|${spec}`,\n      (ctx) => ctx.resolve(spec, fromUri)\n    );\n  }\n}\n\nexport namespace Resolver {\n  export interface Settings {\n    debug?: boolean;\n    extensions: string[];\n    packageMain: PackageMainField[];\n  }\n}\n"],"sourceRoot":""}