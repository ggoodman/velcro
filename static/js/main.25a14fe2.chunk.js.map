{"version":3,"sources":["../../../src/base64.ts","../../../src/error.ts","../../../src/async.ts","../../../src/decoder.ts","../../../src/mapSet.ts","../../../src/packageJson.ts","../../../src/path.ts","../../../src/uri.ts","../../../src/memoryStrategy.ts","velcro/monaco.ts","velcro/types.ts","velcro/velcroWorker.ts","../../../node_modules/sourcemap-codec/dist/sourcemap-codec.es.js","../../../src/graph/errors.ts","../../../src/build/sourceMap.ts","../../../src/build/sourceMapTree.ts","../../../src/graph/sourceModuleDependency.ts","../../../src/plugins/pluginManager.ts","../../../src/graph/commonjs/ast.ts","../../../src/graph/commonjs/traverse.ts","../../../src/graph/commonjs/parser.ts","../../../src/runtime/runtime.js","../../../src/build/chunkOutput.ts","../../../src/build/chunk.ts","../../../src/graph/graph.ts","../../../src/graph/shims.ts","../../../src/graph/sourceModule.ts","../../../src/graph/graphBuilder.ts","../../../src/cdnStrategy.ts","../../../src/compoundStrategy.ts","../../../src/execute.ts","lib/svelte.language.ts","lib/EditorManager.ts","playground/Editor.tsx","playground/Preview.tsx","lib/hooks.ts","playground/Sidebar.tsx","playground/Playground.tsx","templates/svelte.ts","useServiceWorker.tsx","App.tsx","serviceWorker.ts","index.tsx","../../../src/bareModules.ts","../../../src/shims.ts","../../../src/strategy.ts","../../../src/context.ts","../../../src/resolver.ts"],"names":["Base64","BaseError","name","constructor","Error","CanceledError","EntryExcludedError","uri","toString","EntryNotFoundError","DependencyNotFoundError","spec","parentUri","isCanceledError","err","all","values","token","shouldAwait","result","map","element","isThenable","checkCancellation","Promise","promise","a","isCancellationRequested","reject","object","then","done","next","pre","decode","global","data","from","atob","decodeURIComponent","escape","_data","encode","btoa","unescape","encodeURIComponent","Decoder","TextDecoder","this","decoder","Buffer","buf","str","charCodeAt","slice","MapSet","Map","key","value","get","Set","set","add","clear","ret","delete","size","has","entries","hasInvalidBrowserField","json","error","browser","hasInvalidRequiredStringField","field","hasInvalidOptionalStringField","undefined","hasInvalidDependenciesField","Object","keys","every","parseBufferAsPartialPackageJson","content","parseTextAsPartialPackageJson","message","parseBufferAsPackageJson","text","isValidPackageJson","parseTextAsPackageJson","JSON","parse","isValidPartialPackageJson","ErrorInvalidArgType","expected","actual","determiner","indexOf","replace","type","msg","code","validateString","isPosixPathSeparator","normalizeString","path","allowAboveRoot","separator","isPathSeparator","res","lastSegmentLength","lastSlash","dots","i","length","lastSlashIndex","lastIndexOf","posix","resolve","resolvedPath","resolvedAbsolute","process","cwd","normalize","isAbsolute","trailingSeparator","join","joined","arg","relative","to","fromEnd","fromLen","toLen","lastCommonSep","fromCode","out","toNamespacedPath","dirname","hasRoot","end","matchedSlash","basename","ext","start","extIdx","firstNonSlashEnd","extname","startDot","startPart","preDotState","format","sep","pathObject","dir","root","base","bind","delimiter","win32","_schemePattern","_singleSlashStart","_doubleSlashStart","_validateUri","_strict","scheme","authority","query","fragment","test","_schemeFix","_referenceResolution","_slash","_regexp","Uri","schemeOrData","change","_URI","skipEncoding","_asFormatted","uriToFsPath","trailingSlash","with","TRAILING_SLASH_RX","l","r","child","parent","childHref","parentHref","parentOffset","charAt","prefix","startsWith","thing","fsPath","match","exec","percentDecode","idx","substring","components","pathFragment","newPath","_formatted","external","_fsPath","_sep","_pathSepMarker","$mid","encodeTable","encodeURIComponentFast","uriComponent","allowSlash","nativeEncodePos","pos","substr","escaped","encodeURIComponentMinimal","keepDriveLetterCasing","toLowerCase","encoder","userinfo","String","fromCharCode","_rEncodedAsHex","decodeURIComponentGraceful","FileEncoding","encodeText","TextEncoder","buffer","MemoryStrategy","files","rootUri","pathname","ensureTrailingSlash","EntryKind","Directory","children","file","addFile","encoding","segments","Array","isArray","split","filter","Boolean","segment","UTF8","overwrite","filename","pop","entry","File","_ctx","urlPathname","basePathname","fsPathname","getEntryAtPath","joinPath","binSting","binArray","Uint8Array","prototype","forEach","call","_el","arr","trackMonaco","monaco","disposer","DisposableStore","worker","Worker","trackModel","model","onWillDispose","event","href","postMessage","disposerReference","dispose","onDidChangeContent","getValue","postMessageEmitter","Emitter","postMessageQueue","Event","debounce","last","events","fire","editor","getModels","onDidCreateModel","terminate","emitter","addEventListener","e","WorkerState","is","FileCreateEvent","z","FileRemoveEvent","FileUpdateEvent","EditorEvent","BuiltState","state","int","BuildingState","completed","pending","ErrorState","InitialState","module","exports","charToInteger","chars","mappings","decoded","line","j","shift","c","segmentify","push","integer","hasContinuationBit","shouldNegate","sourceFileIndex","sourceCodeLine","sourceCodeColumn","nameIndex","generatedCodeColumn","lineMappings","_i","line_1","segmentMappings","encodeInteger","num","clamped","input","sourceRoot","names","sources","sourcesContent","version","stringify","getSourceMappingUrlMatch","re","lastMatch","getSourceMappingUrl","updateSourceMappingUrl","url","index","decodeDataUriAsSourceMap","column","source","loadLink","link","getLink","tracedLine","traced","traceSegment","sourceIndex","tracedSegment","m","SourceModuleDependencyKind","plugins","load","ctx","id","readReturn","resolver","readFileContent","readResult","visited","resolveDependency","dependency","fromSourceModule","resolveReturn","resolveResult","found","resolveEntrypoint","transform","createMagicString","endsWith","magicString","prepend","sourceMap","generateDecodedMap","plugin","loadReturn","loadResult","fromModule","kind","pluginCtx","assign","sourceMapTree","sourceMapRef","sourceMapUri","baseSources","transformReturn","transformResult","locations","options","SourceModuleDependency","Entrypoint","exportName","GlobalObject","Require","RequireResolve","isArrowFunctionExpression","node","isFunctionDeclaration","isFunctionExpression","isIdentifier","isMemberExpression","isRestElement","isStringLiteral","isLiteral","traverse","ast","enter","leave","_shouldSkip","shouldSkip","skipped","childKeys","sort","b","skip","visitorCtx","unboundSymbols","locals","indentExclusionRanges","nodeEnv","replacedSymbols","requires","requireResolves","skipTransform","dependencies","Acorn.parse","allowReturnOutsideFunction","sourceType","parseAst","scopingAndRequiresVisitor","collectGlobalsVisitor","requiresBySpec","requireDependency","fromRequire","requireResolvesBySpec","fromRequireResolve","symbolName","shim","globalModules","fromGlobalObject","export","location","addSourcemapLocation","_parent","isVariableDeclaration","nextParent","isScope","isBlockScope","declarations","declarePattern","declareFunction","isFunction","isClassDeclaration","isTryStatement","handler","param","visitAndCaptureScoping","isIfStatement","isBinaryExpression","operator","left","right","memberExpressionMatches","rootObject","remove","consequent","alternate","visitAndSkipBranches","isCallExpression","callee","firstArg","arguments","isTemplateLiteral","expressions","quasis","console","warn","raw","property","visitRequires","nextCheck","contentOnly","storeName","isPropertyOfMemberExpression","isProperty","isKeyOfProperty","isMethodDefinition","isKeyOfMethodDefinition","isBindingIdentifier","foundBinding","declaresArguments","isThisExpression","declaresThis","params","isObjectPattern","properties","argument","isArrayPattern","elements","isAssignmentPattern","isProgram","isBlockStatement","pattern","memberParts","createRuntime","velcro","runtime","Module","importMap","require","createRequire","Runtime","imports","scopes","defs","modules","create","dependents","resolveSpecAgainstImportMap","moduleDefinition","factory","specParts","__filename","__dirname","_spec","inject","invalidate","invalidations","queue","scopesForId","mappedId","bundle","sourceMapTreeMappings","traceMappings","cachedCode","cachedSourceMap","generateSourceMap","cachedSourceMapString","cachedSourceMapDataUri","toDataUri","edgesFrom","edgesTo","sourceModules","sourceModule","edges","edge","fromHref","fromUri","toHref","toUri","moduleScopes","sourceModuleCode","clone","append","addSource","injectRuntime","inputMap","includeContent","hires","sourceHref","sourceMapsTree","DEFAULT_SHIM_GLOBALS","globalThis","visits","errors","seen","pendingModuleOperations","onCompletedEmitter","onErrorEmitter","onProgressEmitter","onCompleted","graph","onError","tokenSource","catch","cancel","fn","progress","edgesByDependency","WeakMap","edgesByInvalidation","sourceModulesByInvalidation","pluginManager","build","dep","runAsync","executeResolveDependency","createEdge","addEdge","loadEdge","hasSourceModule","existingSourceModule","addSourceModule","visitSourceModule","executeLoad","executeTransform","parseResult","toRootUri","executeResolveEntrypoint","fromEntrypoint","existingEdge","loadDependency","entrypoints","loadEntrypoint","isUri","deleteAll","fromRootUri","isValidEntry","isValidFile","isValidDirectory","specToString","specRx","JSDelivrCdn","protocol","host","mapChildEntry","matches","dataHost","UNPKG_SPEC_RX","UnpkgCdn","readUrlFn","cdn","urlForPackageFile","contentCache","locks","packageEntriesCache","packageJsonCache","isPrefixOf","unresolvedUri","resolveUri","_withRootUriCheck","unresolvedSpec","parseUrl","packageJsonReturn","runInChildContext","_readPackageJsonWithCache","packageJson","results","getResolveRoot","_readPackageEntriesWithCache","resolveRootUri","entriesReturn","canonicalizedSpec","traversalSegments","parentEntry","find","uriStr","cached","recordVisit","VisitKind","wrappedReturn","debug","_withLock","packageEntriesCacheForModule","exactMatch","range","_readPackageEntries","rootDir","urlForPackageList","dataStr","normalizePackageListing","packageJsonCacheForModule","visit","_readPackageJson","contentReturn","contentResult","manifest","canonicalHref","lockKey","lock","runCriticalSection","locked","CdnStrategy","strategies","method","strategy","_delegateToStrategy","getUrlForBareModule","defaultExtensions","defaultPackageMain","cdnStrategy","forUnpkg","readUrl","forJsDelivr","memoryStrategy","Math","random","entrypointUri","uriForPath","compoundStrategy","extensions","packageMain","graphBuilder","splitChunks","chunk","output","buildForStaticRuntime","execute","injectModules","injectedModuleSpecs","optionsExternal","isExternal","codeWithStart","runtimeCode","sourceMapDataUri","runtimeFn","Function","EMPTY_ELEMENTS","conf","wordPattern","comments","blockComment","brackets","autoClosingPairs","open","close","surroundingPairs","onEnterRules","beforeText","RegExp","afterText","action","indentAction","Monaco","IndentAction","IndentOutdent","Indent","language","defaultToken","tokenPostfix","ignoreCase","tokenizer","doctype","comment","otherTag","script","nextEmbedded","scriptAfterType","scriptAfterTypeEquals","switchTo","scriptWithCustomType","scriptEmbedded","style","styleAfterType","styleAfterTypeEquals","styleWithCustomType","styleEmbedded","fetch","arrayBuffer","EditorManager","disposableStore","initialPath","viewState","onWillFocusModelEmitter","onDidChangeEmitter","typescript","typescriptDefaults","setEagerModelSync","setMaximumWorkerIdleTime","setCompilerOptions","allowJs","allowNonTsExtensions","allowSyntheticDefaultImports","baseUrl","checkJs","esModuleInterop","experimentalDecorators","inlineSourceMap","inlineSources","isolatedModules","jsx","JsxEmit","React","lib","ModuleKind","CommonJS","moduleResolution","ModuleResolutionKind","NodeJs","noEmit","outDir","resolveJsonModule","target","ScriptTarget","ES2015","typeRoots","setDiagnosticsOptions","noSemanticValidation","noSyntaxValidation","register","mimetypes","setLanguageConfiguration","SvelteLanguage","setMonarchTokensProvider","createPrettierFormattingProvider","prettierPromise","loadPrettier","prettier","svelte","prettierPluginSvelte","provideDocumentFormattingEdits","formatted","filepath","singleQuote","tabWidth","getFullModelRange","codeFormattingEditProvider","registerDocumentFormattingEditProvider","createModel","inferLanguage","getModel","getModelByHref","focusModel","setModel","lineNumber","revealLineInCenter","ScrollType","Smooth","setPosition","columnNumber","markers","setModelMarkers","focus","getModelByPath","_","el","automaticLayout","minimap","enabled","showUnused","scrollBeyondLastLine","theme","wordWrap","wrappingIndent","onDidDispose","onDidChangeModel","newModelUrl","restoreViewState","onDidBlurEditorText","saveViewState","focusPath","EditorManagerContext","createContext","Editor","className","useRef","editorManager","useContext","useEffect","current","mount","ref","PreviewProgress","props","total","round","PreviewIframeWrap","PreviewWrap","PreviewMessageError","PreviewMessageErrorText","isInternal","PreviewMessages","PreviewMessageLine","PreviewMessage","lines","Preview","previewWrapRef","previewIframeRef","useState","buildState","setBuildState","buildProgress","setBuildProgress","onMessage","contentWindow","window","removeEventListener","monacoIntegration","onStateChange","Date","now","iframe","document","createElement","display","src","appendChild","onLoad","once","Entry","modelFocused","color","cursor","backgroundColor","CreateEntry","SidebarFileDelete","Button","StyledTooltip","SidebarFile","activeModel","workbench","setActiveModel","disposable","trackEditor","onDidFocusEditorText","hasTextFocus","onDidCreateEditor","useActiveModel","tooltip","useTooltipState","gutter","onClick","TooltipReference","as","role","aria-label","Tooltip","Sidebar","sortEntries","models","initialEntries","reduce","modelUri","nestedPath","nextDirIdx","setEntries","onWillDisposeModel","findIndex","splice","useDirectory","prompt","onClickCreate","PlaygroundCmp","project","Provider","Playground","trim","ServiceWorkerContext","ServiceWorkerProvider","waitingServiceWorker","assetsUpdateReady","assetsCached","useMemo","updateAssets","reload","PlaygroundWrapper","StatusBarItem","StatusBarStyles","AppWrapper","Title","Subtitle","Link","Links","Header","globalCss","css","App","CssBaseline","styles","rel","hostname","navigator","serviceWorker","ready","registration","unregister","ReactDOM","render","getElementById","SPEC_RX","parseBareModuleSpec","bareModuleSpec","nameSpec","ResolverStrategy","NODE_CORE_SHIMS","string_decoder","punycode","AbstractResolverStrategy","_uri","settings","overrides","setPrototypeOf","AbstractResolverStrategyWithRoot","CACHE","Symbol","Visits","cmp","equals","toArray","ResolverContext","mapResultWithVisits","cache","cacheInvalidations","debugMode","operationName","encodedOperation","encodePathNode","includes","formattedPath","decodePathNode","_wrapError","resetPath","concat","resetVisits","getCanonicalUrl","receiver","runWithCache","getSettings","invalidated","cacheKey","operationCache","listEntries","contextFn","runInContext","forOperation","mappedResult","cacheEntries","cacheSegment","cacheResult","createStoreResultFn","args","apply","promiseRet","wrappedRet","repeat","parts","log","bothResolved","canonicalizationResult","resolveRootResult","settingsResult","rootUriWithoutTrailingSlash","resolveAsDirectory","resolveAsFile","readParentPackageJsonReturn","readParentPackageJson","resolveAndPackageJson","readParentPackageJsonResult","parentPackageJson","parsedSpec","resolveBareModule","relativeUri","locatorName","locatorSpec","locatorPath","resolveRootReturn","nextUri","maxIterations","parentPackageJsonReturn","parentPackageJsonResult","directoryUri","devDependencies","peerDependencies","builtIn","bareModuleUriReturn","bareModuleUriResult","listEntriesReturn","listEntriesResult","mainPathname","packageJsonUri","packageJsonEntry","packageJsonContentReturn","packageJsonContentResult","fileUri","ignoreBrowserOverrides","TypeError","browserOverrides","readParentPackageJsonInternal","uriIsCanonicalized","browserMap","packageJsonDir","impliedUri","targetSpec","containingDirUri","entriesResult","entryDirectoryMap","entryFileMap","childFilename","getFirstPathSegmentAfterPrefix","hrefWithExtensionUri","hrefWithExtension","mapping","canonicalizationReturn","visitedDirs","hostRootHref","containingDirUrl","readPackageJsonOrRecurse","parentPackageJsonContentReturn","parentPackageJsonContentResult","parentDir","Resolver","disposed","rootCtx","runInIsolatedContext"],"mappings":"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","file":"static/js/main.25a14fe2.chunk.js","sourcesContent":["type Buffer = {\n  from(\n    buf: BufferSource | string,\n    encoding?: 'base64'\n  ): {\n    toString(encoding: 'base64' | 'utf-8'): string;\n  };\n};\n\nexport namespace Base64 {\n  export const decode =\n    typeof global === 'object' && typeof global['Buffer'] === 'function'\n      ? (data: string) => (global['Buffer'] as Buffer).from(data, 'base64').toString('utf-8')\n      : typeof atob === 'function'\n      ? (data: string) => decodeURIComponent(escape(atob(data)))\n      : (_data: string) => {\n          throw new Error(\n            'The environment has neither the Buffer nor btoa functions. Please consider polyfilling one of these apis.'\n          );\n        };\n\n  export const encode =\n    typeof global === 'object' && typeof global['Buffer'] === 'function'\n      ? (data: string) => (global['Buffer'] as Buffer).from(data).toString('base64')\n      : typeof btoa === 'function'\n      ? (data: string) => btoa(unescape(encodeURIComponent(data)))\n      : (_data: string) => {\n          throw new Error(\n            'The environment has neither the Buffer nor btoa functions. Please consider polyfilling one of these apis.'\n          );\n        };\n}\n","import type { Uri } from './uri';\n\nabstract class BaseError extends Error {\n  readonly name = this.constructor.name;\n}\n\nexport class AmbiguousModuleError extends BaseError {}\n\nexport class CanceledError extends BaseError {}\n\nexport class EntryExcludedError extends BaseError {\n  constructor(uri: { toString(): string }) {\n    super(`Entry was excluded by current configuration '${uri.toString()}'`);\n  }\n}\n\nexport class EntryNotFoundError extends BaseError {\n  constructor(uri: { toString(): string }) {\n    super(`Unable to resolve '${uri.toString()}'`);\n  }\n}\n\nexport class DependencyNotFoundError extends EntryNotFoundError {\n  constructor(spec: string, parentUri: { toString(): string }) {\n    super(`The dependency '${spec}' of '${parentUri.toString()}' was not found`);\n  }\n}\n\nexport class NotResolvableError extends BaseError {}\n\nexport class ParseError extends BaseError {\n  constructor(readonly uri: Uri, message: string) {\n    super(`Parsing failed for '${uri.toString()}': ${message}`);\n  }\n}\n\nexport function isCanceledError(err: unknown): err is CanceledError {\n  return err instanceof CanceledError || (err && (err as any).name === 'CanceledError');\n}\n","import type { CancellationToken } from 'ts-primitives';\nimport { CanceledError } from './error';\n\nexport type Awaited<T> = T extends Thenable<infer U> ? U : T;\n\nexport interface Thenable<T> {\n  /**\n   * Attaches callbacks for the resolution and/or rejection of the Promise.\n   * @param onfulfilled The callback to execute when the Promise is resolved.\n   * @param onrejected The callback to execute when the Promise is rejected.\n   * @returns A Promise for the completion of which ever callback is executed.\n   */\n  then<TResult>(\n    onfulfilled?: (value: T) => TResult | Thenable<TResult>,\n    onrejected?: (reason: any) => TResult | Thenable<TResult>\n  ): Thenable<TResult>;\n  then<TResult>(\n    onfulfilled?: (value: T) => TResult | Thenable<TResult>,\n    onrejected?: (reason: any) => void\n  ): Thenable<TResult>;\n}\n\n// See: https://github.com/microsoft/TypeScript/pull/26063#issuecomment-461576933\nexport function all<T extends [unknown] | unknown[]>(values: T, token: CancellationToken) {\n  let shouldAwait = false;\n\n  const result = values.map((element) => {\n    if (isThenable(element)) {\n      shouldAwait = true;\n\n      return checkCancellation(element, token);\n    }\n\n    return element;\n  }) as T;\n\n  if (shouldAwait) {\n    return (Promise.all(result) as unknown) as Promise<{ [P in keyof T]: Awaited<T[P]> }>;\n  }\n\n  return values as { [P in keyof T]: Awaited<T[P]> };\n}\n\nexport async function checkCancellation<T>(promise: Thenable<T>, token: CancellationToken) {\n  try {\n    const result = await promise;\n    if (token.isCancellationRequested) {\n      return Promise.reject(new CanceledError());\n    }\n\n    return result;\n  } catch (err) {\n    if (token.isCancellationRequested) {\n      return Promise.reject(new CanceledError());\n    }\n\n    throw err;\n  }\n}\n\nexport function isThenable<T = unknown>(object: unknown): object is Thenable<T> {\n  return (\n    object &&\n    // Detection of 'normal' thenable\n    (typeof (object as any).then === 'function' ||\n      // Detection for regenerator runtime state\n      (typeof (object as any).done === 'boolean' &&\n        typeof (object as any).next === 'number' &&\n        typeof (object as any).pre === 'number'))\n  );\n}\n","export class Decoder {\n  private readonly decoder: TextDecoder | undefined;\n\n  constructor() {\n    if (typeof TextDecoder !== 'undefined') {\n      this.decoder = new TextDecoder();\n    } else if (typeof Buffer !== 'function' || typeof Buffer['from'] !== 'function') {\n      throw new Error(\n        'The environment supports neither the TextDecoder nor Buffer API. Please consider polyfilling one of these.'\n      );\n    }\n  }\n\n  decode(buf: BufferSource): string {\n    const str = this.decoder\n      ? this.decoder.decode(buf)\n      : (Buffer as any).from(buf).toString('utf-8');\n\n    return str.charCodeAt(0) === 0xfeff ? str.slice(1) : str;\n  }\n}\n","export class MapSet<K, V> {\n  private readonly _data = new Map<K, Set<V>>();\n\n  get size() {\n    return this._data.size;\n  }\n\n  add(key: K, value: V) {\n    let values = this._data.get(key);\n\n    if (!values) {\n      values = new Set();\n      this._data.set(key, values);\n    }\n\n    values.add(value);\n\n    return this;\n  }\n\n  clear() {\n    this._data.clear();\n  }\n\n  delete(key: K, value: V) {\n    const values = this._data.get(key);\n\n    if (values) {\n      const ret = values.delete(value);\n\n      if (!values.size) {\n        this._data.delete(key);\n      }\n\n      return ret;\n    }\n\n    return false;\n  }\n\n  deleteAll(key: K) {\n    return this._data.delete(key);\n  }\n\n  get(key: K) {\n    return this._data.get(key);\n  }\n\n  has(key: K) {\n    return this._data.has(key);\n  }\n\n  hasValue(key: K, value: V) {\n    const values = this._data.get(key);\n\n    return values ? values.has(value) : false;\n  }\n\n  *entries(): IterableIterator<[K, V]> {\n    for (const [key, values] of this._data.entries()) {\n      for (const value of values) {\n        yield [key, value];\n      }\n    }\n  }\n\n  *values(): IterableIterator<V> {\n    for (const values of this._data.values()) {\n      yield* values.values();\n    }\n  }\n}\n","import { Decoder } from './decoder';\n\nexport type PackageMainField = 'browser' | 'module' | 'jsnext:main' | 'main' | 'unpkg';\n\nexport interface PartialPackageJson {\n  name?: string;\n  version?: string;\n  browser?: string | { [key: string]: false | string };\n  main?: string;\n  module?: string;\n  'jsnext:main'?: string;\n  dependencies?: { [key: string]: string };\n  devDependencies?: { [key: string]: string };\n  peerDependencies?: { [key: string]: string };\n  unpkg?: string;\n}\nexport interface PackageJson extends PartialPackageJson {\n  name: string;\n  version: string;\n}\n\nexport function isValidPartialPackageJson(json: unknown): json is PartialPackageJson {\n  return (\n    typeof json === 'object' &&\n    json !== null &&\n    !hasInvalidOptionalStringField(json as any, 'name') &&\n    !hasInvalidOptionalStringField(json as any, 'version') &&\n    !hasInvalidBrowserField(json as any) &&\n    !hasInvalidOptionalStringField(json as any, 'main') &&\n    !hasInvalidOptionalStringField(json as any, 'module') &&\n    !hasInvalidOptionalStringField(json as any, 'jsnext:main') &&\n    !hasInvalidOptionalStringField(json as any, 'unpkg') &&\n    !hasInvalidDependenciesField(json as any, 'dependencies') &&\n    !hasInvalidDependenciesField(json as any, 'devDependencies') &&\n    !hasInvalidDependenciesField(json as any, 'peerDependencies')\n  );\n}\n\nexport function isValidPackageJson(json: unknown): json is PackageJson {\n  return (\n    typeof json === 'object' &&\n    json !== null &&\n    !hasInvalidRequiredStringField(json as any, 'name') &&\n    !hasInvalidRequiredStringField(json as any, 'version') &&\n    !hasInvalidBrowserField(json as any) &&\n    !hasInvalidOptionalStringField(json as any, 'main') &&\n    !hasInvalidOptionalStringField(json as any, 'module') &&\n    !hasInvalidOptionalStringField(json as any, 'jsnext:main') &&\n    !hasInvalidOptionalStringField(json as any, 'unpkg') &&\n    !hasInvalidDependenciesField(json as any, 'dependencies') &&\n    !hasInvalidDependenciesField(json as any, 'devDependencies') &&\n    !hasInvalidDependenciesField(json as any, 'peerDependencies')\n  );\n}\n\nfunction hasInvalidBrowserField(json: any) {\n  let error = '';\n\n  const browser = json.browser;\n  if (browser) {\n    if (typeof browser === 'object') {\n      for (const key in browser) {\n        if (typeof key !== 'string') {\n          error = `The key ${key} of .browser must be a string`;\n          break;\n        }\n        if (typeof browser[key] !== 'string' && browser[key] !== false) {\n          error = `The value ${key} of .browser must be a string or false`;\n          break;\n        }\n      }\n    }\n  }\n\n  return error;\n}\n\nfunction hasInvalidRequiredStringField(json: any, field: string) {\n  return typeof json[field] !== 'string';\n}\n\nfunction hasInvalidOptionalStringField(json: any, field: string) {\n  return json[field] !== undefined && typeof json[field] !== 'string';\n}\n\nfunction hasInvalidDependenciesField(json: any, field: string) {\n  return (\n    json[field] !== undefined &&\n    typeof json[field] === 'object' &&\n    json[field] !== null &&\n    !Object.keys(json[field]).every(\n      (key) => typeof key === 'string' && typeof json[field][key] === 'string'\n    )\n  );\n}\n\nexport function parseBufferAsPartialPackageJson(\n  decoder: Decoder,\n  content: ArrayBuffer,\n  spec: string\n): PartialPackageJson {\n  try {\n    const text = decoder.decode(content);\n\n    return parseTextAsPartialPackageJson(text, spec);\n  } catch (err) {\n    throw new Error(`Error decoding manifest buffer for package ${spec}: ${err.message}`);\n  }\n}\n\nexport function parseBufferAsPackageJson(\n  decoder: Decoder,\n  content: ArrayBuffer,\n  spec: string\n): PackageJson {\n  try {\n    const text = decoder.decode(content);\n\n    return parseTextAsPackageJson(text, spec);\n  } catch (err) {\n    throw new Error(`Error decoding manifest buffer for package ${spec}: ${err.message}`);\n  }\n}\n\nfunction parseTextAsPartialPackageJson(text: string, spec: string): PartialPackageJson {\n  let json: unknown;\n\n  try {\n    json = JSON.parse(text);\n  } catch (err) {\n    throw new Error(`Error parsing manifest as json for package ${spec}: ${err.message}`);\n  }\n\n  if (!isValidPartialPackageJson(json)) {\n    throw new Error(`Invalid manifest for the package ${spec}`);\n  }\n\n  return json;\n}\n\nfunction parseTextAsPackageJson(text: string, spec: string): PackageJson {\n  const json = parseTextAsPartialPackageJson(text, spec);\n\n  if (!isValidPackageJson(json)) {\n    throw new Error(`Invalid manifest for the package ${spec}`);\n  }\n\n  return json;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n// NOTE: VSCode's copy of nodejs path library to be usable in common (non-node) namespace\n// Copied from: https://github.com/nodejs/node/blob/v12.8.1/lib/path.js\n\n/**\n * Copyright Joyent, Inc. and other Node contributors.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to permit\n * persons to whom the Software is furnished to do so, subject to the\n * following conditions:\n *\n * The above copyright notice and this permission notice shall be included\n * in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n * NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n * USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\nconst CHAR_DOT = 46; /* . */\nconst CHAR_FORWARD_SLASH = 47; /* / */\n\nclass ErrorInvalidArgType extends Error {\n  code: 'ERR_INVALID_ARG_TYPE';\n  constructor(name: string, expected: string, actual: any) {\n    // determiner: 'must be' or 'must not be'\n    let determiner;\n    if (typeof expected === 'string' && expected.indexOf('not ') === 0) {\n      determiner = 'must not be';\n      expected = expected.replace(/^not /, '');\n    } else {\n      determiner = 'must be';\n    }\n\n    const type = name.indexOf('.') !== -1 ? 'property' : 'argument';\n    let msg = `The \"${name}\" ${type} ${determiner} of type ${expected}`;\n\n    msg += `. Received type ${typeof actual}`;\n    super(msg);\n\n    this.code = 'ERR_INVALID_ARG_TYPE';\n  }\n}\n\nfunction validateString(value: string, name: string) {\n  if (typeof value !== 'string') {\n    throw new ErrorInvalidArgType(name, 'string', value);\n  }\n}\n\nfunction isPosixPathSeparator(code: number | undefined) {\n  return code === CHAR_FORWARD_SLASH;\n}\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeString(\n  path: string,\n  allowAboveRoot: boolean,\n  separator: string,\n  isPathSeparator: (code?: number) => boolean\n) {\n  let res = '';\n  let lastSegmentLength = 0;\n  let lastSlash = -1;\n  let dots = 0;\n  let code = 0;\n  for (let i = 0; i <= path.length; ++i) {\n    if (i < path.length) {\n      code = path.charCodeAt(i);\n    } else if (isPathSeparator(code)) {\n      break;\n    } else {\n      code = CHAR_FORWARD_SLASH;\n    }\n\n    if (isPathSeparator(code)) {\n      if (lastSlash === i - 1 || dots === 1) {\n        // NOOP\n      } else if (dots === 2) {\n        if (\n          res.length < 2 ||\n          lastSegmentLength !== 2 ||\n          res.charCodeAt(res.length - 1) !== CHAR_DOT ||\n          res.charCodeAt(res.length - 2) !== CHAR_DOT\n        ) {\n          if (res.length > 2) {\n            const lastSlashIndex = res.lastIndexOf(separator);\n            if (lastSlashIndex === -1) {\n              res = '';\n              lastSegmentLength = 0;\n            } else {\n              res = res.slice(0, lastSlashIndex);\n              lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);\n            }\n            lastSlash = i;\n            dots = 0;\n            continue;\n          } else if (res.length !== 0) {\n            res = '';\n            lastSegmentLength = 0;\n            lastSlash = i;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          res += res.length > 0 ? `${separator}..` : '..';\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (res.length > 0) {\n          res += `${separator}${path.slice(lastSlash + 1, i)}`;\n        } else {\n          res = path.slice(lastSlash + 1, i);\n        }\n        lastSegmentLength = i - lastSlash - 1;\n      }\n      lastSlash = i;\n      dots = 0;\n    } else if (code === CHAR_DOT && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\n\nfunction _format(sep: string, pathObject: ParsedPath) {\n  if (pathObject === null || typeof pathObject !== 'object') {\n    throw new ErrorInvalidArgType('pathObject', 'Object', pathObject);\n  }\n  const dir = pathObject.dir || pathObject.root;\n  const base = pathObject.base || `${pathObject.name || ''}${pathObject.ext || ''}`;\n  if (!dir) {\n    return base;\n  }\n  return dir === pathObject.root ? `${dir}${base}` : `${dir}${sep}${base}`;\n}\n\nexport interface ParsedPath {\n  root: string;\n  dir: string;\n  base: string;\n  ext: string;\n  name: string;\n}\n\nexport interface IPath {\n  normalize(path: string): string;\n  isAbsolute(path: string): boolean;\n  join(...paths: string[]): string;\n  resolve(...pathSegments: string[]): string;\n  relative(from: string, to: string): string;\n  dirname(path: string): string;\n  basename(path: string, ext?: string): string;\n  extname(path: string): string;\n  format(pathObject: ParsedPath): string;\n  parse(path: string): ParsedPath;\n  toNamespacedPath(path: string): string;\n  sep: '\\\\' | '/';\n  delimiter: string;\n  win32: IPath | null;\n  posix: IPath | null;\n}\n\n// export const win32: IPath = {\n// \t// path.resolve([from ...], to)\n// \tresolve(...pathSegments: string[]): string {\n// \t\tlet resolvedDevice = '';\n// \t\tlet resolvedTail = '';\n// \t\tlet resolvedAbsolute = false;\n\n// \t\tfor (let i = pathSegments.length - 1; i >= -1; i--) {\n// \t\t\tlet path;\n// \t\t\tif (i >= 0) {\n// \t\t\t\tpath = pathSegments[i];\n// \t\t\t\tvalidateString(path, 'path');\n\n// \t\t\t\t// Skip empty entries\n// \t\t\t\tif (path.length === 0) {\n// \t\t\t\t\tcontinue;\n// \t\t\t\t}\n// \t\t\t} else if (resolvedDevice.length === 0) {\n// \t\t\t\tpath = process.cwd();\n// \t\t\t} else {\n// \t\t\t\t// Windows has the concept of drive-specific current working\n// \t\t\t\t// directories. If we've resolved a drive letter but not yet an\n// \t\t\t\t// absolute path, get cwd for that drive, or the process cwd if\n// \t\t\t\t// the drive cwd is not available. We're sure the device is not\n// \t\t\t\t// a UNC path at this points, because UNC paths are always absolute.\n// \t\t\t\tpath = (process.env as any)[`=${resolvedDevice}`] || process.cwd();\n\n// \t\t\t\t// Verify that a cwd was found and that it actually points\n// \t\t\t\t// to our drive. If not, default to the drive's root.\n// \t\t\t\tif (path === undefined ||\n// \t\t\t\t\tpath.slice(0, 2).toLowerCase() !== resolvedDevice.toLowerCase() &&\n// \t\t\t\t\tpath.charCodeAt(2) === CHAR_BACKWARD_SLASH) {\n// \t\t\t\t\tpath = `${resolvedDevice}\\\\`;\n// \t\t\t\t}\n// \t\t\t}\n\n// \t\t\tconst len = path.length;\n// \t\t\tlet rootEnd = 0;\n// \t\t\tlet device = '';\n// \t\t\tlet isAbsolute = false;\n// \t\t\tconst code = path.charCodeAt(0);\n\n// \t\t\t// Try to match a root\n// \t\t\tif (len === 1) {\n// \t\t\t\tif (isPathSeparator(code)) {\n// \t\t\t\t\t// `path` contains just a path separator\n// \t\t\t\t\trootEnd = 1;\n// \t\t\t\t\tisAbsolute = true;\n// \t\t\t\t}\n// \t\t\t} else if (isPathSeparator(code)) {\n// \t\t\t\t// Possible UNC root\n\n// \t\t\t\t// If we started with a separator, we know we at least have an\n// \t\t\t\t// absolute path of some kind (UNC or otherwise)\n// \t\t\t\tisAbsolute = true;\n\n// \t\t\t\tif (isPathSeparator(path.charCodeAt(1))) {\n// \t\t\t\t\t// Matched double path separator at beginning\n// \t\t\t\t\tlet j = 2;\n// \t\t\t\t\tlet last = j;\n// \t\t\t\t\t// Match 1 or more non-path separators\n// \t\t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n// \t\t\t\t\t\tj++;\n// \t\t\t\t\t}\n// \t\t\t\t\tif (j < len && j !== last) {\n// \t\t\t\t\t\tconst firstPart = path.slice(last, j);\n// \t\t\t\t\t\t// Matched!\n// \t\t\t\t\t\tlast = j;\n// \t\t\t\t\t\t// Match 1 or more path separators\n// \t\t\t\t\t\twhile (j < len && isPathSeparator(path.charCodeAt(j))) {\n// \t\t\t\t\t\t\tj++;\n// \t\t\t\t\t\t}\n// \t\t\t\t\t\tif (j < len && j !== last) {\n// \t\t\t\t\t\t\t// Matched!\n// \t\t\t\t\t\t\tlast = j;\n// \t\t\t\t\t\t\t// Match 1 or more non-path separators\n// \t\t\t\t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n// \t\t\t\t\t\t\t\tj++;\n// \t\t\t\t\t\t\t}\n// \t\t\t\t\t\t\tif (j === len || j !== last) {\n// \t\t\t\t\t\t\t\t// We matched a UNC root\n// \t\t\t\t\t\t\t\tdevice = `\\\\\\\\${firstPart}\\\\${path.slice(last, j)}`;\n// \t\t\t\t\t\t\t\trootEnd = j;\n// \t\t\t\t\t\t\t}\n// \t\t\t\t\t\t}\n// \t\t\t\t\t}\n// \t\t\t\t} else {\n// \t\t\t\t\trootEnd = 1;\n// \t\t\t\t}\n// \t\t\t} else if (isWindowsDeviceRoot(code) &&\n// \t\t\t\tpath.charCodeAt(1) === CHAR_COLON) {\n// \t\t\t\t// Possible device root\n// \t\t\t\tdevice = path.slice(0, 2);\n// \t\t\t\trootEnd = 2;\n// \t\t\t\tif (len > 2 && isPathSeparator(path.charCodeAt(2))) {\n// \t\t\t\t\t// Treat separator following drive name as an absolute path\n// \t\t\t\t\t// indicator\n// \t\t\t\t\tisAbsolute = true;\n// \t\t\t\t\trootEnd = 3;\n// \t\t\t\t}\n// \t\t\t}\n\n// \t\t\tif (device.length > 0) {\n// \t\t\t\tif (resolvedDevice.length > 0) {\n// \t\t\t\t\tif (device.toLowerCase() !== resolvedDevice.toLowerCase()) {\n// \t\t\t\t\t\t// This path points to another device so it is not applicable\n// \t\t\t\t\t\tcontinue;\n// \t\t\t\t\t}\n// \t\t\t\t} else {\n// \t\t\t\t\tresolvedDevice = device;\n// \t\t\t\t}\n// \t\t\t}\n\n// \t\t\tif (resolvedAbsolute) {\n// \t\t\t\tif (resolvedDevice.length > 0) {\n// \t\t\t\t\tbreak;\n// \t\t\t\t}\n// \t\t\t} else {\n// \t\t\t\tresolvedTail = `${path.slice(rootEnd)}\\\\${resolvedTail}`;\n// \t\t\t\tresolvedAbsolute = isAbsolute;\n// \t\t\t\tif (isAbsolute && resolvedDevice.length > 0) {\n// \t\t\t\t\tbreak;\n// \t\t\t\t}\n// \t\t\t}\n// \t\t}\n\n// \t\t// At this point the path should be resolved to a full absolute path,\n// \t\t// but handle relative paths to be safe (might happen when process.cwd()\n// \t\t// fails)\n\n// \t\t// Normalize the tail path\n// \t\tresolvedTail = normalizeString(resolvedTail, !resolvedAbsolute, '\\\\',\n// \t\t\tisPathSeparator);\n\n// \t\treturn resolvedAbsolute ?\n// \t\t\t`${resolvedDevice}\\\\${resolvedTail}` :\n// \t\t\t`${resolvedDevice}${resolvedTail}` || '.';\n// \t},\n\n// \tnormalize(path: string): string {\n// \t\tvalidateString(path, 'path');\n// \t\tconst len = path.length;\n// \t\tif (len === 0) {\n// \t\t\treturn '.';\n// \t\t}\n// \t\tlet rootEnd = 0;\n// \t\tlet device;\n// \t\tlet isAbsolute = false;\n// \t\tconst code = path.charCodeAt(0);\n\n// \t\t// Try to match a root\n// \t\tif (len === 1) {\n// \t\t\t// `path` contains just a single char, exit early to avoid\n// \t\t\t// unnecessary work\n// \t\t\treturn isPosixPathSeparator(code) ? '\\\\' : path;\n// \t\t}\n// \t\tif (isPathSeparator(code)) {\n// \t\t\t// Possible UNC root\n\n// \t\t\t// If we started with a separator, we know we at least have an absolute\n// \t\t\t// path of some kind (UNC or otherwise)\n// \t\t\tisAbsolute = true;\n\n// \t\t\tif (isPathSeparator(path.charCodeAt(1))) {\n// \t\t\t\t// Matched double path separator at beginning\n// \t\t\t\tlet j = 2;\n// \t\t\t\tlet last = j;\n// \t\t\t\t// Match 1 or more non-path separators\n// \t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n// \t\t\t\t\tj++;\n// \t\t\t\t}\n// \t\t\t\tif (j < len && j !== last) {\n// \t\t\t\t\tconst firstPart = path.slice(last, j);\n// \t\t\t\t\t// Matched!\n// \t\t\t\t\tlast = j;\n// \t\t\t\t\t// Match 1 or more path separators\n// \t\t\t\t\twhile (j < len && isPathSeparator(path.charCodeAt(j))) {\n// \t\t\t\t\t\tj++;\n// \t\t\t\t\t}\n// \t\t\t\t\tif (j < len && j !== last) {\n// \t\t\t\t\t\t// Matched!\n// \t\t\t\t\t\tlast = j;\n// \t\t\t\t\t\t// Match 1 or more non-path separators\n// \t\t\t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n// \t\t\t\t\t\t\tj++;\n// \t\t\t\t\t\t}\n// \t\t\t\t\t\tif (j === len) {\n// \t\t\t\t\t\t\t// We matched a UNC root only\n// \t\t\t\t\t\t\t// Return the normalized version of the UNC root since there\n// \t\t\t\t\t\t\t// is nothing left to process\n// \t\t\t\t\t\t\treturn `\\\\\\\\${firstPart}\\\\${path.slice(last)}\\\\`;\n// \t\t\t\t\t\t}\n// \t\t\t\t\t\tif (j !== last) {\n// \t\t\t\t\t\t\t// We matched a UNC root with leftovers\n// \t\t\t\t\t\t\tdevice = `\\\\\\\\${firstPart}\\\\${path.slice(last, j)}`;\n// \t\t\t\t\t\t\trootEnd = j;\n// \t\t\t\t\t\t}\n// \t\t\t\t\t}\n// \t\t\t\t}\n// \t\t\t} else {\n// \t\t\t\trootEnd = 1;\n// \t\t\t}\n// \t\t} else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {\n// \t\t\t// Possible device root\n// \t\t\tdevice = path.slice(0, 2);\n// \t\t\trootEnd = 2;\n// \t\t\tif (len > 2 && isPathSeparator(path.charCodeAt(2))) {\n// \t\t\t\t// Treat separator following drive name as an absolute path\n// \t\t\t\t// indicator\n// \t\t\t\tisAbsolute = true;\n// \t\t\t\trootEnd = 3;\n// \t\t\t}\n// \t\t}\n\n// \t\tlet tail = rootEnd < len ?\n// \t\t\tnormalizeString(path.slice(rootEnd), !isAbsolute, '\\\\', isPathSeparator) :\n// \t\t\t'';\n// \t\tif (tail.length === 0 && !isAbsolute) {\n// \t\t\ttail = '.';\n// \t\t}\n// \t\tif (tail.length > 0 && isPathSeparator(path.charCodeAt(len - 1))) {\n// \t\t\ttail += '\\\\';\n// \t\t}\n// \t\tif (device === undefined) {\n// \t\t\treturn isAbsolute ? `\\\\${tail}` : tail;\n// \t\t}\n// \t\treturn isAbsolute ? `${device}\\\\${tail}` : `${device}${tail}`;\n// \t},\n\n// \tisAbsolute(path: string): boolean {\n// \t\tvalidateString(path, 'path');\n// \t\tconst len = path.length;\n// \t\tif (len === 0) {\n// \t\t\treturn false;\n// \t\t}\n\n// \t\tconst code = path.charCodeAt(0);\n// \t\treturn isPathSeparator(code) ||\n// \t\t\t// Possible device root\n// \t\t\tlen > 2 &&\n// \t\t\tisWindowsDeviceRoot(code) &&\n// \t\t\tpath.charCodeAt(1) === CHAR_COLON &&\n// \t\t\tisPathSeparator(path.charCodeAt(2));\n// \t},\n\n// \tjoin(...paths: string[]): string {\n// \t\tif (paths.length === 0) {\n// \t\t\treturn '.';\n// \t\t}\n\n// \t\tlet joined;\n// \t\tlet firstPart: string | undefined;\n// \t\tfor (let i = 0; i < paths.length; ++i) {\n// \t\t\tconst arg = paths[i];\n// \t\t\tvalidateString(arg, 'path');\n// \t\t\tif (arg.length > 0) {\n// \t\t\t\tif (joined === undefined) {\n// \t\t\t\t\tjoined = firstPart = arg;\n// \t\t\t\t}\n// \t\t\t\telse {\n// \t\t\t\t\tjoined += `\\\\${arg}`;\n// \t\t\t\t}\n// \t\t\t}\n// \t\t}\n\n// \t\tif (joined === undefined) {\n// \t\t\treturn '.';\n// \t\t}\n\n// \t\t// Make sure that the joined path doesn't start with two slashes, because\n// \t\t// normalize() will mistake it for an UNC path then.\n// \t\t//\n// \t\t// This step is skipped when it is very clear that the user actually\n// \t\t// intended to point at an UNC path. This is assumed when the first\n// \t\t// non-empty string arguments starts with exactly two slashes followed by\n// \t\t// at least one more non-slash character.\n// \t\t//\n// \t\t// Note that for normalize() to treat a path as an UNC path it needs to\n// \t\t// have at least 2 components, so we don't filter for that here.\n// \t\t// This means that the user can use join to construct UNC paths from\n// \t\t// a server name and a share name; for example:\n// \t\t//   path.join('//server', 'share') -> '\\\\\\\\server\\\\share\\\\')\n// \t\tlet needsReplace = true;\n// \t\tlet slashCount = 0;\n// \t\tif (typeof firstPart === 'string' && isPathSeparator(firstPart.charCodeAt(0))) {\n// \t\t\t++slashCount;\n// \t\t\tconst firstLen = firstPart.length;\n// \t\t\tif (firstLen > 1 && isPathSeparator(firstPart.charCodeAt(1))) {\n// \t\t\t\t++slashCount;\n// \t\t\t\tif (firstLen > 2) {\n// \t\t\t\t\tif (isPathSeparator(firstPart.charCodeAt(2))) {\n// \t\t\t\t\t\t++slashCount;\n// \t\t\t\t\t} else {\n// \t\t\t\t\t\t// We matched a UNC path in the first part\n// \t\t\t\t\t\tneedsReplace = false;\n// \t\t\t\t\t}\n// \t\t\t\t}\n// \t\t\t}\n// \t\t}\n// \t\tif (needsReplace) {\n// \t\t\t// Find any more consecutive slashes we need to replace\n// \t\t\twhile (slashCount < joined.length &&\n// \t\t\t\tisPathSeparator(joined.charCodeAt(slashCount))) {\n// \t\t\t\tslashCount++;\n// \t\t\t}\n\n// \t\t\t// Replace the slashes if needed\n// \t\t\tif (slashCount >= 2) {\n// \t\t\t\tjoined = `\\\\${joined.slice(slashCount)}`;\n// \t\t\t}\n// \t\t}\n\n// \t\treturn win32.normalize(joined);\n// \t},\n\n// \t// It will solve the relative path from `from` to `to`, for instance:\n// \t//  from = 'C:\\\\orandea\\\\test\\\\aaa'\n// \t//  to = 'C:\\\\orandea\\\\impl\\\\bbb'\n// \t// The output of the function should be: '..\\\\..\\\\impl\\\\bbb'\n// \trelative(from: string, to: string): string {\n// \t\tvalidateString(from, 'from');\n// \t\tvalidateString(to, 'to');\n\n// \t\tif (from === to) {\n// \t\t\treturn '';\n// \t\t}\n\n// \t\tconst fromOrig = win32.resolve(from);\n// \t\tconst toOrig = win32.resolve(to);\n\n// \t\tif (fromOrig === toOrig) {\n// \t\t\treturn '';\n// \t\t}\n\n// \t\tfrom = fromOrig.toLowerCase();\n// \t\tto = toOrig.toLowerCase();\n\n// \t\tif (from === to) {\n// \t\t\treturn '';\n// \t\t}\n\n// \t\t// Trim any leading backslashes\n// \t\tlet fromStart = 0;\n// \t\twhile (fromStart < from.length &&\n// \t\t\tfrom.charCodeAt(fromStart) === CHAR_BACKWARD_SLASH) {\n// \t\t\tfromStart++;\n// \t\t}\n// \t\t// Trim trailing backslashes (applicable to UNC paths only)\n// \t\tlet fromEnd = from.length;\n// \t\twhile (fromEnd - 1 > fromStart &&\n// \t\t\tfrom.charCodeAt(fromEnd - 1) === CHAR_BACKWARD_SLASH) {\n// \t\t\tfromEnd--;\n// \t\t}\n// \t\tconst fromLen = fromEnd - fromStart;\n\n// \t\t// Trim any leading backslashes\n// \t\tlet toStart = 0;\n// \t\twhile (toStart < to.length &&\n// \t\t\tto.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {\n// \t\t\ttoStart++;\n// \t\t}\n// \t\t// Trim trailing backslashes (applicable to UNC paths only)\n// \t\tlet toEnd = to.length;\n// \t\twhile (toEnd - 1 > toStart &&\n// \t\t\tto.charCodeAt(toEnd - 1) === CHAR_BACKWARD_SLASH) {\n// \t\t\ttoEnd--;\n// \t\t}\n// \t\tconst toLen = toEnd - toStart;\n\n// \t\t// Compare paths to find the longest common path from root\n// \t\tconst length = fromLen < toLen ? fromLen : toLen;\n// \t\tlet lastCommonSep = -1;\n// \t\tlet i = 0;\n// \t\tfor (; i < length; i++) {\n// \t\t\tconst fromCode = from.charCodeAt(fromStart + i);\n// \t\t\tif (fromCode !== to.charCodeAt(toStart + i)) {\n// \t\t\t\tbreak;\n// \t\t\t} else if (fromCode === CHAR_BACKWARD_SLASH) {\n// \t\t\t\tlastCommonSep = i;\n// \t\t\t}\n// \t\t}\n\n// \t\t// We found a mismatch before the first common path separator was seen, so\n// \t\t// return the original `to`.\n// \t\tif (i !== length) {\n// \t\t\tif (lastCommonSep === -1) {\n// \t\t\t\treturn toOrig;\n// \t\t\t}\n// \t\t} else {\n// \t\t\tif (toLen > length) {\n// \t\t\t\tif (to.charCodeAt(toStart + i) === CHAR_BACKWARD_SLASH) {\n// \t\t\t\t\t// We get here if `from` is the exact base path for `to`.\n// \t\t\t\t\t// For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo\\\\bar\\\\baz'\n// \t\t\t\t\treturn toOrig.slice(toStart + i + 1);\n// \t\t\t\t}\n// \t\t\t\tif (i === 2) {\n// \t\t\t\t\t// We get here if `from` is the device root.\n// \t\t\t\t\t// For example: from='C:\\\\'; to='C:\\\\foo'\n// \t\t\t\t\treturn toOrig.slice(toStart + i);\n// \t\t\t\t}\n// \t\t\t}\n// \t\t\tif (fromLen > length) {\n// \t\t\t\tif (from.charCodeAt(fromStart + i) === CHAR_BACKWARD_SLASH) {\n// \t\t\t\t\t// We get here if `to` is the exact base path for `from`.\n// \t\t\t\t\t// For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo'\n// \t\t\t\t\tlastCommonSep = i;\n// \t\t\t\t} else if (i === 2) {\n// \t\t\t\t\t// We get here if `to` is the device root.\n// \t\t\t\t\t// For example: from='C:\\\\foo\\\\bar'; to='C:\\\\'\n// \t\t\t\t\tlastCommonSep = 3;\n// \t\t\t\t}\n// \t\t\t}\n// \t\t\tif (lastCommonSep === -1) {\n// \t\t\t\tlastCommonSep = 0;\n// \t\t\t}\n// \t\t}\n\n// \t\tlet out = '';\n// \t\t// Generate the relative path based on the path difference between `to` and\n// \t\t// `from`\n// \t\tfor (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n// \t\t\tif (i === fromEnd || from.charCodeAt(i) === CHAR_BACKWARD_SLASH) {\n// \t\t\t\tout += out.length === 0 ? '..' : '\\\\..';\n// \t\t\t}\n// \t\t}\n\n// \t\ttoStart += lastCommonSep;\n\n// \t\t// Lastly, append the rest of the destination (`to`) path that comes after\n// \t\t// the common path parts\n// \t\tif (out.length > 0) {\n// \t\t\treturn `${out}${toOrig.slice(toStart, toEnd)}`;\n// \t\t}\n\n// \t\tif (toOrig.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {\n// \t\t\t++toStart;\n// \t\t}\n\n// \t\treturn toOrig.slice(toStart, toEnd);\n// \t},\n\n// \ttoNamespacedPath(path: string): string {\n// \t\t// Note: this will *probably* throw somewhere.\n// \t\tif (typeof path !== 'string') {\n// \t\t\treturn path;\n// \t\t}\n\n// \t\tif (path.length === 0) {\n// \t\t\treturn '';\n// \t\t}\n\n// \t\tconst resolvedPath = win32.resolve(path);\n\n// \t\tif (resolvedPath.length <= 2) {\n// \t\t\treturn path;\n// \t\t}\n\n// \t\tif (resolvedPath.charCodeAt(0) === CHAR_BACKWARD_SLASH) {\n// \t\t\t// Possible UNC root\n// \t\t\tif (resolvedPath.charCodeAt(1) === CHAR_BACKWARD_SLASH) {\n// \t\t\t\tconst code = resolvedPath.charCodeAt(2);\n// \t\t\t\tif (code !== CHAR_QUESTION_MARK && code !== CHAR_DOT) {\n// \t\t\t\t\t// Matched non-long UNC root, convert the path to a long UNC path\n// \t\t\t\t\treturn `\\\\\\\\?\\\\UNC\\\\${resolvedPath.slice(2)}`;\n// \t\t\t\t}\n// \t\t\t}\n// \t\t} else if (isWindowsDeviceRoot(resolvedPath.charCodeAt(0)) &&\n// \t\t\tresolvedPath.charCodeAt(1) === CHAR_COLON &&\n// \t\t\tresolvedPath.charCodeAt(2) === CHAR_BACKWARD_SLASH) {\n// \t\t\t// Matched device root, convert the path to a long UNC path\n// \t\t\treturn `\\\\\\\\?\\\\${resolvedPath}`;\n// \t\t}\n\n// \t\treturn path;\n// \t},\n\n// \tdirname(path: string): string {\n// \t\tvalidateString(path, 'path');\n// \t\tconst len = path.length;\n// \t\tif (len === 0) {\n// \t\t\treturn '.';\n// \t\t}\n// \t\tlet rootEnd = -1;\n// \t\tlet offset = 0;\n// \t\tconst code = path.charCodeAt(0);\n\n// \t\tif (len === 1) {\n// \t\t\t// `path` contains just a path separator, exit early to avoid\n// \t\t\t// unnecessary work or a dot.\n// \t\t\treturn isPathSeparator(code) ? path : '.';\n// \t\t}\n\n// \t\t// Try to match a root\n// \t\tif (isPathSeparator(code)) {\n// \t\t\t// Possible UNC root\n\n// \t\t\trootEnd = offset = 1;\n\n// \t\t\tif (isPathSeparator(path.charCodeAt(1))) {\n// \t\t\t\t// Matched double path separator at beginning\n// \t\t\t\tlet j = 2;\n// \t\t\t\tlet last = j;\n// \t\t\t\t// Match 1 or more non-path separators\n// \t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n// \t\t\t\t\tj++;\n// \t\t\t\t}\n// \t\t\t\tif (j < len && j !== last) {\n// \t\t\t\t\t// Matched!\n// \t\t\t\t\tlast = j;\n// \t\t\t\t\t// Match 1 or more path separators\n// \t\t\t\t\twhile (j < len && isPathSeparator(path.charCodeAt(j))) {\n// \t\t\t\t\t\tj++;\n// \t\t\t\t\t}\n// \t\t\t\t\tif (j < len && j !== last) {\n// \t\t\t\t\t\t// Matched!\n// \t\t\t\t\t\tlast = j;\n// \t\t\t\t\t\t// Match 1 or more non-path separators\n// \t\t\t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n// \t\t\t\t\t\t\tj++;\n// \t\t\t\t\t\t}\n// \t\t\t\t\t\tif (j === len) {\n// \t\t\t\t\t\t\t// We matched a UNC root only\n// \t\t\t\t\t\t\treturn path;\n// \t\t\t\t\t\t}\n// \t\t\t\t\t\tif (j !== last) {\n// \t\t\t\t\t\t\t// We matched a UNC root with leftovers\n\n// \t\t\t\t\t\t\t// Offset by 1 to include the separator after the UNC root to\n// \t\t\t\t\t\t\t// treat it as a \"normal root\" on top of a (UNC) root\n// \t\t\t\t\t\t\trootEnd = offset = j + 1;\n// \t\t\t\t\t\t}\n// \t\t\t\t\t}\n// \t\t\t\t}\n// \t\t\t}\n// \t\t\t// Possible device root\n// \t\t} else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {\n// \t\t\trootEnd = len > 2 && isPathSeparator(path.charCodeAt(2)) ? 3 : 2;\n// \t\t\toffset = rootEnd;\n// \t\t}\n\n// \t\tlet end = -1;\n// \t\tlet matchedSlash = true;\n// \t\tfor (let i = len - 1; i >= offset; --i) {\n// \t\t\tif (isPathSeparator(path.charCodeAt(i))) {\n// \t\t\t\tif (!matchedSlash) {\n// \t\t\t\t\tend = i;\n// \t\t\t\t\tbreak;\n// \t\t\t\t}\n// \t\t\t} else {\n// \t\t\t\t// We saw the first non-path separator\n// \t\t\t\tmatchedSlash = false;\n// \t\t\t}\n// \t\t}\n\n// \t\tif (end === -1) {\n// \t\t\tif (rootEnd === -1) {\n// \t\t\t\treturn '.';\n// \t\t\t}\n\n// \t\t\tend = rootEnd;\n// \t\t}\n// \t\treturn path.slice(0, end);\n// \t},\n\n// \tbasename(path: string, ext?: string): string {\n// \t\tif (ext !== undefined) {\n// \t\t\tvalidateString(ext, 'ext');\n// \t\t}\n// \t\tvalidateString(path, 'path');\n// \t\tlet start = 0;\n// \t\tlet end = -1;\n// \t\tlet matchedSlash = true;\n// \t\tlet i;\n\n// \t\t// Check for a drive letter prefix so as not to mistake the following\n// \t\t// path separator as an extra separator at the end of the path that can be\n// \t\t// disregarded\n// \t\tif (path.length >= 2 &&\n// \t\t\tisWindowsDeviceRoot(path.charCodeAt(0)) &&\n// \t\t\tpath.charCodeAt(1) === CHAR_COLON) {\n// \t\t\tstart = 2;\n// \t\t}\n\n// \t\tif (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n// \t\t\tif (ext === path) {\n// \t\t\t\treturn '';\n// \t\t\t}\n// \t\t\tlet extIdx = ext.length - 1;\n// \t\t\tlet firstNonSlashEnd = -1;\n// \t\t\tfor (i = path.length - 1; i >= start; --i) {\n// \t\t\t\tconst code = path.charCodeAt(i);\n// \t\t\t\tif (isPathSeparator(code)) {\n// \t\t\t\t\t// If we reached a path separator that was not part of a set of path\n// \t\t\t\t\t// separators at the end of the string, stop now\n// \t\t\t\t\tif (!matchedSlash) {\n// \t\t\t\t\t\tstart = i + 1;\n// \t\t\t\t\t\tbreak;\n// \t\t\t\t\t}\n// \t\t\t\t} else {\n// \t\t\t\t\tif (firstNonSlashEnd === -1) {\n// \t\t\t\t\t\t// We saw the first non-path separator, remember this index in case\n// \t\t\t\t\t\t// we need it if the extension ends up not matching\n// \t\t\t\t\t\tmatchedSlash = false;\n// \t\t\t\t\t\tfirstNonSlashEnd = i + 1;\n// \t\t\t\t\t}\n// \t\t\t\t\tif (extIdx >= 0) {\n// \t\t\t\t\t\t// Try to match the explicit extension\n// \t\t\t\t\t\tif (code === ext.charCodeAt(extIdx)) {\n// \t\t\t\t\t\t\tif (--extIdx === -1) {\n// \t\t\t\t\t\t\t\t// We matched the extension, so mark this as the end of our path\n// \t\t\t\t\t\t\t\t// component\n// \t\t\t\t\t\t\t\tend = i;\n// \t\t\t\t\t\t\t}\n// \t\t\t\t\t\t} else {\n// \t\t\t\t\t\t\t// Extension does not match, so our result is the entire path\n// \t\t\t\t\t\t\t// component\n// \t\t\t\t\t\t\textIdx = -1;\n// \t\t\t\t\t\t\tend = firstNonSlashEnd;\n// \t\t\t\t\t\t}\n// \t\t\t\t\t}\n// \t\t\t\t}\n// \t\t\t}\n\n// \t\t\tif (start === end) {\n// \t\t\t\tend = firstNonSlashEnd;\n// \t\t\t} else if (end === -1) {\n// \t\t\t\tend = path.length;\n// \t\t\t}\n// \t\t\treturn path.slice(start, end);\n// \t\t}\n// \t\tfor (i = path.length - 1; i >= start; --i) {\n// \t\t\tif (isPathSeparator(path.charCodeAt(i))) {\n// \t\t\t\t// If we reached a path separator that was not part of a set of path\n// \t\t\t\t// separators at the end of the string, stop now\n// \t\t\t\tif (!matchedSlash) {\n// \t\t\t\t\tstart = i + 1;\n// \t\t\t\t\tbreak;\n// \t\t\t\t}\n// \t\t\t} else if (end === -1) {\n// \t\t\t\t// We saw the first non-path separator, mark this as the end of our\n// \t\t\t\t// path component\n// \t\t\t\tmatchedSlash = false;\n// \t\t\t\tend = i + 1;\n// \t\t\t}\n// \t\t}\n\n// \t\tif (end === -1) {\n// \t\t\treturn '';\n// \t\t}\n// \t\treturn path.slice(start, end);\n// \t},\n\n// \textname(path: string): string {\n// \t\tvalidateString(path, 'path');\n// \t\tlet start = 0;\n// \t\tlet startDot = -1;\n// \t\tlet startPart = 0;\n// \t\tlet end = -1;\n// \t\tlet matchedSlash = true;\n// \t\t// Track the state of characters (if any) we see before our first dot and\n// \t\t// after any path separator we find\n// \t\tlet preDotState = 0;\n\n// \t\t// Check for a drive letter prefix so as not to mistake the following\n// \t\t// path separator as an extra separator at the end of the path that can be\n// \t\t// disregarded\n\n// \t\tif (path.length >= 2 &&\n// \t\t\tpath.charCodeAt(1) === CHAR_COLON &&\n// \t\t\tisWindowsDeviceRoot(path.charCodeAt(0))) {\n// \t\t\tstart = startPart = 2;\n// \t\t}\n\n// \t\tfor (let i = path.length - 1; i >= start; --i) {\n// \t\t\tconst code = path.charCodeAt(i);\n// \t\t\tif (isPathSeparator(code)) {\n// \t\t\t\t// If we reached a path separator that was not part of a set of path\n// \t\t\t\t// separators at the end of the string, stop now\n// \t\t\t\tif (!matchedSlash) {\n// \t\t\t\t\tstartPart = i + 1;\n// \t\t\t\t\tbreak;\n// \t\t\t\t}\n// \t\t\t\tcontinue;\n// \t\t\t}\n// \t\t\tif (end === -1) {\n// \t\t\t\t// We saw the first non-path separator, mark this as the end of our\n// \t\t\t\t// extension\n// \t\t\t\tmatchedSlash = false;\n// \t\t\t\tend = i + 1;\n// \t\t\t}\n// \t\t\tif (code === CHAR_DOT) {\n// \t\t\t\t// If this is our first dot, mark it as the start of our extension\n// \t\t\t\tif (startDot === -1) {\n// \t\t\t\t\tstartDot = i;\n// \t\t\t\t}\n// \t\t\t\telse if (preDotState !== 1) {\n// \t\t\t\t\tpreDotState = 1;\n// \t\t\t\t}\n// \t\t\t} else if (startDot !== -1) {\n// \t\t\t\t// We saw a non-dot and non-path separator before our dot, so we should\n// \t\t\t\t// have a good chance at having a non-empty extension\n// \t\t\t\tpreDotState = -1;\n// \t\t\t}\n// \t\t}\n\n// \t\tif (startDot === -1 ||\n// \t\t\tend === -1 ||\n// \t\t\t// We saw a non-dot character immediately before the dot\n// \t\t\tpreDotState === 0 ||\n// \t\t\t// The (right-most) trimmed path component is exactly '..'\n// \t\t\t(preDotState === 1 &&\n// \t\t\t\tstartDot === end - 1 &&\n// \t\t\t\tstartDot === startPart + 1)) {\n// \t\t\treturn '';\n// \t\t}\n// \t\treturn path.slice(startDot, end);\n// \t},\n\n// \tformat: _format.bind(null, '\\\\'),\n\n// \tparse(path) {\n// \t\tvalidateString(path, 'path');\n\n// \t\tconst ret = { root: '', dir: '', base: '', ext: '', name: '' };\n// \t\tif (path.length === 0) {\n// \t\t\treturn ret;\n// \t\t}\n\n// \t\tconst len = path.length;\n// \t\tlet rootEnd = 0;\n// \t\tlet code = path.charCodeAt(0);\n\n// \t\tif (len === 1) {\n// \t\t\tif (isPathSeparator(code)) {\n// \t\t\t\t// `path` contains just a path separator, exit early to avoid\n// \t\t\t\t// unnecessary work\n// \t\t\t\tret.root = ret.dir = path;\n// \t\t\t\treturn ret;\n// \t\t\t}\n// \t\t\tret.base = ret.name = path;\n// \t\t\treturn ret;\n// \t\t}\n// \t\t// Try to match a root\n// \t\tif (isPathSeparator(code)) {\n// \t\t\t// Possible UNC root\n\n// \t\t\trootEnd = 1;\n// \t\t\tif (isPathSeparator(path.charCodeAt(1))) {\n// \t\t\t\t// Matched double path separator at beginning\n// \t\t\t\tlet j = 2;\n// \t\t\t\tlet last = j;\n// \t\t\t\t// Match 1 or more non-path separators\n// \t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n// \t\t\t\t\tj++;\n// \t\t\t\t}\n// \t\t\t\tif (j < len && j !== last) {\n// \t\t\t\t\t// Matched!\n// \t\t\t\t\tlast = j;\n// \t\t\t\t\t// Match 1 or more path separators\n// \t\t\t\t\twhile (j < len && isPathSeparator(path.charCodeAt(j))) {\n// \t\t\t\t\t\tj++;\n// \t\t\t\t\t}\n// \t\t\t\t\tif (j < len && j !== last) {\n// \t\t\t\t\t\t// Matched!\n// \t\t\t\t\t\tlast = j;\n// \t\t\t\t\t\t// Match 1 or more non-path separators\n// \t\t\t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n// \t\t\t\t\t\t\tj++;\n// \t\t\t\t\t\t}\n// \t\t\t\t\t\tif (j === len) {\n// \t\t\t\t\t\t\t// We matched a UNC root only\n// \t\t\t\t\t\t\trootEnd = j;\n// \t\t\t\t\t\t} else if (j !== last) {\n// \t\t\t\t\t\t\t// We matched a UNC root with leftovers\n// \t\t\t\t\t\t\trootEnd = j + 1;\n// \t\t\t\t\t\t}\n// \t\t\t\t\t}\n// \t\t\t\t}\n// \t\t\t}\n// \t\t} else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {\n// \t\t\t// Possible device root\n// \t\t\tif (len <= 2) {\n// \t\t\t\t// `path` contains just a drive root, exit early to avoid\n// \t\t\t\t// unnecessary work\n// \t\t\t\tret.root = ret.dir = path;\n// \t\t\t\treturn ret;\n// \t\t\t}\n// \t\t\trootEnd = 2;\n// \t\t\tif (isPathSeparator(path.charCodeAt(2))) {\n// \t\t\t\tif (len === 3) {\n// \t\t\t\t\t// `path` contains just a drive root, exit early to avoid\n// \t\t\t\t\t// unnecessary work\n// \t\t\t\t\tret.root = ret.dir = path;\n// \t\t\t\t\treturn ret;\n// \t\t\t\t}\n// \t\t\t\trootEnd = 3;\n// \t\t\t}\n// \t\t}\n// \t\tif (rootEnd > 0) {\n// \t\t\tret.root = path.slice(0, rootEnd);\n// \t\t}\n\n// \t\tlet startDot = -1;\n// \t\tlet startPart = rootEnd;\n// \t\tlet end = -1;\n// \t\tlet matchedSlash = true;\n// \t\tlet i = path.length - 1;\n\n// \t\t// Track the state of characters (if any) we see before our first dot and\n// \t\t// after any path separator we find\n// \t\tlet preDotState = 0;\n\n// \t\t// Get non-dir info\n// \t\tfor (; i >= rootEnd; --i) {\n// \t\t\tcode = path.charCodeAt(i);\n// \t\t\tif (isPathSeparator(code)) {\n// \t\t\t\t// If we reached a path separator that was not part of a set of path\n// \t\t\t\t// separators at the end of the string, stop now\n// \t\t\t\tif (!matchedSlash) {\n// \t\t\t\t\tstartPart = i + 1;\n// \t\t\t\t\tbreak;\n// \t\t\t\t}\n// \t\t\t\tcontinue;\n// \t\t\t}\n// \t\t\tif (end === -1) {\n// \t\t\t\t// We saw the first non-path separator, mark this as the end of our\n// \t\t\t\t// extension\n// \t\t\t\tmatchedSlash = false;\n// \t\t\t\tend = i + 1;\n// \t\t\t}\n// \t\t\tif (code === CHAR_DOT) {\n// \t\t\t\t// If this is our first dot, mark it as the start of our extension\n// \t\t\t\tif (startDot === -1) {\n// \t\t\t\t\tstartDot = i;\n// \t\t\t\t} else if (preDotState !== 1) {\n// \t\t\t\t\tpreDotState = 1;\n// \t\t\t\t}\n// \t\t\t} else if (startDot !== -1) {\n// \t\t\t\t// We saw a non-dot and non-path separator before our dot, so we should\n// \t\t\t\t// have a good chance at having a non-empty extension\n// \t\t\t\tpreDotState = -1;\n// \t\t\t}\n// \t\t}\n\n// \t\tif (end !== -1) {\n// \t\t\tif (startDot === -1 ||\n// \t\t\t\t// We saw a non-dot character immediately before the dot\n// \t\t\t\tpreDotState === 0 ||\n// \t\t\t\t// The (right-most) trimmed path component is exactly '..'\n// \t\t\t\t(preDotState === 1 &&\n// \t\t\t\t\tstartDot === end - 1 &&\n// \t\t\t\t\tstartDot === startPart + 1)) {\n// \t\t\t\tret.base = ret.name = path.slice(startPart, end);\n// \t\t\t} else {\n// \t\t\t\tret.name = path.slice(startPart, startDot);\n// \t\t\t\tret.base = path.slice(startPart, end);\n// \t\t\t\tret.ext = path.slice(startDot, end);\n// \t\t\t}\n// \t\t}\n\n// \t\t// If the directory is the root, use the entire root as the `dir` including\n// \t\t// the trailing slash if any (`C:\\abc` -> `C:\\`). Otherwise, strip out the\n// \t\t// trailing slash (`C:\\abc\\def` -> `C:\\abc`).\n// \t\tif (startPart > 0 && startPart !== rootEnd) {\n// \t\t\tret.dir = path.slice(0, startPart - 1);\n// \t\t} else {\n// \t\t\tret.dir = ret.root;\n// \t\t}\n\n// \t\treturn ret;\n// \t},\n\n// \tsep: '\\\\',\n// \tdelimiter: ';',\n// \twin32: null,\n// \tposix: null\n// };\n\nexport const posix: IPath = {\n  // path.resolve([from ...], to)\n  resolve(...pathSegments: string[]): string {\n    let resolvedPath = '';\n    let resolvedAbsolute = false;\n\n    for (let i = pathSegments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n      const path = i >= 0 ? pathSegments[i] : process.cwd();\n\n      validateString(path, 'path');\n\n      // Skip empty entries\n      if (path.length === 0) {\n        continue;\n      }\n\n      resolvedPath = `${path}/${resolvedPath}`;\n      resolvedAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n    }\n\n    // At this point the path should be resolved to a full absolute path, but\n    // handle relative paths to be safe (might happen when process.cwd() fails)\n\n    // Normalize the path\n    resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute, '/', isPosixPathSeparator);\n\n    if (resolvedAbsolute) {\n      return `/${resolvedPath}`;\n    }\n    return resolvedPath.length > 0 ? resolvedPath : '.';\n  },\n\n  normalize(path: string): string {\n    validateString(path, 'path');\n\n    if (path.length === 0) {\n      return '.';\n    }\n\n    const isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n    const trailingSeparator = path.charCodeAt(path.length - 1) === CHAR_FORWARD_SLASH;\n\n    // Normalize the path\n    path = normalizeString(path, !isAbsolute, '/', isPosixPathSeparator);\n\n    if (path.length === 0) {\n      if (isAbsolute) {\n        return '/';\n      }\n      return trailingSeparator ? './' : '.';\n    }\n    if (trailingSeparator) {\n      path += '/';\n    }\n\n    return isAbsolute ? `/${path}` : path;\n  },\n\n  isAbsolute(path: string): boolean {\n    validateString(path, 'path');\n    return path.length > 0 && path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n  },\n\n  join(...paths: string[]): string {\n    if (paths.length === 0) {\n      return '.';\n    }\n    let joined;\n    for (let i = 0; i < paths.length; ++i) {\n      const arg = paths[i];\n      validateString(arg, 'path');\n      if (arg.length > 0) {\n        if (joined === undefined) {\n          joined = arg;\n        } else {\n          joined += `/${arg}`;\n        }\n      }\n    }\n    if (joined === undefined) {\n      return '.';\n    }\n    return posix.normalize(joined);\n  },\n\n  relative(from: string, to: string): string {\n    validateString(from, 'from');\n    validateString(to, 'to');\n\n    if (from === to) {\n      return '';\n    }\n\n    // Trim leading forward slashes.\n    from = posix.resolve(from);\n    to = posix.resolve(to);\n\n    if (from === to) {\n      return '';\n    }\n\n    const fromStart = 1;\n    const fromEnd = from.length;\n    const fromLen = fromEnd - fromStart;\n    const toStart = 1;\n    const toLen = to.length - toStart;\n\n    // Compare paths to find the longest common path from root\n    const length = fromLen < toLen ? fromLen : toLen;\n    let lastCommonSep = -1;\n    let i = 0;\n    for (; i < length; i++) {\n      const fromCode = from.charCodeAt(fromStart + i);\n      if (fromCode !== to.charCodeAt(toStart + i)) {\n        break;\n      } else if (fromCode === CHAR_FORWARD_SLASH) {\n        lastCommonSep = i;\n      }\n    }\n    if (i === length) {\n      if (toLen > length) {\n        if (to.charCodeAt(toStart + i) === CHAR_FORWARD_SLASH) {\n          // We get here if `from` is the exact base path for `to`.\n          // For example: from='/foo/bar'; to='/foo/bar/baz'\n          return to.slice(toStart + i + 1);\n        }\n        if (i === 0) {\n          // We get here if `from` is the root\n          // For example: from='/'; to='/foo'\n          return to.slice(toStart + i);\n        }\n      } else if (fromLen > length) {\n        if (from.charCodeAt(fromStart + i) === CHAR_FORWARD_SLASH) {\n          // We get here if `to` is the exact base path for `from`.\n          // For example: from='/foo/bar/baz'; to='/foo/bar'\n          lastCommonSep = i;\n        } else if (i === 0) {\n          // We get here if `to` is the root.\n          // For example: from='/foo/bar'; to='/'\n          lastCommonSep = 0;\n        }\n      }\n    }\n\n    let out = '';\n    // Generate the relative path based on the path difference between `to`\n    // and `from`.\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n      if (i === fromEnd || from.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n        out += out.length === 0 ? '..' : '/..';\n      }\n    }\n\n    // Lastly, append the rest of the destination (`to`) path that comes after\n    // the common path parts.\n    return `${out}${to.slice(toStart + lastCommonSep)}`;\n  },\n\n  toNamespacedPath(path: string): string {\n    // Non-op on posix systems\n    return path;\n  },\n\n  dirname(path: string): string {\n    validateString(path, 'path');\n    if (path.length === 0) {\n      return '.';\n    }\n    const hasRoot = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n    let end = -1;\n    let matchedSlash = true;\n    for (let i = path.length - 1; i >= 1; --i) {\n      if (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n        if (!matchedSlash) {\n          end = i;\n          break;\n        }\n      } else {\n        // We saw the first non-path separator\n        matchedSlash = false;\n      }\n    }\n\n    if (end === -1) {\n      return hasRoot ? '/' : '.';\n    }\n    if (hasRoot && end === 1) {\n      return '//';\n    }\n    return path.slice(0, end);\n  },\n\n  basename(path: string, ext?: string): string {\n    if (ext !== undefined) {\n      validateString(ext, 'ext');\n    }\n    validateString(path, 'path');\n\n    let start = 0;\n    let end = -1;\n    let matchedSlash = true;\n    let i;\n\n    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n      if (ext === path) {\n        return '';\n      }\n      let extIdx = ext.length - 1;\n      let firstNonSlashEnd = -1;\n      for (i = path.length - 1; i >= 0; --i) {\n        const code = path.charCodeAt(i);\n        if (code === CHAR_FORWARD_SLASH) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            start = i + 1;\n            break;\n          }\n        } else {\n          if (firstNonSlashEnd === -1) {\n            // We saw the first non-path separator, remember this index in case\n            // we need it if the extension ends up not matching\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            // Try to match the explicit extension\n            if (code === ext.charCodeAt(extIdx)) {\n              if (--extIdx === -1) {\n                // We matched the extension, so mark this as the end of our path\n                // component\n                end = i;\n              }\n            } else {\n              // Extension does not match, so our result is the entire path\n              // component\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n\n      if (start === end) {\n        end = firstNonSlashEnd;\n      } else if (end === -1) {\n        end = path.length;\n      }\n      return path.slice(start, end);\n    }\n    for (i = path.length - 1; i >= 0; --i) {\n      if (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          start = i + 1;\n          break;\n        }\n      } else if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // path component\n        matchedSlash = false;\n        end = i + 1;\n      }\n    }\n\n    if (end === -1) {\n      return '';\n    }\n    return path.slice(start, end);\n  },\n\n  extname(path: string): string {\n    validateString(path, 'path');\n    let startDot = -1;\n    let startPart = 0;\n    let end = -1;\n    let matchedSlash = true;\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    let preDotState = 0;\n    for (let i = path.length - 1; i >= 0; --i) {\n      const code = path.charCodeAt(i);\n      if (code === CHAR_FORWARD_SLASH) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === CHAR_DOT) {\n        // If this is our first dot, mark it as the start of our extension\n        if (startDot === -1) {\n          startDot = i;\n        } else if (preDotState !== 1) {\n          preDotState = 1;\n        }\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (\n      startDot === -1 ||\n      end === -1 ||\n      // We saw a non-dot character immediately before the dot\n      preDotState === 0 ||\n      // The (right-most) trimmed path component is exactly '..'\n      (preDotState === 1 && startDot === end - 1 && startDot === startPart + 1)\n    ) {\n      return '';\n    }\n    return path.slice(startDot, end);\n  },\n\n  format: _format.bind(null, '/'),\n\n  parse(path: string): ParsedPath {\n    validateString(path, 'path');\n\n    const ret = { root: '', dir: '', base: '', ext: '', name: '' };\n    if (path.length === 0) {\n      return ret;\n    }\n    const isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n    let start;\n    if (isAbsolute) {\n      ret.root = '/';\n      start = 1;\n    } else {\n      start = 0;\n    }\n    let startDot = -1;\n    let startPart = 0;\n    let end = -1;\n    let matchedSlash = true;\n    let i = path.length - 1;\n\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    let preDotState = 0;\n\n    // Get non-dir info\n    for (; i >= start; --i) {\n      const code = path.charCodeAt(i);\n      if (code === CHAR_FORWARD_SLASH) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === CHAR_DOT) {\n        // If this is our first dot, mark it as the start of our extension\n        if (startDot === -1) {\n          startDot = i;\n        } else if (preDotState !== 1) {\n          preDotState = 1;\n        }\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (end !== -1) {\n      const start = startPart === 0 && isAbsolute ? 1 : startPart;\n      if (\n        startDot === -1 ||\n        // We saw a non-dot character immediately before the dot\n        preDotState === 0 ||\n        // The (right-most) trimmed path component is exactly '..'\n        (preDotState === 1 && startDot === end - 1 && startDot === startPart + 1)\n      ) {\n        ret.base = ret.name = path.slice(start, end);\n      } else {\n        ret.name = path.slice(start, startDot);\n        ret.base = path.slice(start, end);\n        ret.ext = path.slice(startDot, end);\n      }\n    }\n\n    if (startPart > 0) {\n      ret.dir = path.slice(0, startPart - 1);\n    } else if (isAbsolute) {\n      ret.dir = '/';\n    }\n\n    return ret;\n  },\n\n  sep: '/',\n  delimiter: ':',\n  win32: null,\n  posix: null,\n};\n\nexport const normalize = posix.normalize;\nexport const isAbsolute = posix.isAbsolute;\nexport const join = posix.join;\nexport const resolve = posix.resolve;\nexport const relative = posix.relative;\nexport const dirname = posix.dirname;\nexport const basename = posix.basename;\nexport const extname = posix.extname;\nexport const format = posix.format;\nexport const parse = posix.parse;\nexport const toNamespacedPath = posix.toNamespacedPath;\nexport const sep = posix.sep;\nexport const delimiter = posix.delimiter;\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from './charCode';\nimport { join } from './path';\n\nconst _schemePattern = /^\\w[\\w\\d+.-]*$/;\nconst _singleSlashStart = /^\\//;\nconst _doubleSlashStart = /^\\/\\//;\n\nfunction _validateUri(ret: Uri, _strict?: boolean): void {\n  // scheme, must be set\n  if (!ret.scheme && _strict) {\n    throw new Error(\n      `[UriError]: Scheme is missing: {scheme: \"\", authority: \"${ret.authority}\", path: \"${ret.path}\", query: \"${ret.query}\", fragment: \"${ret.fragment}\"}`\n    );\n  }\n\n  // scheme, https://tools.ietf.org/html/rfc3986#section-3.1\n  // ALPHA *( ALPHA / DIGIT / \"+\" / \"-\" / \".\" )\n  if (ret.scheme && !_schemePattern.test(ret.scheme)) {\n    throw new Error('[UriError]: Scheme contains illegal characters.');\n  }\n\n  // path, http://tools.ietf.org/html/rfc3986#section-3.3\n  // If a URI contains an authority component, then the path component\n  // must either be empty or begin with a slash (\"/\") character.  If a URI\n  // does not contain an authority component, then the path cannot begin\n  // with two slash characters (\"//\").\n  if (ret.path) {\n    if (ret.authority) {\n      if (!_singleSlashStart.test(ret.path)) {\n        throw new Error(\n          '[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash (\"/\") character'\n        );\n      }\n    } else {\n      if (_doubleSlashStart.test(ret.path)) {\n        throw new Error(\n          '[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters (\"//\")'\n        );\n      }\n    }\n  }\n}\n\n// for a while we allowed uris *without* schemes and this is the migration\n// for them, e.g. an uri without scheme and without strict-mode warns and falls\n// back to the file-scheme. that should cause the least carnage and still be a\n// clear warning\nfunction _schemeFix(scheme: string, _strict: boolean): string {\n  if (!scheme && !_strict) {\n    return 'file';\n  }\n  return scheme;\n}\n\n// implements a bit of https://tools.ietf.org/html/rfc3986#section-5\nfunction _referenceResolution(scheme: string, path: string): string {\n  // the slash-character is our 'default base' as we don't\n  // support constructing URIs relative to other URIs. This\n  // see https://tools.ietf.org/html/rfc3986#section-5.1.4\n  switch (scheme) {\n    case 'https':\n    case 'http':\n    case 'file':\n      if (!path) {\n        path = _slash;\n      } else if (path[0] !== _slash) {\n        path = _slash + path;\n      }\n      break;\n  }\n  return path;\n}\n\nconst _empty = '';\nconst _slash = '/';\nconst _regexp = /^(([^:/?#]+?):)?(\\/\\/([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?/;\n\n/**\n * Uniform Resource Identifier (URI) http://tools.ietf.org/html/rfc3986.\n * This class is a simple parser which creates the basic component parts\n * (http://tools.ietf.org/html/rfc3986#section-3) with minimal validation\n * and encoding.\n *\n * ```txt\n *       foo://example.com:8042/over/there?name=ferret#nose\n *       \\_/   \\______________/\\_________/ \\_________/ \\__/\n *        |           |            |            |        |\n *     scheme     authority       path        query   fragment\n *        |   _____________________|__\n *       / \\ /                        \\\n *       urn:example:animal:ferret:nose\n * ```\n */\nexport class Uri implements UriComponents {\n  static ensureTrailingSlash(uri: Uri, trailingSlash = '/') {\n    return uri.with({\n      path: uri.path.replace(TRAILING_SLASH_RX, trailingSlash),\n    });\n  }\n\n  static equals(l: Uri, r: Uri) {\n    return (\n      l.authority === r.authority &&\n      l.fragment === r.fragment &&\n      l.path === r.path &&\n      l.query === r.query &&\n      l.scheme === r.scheme\n    );\n  }\n\n  static getFirstPathSegmentAfterPrefix(child: Uri, parent: Uri): string {\n    const childHref = child.path;\n    const parentHref = parent.path;\n    const parentOffset = parentHref.charAt(parentHref.length - 1) === '/' ? -1 : 0;\n\n    for (let i = 0; i <= childHref.length; i++) {\n      if (i < parentHref.length) {\n        if (childHref.charAt(i) !== parentHref.charAt(i)) {\n          throw new Error(\n            `The child entry ${child.toString()} does not have the pathname of ${parent.toString()} as a prefix`\n          );\n        }\n      } else if (i === parentHref.length + parentOffset) {\n        if (childHref.charAt(i) !== '/') {\n          throw new Error(\n            `The child entry ${child.toString()} does not have the pathname of ${parent.toString()} as a prefix`\n          );\n        }\n      } else if (childHref.charAt(i) === '/') {\n        return childHref.slice(parentHref.length + 1 + parentOffset, i);\n      }\n    }\n\n    return childHref.slice(parentHref.length + 1 + parentOffset);\n  }\n\n  static isPrefixOf(prefix: Uri, uri: Uri) {\n    return (\n      prefix.authority === uri.authority &&\n      prefix.fragment === uri.fragment &&\n      prefix.query === uri.query &&\n      prefix.scheme === uri.scheme &&\n      uri.path.startsWith(prefix.path)\n    );\n  }\n\n  static isUri(thing: any): thing is Uri {\n    if (thing instanceof Uri) {\n      return true;\n    }\n    if (!thing) {\n      return false;\n    }\n    return (\n      typeof (<Uri>thing).authority === 'string' &&\n      typeof (<Uri>thing).fragment === 'string' &&\n      typeof (<Uri>thing).path === 'string' &&\n      typeof (<Uri>thing).query === 'string' &&\n      typeof (<Uri>thing).scheme === 'string' &&\n      typeof (<Uri>thing).fsPath === 'function' &&\n      typeof (<Uri>thing).with === 'function' &&\n      typeof (<Uri>thing).toString === 'function'\n    );\n  }\n\n  /**\n   * scheme is the 'http' part of 'http://www.msft.com/some/path?query#fragment'.\n   * The part before the first colon.\n   */\n  readonly scheme: string;\n\n  /**\n   * authority is the 'www.msft.com' part of 'http://www.msft.com/some/path?query#fragment'.\n   * The part between the first double slashes and the next slash.\n   */\n  readonly authority: string;\n\n  /**\n   * path is the '/some/path' part of 'http://www.msft.com/some/path?query#fragment'.\n   */\n  readonly path: string;\n\n  /**\n   * query is the 'query' part of 'http://www.msft.com/some/path?query#fragment'.\n   */\n  readonly query: string;\n\n  /**\n   * fragment is the 'fragment' part of 'http://www.msft.com/some/path?query#fragment'.\n   */\n  readonly fragment: string;\n\n  /**\n   * @internal\n   */\n  protected constructor(\n    scheme: string,\n    authority?: string,\n    path?: string,\n    query?: string,\n    fragment?: string,\n    _strict?: boolean\n  );\n\n  /**\n   * @internal\n   */\n  protected constructor(components: UriComponents);\n\n  /**\n   * @internal\n   */\n  protected constructor(\n    schemeOrData: string | UriComponents,\n    authority?: string,\n    path?: string,\n    query?: string,\n    fragment?: string,\n    _strict: boolean = false\n  ) {\n    if (typeof schemeOrData === 'object') {\n      this.scheme = schemeOrData.scheme || _empty;\n      this.authority = schemeOrData.authority || _empty;\n      this.path = schemeOrData.path || _empty;\n      this.query = schemeOrData.query || _empty;\n      this.fragment = schemeOrData.fragment || _empty;\n      // no validation because it's this URI\n      // that creates uri components.\n      // _validateUri(this);\n    } else {\n      this.scheme = _schemeFix(schemeOrData, _strict);\n      this.authority = authority || _empty;\n      this.path = _referenceResolution(this.scheme, path || _empty);\n      this.query = query || _empty;\n      this.fragment = fragment || _empty;\n\n      _validateUri(this, _strict);\n    }\n  }\n\n  // ---- filesystem path -----------------------\n\n  /**\n\t * Returns a string representing the corresponding file system path of this URI.\n\t * platform specific path separator.\n\t *\n\t * * Will *not* validate the path for invalid characters and semantics.\n\t * * Will *not* look at the scheme of this URI.\n\t * * The result shall *not* be used for display purposes but for accessing a file on disk.\n\t *\n\t *\n\t * The *difference* to `URI#path` is the use of the platform specific separator and the handling\n\t *\n\t * ```ts\n\t\tconst u = URI.parse('file://server/c$/folder/file.txt')\n\t\tu.authority === 'server'\n\t\tu.path === '/shares/c$/file.txt'\n\t\tu.fsPath === '\\\\server\\c$\\folder\\file.txt'\n\t```\n\t *\n\t * Using `URI#path` to read a file (using fs-apis) would not be enough because parts of the path,\n\t * namely the server name, would be missing. Therefore `URI#fsPath` exists - it's sugar to ease working\n\t * with URIs that represent files on disk (`file` scheme).\n\t */\n  get fsPath(): string {\n    // if (this.scheme !== 'file') {\n    // \tconsole.warn(`[UriError] calling fsPath with scheme ${this.scheme}`);\n    // }\n    return uriToFsPath(this, false);\n  }\n\n  // ---- modify to new -------------------------\n\n  with(change: {\n    scheme?: string;\n    authority?: string | null;\n    path?: string | null;\n    query?: string | null;\n    fragment?: string | null;\n  }): Uri {\n    if (!change) {\n      return this;\n    }\n\n    let { scheme, authority, path, query, fragment } = change;\n    if (scheme === undefined) {\n      scheme = this.scheme;\n    } else if (scheme === null) {\n      scheme = _empty;\n    }\n    if (authority === undefined) {\n      authority = this.authority;\n    } else if (authority === null) {\n      authority = _empty;\n    }\n    if (path === undefined) {\n      path = this.path;\n    } else if (path === null) {\n      path = _empty;\n    }\n    if (query === undefined) {\n      query = this.query;\n    } else if (query === null) {\n      query = _empty;\n    }\n    if (fragment === undefined) {\n      fragment = this.fragment;\n    } else if (fragment === null) {\n      fragment = _empty;\n    }\n\n    if (\n      scheme === this.scheme &&\n      authority === this.authority &&\n      path === this.path &&\n      query === this.query &&\n      fragment === this.fragment\n    ) {\n      return this;\n    }\n\n    return new _URI(scheme, authority, path, query, fragment);\n  }\n\n  // ---- parse & validate ------------------------\n\n  /**\n   * Creates a new URI from a string, e.g. `http://www.msft.com/some/path`,\n   * `file:///usr/home`, or `scheme:with/path`.\n   *\n   * @param value A string which represents an URI (see `URI#toString`).\n   */\n  static parse(value: string, _strict: boolean = false): Uri {\n    const match = _regexp.exec(value);\n    if (!match) {\n      return new _URI(_empty, _empty, _empty, _empty, _empty);\n    }\n    return new _URI(\n      match[2] || _empty,\n      percentDecode(match[4] || _empty),\n      percentDecode(match[5] || _empty),\n      percentDecode(match[7] || _empty),\n      percentDecode(match[9] || _empty),\n      _strict\n    );\n  }\n\n  /**\n\t * Creates a new URI from a file system path, e.g. `c:\\my\\files`,\n\t * `/usr/home`, or `\\\\server\\share\\some\\path`.\n\t *\n\t * The *difference* between `URI#parse` and `URI#file` is that the latter treats the argument\n\t * as path, not as stringified-uri. E.g. `URI.file(path)` is **not the same as**\n\t * `URI.parse('file://' + path)` because the path might contain characters that are\n\t * interpreted (# and ?). See the following sample:\n\t * ```ts\n\tconst good = URI.file('/coding/c#/project1');\n\tgood.scheme === 'file';\n\tgood.path === '/coding/c#/project1';\n\tgood.fragment === '';\n\tconst bad = URI.parse('file://' + '/coding/c#/project1');\n\tbad.scheme === 'file';\n\tbad.path === '/coding/c'; // path is now broken\n\tbad.fragment === '/project1';\n\t```\n\t *\n\t * @param path A file system path (see `URI#fsPath`)\n\t */\n  static file(path: string): Uri {\n    let authority = _empty;\n\n    // check for authority as used in UNC shares\n    // or use the path as given\n    if (path[0] === _slash && path[1] === _slash) {\n      const idx = path.indexOf(_slash, 2);\n      if (idx === -1) {\n        authority = path.substring(2);\n        path = _slash;\n      } else {\n        authority = path.substring(2, idx);\n        path = path.substring(idx) || _slash;\n      }\n    }\n\n    return new _URI('file', authority, path, _empty, _empty);\n  }\n\n  static from(components: {\n    scheme: string;\n    authority?: string;\n    path?: string;\n    query?: string;\n    fragment?: string;\n  }): Uri {\n    return new _URI(\n      components.scheme,\n      components.authority,\n      components.path,\n      components.query,\n      components.fragment\n    );\n  }\n\n  /**\n   * Join a URI path with path fragments and normalizes the resulting path.\n   *\n   * @param uri The input URI.\n   * @param pathFragment The path fragment to add to the URI path.\n   * @returns The resulting URI.\n   */\n  static joinPath(uri: Uri, ...pathFragment: string[]): Uri {\n    if (!uri.path) {\n      throw new Error(`[UriError]: cannot call joinPaths on URI without path`);\n    }\n    const newPath = join(uri.path, ...pathFragment);\n    return uri.with({ path: newPath });\n  }\n\n  // ---- printing/externalize ---------------------------\n\n  /**\n   * Creates a string representation for this URI. It's guaranteed that calling\n   * `URI.parse` with the result of this function creates an URI which is equal\n   * to this URI.\n   *\n   * * The result shall *not* be used for display purposes but for externalization or transport.\n   * * The result will be encoded using the percentage encoding and encoding happens mostly\n   * ignore the scheme-specific encoding rules.\n   *\n   * @param skipEncoding Do not encode the result, default is `false`\n   */\n  toString(skipEncoding: boolean = true): string {\n    return _asFormatted(this, skipEncoding);\n  }\n\n  toJSON(): UriComponents {\n    return this;\n  }\n\n  static revive(data: UriComponents | Uri): Uri;\n  static revive(data: UriComponents | Uri | undefined): Uri | undefined;\n  static revive(data: UriComponents | Uri | null): Uri | null;\n  static revive(data: UriComponents | Uri | undefined | null): Uri | undefined | null;\n  static revive(data: UriComponents | Uri | undefined | null): Uri | undefined | null {\n    if (!data) {\n      return data;\n    } else if (data instanceof Uri) {\n      return data;\n    } else {\n      const result = new _URI(data);\n      result._formatted = (<UriState>data).external;\n      result._fsPath = (<UriState>data)._sep === _pathSepMarker ? (<UriState>data).fsPath : null;\n      return result;\n    }\n  }\n}\n\nexport interface UriComponents {\n  scheme: string;\n  authority: string;\n  path: string;\n  query: string;\n  fragment: string;\n}\n\ninterface UriState extends UriComponents {\n  $mid: number;\n  external: string;\n  fsPath: string;\n  _sep: 1 | undefined;\n}\n\nconst _pathSepMarker = undefined;\n\n// eslint-disable-next-line @typescript-eslint/naming-convention\nclass _URI extends Uri {\n  _formatted: string | null = null;\n  _fsPath: string | null = null;\n\n  get fsPath(): string {\n    if (!this._fsPath) {\n      this._fsPath = uriToFsPath(this, false);\n    }\n    return this._fsPath;\n  }\n\n  toString(skipEncoding: boolean = true): string {\n    if (!skipEncoding) {\n      // we don't cache that\n      return _asFormatted(this, false);\n    } else {\n      if (!this._formatted) {\n        this._formatted = _asFormatted(this, true);\n      }\n      return this._formatted;\n    }\n  }\n\n  toJSON(): UriComponents {\n    const res = <UriState>{\n      $mid: 1,\n    };\n    // cached state\n    if (this._fsPath) {\n      res.fsPath = this._fsPath;\n      res._sep = _pathSepMarker;\n    }\n    if (this._formatted) {\n      res.external = this._formatted;\n    }\n    // uri components\n    if (this.path) {\n      res.path = this.path;\n    }\n    if (this.scheme) {\n      res.scheme = this.scheme;\n    }\n    if (this.authority) {\n      res.authority = this.authority;\n    }\n    if (this.query) {\n      res.query = this.query;\n    }\n    if (this.fragment) {\n      res.fragment = this.fragment;\n    }\n    return res;\n  }\n}\n\n// reserved characters: https://tools.ietf.org/html/rfc3986#section-2.2\nconst encodeTable: { [ch: number]: string } = {\n  [CharCode.Colon]: '%3A', // gen-delims\n  [CharCode.Slash]: '%2F',\n  [CharCode.QuestionMark]: '%3F',\n  [CharCode.Hash]: '%23',\n  [CharCode.OpenSquareBracket]: '%5B',\n  [CharCode.CloseSquareBracket]: '%5D',\n  [CharCode.AtSign]: '%40',\n\n  [CharCode.ExclamationMark]: '%21', // sub-delims\n  [CharCode.DollarSign]: '%24',\n  [CharCode.Ampersand]: '%26',\n  [CharCode.SingleQuote]: '%27',\n  [CharCode.OpenParen]: '%28',\n  [CharCode.CloseParen]: '%29',\n  [CharCode.Asterisk]: '%2A',\n  [CharCode.Plus]: '%2B',\n  [CharCode.Comma]: '%2C',\n  [CharCode.Semicolon]: '%3B',\n  [CharCode.Equals]: '%3D',\n\n  [CharCode.Space]: '%20',\n};\n\nfunction encodeURIComponentFast(uriComponent: string, allowSlash: boolean): string {\n  let res: string | undefined = undefined;\n  let nativeEncodePos = -1;\n\n  for (let pos = 0; pos < uriComponent.length; pos++) {\n    const code = uriComponent.charCodeAt(pos);\n\n    // unreserved characters: https://tools.ietf.org/html/rfc3986#section-2.3\n    if (\n      (code >= CharCode.a && code <= CharCode.z) ||\n      (code >= CharCode.A && code <= CharCode.Z) ||\n      (code >= CharCode.Digit0 && code <= CharCode.Digit9) ||\n      code === CharCode.Dash ||\n      code === CharCode.Period ||\n      code === CharCode.Underline ||\n      code === CharCode.Tilde ||\n      (allowSlash && code === CharCode.Slash)\n    ) {\n      // check if we are delaying native encode\n      if (nativeEncodePos !== -1) {\n        res += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));\n        nativeEncodePos = -1;\n      }\n      // check if we write into a new string (by default we try to return the param)\n      if (res !== undefined) {\n        res += uriComponent.charAt(pos);\n      }\n    } else {\n      // encoding needed, we need to allocate a new string\n      if (res === undefined) {\n        res = uriComponent.substr(0, pos);\n      }\n\n      // check with default table first\n      const escaped = encodeTable[code];\n      if (escaped !== undefined) {\n        // check if we are delaying native encode\n        if (nativeEncodePos !== -1) {\n          res += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));\n          nativeEncodePos = -1;\n        }\n\n        // append escaped variant to result\n        res += escaped;\n      } else if (nativeEncodePos === -1) {\n        // use native encode only when needed\n        nativeEncodePos = pos;\n      }\n    }\n  }\n\n  if (nativeEncodePos !== -1) {\n    res += encodeURIComponent(uriComponent.substring(nativeEncodePos));\n  }\n\n  return res !== undefined ? res : uriComponent;\n}\n\nfunction encodeURIComponentMinimal(path: string): string {\n  let res: string | undefined = undefined;\n  for (let pos = 0; pos < path.length; pos++) {\n    const code = path.charCodeAt(pos);\n    if (code === CharCode.Hash || code === CharCode.QuestionMark) {\n      if (res === undefined) {\n        res = path.substr(0, pos);\n      }\n      res += encodeTable[code];\n    } else {\n      if (res !== undefined) {\n        res += path[pos];\n      }\n    }\n  }\n  return res !== undefined ? res : path;\n}\n\n/**\n * Compute `fsPath` for the given uri\n */\nexport function uriToFsPath(uri: Uri, keepDriveLetterCasing: boolean): string {\n  let value: string;\n  if (uri.authority && uri.path.length > 1 && uri.scheme === 'file') {\n    // unc path: file://shares/c$/far/boo\n    value = `//${uri.authority}${uri.path}`;\n  } else if (\n    uri.path.charCodeAt(0) === CharCode.Slash &&\n    ((uri.path.charCodeAt(1) >= CharCode.A && uri.path.charCodeAt(1) <= CharCode.Z) ||\n      (uri.path.charCodeAt(1) >= CharCode.a && uri.path.charCodeAt(1) <= CharCode.z)) &&\n    uri.path.charCodeAt(2) === CharCode.Colon\n  ) {\n    if (!keepDriveLetterCasing) {\n      // windows drive letter: file:///c:/far/boo\n      value = uri.path[1].toLowerCase() + uri.path.substr(2);\n    } else {\n      value = uri.path.substr(1);\n    }\n  } else {\n    // other path\n    value = uri.path;\n  }\n  return value;\n}\n\n/**\n * Create the external version of a uri\n */\nfunction _asFormatted(uri: Uri, skipEncoding: boolean): string {\n  const encoder = !skipEncoding ? encodeURIComponentFast : encodeURIComponentMinimal;\n\n  let res = '';\n  let { scheme, authority, path, query, fragment } = uri;\n  if (scheme) {\n    res += scheme;\n    res += ':';\n  }\n  if (authority || scheme === 'file') {\n    res += _slash;\n    res += _slash;\n  }\n  if (authority) {\n    let idx = authority.indexOf('@');\n    if (idx !== -1) {\n      // <user>@<auth>\n      const userinfo = authority.substr(0, idx);\n      authority = authority.substr(idx + 1);\n      idx = userinfo.indexOf(':');\n      if (idx === -1) {\n        res += encoder(userinfo, false);\n      } else {\n        // <user>:<pass>@<auth>\n        res += encoder(userinfo.substr(0, idx), false);\n        res += ':';\n        res += encoder(userinfo.substr(idx + 1), false);\n      }\n      res += '@';\n    }\n    authority = authority.toLowerCase();\n    idx = authority.indexOf(':');\n    if (idx === -1) {\n      res += encoder(authority, false);\n    } else {\n      // <auth>:<port>\n      res += encoder(authority.substr(0, idx), false);\n      res += authority.substr(idx);\n    }\n  }\n  if (path) {\n    // lower-case windows drive letters in /C:/fff or C:/fff\n    if (\n      path.length >= 3 &&\n      path.charCodeAt(0) === CharCode.Slash &&\n      path.charCodeAt(2) === CharCode.Colon\n    ) {\n      const code = path.charCodeAt(1);\n      if (code >= CharCode.A && code <= CharCode.Z) {\n        path = `/${String.fromCharCode(code + 32)}:${path.substr(3)}`; // \"/c:\".length === 3\n      }\n    } else if (path.length >= 2 && path.charCodeAt(1) === CharCode.Colon) {\n      const code = path.charCodeAt(0);\n      if (code >= CharCode.A && code <= CharCode.Z) {\n        path = `${String.fromCharCode(code + 32)}:${path.substr(2)}`; // \"/c:\".length === 3\n      }\n    }\n    // encode the rest of the path\n    res += encoder(path, true);\n  }\n  if (query) {\n    res += '?';\n    res += encoder(query, false);\n  }\n  if (fragment) {\n    res += '#';\n    res += !skipEncoding ? encodeURIComponentFast(fragment, false) : fragment;\n  }\n  return res;\n}\n\n// --- decode\n\nfunction decodeURIComponentGraceful(str: string): string {\n  try {\n    return decodeURIComponent(str);\n  } catch {\n    if (str.length > 3) {\n      return str.substr(0, 3) + decodeURIComponentGraceful(str.substr(3));\n    } else {\n      return str;\n    }\n  }\n}\n\nconst _rEncodedAsHex = /(%[0-9A-Za-z][0-9A-Za-z])+/g;\n\nfunction percentDecode(str: string): string {\n  if (!str.match(_rEncodedAsHex)) {\n    return str;\n  }\n  return str.replace(_rEncodedAsHex, (match) => decodeURIComponentGraceful(match));\n}\n\nconst TRAILING_SLASH_RX = /\\/?$/;\n","import { Uri } from '@velcro/common';\nimport {\n  AbstractResolverStrategyWithRoot,\n  ResolverContext,\n  ResolverStrategy,\n} from '@velcro/resolver';\n\ninterface DirectoryEntry {\n  type: ResolverStrategy.EntryKind.Directory;\n  children: Record<string, Entry>;\n}\n\nenum FileEncoding {\n  Base64 = 'base64',\n  UTF8 = 'utf-8',\n}\n\ninterface FileEntry {\n  type: ResolverStrategy.EntryKind.File;\n  content: string;\n  encoding: FileEncoding;\n}\n\ninterface FileInputWithEncoding {\n  encoding: FileEncoding;\n  content: string;\n}\n\ntype Entry = DirectoryEntry | FileEntry;\ntype FileInput = string | FileInputWithEncoding;\n\nconst encodeText =\n  typeof TextEncoder === 'function'\n    ? (function () {\n        const encoder = new TextEncoder();\n\n        return function encodeText(data: string): ArrayBuffer {\n          return encoder.encode(data).buffer;\n        };\n      })()\n    : typeof Buffer === 'function'\n    ? function encodeText(data: string): ArrayBuffer {\n        return Buffer.from(data);\n      }\n    : function encodeText(_data: string): ArrayBuffer {\n        throw new Error(\n          'The environment provides neither TextEncoder nor Buffer. Please consider polyfilling one of these APIs.'\n        );\n      };\n\nexport class MemoryStrategy extends AbstractResolverStrategyWithRoot {\n  private readonly root: DirectoryEntry = {\n    type: ResolverStrategy.EntryKind.Directory,\n    children: {},\n  };\n\n  constructor(files: Record<string, FileInput>, rootUri = Uri.parse('memory:/')) {\n    super(Uri.ensureTrailingSlash(rootUri));\n\n    for (const pathname in files) {\n      const file = files[pathname];\n\n      if (typeof file === 'string') {\n        this.addFile(pathname, file);\n      } else {\n        this.addFile(pathname, file.content, { encoding: file.encoding });\n      }\n    }\n  }\n\n  getEntryAtPath(pathname: string) {\n    const segments = Array.isArray(pathname)\n      ? pathname.slice()\n      : pathname.split('/').filter(Boolean);\n\n    let parent: Entry = this.root;\n\n    for (const segment of segments) {\n      if (!parent || parent.type !== ResolverStrategy.EntryKind.Directory) {\n        throw new Error(`Failed to add ${pathname}`);\n      }\n\n      parent = parent.children[segment];\n    }\n\n    return parent;\n  }\n\n  addFile(\n    pathname: string,\n    content: string,\n    {\n      encoding = FileEncoding.UTF8,\n      overwrite = false,\n    }: { encoding?: FileEncoding; overwrite?: boolean } = {}\n  ) {\n    const segments = pathname.split('/').filter(Boolean);\n    const filename = segments.pop();\n\n    if (!filename) {\n      throw new Error(`Unable to add a file without a filename '${pathname}'`);\n    }\n\n    let parent: Entry = this.root;\n\n    for (const segment of segments) {\n      if (!parent || parent.type !== ResolverStrategy.EntryKind.Directory) {\n        throw new Error(`Failed to add ${pathname}`);\n      }\n\n      let dir: Entry = parent.children[segment];\n\n      if (!dir) {\n        dir = {\n          type: ResolverStrategy.EntryKind.Directory,\n          children: {},\n        };\n\n        parent.children[segment] = dir;\n      }\n\n      parent = dir;\n    }\n\n    if (parent.type !== ResolverStrategy.EntryKind.Directory) {\n      throw new Error(`Cannot add file to a non directory entry ${pathname}`);\n    }\n\n    if (parent.children[filename] && !overwrite) {\n      throw new Error(`Entry already exists at ${pathname}`);\n    }\n\n    const entry: FileEntry = {\n      type: ResolverStrategy.EntryKind.File,\n      content,\n      encoding,\n    };\n\n    parent.children[filename] = entry;\n\n    return entry;\n  }\n\n  removeFile(pathname: string) {\n    const segments = pathname.split('/').filter(Boolean);\n    const filename = segments.pop();\n\n    if (!filename) {\n      return false;\n    }\n\n    let parent: Entry = this.root;\n\n    for (const segment of segments) {\n      if (!parent || parent.type !== ResolverStrategy.EntryKind.Directory) {\n        return false;\n      }\n\n      parent = parent.children[segment];\n    }\n\n    if (!parent || parent.type !== ResolverStrategy.EntryKind.Directory) {\n      return false;\n    }\n\n    return delete parent.children[filename];\n  }\n\n  getResolveRoot() {\n    return {\n      uri: this.rootUri,\n    };\n  }\n\n  listEntries(_ctx: ResolverContext, uri: Uri) {\n    const urlPathname = Uri.ensureTrailingSlash(uri).fsPath;\n    const basePathname = this.rootUri.fsPath;\n    const fsPathname = urlPathname.startsWith(basePathname)\n      ? urlPathname.slice(basePathname.length - 1)\n      : urlPathname;\n    const parent = this.getEntryAtPath(fsPathname);\n\n    if (!parent) {\n      throw new Error(`No such directory ${uri.toString()}`);\n    }\n\n    if (parent.type !== ResolverStrategy.EntryKind.Directory) {\n      throw new Error(`Cannot list entries under a file at ${uri.toString()}`);\n    }\n\n    const entries = Object.keys(parent.children).map((filename) => {\n      const entry = parent.children[filename];\n\n      return {\n        uri: Uri.joinPath(this.rootUri, fsPathname, filename),\n        type: entry.type,\n      };\n    });\n\n    return {\n      entries,\n    };\n  }\n\n  readFileContent(_ctx: ResolverContext, uri: Uri) {\n    const urlPathname = Uri.ensureTrailingSlash(uri).fsPath;\n    const basePathname = this.rootUri.fsPath;\n    const fsPathname = urlPathname.startsWith(basePathname)\n      ? urlPathname.slice(basePathname.length - 1)\n      : urlPathname;\n    const entry = this.getEntryAtPath(fsPathname);\n\n    if (!entry) {\n      throw new Error(`No such file ${uri.toString()}`);\n    }\n\n    if (entry.type !== 'file') {\n      throw new Error(`Cannot read content of a non-file at ${uri.toString()}`);\n    }\n\n    switch (entry.encoding) {\n      case FileEncoding.Base64: {\n        const binSting = atob(entry.content);\n        const binArray = new Uint8Array(binSting.length);\n\n        Array.prototype.forEach.call(binArray, function (_el: any, idx: number, arr: number[]) {\n          arr[idx] = binSting.charCodeAt(idx);\n        });\n\n        return {\n          content: binArray.buffer,\n        };\n      }\n      case FileEncoding.UTF8: {\n        return {\n          content: encodeText(entry.content),\n        };\n      }\n      default:\n        throw new Error(`Unsupported encoding for ${uri.toString()}: ${entry.encoding}`);\n    }\n  }\n\n  uriForPath(pathname: string) {\n    return Uri.joinPath(this.rootUri, pathname);\n  }\n}\n","import { DisposableStore, Emitter, Event } from '@velcro/common';\nimport type * as Monaco from 'monaco-editor';\nimport {\n  EditorEvent,\n  FileCreateEvent,\n  FileRemoveEvent,\n  FileUpdateEvent,\n  WorkerState,\n} from './types';\n\nconst EDITOR_EVENT_THROTTLE_MS = (1000 / 16) | 0;\n\nexport function trackMonaco(monaco: typeof Monaco) {\n  const disposer = new DisposableStore();\n  const worker = new Worker('./velcroWorker.ts', { type: 'module' });\n\n  const trackModel = (model: Monaco.editor.ITextModel) => {\n    model.onWillDispose(() => {\n      const message: FileRemoveEvent = {\n        event: 'file_remove',\n        href: model.uri.toString(true),\n      };\n      postMessage(message);\n      disposerReference.dispose();\n    });\n\n    const disposerReference = disposer.add(\n      model.onDidChangeContent(() => {\n        const message: FileUpdateEvent = {\n          event: 'file_update',\n          content: model.getValue(),\n          href: model.uri.toString(true),\n        };\n        postMessage(message);\n      })\n    );\n\n    const message: FileCreateEvent = {\n      event: 'file_create',\n      content: model.getValue(),\n      href: model.uri.toString(true),\n    };\n    postMessage(message);\n  };\n\n  const postMessageEmitter = new Emitter<EditorEvent>();\n  const postMessageQueue = Event.debounce<EditorEvent, Map<string, EditorEvent>>(\n    postMessageEmitter.event,\n    (last, event) => {\n      if (!last) {\n        last = new Map();\n      }\n\n      last.set(event.href, event);\n\n      return last;\n    },\n    EDITOR_EVENT_THROTTLE_MS\n  )((events) => {\n    worker.postMessage([...events.values()]);\n  });\n\n  disposer.add(postMessageEmitter);\n  disposer.add(postMessageQueue);\n\n  const postMessage = (message: EditorEvent) => {\n    postMessageEmitter.fire(message);\n  };\n\n  // Track existing models\n  monaco.editor.getModels().forEach(trackModel);\n\n  // And future models\n  disposer.add(monaco.editor.onDidCreateModel(trackModel));\n  disposer.add({\n    dispose: () => worker.terminate(),\n  });\n\n  const emitter = new Emitter<WorkerState>();\n  disposer.add(emitter);\n\n  worker.addEventListener('message', (e) => {\n    if (WorkerState.is(e.data)) {\n      emitter.fire(e.data);\n    }\n  });\n\n  return {\n    dispose: () => disposer.dispose(),\n    get onStateChange() {\n      return emitter.event;\n    },\n  };\n}\n","import * as z from 'zod';\n\nexport const FileCreateEvent = z.object({\n  event: z.literal('file_create'),\n  content: z.string(),\n  href: z.string(),\n});\nexport type FileCreateEvent = z.infer<typeof FileCreateEvent>;\n\nexport const FileRemoveEvent = z.object({\n  event: z.literal('file_remove'),\n  href: z.string(),\n});\nexport type FileRemoveEvent = z.infer<typeof FileRemoveEvent>;\n\nexport const FileUpdateEvent = z.object({\n  event: z.literal('file_update'),\n  content: z.string(),\n  href: z.string(),\n});\nexport type FileUpdateEvent = z.infer<typeof FileUpdateEvent>;\n\nexport const EditorEvent = z.union([FileCreateEvent, FileRemoveEvent, FileUpdateEvent]);\nexport type EditorEvent = z.infer<typeof EditorEvent>;\n\nexport const EditorEvents = z.array(EditorEvent);\nexport type EditorEvents = z.infer<typeof EditorEvents>;\n\nexport const BuiltState = z.object({\n  state: z.literal('built'),\n  href: z.string(),\n  start: z.number().int(),\n  end: z.number().int(),\n});\nexport type BuiltState = z.infer<typeof BuiltState>;\n\nexport const BuildingState = z.object({\n  state: z.literal('building'),\n  completed: z.number(),\n  pending: z.number(),\n});\nexport type BuildingState = z.infer<typeof BuildingState>;\n\nexport const ErrorState = z.object({\n  state: z.literal('error'),\n  error: z.object({\n    message: z.string(),\n  }),\n});\nexport type ErrorState = z.infer<typeof ErrorState>;\n\nexport const InitialState = z.object({\n  state: z.literal('initial'),\n});\nexport type InitialState = z.infer<typeof InitialState>;\n\nexport const WorkerState = z.union([BuildingState, BuiltState, ErrorState, InitialState]);\nexport type WorkerState = z.infer<typeof WorkerState>;\n","module.exports = __webpack_public_path__ + \"static/js/0.0dcb2073.chunk.worker.js\"","var charToInteger = {};\nvar chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\nfor (var i = 0; i < chars.length; i++) {\n    charToInteger[chars.charCodeAt(i)] = i;\n}\nfunction decode(mappings) {\n    var decoded = [];\n    var line = [];\n    var segment = [\n        0,\n        0,\n        0,\n        0,\n        0,\n    ];\n    var j = 0;\n    for (var i = 0, shift = 0, value = 0; i < mappings.length; i++) {\n        var c = mappings.charCodeAt(i);\n        if (c === 44) { // \",\"\n            segmentify(line, segment, j);\n            j = 0;\n        }\n        else if (c === 59) { // \";\"\n            segmentify(line, segment, j);\n            j = 0;\n            decoded.push(line);\n            line = [];\n            segment[0] = 0;\n        }\n        else {\n            var integer = charToInteger[c];\n            if (integer === undefined) {\n                throw new Error('Invalid character (' + String.fromCharCode(c) + ')');\n            }\n            var hasContinuationBit = integer & 32;\n            integer &= 31;\n            value += integer << shift;\n            if (hasContinuationBit) {\n                shift += 5;\n            }\n            else {\n                var shouldNegate = value & 1;\n                value >>>= 1;\n                if (shouldNegate) {\n                    value = value === 0 ? -0x80000000 : -value;\n                }\n                segment[j] += value;\n                j++;\n                value = shift = 0; // reset\n            }\n        }\n    }\n    segmentify(line, segment, j);\n    decoded.push(line);\n    return decoded;\n}\nfunction segmentify(line, segment, j) {\n    // This looks ugly, but we're creating specialized arrays with a specific\n    // length. This is much faster than creating a new array (which v8 expands to\n    // a capacity of 17 after pushing the first item), or slicing out a subarray\n    // (which is slow). Length 4 is assumed to be the most frequent, followed by\n    // length 5 (since not everything will have an associated name), followed by\n    // length 1 (it's probably rare for a source substring to not have an\n    // associated segment data).\n    if (j === 4)\n        line.push([segment[0], segment[1], segment[2], segment[3]]);\n    else if (j === 5)\n        line.push([segment[0], segment[1], segment[2], segment[3], segment[4]]);\n    else if (j === 1)\n        line.push([segment[0]]);\n}\nfunction encode(decoded) {\n    var sourceFileIndex = 0; // second field\n    var sourceCodeLine = 0; // third field\n    var sourceCodeColumn = 0; // fourth field\n    var nameIndex = 0; // fifth field\n    var mappings = '';\n    for (var i = 0; i < decoded.length; i++) {\n        var line = decoded[i];\n        if (i > 0)\n            mappings += ';';\n        if (line.length === 0)\n            continue;\n        var generatedCodeColumn = 0; // first field\n        var lineMappings = [];\n        for (var _i = 0, line_1 = line; _i < line_1.length; _i++) {\n            var segment = line_1[_i];\n            var segmentMappings = encodeInteger(segment[0] - generatedCodeColumn);\n            generatedCodeColumn = segment[0];\n            if (segment.length > 1) {\n                segmentMappings +=\n                    encodeInteger(segment[1] - sourceFileIndex) +\n                        encodeInteger(segment[2] - sourceCodeLine) +\n                        encodeInteger(segment[3] - sourceCodeColumn);\n                sourceFileIndex = segment[1];\n                sourceCodeLine = segment[2];\n                sourceCodeColumn = segment[3];\n            }\n            if (segment.length === 5) {\n                segmentMappings += encodeInteger(segment[4] - nameIndex);\n                nameIndex = segment[4];\n            }\n            lineMappings.push(segmentMappings);\n        }\n        mappings += lineMappings.join(',');\n    }\n    return mappings;\n}\nfunction encodeInteger(num) {\n    var result = '';\n    num = num < 0 ? (-num << 1) | 1 : num << 1;\n    do {\n        var clamped = num & 31;\n        num >>>= 5;\n        if (num > 0) {\n            clamped |= 32;\n        }\n        result += chars[clamped];\n    } while (num > 0);\n    return result;\n}\n\nexport { decode, encode };\n//# sourceMappingURL=sourcemap-codec.es.js.map\n","abstract class BaseError extends Error {\n  readonly name = this.constructor.name;\n}\n\nexport class GraphBuildError extends BaseError {\n  constructor(readonly errors: Error[]) {\n    super(\n      `Graph building failed with errors:\\n${errors.map((err) => `  ${err.message}`).join('\\n')}`\n    );\n  }\n}\n","import { Base64 } from '@velcro/common';\nimport { DecodedSourceMap } from 'magic-string';\nimport { decode } from 'sourcemap-codec';\n\nexport class SourceMap {\n  readonly file?: string;\n  readonly mappings: string;\n  readonly sourceRoot?: string;\n  readonly names: string[];\n  readonly sources: (string | null)[];\n  readonly sourcesContent?: (string | null)[];\n  readonly version: number;\n\n  constructor(input: {\n    file?: string;\n    mappings: string;\n    sourceRoot?: string;\n    names: string[];\n    sources: (string | null)[];\n    sourcesContent?: (string | null)[];\n    version: string | number;\n  }) {\n    this.file = input.file;\n    this.mappings = input.mappings;\n    this.sourceRoot = input.sourceRoot;\n    this.names = input.names;\n    this.sources = input.sources;\n    this.sourcesContent = input.sourcesContent;\n    this.version = input.version as number | 0;\n  }\n\n  toString() {\n    return JSON.stringify(this);\n  }\n\n  toDataUri() {\n    return `data:application/json;charset=utf-8;base64,${Base64.encode(this.toString())}`;\n  }\n}\n\nfunction getSourceMappingUrlMatch(str: string) {\n  const re = /(?:(?:\\/\\/|\\/\\*)[@#][\\s]*(?:source)MappingURL=([^\\s'\"]+)[\\s]*$)|(?:\\/\\*[@#][\\s]*(?:source)MappingURL=([^\\s*'\"]+)[\\s]*(?:\\*\\/)[\\s]*$)/gm;\n  // Keep executing the search to find the *last* sourceMappingURL to avoid\n  // picking up sourceMappingURLs from comments, strings, etc.\n  let lastMatch: RegExpExecArray | null = null;\n  let match: RegExpExecArray | null;\n\n  while ((match = re.exec(str))) lastMatch = match;\n\n  return lastMatch;\n}\n\nexport function getSourceMappingUrl(str: string) {\n  const lastMatch = getSourceMappingUrlMatch(str);\n\n  if (!lastMatch) return '';\n\n  return lastMatch[1];\n}\n\nexport function updateSourceMappingUrl(str: string, url: string) {\n  const lastMatch = getSourceMappingUrlMatch(str);\n\n  if (!lastMatch) return str;\n\n  return str.slice(0, lastMatch.index) + str.slice(lastMatch.index).replace(lastMatch[1], url);\n}\n\nexport function decodeDataUriAsSourceMap(href: string): DecodedSourceMap | null {\n  const match = href.match(/^data:application\\/json;(?:charset=([^;]+);)?base64,(.*)$/);\n\n  if (match) {\n    if (match[1] && match[1] !== 'utf-8') {\n      return null;\n    }\n\n    try {\n      const decoded = JSON.parse(Base64.decode(match[2]));\n\n      if (decoded.mappings === '') {\n        return {\n          file: '',\n          mappings: [],\n          names: [],\n          sources: [],\n          sourcesContent: [],\n        };\n      }\n\n      if (typeof decoded.mappings === 'string') {\n        decoded.mappings = decode(decoded.mappings);\n      }\n\n      return decoded;\n    } catch (err) {\n      return null;\n    }\n  }\n\n  return null;\n}\n","import { SourceMapSegment } from 'magic-string';\nimport { decode } from 'sourcemap-codec';\n\nexport interface ISourceMapper {\n  traceMappings(): ReturnType<typeof traceMappings>;\n}\n\n/**\n * Copyright (c) Rollup 2020 authors: https://github.com/rollup/rollup/graphs/contributors)\n *\n * Copied with light modifications from:\n * https://github.com/rollup/rollup/blob/36a4527473ea1fe678ed866c9f8dfd3c2542cd22/src/utils/collapseSourcemaps.ts\n */\n\nexport class Source {\n  content: string | null;\n  filename: string;\n\n  constructor(filename: string, content: string | null) {\n    this.filename = filename;\n    this.content = content;\n  }\n\n  traceSegment(line: number, column: number, name?: string): SourceMapSegmentObject {\n    return { line, column, name, source: this };\n  }\n}\n\ninterface SourceMapSegmentObject {\n  column: number;\n  line: number;\n  name?: string;\n  source: Source;\n}\n\nexport class Link {\n  mappings: SourceMapSegment[][];\n  names: string[];\n  sources: (Source | Link)[];\n\n  constructor(\n    map: { mappings: SourceMapSegment[][] | string; names: string[] },\n    sources: (Source | Link)[]\n  ) {\n    this.sources = sources;\n    this.names = map.names;\n    this.mappings = typeof map.mappings === 'string' ? decode(map.mappings) : map.mappings;\n  }\n\n  traceMappings() {\n    return traceMappings(this);\n  }\n\n  traceSegment(line: number, column: number, name: string): SourceMapSegmentObject | null {\n    return traceSegment(this, line, column, name);\n  }\n}\n\nexport class LazyLink {\n  private link?: Link = undefined;\n\n  constructor(private readonly loadLink: () => Link) {}\n\n  private getLink() {\n    let link = this.link;\n\n    if (!link) {\n      link = this.loadLink();\n      this.link = link;\n    }\n\n    return link;\n  }\n\n  traceMappings() {\n    return traceMappings(this.getLink());\n  }\n\n  traceSegment(line: number, column: number, name: string): SourceMapSegmentObject | null {\n    return traceSegment(this.getLink(), line, column, name);\n  }\n}\n\nfunction traceMappings(\n  this: void,\n  map: { mappings: SourceMapSegment[][]; names: string[]; sources: (Link | Source)[] }\n) {\n  const sources: string[] = [];\n  const sourcesContent: (string | null)[] = [];\n  const names: string[] = [];\n  const mappings = [];\n\n  for (const line of map.mappings) {\n    const tracedLine: SourceMapSegment[] = [];\n\n    for (const segment of line) {\n      if (segment.length == 1) continue;\n      const source = map.sources[segment[1]];\n      if (!source) continue;\n\n      const traced = source.traceSegment(\n        segment[2],\n        segment[3],\n        segment.length === 5 ? map.names[segment[4]] : ''\n      );\n\n      if (traced) {\n        // newer sources are more likely to be used, so search backwards.\n        let sourceIndex = sources.lastIndexOf(traced.source.filename);\n        if (sourceIndex === -1) {\n          sourceIndex = sources.length;\n          sources.push(traced.source.filename);\n          sourcesContent[sourceIndex] = traced.source.content;\n        } else if (sourcesContent[sourceIndex] == null) {\n          sourcesContent[sourceIndex] = traced.source.content;\n        } else if (\n          traced.source.content != null &&\n          sourcesContent[sourceIndex] !== traced.source.content\n        ) {\n          return new Error(\n            `Multiple conflicting contents for sourcemap source ${traced.source.filename}`\n          );\n        }\n\n        const tracedSegment: SourceMapSegment = [\n          segment[0],\n          sourceIndex,\n          traced.line,\n          traced.column,\n        ];\n\n        if (traced.name) {\n          let nameIndex = names.indexOf(traced.name);\n          if (nameIndex === -1) {\n            nameIndex = names.length;\n            names.push(traced.name);\n          }\n\n          (tracedSegment as SourceMapSegment)[4] = nameIndex;\n        }\n\n        tracedLine.push(tracedSegment);\n      }\n    }\n\n    mappings.push(tracedLine);\n  }\n\n  return { sources, sourcesContent, names, mappings };\n}\n\nfunction traceSegment(\n  this: void,\n  map: { mappings: SourceMapSegment[][]; names: string[]; sources: (Link | Source)[] },\n  line: number,\n  column: number,\n  name: string\n): SourceMapSegmentObject | null {\n  const segments = map.mappings[line];\n  if (!segments) return null;\n\n  // binary search through segments for the given column\n  let i = 0;\n  let j = segments.length - 1;\n\n  const checks = [];\n\n  while (i <= j) {\n    const m = (i + j) >> 1;\n    const segment = segments[m];\n    checks.push(segment);\n    if (segment[0] === column) {\n      if (segment.length == 1) return null;\n      const source = map.sources[segment[1]];\n      if (!source) return null;\n\n      return source.traceSegment(\n        segment[2],\n        segment[3],\n        segment.length === 5 ? map.names[segment[4]] : name\n      );\n    }\n    if (segment[0] > column) {\n      j = m - 1;\n    } else {\n      i = m + 1;\n    }\n  }\n\n  return null;\n}\n/**\n * This function attempts to compensate for the loss of precision when lower\n * layers of source maps have higher precision than upper layers, leading to\n * a loss of fidelity.\n *\n * The code was lifted from [Alec Larson](https://github.com/aleclarson)'s\n * [fork of sorcery](https://github.com/aleclarson/sorcery/blob/3934a3f38a6d8604fc9dbaa576cbb6e4d733040f/src/blend.js).\n *\n * NOTE: This function mutates the given node.\n *\n * @copyright [Alec Larson](https://github.com/aleclarson) 2018\n */\n// function blend(node: Link) {\n//   let mappings: SourceMapSegment[][] = []; // traced lines\n//   let sources: (Link | Source)[] = []; // traced sources\n//   let names: string[] = []; // traced symbols\n\n//   // Precompute which source/line/column triples are mapped by the given node.\n//   // These references are useful when interweaving old segments.\n//   const refs: number[][][] = Object.keys(node.sources).map(() => []);\n\n//   for (const segments of node.mappings) {\n//     let segment: SourceMapSegment;\n//     let lines: number[][];\n//     let columns: number[];\n//     for (let i = 0; i < segments.length; i++) {\n//       segment = segments[i];\n\n//       if (segment.length === 4 || segment.length === 5) {\n//         lines = refs[segment[1]];\n//         if (!lines) refs[segment[1]] = lines = [];\n\n//         columns = lines[segment[2]];\n//         if (columns) {\n//           uniqueAscendingInsert(columns, segment[3]);\n//         } else {\n//           lines[segment[2]] = [segment[3]];\n//         }\n//       }\n//     }\n//   }\n\n//   let traced: SourceMapSegment[] | undefined = undefined; // the traced line mapping\n//   let untraced: SourceMapSegment[] | undefined = undefined; // the untraced line mapping\n\n//   function addSegment(\n//     segment: SourceMapSegment,\n//     source?: { names: string[]; sources: (Link | Source)[] }\n//   ) {\n//     if (source) {\n//       segment[1] = uniq<Link | Source>(sources, source.sources[segment[1]!]);\n//       if (segment.length === 5) {\n//         segment[4] = uniq(names, source.names[segment[4]]);\n//       }\n//     } else if (segment.length === 5) {\n//       segment[4] = uniq(names, node.names[segment[4]]);\n//     }\n//     traced!.push(segment);\n//   }\n\n//   let tracedLine: number; // the last traced line\n//   let generatedLine = -1; // the current line\n//   let sourceIndex: number | undefined = -1; // source of last traced segment\n//   let sourceLine: number | undefined = undefined; // source line of last traced segment\n\n//   // Find the next line with segments.\n//   function nextLine() {\n//     tracedLine = generatedLine;\n//     while (++generatedLine < node.mappings.length) {\n//       untraced = node.mappings[generatedLine];\n//       if (untraced.length) return true;\n//     }\n//   }\n\n//   // Provide mappings for lines between the\n//   // last traced line and the current line.\n//   function fillSkippedLines() {\n//     const skipped = generatedLine - (tracedLine + 1);\n//     if (skipped !== 0) {\n//       let line = tracedLine;\n\n//       // Take line mappings from the current source.\n//       if (sourceIndex !== -1) {\n//         const source = node.sources[sourceIndex!];\n//         if (source instanceof Link) {\n//           while (line < generatedLine - 1) {\n//             if (++sourceLine! !== source.mappings.length) {\n//               mappings[++line] = traced = [];\n\n//               // Check referenced columns to avoid duplicate segments.\n//               const columns = refs[sourceIndex!][sourceLine!] || [];\n//               let prevColumn = -1;\n\n//               // Interweave old segments from the current source.\n//               const segments = source.mappings[sourceLine!];\n//               for (let i = 0; i < segments.length; i++) {\n//                 const segment = segments[i];\n//                 if (!hasValueBetween(columns, prevColumn, segment[0] + 1)) {\n//                   addSegment([...segment] as SourceMapSegment, source);\n//                   prevColumn = segment[0];\n//                 } else break;\n//               }\n//             } else {\n//               // End of source file.\n//               sourceIndex = -1;\n//               break;\n//             }\n//           }\n//         }\n//       }\n\n//       // Default to empty arrays for unmapped lines.\n//       while (++line < generatedLine) {\n//         mappings[line] = [];\n//       }\n//     }\n//   }\n\n//   while (nextLine()) {\n//     fillSkippedLines();\n\n//     // Trace the segments of this generated line.\n//     mappings[generatedLine] = traced = [];\n\n//     // Interweave old segments before the first mapped column of each line.\n//     const sourceColumn = untraced![0][3];\n//     if (sourceIndex !== -1 && sourceColumn !== 0) {\n//       const source = node.sources[sourceIndex];\n//       if (source instanceof Link) {\n//         const segments =\n//           sourceLine! < source.mappings.length - 1 ? source.mappings[++sourceLine!] : [];\n\n//         for (let i = 0; i < segments.length; i++) {\n//           const segment = segments[i];\n//           if (segment[0] < sourceColumn!) {\n//             addSegment(segment.slice(0) as SourceMapSegment, source);\n//           } else break;\n//         }\n//       }\n//     }\n\n//     const last = untraced!.length - 1;\n//     untraced!.forEach((curr: SourceMapSegment | null, i) => {\n//       [, sourceIndex, sourceLine] = curr!;\n\n//       const source = node.sources[sourceIndex!];\n//       if (source === null) {\n//         curr![1] = uniq(sources, null);\n//         return addSegment(curr!);\n//       }\n//       if (!(source instanceof Link)) {\n//         curr![1] = uniq(sources, source);\n//         return addSegment(curr!);\n//       }\n\n//       const next = i !== last ? untraced![i + 1] : null;\n//       const sourceColumn = curr![3];\n//       const generatedColumn = curr![0];\n\n//       // Find the first segment with a greater column.\n//       const segments = source.mappings[sourceLine!] || [];\n//       let j = findGreaterColumn(segments, sourceColumn!);\n\n//       // A \"base segment\" is required for tracing to a grand-parent.\n//       let base;\n//       if (--j !== -1) {\n//         base = segments[j];\n//         curr![1] = uniq(sources, source.sources[base[1]!]);\n//         curr![2] = base[2];\n//         curr![3] = base[3]! + sourceColumn! - base[0];\n//         if (base.length === 5) {\n//           // Inherit the names of aligned base segments.\n//           if (base[0] === sourceColumn) {\n//             curr![4] = uniq(names, source.names[base[4]!]);\n//           }\n//         } else if (curr!.length === 5) {\n//           // When our segment is named and the base segment is not,\n//           // assume this segment cannot be traced to its original source.\n//           if (base[0] !== sourceColumn) curr = null;\n//         }\n//       } else {\n//         curr![1] = uniq(sources, null);\n//       }\n\n//       curr && addSegment(curr);\n\n//       // Check referenced columns to avoid duplicate segments.\n//       const columns = refs[sourceIndex!][sourceLine!] || [];\n//       let baseColumn = base ? base[0] : -1;\n\n//       // Interweave old segments between our current and next segments.\n//       const nextColumn = next ? next[0] : 1 / 0;\n//       while (++j < segments.length) {\n//         let segment = segments[j];\n\n//         // The generated column is shifted to fit into the root source map.\n//         const column = segment[0] + generatedColumn - sourceColumn!;\n//         if (column >= nextColumn) break;\n\n//         // Avoid duplicates by checking if this segment goes elsewhere.\n//         if (!hasValueBetween(columns, baseColumn, segment[0] + 1)) {\n//           baseColumn = segment[0];\n//           segment = segment.slice(0) as SourceMapSegment;\n//           segment[0] = column;\n//           addSegment(segment, source);\n//         } else break;\n//       }\n//     });\n//   }\n//   fillSkippedLines();\n\n//   node.mappings = mappings;\n//   node.sources = sources;\n//   node.names = names;\n//   return node;\n// }\n\n// // Check if a value exists before pushing it to an array.\n// // Return the new or existing index of the value.\n// function uniq<T>(arr: T[], val: T): number {\n//   const i = arr.indexOf(val);\n//   return ~i ? i : arr.push(val) - 1;\n// }\n\n// // Get the first segment with a greater column.\n// function findGreaterColumn(segments: SourceMapSegment[], column: number) {\n//   let low = 0,\n//     high = segments.length;\n//   while (low < high) {\n//     const mid = (low + high) >>> 1;\n//     segments[mid][0] <= column ? (low = mid + 1) : (high = mid);\n//   }\n//   return low;\n// }\n\n// // The range is exclusive.\n// function hasValueBetween(arr: number[], start: number, end: number) {\n//   let low = 0,\n//     high = arr.length;\n//   while (low < high) {\n//     const mid = (low + high) >>> 1;\n//     const val = arr[mid];\n//     if (val <= start) {\n//       low = mid + 1;\n//     } else if (val >= end) {\n//       high = mid;\n//     } else {\n//       return true;\n//     }\n//   }\n//   return false;\n// }\n\n// // Insert unique values in ascending order.\n// function uniqueAscendingInsert(arr: number[], val: number) {\n//   let low = 0,\n//     high = arr.length;\n//   while (low < high) {\n//     const mid = (low + high) >>> 1;\n//     const x = arr[mid];\n//     if (x === val) return;\n//     if (x < val) {\n//       low = mid + 1;\n//     } else {\n//       high = mid;\n//     }\n//   }\n//   arr.splice(low, 0, val);\n// }\n","import { Uri } from '@velcro/common';\n\nexport enum SourceModuleDependencyKind {\n  Entrypoint = 'Entrypoint',\n  Require = 'Require',\n  RequireResolve = 'RequireResolve',\n  GlobalObject = 'GlobalObject',\n}\n\ninterface SourceModuleOptions {\n  exportName?: string;\n}\n\ntype SourceLocation = { start: number; end: number };\n\nexport class SourceModuleDependency {\n  locator?: { name: string; spec: string; path: string; version?: string };\n\n  private constructor(\n    readonly kind: SourceModuleDependencyKind,\n    readonly spec: string,\n    readonly locations: ReadonlyArray<SourceLocation>,\n    readonly options: SourceModuleOptions = {}\n  ) {}\n\n  static areIdentical(l: SourceModuleDependency, r: SourceModuleDependency) {\n    return l.kind === r.kind && l.spec === r.spec;\n  }\n\n  static fromEntrypoint(uri: Uri) {\n    return new SourceModuleDependency(SourceModuleDependencyKind.Entrypoint, uri.toString(), []);\n  }\n\n  static fromGlobalObject(spec: string, locations: SourceLocation[], exportName?: string) {\n    return new SourceModuleDependency(SourceModuleDependencyKind.GlobalObject, spec, locations, {\n      exportName,\n    });\n  }\n\n  static fromRequire(spec: string, locations: SourceLocation[]) {\n    return new SourceModuleDependency(SourceModuleDependencyKind.Require, spec, locations);\n  }\n\n  static fromRequireResolve(spec: string, locations: SourceLocation[]) {\n    return new SourceModuleDependency(SourceModuleDependencyKind.RequireResolve, spec, locations);\n  }\n}\n","import {\n  checkCancellation,\n  DependencyNotFoundError,\n  EntryExcludedError,\n  EntryNotFoundError,\n  isThenable,\n  Uri,\n} from '@velcro/common';\nimport { ResolverContext } from '@velcro/resolver';\nimport MagicString, { DecodedSourceMap, SourceMap } from 'magic-string';\nimport {\n  decodeDataUriAsSourceMap,\n  getSourceMappingUrl,\n  updateSourceMappingUrl,\n} from '../build/sourceMap';\nimport { Link, Source } from '../build/sourceMapTree';\nimport { SourceModule, SourceModuleDependency } from '../graph';\nimport {\n  Plugin,\n  PluginLoadContext,\n  PluginResolveDependencyContext,\n  PluginResolveEntrypointContext,\n  PluginTransformContext,\n} from './plugin';\n\nexport class PluginManager {\n  constructor(private readonly plugins: Plugin[]) {\n    this.plugins.push({\n      name: 'builtIn',\n      load: async (ctx, id) => {\n        const uri = Uri.parse(id);\n        const readReturn = ctx.resolver.readFileContent(uri);\n        const readResult = isThenable(readReturn)\n          ? await checkCancellation(readReturn, ctx.token)\n          : readReturn;\n\n        return {\n          code: ctx.resolver.decode(readResult.content),\n          visited: readResult.visited,\n        };\n      },\n      resolveDependency: async (ctx, dependency, fromSourceModule) => {\n        const resolveReturn = ctx.resolver.resolve(dependency.spec, fromSourceModule.uri);\n        const resolveResult = isThenable(resolveReturn)\n          ? await checkCancellation(resolveReturn, ctx.token)\n          : resolveReturn;\n\n        if (!resolveResult.found) {\n          throw new DependencyNotFoundError(dependency.spec, fromSourceModule);\n        }\n\n        if (!resolveResult.uri) {\n          // TODO: Inject empty module\n          throw new EntryExcludedError(dependency.spec);\n        }\n\n        return {\n          uri: resolveResult.uri,\n          rootUri: resolveResult.rootUri,\n          visited: resolveResult.visited,\n        };\n      },\n      resolveEntrypoint: async (ctx, uri) => {\n        const resolveResult = await ctx.resolver.resolve(uri);\n\n        if (!resolveResult.found) {\n          throw new EntryNotFoundError(`Entry point not found: ${uri}`);\n        }\n\n        if (!resolveResult.uri) {\n          throw new EntryExcludedError(uri);\n        }\n\n        return resolveResult;\n      },\n      transform: async ({ createMagicString }, id) => {\n        if (id.path.endsWith('.json')) {\n          const magicString = createMagicString();\n          magicString.prepend('module.exports = ');\n\n          return {\n            code: magicString.toString(),\n            sourceMap: magicString.generateDecodedMap(),\n          };\n        }\n      },\n    });\n  }\n\n  async executeLoad(ctx: PluginLoadContext, uri: Uri) {\n    for (const plugin of this.plugins) {\n      if (typeof plugin.load === 'function') {\n        const loadReturn = plugin.load(ctx, uri.toString());\n        const loadResult = isThenable(loadReturn)\n          ? await checkCancellation(loadReturn, ctx.token)\n          : loadReturn;\n\n        if (!loadResult) {\n          continue;\n        }\n\n        return {\n          code: loadResult.code,\n          visited: loadResult.visited || [],\n        };\n      }\n    }\n\n    throw new Error(`No plugin was found that was able to load the uri ${uri.toString()}`);\n  }\n\n  async executeResolveDependency(\n    ctx: PluginResolveDependencyContext,\n    dependency: SourceModuleDependency,\n    fromModule: SourceModule\n  ) {\n    for (const plugin of this.plugins) {\n      if (typeof plugin.resolveDependency === 'function') {\n        const loadReturn = plugin.resolveDependency(ctx, dependency, fromModule);\n        const loadResult = isThenable(loadReturn)\n          ? await checkCancellation(loadReturn, ctx.token)\n          : loadReturn;\n\n        if (!loadResult) {\n          continue;\n        }\n\n        return {\n          uri: loadResult.uri,\n          rootUri: loadResult.rootUri,\n          visited: loadResult.visited || [],\n        };\n      }\n    }\n\n    throw new Error(\n      `No plugin was able to resolve the '${dependency.kind}' dependency, '${dependency.spec}' from '${fromModule.href}'`\n    );\n  }\n\n  async executeResolveEntrypoint(ctx: PluginResolveEntrypointContext, uri: Uri) {\n    for (const plugin of this.plugins) {\n      if (typeof plugin.resolveEntrypoint === 'function') {\n        const loadReturn = plugin.resolveEntrypoint(ctx, uri);\n        const loadResult = isThenable(loadReturn)\n          ? await checkCancellation(loadReturn, ctx.token)\n          : loadReturn;\n\n        if (!loadResult) {\n          continue;\n        }\n\n        return {\n          uri: loadResult.uri,\n          rootUri: loadResult.rootUri,\n          visited: loadResult.visited || [],\n        };\n      }\n    }\n\n    throw new Error(`No plugin was able to resolve the entrypoint '${uri.toString()}'`);\n  }\n\n  async executeTransform(\n    ctx: Omit<PluginTransformContext, 'createMagicString'>,\n    uri: Uri,\n    code: string | ArrayBuffer\n  ) {\n    if (typeof code !== 'string') {\n      code = ctx.resolver.decode(code);\n    }\n\n    const pluginCtx: PluginTransformContext = Object.assign(ctx, {\n      createMagicString() {\n        return new MagicString(code as string);\n      },\n    });\n\n    let sourceMapTree: Source | Link = new Source(uri.toString(), code);\n\n    // Figure out if our original code, itself has a sourcemap.\n    // For now, we will not recurse beyond that depth.\n    const sourceMapRef = getSourceMappingUrl(code);\n    if (sourceMapRef) {\n      let sourceMap: DecodedSourceMap | SourceMap | null = decodeDataUriAsSourceMap(sourceMapRef);\n\n      if (!sourceMap) {\n        const sourceMapUri = Uri.joinPath(uri, `../${sourceMapRef}`);\n\n        code = updateSourceMappingUrl(code, sourceMapUri.toString());\n      }\n\n      if (sourceMap) {\n        const sources = sourceMap.sources;\n        const sourcesContent = sourceMap.sourcesContent || [];\n        const baseSources = [] as Source[];\n\n        for (const idx in sources) {\n          if (sources[idx] && sourcesContent[idx]) {\n            baseSources.push(new Source(sources[idx]!, sourcesContent[idx]!));\n          }\n        }\n\n        sourceMapTree = new Link(sourceMap, baseSources);\n      }\n    }\n\n    const visited = [] as ResolverContext.Visit[];\n\n    for (const plugin of this.plugins) {\n      if (typeof plugin.transform === 'function') {\n        const transformReturn = plugin.transform(pluginCtx, uri, code);\n        const transformResult = isThenable(transformReturn)\n          ? await checkCancellation(transformReturn, ctx.token)\n          : transformReturn;\n\n        if (transformResult === null || transformResult === undefined) {\n          continue;\n        }\n\n        if (transformResult.sourceMap) {\n          sourceMapTree = new Link(transformResult.sourceMap, [sourceMapTree]);\n        }\n\n        code = transformResult.code;\n\n        if (transformResult.visited) {\n          visited.push(...transformResult.visited);\n        }\n      }\n    }\n\n    return {\n      code,\n      sourceMapTree,\n      visited,\n    };\n  }\n}\n","import * as Acorn from 'acorn';\nimport {\n  ArrayPattern,\n  ArrowFunctionExpression,\n  AssignmentPattern,\n  BinaryExpression,\n  BlockStatement,\n  CallExpression,\n  ClassDeclaration,\n  Function,\n  FunctionDeclaration,\n  FunctionExpression,\n  Identifier,\n  IfStatement,\n  Literal,\n  MemberExpression,\n  Node,\n  ObjectPattern,\n  Program,\n  Property,\n  RestElement,\n  SimpleLiteral,\n  TemplateLiteral,\n  ThisExpression,\n  TryStatement,\n  VariableDeclaration,\n} from 'estree';\n\nexport type NodeWithParent<TNode = Node> = TNode & {\n  parent: NodeWithParent | null;\n};\n\nexport interface StringLiteral extends SimpleLiteral {\n  value: string;\n}\n\nexport function isArrowFunctionExpression(node: Node): node is ArrowFunctionExpression {\n  return node.type === 'ArrowFunctionExpression';\n}\n\nexport function isArrayPattern(node: Node): node is ArrayPattern {\n  return node.type === 'ArrayPattern';\n}\n\nexport function isAssignmentPattern(node: Node): node is AssignmentPattern {\n  return node.type === 'AssignmentPattern';\n}\n\nexport function isBinaryExpression(node: Node): node is BinaryExpression {\n  return node.type === 'BinaryExpression';\n}\n\nexport function isBlockStatement(node: Node): node is BlockStatement {\n  return node.type === 'BlockStatement';\n}\n\nexport function isCallExpression(node: Node): node is CallExpression {\n  return node.type === 'CallExpression';\n}\n\nexport function isClassDeclaration(node: Node): node is ClassDeclaration {\n  return node.type === 'ClassDeclaration';\n}\n\nexport function isFunctionDeclaration(node: Node): node is FunctionDeclaration {\n  return node.type === 'FunctionDeclaration';\n}\n\nexport function isFunctionExpression(node: Node): node is FunctionExpression {\n  return node.type === 'FunctionExpression';\n}\n\nexport function isIdentifier(node: Node): node is Identifier {\n  return node.type === 'Identifier';\n}\n\nexport function isIfStatement(node: Node): node is IfStatement {\n  return node.type === 'IfStatement';\n}\n\nexport function isLiteral(node: Node): node is Literal {\n  return node.type === 'Literal';\n}\n\nexport function isMemberExpression(node: Node): node is MemberExpression {\n  return node.type === 'MemberExpression';\n}\n\nexport function isMethodDefinition(node: Node): node is MemberExpression {\n  return node.type === 'MethodDefinition';\n}\n\nexport function isObjectPattern(node: Node): node is ObjectPattern {\n  return node.type === 'ObjectPattern';\n}\n\nexport function isProperty(node: Node): node is Property {\n  return node.type === 'Property';\n}\n\nexport function isRestElement(node: Node): node is RestElement {\n  return node.type === 'RestElement';\n}\n\nexport function isProgram(node: Node): node is Program {\n  return node.type === 'Program';\n}\n\nexport function isTemplateLiteral(node: Node): node is TemplateLiteral {\n  return node.type === 'TemplateLiteral';\n}\n\nexport function isThisExpression(node: Node): node is ThisExpression {\n  return node.type === 'ThisExpression';\n}\n\nexport function isTryStatement(node: Node): node is TryStatement {\n  return node.type === 'TryStatement';\n}\n\nexport function isVariableDeclaration(node: Node): node is VariableDeclaration {\n  return node.type === 'VariableDeclaration';\n}\n\n// Refinements or groups\nexport function isFunction(node: Node): node is Function {\n  return (\n    isFunctionDeclaration(node) || isFunctionExpression(node) || isArrowFunctionExpression(node)\n  );\n}\n\nexport function isStringLiteral(node: Node): node is StringLiteral {\n  return isLiteral(node) && typeof node.value === 'string';\n}\n\nexport function parse(code: string, options?: acorn.Options) {\n  return (Acorn.parse(code, {\n    ...options,\n    allowReturnOutsideFunction: true,\n    sourceType: 'script',\n  }) as any) as Program;\n}\n","import { Node } from 'estree';\nimport { NodeWithParent } from './ast';\n\ntype VisitorContext = {\n  skip(): void;\n};\n\ntype EnterFunction<TContext> = (\n  this: VisitorContext,\n  node: NodeWithParent,\n  parent: NodeWithParent | null,\n  ctx: TContext,\n  prop?: string,\n  index?: number\n) => void;\ntype LeaveFunction<TContext> = (\n  node: NodeWithParent,\n  parent: NodeWithParent | null,\n  ctx: TContext,\n  prop?: string,\n  index?: number\n) => void;\n\nexport type Visitor<TContext> = {\n  enter?: EnterFunction<TContext>;\n  leave?: LeaveFunction<TContext>;\n};\n\nexport function traverse<TContext>(ast: Node, ctx: TContext, { enter, leave }: Visitor<TContext>) {\n  visit(ast as NodeWithParent, null, ctx, enter, leave);\n}\n\nlet shouldSkip = false;\nconst context = { skip: () => (shouldSkip = true) };\n\nexport const childKeys: {\n  [key: string]: string[];\n} = {};\n\nfunction visit<TContext>(\n  node: NodeWithParent,\n  parent: NodeWithParent | null,\n  ctx: TContext,\n  enter?: EnterFunction<TContext>,\n  leave?: LeaveFunction<TContext>\n  // prop?: string,\n  // index?: number\n) {\n  if (!node) return;\n\n  node.parent = parent;\n\n  if (enter) {\n    const _shouldSkip = shouldSkip;\n    shouldSkip = false;\n    enter.call(context, node, parent, ctx);\n    const skipped = shouldSkip;\n    shouldSkip = _shouldSkip;\n\n    if (skipped) return;\n  }\n\n  const keys =\n    childKeys[node.type] ||\n    (childKeys[node.type] = Object.keys(node).filter(\n      (key) => key !== 'parent' && typeof (node as any)[key] === 'object'\n    ));\n\n  const children = [] as NodeWithParent[];\n\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    const value = (node as any)[key] as NodeWithParent | NodeWithParent[];\n\n    if (Array.isArray(value)) {\n      for (let j = 0; j < value.length; j++) {\n        if (value[j]) children.push(value[j]);\n      }\n    } else if (value && value.type) {\n      children.push(value);\n    }\n  }\n\n  children.sort((a, b) => a.start - b.start);\n\n  for (const child of children) {\n    visit(child, node, ctx, enter, leave);\n  }\n\n  if (leave) {\n    leave(node, parent, ctx);\n  }\n}\n","import { Uri } from '@velcro/common/src';\nimport type { BinaryOperator, Function, Identifier, MemberExpression, Node, Pattern } from 'estree';\nimport MagicString from 'magic-string';\nimport { ParserFunction } from '../parsing';\nimport { DEFAULT_SHIM_GLOBALS } from '../shims';\nimport { SourceModuleDependency } from '../sourceModuleDependency';\nimport {\n  isArrayPattern,\n  isArrowFunctionExpression,\n  isAssignmentPattern,\n  isBinaryExpression,\n  isBlockStatement,\n  isCallExpression,\n  isClassDeclaration,\n  isFunction,\n  isFunctionDeclaration,\n  isFunctionExpression,\n  isIdentifier,\n  isIfStatement,\n  isMemberExpression,\n  isMethodDefinition,\n  isObjectPattern,\n  isProgram,\n  isProperty,\n  isRestElement,\n  isStringLiteral,\n  isTemplateLiteral,\n  isThisExpression,\n  isTryStatement,\n  isVariableDeclaration,\n  NodeWithParent,\n  parse as parseAst,\n} from './ast';\nimport { traverse, Visitor } from './traverse';\n\ndeclare module 'estree' {\n  export interface BaseNodeWithoutComments {\n    start: number;\n    end: number;\n  }\n}\n\nexport const parse = function parseJavaScript(\n  uri: Uri,\n  code: string,\n  options: {\n    globalModules: typeof DEFAULT_SHIM_GLOBALS;\n    nodeEnv: string;\n  }\n): ReturnType<ParserFunction> {\n  const visitorCtx: DependencyVisitorContext = {\n    unboundSymbols: new Map(),\n    locals: new Map(),\n    magicString: new MagicString(code, { filename: uri.toString(), indentExclusionRanges: [] }),\n    nodeEnv: options.nodeEnv,\n    replacedSymbols: new Set<Identifier>(),\n    requires: [],\n    requireResolves: [],\n    skip: new Set(),\n    skipTransform: new Set(),\n  };\n  const dependencies = [] as SourceModuleDependency[];\n\n  try {\n    // let lastToken: Token | undefined;\n    const ast = parseAst(code, {\n      // onComment: (_isBlock, _test, start, end) => {\n      //   result.changes.push({ type: 'remove', start, end });\n      // },\n      // onInsertedSemicolon(lastTokEnd) {\n      //   result.changes.push({ type: 'appendRight', position: lastTokEnd, value: ';' });\n      // },\n      // onToken: (token) => {\n      //   const start = lastToken ? lastToken.end + 1 : 0;\n      //   const end = token.start;\n      //   if (end > start) {\n      //     result.changes.push({ type: 'remove', start, end });\n      //   }\n      //   lastToken = token;\n      // },\n    });\n\n    traverse(ast, visitorCtx, scopingAndRequiresVisitor);\n    traverse(ast, visitorCtx, collectGlobalsVisitor);\n  } catch (err) {\n    // console.debug(code);\n    // console.trace(err);\n    throw new Error(`Error parsing ${uri}: ${err.message}`);\n  }\n\n  // Handle explicit requires\n  const requiresBySpec = new Map<string, Array<{ start: number; end: number }>>();\n  for (const requireDependency of visitorCtx.requires) {\n    let locations = requiresBySpec.get(requireDependency.spec.value);\n    if (!locations) {\n      locations = [];\n      requiresBySpec.set(requireDependency.spec.value, locations);\n    }\n\n    locations.push({ start: requireDependency.spec.start, end: requireDependency.spec.end });\n  }\n  for (const [spec, locations] of requiresBySpec) {\n    dependencies.push(SourceModuleDependency.fromRequire(spec, locations));\n  }\n\n  // Handle require.resolve\n  const requireResolvesBySpec = new Map<string, Array<{ start: number; end: number }>>();\n  for (const requireDependency of visitorCtx.requireResolves) {\n    let locations = requiresBySpec.get(requireDependency.spec.value);\n    if (!locations) {\n      locations = [];\n      requiresBySpec.set(requireDependency.spec.value, locations);\n    }\n\n    locations.push({ start: requireDependency.spec.start, end: requireDependency.spec.end });\n  }\n  for (const [spec, locations] of requireResolvesBySpec) {\n    dependencies.push(SourceModuleDependency.fromRequireResolve(spec, locations));\n  }\n\n  for (const [symbolName, locations] of visitorCtx.unboundSymbols) {\n    const shim = options.globalModules[symbolName];\n\n    if (shim) {\n      dependencies.push(SourceModuleDependency.fromGlobalObject(shim.spec, locations, shim.export));\n\n      for (const location of locations) {\n        visitorCtx.magicString.overwrite(\n          location.start,\n          location.end,\n          `require(${JSON.stringify(`${shim.spec}`)})${shim.export ? `.${shim.export}` : ''}`\n        );\n      }\n    }\n  }\n\n  return {\n    code: visitorCtx.magicString,\n    dependencies,\n  };\n};\n\nexport type CommonJsRequire = {\n  callee: { start: number; end: number };\n  spec: { start: number; end: number; value: string };\n};\n\nexport type CommonJsRequireResolve = {\n  callee: { start: number; end: number };\n  spec: { start: number; end: number; value: string };\n};\n\nexport type DependencyVisitorContext = {\n  readonly unboundSymbols: Map<string, Node[]>;\n  readonly locals: Map<Node, { [identifier: string]: boolean }>;\n  readonly magicString: MagicString;\n  readonly nodeEnv: string;\n  readonly requires: CommonJsRequire[];\n  readonly replacedSymbols: Set<Identifier>;\n  readonly requireResolves: CommonJsRequireResolve[];\n  readonly skip: Set<Node>;\n  readonly skipTransform: Set<Node>;\n};\n\nexport const scopingAndRequiresVisitor: Visitor<DependencyVisitorContext> = {\n  enter(node, parent, ctx) {\n    // Get AST-node level locations in the source map\n    ctx.magicString.addSourcemapLocation(node.start);\n    ctx.magicString.addSourcemapLocation(node.end);\n\n    if (ctx.skip.has(node)) {\n      return this.skip();\n    }\n\n    visitAndCaptureScoping(node, parent, ctx);\n    visitAndSkipBranches(node, parent, ctx);\n    visitRequires(node, parent, ctx);\n  },\n  leave(node, _parent, ctx) {\n    let skipped = false;\n    let nextCheck: NodeWithParent<Node> | undefined = node;\n\n    while (nextCheck) {\n      if (ctx.skipTransform.has(nextCheck)) {\n        skipped = true;\n        break;\n      }\n\n      nextCheck = nextCheck.parent as NodeWithParent<Node> | undefined;\n    }\n\n    if (\n      !skipped &&\n      isMemberExpression(node) &&\n      memberExpressionMatches(node, 'process.env.NODE_ENV')\n    ) {\n      ctx.magicString.overwrite(node.start, node.end, JSON.stringify(ctx.nodeEnv), {\n        contentOnly: true,\n        storeName: true,\n      });\n      ctx.skip.add(node);\n      ctx.skipTransform.add(node);\n    }\n  },\n};\n\nexport const collectGlobalsVisitor: Visitor<DependencyVisitorContext> = {\n  enter(node, _parent, ctx) {\n    if (ctx.skip.has(node)) {\n      return this.skip();\n    }\n\n    if (isBindingIdentifier(node) && isIdentifier(node)) {\n      var name = node.name;\n      if (name === 'undefined') return;\n      if (ctx.replacedSymbols.has(node)) {\n        return;\n      }\n\n      let foundBinding = false;\n      let nextParent = node.parent;\n\n      while (nextParent) {\n        if (name === 'arguments' && declaresArguments(nextParent)) {\n          foundBinding = true;\n          break;\n        }\n\n        const locals = ctx.locals.get(nextParent);\n\n        if (locals && locals[name]) {\n          foundBinding = true;\n          break;\n        }\n\n        nextParent = nextParent.parent;\n      }\n\n      if (!foundBinding) {\n        let unboundSymbols = ctx.unboundSymbols.get(name);\n        if (!unboundSymbols) {\n          unboundSymbols = [];\n          ctx.unboundSymbols.set(name, unboundSymbols);\n        }\n        unboundSymbols.push(node);\n      }\n    } else if (isThisExpression(node)) {\n      let foundBinding = false;\n      let nextParent = node.parent;\n\n      while (nextParent) {\n        if (declaresThis(nextParent)) {\n          foundBinding = true;\n          break;\n        }\n\n        nextParent = nextParent.parent;\n      }\n\n      if (!foundBinding) {\n        let unboundSymbols = ctx.unboundSymbols.get('this');\n        if (!unboundSymbols) {\n          unboundSymbols = [];\n          ctx.unboundSymbols.set('this', unboundSymbols);\n        }\n        unboundSymbols.push(node);\n      }\n    }\n  },\n};\n\nfunction visitAndCaptureScoping(\n  node: NodeWithParent,\n  _parent: NodeWithParent | null,\n  ctx: DependencyVisitorContext\n) {\n  if (isVariableDeclaration(node)) {\n    let parent: NodeWithParent | undefined;\n    let nextParent = node.parent;\n\n    while (nextParent) {\n      if (node.kind === 'var' ? isScope(nextParent) : isBlockScope(nextParent)) {\n        parent = nextParent;\n        break;\n      }\n\n      nextParent = nextParent.parent;\n    }\n\n    if (!parent) {\n      throw new Error(`Invariant violation: Failed to find a parent`);\n    }\n\n    let locals = ctx.locals.get(parent);\n\n    if (!locals) {\n      locals = {};\n      ctx.locals.set(parent, locals);\n    }\n\n    for (const declaration of node.declarations) {\n      declarePattern(declaration.id, locals);\n    }\n  } else if (isFunctionDeclaration(node)) {\n    let parent: NodeWithParent | undefined;\n    let nextParent = node.parent;\n\n    if (nextParent && nextParent.parent) {\n      nextParent = nextParent.parent;\n    }\n\n    while (nextParent) {\n      if (isScope(nextParent)) {\n        parent = nextParent;\n        break;\n      }\n\n      nextParent = nextParent.parent;\n    }\n\n    if (!parent) {\n      throw new Error(`Invariant violation: Failed to find a parent`);\n    }\n\n    let locals = ctx.locals.get(parent);\n\n    if (!locals) {\n      locals = {};\n      ctx.locals.set(parent, locals);\n    }\n\n    declareFunction(node, locals);\n  } else if (isFunction(node)) {\n    let locals = ctx.locals.get(node);\n\n    if (!locals) {\n      locals = {};\n      ctx.locals.set(node, locals);\n    }\n\n    declareFunction(node, locals);\n  } else if (isClassDeclaration(node) && node.id) {\n    let parent: NodeWithParent | undefined;\n    let nextParent = node.parent;\n\n    if (nextParent && nextParent.parent) {\n      nextParent = nextParent.parent;\n    }\n\n    while (nextParent) {\n      if (isScope(nextParent)) {\n        parent = nextParent;\n        break;\n      }\n\n      nextParent = nextParent.parent;\n    }\n\n    if (!parent) {\n      throw new Error(`Invariant violation: Failed to find a parent`);\n    }\n\n    let locals = ctx.locals.get(parent);\n\n    if (!locals) {\n      locals = {};\n      ctx.locals.set(parent, locals);\n    }\n\n    locals[node.id.name] = true;\n  } else if (isTryStatement(node)) {\n    if (node.handler) {\n      let locals = ctx.locals.get(node.handler);\n\n      if (!locals) {\n        locals = {};\n        ctx.locals.set(node.handler, locals);\n      }\n\n      if (node.handler.param) {\n        declarePattern(node.handler.param, locals);\n      }\n    }\n  }\n}\n\nfunction visitAndSkipBranches(\n  node: NodeWithParent,\n  _parent: NodeWithParent | null,\n  ctx: DependencyVisitorContext\n) {\n  if (isIfStatement(node) && isBinaryExpression(node.test)) {\n    const tests = {\n      '!=': (l: string, r: string) => l != r,\n      '!==': (l: string, r: string) => l !== r,\n      '==': (l: string, r: string) => l == r,\n      '===': (l: string, r: string) => l === r,\n    } as { [key in BinaryOperator]: (l: string, r: string) => boolean };\n    const test = tests[node.test.operator];\n\n    if (test) {\n      if (\n        isStringLiteral(node.test.left) &&\n        isMemberExpression(node.test.right) &&\n        memberExpressionMatches(node.test.right, 'process.env.NODE_ENV')\n      ) {\n        let rootObject = node.test.right;\n        while (isMemberExpression(rootObject.object)) {\n          rootObject = rootObject.object;\n        }\n        if (isIdentifier(rootObject.object)) {\n          ctx.replacedSymbols.add(rootObject.object);\n        }\n\n        ctx.skipTransform.add(node.test.right);\n\n        // if ('development' === process.env.NODE_ENV) {}\n\n        if (!test(node.test.left.value, ctx.nodeEnv)) {\n          ctx.skip.add(node.consequent);\n          // We can blow away the consequent\n          ctx.magicString.remove(\n            node.start,\n            node.alternate ? node.alternate.start : node.consequent.end\n          );\n        } else {\n          // We can blow away the test\n          ctx.magicString.remove(node.start, node.consequent.start - 1);\n\n          if (node.alternate) {\n            ctx.skip.add(node.alternate);\n            // We can blow away the alternate but we need to start and the end of the consequent + 1 char\n            ctx.magicString.remove(node.consequent.end + 1, node.alternate.end);\n          }\n        }\n      } else if (\n        isStringLiteral(node.test.right) &&\n        isMemberExpression(node.test.left) &&\n        memberExpressionMatches(node.test.left, 'process.env.NODE_ENV')\n      ) {\n        let rootObject = node.test.left;\n        while (isMemberExpression(rootObject.object)) {\n          rootObject = rootObject.object;\n        }\n        if (isIdentifier(rootObject.object)) {\n          ctx.replacedSymbols.add(rootObject.object);\n        }\n\n        ctx.skipTransform.add(node.test.left);\n\n        // if (process.env.NODE_ENV === 'development') {}\n\n        if (!test(node.test.right.value, ctx.nodeEnv)) {\n          ctx.skip.add(node.consequent);\n          // We can blow away the consequent\n          ctx.magicString.remove(\n            node.start,\n            node.alternate ? node.alternate.start : node.consequent.end\n          );\n        } else {\n          // We can blow away the test and the alternate\n          ctx.magicString.remove(node.start, node.consequent.start - 1);\n\n          if (node.alternate) {\n            ctx.skip.add(node.alternate);\n            // We can blow away the alternate but we need to start and the end of the consequent + 1 char\n            ctx.magicString.remove(node.consequent.end + 1, node.alternate.end);\n          }\n        }\n      }\n    }\n  }\n}\n\nfunction visitRequires(\n  node: NodeWithParent,\n  _parent: NodeWithParent | null,\n  ctx: DependencyVisitorContext\n) {\n  if (isCallExpression(node)) {\n    const callee = node.callee;\n    if (isIdentifier(callee) && callee.name === 'require') {\n      const firstArg = node.arguments[0];\n\n      if (isStringLiteral(firstArg)) {\n        ctx.requires.push({\n          spec: { start: firstArg.start, end: firstArg.end, value: firstArg.value },\n          callee: { start: callee.start, end: callee.end },\n        });\n      } else if (\n        isTemplateLiteral(firstArg) &&\n        firstArg.expressions.length === 0 &&\n        firstArg.quasis.length === 1\n      ) {\n        ctx.requires.push({\n          spec: {\n            start: firstArg.quasis[0].start,\n            end: firstArg.quasis[0].end,\n            value: firstArg.quasis[0].value.raw,\n          },\n          callee: { start: callee.start, end: callee.end },\n        });\n      } else {\n        console.warn('Non string-literal first arg to require', firstArg);\n      }\n    } else if (\n      isMemberExpression(callee) &&\n      isIdentifier(callee.object) &&\n      callee.object.name === 'require' &&\n      isIdentifier(callee.property) &&\n      callee.property.name === 'resolve'\n    ) {\n      const firstArg = node.arguments[0];\n\n      if (isStringLiteral(firstArg)) {\n        ctx.requireResolves.push({\n          spec: { start: firstArg.start, end: firstArg.end, value: firstArg.value },\n          callee: { start: callee.start, end: callee.end },\n        });\n      } else {\n        console.warn('Non string-literal first arg to require.resolve', firstArg);\n      }\n    }\n  }\n}\n\nfunction declareFunction(node: Function, locals: { [name: string]: boolean }) {\n  node.params.forEach(function (node) {\n    declarePattern(node, locals);\n  });\n  if ((node as any).id) {\n    locals[(node as any).id.name] = true;\n  }\n}\n\nfunction declarePattern(node: Pattern, locals: { [name: string]: boolean }) {\n  if (isIdentifier(node)) {\n    locals[node.name] = true;\n  } else if (isObjectPattern(node)) {\n    node.properties.forEach((node) =>\n      isRestElement(node)\n        ? declarePattern(node.argument, locals)\n        : declarePattern(node.value, locals)\n    );\n  } else if (isArrayPattern(node)) {\n    node.elements.forEach((node) => node && declarePattern(node, locals));\n  } else if (isRestElement(node)) {\n    declarePattern(node.argument, locals);\n  } else if (isAssignmentPattern(node)) {\n    declarePattern(node.left, locals);\n  } else {\n    throw new Error(`Invariant violation: Unexpected pattern type: ${node.type}`);\n  }\n}\n\nfunction isBindingIdentifier(node: NodeWithParent) {\n  return (\n    isIdentifier(node) &&\n    !isPropertyOfMemberExpression(node) &&\n    !isKeyOfProperty(node) &&\n    !isKeyOfMethodDefinition(node)\n  );\n}\n\nfunction isKeyOfProperty(node: NodeWithParent) {\n  return node.parent && isProperty(node.parent) && node.parent.key === node;\n}\n\nfunction isPropertyOfMemberExpression(node: NodeWithParent) {\n  return node.parent && isMemberExpression(node.parent) && node.parent.object !== node;\n}\n\nfunction isKeyOfMethodDefinition(node: NodeWithParent) {\n  return node.parent && isMethodDefinition(node.parent);\n}\n\nfunction isScope(node: NodeWithParent) {\n  return (\n    isFunctionDeclaration(node) ||\n    isFunctionExpression(node) ||\n    isArrowFunctionExpression(node) ||\n    isProgram(node)\n  );\n}\n\nfunction isBlockScope(node: NodeWithParent) {\n  return isBlockStatement(node) || isScope(node);\n}\n\nfunction declaresArguments(node: NodeWithParent) {\n  return isFunctionDeclaration(node) || isFunctionExpression(node);\n}\n\nfunction declaresThis(node: NodeWithParent) {\n  return isFunctionDeclaration(node) || isFunctionExpression(node);\n}\n\nfunction memberExpressionMatches(node: MemberExpression, pattern: string) {\n  const memberParts = pattern.split('.');\n\n  if (memberParts.length < 2) {\n    return false;\n  }\n\n  const object = memberParts.shift();\n  const property = memberParts.shift();\n\n  for (let i = memberParts.length - 1; i >= 0; i--) {\n    if (!isIdentifier(node.property) || node.property.name !== memberParts[i]) {\n      return false;\n    }\n\n    if (!isMemberExpression(node.object)) {\n      return false;\n    }\n\n    node = node.object;\n  }\n\n  if (!isIdentifier(node.object) || !isIdentifier(node.property)) {\n    return false;\n  }\n\n  return node.object.name === object && node.property.name === property;\n}\n","//@ts-check\n'use strict';\n\n/**\n * @param {import('./types').VelcroStaticRuntime} velcro\n * @returns {import('./runtimeInterface').VelcroRuntime}\n */\nexport function createRuntime(velcro) {\n  if (velcro.runtime) return velcro.runtime;\n\n  /**\n   * @constructor\n   * @param {Runtime} runtime\n   * @param {string} id\n   * @param {import('./types').VelcroImportMap} importMap\n   */\n  function Module(runtime, id, importMap) {\n    this.runtime = runtime;\n    this.id = id;\n    this.importMap = importMap;\n    this.module = { exports: {} };\n    this.require = runtime.createRequire(this);\n  }\n\n  /**\n   * @constructor\n   * @param {import('./types').VelcroStaticRuntime} velcro\n   */\n  function Runtime(velcro) {\n    /** @type {Required<import('./types').VelcroImportMap>} */\n    this.importMap = { imports: {}, scopes: {} };\n    this.defs = velcro.defs;\n    /** @type {Record<string, Module | undefined>} */\n    this.modules = Object.create(null);\n    this.root = new Module(this, 'velcro:/root', {});\n    this.require = this.createRequire(this.root);\n    /** @type {Record<string, Module[] | undefined>} */\n    this.dependents = Object.create(null);\n  }\n\n  Runtime.prototype.createRequire = createRequire;\n  Runtime.prototype.inject = inject;\n  Runtime.prototype.invalidate = invalidate;\n  Runtime.prototype.resolveSpecAgainstImportMap = resolveSpecAgainstImportMap;\n\n  /**\n   *\n   * @this {Runtime}\n   * @param {Module} fromModule\n   */\n  function createRequire(fromModule) {\n    var runtime = this;\n\n    /**\n     * @param {string} spec\n     */\n    function require(spec) {\n      var id = runtime.resolveSpecAgainstImportMap(spec, fromModule);\n\n      var module = runtime.modules[id];\n\n      if (!module) {\n        var moduleDefinition = runtime.defs[id];\n\n        if (!moduleDefinition) {\n          throw new Error(`Unable to locate module '${id}' from '${fromModule.id}`);\n        }\n\n        var factory = moduleDefinition[0];\n        var importMap = moduleDefinition[1];\n\n        module = new Module(runtime, id, importMap);\n        runtime.modules[id] = module;\n\n        var specParts = id.split('/');\n        var __filename = specParts.pop() || spec;\n        var __dirname = specParts.join('/');\n\n        factory.call(\n          module.module.exports,\n          module.module,\n          module.module.exports,\n          module.require.bind(module),\n          __dirname,\n          __filename\n        );\n      }\n\n      (runtime.dependents[id] = runtime.dependents[id] || []).push(fromModule);\n\n      return module.module.exports;\n    }\n\n    /**\n     * @param {string} _spec\n     */\n    function resolve(_spec) {\n      return '';\n    }\n\n    return Object.assign(require, {\n      resolve,\n    });\n  }\n\n  /**\n   * Inject a pre-existing module\n   *\n   * @template T\n   * @this {Runtime}\n   * @param {string} id Identifier of module\n   * @param {T} exports Value that represents the exported interface of the module\n   */\n  function inject(id, exports) {\n    var module = new Module(this, id, Object.create(null));\n\n    module.module.exports = exports;\n\n    this.modules[id] = module;\n\n    return module;\n  }\n\n  /**\n   *\n   * @this {Runtime}\n   * @param {string[]} invalidations\n   */\n  function invalidate(invalidations) {\n    var queue = invalidations.slice();\n\n    while (queue.length) {\n      var id = queue.shift();\n\n      //@ts-expect-error\n      var deleted = delete this.modules[id];\n\n      /** @type {Module[] | undefined} */\n      //@ts-expect-error\n      var dependents = this.dependents[id];\n\n      if (!Array.isArray(dependents)) continue;\n\n      for (var i = 0; i < dependents.length; i++) {\n        queue.push(dependents[i].id);\n      }\n    }\n  }\n\n  /**\n   *\n   * @this {Runtime}\n   * @param {string} spec\n   * @param {Module} module\n   * @private\n   */\n  function resolveSpecAgainstImportMap(spec, module) {\n    var importMap = module.importMap;\n\n    if (!importMap.scopes) {\n      return spec;\n    }\n\n    var scopesForId = importMap.scopes[module.id];\n\n    if (!scopesForId) {\n      return spec;\n    }\n\n    var mappedId = scopesForId[spec];\n\n    if (mappedId) {\n      return mappedId;\n    }\n\n    return spec;\n  }\n\n  var runtime = new Runtime(velcro);\n\n  velcro.runtime = runtime;\n\n  return runtime;\n}\n","import { Uri } from '@velcro/common';\nimport { Bundle } from 'magic-string';\nimport { encode } from 'sourcemap-codec';\nimport { SourceMap } from './sourceMap';\nimport { ISourceMapper } from './sourceMapTree';\n\nexport class ChunkOutput {\n  private cachedCode?: string;\n  private cachedSourceMap?: SourceMap;\n  private cachedSourceMapDataUri?: string;\n  private cachedSourceMapString?: string;\n\n  constructor(\n    private readonly bundle: Bundle,\n    private readonly sourceMapTree: ISourceMapper,\n    readonly uri: Uri\n  ) {}\n\n  get code() {\n    if (typeof this.cachedCode === 'undefined') {\n      this.cachedCode = this.bundle.toString();\n    }\n\n    return this.cachedCode!;\n  }\n\n  get href() {\n    return this.uri.toString();\n  }\n\n  get sourceMap() {\n    if (typeof this.cachedSourceMap === 'undefined') {\n      this.cachedSourceMap = this.generateSourceMap();\n    }\n\n    return this.cachedSourceMap!;\n  }\n\n  get sourceMapString() {\n    if (typeof this.cachedSourceMapString === 'undefined') {\n      this.cachedSourceMapString = this.sourceMap.toString();\n    }\n\n    return this.cachedSourceMapString!;\n  }\n\n  get sourceMapDataUri() {\n    if (typeof this.cachedSourceMapDataUri === 'undefined') {\n      this.cachedSourceMapDataUri = this.sourceMap.toDataUri();\n    }\n\n    return this.cachedSourceMapDataUri!;\n  }\n\n  private generateSourceMap() {\n    const sourceMapTreeMappings = this.sourceMapTree.traceMappings();\n\n    if (sourceMapTreeMappings instanceof Error) {\n      return new SourceMap({\n        file: this.href,\n        mappings: '',\n        names: [],\n        sources: [],\n        version: 3,\n        sourcesContent: [],\n      });\n    }\n\n    // Loop through generated mappings, removing mappings that are character-by-character increments\n    // from the previous mapping. Since we generated a hires bundle, this will shrink the resolution\n    // back down to something not unnecessarily large.\n    // for (const line of sourceMapTreeMappings.mappings) {\n    //   let lastSegment: SourceMapSegment | null = null;\n    //   const shrinkedLine: SourceMapSegment[] = [];\n\n    //   for (const segment of line) {\n    //     if (lastSegment && lastSegment.length >= 4 && lastSegment.length === segment.length) {\n    //       // We will only push the segment if it is not, effectively a direct cursor move of the\n    //       // last one.\n    //       // For example:\n    //       //   lastSegment = [1, 0, 0, 1] // Generated column 1, original column 1 of the 0th file, 0th line\n    //       //   segment = [2, 0, 0, 2] // Generated column 2, original column 2 of the 0th file, 0th line\n    //       // Given that, we can see that this segment is not adding any _new_ information so we can skip it.\n    //       if (\n    //         lastSegment.length >= 4 &&\n    //         (lastSegment[0] + 1 !== segment[0] ||\n    //           lastSegment[1] !== segment[1] ||\n    //           lastSegment[2] !== segment[2] ||\n    //           lastSegment[3]! + 1 !== segment[3] ||\n    //           lastSegment[4] !== segment[4])\n    //       ) {\n    //         shrinkedLine.push(segment);\n    //       }\n    //     } else {\n    //       shrinkedLine.push(segment);\n    //     }\n\n    //     lastSegment = segment;\n    //   }\n\n    //   // line.splice(0, line.length, ...shrinkedLine);\n    // }\n\n    const sourceMap = new SourceMap({\n      file: this.href,\n      mappings: encode(sourceMapTreeMappings.mappings),\n      names: sourceMapTreeMappings.names,\n      sources: sourceMapTreeMappings.sources,\n      version: 3,\n      sourcesContent: sourceMapTreeMappings.sourcesContent,\n    });\n\n    return sourceMap;\n  }\n}\n","import { MapSet, Uri } from '@velcro/common';\nimport { Bundle } from 'magic-string';\nimport { DependencyEdge } from '../graph/dependencyEdge';\nimport { SourceModule } from '../graph/sourceModule';\nimport { createRuntime } from '../runtime/runtime';\nimport { VelcroImportMap, VelcroStaticRuntime } from '../runtime/types';\nimport { ChunkOutput } from './chunkOutput';\nimport { LazyLink, Link, Source } from './sourceMapTree';\n\ntype NotUndefined<T> = T extends undefined ? never : T;\n\nexport class Chunk {\n  private readonly edgesFrom = new MapSet<string, DependencyEdge>();\n  private readonly edgesTo = new MapSet<string, DependencyEdge>();\n  //@ts-ignore\n  private readonly rootUri: Uri;\n  private readonly sourceModules = new Map<string, SourceModule>();\n\n  constructor(options: Chunk.Options) {\n    this.rootUri = options.rootUri;\n\n    for (const sourceModule of options.sourceModules) {\n      this.sourceModules.set(sourceModule.href, sourceModule);\n    }\n\n    for (const edge of options.edges) {\n      const fromHref = edge.fromUri.toString();\n      const toHref = edge.toUri.toString();\n\n      this.edgesFrom.add(fromHref, edge);\n      this.edgesTo.add(toHref, edge);\n    }\n  }\n\n  buildForStaticRuntime(options?: Chunk.ToStringOptions) {\n    // const velcroModuleFactoryParts = velcroModuleFactory\n    //   .toString()\n    //   .split(velcroModuleFactory.splitString);\n    // const velcroChunkWrapperParts = velcroChunkWrapper\n    //   .toString()\n    //   .split(velcroChunkWrapper.splitString);\n\n    const bundle = new Bundle({\n      separator: '\\n',\n    });\n\n    for (const sourceModule of this.sourceModules.values()) {\n      const moduleScopes: NotUndefined<NotUndefined<VelcroImportMap['scopes']>[string]> = {};\n      const scopes: NotUndefined<VelcroImportMap['scopes']> = {\n        [sourceModule.href]: moduleScopes,\n      };\n      const importMap: VelcroImportMap = { scopes };\n      const edgesFrom = this.edgesFrom.get(sourceModule.href);\n\n      if (edgesFrom) {\n        for (const edge of edgesFrom) {\n          moduleScopes[edge.dependency.spec] = edge.toUri.toString();\n        }\n      }\n      const sourceModuleCode = sourceModule.source.clone();\n\n      sourceModuleCode.prepend(\n        `velcro.defs[${JSON.stringify(\n          sourceModule.uri.toString()\n        )}] = [function(module,exports,require,__dirname,__filename){\\n`\n      );\n      sourceModuleCode.append(`\\n},${JSON.stringify(importMap)}];`);\n      bundle.addSource(sourceModuleCode);\n    }\n\n    const velcroStaticRuntime: VelcroStaticRuntime = { defs: {} };\n\n    bundle.prepend(`(function(velcro){\\n`);\n    bundle.prepend(\n      `if (typeof Velcro === 'undefined') Velcro = Object.create(null);\\nif (typeof Velcro.registry === 'undefined') Velcro.registry = ${JSON.stringify(\n        velcroStaticRuntime\n      )};\\n`\n    );\n    bundle.append(`\\n})(Velcro.registry);\\n`);\n\n    if (options && options.injectRuntime) {\n      bundle.append(`\\nVelcro.runtime = ${createRuntime.toString()}(Velcro.registry);\\n`);\n    }\n\n    if (options && options.invalidations) {\n      if (!options.injectRuntime) {\n        throw new Error(\n          'Setting injectRuntime to true is required when calling buildForStaticRuntime and specifying invalidations'\n        );\n      }\n\n      bundle.append(`\\nVelcro.runtime.invalidate(${JSON.stringify(options.invalidations)});\\n`);\n    }\n\n    const sourceMapTree = new LazyLink(() => {\n      const inputMap = bundle.generateDecodedMap({\n        includeContent: false,\n        hires: true,\n        source: this.rootUri.toString(),\n      });\n      return new Link(\n        inputMap,\n        inputMap.sources.map((sourceHref) => {\n          const sourceModule = this.sourceModules.get(sourceHref);\n\n          if (!sourceModule) {\n            return new Source(sourceHref, 'SOURCEMAP ERROR');\n          }\n\n          // All of the transformations included in the source module's magicString\n          // were baked into the bundle already. We just need to map these into any\n          // earlier sources.\n          return sourceModule.sourceMapsTree;\n        })\n      );\n    });\n\n    return new ChunkOutput(bundle, sourceMapTree, this.rootUri);\n  }\n}\n\nexport namespace Chunk {\n  export interface Options {\n    edges: Iterable<DependencyEdge>;\n    rootUri: Uri;\n    sourceModules: Iterable<SourceModule>;\n  }\n\n  export interface ToStringOptions {\n    /**\n     * Toggle whether to inject the runtime in the generated code.\n     *\n     * An instance of the runtime is important as it is what will actually schedule\n     * and execute code built for Velcro.\n     *\n     * When `injectRuntime` is `true`, the runtime code will be injected and the\n     * instance of it will be exposed as `Velcro.runtime`.\n     */\n    injectRuntime?: boolean;\n    invalidations?: string[];\n  }\n}\n","import { MapSet, Uri } from '@velcro/common';\nimport { Chunk } from '../build/chunk';\nimport { DependencyEdge } from './dependencyEdge';\nimport { SourceModule } from './sourceModule';\n\nexport class Graph {\n  private readonly edgesFrom = new MapSet<string, DependencyEdge>();\n  private readonly edgesTo = new MapSet<string, DependencyEdge>();\n  //@ts-ignore\n  private readonly rootUri: Uri;\n  private readonly sourceModules = new Map<string, SourceModule>();\n\n  constructor(options: Graph.Options) {\n    this.rootUri = options.rootUri;\n\n    for (const sourceModule of options.sourceModules) {\n      this.sourceModules.set(sourceModule.href, sourceModule);\n    }\n\n    for (const edge of options.edges) {\n      const fromHref = edge.fromUri.toString();\n      const toHref = edge.toUri.toString();\n\n      this.edgesFrom.add(fromHref, edge);\n      this.edgesTo.add(toHref, edge);\n    }\n  }\n\n  splitChunks(): Iterable<Chunk> {\n    return [\n      new Chunk({\n        edges: this.edgesFrom.values(),\n        rootUri: Uri.joinPath(this.rootUri, './chunk/0.js'),\n        sourceModules: this.sourceModules.values(),\n      }),\n    ];\n  }\n}\n\nexport namespace Graph {\n  export interface Options {\n    edges: Iterable<DependencyEdge>;\n    rootUri: Uri;\n    sourceModules: Iterable<SourceModule>;\n  }\n}\n","import { version as nodeLibsVersion } from '@velcro/node-libs/package.json';\n\nexport const DEFAULT_SHIM_GLOBALS: Record<\n  string,\n  { spec: string; export?: string } | undefined\n> = Object.assign(Object.create(null), {\n  Buffer: {\n    spec: `@velcro/node-libs@${nodeLibsVersion}/lib/buffer.js`,\n    export: 'Buffer',\n  },\n  global: {\n    spec: `@velcro/node-libs@${nodeLibsVersion}/lib/global.js`,\n  },\n  globalThis: {\n    spec: `@velcro/node-libs@${nodeLibsVersion}/lib/global.js`,\n  },\n  process: {\n    spec: `@velcro/node-libs@${nodeLibsVersion}/lib/process.js`,\n  },\n});\n","import { Uri } from '@velcro/common';\nimport { ResolverContext } from '@velcro/resolver';\nimport MagicString from 'magic-string';\nimport { Link, Source } from '../build/sourceMapTree';\nimport { SourceModuleDependency } from './sourceModuleDependency';\n\nexport class SourceModule {\n  constructor(\n    readonly uri: Uri,\n    readonly rootUri: Uri,\n    readonly source: MagicString,\n    readonly dependencies: Set<SourceModuleDependency>,\n    readonly sourceMapsTree: Source | Link,\n    readonly visits: ResolverContext.Visit[]\n  ) {}\n\n  get href() {\n    return this.uri.toString();\n  }\n\n  get rootHref() {\n    return this.rootUri.toString();\n  }\n}\n","import {\n  CancellationToken,\n  CancellationTokenSource,\n  DisposableStore,\n  Emitter,\n  Event,\n  isCanceledError,\n  MapSet,\n  Uri,\n} from '@velcro/common';\nimport { Resolver, ResolverContext } from '@velcro/resolver';\nimport { Plugin, PluginManager } from '../plugins';\nimport { parse } from './commonjs';\nimport { DependencyEdge } from './dependencyEdge';\nimport { Graph } from './graph';\nimport { DEFAULT_SHIM_GLOBALS } from './shims';\nimport { SourceModule } from './sourceModule';\nimport { SourceModuleDependency } from './sourceModuleDependency';\n\ntype ExternalTestFunction = (\n  dependency: SourceModuleDependency,\n  fromSourceModule: SourceModule\n) => boolean;\n\nexport class Build {\n  private readonly disposer = new DisposableStore();\n  private readonly edges = new Set<DependencyEdge>();\n  readonly errors: Error[] = [];\n  readonly seen = new Set<unknown>();\n  private readonly sourceModules = new Map<string, SourceModule>();\n\n  private readonly pendingModuleOperations = new MapSet<string, Promise<unknown>>();\n  private readonly tokenSource: CancellationTokenSource;\n\n  private readonly onCompletedEmitter = new Emitter<{ graph: Graph }>();\n  private readonly onErrorEmitter = new Emitter<{ error: Error }>();\n  private readonly onProgressEmitter = new Emitter<{\n    progress: {\n      completed: number;\n      pending: number;\n    };\n  }>();\n\n  readonly done = new Promise<Graph>((resolve, reject) => {\n    this.disposer.add(this.onCompleted(({ graph }) => resolve(graph)));\n    this.disposer.add(this.onError(({ error }) => reject(error)));\n  });\n\n  constructor(readonly rootUri: Uri, options: { token?: CancellationToken } = {}) {\n    this.tokenSource = new CancellationTokenSource(options.token);\n\n    this.disposer.add(this.tokenSource);\n    this.done.catch(() => {\n      // Prevent uncaught rejection\n    });\n  }\n\n  get onCompleted(): Event<{ graph: Graph }> {\n    return this.onCompletedEmitter.event;\n  }\n\n  get onError(): Event<{ error: Error }> {\n    return this.onErrorEmitter.event;\n  }\n\n  get onProgress(): Event<{\n    progress: {\n      completed: number;\n      pending: number;\n    };\n  }> {\n    return this.onProgressEmitter.event;\n  }\n\n  get token() {\n    return this.tokenSource.token;\n  }\n\n  addEdge(edge: DependencyEdge) {\n    this.edges.add(edge);\n  }\n\n  addSourceModule(sourceModule: SourceModule) {\n    this.sourceModules.set(sourceModule.href, sourceModule);\n  }\n\n  cancel() {\n    this.tokenSource.cancel();\n  }\n\n  dispose() {\n    this.cancel();\n    this.disposer.dispose();\n  }\n\n  hasSourceModule(href: string) {\n    return this.sourceModules.has(href);\n  }\n\n  runAsync(key: string, fn: () => Promise<unknown>): void {\n    if (this.token.isCancellationRequested) {\n      return;\n    }\n\n    const onError = (err: Error) => {\n      if (ret) {\n        this.pendingModuleOperations.delete(key, ret);\n      }\n      this.cancel();\n\n      if (!isCanceledError(err)) {\n        this.errors.push(err);\n\n        this.onErrorEmitter.fire({ error: err });\n      }\n    };\n    const onSuccess = () => {\n      this.pendingModuleOperations.delete(key, ret);\n\n      if (!this.pendingModuleOperations.size) {\n        this.onCompletedEmitter.fire({\n          graph: new Graph({\n            edges: this.edges,\n            rootUri: this.rootUri,\n            sourceModules: this.sourceModules.values(),\n          }),\n        });\n      } else {\n        this.onProgressEmitter.fire({\n          progress: {\n            completed: this.sourceModules.size,\n            pending: this.pendingModuleOperations.size,\n          },\n        });\n      }\n    };\n\n    let ret: ReturnType<typeof fn>;\n\n    try {\n      ret = fn().then(onSuccess, onError);\n      this.pendingModuleOperations.add(key, ret);\n    } catch (err) {\n      onError(err);\n    }\n  }\n}\n\nexport class GraphBuilder {\n  private readonly edgesByDependency = new WeakMap<SourceModuleDependency, DependencyEdge>();\n  private readonly edgesByInvalidation = new MapSet<string, DependencyEdge>();\n  private readonly external?: ExternalTestFunction;\n  private readonly nodeEnv: string;\n  private readonly resolver: Resolver;\n  private readonly pluginManager: PluginManager;\n  private readonly sourceModules = new Map<string, SourceModule>();\n  private readonly sourceModulesByInvalidation = new MapSet<string, SourceModule>();\n\n  constructor(options: GraphBuilder.Options) {\n    this.resolver = options.resolver;\n    this.external = options.external;\n    this.nodeEnv = options.nodeEnv || 'development';\n    this.pluginManager = new PluginManager(options.plugins || []);\n  }\n\n  private loadDependency(build: Build, sourceModule: SourceModule, dep: SourceModuleDependency) {\n    if (build.seen.has(dep)) return;\n    build.seen.add(dep);\n\n    if (this.external && this.external(dep, sourceModule)) {\n      return;\n    }\n\n    // console.debug('loadDependency(%s, %s)', sourceModule.href, dep.spec);\n\n    build.runAsync(`${sourceModule.href}|${dep.spec}`, async () => {\n      const result = await this.pluginManager.executeResolveDependency(\n        {\n          nodeEnv: this.nodeEnv,\n          resolver: this.resolver,\n          token: build.token,\n        },\n        dep,\n        sourceModule\n      );\n      const edge = this.createEdge(\n        sourceModule.uri,\n        sourceModule.rootUri,\n        result.uri,\n        result.rootUri,\n        result.visited,\n        dep\n      );\n\n      build.addEdge(edge);\n\n      this.loadEdge(build, edge);\n    });\n  }\n\n  private loadEdge(build: Build, edge: DependencyEdge) {\n    const href = edge.toUri.toString();\n\n    if (build.hasSourceModule(href)) return;\n\n    const existingSourceModule = this.sourceModules.get(href);\n\n    if (existingSourceModule) {\n      build.addSourceModule(existingSourceModule);\n\n      return this.visitSourceModule(build, existingSourceModule);\n    }\n\n    // console.debug(\n    //   'loadEdge(%s, %s, %s)',\n    //   edge.fromUri.toString(),\n    //   edge.dependency.spec,\n    //   edge.toUri.toString()\n    // );\n\n    build.runAsync(href, async () => {\n      // We need to check again in case another 'thread' already produced this\n      // sourceModule\n      if (build.hasSourceModule(href)) return;\n\n      const loadResult = await this.pluginManager.executeLoad(\n        {\n          nodeEnv: this.nodeEnv,\n          resolver: this.resolver,\n          token: build.token,\n        },\n        edge.toUri\n      );\n\n      // We need to check again in case another 'thread' already produced this\n      // sourceModule\n      if (build.hasSourceModule(href)) return;\n\n      const transformResult = await this.pluginManager.executeTransform(\n        {\n          nodeEnv: this.nodeEnv,\n          resolver: this.resolver,\n          token: build.token,\n        },\n        edge.toUri,\n        loadResult.code\n      );\n\n      // We need to check again in case another 'thread' already produced this\n      // sourceModule\n      if (build.hasSourceModule(href)) return;\n\n      const parseResult = parse(edge.toUri, transformResult.code, {\n        globalModules: DEFAULT_SHIM_GLOBALS,\n        nodeEnv: this.nodeEnv,\n      });\n      const sourceModule = new SourceModule(\n        edge.toUri,\n        edge.toRootUri,\n        parseResult.code,\n        new Set(parseResult.dependencies),\n        transformResult.sourceMapTree,\n        [...transformResult.visited, ...loadResult.visited]\n      );\n\n      build.addSourceModule(sourceModule);\n      this.sourceModules.set(sourceModule.href, sourceModule);\n\n      for (const visit of sourceModule.visits) {\n        this.sourceModulesByInvalidation.add(visit.uri.toString(), sourceModule);\n      }\n\n      this.sourceModulesByInvalidation.add(sourceModule.href, sourceModule);\n\n      this.visitSourceModule(build, sourceModule);\n    });\n  }\n\n  private loadEntrypoint(build: Build, uri: Uri) {\n    const href = uri.toString();\n\n    // console.debug('loadEntrypoint(%s)', href);\n    build.runAsync(href, async () => {\n      const result = await this.pluginManager.executeResolveEntrypoint(\n        {\n          nodeEnv: this.nodeEnv,\n          resolver: this.resolver,\n          token: build.token,\n        },\n        uri\n      );\n      const edge = this.createEdge(\n        build.rootUri,\n        build.rootUri,\n        result.uri,\n        result.rootUri,\n        result.visited,\n        SourceModuleDependency.fromEntrypoint(uri)\n      );\n\n      this.loadEdge(build, edge);\n    });\n  }\n\n  private visitSourceModule(build: Build, sourceModule: SourceModule) {\n    if (build.seen.has(sourceModule)) return;\n    build.seen.add(sourceModule);\n\n    // console.debug('visitSourceModule(%s)', sourceModule.href);\n    for (const dep of sourceModule.dependencies) {\n      const existingEdge = this.edgesByDependency.get(dep);\n\n      if (existingEdge) {\n        build.addEdge(existingEdge);\n\n        this.loadEdge(build, existingEdge);\n      } else {\n        this.loadDependency(build, sourceModule, dep);\n      }\n    }\n  }\n\n  build(\n    entrypoints: (string | Uri)[],\n    options: { incremental?: boolean; token?: CancellationToken } = {}\n  ) {\n    const rootUri = Uri.parse('velcro:/');\n    const build = new Build(rootUri, { token: options.token });\n\n    for (const uri of entrypoints) {\n      this.loadEntrypoint(build, Uri.isUri(uri) ? uri : Uri.parse(uri));\n    }\n\n    return build;\n  }\n\n  invalidate(uri: Uri | string) {\n    const href = Uri.isUri(uri) ? uri.toString() : uri;\n    const sourceModules = this.sourceModulesByInvalidation.get(href);\n\n    if (sourceModules) {\n      for (const sourceModule of sourceModules) {\n        this.sourceModules.delete(sourceModule.href);\n      }\n      this.sourceModulesByInvalidation.deleteAll(href);\n    }\n\n    this.sourceModules.delete(href);\n\n    const edges = this.edgesByInvalidation.get(href);\n\n    if (edges) {\n      for (const edge of edges) {\n        this.edgesByDependency.delete(edge.dependency);\n      }\n      this.edgesByInvalidation.deleteAll(href);\n    }\n\n    this.resolver.invalidate(uri);\n  }\n\n  private createEdge(\n    fromUri: Uri,\n    fromRootUri: Uri,\n    toUri: Uri,\n    toRootUri: Uri,\n    visited: ResolverContext.Visit[],\n    dependency: SourceModuleDependency\n  ) {\n    const edge = { dependency, fromUri, fromRootUri, toUri, toRootUri, visited };\n\n    this.edgesByDependency.set(dependency, edge);\n\n    this.edgesByInvalidation.add(toUri.toString(), edge);\n    for (const visit of visited) {\n      this.edgesByInvalidation.add(visit.uri.toString(), edge);\n    }\n\n    return edge;\n  }\n}\n\nexport namespace GraphBuilder {\n  export interface Options {\n    external?: ExternalTestFunction;\n    nodeEnv?: string;\n    plugins?: Plugin[];\n    resolver: Resolver;\n  }\n}\n","import {\n  all,\n  basename,\n  CancellationToken,\n  checkCancellation,\n  EntryNotFoundError,\n  isThenable,\n  PackageJson,\n  parseBufferAsPackageJson,\n  Thenable,\n  Uri,\n} from '@velcro/common';\nimport {\n  AbstractResolverStrategyWithRoot,\n  ResolverContext,\n  ResolverStrategy,\n  ResolverStrategyWithRoot,\n} from '@velcro/resolver';\nimport { satisfies, validRange } from 'semver';\n\ninterface AbstractCdn {\n  name: string;\n\n  isValidUrl(url: Uri): boolean;\n  normalizePackageListing(result: unknown): CdnStrategy.Directory;\n  parseUrl(url: Uri | string): CdnStrategy.Spec;\n  urlForPackageFile(spec: string, pathname: string): Uri;\n  urlForPackageList(spec: string): Uri;\n}\n\nfunction isValidEntry(entry: unknown): entry is CdnStrategy.Entry {\n  if (!entry || typeof entry !== 'object') return false;\n\n  return isValidFile(entry) || isValidDirectory(entry);\n}\n\nfunction isValidDirectory(entry: unknown): entry is CdnStrategy.Directory {\n  return (\n    typeof entry === 'object' &&\n    entry &&\n    (entry as any).type === ResolverStrategy.EntryKind.Directory &&\n    typeof (entry as any).path === 'string' &&\n    (entry as any).path &&\n    (typeof (entry as any).files === 'undefined' ||\n      (Array.isArray((entry as any).files) && (entry as any).files.every(isValidEntry)))\n  );\n}\n\nfunction isValidFile(entry: unknown): entry is File {\n  return (\n    typeof entry === 'object' &&\n    entry &&\n    (entry as any).type === ResolverStrategy.EntryKind.File &&\n    typeof (entry as any).path === 'string' &&\n    (entry as any).path\n  );\n}\n\nfunction specToString(spec: CdnStrategy.Spec) {\n  return `${spec.spec}${spec.pathname}`;\n}\n\nclass JSDelivrCdn implements AbstractCdn {\n  name = 'jsdelivr';\n\n  private readonly specRx = /^\\/((@[^/]+\\/[^/@]+|[^/@]+)(?:@([^/]+))?)(.*)?$/;\n\n  isValidUrl(url: Uri) {\n    return url.scheme === JSDelivrCdn.protocol || url.authority === JSDelivrCdn.host;\n  }\n\n  normalizePackageListing(result: unknown): CdnStrategy.Directory {\n    if (!result || typeof result !== 'object') {\n      throw new Error(`Unexpected package listing contents`);\n    }\n\n    const files = (result as any).files;\n\n    if (!Array.isArray(files)) {\n      throw new Error(`Unexpected package listing contents`);\n    }\n\n    const mapChildEntry = (parent: string, child: unknown): CdnStrategy.Entry => {\n      if (!child || typeof child !== 'object') {\n        throw new Error(`Unexpected entry in package listing contents`);\n      }\n\n      const name = (child as any).name;\n\n      if (typeof name !== 'string') {\n        throw new Error(`Unexpected entry in package listing contents`);\n      }\n\n      const path = `${parent}/${name}`;\n\n      if ((child as any).type === ResolverStrategy.EntryKind.Directory) {\n        const files = (child as any).files;\n\n        if (!Array.isArray(files)) {\n          throw new Error(`Unexpected entry in package listing contents`);\n        }\n        return {\n          type: ResolverStrategy.EntryKind.Directory,\n          path,\n          files: files.map((file) => mapChildEntry(path, file)),\n        };\n      } else if ((child as any).type === ResolverStrategy.EntryKind.File) {\n        return {\n          type: ResolverStrategy.EntryKind.File,\n          path,\n        };\n      }\n\n      throw new Error(`Error mapping child entry in package file listing`);\n    };\n\n    return {\n      type: ResolverStrategy.EntryKind.Directory,\n      path: '/',\n      files: files.map((file) => mapChildEntry('', file)),\n    };\n  }\n\n  parseUrl(url: Uri | string) {\n    if (Uri.isUri(url)) {\n      url = url.path;\n    }\n\n    const prefix = `/npm`;\n\n    if (!url.startsWith(prefix)) {\n      throw new Error(`Unable to parse unexpected ${this.name} url: ${url}`);\n    }\n\n    url = url.slice(prefix.length);\n\n    /**\n     * 1: scope + name + version\n     * 2: scope + name\n     * 3: version?\n     * 4: pathname\n     */\n    const matches = url.match(this.specRx);\n\n    if (!matches) {\n      throw new Error(`Unable to parse unexpected unpkg url: ${url}`);\n    }\n\n    return {\n      spec: matches[1],\n      name: matches[2],\n      version: matches[3] || '',\n      pathname: matches[4] || '',\n    };\n  }\n\n  urlForPackageFile(spec: string, pathname: string): Uri {\n    return Uri.from({\n      scheme: JSDelivrCdn.protocol,\n      authority: JSDelivrCdn.host,\n      path: `/npm/${spec}${pathname}`,\n    });\n  }\n\n  urlForPackageList(spec: string): Uri {\n    return Uri.from({\n      scheme: JSDelivrCdn.protocol,\n      authority: JSDelivrCdn.dataHost,\n      path: `/v1/package/npm/${spec}/tree`,\n    });\n  }\n\n  static readonly protocol = 'https';\n  static readonly host = 'cdn.jsdelivr.net';\n  static readonly dataHost = 'data.jsdelivr.com';\n}\n\nclass UnpkgCdn implements AbstractCdn {\n  name = 'unpkg';\n\n  private readonly UNPKG_SPEC_RX = /^\\/((@[^/]+\\/[^/@]+|[^/@]+)(?:@([^/]+))?)(.*)?$/;\n\n  isValidUrl(url: Uri) {\n    return url.scheme === UnpkgCdn.protocol || url.authority === UnpkgCdn.host;\n  }\n\n  normalizePackageListing(result: unknown) {\n    if (!isValidDirectory(result)) {\n      throw new Error(`Error normalizing directory listing`);\n    }\n\n    return result;\n  }\n\n  parseUrl(url: Uri | string) {\n    if (Uri.isUri(url)) {\n      url = url.path;\n    }\n\n    /**\n     * 1: scope + name + version\n     * 2: scope + name\n     * 3: version?\n     * 4: pathname\n     */\n    const matches = url.match(this.UNPKG_SPEC_RX);\n\n    if (!matches) {\n      throw new Error(`Unable to parse unexpected unpkg url: ${url}`);\n    }\n\n    return {\n      spec: matches[1],\n      name: matches[2],\n      version: matches[3] || '',\n      pathname: matches[4] || '',\n    };\n  }\n\n  urlForPackageFile(spec: string, pathname: string): Uri {\n    return Uri.from({\n      scheme: UnpkgCdn.protocol,\n      authority: UnpkgCdn.host,\n      path: `/${spec}${pathname}`,\n    });\n  }\n\n  urlForPackageList(spec: string) {\n    return Uri.from({\n      scheme: UnpkgCdn.protocol,\n      authority: UnpkgCdn.host,\n      path: `/${spec}/`,\n      query: 'meta',\n    });\n  }\n\n  static readonly protocol = 'https';\n  static readonly host = 'unpkg.com';\n}\n\nexport namespace CdnStrategy {\n  export type Spec = {\n    spec: string;\n    name: string;\n    version: string;\n    pathname: string;\n  };\n\n  export type Directory = {\n    type: ResolverStrategy.EntryKind.Directory;\n    path: string;\n    files?: ReadonlyArray<Entry>;\n  };\n  export type File = {\n    type: ResolverStrategy.EntryKind.File;\n    path: string;\n  };\n  export type Entry = Directory | File;\n\n  export type UrlContentFetcher = (\n    href: string,\n    token: CancellationToken\n  ) => Thenable<ArrayBuffer | null>;\n}\n\nexport class CdnStrategy extends AbstractResolverStrategyWithRoot\n  implements ResolverStrategyWithRoot {\n  private readonly cdn: AbstractCdn;\n  private readonly contentCache = new Map<\n    string,\n    null | { content: ArrayBuffer } | Thenable<{ content: ArrayBuffer }>\n  >();\n  private readonly locks = new Map<string, unknown | Thenable<unknown>>();\n  private readonly packageEntriesCache = new Map<string, Map<string, CdnStrategy.Directory>>();\n  private readonly packageJsonCache = new Map<\n    string,\n    Map<string, { packageJson: PackageJson; visited: ResolverContext.Visit[] }>\n  >();\n  private readonly readUrlFn: CdnStrategy.UrlContentFetcher;\n\n  private constructor(readUrlFn: CdnStrategy.UrlContentFetcher, cdn: AbstractCdn) {\n    super(cdn.urlForPackageFile('', ''));\n\n    this.cdn = cdn;\n    this.readUrlFn = readUrlFn;\n  }\n\n  private _withRootUriCheck<T extends unknown | Thenable<unknown>>(\n    uri: Uri,\n    fn: (rootUri: Uri) => T\n  ): T {\n    if (!Uri.isPrefixOf(this.rootUri, uri)) {\n      throw new Error(\n        `This strategy is only able to handle URIs under '${this.rootUri.toString()}' and is unable to handle '${uri.toString()}'`\n      );\n    }\n\n    return fn(this.rootUri);\n  }\n\n  async getUrlForBareModule(\n    ctx: ResolverContext,\n    name: string,\n    spec: string,\n    path: string\n  ): Promise<ResolverStrategy.BareModuleResult> {\n    const unresolvedUri = this.cdn.urlForPackageFile(`${name}@${spec}`, path);\n    const resolveReturn = await ctx.resolveUri(unresolvedUri);\n\n    return resolveReturn;\n  }\n\n  getCanonicalUrl(ctx: ResolverContext, uri: Uri): Promise<ResolverStrategy.CanonicalizeResult> {\n    return this._withRootUriCheck(uri, async () => {\n      const unresolvedSpec = this.cdn.parseUrl(uri);\n      const packageJsonReturn = ctx.runInChildContext(\n        'CdnStrategy._readPackageJsonWithCache',\n        specToString(unresolvedSpec),\n        (ctx) => this._readPackageJsonWithCache(ctx, unresolvedSpec)\n      );\n      const packageJson = isThenable(packageJsonReturn)\n        ? await packageJsonReturn\n        : packageJsonReturn;\n\n      return {\n        uri: this.cdn.urlForPackageFile(\n          `${packageJson.name}@${packageJson.version}`,\n          unresolvedSpec.pathname\n        ),\n      };\n    });\n    // const results = all([ctx.getRootUrl(uri), ctx.getResolveRoot(uri)], ctx.token);\n    // const [rootUriResult, resolveRootResult] = isThenable(results) ? await results : results;\n  }\n\n  getResolveRoot(ctx: ResolverContext, uri: Uri): Promise<ResolverStrategy.ResolveRootResult> {\n    return this._withRootUriCheck(uri, async () => {\n      const unresolvedSpec = this.cdn.parseUrl(uri);\n      const packageJsonReturn = this._readPackageJsonWithCache(ctx, unresolvedSpec);\n      const packageJson = isThenable(packageJsonReturn)\n        ? await packageJsonReturn\n        : packageJsonReturn;\n\n      return {\n        uri: this.cdn.urlForPackageFile(`${packageJson.name}@${packageJson.version}`, '/'),\n      };\n    });\n  }\n\n  getRootUrl() {\n    return {\n      uri: this.cdn.urlForPackageFile('', ''),\n    };\n  }\n\n  listEntries(ctx: ResolverContext, uri: Uri): Promise<ResolverStrategy.ListEntriesResult> {\n    return this._withRootUriCheck(\n      uri,\n      async (): Promise<ResolverStrategy.ListEntriesResult> => {\n        const unresolvedSpec = this.cdn.parseUrl(uri);\n        const results = all(\n          [\n            ctx.getResolveRoot(uri),\n            this._readPackageJsonWithCache(ctx, unresolvedSpec),\n            this._readPackageEntriesWithCache(ctx, unresolvedSpec),\n          ],\n          ctx.token\n        );\n\n        const [{ uri: resolveRootUri }, packageJson, entriesReturn] = isThenable(results)\n          ? await results\n          : results;\n        const canonicalizedSpec: CdnStrategy.Spec = {\n          name: packageJson.name,\n          pathname: unresolvedSpec.pathname,\n          spec: `${packageJson.name}@${packageJson.version}`,\n          version: packageJson.version,\n        };\n\n        // Proactively cache the canonicalized package entries\n        this.packageEntriesCache.get(packageJson.name)!.set(packageJson.version, entriesReturn);\n\n        const traversalSegments = canonicalizedSpec.pathname.split('/').filter(Boolean);\n\n        let parentEntry: CdnStrategy.Directory | undefined = entriesReturn;\n\n        while (parentEntry && traversalSegments.length) {\n          const segment = traversalSegments.shift() as string;\n\n          if (parentEntry.type !== ResolverStrategy.EntryKind.Directory || !parentEntry.files) {\n            throw new EntryNotFoundError(uri);\n          }\n\n          parentEntry = parentEntry.files.find(\n            (file) =>\n              file.type === ResolverStrategy.EntryKind.Directory && basename(file.path) === segment\n          ) as CdnStrategy.Directory | undefined;\n        }\n\n        if (!parentEntry) {\n          throw new EntryNotFoundError(uri);\n        }\n\n        if (!parentEntry.files) {\n          return {\n            entries: [],\n          };\n        }\n\n        return {\n          entries: parentEntry.files.map((entry) => {\n            return {\n              type: entry.type,\n              uri: Uri.joinPath(resolveRootUri, `.${entry.path}`),\n            };\n          }),\n        };\n      }\n    );\n  }\n\n  readFileContent(ctx: ResolverContext, uri: Uri) {\n    return this._withRootUriCheck(uri, () => {\n      const uriStr = uri.toString();\n      const cached = this.contentCache.get(uriStr);\n\n      if (cached === null) {\n        return Promise.reject(new EntryNotFoundError(uri));\n      }\n\n      if (cached) {\n        return cached;\n      }\n\n      ctx.recordVisit(uri, ResolverContext.VisitKind.File);\n      const readReturn = this.readUrlFn(uriStr, ctx.token);\n\n      if (readReturn === null) {\n        this.contentCache.set(uriStr, null);\n\n        return Promise.reject(new EntryNotFoundError(uri));\n      }\n\n      if (isThenable(readReturn)) {\n        const wrappedReturn = readReturn.then((data) => {\n          if (data === null) {\n            this.contentCache.delete(uriStr);\n\n            return Promise.reject(new EntryNotFoundError(uri));\n          }\n\n          const entry = { content: data };\n\n          this.contentCache.set(uriStr, entry);\n\n          return entry;\n        });\n\n        this.contentCache.set(uriStr, wrappedReturn);\n\n        return wrappedReturn;\n      }\n\n      const entry = { content: readReturn };\n      this.contentCache.set(uriStr, entry);\n\n      return entry;\n    });\n  }\n\n  private _readPackageEntriesWithCache(ctx: ResolverContext, spec: CdnStrategy.Spec) {\n    ctx.debug('%s._readPackageEntriesWithCache(%s)', this.constructor.name, specToString(spec));\n\n    return this._withLock(`packageEntries:${spec.name}`, () => {\n      let packageEntriesCacheForModule = this.packageEntriesCache.get(spec.name);\n\n      if (packageEntriesCacheForModule) {\n        const exactMatch = packageEntriesCacheForModule.get(spec.version);\n\n        if (exactMatch) {\n          // console.log('[HIT-EXACT] readPackageJsonWithCache(%s)', spec.spec);\n          return exactMatch;\n        }\n\n        const range = validRange(spec.version);\n\n        if (range) {\n          for (const [version, entries] of packageEntriesCacheForModule) {\n            if (satisfies(version, range)) {\n              return entries;\n            }\n          }\n        }\n      } else {\n        packageEntriesCacheForModule = new Map();\n        this.packageEntriesCache.set(spec.name, packageEntriesCacheForModule);\n      }\n\n      return this._readPackageEntries(ctx, spec).then((rootDir) => {\n        packageEntriesCacheForModule!.set(spec.version, rootDir);\n\n        return rootDir;\n      });\n    });\n  }\n\n  private async _readPackageEntries(ctx: ResolverContext, spec: CdnStrategy.Spec) {\n    ctx.debug('%s._readPackageEntries(%s)', this.constructor.name, specToString(spec));\n\n    const uri = this.cdn.urlForPackageList(spec.spec);\n    const href = uri.toString();\n    ctx.recordVisit(uri, ResolverContext.VisitKind.Directory);\n    const data = await checkCancellation(this.readUrlFn(href, ctx.token), ctx.token);\n\n    if (data === null) {\n      throw new EntryNotFoundError(spec);\n    }\n\n    const dataStr = ctx.decoder.decode(data);\n\n    return this.cdn.normalizePackageListing(JSON.parse(dataStr));\n  }\n\n  private _readPackageJsonWithCache(ctx: ResolverContext, spec: CdnStrategy.Spec) {\n    return this._withLock(`packageJson:${spec.name}`, () => {\n      let packageJsonCacheForModule = this.packageJsonCache.get(spec.name);\n\n      if (packageJsonCacheForModule) {\n        const exactMatch = packageJsonCacheForModule.get(spec.version);\n\n        if (exactMatch) {\n          // console.log('[HIT-EXACT] readPackageJsonWithCache(%s)', spec.spec);\n          for (const visit of exactMatch.visited) {\n            ctx.recordVisit(visit.uri, visit.type);\n          }\n          return exactMatch.packageJson;\n        }\n\n        const range = validRange(spec.version);\n\n        if (range) {\n          for (const [version, entry] of packageJsonCacheForModule) {\n            if (satisfies(version, range)) {\n              // console.log('[HIT] readPackageJsonWithCache(%s)', spec.spec);\n              for (const visit of entry.visited) {\n                ctx.recordVisit(visit.uri, visit.type);\n              }\n              return entry.packageJson;\n            }\n          }\n        }\n      } else {\n        packageJsonCacheForModule = new Map();\n        this.packageJsonCache.set(spec.name, packageJsonCacheForModule);\n      }\n\n      return this._readPackageJson(spec, ctx).then((packageJson) => {\n        packageJsonCacheForModule!.set(packageJson.version, { packageJson, visited: ctx.visited });\n\n        return packageJson;\n      });\n    });\n  }\n\n  private async _readPackageJson(\n    spec: CdnStrategy.Spec,\n    ctx: ResolverContext\n  ): Promise<PackageJson> {\n    ctx.debug('%s._readPackageJson(%s)', this.constructor.name, specToString(spec));\n    const uri = this.cdn.urlForPackageFile(spec.spec, '/package.json');\n    const contentReturn = ctx.readFileContent(uri);\n    const contentResult = isThenable(contentReturn) ? await contentReturn : contentReturn;\n\n    let manifest: PackageJson;\n\n    try {\n      manifest = parseBufferAsPackageJson(ctx.decoder, contentResult.content, spec.spec);\n    } catch (err) {\n      throw new Error(`Error parsing manifest as json for package ${spec}: ${err.message}`);\n    }\n\n    // Since we know what the canonicalized version is now (we didn't until the promise resolved)\n    // and the package.json was parsed), we can proactively seed the content cache for the\n    // canonical url.\n    const canonicalHref = this.cdn\n      .urlForPackageFile(`${manifest.name}@${manifest.version}`, '/package.json')\n      .toString();\n\n    this.contentCache.set(canonicalHref, contentResult);\n\n    return manifest;\n  }\n\n  private _withLock<T extends unknown | Promise<unknown>>(\n    lockKey: string,\n    fn: (...args: any[]) => T\n  ): T {\n    const lock = this.locks.get(lockKey);\n    const runCriticalSection = (): T => {\n      const ret = fn();\n\n      if (isThenable(ret)) {\n        const locked = ret.then(\n          (result) => {\n            this.locks.delete(lockKey);\n\n            return result;\n          },\n          (err) => {\n            this.locks.delete(lockKey);\n\n            return Promise.reject(err);\n          }\n        );\n\n        this.locks.set(lockKey, locked);\n\n        return ret;\n      }\n\n      // No need to lock in non-promise\n      return ret;\n    };\n\n    if (isThenable(lock)) {\n      return lock.then(runCriticalSection) as T;\n    }\n\n    return runCriticalSection();\n  }\n\n  static forJsDelivr(readUrlFn: CdnStrategy.UrlContentFetcher) {\n    return new CdnStrategy(readUrlFn, new JSDelivrCdn());\n  }\n\n  static forUnpkg(readUrlFn: CdnStrategy.UrlContentFetcher) {\n    return new CdnStrategy(readUrlFn, new UnpkgCdn());\n  }\n}\n","import {\n  ResolverContext,\n  AbstractResolverStrategy,\n  ResolverStrategy,\n  ResolverStrategyWithRoot,\n} from '@velcro/resolver';\nimport { Uri } from '@velcro/common';\n\ntype StrategyMethodsNames =\n  | 'getCanonicalUrl'\n  | 'getResolveRoot'\n  | 'getSettings'\n  | 'listEntries'\n  | 'readFileContent';\n\ninterface ResolverHostFsOptions {\n  strategies: ResolverStrategyWithRoot[];\n}\n\nexport class CompoundStrategy extends AbstractResolverStrategy implements ResolverStrategy {\n  private readonly strategies: Set<ResolverStrategyWithRoot>;\n\n  constructor(options: ResolverHostFsOptions) {\n    super();\n\n    this.strategies = new Set(options.strategies);\n  }\n\n  private _delegateToStrategy<\n    TMethodName extends StrategyMethodsNames,\n    TMethod extends (ctx: ResolverContext, uri: Uri) => any = ResolverStrategy[TMethodName]\n  >(method: TMethodName, ctx: ResolverContext, uri: Uri) {\n    for (const strategy of this.strategies) {\n      if (Uri.isPrefixOf(strategy.rootUri, uri)) {\n        return strategy[method](ctx, uri) as ReturnType<TMethod>;\n      }\n    }\n\n    return Promise.reject(\n      new Error(`No strategy found whose root is a prefix of ${uri}`)\n    ) as ReturnType<TMethod>;\n  }\n\n  getCanonicalUrl(ctx: ResolverContext, uri: Uri) {\n    return this._delegateToStrategy('getCanonicalUrl', ctx, uri);\n  }\n\n  getResolveRoot(ctx: ResolverContext, uri: Uri) {\n    return this._delegateToStrategy('getResolveRoot', ctx, uri);\n  }\n\n  getUrlForBareModule(ctx: ResolverContext, name: string, spec: string, path: string) {\n    for (const strategy of this.strategies) {\n      if (strategy.getUrlForBareModule) {\n        return strategy.getUrlForBareModule(ctx, name, spec, path);\n      }\n    }\n    return {\n      found: false,\n      uri: null,\n    };\n  }\n\n  listEntries(ctx: ResolverContext, uri: Uri) {\n    return this._delegateToStrategy('listEntries', ctx, uri);\n  }\n\n  readFileContent(ctx: ResolverContext, uri: Uri) {\n    return this._delegateToStrategy('readFileContent', ctx, uri);\n  }\n}\n","import { ChunkOutput, GraphBuilder, Plugin, VelcroRuntime } from '@velcro/bundler';\nimport { Uri } from '@velcro/common';\nimport { Resolver } from '@velcro/resolver';\nimport { CdnStrategy } from '@velcro/strategy-cdn';\nimport { CompoundStrategy } from '@velcro/strategy-compound';\nimport { MemoryStrategy } from '@velcro/strategy-memory';\n\nconst defaultExtensions: Resolver.Settings['extensions'] = ['.js', '.json'];\nconst defaultPackageMain: Resolver.Settings['packageMain'] = ['browser', 'main'];\n\nexport interface BuildOptions {\n  cdn?: 'jsdelivr' | 'unpkg';\n  dependencies?: { [key: string]: string };\n  extensions?: Resolver.Settings['extensions'];\n  external?: GraphBuilder.Options['external'];\n  nodeEnv?: string;\n  plugins?: Plugin[];\n  packageMain?: Resolver.Settings['packageMain'];\n  readUrl: CdnStrategy.UrlContentFetcher;\n}\n\nexport interface ExecuteOptions extends BuildOptions {\n  sourceMap?: boolean;\n  injectModules?: { [id: string]: unknown };\n}\n\nexport async function build(\n  code: string,\n  options: BuildOptions\n): Promise<{ entrypointUri: Uri; output: ChunkOutput }> {\n  const entrypointPath = `index.js`;\n  const cdnStrategy =\n    options.cdn === 'unpkg'\n      ? CdnStrategy.forUnpkg(options.readUrl)\n      : CdnStrategy.forJsDelivr(options.readUrl);\n  const memoryStrategy = new MemoryStrategy(\n    {\n      [entrypointPath]: code,\n      ['package.json']: JSON.stringify({\n        name: '@@velcro/execute',\n        version: '0.0.0',\n        dependencies: options.dependencies,\n      }),\n    },\n    Uri.parse(`velcro://${Math.random().toString(16).slice(2)}/`)\n  );\n  const entrypointUri = memoryStrategy.uriForPath(entrypointPath);\n  const compoundStrategy = new CompoundStrategy({ strategies: [cdnStrategy, memoryStrategy] });\n  const resolver = new Resolver(compoundStrategy, {\n    extensions: options.extensions || defaultExtensions,\n    packageMain: options.packageMain || defaultPackageMain,\n  });\n  const graphBuilder = new GraphBuilder({\n    external: options.external,\n    resolver,\n    nodeEnv: options.nodeEnv || 'development',\n    plugins: options.plugins,\n  });\n  const build = graphBuilder.build([entrypointUri]);\n  const graph = await build.done;\n  const [chunk] = graph.splitChunks();\n  const output = chunk.buildForStaticRuntime({\n    injectRuntime: true,\n  });\n\n  return { entrypointUri, output };\n}\n\nexport async function execute<T = unknown>(code: string, options: ExecuteOptions): Promise<T> {\n  if (options.injectModules) {\n    const injectedModuleSpecs = new Set(Object.keys(options.injectModules));\n    const optionsExternal = options.external;\n    const isExternal: GraphBuilder.Options['external'] = (dependency, fromSourceModule) => {\n      if (injectedModuleSpecs.has(dependency.spec)) {\n        return true;\n      }\n\n      return typeof optionsExternal === 'function'\n        ? optionsExternal(dependency, fromSourceModule)\n        : false;\n    };\n\n    options.external = isExternal;\n  }\n\n  const { entrypointUri, output } = await build(code, options);\n  const codeWithStart = `${output.code}\\n\\nreturn Velcro.runtime;\\n`;\n  const runtimeCode = options.sourceMap\n    ? `${codeWithStart}\\n//# sourceMappingURL=${output.sourceMapDataUri}`\n    : codeWithStart;\n\n  const runtimeFn = new Function(runtimeCode) as () => VelcroRuntime;\n  const velcro = runtimeFn();\n\n  if (options.injectModules) {\n    for (const id in options.injectModules) {\n      velcro.inject(id, options.injectModules[id]);\n    }\n  }\n\n  const result = velcro.require(entrypointUri.toString());\n\n  return result as T;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as Monaco from 'monaco-editor';\n\nconst EMPTY_ELEMENTS = [\n  'area',\n  'base',\n  'br',\n  'col',\n  'embed',\n  'hr',\n  'img',\n  'input',\n  'keygen',\n  'link',\n  'menuitem',\n  'meta',\n  'param',\n  'source',\n  'track',\n  'wbr',\n];\nexport const conf = {\n  wordPattern: /(-?\\d*\\.\\d\\w*)|([^\\`\\~\\!\\@\\$\\^\\&\\*\\(\\)\\=\\+\\[\\{\\]\\}\\\\\\|\\;\\:\\'\\\"\\,\\.\\<\\>\\/\\s]+)/g,\n  comments: {\n    blockComment: ['{!--', '--}'],\n  },\n  brackets: [\n    ['<!--', '-->'],\n    ['<', '>'],\n    ['{', '}'],\n    ['(', ')'],\n  ],\n  autoClosingPairs: [\n    { open: '{', close: '}' },\n    { open: '[', close: ']' },\n    { open: '(', close: ')' },\n    { open: '\"', close: '\"' },\n    { open: \"'\", close: \"'\" },\n  ],\n  surroundingPairs: [\n    { open: '{', close: '}' },\n    { open: '<', close: '>' },\n    { open: '\"', close: '\"' },\n    { open: \"'\", close: \"'\" },\n  ],\n  onEnterRules: [\n    {\n      beforeText: new RegExp(\n        '<(?!(?:' + EMPTY_ELEMENTS.join('|') + '))(\\\\w[\\\\w\\\\d]*)([^/>]*(?!/)>)[^<]*$',\n        'i'\n      ),\n      afterText: /^<\\/(\\w[\\w\\d]*)\\s*>$/i,\n      action: { indentAction: Monaco.languages.IndentAction.IndentOutdent },\n    },\n    {\n      beforeText: new RegExp(\n        '<(?!(?:' + EMPTY_ELEMENTS.join('|') + '))(\\\\w[\\\\w\\\\d]*)([^/>]*(?!/)>)[^<]*$',\n        'i'\n      ),\n      action: { indentAction: Monaco.languages.IndentAction.Indent },\n    },\n  ],\n};\n\nexport const language = {\n  defaultToken: '',\n  tokenPostfix: '.svelte',\n  ignoreCase: false,\n  tokenizer: {\n    root: [\n      [/<!DOCTYPE/, 'metatag', '@doctype'],\n      [/<!--/, 'comment', '@comment'],\n      [/(<)((?:[\\w\\-]+:)?[\\w\\-]+)(\\s*)(\\/>)/, ['delimiter', 'tag', '', 'delimiter']],\n      [/(<)(script)/, ['delimiter', { token: 'tag', next: '@script' }]],\n      [/(<)(style)/, ['delimiter', { token: 'tag', next: '@style' }]],\n      [/(<)((?:[\\w\\-]+:)?[\\w\\-]+)/, ['delimiter', { token: 'tag', next: '@otherTag' }]],\n      [/(<\\/)((?:[\\w\\-]+:)?[\\w\\-]+)/, ['delimiter', { token: 'tag', next: '@otherTag' }]],\n      [/</, 'delimiter'],\n      [/[^<]+/], // text\n    ],\n    doctype: [\n      [/[^>]+/, 'metatag.content'],\n      [/>/, 'metatag', '@pop'],\n    ],\n    comment: [\n      [/-->/, 'comment', '@pop'],\n      [/[^-]+/, 'comment.content'],\n      [/./, 'comment.content'],\n    ],\n    otherTag: [\n      [/\\/?>/, 'delimiter', '@pop'],\n      [/\"([^\"]*)\"/, 'attribute.value'],\n      [/'([^']*)'/, 'attribute.value'],\n      [/[\\w\\-]+/, 'attribute.name'],\n      [/=/, 'delimiter'],\n      [/[ \\t\\r\\n]+/], // whitespace\n    ],\n    script: [\n      [/type/, 'attribute.name', '@scriptAfterType'],\n      [/\"([^\"]*)\"/, 'attribute.value'],\n      [/'([^']*)'/, 'attribute.value'],\n      [/[\\w\\-]+/, 'attribute.name'],\n      [/=/, 'delimiter'],\n      [/>/, { token: 'delimiter', next: '@scriptEmbedded', nextEmbedded: 'text/javascript' }],\n      [/[ \\t\\r\\n]+/], // whitespace\n      [/(<\\/)(script\\s*)(>)/, ['delimiter', 'tag', { token: 'delimiter', next: '@pop' }]],\n    ],\n    scriptAfterType: [\n      [/=/, 'delimiter', '@scriptAfterTypeEquals'],\n      [/>/, { token: 'delimiter', next: '@scriptEmbedded', nextEmbedded: 'text/javascript' }], // cover invalid e.g. <script type>\n      [/[ \\t\\r\\n]+/], // whitespace\n      [/<\\/script\\s*>/, { token: '@rematch', next: '@pop' }],\n    ],\n    scriptAfterTypeEquals: [\n      [/\"([^\"]*)\"/, { token: 'attribute.value', switchTo: '@scriptWithCustomType.$1' }],\n      [/'([^']*)'/, { token: 'attribute.value', switchTo: '@scriptWithCustomType.$1' }],\n      [/>/, { token: 'delimiter', next: '@scriptEmbedded', nextEmbedded: 'text/javascript' }], // cover invalid e.g. <script type=>\n      [/[ \\t\\r\\n]+/], // whitespace\n      [/<\\/script\\s*>/, { token: '@rematch', next: '@pop' }],\n    ],\n    scriptWithCustomType: [\n      [/>/, { token: 'delimiter', next: '@scriptEmbedded.$S2', nextEmbedded: '$S2' }],\n      [/\"([^\"]*)\"/, 'attribute.value'],\n      [/'([^']*)'/, 'attribute.value'],\n      [/[\\w\\-]+/, 'attribute.name'],\n      [/=/, 'delimiter'],\n      [/[ \\t\\r\\n]+/], // whitespace\n      [/<\\/script\\s*>/, { token: '@rematch', next: '@pop' }],\n    ],\n    scriptEmbedded: [\n      [/<\\/script/, { token: '@rematch', next: '@pop', nextEmbedded: '@pop' }],\n      [/[^<]+/, ''],\n    ],\n    style: [\n      [/type/, 'attribute.name', '@styleAfterType'],\n      [/\"([^\"]*)\"/, 'attribute.value'],\n      [/'([^']*)'/, 'attribute.value'],\n      [/[\\w\\-]+/, 'attribute.name'],\n      [/=/, 'delimiter'],\n      [/>/, { token: 'delimiter', next: '@styleEmbedded', nextEmbedded: 'text/css' }],\n      [/[ \\t\\r\\n]+/], // whitespace\n      [/(<\\/)(style\\s*)(>)/, ['delimiter', 'tag', { token: 'delimiter', next: '@pop' }]],\n    ],\n    styleAfterType: [\n      [/=/, 'delimiter', '@styleAfterTypeEquals'],\n      [/>/, { token: 'delimiter', next: '@styleEmbedded', nextEmbedded: 'text/css' }], // cover invalid e.g. <style type>\n      [/[ \\t\\r\\n]+/], // whitespace\n      [/<\\/style\\s*>/, { token: '@rematch', next: '@pop' }],\n    ],\n    styleAfterTypeEquals: [\n      [/\"([^\"]*)\"/, { token: 'attribute.value', switchTo: '@styleWithCustomType.$1' }],\n      [/'([^']*)'/, { token: 'attribute.value', switchTo: '@styleWithCustomType.$1' }],\n      [/>/, { token: 'delimiter', next: '@styleEmbedded', nextEmbedded: 'text/css' }], // cover invalid e.g. <style type=>\n      [/[ \\t\\r\\n]+/], // whitespace\n      [/<\\/style\\s*>/, { token: '@rematch', next: '@pop' }],\n    ],\n    styleWithCustomType: [\n      [/>/, { token: 'delimiter', next: '@styleEmbedded.$S2', nextEmbedded: '$S2' }],\n      [/\"([^\"]*)\"/, 'attribute.value'],\n      [/'([^']*)'/, 'attribute.value'],\n      [/[\\w\\-]+/, 'attribute.name'],\n      [/=/, 'delimiter'],\n      [/[ \\t\\r\\n]+/], // whitespace\n      [/<\\/style\\s*>/, { token: '@rematch', next: '@pop' }],\n    ],\n    styleEmbedded: [\n      [/<\\/style/, { token: '@rematch', next: '@pop', nextEmbedded: '@pop' }],\n      [/[^<]+/, ''],\n    ],\n  },\n};\n","import { DisposableStore, Emitter, Event, IDisposable } from '@velcro/common';\nimport { execute } from '@velcro/runner';\nimport * as Monaco from 'monaco-editor';\nimport { createContext, useContext, useEffect, useState } from 'react';\nimport * as SvelteLanguage from './svelte.language';\n\nconst readUrl = (href: string) => fetch(href).then((res) => res.arrayBuffer());\n\nexport class EditorManager implements IDisposable {\n  editor: Monaco.editor.IStandaloneCodeEditor | null = null;\n\n  private readonly disposableStore = new DisposableStore();\n  private readonly initialPath: string | undefined;\n  private readonly viewState = new WeakMap<\n    Monaco.editor.ITextModel,\n    Monaco.editor.ICodeEditorViewState\n  >();\n\n  private readonly onWillFocusModelEmitter = new Emitter<Monaco.editor.ITextModel>();\n  private readonly onDidChangeEmitter = new Emitter<{ model: Monaco.editor.ITextModel }>();\n\n  constructor(options: { files?: Record<string, string>; initialPath?: string } = {}) {\n    this.disposableStore.add(this.onWillFocusModelEmitter);\n    this.disposableStore.add(this.onDidChangeEmitter);\n\n    Monaco.languages.typescript.typescriptDefaults.setEagerModelSync(true);\n    Monaco.languages.typescript.typescriptDefaults.setMaximumWorkerIdleTime(-1);\n    Monaco.languages.typescript.typescriptDefaults.setCompilerOptions({\n      allowJs: true,\n      allowNonTsExtensions: true,\n      allowSyntheticDefaultImports: true,\n      baseUrl: '.',\n      checkJs: true,\n      esModuleInterop: true,\n      experimentalDecorators: true,\n      inlineSourceMap: true,\n      inlineSources: true,\n      isolatedModules: false,\n      jsx: Monaco.languages.typescript.JsxEmit.React,\n      lib: ['dom'],\n      module: Monaco.languages.typescript.ModuleKind.CommonJS,\n      moduleResolution: Monaco.languages.typescript.ModuleResolutionKind.NodeJs,\n      noEmit: false,\n      outDir: `dist`,\n      resolveJsonModule: true,\n      rootDir: '/',\n      sourceMap: true,\n      target: Monaco.languages.typescript.ScriptTarget.ES2015,\n      typeRoots: ['node_modules/@types'],\n    });\n    Monaco.languages.typescript.typescriptDefaults.setDiagnosticsOptions({\n      noSemanticValidation: true,\n      noSyntaxValidation: false,\n    });\n\n    Monaco.languages.register({\n      id: 'svelte',\n      extensions: ['.svelte'],\n      mimetypes: ['text/x-svelte'],\n    });\n    Monaco.languages.setLanguageConfiguration(\n      'svelte',\n      SvelteLanguage.conf as Monaco.languages.LanguageConfiguration\n    );\n    Monaco.languages.setMonarchTokensProvider(\n      'svelte',\n      SvelteLanguage.language as Monaco.languages.IMonarchLanguage\n    );\n\n    const createPrettierFormattingProvider = (): Monaco.languages.DocumentFormattingEditProvider => {\n      let prettierPromise:\n        | Promise<{\n            prettier: typeof import('prettier/standalone');\n            plugins: import('prettier').Plugin[];\n          }>\n        | undefined = undefined;\n\n      const loadPrettier = async () => {\n        if (!prettierPromise) {\n          prettierPromise = execute(\n            'module.exports = { prettier: require(\"prettier/standalone\"), plugins: [require(\"prettier/parser-babel\"), require(\"prettier/parser-html\"), require(\"prettier/parser-postcss\")] };',\n            {\n              readUrl,\n              cdn: 'jsdelivr',\n              dependencies: {\n                prettier: '^2.0.5',\n                'prettier-plugin-svelte': '^1.1.0',\n              },\n              nodeEnv: 'production',\n              packageMain: ['browser', 'main'],\n              sourceMap: false,\n            }\n          );\n\n          // The Svelte plugin depends on 'prettier' but we're in a browser and so we need\n          // to inject the 'standalone' version of prettier. This means to need to defer\n          // loading the svelte plugin until we've gotten a reference to prettier from\n          // the previous logic.\n          prettierPromise = prettierPromise.then(async ({ prettier, plugins }) => {\n            const prettierPluginSvelte = await execute<import('prettier').Plugin>(\n              'module.exports = require(\"prettier-plugin-svelte\")',\n              {\n                readUrl,\n                cdn: 'jsdelivr',\n                dependencies: {\n                  'prettier-plugin-svelte': '^1.1.0',\n                  svelte: '^3.2.0',\n                },\n                injectModules: {\n                  prettier,\n                },\n                nodeEnv: 'production',\n                packageMain: ['browser', 'main'],\n                sourceMap: false,\n              }\n            );\n\n            return {\n              prettier,\n              plugins: [...plugins, prettierPluginSvelte],\n            };\n          });\n\n          prettierPromise.catch((e) => {\n            console.error(e);\n            debugger;\n          });\n        }\n\n        return prettierPromise;\n      };\n\n      return {\n        async provideDocumentFormattingEdits(model, options, token) {\n          const { prettier, plugins } = await loadPrettier();\n\n          if (token.isCancellationRequested) {\n            return [];\n          }\n\n          const formatted = prettier.format(model.getValue(), {\n            filepath: model.uri.fsPath,\n            singleQuote: true,\n            tabWidth: 2,\n            plugins,\n          });\n\n          return [\n            {\n              range: model.getFullModelRange(),\n              text: formatted,\n            },\n          ];\n        },\n      };\n    };\n\n    const codeFormattingEditProvider = createPrettierFormattingProvider();\n\n    Monaco.languages.registerDocumentFormattingEditProvider('css', codeFormattingEditProvider);\n\n    Monaco.languages.registerDocumentFormattingEditProvider('html', codeFormattingEditProvider);\n\n    Monaco.languages.registerDocumentFormattingEditProvider(\n      'javascript',\n      codeFormattingEditProvider\n    );\n\n    Monaco.languages.registerDocumentFormattingEditProvider('svelte', codeFormattingEditProvider);\n\n    Monaco.languages.registerDocumentFormattingEditProvider(\n      'typescript',\n      codeFormattingEditProvider\n    );\n\n    if (options.files) {\n      for (const pathname in options.files) {\n        const content = options.files[pathname];\n\n        this.createModel(pathname, content);\n      }\n    }\n\n    this.initialPath = options.initialPath;\n  }\n\n  get dispose() {\n    return this.disposableStore.dispose;\n  }\n\n  get onDidChange(): Event<{ model: Monaco.editor.ITextModel }> {\n    return this.onDidChangeEmitter.event;\n  }\n\n  get onWillFocusModel(): Event<Monaco.editor.ITextModel> {\n    return this.onWillFocusModelEmitter.event;\n  }\n\n  createModel(pathname: string, content = '') {\n    const language = this.inferLanguage(pathname);\n\n    let uri: Monaco.Uri;\n\n    try {\n      uri = Monaco.Uri.file(pathname);\n    } catch (err) {\n      throw new Error(`Invalid path '${pathname}': ${err && err.message}`);\n    }\n\n    if (Monaco.editor.getModel(uri)) {\n      throw new Error(`Cannot create file because it exists '${pathname}'`);\n    }\n\n    return Monaco.editor.createModel(content, language, uri);\n  }\n\n  focusHref(\n    href: string,\n    options: {\n      lineNumber?: number;\n      columnNumber?: number;\n      markers?: Monaco.editor.IMarkerData[];\n    } = {}\n  ) {\n    const model = this.getModelByHref(href);\n\n    if (model) {\n      this.focusModel(model, options);\n    }\n  }\n\n  focusModel(\n    model: Monaco.editor.ITextModel,\n    options: {\n      lineNumber?: number;\n      columnNumber?: number;\n      markers?: Monaco.editor.IMarkerData[];\n    } = {}\n  ) {\n    if (this.editor) {\n      this.editor.setModel(model);\n      if (options.lineNumber) {\n        this.editor.revealLineInCenter(options.lineNumber, Monaco.editor.ScrollType.Smooth);\n        this.editor.setPosition({\n          column: options.columnNumber || 0,\n          lineNumber: options.lineNumber,\n        });\n      }\n      if (options.markers) {\n        Monaco.editor.setModelMarkers(model, 'editorManager', options.markers);\n      }\n      this.editor.focus();\n    }\n  }\n\n  focusPath(\n    path: string,\n    options: {\n      lineNumber?: number;\n      columnNumber?: number;\n      markers?: Monaco.editor.IMarkerData[];\n    } = {}\n  ) {\n    const model = this.getModelByPath(path);\n\n    if (model) {\n      this.focusModel(model, options);\n    }\n  }\n\n  getModelByHref(href: string) {\n    try {\n      const uri = Monaco.Uri.parse(href);\n      return Monaco.editor.getModel(uri);\n    } catch (_) {\n      return null;\n    }\n  }\n\n  getModelByPath(path: string) {\n    return Monaco.editor.getModel(Monaco.Uri.file(path));\n  }\n\n  mount(el: HTMLElement) {\n    if (this.editor) {\n      throw new Error('Invariant violation: Editor already mounted');\n    }\n\n    this.editor = Monaco.editor.create(el, {\n      model: null,\n      automaticLayout: true,\n      minimap: {\n        enabled: false,\n      },\n      showUnused: true,\n      scrollBeyondLastLine: false,\n      theme: 'vs',\n      wordWrap: 'bounded',\n      wrappingIndent: 'same',\n    });\n\n    this.editor.onDidDispose(() => {\n      this.editor = null;\n    });\n\n    this.editor.onDidChangeModel((e) => {\n      if (e.newModelUrl && this.editor) {\n        const model = Monaco.editor.getModel(e.newModelUrl)!;\n        const viewState = this.viewState.get(model);\n\n        if (viewState) {\n          this.editor.restoreViewState(viewState);\n        }\n      }\n    });\n\n    this.editor.onDidBlurEditorText(() => {\n      if (this.editor) {\n        const model = this.editor.getModel();\n        const viewState = this.editor.saveViewState();\n\n        if (model && viewState) {\n          this.viewState.set(model, viewState);\n        }\n      }\n    });\n\n    this.disposableStore.add(this.editor);\n\n    if (this.initialPath) {\n      this.focusPath(this.initialPath);\n    }\n\n    return this.editor;\n  }\n\n  inferLanguage(pathname: string) {\n    return pathname.match(/\\.(?:tsx?|jsx?)$/) ? 'typescript' : undefined;\n  }\n}\n\nexport const EditorManagerContext = createContext<EditorManager>(undefined as any);\n\nexport function useActiveModel() {\n  const workbench = useContext(EditorManagerContext);\n  const [activeModel, setActiveModel] = useState<Monaco.editor.ITextModel | null>(\n    workbench.editor ? workbench.editor.getModel() : null\n  );\n\n  useEffect(() => {\n    const disposable = new DisposableStore();\n\n    const trackEditor = (editor: Monaco.editor.ICodeEditor) => {\n      editor.onDidChangeModel((e) => {\n        const model = e.newModelUrl ? Monaco.editor.getModel(e.newModelUrl) : null;\n\n        setActiveModel(model);\n      });\n\n      disposable.add(\n        editor.onDidBlurEditorText(() => {\n          setActiveModel(null);\n        })\n      );\n\n      disposable.add(\n        editor.onDidFocusEditorText(() => {\n          setActiveModel(editor.getModel());\n        })\n      );\n\n      if (editor.hasTextFocus()) {\n        setActiveModel(editor.getModel());\n      }\n    };\n\n    disposable.add(Monaco.editor.onDidCreateEditor(trackEditor));\n    if (workbench.editor) {\n      trackEditor(workbench.editor);\n    }\n\n    return () => disposable.dispose();\n  }, [workbench.editor, activeModel]);\n\n  return activeModel;\n}\n","import styled from '@emotion/styled/macro';\nimport React, { useRef, useEffect, useContext } from 'react';\nimport { EditorManagerContext } from '../lib/EditorManager';\n\nconst Editor: React.FC<{\n  className?: string;\n}> = ({ className }) => {\n  const el = useRef<HTMLDivElement | null>(null);\n  const editorManager = useContext(EditorManagerContext);\n\n  useEffect(() => {\n    if (!el.current) {\n      return;\n    }\n\n    const editor = editorManager.mount(el.current);\n\n    return () => {\n      editor.dispose();\n    };\n  }, [editorManager, el]);\n\n  return (\n    <div className={className} ref={el}>\n      <div></div>\n    </div>\n  );\n};\n\nexport default styled(Editor)``;\n","import styled from '@emotion/styled/macro';\nimport { Uri } from '@velcro/common';\nimport * as Monaco from 'monaco-editor';\nimport React, { useContext, useEffect, useRef, useState } from 'react';\nimport { EditorManagerContext } from '../lib/EditorManager';\nimport { trackMonaco } from '../velcro/monaco';\nimport { WorkerState } from '../velcro/types';\n\nexport interface DeferredExecutionModuleRecord {\n  code: string;\n  dependencies: Record<string, string>;\n}\n\nexport interface DeferredExecutionManifest {\n  aliases: Record<string, string>;\n  entrypoints: Record<string, string>;\n  modules: Record<string, DeferredExecutionModuleRecord>;\n}\n\ninterface MessageLine {\n  isInternal: boolean;\n  text: string;\n}\ninterface Message {\n  lines: MessageLine[];\n}\n\nconst PreviewProgress = styled.div<{ completed: number; total: number }>`\n  z-index: 1;\n  position: absolute;\n  top: 0;\n  width: ${(props) => (props.total ? `${Math.round((100 * props.completed) / props.total)}%` : 0)};\n  left: 0;\n  height: ${(props) => (props.total ? '2px' : '0')};\n  background-color: #008cba;\n  transition: width 0.5s 0s cubic-bezier(0.455, 0.03, 0.515, 0.955);\n`;\nconst PreviewIframeWrap = styled.div`\n  position: relative;\n  overflow: hidden;\n\n  & > iframe {\n    position: absolute;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n    border: none;\n    width: 100%;\n    height: 100%;\n  }\n`;\nconst PreviewWrap = styled.div`\n  position: relative;\n  background: white;\n\n  ${PreviewIframeWrap} {\n    position: absolute;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n  }\n`;\nconst PreviewMessageError = styled.ul`\n  margin: 0;\n  padding: 1em 2em;\n  font-family: monospace;\n  font-size: 16px;\n  background-color: rgba(255, 0, 0, 0.5);\n  backdrop-filter: brightness(50%);\n  color: white;\n  list-style: none;\n`;\nconst PreviewMessageErrorText = styled.li<{ isInternal: boolean }>`\n  white-space: pre-wrap;\n  opacity: ${(props) => (props.isInternal ? 0.7 : 1.0)};\n`;\nconst PreviewMessages = styled.div`\n  z-index: 1;\n  position: absolute;\n  bottom: 0;\n  right: 0;\n  left: 0;\n  display: flex;\n  flex-direction: column-reverse;\n`;\nconst PreviewMessageLine: React.FC<{ line: MessageLine }> = ({ line }) => {\n  return (\n    <PreviewMessageErrorText isInternal={line.isInternal}>{line.text}</PreviewMessageErrorText>\n  );\n};\nconst PreviewMessage: React.FC<{ message: Message }> = ({ message }) => {\n  return message.lines.length ? (\n    <PreviewMessageError>\n      {message.lines.map((line, i) => (\n        <PreviewMessageLine key={i} line={line}></PreviewMessageLine>\n      ))}\n    </PreviewMessageError>\n  ) : null;\n};\n\nconst Preview: React.FC<{ className?: string }> = (props) => {\n  const editorManager = useContext(EditorManagerContext);\n  const previewWrapRef = useRef<HTMLDivElement | null>(null);\n  const previewIframeRef = useRef<HTMLIFrameElement | null>(null);\n  const [buildState, setBuildState] = useState<WorkerState>({\n    state: 'initial',\n  });\n  const [buildProgress, setBuildProgress] = useState({ completed: 0, total: 0 });\n\n  useEffect(() => {\n    const onMessage = (e: MessageEvent) => {\n      if (\n        previewIframeRef.current &&\n        previewIframeRef.current.contentWindow === e.source &&\n        e.data.event === 'click_error'\n      ) {\n        editorManager.focusPath(Uri.parse(e.data.entry.file).fsPath, {\n          columnNumber: e.data.entry.column,\n          lineNumber: e.data.entry.line,\n        });\n      }\n    };\n\n    window.addEventListener('message', onMessage);\n\n    return () => window.removeEventListener('message', onMessage);\n  });\n\n  useEffect(() => {\n    const monacoIntegration = trackMonaco(Monaco);\n\n    monacoIntegration.onStateChange((state) => {\n      setBuildState(state);\n\n      switch (state.state) {\n        case 'building': {\n          setBuildProgress({\n            completed: state.completed,\n            total: state.completed + state.pending,\n          });\n          break;\n        }\n        case 'built': {\n          console.debug(\n            'Rebuild finished, build latency: %d, end-to-end latency: %d',\n            state.end - state.start,\n            Date.now() - state.start\n          );\n\n          const iframe = document.createElement('iframe');\n          iframe.style.display = 'none';\n          iframe.src = state.href;\n\n          if (previewWrapRef.current) {\n            previewWrapRef.current.appendChild(iframe);\n          }\n\n          const onLoad = () => {\n            iframe.removeEventListener('error', onError);\n            iframe.style.display = '';\n\n            if (previewIframeRef.current) {\n              previewIframeRef.current.remove();\n            }\n\n            previewIframeRef.current = iframe;\n          };\n          const onError = () => {\n            iframe.removeEventListener('load', onLoad);\n            iframe.remove();\n          };\n\n          iframe.addEventListener('load', onLoad, { once: true });\n          iframe.addEventListener('error', onError, { once: true });\n\n          break;\n        }\n      }\n    });\n\n    return () => {\n      monacoIntegration.dispose();\n    };\n  }, [setBuildProgress, setBuildState]);\n\n  return (\n    <PreviewWrap className={props.className}>\n      {buildState.state === 'building' ? (\n        <PreviewProgress\n          completed={buildProgress.completed}\n          total={buildProgress.total}\n        ></PreviewProgress>\n      ) : null}\n      <PreviewIframeWrap ref={previewWrapRef}></PreviewIframeWrap>\n      <PreviewMessages>\n        {buildState.state === 'error' ? (\n          <PreviewMessage\n            message={{ lines: [{ isInternal: true, text: buildState.error.message }] }}\n          ></PreviewMessage>\n        ) : null}\n      </PreviewMessages>\n    </PreviewWrap>\n  );\n};\n\nexport default styled(Preview)``;\n","import { DisposableStore } from '@velcro/common';\nimport * as Monaco from 'monaco-editor';\nimport { useEffect, useState } from 'react';\n\n// import { EditorContext } from './context';\n\nexport enum EntryKind {\n  Directory = 'directory',\n  File = 'file',\n}\n\nexport interface IDirectory {\n  type: EntryKind.Directory;\n  uri: Monaco.Uri;\n}\nexport interface IFile {\n  type: EntryKind.File;\n  uri: Monaco.Uri;\n  model: Monaco.editor.ITextModel;\n}\n\nexport type DirectoryEntry = IDirectory | IFile;\n\nexport function useDirectory(uri: Monaco.Uri) {\n  // Make sure the URI always ends with a trailing slash\n  const prefix = uri.toString(true).replace(/\\/?$/, '/');\n  const sortEntries = (models: DirectoryEntry[]) => {\n    return [...models].sort((a, b) => (a.uri.fsPath > b.uri.fsPath ? 1 : -1));\n  };\n\n  const initialEntries = sortEntries(\n    Monaco.editor.getModels().reduce((entries, model) => {\n      const modelUri = model.uri.toString(true);\n\n      if (modelUri.startsWith(prefix)) {\n        const nestedPath = modelUri.slice(prefix.length);\n        const nextDirIdx = nestedPath.indexOf('/');\n\n        if (nextDirIdx === 0) {\n          throw new Error('Invariant error: WAT?');\n        }\n\n        if (nextDirIdx > 0) {\n          // This is an intermediate directory\n          const uri = Monaco.Uri.parse(`${prefix}${nestedPath.slice(0, nextDirIdx + 1)}`);\n\n          entries.push({\n            type: EntryKind.Directory,\n            uri,\n          });\n        } else {\n          entries.push({\n            type: EntryKind.File,\n            uri: model.uri,\n            model,\n          });\n        }\n      }\n\n      return entries;\n    }, [] as DirectoryEntry[])\n  );\n  const [entries, setEntries] = useState(initialEntries);\n\n  useEffect(() => {\n    const disposable = new DisposableStore();\n    const prefix = uri.toString(true).replace(/\\/?$/, '/');\n\n    disposable.add(\n      Monaco.editor.onDidCreateModel((model: Monaco.editor.ITextModel) => {\n        const modelUri = model.uri.toString(true);\n\n        if (modelUri.startsWith(prefix)) {\n          const nestedPath = modelUri.slice(prefix.length);\n          const nextDirIdx = nestedPath.indexOf('/');\n\n          if (nextDirIdx === 0) {\n            throw new Error('Invariant error: WAT?');\n          }\n\n          if (nextDirIdx > 0) {\n            // This is an intermediate directory\n            const uri = Monaco.Uri.parse(`${prefix}${nestedPath.slice(0, nextDirIdx)}`);\n\n            // It is possible that we already have this directory\n            const entry = entries.find((entry) => entry.uri.toString(true) === uri.toString(true));\n\n            if (entry) {\n              if (entry.type !== EntryKind.Directory) {\n                throw new Error(\n                  `Invariant violation: A file in '${prefix}' conflicts with the path of the new file '${modelUri}'`\n                );\n              }\n\n              return;\n            }\n\n            entries.push({ type: EntryKind.Directory, uri });\n\n            return setEntries(sortEntries(entries));\n          }\n\n          if (\n            !entries.find(\n              (entry) =>\n                entry.type === EntryKind.File &&\n                entry.uri.toString(true) === model.uri.toString(true)\n            )\n          ) {\n            entries.push({ type: EntryKind.File, uri: model.uri, model });\n\n            setEntries(sortEntries(entries));\n          }\n        }\n      })\n    );\n\n    disposable.add(\n      Monaco.editor.onWillDisposeModel((model) => {\n        const idx = entries.findIndex(\n          (entry) => entry.type === EntryKind.File && entry.model === model\n        );\n\n        if (idx === -1) {\n          throw new Error(\n            `Invariant violation: Removing an untracked model: '${model.uri.fsPath}'`\n          );\n        }\n\n        entries.splice(idx, 1);\n\n        setEntries(sortEntries(entries));\n      })\n    );\n\n    return () => disposable.dispose();\n  }, [entries, uri]);\n\n  return entries;\n}\n","import styled from '@emotion/styled/macro';\nimport * as Monaco from 'monaco-editor';\nimport React, { useContext, useRef } from 'react';\nimport { Button } from 'reakit/Button';\nimport { Tooltip, TooltipReference, useTooltipState } from 'reakit/Tooltip';\nimport { useDirectory, EntryKind } from '../lib/hooks';\nimport { useActiveModel, EditorManagerContext } from '../lib/EditorManager';\n\nconst Entry = styled.div<{ modelFocused: boolean }>`\n  background-color: ${props => (props.modelFocused ? '#008cba' : 'inherit')};\n  text-decoration: none;\n  color: ${props => (props.modelFocused ? '#fff' : '#262626')};\n\n  height: 25px;\n  padding: 0 0 0 8px;\n  display: flex;\n  flex-direction: row;\n  align-items: center;\n\n  & > span {\n    flex: 1;\n  }\n\n  & > button {\n    display: none;\n  }\n\n  &:hover > button {\n    display: block;\n  }\n\n  ${props =>\n    props.modelFocused\n      ? {\n          ':hover': {\n            color: '#f5f5f5',\n            cursor: 'pointer',\n          },\n        }\n      : {\n          ':hover': {\n            backgroundColor: '#eee',\n            color: '#262626',\n            cursor: 'pointer',\n          },\n        }}\n`;\n\nconst CreateEntry = styled.div`\n  text-decoration: none;\n  color: '#262626';\n\n  height: 25px;\n  padding: 0 0 0 8px;\n  display: flex;\n  align-items: center;\n\n  :hover {\n    background-color: #eee;\n    cursor: pointer;\n  }\n`;\n\nconst SidebarFileDelete = styled(Button)`\n  border: none;\n  background: none;\n\n  :hover {\n    cursor: pointer;\n  }\n`;\n\nconst StyledTooltip = styled.div`\n  font-family: Open Sans, Helvetica Neue, Helvetica, Arial, sans-serif;\n  font-size: 14px;\n  line-height: 1.4;\n  background-color: #333;\n  color: #fff;\n  border-radius: 4px;\n  opacity: 0.9;\n  padding: 0.2em 0.4em;\n`;\n\nconst SidebarFile: React.FC<{ className?: string; model: Monaco.editor.ITextModel }> = ({ className, model }) => {\n  const activeModel = useActiveModel();\n  const editorManager = useContext(EditorManagerContext);\n  const tooltip = useTooltipState({ gutter: 0 });\n\n  const onClickDelete = () => {\n    model.dispose();\n  };\n\n  return (\n    <Entry className={className} modelFocused={model === activeModel}>\n      <span onClick={() => editorManager.focusModel(model)}>{model.uri.fsPath.slice(1)}</span>\n      <TooltipReference {...tooltip} as={SidebarFileDelete} onClick={() => onClickDelete()}>\n        <span role=\"img\" aria-label=\"Delete file\">\n          \n        </span>\n      </TooltipReference>\n      <Tooltip {...tooltip} as={StyledTooltip}>\n        Delete file\n      </Tooltip>\n    </Entry>\n  );\n};\n\nconst Sidebar: React.FC<{ className?: string }> = props => {\n  const rootDir = useRef(Monaco.Uri.file('/'));\n  const entries = useDirectory(rootDir.current);\n  const editorManager = useContext(EditorManagerContext);\n\n  const onClickCreate = () => {\n    const filename = prompt('Filename?');\n\n    if (filename) {\n      editorManager.createModel(filename);\n    }\n  };\n\n  return (\n    <div className={props.className}>\n      {entries.map(entry =>\n        entry.type === EntryKind.Directory ? (\n          <div>{entry.uri.fsPath.slice(1)}</div>\n        ) : (\n          <SidebarFile key={entry.uri.toString(true)} model={entry.model}></SidebarFile>\n        )\n      )}\n      <CreateEntry onClick={() => onClickCreate()}>Create...</CreateEntry>\n    </div>\n  );\n};\n\nexport default styled(Sidebar)`\n  display: flex;\n  flex-direction: column;\n`;\n","import styled from '@emotion/styled/macro';\nimport React from 'react';\n\nimport Editor from './Editor';\nimport Preview from './Preview';\nimport Sidebar from './Sidebar';\nimport { EditorManager, EditorManagerContext } from '../lib/EditorManager';\n\nconst PlaygroundCmp: React.FC<{\n  className?: string;\n  initialPath: string;\n  project: Record<string, string>;\n}> = ({ className, initialPath, project }) => {\n  const editorManager = new EditorManager({ files: project, initialPath: initialPath });\n\n  return (\n    <div className={className}>\n      <EditorManagerContext.Provider value={editorManager}>\n        <Sidebar></Sidebar>\n        <Editor></Editor>\n        <Preview></Preview>\n      </EditorManagerContext.Provider>\n    </div>\n  );\n};\n\nexport const Playground = styled(PlaygroundCmp)`\n  display: flex;\n  flex-direction: row;\n\n  font-family: Open Sans, Helvetica Neue, Helvetica, Arial, sans-serif;\n  font-size: 14px;\n  line-height: 1.4;\n\n  color: #222;\n\n  ${Sidebar} {\n    flex: 1 1 100px;\n    min-width: 100px;\n    max-width: 400px;\n    border-right: 1px solid #ccc;\n  }\n\n  ${Editor} {\n    border-right: 1px solid #ccc;\n  }\n\n  ${Editor}, ${Preview} {\n    flex: 10;\n  }\n`;\n","export const files = {\n  'package.json':\n    JSON.stringify(\n      {\n        name: 'test',\n        version: '0.0.0',\n        dependencies: {\n          svelte: '^3.24.0',\n        },\n      },\n      null,\n      2\n    ) + '\\n',\n  'index.jsx':\n    `\nimport App from './App.svelte';\n\nnew App({\n  target: document.body,\n  props: {\n    name: 'World',\n  }\n});\n    `.trim() + '\\n',\n  'App.svelte':\n    `\n<script>\n  import Button from './Button.svelte';\n\n  export let name;\n</script>\n\n<h1>Hello {name}</h1>\n<Button>Click me, I do nothing</Button>\n    `.trim() + '\\n',\n  'Button.svelte':\n    `\n<button on:click|once={() => alert('well, almost nothing')}><slot /></button>\n    `.trim() + '\\n',\n};\n","import React from 'react';\n\n// import * as serviceWorker from './serviceWorker';\n\ninterface ServiceWorkerEvent extends Event {\n  target: (Partial<ServiceWorker> & EventTarget) | null;\n}\n\ninterface ServiceWorkerContextValue {\n  assetsUpdateReady: boolean;\n  assetsCached: boolean;\n  updateAssets(): void;\n}\n\nconst ServiceWorkerContext = React.createContext<ServiceWorkerContextValue | undefined>(undefined);\n\nexport function ServiceWorkerProvider(props: React.PropsWithChildren<{}>) {\n  const [waitingServiceWorker, setWaitingServiceWorker] = React.useState<ServiceWorker | null>(\n    null\n  );\n  const [assetsUpdateReady, setAssetsUpdateReady] = React.useState(false);\n  const [assetsCached, setAssetsCached] = React.useState(false);\n\n  const value = React.useMemo(() => {\n    return {\n      assetsUpdateReady,\n      assetsCached,\n      // Call when the user confirm update of application and reload page\n      updateAssets: () => {\n        if (waitingServiceWorker) {\n          waitingServiceWorker.addEventListener('statechange', (event: ServiceWorkerEvent) => {\n            if (event.target && event.target.state === 'activated') {\n              window.location.reload();\n            }\n          });\n\n          waitingServiceWorker.postMessage({ type: 'SKIP_WAITING' });\n        }\n      },\n    };\n  }, [assetsUpdateReady, assetsCached, waitingServiceWorker]);\n\n  // Once on component mounted subscribe to Update and Succes events in\n  // CRA's service worker wrapper\n  // React.useEffect(() => {\n  //   serviceWorker.register({\n  //     onUpdate: (registration) => {\n  //       setWaitingServiceWorker(registration.waiting);\n  //     },\n  //     onUpdateAvailable: () => {\n  //       setAssetsUpdateReady(true);\n  //     },\n  //     onSuccess: (registration) => {\n  //       setAssetsCached(true);\n  //       setAssetsUpdateReady(false);\n\n  //       if (registration.active) {\n  //         registration.active.addEventListener('statechange', (event: ServiceWorkerEvent) => {\n  //           if (!navigator.serviceWorker.controller) {\n  //             setAssetsCached(false);\n  //           }\n  //         });\n  //       }\n  //     },\n  //   });\n  // }, []);\n\n  return <ServiceWorkerContext.Provider value={value} {...props} />;\n}\n\nexport function useServiceWorker() {\n  const context = React.useContext(ServiceWorkerContext);\n\n  if (!context) {\n    throw new Error('useServiceWorker must be used within a ServiceWorkerProvider');\n  }\n\n  return context;\n}\n","//@ts-nocheck\nimport { Global, css } from '@emotion/core';\nimport styled from '@emotion/styled/macro';\nimport CssBaseline from '@material-ui/core/CssBaseline';\nimport { OfflineBolt, Update } from '@material-ui/icons';\nimport React from 'react';\nimport { Tooltip, TooltipReference, useTooltipState } from 'reakit/Tooltip';\n\nimport { Playground } from './playground';\nimport { files } from './templates/svelte';\nimport { useServiceWorker, ServiceWorkerProvider } from './useServiceWorker';\nimport { Button } from 'reakit/Button';\n\nconst PlaygroundWrapper = styled.div`\n  background: white;\n  color: #666;\n  display: flex;\n  flex-direction: column;\n\n  ${Playground} {\n    border-bottom: 1px solid #ccc;\n    flex: 1;\n  }\n`;\n\nconst StatusBarItem = styled.span`\n  display: inline-flex;\n  flex-direction: row;\n  align-items: center;\n`;\n\nconst ReloadButton = styled(Button)`\n  border: 0;\n  background: #008cba;\n  margin: 0 0.5em;\n  color: white;\n  border-radius: 2px;\n  font-weight: 600;\n\n  :hover {\n    cursor: pointer;\n    text-decoration: underline;\n  }\n`;\n\nconst StyledTooltip = styled.div`\n  font-family: Open Sans, Helvetica Neue, Helvetica, Arial, sans-serif;\n  font-size: 14px;\n  line-height: 1.4;\n  background-color: #333;\n  color: #fff;\n  border-radius: 4px;\n  opacity: 0.9;\n  padding: 0.2em 0.4em;\n`;\n\nconst StatusBar: React.FC = () => {\n  const serviceWorker = useServiceWorker();\n  const offlineTooltip = useTooltipState({ gutter: 0 });\n  const reloadTooltip = useTooltipState({ gutter: 0 });\n\n  return (\n    <StatusBarStyles>\n      {serviceWorker.assetsCached ? (\n        <TooltipReference {...offlineTooltip} as={StatusBarItem}>\n          <OfflineBolt color=\"inherit\" fontSize=\"small\" />\n          &nbsp;Offline ready\n        </TooltipReference>\n      ) : null}\n      <Tooltip {...offlineTooltip} as={StyledTooltip}>\n        This application has been fully cached and can now be used offline.\n      </Tooltip>\n\n      {serviceWorker.assetsUpdateReady ? (\n        <TooltipReference {...reloadTooltip} as={StatusBarItem}>\n          <Update color=\"inherit\" fontSize=\"small\" />\n          &nbsp;Update ready:\n          <ReloadButton onClick={() => serviceWorker.updateAssets()}>Reload</ReloadButton>\n        </TooltipReference>\n      ) : null}\n      <Tooltip {...reloadTooltip} as={StyledTooltip}>\n        There is an update of this application ready to install. Click install reload to install the\n        update and reload the page.\n      </Tooltip>\n    </StatusBarStyles>\n  );\n};\n\nconst StatusBarStyles = styled.div`\n  display: flex;\n  flex-direction: row;\n\n  font-size: 90%;\n\n  height: 24px;\n  padding: 0 0.5em;\n\n  ${StatusBarItem} {\n    margin-left: 0.5em;\n    margin-right: 0.5em;\n  }\n`;\n\nconst AppWrapper = styled.div`\n  width: 100%;\n  min-width: 200px;\n  max-width: 80vw;\n  margin: 0 auto;\n  padding: 0 0 45px 0;\n\n  @media (max-width: 960px) {\n    padding: 0 15px 15px 15px;\n    max-width: initial;\n  }\n\n  display: flex;\n  flex-direction: column;\n\n  ${PlaygroundWrapper} {\n    flex: 1;\n    background: #f5f5f5;\n    border-radius: 2px;\n    box-shadow: 0 10px 20px rgba(0, 0, 0, 0.19), 0 6px 6px rgba(0, 0, 0, 0.23);\n\n    ${StatusBarStyles} {\n    }\n  }\n`;\n\nconst Title = styled.div`\n  font-family: 'Raleway', sans-serif;\n  font-size: 250%;\n  font-weight: 800;\n  font-variant: small-caps;\n  font-variant-caps: small-caps;\n  color: #00bfff;\n`;\n\nconst Subtitle = styled.div`\n  color: #ddd;\n  font-size: 120%;\n  font-weight: 400;\n`;\n\nconst Link = styled.a`\n  color: white;\n  text-decoration: none;\n\n  :hover {\n    text-decoration: underline;\n  }\n`;\n\nconst Links = styled.div`\n  display: flex;\n  flex-direction: row;\n\n  & > *:not(:last-child):after {\n    padding: 0 0.5em;\n    content: '';\n    color: #aaa;\n    text-decoration: none;\n  }\n\n  ${Link} {\n    color: #ccc;\n  }\n`;\n\nconst Header = styled.div`\n  display: flex;\n  flex-direction: row;\n  align-items: baseline;\n  padding: 0.8em 0 0.3em 0;\n  text-shadow: #000 1px 1px 5px;\n\n  ${Title} {\n    margin-right: 0.5em;\n  }\n\n  ${Subtitle} {\n    margin-right: 0.5em;\n  }\n\n  ${Links} {\n    flex: 1;\n    justify-content: flex-end;\n  }\n`;\n\nconst globalCss = css`\n  @import url('https://fonts.googleapis.com/css?family=Raleway:900&display=swap');\n\n  *,\n  *::before,\n  *::after {\n    box-sizing: border-box;\n  }\n\n  html,\n  body {\n    margin: 0;\n    padding: 0;\n    min-height: 100vh;\n\n    font-family: Open Sans, Helvetica Neue, Helvetica, Arial, sans-serif;\n    font-size: 14px;\n    line-height: 1.4;\n\n    background: #333;\n    color: #fff;\n\n    display: flex;\n    flex-direction: column;\n\n    #root {\n      flex: 1;\n      display: flex;\n      flex-direction: column;\n\n      ${AppWrapper} {\n        flex: 1;\n      }\n    }\n  }\n`;\n\nexport const App: React.FC = () => {\n  return (\n    <ServiceWorkerProvider>\n      <CssBaseline />\n      <AppWrapper>\n        <Global styles={globalCss}></Global>\n        <Header>\n          <Title>Velcro</Title>\n          <Subtitle>The client-side bundler and playground</Subtitle>\n          <Links>\n            <div>\n              <Link href=\"https://twitter.com/filearts\" target=\"_blank\" rel=\"nofollow noreferrer\">\n                @filearts\n              </Link>\n            </div>\n            <div>\n              <Link\n                href=\"https://github.com/ggoodman/velcro\"\n                target=\"_blank\"\n                rel=\"nofollow noreferrer\"\n              >\n                View on GitHub\n              </Link>\n            </div>\n          </Links>\n        </Header>\n        <PlaygroundWrapper>\n          <Playground project={files} initialPath=\"index.jsx\"></Playground>\n        </PlaygroundWrapper>\n      </AppWrapper>\n    </ServiceWorkerProvider>\n  );\n};\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://cra.link/PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(/^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/)\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://cra.link/PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://cra.link/PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch((error) => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log('No internet connection found. App is running in offline mode.');\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then((registration) => {\n        registration.unregister();\n      })\n      .catch((error) => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\n\nimport { App } from './App';\nimport * as serviceWorker from './serviceWorker';\n\nserviceWorker.unregister();\n\nReactDOM.render(<App />, document.getElementById('root'));\n","const SPEC_RX = /^((@[^/]+\\/[^/@]+|[^./@][^/@]*)(?:@([^/]+))?)(.*)?$/;\n\ntype _BareModuleSpec<T = ReturnType<typeof parseBareModuleSpec>> = T extends null | undefined\n  ? never\n  : T;\nexport type BareModuleSpec = _BareModuleSpec;\n\nexport function parseBareModuleSpec(bareModuleSpec: string) {\n  const matches = bareModuleSpec.match(SPEC_RX);\n\n  if (matches) {\n    const [, nameSpec, name, spec, path = ''] = matches;\n\n    return {\n      nameSpec,\n      name,\n      spec,\n      path,\n    };\n  }\n\n  return null;\n}\n","import { version as nodeLibsVersion } from '@velcro/node-libs/package.json';\nimport { BareModuleSpec, parseBareModuleSpec } from './bareModules';\n\nexport const NODE_CORE_SHIMS: Record<string, BareModuleSpec | undefined> = Object.assign(\n  Object.create(null),\n  {\n    string_decoder: parseBareModuleSpec('string_decoder@1.2.0'),\n    punycode: parseBareModuleSpec('punycode@2.1.1'),\n  }\n);\n\nfor (const name of [\n  'assert',\n  'buffer',\n  'constants',\n  'crypto',\n  'events',\n  'fs',\n  'http',\n  'https',\n  'net',\n  'os',\n  'path',\n  'process',\n  'querystring',\n  'stream',\n  'tls',\n  'url',\n  'util',\n  'vm',\n  'zlib',\n]) {\n  NODE_CORE_SHIMS[name] = parseBareModuleSpec(\n    `@velcro/node-libs@${nodeLibsVersion}/lib/${name}.js`\n  )!;\n}\n","import type { Thenable, Uri } from '@velcro/common';\nimport type { ResolverContext } from './context';\nimport type { Resolver } from './resolver';\n\ntype MaybeThenable<T> = T | Thenable<T>;\n\nexport interface ResolverStrategy {\n  /**\n   * Produce a url given the components of a bare module specifier.\n   *\n   * @param ctx A `ResolverContext` that should be used for making calls to other strategy methods\n   * @param name The name of a bare module\n   * @param spec The optional `@version` of a bare module specifier\n   * @param path The optional path at the end of the bare module specifier\n   */\n  getUrlForBareModule?(\n    ctx: ResolverContext,\n    name: string,\n    spec: string,\n    path: string\n  ): MaybeThenable<ResolverStrategy.BareModuleResult>;\n\n  /**\n   * Determine the canonical uri for a given uri.\n   *\n   * For example, you might consider symlink targets their canonicalized path or you might\n   * consider the canonicalized path of https://unpkg.com/react to be\n   * https://unpkg.com/react@16.13.1/index.js.\n   *\n   * Dealing only in canonical uris means that anything produced from those can be cached.\n   *\n   * @param ctx A `ResolverContext` that should be used for making calls to other strategy methods\n   * @param uri The uri to canonicalize\n   */\n  getCanonicalUrl(\n    ctx: ResolverContext,\n    uri: Uri\n  ): MaybeThenable<ResolverStrategy.CanonicalizeResult>;\n\n  /**\n   * Get the logical resolve root for a given uri.\n   *\n   * For example, a filesystem-based strategy might consider the root to be `file:///`. Or,\n   * if it was scoped to /home/filearts, the root might be `file:///home/filearts/`.\n   *\n   * Any uri that is not a 'child' of the resolve root should be considered out of scope for a given\n   * strategy.\n   *\n   * @param ctx A `ResolverContext` that should be used for making calls to other strategy methods\n   * @param uri The uri for which the logical resolve root uri should be found\n   */\n  getResolveRoot(ctx: ResolverContext, uri: Uri): MaybeThenable<ResolverStrategy.ResolveRootResult>;\n\n  /**\n   * Get the settings for a given uri\n   *\n   * This indirection allows resolver strategies to have per-strategy or even per-uri settings.\n   *\n   * @param ctx A `ResolverContext` that should be used for making calls to other strategy methods\n   * @param uri The uri for which to load settings\n   */\n  getSettings(ctx: ResolverContext, uri: Uri): MaybeThenable<ResolverStrategy.SettingsResult>;\n\n  /**\n   * Produce a list of resolved entries that are direct children of the given uri.\n   *\n   * This is the moral equivalent to something like non-recursive `fs.readdir()`. It is only\n   * designed to show files and folders (for now).\n   *\n   * @param ctx A `ResolverContext` that should be used for making calls to other strategy methods\n   * @param uri The uri at which to list entries\n   */\n  listEntries(ctx: ResolverContext, uri: Uri): MaybeThenable<ResolverStrategy.ListEntriesResult>;\n\n  /**\n   * Read the content at the uri as an `ArrayBuffer`\n   *\n   * ArrayBuffers are the lowest-common-denominator across the web and node and can easily be\n   * decoded with standard web apis like `StringDecoder`. In Node.js, `Buffer` objects are also\n   * `ArrayBuffer`s, allowing the tooling to be built on that primitive.\n   *\n   * This is helpful for the understanding that not all uris are expected to produce meaningful\n   * text representations.\n   *\n   * @param ctx A `ResolverContext` that should be used for making calls to other strategy methods\n   * @param uri The uri at which to read the content\n   */\n  readFileContent(\n    ctx: ResolverContext,\n    uri: Uri\n  ): MaybeThenable<ResolverStrategy.ReadFileContentResult>;\n}\n\nexport interface ResolverStrategyWithRoot extends ResolverStrategy {\n  /**\n   * The root uri of the strategy.\n   *\n   * A common parent to all uris that this strategy can handle.\n   *\n   * This may sometimes be the same value as would be returned by `getResolveRoot` but will\n   * sometimes be a parent of that. Take, for example Unpkg; there, we may want to express\n   * that a strategy should 'own' all uris under https://unpkg.com/ even though the resolve\n   * root for https://unpkg.com/react@16.13.1/index.js will actually be\n   * https://unpkg.com/react@16.13.1/.\n   *\n   * Notably, the `CompoundResolverStrategy` requires all child strategies implement the\n   * `ResolverStrategyWithRoot` interface because it dispatches operations on different\n   * uris according to each strategy's `rootUri`.\n   */\n  rootUri: Uri;\n}\n\nexport namespace ResolverStrategy {\n  export enum EntryKind {\n    File = 'file',\n    Directory = 'directory',\n  }\n\n  export interface Entry<TKind extends EntryKind = EntryKind> {\n    uri: Uri;\n    type: TKind;\n  }\n\n  export type BareModuleResult = {\n    found: boolean;\n    uri: Uri | null;\n  };\n\n  export interface CanonicalizeResult {\n    uri: Uri;\n  }\n\n  export interface ResolveRootResult {\n    uri: Uri;\n  }\n\n  export interface SettingsResult {\n    settings: Resolver.Settings;\n  }\n\n  export interface ListEntriesResult {\n    entries: Entry[];\n  }\n\n  export interface ReadFileContentResult {\n    content: ArrayBuffer;\n  }\n}\n\nexport abstract class AbstractResolverStrategy implements ResolverStrategy {\n  getCanonicalUrl(\n    _ctx: ResolverContext,\n    uri: Uri\n  ): ReturnType<ResolverStrategy['getCanonicalUrl']> {\n    return {\n      uri,\n    };\n  }\n\n  getSettings(ctx: ResolverContext, _uri: Uri): ReturnType<ResolverStrategy['getSettings']> {\n    return {\n      settings: ctx.settings,\n    };\n  }\n\n  /**\n   * Create a new ResolverStrategy having one or more methods overridden.\n   *\n   * You might use this if you want to override specific behaviour of another strategy without\n   * wanting to re-implement the whole strategy.\n   *\n   * If you need to invoke an overridden method, the overridden strategy will be available\n   * on `this.parent`.\n   *\n   * @param overrides A map of ResolverStrategy methods that you would like to override\n   */\n  withOverrides(\n    overrides: {\n      [TMethodName in keyof ResolverStrategy]?: ResolverStrategy[TMethodName];\n    }\n  ): ResolverStrategy {\n    const strategy = { ...overrides, parent: this };\n\n    return Object.setPrototypeOf(Object.assign(Object.create(null), strategy), this);\n  }\n\n  abstract getResolveRoot(\n    ctx: ResolverContext,\n    uri: Uri\n  ): ReturnType<ResolverStrategy['getResolveRoot']>;\n  abstract listEntries(ctx: ResolverContext, uri: Uri): ReturnType<ResolverStrategy['listEntries']>;\n  abstract readFileContent(\n    ctx: ResolverContext,\n    uri: Uri\n  ): ReturnType<ResolverStrategy['readFileContent']>;\n}\n\nexport abstract class AbstractResolverStrategyWithRoot extends AbstractResolverStrategy\n  implements ResolverStrategyWithRoot {\n  constructor(readonly rootUri: Uri) {\n    super();\n  }\n}\n","import {\n  all,\n  Awaited,\n  basename,\n  CanceledError,\n  CancellationToken,\n  CancellationTokenSource,\n  checkCancellation,\n  Decoder,\n  DependencyNotFoundError,\n  dirname,\n  EntryExcludedError,\n  EntryNotFoundError,\n  isThenable,\n  MapSet,\n  PackageJson,\n  parseBufferAsPackageJson,\n  parseBufferAsPartialPackageJson,\n  PartialPackageJson,\n  Thenable,\n  Uri,\n} from '@velcro/common';\nimport { BareModuleSpec, parseBareModuleSpec } from './bareModules';\nimport type { Resolver } from './resolver';\nimport { NODE_CORE_SHIMS } from './shims';\nimport { ResolverStrategy } from './strategy';\n\ntype ReturnTypeWithVisits<\n  T extends (...args: any[]) => any,\n  TReturn = ReturnType<T>\n> = TReturn extends Thenable<infer U>\n  ? Promise<U & { visited: ResolverContext.Visit[] }>\n  : TReturn & { visited: ResolverContext.Visit[] };\n\n// type UncachedReturnType<T> = { [K in keyof T] : K extends typeof CACHE ? never : T[K] };\n// type UncachedReturn<\n//   T extends (...any: any[]) => any,\n//   TReturn = ReturnType<T>\n// > = TReturn extends Thenable<infer U>\n//   ? Thenable<UncachedReturnType<U>>\n//   : UncachedReturnType<TReturn>;\n\nconst CACHE = Symbol('Context.cache');\n\ntype InvalidationRecord = {\n  cacheKey: string;\n  operationCache: Map<string, unknown>;\n};\n\ntype ResolveResult =\n  | {\n      found: false;\n      uri: null;\n      parentPackageJson?: { packageJson: PackageJson; uri: Uri };\n    }\n  | {\n      found: true;\n      uri: null;\n      parentPackageJson?: { packageJson: PackageJson; uri: Uri };\n      rootUri: Uri;\n    }\n  | {\n      found: true;\n      uri: Uri;\n      parentPackageJson?: { packageJson: PackageJson; uri: Uri };\n      rootUri: Uri;\n    };\n\ntype ReadParentPackageJsonResultInternal =\n  | {\n      found: true;\n      packageJson: PackageJson;\n      uri: Uri;\n      visitedDirs: Uri[];\n    }\n  | {\n      found: false;\n      packageJson: null;\n      uri: null;\n    };\n\ntype StrategyResult<T> =\n  | Promise<T & { visited: ResolverContext.Visit[] }>\n  | (T & { visited: ResolverContext.Visit[] });\n\nclass Visits {\n  private readonly parent?: Visits;\n  private readonly visits = [] as ResolverContext.Visit[];\n\n  constructor(readonly uri: { toString(): string }, parent?: Visits) {\n    this.parent = parent;\n  }\n\n  child(uri: { toString(): string }): Visits {\n    return new Visits(uri, this);\n  }\n\n  push(visit: ResolverContext.Visit) {\n    if (!this.visits.find((cmp) => cmp.type == visit.type && Uri.equals(cmp.uri, visit.uri))) {\n      this.visits.push(visit);\n      if (this.parent) {\n        this.parent.push(visit);\n      }\n    }\n  }\n\n  toArray(): ResolverContext.Visit[] {\n    return this.parent ? this.parent.toArray() : this.visits.slice();\n  }\n}\n\nexport class ResolverContext {\n  static create(\n    resolver: Resolver,\n    strategy: ResolverStrategy,\n    settings: Resolver.Settings,\n    token: CancellationToken,\n    options: { debug?: boolean } = {}\n  ) {\n    return new ResolverContext({\n      cache: new Map(),\n      cacheInvalidations: new MapSet(),\n      debug: !!options.debug,\n      decoder: new Decoder(),\n      path: [],\n      resolver,\n      settings,\n      strategy,\n      token,\n      visits: new Visits(Uri.parse('velcro:/root')),\n    });\n  }\n\n  private readonly cache: ResolverContext.Options['cache'];\n  private readonly cacheInvalidations: ResolverContext.Options['cacheInvalidations'];\n  private readonly debugMode: boolean;\n  readonly decoder: ResolverContext.Options['decoder'];\n  private readonly mapResultWithVisits = <T>(result: T) =>\n    Object.assign(result, { visited: this.visits.toArray() });\n  readonly path: ReadonlyArray<string>;\n  private readonly resolver: ResolverContext.Options['resolver'];\n  readonly settings: Readonly<ResolverContext.Options['settings']>;\n  private readonly strategy: ResolverContext.Options['strategy'];\n  private readonly tokenSource: CancellationTokenSource;\n  private readonly visits: Visits;\n\n  protected constructor(options: ResolverContext.Options) {\n    this.cache = options.cache;\n    this.cacheInvalidations = options.cacheInvalidations;\n    this.debugMode = options.debug;\n    this.decoder = options.decoder;\n    this.path = options.path;\n    this.resolver = options.resolver;\n    this.settings = options.settings;\n    this.strategy = options.strategy;\n    this.tokenSource = new CancellationTokenSource(options.token);\n    this.visits = options.visits;\n  }\n\n  get token() {\n    return this.tokenSource.token;\n  }\n\n  get visited() {\n    return this.visits.toArray();\n  }\n\n  dispose() {\n    this.tokenSource.dispose(true);\n  }\n\n  forOperation(\n    operationName: string,\n    uri: { toString(): string },\n    options: { resetPath?: boolean; resetVisits?: boolean } = {}\n  ) {\n    const encodedOperation = encodePathNode(operationName, uri);\n\n    if (this.path.includes(encodedOperation)) {\n      const formattedPath = this.path\n        .map((segment) => {\n          const { operationName, uri } = decodePathNode(segment);\n\n          return `${operationName}(${uri.toString()})`;\n        })\n        .join(' -> ');\n\n      throw this._wrapError(\n        new Error(\n          `Detected a recursive call to the operation '${operationName}' for '${uri.toString()}' at path '${formattedPath}'`\n        )\n      );\n    }\n\n    return new ResolverContext({\n      cache: this.cache,\n      cacheInvalidations: this.cacheInvalidations,\n      debug: this.debugMode,\n      decoder: this.decoder,\n      path: options.resetPath ? [] : this.path.concat(encodedOperation),\n      resolver: this.resolver,\n      settings: this.settings,\n      strategy: this.strategy,\n      token: this.tokenSource.token,\n      visits: options.resetVisits ? new Visits(uri) : this.visits.child(uri),\n    });\n  }\n\n  getCanonicalUrl(uri: Uri): StrategyResult<ResolverStrategy.CanonicalizeResult> {\n    const method = this.strategy.getCanonicalUrl;\n    const receiver = this.strategy;\n    const operationName = 'Strategy.getCanonicalUrl';\n    const href = uri.toString();\n\n    return this.runInChildContext(operationName, uri, (ctx) =>\n      ctx.runWithCache(operationName, href, method, receiver, ctx, uri)\n    );\n  }\n\n  getResolveRoot(uri: Uri): StrategyResult<ResolverStrategy.ResolveRootResult> {\n    const method = this.strategy.getResolveRoot;\n    const receiver = this.strategy;\n    const operationName = 'Strategy.getResolveRoot';\n    const href = uri.toString();\n\n    return this.runInChildContext(operationName, uri, (ctx) =>\n      ctx.runWithCache(operationName, href, method, receiver, ctx, uri)\n    );\n  }\n\n  getSettings(uri: Uri): StrategyResult<ResolverStrategy.SettingsResult> {\n    const method = this.strategy.getSettings;\n    const receiver = this.strategy;\n    const operationName = 'Strategy.getSettings';\n    const href = uri.toString();\n\n    return this.runInChildContext(operationName, uri, (ctx) =>\n      ctx.runWithCache(operationName, href, method, receiver, ctx, uri)\n    );\n  }\n\n  getUrlForBareModule(\n    name: string,\n    spec: string,\n    path: string\n  ): StrategyResult<ResolverStrategy.BareModuleResult> {\n    const method = this.strategy.getUrlForBareModule;\n\n    if (!method) {\n      return Promise.reject(\n        new Error(\n          `Unable to resolve bare module spec '${name}@${spec}${path}' because no strategy was found that supports resolving bare modules`\n        )\n      );\n    }\n\n    const receiver = this.strategy;\n    const operationName = 'Strategy.getUrlForBareModule';\n    const href = `${name}@${spec}${path}`;\n\n    return this.runInChildContext(operationName, href, (ctx) =>\n      ctx.runWithCache(operationName, href, method, receiver, ctx, name, spec, path)\n    );\n  }\n\n  invalidate(uri: Uri) {\n    const href = uri.toString();\n    const invalidations = this.cacheInvalidations.get(href);\n    let invalidated = false;\n\n    if (invalidations) {\n      for (const { cacheKey, operationCache } of invalidations) {\n        invalidated = operationCache.delete(cacheKey) || invalidated;\n      }\n    }\n\n    this.cacheInvalidations.deleteAll(href);\n\n    return invalidated;\n  }\n\n  listEntries(uri: Uri): StrategyResult<ResolverStrategy.ListEntriesResult> {\n    const method = this.strategy.listEntries;\n    const receiver = this.strategy;\n    const operationName = 'Strategy.listEntries';\n    const href = uri.toString();\n\n    return this.runInChildContext(operationName, uri, (ctx) =>\n      ctx.runWithCache(operationName, href, method, receiver, ctx, uri)\n    );\n  }\n\n  readFileContent(uri: Uri): StrategyResult<ResolverStrategy.ReadFileContentResult> {\n    const method = this.strategy.readFileContent;\n    const receiver = this.strategy;\n    const operationName = 'Strategy.readFileContent';\n    const href = uri.toString();\n\n    this.recordVisit(uri, ResolverContext.VisitKind.File);\n\n    return this.runInChildContext(operationName, uri, (ctx) =>\n      ctx.runWithCache(operationName, href, method, receiver, ctx, uri)\n    );\n  }\n\n  readParentPackageJson(uri: Uri): StrategyResult<ReadParentPackageJsonResultInternal> {\n    return this.runWithCache(\n      'readParentPackageJson',\n      uri.toString(),\n      readParentPackageJson,\n      null,\n      this,\n      uri\n    );\n  }\n\n  recordVisit(uri: Uri, type: ResolverContext.VisitKind = ResolverContext.VisitKind.File) {\n    this.visits.push({ type, uri });\n  }\n\n  resolve(spec: string, fromUri: Uri): StrategyResult<ResolveResult> {\n    const method = resolveDependency;\n    const receiver = null;\n    const operationName = 'resolve';\n    const href = `${fromUri}|${spec}`;\n\n    return this.runInChildContext(operationName, href, (ctx) =>\n      ctx.runWithCache(operationName, href, method, receiver, ctx, fromUri, spec)\n    );\n  }\n\n  resolveUri(uri: Uri): StrategyResult<ResolveResult> {\n    const method = resolve;\n    const receiver = null;\n    const operationName = 'resolveUri';\n    const href = uri.toString();\n\n    return this.runInChildContext(operationName, uri, (ctx) =>\n      ctx.runWithCache(operationName, href, method, receiver, ctx, uri)\n    );\n  }\n\n  runInChildContext<T>(\n    operationName: string,\n    uri: { toString(): string },\n    contextFn: (ctx: ResolverContext) => T\n  ): T {\n    return this.runInContext(\n      operationName,\n      uri,\n      { resetPath: false, resetVisits: false },\n      contextFn\n    );\n  }\n\n  runInIsolatedContext<T>(\n    operationName: string,\n    uri: { toString(): string },\n    contextFn: (ctx: ResolverContext) => T\n  ): T {\n    return this.runInContext(operationName, uri, { resetPath: true, resetVisits: true }, contextFn);\n  }\n\n  private runInContext<T>(\n    operationName: string,\n    uri: { toString(): string },\n    options: { resetPath: boolean; resetVisits: boolean },\n    contextFn: (ctx: ResolverContext) => T\n  ) {\n    const ctx = this.forOperation(operationName, uri, options);\n\n    ctx.debug('%s(%s)', operationName, uri.toString());\n\n    return contextFn(ctx);\n  }\n\n  private createStoreResultFn<TMethod extends (...args: any[]) => any>(\n    operationCache: Map<string, ReturnTypeWithVisits<TMethod>>,\n    cacheKey: string\n  ) {\n    return (result: ReturnTypeWithVisits<TMethod>) => {\n      const mappedResult = this.mapResultWithVisits(result);\n      const visited = mappedResult.visited as ResolverContext.Visit[];\n\n      if (mappedResult[CACHE]) {\n        const cacheEntries = mappedResult[CACHE] as [string, ReturnTypeWithVisits<TMethod>][];\n        delete mappedResult[CACHE];\n\n        for (const [cacheKey, value] of cacheEntries) {\n          operationCache.set(cacheKey, value);\n\n          for (const visit of visited) {\n            this.cacheInvalidations.add(visit.uri.toString(), { cacheKey, operationCache });\n          }\n        }\n      }\n\n      // Override the pending value with the resolved value\n      operationCache.set(cacheKey, mappedResult);\n\n      for (const visit of visited) {\n        this.cacheInvalidations.add(visit.uri.toString(), { cacheKey, operationCache });\n      }\n\n      return mappedResult;\n    };\n  }\n\n  private runWithCache<TMethod extends (...args: any[]) => any>(\n    cacheSegment: string,\n    cacheKey: string,\n    fn: TMethod,\n    target: unknown,\n    ...args: Parameters<TMethod>\n  ): ReturnTypeWithVisits<TMethod> {\n    let operationCache = this.cache.get(cacheSegment) as\n      | Map<string, ReturnTypeWithVisits<TMethod>>\n      | undefined;\n\n    if (!operationCache) {\n      operationCache = new Map();\n      this.cache.set(cacheSegment, operationCache);\n    }\n\n    const cached = operationCache.get(cacheKey);\n\n    if (cached) {\n      this.debug('%s(%s) [HIT]', cacheSegment, cacheKey);\n\n      // We either have a cached result or a cached promise for a result. Either way, the value\n      // is suitable as a return.\n      return cached;\n    }\n\n    const cacheResult = this.createStoreResultFn(operationCache, cacheKey);\n\n    this.debug('%s(%s) [MISS]', cacheSegment, cacheKey);\n\n    // Nothing is cached\n    const ret = fn.apply(target, args);\n\n    if (isThenable(ret)) {\n      const promiseRet = ret as Thenable<ReturnTypeWithVisits<TMethod>>;\n\n      // Produce a promise that will only be settled once the cache has been updated accordingly.\n      const wrappedRet = promiseRet.then(cacheResult, (err) => {\n        // Delete the entry from the cache in case it was a transient failure\n        operationCache!.delete(cacheKey);\n\n        return Promise.reject(err);\n      });\n\n      // Set the pending value in the cache for now\n      operationCache.set(cacheKey, wrappedRet as Awaited<Thenable<ReturnTypeWithVisits<TMethod>>>);\n\n      return wrappedRet as Awaited<Thenable<ReturnTypeWithVisits<TMethod>>>;\n    }\n\n    return cacheResult(ret);\n  }\n\n  private _wrapError<T extends Error>(\n    err: T\n  ): T & { path: { operationName: string; uri: Uri | string }[] } {\n    return Object.assign(err, {\n      path: this.path.map(decodePathNode),\n    });\n  }\n\n  debug(...args: Parameters<Console['warn']>) {\n    if (this.debugMode) {\n      if (typeof args[0] === 'string') {\n        args[0] = ' '.repeat(this.path.length) + args[0];\n      }\n      console.warn(...args);\n    }\n  }\n}\n\nfunction encodePathNode(operationName: string, uri: { toString(): string }) {\n  return `${operationName}:${uri.toString()}`;\n}\n\nfunction decodePathNode(node: string) {\n  const parts = node.split(':', 2);\n\n  if (parts.length !== 2) {\n    console.log('WTF', { node, parts });\n    throw new Error(`Invariant violation: Unexpected path node: '${node}'`);\n  }\n\n  return {\n    operationName: parts[0],\n    uri: parts[1].includes(':') ? Uri.parse(parts[1]) : parts[1],\n  };\n}\n\nasync function resolve(ctx: ResolverContext, uri: Uri): Promise<ResolveResult> {\n  const bothResolved = all(\n    [ctx.getCanonicalUrl(uri), ctx.getResolveRoot(uri), ctx.getSettings(uri)],\n    ctx.token\n  );\n\n  const [canonicalizationResult, resolveRootResult, settingsResult] = isThenable(bothResolved)\n    ? await checkCancellation(bothResolved, ctx.token)\n    : bothResolved;\n\n  const rootUri = resolveRootResult.uri;\n  const rootUriWithoutTrailingSlash = Uri.ensureTrailingSlash(rootUri, '');\n\n  if (!Uri.isPrefixOf(rootUriWithoutTrailingSlash, canonicalizationResult.uri)) {\n    throw new Error(\n      `Unable to resolve a module whose path ${canonicalizationResult.uri.toString(\n        true\n      )} is above the host's root ${rootUri.toString()}`\n    );\n  }\n\n  const resolveReturn =\n    Uri.equals(rootUriWithoutTrailingSlash, canonicalizationResult.uri) ||\n    Uri.equals(rootUri, canonicalizationResult.uri)\n      ? ctx.runInChildContext('resolveAsDirectory', canonicalizationResult.uri, (ctx) =>\n          resolveAsDirectory(\n            ctx,\n            Uri.ensureTrailingSlash(canonicalizationResult.uri),\n            resolveRootResult.uri,\n            settingsResult.settings\n          )\n        )\n      : ctx.runInChildContext('resolveAsFile', canonicalizationResult.uri, (ctx) =>\n          resolveAsFile(\n            ctx,\n            canonicalizationResult.uri,\n            resolveRootResult.uri,\n            settingsResult.settings,\n            null\n          )\n        );\n  const readParentPackageJsonReturn = ctx.readParentPackageJson(uri);\n  const resolveAndPackageJson = all([resolveReturn, readParentPackageJsonReturn], ctx.token);\n  const [resolveResult, readParentPackageJsonResult] = isThenable(resolveAndPackageJson)\n    ? await resolveAndPackageJson\n    : resolveAndPackageJson;\n\n  return {\n    ...resolveResult,\n    parentPackageJson: readParentPackageJsonResult.found\n      ? {\n          packageJson: readParentPackageJsonResult.packageJson,\n          uri: readParentPackageJsonResult.uri,\n        }\n      : undefined,\n  };\n}\n\nasync function resolveDependency(ctx: ResolverContext, fromUri: Uri, spec: string) {\n  const parsedSpec = parseBareModuleSpec(spec);\n\n  if (parsedSpec) {\n    return ctx.runInChildContext('resolveBareModule', fromUri, (ctx) =>\n      resolveBareModule(ctx, fromUri, parsedSpec)\n    );\n  }\n\n  const relativeUri = Uri.joinPath(\n    Uri.from({\n      ...fromUri,\n      path: dirname(fromUri.path),\n    }),\n    spec\n  );\n\n  return ctx.runInChildContext('resolveUri', relativeUri, (ctx) => resolve(ctx, relativeUri));\n}\n\nasync function resolveBareModule(ctx: ResolverContext, uri: Uri, parsedSpec: BareModuleSpec) {\n  let locatorName = parsedSpec.name;\n  let locatorSpec = parsedSpec.spec;\n  let locatorPath = parsedSpec.path;\n\n  if (!locatorSpec) {\n    const resolveRootReturn = ctx.getResolveRoot(uri);\n    const resolveRootResult = isThenable(resolveRootReturn)\n      ? await checkCancellation(resolveRootReturn, ctx.token)\n      : resolveRootReturn;\n\n    let nextUri = uri;\n    let maxIterations = 10;\n\n    while (Uri.isPrefixOf(resolveRootResult.uri, nextUri)) {\n      if (--maxIterations <= 0) {\n        throw new Error('Max iterations reached');\n      }\n\n      const parentPackageJsonReturn = ctx.readParentPackageJson(uri);\n      const parentPackageJsonResult = isThenable(parentPackageJsonReturn)\n        ? await checkCancellation(parentPackageJsonReturn, ctx.token)\n        : parentPackageJsonReturn;\n\n      if (!parentPackageJsonResult.found) {\n        throw new DependencyNotFoundError(parsedSpec.nameSpec, uri);\n      }\n      ctx.recordVisit(parentPackageJsonResult.uri, ResolverContext.VisitKind.File);\n\n      if (parentPackageJsonResult.packageJson.name === parsedSpec.name) {\n        // We found a parent directory that *IS* the module we're looking for\n        const directoryUri = Uri.ensureTrailingSlash(\n          Uri.joinPath(parentPackageJsonResult.uri, '../')\n        );\n        return ctx.runInChildContext('resolveAsDirectory', directoryUri, (ctx) =>\n          resolveAsDirectory(ctx, directoryUri, resolveRootResult.uri, ctx.settings)\n        );\n      }\n\n      const dependencies = {\n        ...(parentPackageJsonResult.packageJson.devDependencies || {}),\n        ...(parentPackageJsonResult.packageJson.peerDependencies || {}),\n        ...(parentPackageJsonResult.packageJson.dependencies || {}),\n      };\n\n      locatorSpec = dependencies[parsedSpec.name];\n\n      if (locatorSpec) {\n        break;\n      }\n\n      nextUri = Uri.joinPath(parentPackageJsonResult.uri, '..');\n\n      if (Uri.equals(nextUri, resolveRootResult.uri)) {\n        break;\n      }\n    }\n  }\n\n  if (!locatorSpec) {\n    const builtIn = NODE_CORE_SHIMS[parsedSpec.name];\n\n    if (builtIn) {\n      locatorName = builtIn.name;\n      locatorSpec = builtIn.spec;\n      locatorPath = builtIn.path;\n    }\n  }\n\n  if (!locatorSpec) {\n    throw new DependencyNotFoundError(parsedSpec.nameSpec, uri);\n  }\n\n  const bareModuleUriReturn = ctx.getUrlForBareModule(locatorName, locatorSpec, locatorPath);\n  const bareModuleUriResult = isThenable(bareModuleUriReturn)\n    ? await checkCancellation(bareModuleUriReturn, ctx.token)\n    : bareModuleUriReturn;\n\n  if (!bareModuleUriResult.found) {\n    throw new DependencyNotFoundError(parsedSpec.nameSpec, uri);\n  }\n\n  if (!bareModuleUriResult.uri) {\n    // TODO: Inject empty module\n    throw new EntryExcludedError(parsedSpec.nameSpec);\n  }\n\n  const resolveReturn = ctx.resolveUri(bareModuleUriResult.uri);\n  const resolveResult = isThenable(resolveReturn)\n    ? await checkCancellation(resolveReturn, ctx.token)\n    : resolveReturn;\n\n  return resolveResult;\n}\nexport namespace ResolverContext {\n  export interface Options {\n    cache: Map<string, Map<string, unknown>>;\n    cacheInvalidations: MapSet<string, InvalidationRecord>;\n    debug: boolean;\n    decoder: Decoder;\n    path: string[];\n    resolver: Resolver;\n    settings: Resolver.Settings;\n    strategy: ResolverStrategy;\n    token: CancellationToken;\n    visits: Visits;\n  }\n\n  export enum VisitKind {\n    Directory = 'Directory',\n    File = 'File',\n  }\n\n  export type Visit =\n    | {\n        type: VisitKind.Directory;\n        uri: Uri;\n      }\n    | {\n        type: VisitKind.File;\n        uri: Uri;\n      };\n}\n\nasync function resolveAsDirectory(\n  ctx: ResolverContext,\n  uri: Uri,\n  rootUri: Uri,\n  settings: Resolver.Settings\n): Promise<ResolveResult> {\n  ctx.recordVisit(uri, ResolverContext.VisitKind.Directory);\n\n  const listEntriesReturn = ctx.listEntries(uri);\n  const listEntriesResult = isThenable(listEntriesReturn)\n    ? await checkCancellation(listEntriesReturn, ctx.token)\n    : listEntriesReturn;\n\n  let mainPathname = 'index';\n\n  // Step 1: Look for a package.json with an main field\n  const packageJsonUri = Uri.joinPath(uri, './package.json');\n\n  ctx.recordVisit(packageJsonUri, ResolverContext.VisitKind.File);\n\n  const packageJsonEntry = listEntriesResult.entries.find(\n    (entry) =>\n      entry.type === ResolverStrategy.EntryKind.File && Uri.equals(packageJsonUri, entry.uri)\n  );\n\n  let packageJson: PartialPackageJson | null = null;\n\n  if (packageJsonEntry) {\n    const packageJsonContentReturn = ctx.readFileContent(packageJsonUri);\n    const packageJsonContentResult = isThenable(packageJsonContentReturn)\n      ? await checkCancellation(packageJsonContentReturn, ctx.token)\n      : packageJsonContentReturn;\n\n    packageJson = parseBufferAsPartialPackageJson(\n      ctx.decoder,\n      packageJsonContentResult.content,\n      uri.toString()\n    );\n\n    for (const packageMain of settings.packageMain) {\n      const pathname = packageJson[packageMain];\n      if (typeof pathname === 'string') {\n        mainPathname = pathname;\n        break;\n      }\n    }\n  }\n\n  const fileUri = Uri.joinPath(uri, mainPathname);\n\n  return ctx.runInChildContext('resolveAsFile', uri, (ctx) =>\n    resolveAsFile(ctx, fileUri, rootUri, settings, packageJson)\n  );\n}\n\nasync function resolveAsFile(\n  ctx: ResolverContext,\n  uri: Uri,\n  rootUri: Uri,\n  settings: Resolver.Settings,\n  packageJson: PartialPackageJson | null,\n  ignoreBrowserOverrides = false\n): Promise<ResolveResult> {\n  if (uri.path === '' || uri.path === '/') {\n    throw new TypeError(`Unable to resolve the root as a file: ${uri.toString()}`);\n  }\n\n  ctx.recordVisit(uri, ResolverContext.VisitKind.File);\n\n  const browserOverrides = new Map<string, Uri | false>();\n\n  if (packageJson === null) {\n    // The parent package.json is only interesting if we are going to look at the `browser`\n    // field and then consider browser mapping overrides in there.\n    const parentPackageJsonResult =\n      settings.packageMain.includes('browser') && !ignoreBrowserOverrides\n        ? await checkCancellation(\n            ctx.runInChildContext('readParentPackageJsonInternal', uri, (ctx) =>\n              readParentPackageJsonInternal(ctx, uri, rootUri, { uriIsCanonicalized: true })\n            ),\n            ctx.token\n          )\n        : undefined;\n    if (parentPackageJsonResult && parentPackageJsonResult.found) {\n      ctx.recordVisit(parentPackageJsonResult.uri, ResolverContext.VisitKind.File);\n\n      packageJson = parentPackageJsonResult.packageJson;\n\n      if (\n        parentPackageJsonResult.packageJson.browser &&\n        typeof parentPackageJsonResult.packageJson.browser === 'object'\n      ) {\n        const browserMap = parentPackageJsonResult.packageJson.browser;\n        const packageJsonDir = Uri.joinPath(parentPackageJsonResult.uri, '..');\n\n        for (const entry in browserMap) {\n          const impliedUri = Uri.joinPath(packageJsonDir, entry);\n          const targetSpec = browserMap[entry];\n          const target = targetSpec === false ? false : Uri.joinPath(packageJsonDir, targetSpec);\n\n          if (Uri.equals(impliedUri, uri)) {\n            if (target === false) {\n              return {\n                found: false,\n                uri: null,\n              };\n            }\n\n            // console.warn('REMAPPED %s to %s', url, target);\n\n            // We found an exact match so let's make sure we resolve the re-mapped file but\n            // also that we don't go through the browser overrides rodeo again.\n            return ctx.runInChildContext('resolveAsFile', target, (ctx) =>\n              resolveAsFile(ctx, target, rootUri, settings, packageJson, true)\n            );\n          }\n\n          browserOverrides.set(impliedUri.toString(), target);\n        }\n      }\n    }\n  }\n\n  const containingDirUri = Uri.ensureTrailingSlash(Uri.joinPath(uri, '..'));\n\n  const filename = basename(uri.path);\n  const entriesReturn = ctx.listEntries(containingDirUri);\n  const entriesResult = isThenable(entriesReturn)\n    ? await checkCancellation(entriesReturn, ctx.token)\n    : entriesReturn;\n  const entryDirectoryMap = new Map<string, ResolverStrategy.Entry>();\n  const entryFileMap = new Map<string, ResolverStrategy.Entry<ResolverStrategy.EntryKind.File>>();\n\n  for (const entry of entriesResult.entries) {\n    if (Uri.equals(entry.uri, uri) && entry.type == ResolverStrategy.EntryKind.File) {\n      // Found an exact match\n      return {\n        found: true,\n        rootUri,\n        uri,\n      };\n    }\n\n    if (entry.type === ResolverStrategy.EntryKind.Directory) {\n      const childFilename = Uri.getFirstPathSegmentAfterPrefix(entry.uri, containingDirUri);\n\n      entryDirectoryMap.set(childFilename, entry);\n    } else if (entry.type === ResolverStrategy.EntryKind.File) {\n      const childFilename = basename(entry.uri.path);\n\n      entryFileMap.set(\n        childFilename,\n        entry as ResolverStrategy.Entry<ResolverStrategy.EntryKind.File>\n      );\n    }\n  }\n\n  // Look for browser overrides\n  for (const ext of settings.extensions) {\n    const hrefWithExtensionUri = uri.with({ path: `${uri.path}${ext}` });\n    const hrefWithExtension = hrefWithExtensionUri.toString();\n    const mapping = browserOverrides.get(hrefWithExtension);\n\n    ctx.recordVisit(hrefWithExtensionUri, ResolverContext.VisitKind.File);\n\n    if (mapping === false) {\n      // console.warn('REMAPPED %s to undefined', url);\n      return {\n        found: true,\n        rootUri,\n        uri: null,\n      };\n    } else if (mapping) {\n      // console.warn('REMAPPED %s to %s', url, mapping);\n\n      return ctx.runInChildContext('resolveAsFile', mapping, (ctx) =>\n        resolveAsFile(ctx, mapping, rootUri, settings, packageJson, true)\n      );\n    }\n\n    const match = entryFileMap.get(`${filename}${ext}`);\n    if (match) {\n      if (match.type !== ResolverStrategy.EntryKind.File) {\n        continue;\n      }\n\n      return {\n        found: true,\n        rootUri,\n        uri: match.uri,\n      };\n    }\n  }\n\n  // First, attempt to find a matching file or directory\n  const match = entryDirectoryMap.get(filename);\n  if (match) {\n    if (match.type !== ResolverStrategy.EntryKind.Directory) {\n      throw new Error(`Invariant violation ${match.type} is unexpected`);\n    }\n\n    return ctx.runInChildContext('resolveAsDirectory', match.uri, (ctx) =>\n      resolveAsDirectory(ctx, Uri.ensureTrailingSlash(match.uri), rootUri, settings)\n    );\n  }\n\n  throw new EntryNotFoundError(uri);\n}\n\nasync function readParentPackageJson(ctx: ResolverContext, uri: Uri) {\n  const canonicalizationReturn = ctx.getCanonicalUrl(uri);\n  const resolveRootReturn = ctx.getResolveRoot(uri);\n  const bothResolved = all([canonicalizationReturn, resolveRootReturn], ctx.token);\n  const [canonicalizationResult, resolveRootResult] = isThenable(bothResolved)\n    ? await checkCancellation(bothResolved, ctx.token)\n    : bothResolved;\n  const readReturn = ctx.runInChildContext(\n    'readParentPackageJsonInternal',\n    canonicalizationResult.uri,\n    (ctx) =>\n      readParentPackageJsonInternal(ctx, canonicalizationResult.uri, resolveRootResult.uri, {\n        uriIsCanonicalized: true,\n      })\n  );\n  const readResult = isThenable(readReturn) ? await readReturn : readReturn;\n\n  if (readResult.found && readResult.visitedDirs) {\n    const visitedDirs = readResult.visitedDirs;\n    delete readResult.visitedDirs;\n\n    (readResult as any)[CACHE] = visitedDirs.map((uri) => [uri.toString(), { ...readResult, uri }]);\n  }\n\n  return readResult as ReadParentPackageJsonResultInternal;\n}\n\nasync function readParentPackageJsonInternal(\n  ctx: ResolverContext,\n  uri: Uri,\n  rootUri: Uri,\n  options: { uriIsCanonicalized: boolean }\n): Promise<ReadParentPackageJsonResultInternal> {\n  if (!options.uriIsCanonicalized) {\n    const canonicalizationReturn = ctx.getCanonicalUrl(uri);\n    const canonicalizationResult = isThenable(canonicalizationReturn)\n      ? await checkCancellation(canonicalizationReturn, ctx.token)\n      : canonicalizationReturn;\n\n    uri = canonicalizationResult.uri;\n  }\n\n  const hostRootHref = Uri.ensureTrailingSlash(rootUri);\n  const containingDirUrl = Uri.ensureTrailingSlash(Uri.joinPath(uri, '..'));\n  const visitedDirs = [] as Uri[];\n\n  const readPackageJsonOrRecurse = async (\n    ctx: ResolverContext,\n    dir: Uri\n  ): Promise<ReadParentPackageJsonResultInternal> => {\n    if (!Uri.isPrefixOf(hostRootHref, dir)) {\n      // Terminal condition for recursion\n      return {\n        found: false,\n        packageJson: null,\n        uri: null,\n      };\n    }\n\n    ctx.recordVisit(dir, ResolverContext.VisitKind.Directory);\n\n    const entriesReturn = ctx.listEntries(dir);\n    const entriesResult = isThenable(entriesReturn)\n      ? await checkCancellation(entriesReturn, ctx.token)\n      : entriesReturn;\n    const packageJsonUri = Uri.joinPath(dir, 'package.json');\n    const packageJsonEntry = entriesResult.entries.find(\n      (entry) =>\n        entry.type === ResolverStrategy.EntryKind.File && Uri.equals(entry.uri, packageJsonUri)\n    );\n\n    ctx.recordVisit(packageJsonUri, ResolverContext.VisitKind.File);\n\n    if (packageJsonEntry) {\n      // Found! Let's try to parse\n      try {\n        const parentPackageJsonContentReturn = ctx.readFileContent(packageJsonUri);\n        const parentPackageJsonContentResult = isThenable(parentPackageJsonContentReturn)\n          ? await checkCancellation(parentPackageJsonContentReturn, ctx.token)\n          : parentPackageJsonContentReturn;\n\n        const packageJson = parseBufferAsPackageJson(\n          ctx.decoder,\n          parentPackageJsonContentResult.content,\n          packageJsonUri.toString()\n        );\n\n        return { found: true, packageJson, uri: packageJsonUri, visitedDirs };\n      } catch (err) {\n        if (err instanceof CanceledError || (err && err.name === 'CanceledError')) {\n          throw err;\n        }\n\n        // TODO: Maybe issue some warning?\n      }\n    }\n\n    // Not found here, let's try one up\n    const parentDir = Uri.ensureTrailingSlash(Uri.joinPath(dir, '..'));\n\n    // Skip infinite recursion\n    if (Uri.equals(dir, parentDir) || Uri.isPrefixOf(dir, parentDir)) {\n      return {\n        found: false,\n        packageJson: null,\n        uri: null,\n      };\n    }\n\n    visitedDirs.push(dir);\n\n    return ctx.runInChildContext('readPackageJsonOrRecurse', parentDir, (ctx) =>\n      readPackageJsonOrRecurse(ctx, parentDir)\n    );\n  };\n\n  if (Uri.equals(uri, containingDirUrl) || Uri.isPrefixOf(uri, containingDirUrl)) {\n    return {\n      found: false,\n      packageJson: null,\n      uri: null,\n    };\n  }\n  return ctx.runInChildContext('readPackageJsonOrRecurse', containingDirUrl, (ctx) =>\n    readPackageJsonOrRecurse(ctx, containingDirUrl)\n  );\n}\n","import { CancellationTokenSource, PackageMainField, Uri } from '@velcro/common';\nimport { ResolverContext } from './context';\nimport type { ResolverStrategy } from './strategy';\n\nexport class Resolver {\n  private disposed = false;\n  readonly rootCtx: ResolverContext;\n  private readonly settings: Resolver.Settings;\n  private readonly strategy: ResolverStrategy;\n  private readonly tokenSource = new CancellationTokenSource();\n\n  constructor(strategy: ResolverStrategy, settings: Resolver.Settings) {\n    this.settings = settings;\n    this.strategy = strategy;\n    this.rootCtx = ResolverContext.create(\n      this,\n      this.strategy,\n      this.settings,\n      this.tokenSource.token,\n      { debug: settings.debug }\n    );\n  }\n\n  decode(buf: BufferSource | string): string {\n    if (typeof buf === 'string') {\n      return buf;\n    }\n\n    return this.rootCtx.decoder.decode(buf);\n  }\n\n  dispose() {\n    this.disposed = true;\n    return this.rootCtx.dispose();\n  }\n\n  getCanonicalUrl(uri: string | Uri) {\n    if (this.disposed) {\n      throw new Error('Resolver has been disposed');\n    }\n\n    return this.rootCtx.runInIsolatedContext('Resolver.getCanonicalUrl', uri, (ctx) =>\n      ctx.getCanonicalUrl(typeof uri === 'string' ? Uri.parse(uri) : uri)\n    );\n  }\n\n  getResolveRoot(uri: string | Uri) {\n    if (this.disposed) {\n      throw new Error('Resolver has been disposed');\n    }\n\n    return this.rootCtx.runInIsolatedContext('Resolver.getResolveRoot', uri, (ctx) =>\n      ctx.getResolveRoot(typeof uri === 'string' ? Uri.parse(uri) : uri)\n    );\n  }\n\n  getSettings(uri: string | Uri) {\n    if (this.disposed) {\n      throw new Error('Resolver has been disposed');\n    }\n\n    return this.rootCtx.runInIsolatedContext('Resolver.getSettings', uri, (ctx) =>\n      ctx.getSettings(typeof uri === 'string' ? Uri.parse(uri) : uri)\n    );\n  }\n\n  getUrlForBareModule(name: string, spec: string, path: string) {\n    if (this.disposed) {\n      throw new Error('Resolver has been disposed');\n    }\n\n    return this.rootCtx.runInIsolatedContext(\n      'Resolver.getUrlForBareModule',\n      `${name}|${spec}|${path}`,\n      (ctx) => ctx.getUrlForBareModule(name, spec, path)\n    );\n  }\n\n  invalidate(uri: string | Uri) {\n    if (this.disposed) {\n      throw new Error('Resolver has been disposed');\n    }\n\n    return this.rootCtx.runInIsolatedContext('Resolver.invalidate', uri, (ctx) =>\n      ctx.invalidate(typeof uri === 'string' ? Uri.parse(uri) : uri)\n    );\n  }\n\n  listEntries(uri: Uri) {\n    if (this.disposed) {\n      throw new Error('Resolver has been disposed');\n    }\n\n    return this.rootCtx.runInIsolatedContext('Resolver.listEntries', uri, (ctx) =>\n      ctx.listEntries(typeof uri === 'string' ? Uri.parse(uri) : uri)\n    );\n  }\n\n  readFileContent(uri: Uri) {\n    if (this.disposed) {\n      throw new Error('Resolver has been disposed');\n    }\n\n    return this.rootCtx.runInIsolatedContext('Resolver.readFileContent', uri, (ctx) =>\n      ctx.readFileContent(typeof uri === 'string' ? Uri.parse(uri) : uri)\n    );\n  }\n\n  readParentPackageJson(uri: Uri) {\n    if (this.disposed) {\n      throw new Error('Resolver has been disposed');\n    }\n\n    return this.rootCtx.runInIsolatedContext('Resolver.readParentPackageJson', uri, (ctx) =>\n      ctx.readParentPackageJson(typeof uri === 'string' ? Uri.parse(uri) : uri)\n    );\n  }\n\n  resolve(spec: Uri): ReturnType<ResolverContext['resolve']>;\n  resolve(spec: string, fromUri: Uri): ReturnType<ResolverContext['resolve']>;\n  resolve(spec: string | Uri, fromUri?: Uri): ReturnType<ResolverContext['resolve']> {\n    if (this.disposed) {\n      throw new Error('Resolver has been disposed');\n    }\n\n    if (Uri.isUri(spec)) {\n      return this.rootCtx.runInIsolatedContext('Resolver.resolveUri', spec, (ctx) =>\n        ctx.resolveUri(spec)\n      );\n    }\n\n    if (!fromUri) {\n      throw new Error(\n        'When calling Resolver.resolve with a string spec, a second \"fromUri\" argument is required'\n      );\n    }\n\n    return this.rootCtx.runInIsolatedContext(\n      'Resolver.resolve',\n      `${fromUri ? fromUri.toString() : ''}|${spec}`,\n      (ctx) => ctx.resolve(spec, fromUri)\n    );\n  }\n}\n\nexport namespace Resolver {\n  export interface Settings {\n    debug?: boolean;\n    extensions: string[];\n    packageMain: PackageMainField[];\n  }\n}\n"],"sourceRoot":""}