{"version":3,"sources":["../../@velcro/common/dist/dist-module/index.js","../../@velcro/strategy-memory/dist/dist-module/index.js","lib/EditorManager.ts","../../@velcro/bundler/dist/dist-module/index.js","playground/Editor.tsx","../../@velcro/plugin-css/dist/dist-module/index.js","../../@velcro/plugin-sucrase/dist/dist-module/index.js","../../@velcro/strategy-cdn/dist/dist-module/index.js","../../@velcro/strategy-compound/dist/dist-module/index.js","velcro/index.ts","playground/Preview.tsx","lib/hooks.ts","playground/Sidebar.tsx","playground/Playground.tsx","templates/react.ts","useServiceWorker.tsx","App.tsx","index.tsx","../../@velcro/resolver/dist/dist-module/index.js"],"names":["Base64","BaseError","arguments","name","constructor","Error","CanceledError","EntryExcludedError","uri","toString","EntryNotFoundError","DependencyNotFoundError","spec","parentUri","isCanceledError","err","all","values","token","shouldAwait","result","map","element","isThenable","checkCancellation","Promise","promise","a","isCancellationRequested","reject","object","then","decode","global","data","from","atob","decodeURIComponent","escape","_data","encode","btoa","unescape","encodeURIComponent","Decoder","TextDecoder","this","decoder","Buffer","buf","str","charCodeAt","slice","MapSet","Map","key","value","get","Set","set","add","clear","ret","delete","size","has","entries","hasInvalidBrowserField","json","error","browser","hasInvalidRequiredStringField","field","hasInvalidOptionalStringField","undefined","hasInvalidDependenciesField","Object","keys","every","parseBufferAsPartialPackageJson","content","parseTextAsPartialPackageJson","message","parseBufferAsPackageJson","text","isValidPackageJson","parseTextAsPackageJson","JSON","parse","isValidPartialPackageJson","ErrorInvalidArgType","expected","actual","determiner","indexOf","replace","type","msg","code","validateString","isPosixPathSeparator","normalizeString","path","allowAboveRoot","separator","isPathSeparator","res","lastSegmentLength","lastSlash","dots","i","length","lastSlashIndex","lastIndexOf","posix","resolve","resolvedPath","resolvedAbsolute","process","cwd","normalize","isAbsolute","trailingSeparator","join","joined","arg","relative","to","fromEnd","fromLen","toLen","lastCommonSep","fromCode","out","toNamespacedPath","dirname","hasRoot","end","matchedSlash","basename","ext","start","extIdx","firstNonSlashEnd","extname","startDot","startPart","preDotState","format","sep","pathObject","dir","root","base","bind","delimiter","win32","_schemePattern","_singleSlashStart","_doubleSlashStart","_validateUri","_strict","scheme","authority","query","fragment","test","_schemeFix","_referenceResolution","_slash","_regexp","Uri","schemeOrData","change","_URI","skipEncoding","_asFormatted","uriToFsPath","trailingSlash","with","TRAILING_SLASH_RX","l","r","child","parent","childHref","parentHref","parentOffset","charAt","prefix","startsWith","thing","fsPath","match","exec","percentDecode","idx","substring","components","pathFragment","newPath","_formatted","external","_fsPath","_sep","_pathSepMarker","$mid","encodeTable","encodeURIComponentFast","uriComponent","allowSlash","nativeEncodePos","pos","substr","escaped","encodeURIComponentMinimal","keepDriveLetterCasing","toLowerCase","encoder","userinfo","String","fromCharCode","_rEncodedAsHex","decodeURIComponentGraceful","_a","FileEncoding","encodeText","TextEncoder","buffer","MemoryStrategy","files","rootUri","pathname","ensureTrailingSlash","ResolverStrategy","EntryKind","Directory","children","file","addFile","encoding","segments","Array","isArray","split","filter","Boolean","segment","UTF8","overwrite","filename","pop","entry","File","_ctx","urlPathname","basePathname","fsPathname","getEntryAtPath","joinPath","binSting","binArray","Uint8Array","prototype","forEach","call","_el","arr","AbstractResolverStrategyWithRoot","EditorManager","options","editor","disposableStore","DisposableStore","initialPath","viewState","WeakMap","onWillFocusModelEmitter","Emitter","onDidChangeEmitter","Monaco","typescript","typescriptDefaults","setEagerModelSync","setMaximumWorkerIdleTime","setCompilerOptions","allowJs","allowNonTsExtensions","allowSyntheticDefaultImports","baseUrl","checkJs","esModuleInterop","experimentalDecorators","inlineSourceMap","inlineSources","isolatedModules","jsx","JsxEmit","React","lib","module","ModuleKind","CommonJS","moduleResolution","ModuleResolutionKind","NodeJs","noEmit","outDir","resolveJsonModule","rootDir","sourceMap","target","ScriptTarget","ES2015","typeRoots","setDiagnosticsOptions","noSemanticValidation","noSyntaxValidation","createModel","language","inferLanguage","getModel","href","model","getModelByHref","focusModel","setModel","lineNumber","revealLineInCenter","ScrollType","Smooth","setPosition","column","columnNumber","markers","setModelMarkers","focus","getModelByPath","_","el","create","automaticLayout","minimap","enabled","showUnused","scrollBeyondLastLine","theme","wordWrap","wrappingIndent","onDidDispose","onDidChangeModel","e","newModelUrl","restoreViewState","onDidBlurEditorText","saveViewState","focusPath","dispose","event","EditorManagerContext","createContext","Editor","className","useRef","editorManager","useContext","useEffect","current","mount","ref","charToInteger","chars","mappings","decoded","line","j","shift","c","segmentify","push","integer","hasContinuationBit","shouldNegate","sourceFileIndex","sourceCodeLine","sourceCodeColumn","nameIndex","generatedCodeColumn","lineMappings","_i","line_1","segmentMappings","encodeInteger","num","clamped","SourceMap","input","sourceRoot","names","sources","sourcesContent","version","stringify","getSourceMappingUrlMatch","re","lastMatch","getSourceMappingUrl","updateSourceMappingUrl","url","index","decodeDataUriAsSourceMap","SourceModuleDependencyKind","Source","source","Link","tracedLine","traced","traceSegment","sourceIndex","tracedSegment","m","PluginManager","plugins","load","ctx","id","readReturn","resolver","readFileContent","readResult","visited","resolveDependency","dependency","fromSourceModule","resolveReturn","resolveResult","found","resolveEntrypoint","transform","createMagicString","endsWith","magicString","prepend","generateDecodedMap","plugin","loadReturn","loadResult","fromModule","kind","pluginCtx","assign","MagicString","sourceMapTree","sourceMapRef","sourceMapUri","baseSources","transformReturn","transformResult","SourceModuleDependency","locations","Entrypoint","exportName","GlobalObject","Require","RequireResolve","isArrowFunctionExpression","node","isFunctionDeclaration","isFunctionExpression","isIdentifier","isMemberExpression","isRestElement","isStringLiteral","isLiteral","traverse","ast","visit","enter","leave","_shouldSkip","shouldSkip","context","skipped","childKeys","sort","b","skip","parse$1","visitorCtx","unboundSymbols","locals","indentExclusionRanges","nodeEnv","replacedSymbols","requires","requireResolves","skipTransform","dependencies","parse$2","allowReturnOutsideFunction","sourceType","scopingAndRequiresVisitor","collectGlobalsVisitor","requiresBySpec","requireDependency","fromRequire","requireResolvesBySpec","fromRequireResolve","symbolName","shim","globalModules","fromGlobalObject","export","location","addSourcemapLocation","_parent","isVariableDeclaration","nextParent","isScope","isBlockScope","declarations","declarePattern","declareFunction","isFunction","isClassDeclaration","isTryStatement","handler","param","visitAndCaptureScoping","isIfStatement","isBinaryExpression","operator","left","right","memberExpressionMatches","rootObject","remove","consequent","alternate","visitAndSkipBranches","isCallExpression","callee","firstArg","console","warn","property","visitRequires","nextCheck","contentOnly","storeName","isPropertyOfMemberExpression","isProperty","isKeyOfProperty","isBindingIdentifier","foundBinding","declaresArguments","isThisExpression","declaresThis","params","isObjectPattern","properties","argument","isArrayPattern","elements","isAssignmentPattern","isProgram","isBlockStatement","pattern","memberParts","createRuntime","velcro","runtime","Module","importMap","exports","require","createRequire","imports","scopes","defs","modules","dependents","resolveSpecAgainstImportMap","moduleDefinition","factory","specParts","__filename","__dirname","_spec","invalidations","queue","dependent","scopesForId","mappedId","ChunkOutput","bundle","sourceModules","inputMap","includeContent","hires","sourceMapTreeMappings","sourceHref","sourceModule","sourceMapsTree","traceMappings","cachedCode","cachedSourceMap","generateSourceMap","cachedSourceMapString","cachedSourceMapDataUri","toDataUri","Chunk","edgesFrom","edgesTo","edges","edge","fromHref","fromUri","toHref","toUri","Bundle","moduleScopes","sourceModuleCode","clone","append","addSource","injectRuntime","Graph","DEFAULT_SHIM_GLOBALS","globalThis","SourceModule","visits","Build","disposer","errors","seen","pendingModuleOperations","onCompletedEmitter","onErrorEmitter","onProgressEmitter","done","onCompleted","graph","onError","tokenSource","CancellationTokenSource","cancel","fn","fire","progress","completed","pending","GraphBuilder","edgesByDependency","edgesByInvalidation","sourceModulesByInvalidation","pluginManager","build","dep","runAsync","executeResolveDependency","createEdge","addEdge","loadEdge","hasSourceModule","existingSourceModule","addSourceModule","visitSourceModule","executeLoad","executeTransform","parseResult","toRootUri","executeResolveEntrypoint","fromEntrypoint","existingEdge","loadDependency","entrypoints","loadEntrypoint","isUri","deleteAll","invalidate","fromRootUri","VERSION","sucrasePlugin","extensions","transforms","uriTestRx","RegExp","jsxPragmaRx","jsxFragmentPragmaRx","sucraseOptions","filePath","production","sourceMapOptions","compiledFilename","jsxPragma","jsxPragmaMatches","jsxFragmentPragma","jsxFragmentPragmaMatches","isValidEntry","isValidFile","isValidDirectory","specToString","JSDelivrCdn","specRx","protocol","host","mapChildEntry","matches","dataHost","UnpkgCdn","UNPKG_SPEC_RX","CdnStrategy","readUrlFn","cdn","urlForPackageFile","contentCache","locks","packageEntriesCache","packageJsonCache","isPrefixOf","unresolvedUri","resolveUri","_withRootUriCheck","unresolvedSpec","parseUrl","packageJsonReturn","runInChildContext","_readPackageJsonWithCache","packageJson","results","getResolveRoot","_readPackageEntriesWithCache","resolveRootUri","entriesReturn","canonicalizedSpec","traversalSegments","parentEntry","find","uriStr","cached","recordVisit","ResolverContext","VisitKind","wrappedReturn","debug","_withLock","packageEntriesCacheForModule","exactMatch","range","validRange","satisfies","_readPackageEntries","urlForPackageList","dataStr","normalizePackageListing","packageJsonCacheForModule","_readPackageJson","contentReturn","contentResult","manifest","canonicalHref","lockKey","lock","runCriticalSection","locked","CompoundStrategy","strategies","method","strategy","_delegateToStrategy","getUrlForBareModule","AbstractResolverStrategy","readUrl","fetch","arrayBuffer","VelcroMonaco","monaco","fsm","states","initial","onEvent","transitionTo","stateName","dirty","onEnter","eventName","graphBuilder","buildConfig","autoBuild","waiting","timerHandle","setTimeout","sendEvent","autoBuildWaitTimeout","stateDisposer","clearTimeout","timer_fired","building","Date","now","localStrategy","incremental","onProgress","build_complete","latency","build_error","build_progress","built","onStateChangeEmitter","npmStrategy","forJsDelivr","rootStrategy","mutableBuildState","pendingEvents","Resolver","packageMain","cssCode","BACKSLASH","SINGLE_QUOTE","NL","CR","prependRight","getModels","trackModel","onDidCreateModel","currentStateDef","state","nextStateConfig","fromState","onWillDispose","removeFile","handleChange","disposerReference","getValue","onDidChangeContent","PreviewProgress","props","total","Math","round","PreviewIframeWrap","PreviewWrap","PreviewMessageError","PreviewMessageErrorText","isInternal","PreviewMessages","PreviewMessageLine","PreviewMessage","lines","Preview","previewWrapRef","previewIframeRef","useState","buildState","setBuildState","setMessages","buildProgress","setBuildProgress","onMessage","contentWindow","log","window","addEventListener","removeEventListener","onStateChange","splitChunks","buildForStaticRuntime","codeWithStart","entrypoint","runtimeCode","sourceMapDataUri","codeBundleFile","markup","URL","createObjectURL","htmlUrl","iframe","document","createElement","style","display","src","appendChild","onLoad","once","Entry","modelFocused","color","cursor","backgroundColor","CreateEntry","SidebarFileDelete","Button","StyledTooltip","SidebarFile","activeModel","workbench","setActiveModel","disposable","trackEditor","onDidFocusEditorText","hasTextFocus","onDidCreateEditor","useActiveModel","tooltip","useTooltipState","gutter","onClick","TooltipReference","as","role","aria-label","Tooltip","Sidebar","sortEntries","models","initialEntries","reduce","modelUri","nestedPath","nextDirIdx","setEntries","onWillDisposeModel","findIndex","splice","useDirectory","prompt","onClickCreate","PlaygroundCmp","project","Provider","Playground","react","trim","ServiceWorkerContext","ServiceWorkerProvider","waitingServiceWorker","assetsUpdateReady","assetsCached","useMemo","updateAssets","reload","postMessage","PlaygroundWrapper","StatusBarItem","StatusBarStyles","AppWrapper","Title","Subtitle","Links","Header","globalCss","css","App","CssBaseline","styles","rel","ReactDOM","render","getElementById","SPEC_RX","parseBareModuleSpec","bareModuleSpec","nameSpec","NODE_CORE_SHIMS","string_decoder","punycode","_uri","settings","overrides","setPrototypeOf","CACHE","Symbol","Visits","cmp","equals","toArray","mapResultWithVisits","cache","cacheInvalidations","debugMode","operationName","encodedOperation","encodePathNode","includes","formattedPath","decodePathNode","_wrapError","resetPath","concat","resetVisits","getCanonicalUrl","receiver","runWithCache","getSettings","invalidated","cacheKey","operationCache","listEntries","readParentPackageJson","contextFn","runInContext","forOperation","mappedResult","cacheEntries","cacheSegment","cacheResult","createStoreResultFn","args","apply","promiseRet","wrappedRet","repeat","parts","bothResolved","canonicalizationResult","resolveRootResult","settingsResult","rootUriWithoutTrailingSlash","resolveAsDirectory","resolveAsFile","readParentPackageJsonReturn","resolveAndPackageJson","readParentPackageJsonResult","parentPackageJson","parsedSpec","resolveBareModule","relativeUri","locatorName","locatorSpec","locatorPath","resolveRootReturn","nextUri","maxIterations","parentPackageJsonReturn","parentPackageJsonResult","directoryUri","devDependencies","peerDependencies","builtIn","bareModuleUriReturn","bareModuleUriResult","listEntriesReturn","listEntriesResult","mainPathname","packageJsonUri","packageJsonEntry","packageJsonContentReturn","packageJsonContentResult","fileUri","ignoreBrowserOverrides","TypeError","browserOverrides","readParentPackageJsonInternal","uriIsCanonicalized","browserMap","packageJsonDir","impliedUri","targetSpec","containingDirUri","entriesResult","entryDirectoryMap","entryFileMap","childFilename","getFirstPathSegmentAfterPrefix","hrefWithExtensionUri","hrefWithExtension","mapping","canonicalizationReturn","visitedDirs","hostRootHref","containingDirUrl","readPackageJsonOrRecurse","parentPackageJsonContentReturn","parentPackageJsonContentResult","parentDir","disposed","rootCtx","runInIsolatedContext"],"mappings":"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","file":"static/js/main.6ba50243.chunk.js","sourcesContent":["export { CancellationToken, CancellationTokenSource, DisposableStore, Emitter, Event } from 'ts-primitives';\n\nclass BaseError extends Error {\n    constructor() {\n        super(...arguments);\n        this.name = this.constructor.name;\n    }\n}\nclass AmbiguousModuleError extends BaseError {\n}\nclass CanceledError extends BaseError {\n}\nclass EntryExcludedError extends BaseError {\n    constructor(uri) {\n        super(`Entry was excluded by current configuration '${uri.toString()}'`);\n    }\n}\nclass EntryNotFoundError extends BaseError {\n    constructor(uri) {\n        super(`Unable to resolve '${uri.toString()}'`);\n    }\n}\nclass DependencyNotFoundError extends EntryNotFoundError {\n    constructor(spec, parentUri) {\n        super(`The dependency '${spec}' of '${parentUri.toString()}' was not found`);\n    }\n}\nclass NotResolvableError extends BaseError {\n}\nclass ParseError extends BaseError {\n    constructor(uri, message) {\n        super(`Parsing failed for '${uri.toString()}': ${message}`);\n        this.uri = uri;\n    }\n}\nfunction isCanceledError(err) {\n    return err instanceof CanceledError || (err && err.name === 'CanceledError');\n}\n\n// See: https://github.com/microsoft/TypeScript/pull/26063#issuecomment-461576933\nfunction all(values, token) {\n    let shouldAwait = false;\n    const result = values.map((element) => {\n        if (isThenable(element)) {\n            shouldAwait = true;\n            return checkCancellation(element, token);\n        }\n        return element;\n    });\n    if (shouldAwait) {\n        return Promise.all(result);\n    }\n    return values;\n}\nasync function checkCancellation(promise, token) {\n    try {\n        const result = await promise;\n        if (token.isCancellationRequested) {\n            return Promise.reject(new CanceledError());\n        }\n        return result;\n    }\n    catch (err) {\n        if (token.isCancellationRequested) {\n            return Promise.reject(new CanceledError());\n        }\n        throw err;\n    }\n}\nfunction isThenable(object) {\n    return object && typeof object.then === 'function';\n}\n\nvar Base64;\n(function (Base64) {\n    Base64.decode = typeof global === 'object' && typeof global['Buffer'] === 'function'\n        ? (data) => global['Buffer'].from(data, 'base64').toString('utf-8')\n        : typeof atob === 'function'\n            ? (data) => decodeURIComponent(escape(atob(data)))\n            : (_data) => {\n                throw new Error('The environment has neither the Buffer nor btoa functions. Please consider polyfilling one of these apis.');\n            };\n    Base64.encode = typeof global === 'object' && typeof global['Buffer'] === 'function'\n        ? (data) => global['Buffer'].from(data).toString('base64')\n        : typeof btoa === 'function'\n            ? (data) => btoa(unescape(encodeURIComponent(data)))\n            : (_data) => {\n                throw new Error('The environment has neither the Buffer nor btoa functions. Please consider polyfilling one of these apis.');\n            };\n})(Base64 || (Base64 = {}));\n\nclass Decoder {\n    constructor() {\n        if (typeof TextDecoder !== 'undefined') {\n            this.decoder = new TextDecoder();\n        }\n        else if (typeof Buffer !== 'function' || typeof Buffer['from'] !== 'function') {\n            throw new Error('The environment supports neither the TextDecoder nor Buffer API. Please consider polyfilling one of these.');\n        }\n    }\n    decode(buf) {\n        const str = this.decoder\n            ? this.decoder.decode(buf)\n            : Buffer.from(buf).toString('utf-8');\n        return str.charCodeAt(0) === 0xfeff ? str.slice(1) : str;\n    }\n}\n\nclass MapSet {\n    constructor() {\n        this._data = new Map();\n    }\n    get size() {\n        return this._data.size;\n    }\n    add(key, value) {\n        let values = this._data.get(key);\n        if (!values) {\n            values = new Set();\n            this._data.set(key, values);\n        }\n        values.add(value);\n        return this;\n    }\n    clear() {\n        this._data.clear();\n    }\n    delete(key, value) {\n        const values = this._data.get(key);\n        if (values) {\n            const ret = values.delete(value);\n            if (!values.size) {\n                this._data.delete(key);\n            }\n            return ret;\n        }\n        return false;\n    }\n    deleteAll(key) {\n        return this._data.delete(key);\n    }\n    get(key) {\n        return this._data.get(key);\n    }\n    has(key) {\n        return this._data.has(key);\n    }\n    hasValue(key, value) {\n        const values = this._data.get(key);\n        return values ? values.has(value) : false;\n    }\n    *entries() {\n        for (const [key, values] of this._data.entries()) {\n            for (const value of values) {\n                yield [key, value];\n            }\n        }\n    }\n    *values() {\n        for (const values of this._data.values()) {\n            yield* values.values();\n        }\n    }\n}\n\nfunction isValidPartialPackageJson(json) {\n    return (typeof json === 'object' &&\n        json !== null &&\n        !hasInvalidOptionalStringField(json, 'name') &&\n        !hasInvalidOptionalStringField(json, 'version') &&\n        !hasInvalidBrowserField(json) &&\n        !hasInvalidOptionalStringField(json, 'main') &&\n        !hasInvalidOptionalStringField(json, 'module') &&\n        !hasInvalidOptionalStringField(json, 'jsnext:main') &&\n        !hasInvalidOptionalStringField(json, 'unpkg') &&\n        !hasInvalidDependenciesField(json, 'dependencies') &&\n        !hasInvalidDependenciesField(json, 'devDependencies') &&\n        !hasInvalidDependenciesField(json, 'peerDependencies'));\n}\nfunction isValidPackageJson(json) {\n    return (typeof json === 'object' &&\n        json !== null &&\n        !hasInvalidRequiredStringField(json, 'name') &&\n        !hasInvalidRequiredStringField(json, 'version') &&\n        !hasInvalidBrowserField(json) &&\n        !hasInvalidOptionalStringField(json, 'main') &&\n        !hasInvalidOptionalStringField(json, 'module') &&\n        !hasInvalidOptionalStringField(json, 'jsnext:main') &&\n        !hasInvalidOptionalStringField(json, 'unpkg') &&\n        !hasInvalidDependenciesField(json, 'dependencies') &&\n        !hasInvalidDependenciesField(json, 'devDependencies') &&\n        !hasInvalidDependenciesField(json, 'peerDependencies'));\n}\nfunction hasInvalidBrowserField(json) {\n    let error = '';\n    const browser = json.browser;\n    if (browser) {\n        if (typeof browser === 'object') {\n            for (const key in browser) {\n                if (typeof key !== 'string') {\n                    error = `The key ${key} of .browser must be a string`;\n                    break;\n                }\n                if (typeof browser[key] !== 'string' && browser[key] !== false) {\n                    error = `The value ${key} of .browser must be a string or false`;\n                    break;\n                }\n            }\n        }\n    }\n    return error;\n}\nfunction hasInvalidRequiredStringField(json, field) {\n    return typeof json[field] !== 'string';\n}\nfunction hasInvalidOptionalStringField(json, field) {\n    return json[field] !== undefined && typeof json[field] !== 'string';\n}\nfunction hasInvalidDependenciesField(json, field) {\n    return (json[field] !== undefined &&\n        typeof json[field] === 'object' &&\n        json[field] !== null &&\n        !Object.keys(json[field]).every((key) => typeof key === 'string' && typeof json[field][key] === 'string'));\n}\nfunction parseBufferAsPartialPackageJson(decoder, content, spec) {\n    try {\n        const text = decoder.decode(content);\n        return parseTextAsPartialPackageJson(text, spec);\n    }\n    catch (err) {\n        throw new Error(`Error decoding manifest buffer for package ${spec}: ${err.message}`);\n    }\n}\nfunction parseBufferAsPackageJson(decoder, content, spec) {\n    try {\n        const text = decoder.decode(content);\n        return parseTextAsPackageJson(text, spec);\n    }\n    catch (err) {\n        throw new Error(`Error decoding manifest buffer for package ${spec}: ${err.message}`);\n    }\n}\nfunction parseTextAsPartialPackageJson(text, spec) {\n    let json;\n    try {\n        json = JSON.parse(text);\n    }\n    catch (err) {\n        throw new Error(`Error parsing manifest as json for package ${spec}: ${err.message}`);\n    }\n    if (!isValidPartialPackageJson(json)) {\n        throw new Error(`Invalid manifest for the package ${spec}`);\n    }\n    return json;\n}\nfunction parseTextAsPackageJson(text, spec) {\n    const json = parseTextAsPartialPackageJson(text, spec);\n    if (!isValidPackageJson(json)) {\n        throw new Error(`Invalid manifest for the package ${spec}`);\n    }\n    return json;\n}\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n// NOTE: VSCode's copy of nodejs path library to be usable in common (non-node) namespace\n// Copied from: https://github.com/nodejs/node/blob/v12.8.1/lib/path.js\n/**\n * Copyright Joyent, Inc. and other Node contributors.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to permit\n * persons to whom the Software is furnished to do so, subject to the\n * following conditions:\n *\n * The above copyright notice and this permission notice shall be included\n * in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n * NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n * USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\nconst CHAR_DOT = 46; /* . */\nconst CHAR_FORWARD_SLASH = 47; /* / */\nclass ErrorInvalidArgType extends Error {\n    constructor(name, expected, actual) {\n        // determiner: 'must be' or 'must not be'\n        let determiner;\n        if (typeof expected === 'string' && expected.indexOf('not ') === 0) {\n            determiner = 'must not be';\n            expected = expected.replace(/^not /, '');\n        }\n        else {\n            determiner = 'must be';\n        }\n        const type = name.indexOf('.') !== -1 ? 'property' : 'argument';\n        let msg = `The \"${name}\" ${type} ${determiner} of type ${expected}`;\n        msg += `. Received type ${typeof actual}`;\n        super(msg);\n        this.code = 'ERR_INVALID_ARG_TYPE';\n    }\n}\nfunction validateString(value, name) {\n    if (typeof value !== 'string') {\n        throw new ErrorInvalidArgType(name, 'string', value);\n    }\n}\nfunction isPosixPathSeparator(code) {\n    return code === CHAR_FORWARD_SLASH;\n}\n// Resolves . and .. elements in a path with directory names\nfunction normalizeString(path, allowAboveRoot, separator, isPathSeparator) {\n    let res = '';\n    let lastSegmentLength = 0;\n    let lastSlash = -1;\n    let dots = 0;\n    let code = 0;\n    for (let i = 0; i <= path.length; ++i) {\n        if (i < path.length) {\n            code = path.charCodeAt(i);\n        }\n        else if (isPathSeparator(code)) {\n            break;\n        }\n        else {\n            code = CHAR_FORWARD_SLASH;\n        }\n        if (isPathSeparator(code)) {\n            if (lastSlash === i - 1 || dots === 1) ;\n            else if (dots === 2) {\n                if (res.length < 2 ||\n                    lastSegmentLength !== 2 ||\n                    res.charCodeAt(res.length - 1) !== CHAR_DOT ||\n                    res.charCodeAt(res.length - 2) !== CHAR_DOT) {\n                    if (res.length > 2) {\n                        const lastSlashIndex = res.lastIndexOf(separator);\n                        if (lastSlashIndex === -1) {\n                            res = '';\n                            lastSegmentLength = 0;\n                        }\n                        else {\n                            res = res.slice(0, lastSlashIndex);\n                            lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);\n                        }\n                        lastSlash = i;\n                        dots = 0;\n                        continue;\n                    }\n                    else if (res.length !== 0) {\n                        res = '';\n                        lastSegmentLength = 0;\n                        lastSlash = i;\n                        dots = 0;\n                        continue;\n                    }\n                }\n                if (allowAboveRoot) {\n                    res += res.length > 0 ? `${separator}..` : '..';\n                    lastSegmentLength = 2;\n                }\n            }\n            else {\n                if (res.length > 0) {\n                    res += `${separator}${path.slice(lastSlash + 1, i)}`;\n                }\n                else {\n                    res = path.slice(lastSlash + 1, i);\n                }\n                lastSegmentLength = i - lastSlash - 1;\n            }\n            lastSlash = i;\n            dots = 0;\n        }\n        else if (code === CHAR_DOT && dots !== -1) {\n            ++dots;\n        }\n        else {\n            dots = -1;\n        }\n    }\n    return res;\n}\nfunction _format(sep, pathObject) {\n    if (pathObject === null || typeof pathObject !== 'object') {\n        throw new ErrorInvalidArgType('pathObject', 'Object', pathObject);\n    }\n    const dir = pathObject.dir || pathObject.root;\n    const base = pathObject.base || `${pathObject.name || ''}${pathObject.ext || ''}`;\n    if (!dir) {\n        return base;\n    }\n    return dir === pathObject.root ? `${dir}${base}` : `${dir}${sep}${base}`;\n}\n// export const win32: IPath = {\n// \t// path.resolve([from ...], to)\n// \tresolve(...pathSegments: string[]): string {\n// \t\tlet resolvedDevice = '';\n// \t\tlet resolvedTail = '';\n// \t\tlet resolvedAbsolute = false;\n// \t\tfor (let i = pathSegments.length - 1; i >= -1; i--) {\n// \t\t\tlet path;\n// \t\t\tif (i >= 0) {\n// \t\t\t\tpath = pathSegments[i];\n// \t\t\t\tvalidateString(path, 'path');\n// \t\t\t\t// Skip empty entries\n// \t\t\t\tif (path.length === 0) {\n// \t\t\t\t\tcontinue;\n// \t\t\t\t}\n// \t\t\t} else if (resolvedDevice.length === 0) {\n// \t\t\t\tpath = process.cwd();\n// \t\t\t} else {\n// \t\t\t\t// Windows has the concept of drive-specific current working\n// \t\t\t\t// directories. If we've resolved a drive letter but not yet an\n// \t\t\t\t// absolute path, get cwd for that drive, or the process cwd if\n// \t\t\t\t// the drive cwd is not available. We're sure the device is not\n// \t\t\t\t// a UNC path at this points, because UNC paths are always absolute.\n// \t\t\t\tpath = (process.env as any)[`=${resolvedDevice}`] || process.cwd();\n// \t\t\t\t// Verify that a cwd was found and that it actually points\n// \t\t\t\t// to our drive. If not, default to the drive's root.\n// \t\t\t\tif (path === undefined ||\n// \t\t\t\t\tpath.slice(0, 2).toLowerCase() !== resolvedDevice.toLowerCase() &&\n// \t\t\t\t\tpath.charCodeAt(2) === CHAR_BACKWARD_SLASH) {\n// \t\t\t\t\tpath = `${resolvedDevice}\\\\`;\n// \t\t\t\t}\n// \t\t\t}\n// \t\t\tconst len = path.length;\n// \t\t\tlet rootEnd = 0;\n// \t\t\tlet device = '';\n// \t\t\tlet isAbsolute = false;\n// \t\t\tconst code = path.charCodeAt(0);\n// \t\t\t// Try to match a root\n// \t\t\tif (len === 1) {\n// \t\t\t\tif (isPathSeparator(code)) {\n// \t\t\t\t\t// `path` contains just a path separator\n// \t\t\t\t\trootEnd = 1;\n// \t\t\t\t\tisAbsolute = true;\n// \t\t\t\t}\n// \t\t\t} else if (isPathSeparator(code)) {\n// \t\t\t\t// Possible UNC root\n// \t\t\t\t// If we started with a separator, we know we at least have an\n// \t\t\t\t// absolute path of some kind (UNC or otherwise)\n// \t\t\t\tisAbsolute = true;\n// \t\t\t\tif (isPathSeparator(path.charCodeAt(1))) {\n// \t\t\t\t\t// Matched double path separator at beginning\n// \t\t\t\t\tlet j = 2;\n// \t\t\t\t\tlet last = j;\n// \t\t\t\t\t// Match 1 or more non-path separators\n// \t\t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n// \t\t\t\t\t\tj++;\n// \t\t\t\t\t}\n// \t\t\t\t\tif (j < len && j !== last) {\n// \t\t\t\t\t\tconst firstPart = path.slice(last, j);\n// \t\t\t\t\t\t// Matched!\n// \t\t\t\t\t\tlast = j;\n// \t\t\t\t\t\t// Match 1 or more path separators\n// \t\t\t\t\t\twhile (j < len && isPathSeparator(path.charCodeAt(j))) {\n// \t\t\t\t\t\t\tj++;\n// \t\t\t\t\t\t}\n// \t\t\t\t\t\tif (j < len && j !== last) {\n// \t\t\t\t\t\t\t// Matched!\n// \t\t\t\t\t\t\tlast = j;\n// \t\t\t\t\t\t\t// Match 1 or more non-path separators\n// \t\t\t\t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n// \t\t\t\t\t\t\t\tj++;\n// \t\t\t\t\t\t\t}\n// \t\t\t\t\t\t\tif (j === len || j !== last) {\n// \t\t\t\t\t\t\t\t// We matched a UNC root\n// \t\t\t\t\t\t\t\tdevice = `\\\\\\\\${firstPart}\\\\${path.slice(last, j)}`;\n// \t\t\t\t\t\t\t\trootEnd = j;\n// \t\t\t\t\t\t\t}\n// \t\t\t\t\t\t}\n// \t\t\t\t\t}\n// \t\t\t\t} else {\n// \t\t\t\t\trootEnd = 1;\n// \t\t\t\t}\n// \t\t\t} else if (isWindowsDeviceRoot(code) &&\n// \t\t\t\tpath.charCodeAt(1) === CHAR_COLON) {\n// \t\t\t\t// Possible device root\n// \t\t\t\tdevice = path.slice(0, 2);\n// \t\t\t\trootEnd = 2;\n// \t\t\t\tif (len > 2 && isPathSeparator(path.charCodeAt(2))) {\n// \t\t\t\t\t// Treat separator following drive name as an absolute path\n// \t\t\t\t\t// indicator\n// \t\t\t\t\tisAbsolute = true;\n// \t\t\t\t\trootEnd = 3;\n// \t\t\t\t}\n// \t\t\t}\n// \t\t\tif (device.length > 0) {\n// \t\t\t\tif (resolvedDevice.length > 0) {\n// \t\t\t\t\tif (device.toLowerCase() !== resolvedDevice.toLowerCase()) {\n// \t\t\t\t\t\t// This path points to another device so it is not applicable\n// \t\t\t\t\t\tcontinue;\n// \t\t\t\t\t}\n// \t\t\t\t} else {\n// \t\t\t\t\tresolvedDevice = device;\n// \t\t\t\t}\n// \t\t\t}\n// \t\t\tif (resolvedAbsolute) {\n// \t\t\t\tif (resolvedDevice.length > 0) {\n// \t\t\t\t\tbreak;\n// \t\t\t\t}\n// \t\t\t} else {\n// \t\t\t\tresolvedTail = `${path.slice(rootEnd)}\\\\${resolvedTail}`;\n// \t\t\t\tresolvedAbsolute = isAbsolute;\n// \t\t\t\tif (isAbsolute && resolvedDevice.length > 0) {\n// \t\t\t\t\tbreak;\n// \t\t\t\t}\n// \t\t\t}\n// \t\t}\n// \t\t// At this point the path should be resolved to a full absolute path,\n// \t\t// but handle relative paths to be safe (might happen when process.cwd()\n// \t\t// fails)\n// \t\t// Normalize the tail path\n// \t\tresolvedTail = normalizeString(resolvedTail, !resolvedAbsolute, '\\\\',\n// \t\t\tisPathSeparator);\n// \t\treturn resolvedAbsolute ?\n// \t\t\t`${resolvedDevice}\\\\${resolvedTail}` :\n// \t\t\t`${resolvedDevice}${resolvedTail}` || '.';\n// \t},\n// \tnormalize(path: string): string {\n// \t\tvalidateString(path, 'path');\n// \t\tconst len = path.length;\n// \t\tif (len === 0) {\n// \t\t\treturn '.';\n// \t\t}\n// \t\tlet rootEnd = 0;\n// \t\tlet device;\n// \t\tlet isAbsolute = false;\n// \t\tconst code = path.charCodeAt(0);\n// \t\t// Try to match a root\n// \t\tif (len === 1) {\n// \t\t\t// `path` contains just a single char, exit early to avoid\n// \t\t\t// unnecessary work\n// \t\t\treturn isPosixPathSeparator(code) ? '\\\\' : path;\n// \t\t}\n// \t\tif (isPathSeparator(code)) {\n// \t\t\t// Possible UNC root\n// \t\t\t// If we started with a separator, we know we at least have an absolute\n// \t\t\t// path of some kind (UNC or otherwise)\n// \t\t\tisAbsolute = true;\n// \t\t\tif (isPathSeparator(path.charCodeAt(1))) {\n// \t\t\t\t// Matched double path separator at beginning\n// \t\t\t\tlet j = 2;\n// \t\t\t\tlet last = j;\n// \t\t\t\t// Match 1 or more non-path separators\n// \t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n// \t\t\t\t\tj++;\n// \t\t\t\t}\n// \t\t\t\tif (j < len && j !== last) {\n// \t\t\t\t\tconst firstPart = path.slice(last, j);\n// \t\t\t\t\t// Matched!\n// \t\t\t\t\tlast = j;\n// \t\t\t\t\t// Match 1 or more path separators\n// \t\t\t\t\twhile (j < len && isPathSeparator(path.charCodeAt(j))) {\n// \t\t\t\t\t\tj++;\n// \t\t\t\t\t}\n// \t\t\t\t\tif (j < len && j !== last) {\n// \t\t\t\t\t\t// Matched!\n// \t\t\t\t\t\tlast = j;\n// \t\t\t\t\t\t// Match 1 or more non-path separators\n// \t\t\t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n// \t\t\t\t\t\t\tj++;\n// \t\t\t\t\t\t}\n// \t\t\t\t\t\tif (j === len) {\n// \t\t\t\t\t\t\t// We matched a UNC root only\n// \t\t\t\t\t\t\t// Return the normalized version of the UNC root since there\n// \t\t\t\t\t\t\t// is nothing left to process\n// \t\t\t\t\t\t\treturn `\\\\\\\\${firstPart}\\\\${path.slice(last)}\\\\`;\n// \t\t\t\t\t\t}\n// \t\t\t\t\t\tif (j !== last) {\n// \t\t\t\t\t\t\t// We matched a UNC root with leftovers\n// \t\t\t\t\t\t\tdevice = `\\\\\\\\${firstPart}\\\\${path.slice(last, j)}`;\n// \t\t\t\t\t\t\trootEnd = j;\n// \t\t\t\t\t\t}\n// \t\t\t\t\t}\n// \t\t\t\t}\n// \t\t\t} else {\n// \t\t\t\trootEnd = 1;\n// \t\t\t}\n// \t\t} else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {\n// \t\t\t// Possible device root\n// \t\t\tdevice = path.slice(0, 2);\n// \t\t\trootEnd = 2;\n// \t\t\tif (len > 2 && isPathSeparator(path.charCodeAt(2))) {\n// \t\t\t\t// Treat separator following drive name as an absolute path\n// \t\t\t\t// indicator\n// \t\t\t\tisAbsolute = true;\n// \t\t\t\trootEnd = 3;\n// \t\t\t}\n// \t\t}\n// \t\tlet tail = rootEnd < len ?\n// \t\t\tnormalizeString(path.slice(rootEnd), !isAbsolute, '\\\\', isPathSeparator) :\n// \t\t\t'';\n// \t\tif (tail.length === 0 && !isAbsolute) {\n// \t\t\ttail = '.';\n// \t\t}\n// \t\tif (tail.length > 0 && isPathSeparator(path.charCodeAt(len - 1))) {\n// \t\t\ttail += '\\\\';\n// \t\t}\n// \t\tif (device === undefined) {\n// \t\t\treturn isAbsolute ? `\\\\${tail}` : tail;\n// \t\t}\n// \t\treturn isAbsolute ? `${device}\\\\${tail}` : `${device}${tail}`;\n// \t},\n// \tisAbsolute(path: string): boolean {\n// \t\tvalidateString(path, 'path');\n// \t\tconst len = path.length;\n// \t\tif (len === 0) {\n// \t\t\treturn false;\n// \t\t}\n// \t\tconst code = path.charCodeAt(0);\n// \t\treturn isPathSeparator(code) ||\n// \t\t\t// Possible device root\n// \t\t\tlen > 2 &&\n// \t\t\tisWindowsDeviceRoot(code) &&\n// \t\t\tpath.charCodeAt(1) === CHAR_COLON &&\n// \t\t\tisPathSeparator(path.charCodeAt(2));\n// \t},\n// \tjoin(...paths: string[]): string {\n// \t\tif (paths.length === 0) {\n// \t\t\treturn '.';\n// \t\t}\n// \t\tlet joined;\n// \t\tlet firstPart: string | undefined;\n// \t\tfor (let i = 0; i < paths.length; ++i) {\n// \t\t\tconst arg = paths[i];\n// \t\t\tvalidateString(arg, 'path');\n// \t\t\tif (arg.length > 0) {\n// \t\t\t\tif (joined === undefined) {\n// \t\t\t\t\tjoined = firstPart = arg;\n// \t\t\t\t}\n// \t\t\t\telse {\n// \t\t\t\t\tjoined += `\\\\${arg}`;\n// \t\t\t\t}\n// \t\t\t}\n// \t\t}\n// \t\tif (joined === undefined) {\n// \t\t\treturn '.';\n// \t\t}\n// \t\t// Make sure that the joined path doesn't start with two slashes, because\n// \t\t// normalize() will mistake it for an UNC path then.\n// \t\t//\n// \t\t// This step is skipped when it is very clear that the user actually\n// \t\t// intended to point at an UNC path. This is assumed when the first\n// \t\t// non-empty string arguments starts with exactly two slashes followed by\n// \t\t// at least one more non-slash character.\n// \t\t//\n// \t\t// Note that for normalize() to treat a path as an UNC path it needs to\n// \t\t// have at least 2 components, so we don't filter for that here.\n// \t\t// This means that the user can use join to construct UNC paths from\n// \t\t// a server name and a share name; for example:\n// \t\t//   path.join('//server', 'share') -> '\\\\\\\\server\\\\share\\\\')\n// \t\tlet needsReplace = true;\n// \t\tlet slashCount = 0;\n// \t\tif (typeof firstPart === 'string' && isPathSeparator(firstPart.charCodeAt(0))) {\n// \t\t\t++slashCount;\n// \t\t\tconst firstLen = firstPart.length;\n// \t\t\tif (firstLen > 1 && isPathSeparator(firstPart.charCodeAt(1))) {\n// \t\t\t\t++slashCount;\n// \t\t\t\tif (firstLen > 2) {\n// \t\t\t\t\tif (isPathSeparator(firstPart.charCodeAt(2))) {\n// \t\t\t\t\t\t++slashCount;\n// \t\t\t\t\t} else {\n// \t\t\t\t\t\t// We matched a UNC path in the first part\n// \t\t\t\t\t\tneedsReplace = false;\n// \t\t\t\t\t}\n// \t\t\t\t}\n// \t\t\t}\n// \t\t}\n// \t\tif (needsReplace) {\n// \t\t\t// Find any more consecutive slashes we need to replace\n// \t\t\twhile (slashCount < joined.length &&\n// \t\t\t\tisPathSeparator(joined.charCodeAt(slashCount))) {\n// \t\t\t\tslashCount++;\n// \t\t\t}\n// \t\t\t// Replace the slashes if needed\n// \t\t\tif (slashCount >= 2) {\n// \t\t\t\tjoined = `\\\\${joined.slice(slashCount)}`;\n// \t\t\t}\n// \t\t}\n// \t\treturn win32.normalize(joined);\n// \t},\n// \t// It will solve the relative path from `from` to `to`, for instance:\n// \t//  from = 'C:\\\\orandea\\\\test\\\\aaa'\n// \t//  to = 'C:\\\\orandea\\\\impl\\\\bbb'\n// \t// The output of the function should be: '..\\\\..\\\\impl\\\\bbb'\n// \trelative(from: string, to: string): string {\n// \t\tvalidateString(from, 'from');\n// \t\tvalidateString(to, 'to');\n// \t\tif (from === to) {\n// \t\t\treturn '';\n// \t\t}\n// \t\tconst fromOrig = win32.resolve(from);\n// \t\tconst toOrig = win32.resolve(to);\n// \t\tif (fromOrig === toOrig) {\n// \t\t\treturn '';\n// \t\t}\n// \t\tfrom = fromOrig.toLowerCase();\n// \t\tto = toOrig.toLowerCase();\n// \t\tif (from === to) {\n// \t\t\treturn '';\n// \t\t}\n// \t\t// Trim any leading backslashes\n// \t\tlet fromStart = 0;\n// \t\twhile (fromStart < from.length &&\n// \t\t\tfrom.charCodeAt(fromStart) === CHAR_BACKWARD_SLASH) {\n// \t\t\tfromStart++;\n// \t\t}\n// \t\t// Trim trailing backslashes (applicable to UNC paths only)\n// \t\tlet fromEnd = from.length;\n// \t\twhile (fromEnd - 1 > fromStart &&\n// \t\t\tfrom.charCodeAt(fromEnd - 1) === CHAR_BACKWARD_SLASH) {\n// \t\t\tfromEnd--;\n// \t\t}\n// \t\tconst fromLen = fromEnd - fromStart;\n// \t\t// Trim any leading backslashes\n// \t\tlet toStart = 0;\n// \t\twhile (toStart < to.length &&\n// \t\t\tto.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {\n// \t\t\ttoStart++;\n// \t\t}\n// \t\t// Trim trailing backslashes (applicable to UNC paths only)\n// \t\tlet toEnd = to.length;\n// \t\twhile (toEnd - 1 > toStart &&\n// \t\t\tto.charCodeAt(toEnd - 1) === CHAR_BACKWARD_SLASH) {\n// \t\t\ttoEnd--;\n// \t\t}\n// \t\tconst toLen = toEnd - toStart;\n// \t\t// Compare paths to find the longest common path from root\n// \t\tconst length = fromLen < toLen ? fromLen : toLen;\n// \t\tlet lastCommonSep = -1;\n// \t\tlet i = 0;\n// \t\tfor (; i < length; i++) {\n// \t\t\tconst fromCode = from.charCodeAt(fromStart + i);\n// \t\t\tif (fromCode !== to.charCodeAt(toStart + i)) {\n// \t\t\t\tbreak;\n// \t\t\t} else if (fromCode === CHAR_BACKWARD_SLASH) {\n// \t\t\t\tlastCommonSep = i;\n// \t\t\t}\n// \t\t}\n// \t\t// We found a mismatch before the first common path separator was seen, so\n// \t\t// return the original `to`.\n// \t\tif (i !== length) {\n// \t\t\tif (lastCommonSep === -1) {\n// \t\t\t\treturn toOrig;\n// \t\t\t}\n// \t\t} else {\n// \t\t\tif (toLen > length) {\n// \t\t\t\tif (to.charCodeAt(toStart + i) === CHAR_BACKWARD_SLASH) {\n// \t\t\t\t\t// We get here if `from` is the exact base path for `to`.\n// \t\t\t\t\t// For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo\\\\bar\\\\baz'\n// \t\t\t\t\treturn toOrig.slice(toStart + i + 1);\n// \t\t\t\t}\n// \t\t\t\tif (i === 2) {\n// \t\t\t\t\t// We get here if `from` is the device root.\n// \t\t\t\t\t// For example: from='C:\\\\'; to='C:\\\\foo'\n// \t\t\t\t\treturn toOrig.slice(toStart + i);\n// \t\t\t\t}\n// \t\t\t}\n// \t\t\tif (fromLen > length) {\n// \t\t\t\tif (from.charCodeAt(fromStart + i) === CHAR_BACKWARD_SLASH) {\n// \t\t\t\t\t// We get here if `to` is the exact base path for `from`.\n// \t\t\t\t\t// For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo'\n// \t\t\t\t\tlastCommonSep = i;\n// \t\t\t\t} else if (i === 2) {\n// \t\t\t\t\t// We get here if `to` is the device root.\n// \t\t\t\t\t// For example: from='C:\\\\foo\\\\bar'; to='C:\\\\'\n// \t\t\t\t\tlastCommonSep = 3;\n// \t\t\t\t}\n// \t\t\t}\n// \t\t\tif (lastCommonSep === -1) {\n// \t\t\t\tlastCommonSep = 0;\n// \t\t\t}\n// \t\t}\n// \t\tlet out = '';\n// \t\t// Generate the relative path based on the path difference between `to` and\n// \t\t// `from`\n// \t\tfor (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n// \t\t\tif (i === fromEnd || from.charCodeAt(i) === CHAR_BACKWARD_SLASH) {\n// \t\t\t\tout += out.length === 0 ? '..' : '\\\\..';\n// \t\t\t}\n// \t\t}\n// \t\ttoStart += lastCommonSep;\n// \t\t// Lastly, append the rest of the destination (`to`) path that comes after\n// \t\t// the common path parts\n// \t\tif (out.length > 0) {\n// \t\t\treturn `${out}${toOrig.slice(toStart, toEnd)}`;\n// \t\t}\n// \t\tif (toOrig.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {\n// \t\t\t++toStart;\n// \t\t}\n// \t\treturn toOrig.slice(toStart, toEnd);\n// \t},\n// \ttoNamespacedPath(path: string): string {\n// \t\t// Note: this will *probably* throw somewhere.\n// \t\tif (typeof path !== 'string') {\n// \t\t\treturn path;\n// \t\t}\n// \t\tif (path.length === 0) {\n// \t\t\treturn '';\n// \t\t}\n// \t\tconst resolvedPath = win32.resolve(path);\n// \t\tif (resolvedPath.length <= 2) {\n// \t\t\treturn path;\n// \t\t}\n// \t\tif (resolvedPath.charCodeAt(0) === CHAR_BACKWARD_SLASH) {\n// \t\t\t// Possible UNC root\n// \t\t\tif (resolvedPath.charCodeAt(1) === CHAR_BACKWARD_SLASH) {\n// \t\t\t\tconst code = resolvedPath.charCodeAt(2);\n// \t\t\t\tif (code !== CHAR_QUESTION_MARK && code !== CHAR_DOT) {\n// \t\t\t\t\t// Matched non-long UNC root, convert the path to a long UNC path\n// \t\t\t\t\treturn `\\\\\\\\?\\\\UNC\\\\${resolvedPath.slice(2)}`;\n// \t\t\t\t}\n// \t\t\t}\n// \t\t} else if (isWindowsDeviceRoot(resolvedPath.charCodeAt(0)) &&\n// \t\t\tresolvedPath.charCodeAt(1) === CHAR_COLON &&\n// \t\t\tresolvedPath.charCodeAt(2) === CHAR_BACKWARD_SLASH) {\n// \t\t\t// Matched device root, convert the path to a long UNC path\n// \t\t\treturn `\\\\\\\\?\\\\${resolvedPath}`;\n// \t\t}\n// \t\treturn path;\n// \t},\n// \tdirname(path: string): string {\n// \t\tvalidateString(path, 'path');\n// \t\tconst len = path.length;\n// \t\tif (len === 0) {\n// \t\t\treturn '.';\n// \t\t}\n// \t\tlet rootEnd = -1;\n// \t\tlet offset = 0;\n// \t\tconst code = path.charCodeAt(0);\n// \t\tif (len === 1) {\n// \t\t\t// `path` contains just a path separator, exit early to avoid\n// \t\t\t// unnecessary work or a dot.\n// \t\t\treturn isPathSeparator(code) ? path : '.';\n// \t\t}\n// \t\t// Try to match a root\n// \t\tif (isPathSeparator(code)) {\n// \t\t\t// Possible UNC root\n// \t\t\trootEnd = offset = 1;\n// \t\t\tif (isPathSeparator(path.charCodeAt(1))) {\n// \t\t\t\t// Matched double path separator at beginning\n// \t\t\t\tlet j = 2;\n// \t\t\t\tlet last = j;\n// \t\t\t\t// Match 1 or more non-path separators\n// \t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n// \t\t\t\t\tj++;\n// \t\t\t\t}\n// \t\t\t\tif (j < len && j !== last) {\n// \t\t\t\t\t// Matched!\n// \t\t\t\t\tlast = j;\n// \t\t\t\t\t// Match 1 or more path separators\n// \t\t\t\t\twhile (j < len && isPathSeparator(path.charCodeAt(j))) {\n// \t\t\t\t\t\tj++;\n// \t\t\t\t\t}\n// \t\t\t\t\tif (j < len && j !== last) {\n// \t\t\t\t\t\t// Matched!\n// \t\t\t\t\t\tlast = j;\n// \t\t\t\t\t\t// Match 1 or more non-path separators\n// \t\t\t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n// \t\t\t\t\t\t\tj++;\n// \t\t\t\t\t\t}\n// \t\t\t\t\t\tif (j === len) {\n// \t\t\t\t\t\t\t// We matched a UNC root only\n// \t\t\t\t\t\t\treturn path;\n// \t\t\t\t\t\t}\n// \t\t\t\t\t\tif (j !== last) {\n// \t\t\t\t\t\t\t// We matched a UNC root with leftovers\n// \t\t\t\t\t\t\t// Offset by 1 to include the separator after the UNC root to\n// \t\t\t\t\t\t\t// treat it as a \"normal root\" on top of a (UNC) root\n// \t\t\t\t\t\t\trootEnd = offset = j + 1;\n// \t\t\t\t\t\t}\n// \t\t\t\t\t}\n// \t\t\t\t}\n// \t\t\t}\n// \t\t\t// Possible device root\n// \t\t} else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {\n// \t\t\trootEnd = len > 2 && isPathSeparator(path.charCodeAt(2)) ? 3 : 2;\n// \t\t\toffset = rootEnd;\n// \t\t}\n// \t\tlet end = -1;\n// \t\tlet matchedSlash = true;\n// \t\tfor (let i = len - 1; i >= offset; --i) {\n// \t\t\tif (isPathSeparator(path.charCodeAt(i))) {\n// \t\t\t\tif (!matchedSlash) {\n// \t\t\t\t\tend = i;\n// \t\t\t\t\tbreak;\n// \t\t\t\t}\n// \t\t\t} else {\n// \t\t\t\t// We saw the first non-path separator\n// \t\t\t\tmatchedSlash = false;\n// \t\t\t}\n// \t\t}\n// \t\tif (end === -1) {\n// \t\t\tif (rootEnd === -1) {\n// \t\t\t\treturn '.';\n// \t\t\t}\n// \t\t\tend = rootEnd;\n// \t\t}\n// \t\treturn path.slice(0, end);\n// \t},\n// \tbasename(path: string, ext?: string): string {\n// \t\tif (ext !== undefined) {\n// \t\t\tvalidateString(ext, 'ext');\n// \t\t}\n// \t\tvalidateString(path, 'path');\n// \t\tlet start = 0;\n// \t\tlet end = -1;\n// \t\tlet matchedSlash = true;\n// \t\tlet i;\n// \t\t// Check for a drive letter prefix so as not to mistake the following\n// \t\t// path separator as an extra separator at the end of the path that can be\n// \t\t// disregarded\n// \t\tif (path.length >= 2 &&\n// \t\t\tisWindowsDeviceRoot(path.charCodeAt(0)) &&\n// \t\t\tpath.charCodeAt(1) === CHAR_COLON) {\n// \t\t\tstart = 2;\n// \t\t}\n// \t\tif (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n// \t\t\tif (ext === path) {\n// \t\t\t\treturn '';\n// \t\t\t}\n// \t\t\tlet extIdx = ext.length - 1;\n// \t\t\tlet firstNonSlashEnd = -1;\n// \t\t\tfor (i = path.length - 1; i >= start; --i) {\n// \t\t\t\tconst code = path.charCodeAt(i);\n// \t\t\t\tif (isPathSeparator(code)) {\n// \t\t\t\t\t// If we reached a path separator that was not part of a set of path\n// \t\t\t\t\t// separators at the end of the string, stop now\n// \t\t\t\t\tif (!matchedSlash) {\n// \t\t\t\t\t\tstart = i + 1;\n// \t\t\t\t\t\tbreak;\n// \t\t\t\t\t}\n// \t\t\t\t} else {\n// \t\t\t\t\tif (firstNonSlashEnd === -1) {\n// \t\t\t\t\t\t// We saw the first non-path separator, remember this index in case\n// \t\t\t\t\t\t// we need it if the extension ends up not matching\n// \t\t\t\t\t\tmatchedSlash = false;\n// \t\t\t\t\t\tfirstNonSlashEnd = i + 1;\n// \t\t\t\t\t}\n// \t\t\t\t\tif (extIdx >= 0) {\n// \t\t\t\t\t\t// Try to match the explicit extension\n// \t\t\t\t\t\tif (code === ext.charCodeAt(extIdx)) {\n// \t\t\t\t\t\t\tif (--extIdx === -1) {\n// \t\t\t\t\t\t\t\t// We matched the extension, so mark this as the end of our path\n// \t\t\t\t\t\t\t\t// component\n// \t\t\t\t\t\t\t\tend = i;\n// \t\t\t\t\t\t\t}\n// \t\t\t\t\t\t} else {\n// \t\t\t\t\t\t\t// Extension does not match, so our result is the entire path\n// \t\t\t\t\t\t\t// component\n// \t\t\t\t\t\t\textIdx = -1;\n// \t\t\t\t\t\t\tend = firstNonSlashEnd;\n// \t\t\t\t\t\t}\n// \t\t\t\t\t}\n// \t\t\t\t}\n// \t\t\t}\n// \t\t\tif (start === end) {\n// \t\t\t\tend = firstNonSlashEnd;\n// \t\t\t} else if (end === -1) {\n// \t\t\t\tend = path.length;\n// \t\t\t}\n// \t\t\treturn path.slice(start, end);\n// \t\t}\n// \t\tfor (i = path.length - 1; i >= start; --i) {\n// \t\t\tif (isPathSeparator(path.charCodeAt(i))) {\n// \t\t\t\t// If we reached a path separator that was not part of a set of path\n// \t\t\t\t// separators at the end of the string, stop now\n// \t\t\t\tif (!matchedSlash) {\n// \t\t\t\t\tstart = i + 1;\n// \t\t\t\t\tbreak;\n// \t\t\t\t}\n// \t\t\t} else if (end === -1) {\n// \t\t\t\t// We saw the first non-path separator, mark this as the end of our\n// \t\t\t\t// path component\n// \t\t\t\tmatchedSlash = false;\n// \t\t\t\tend = i + 1;\n// \t\t\t}\n// \t\t}\n// \t\tif (end === -1) {\n// \t\t\treturn '';\n// \t\t}\n// \t\treturn path.slice(start, end);\n// \t},\n// \textname(path: string): string {\n// \t\tvalidateString(path, 'path');\n// \t\tlet start = 0;\n// \t\tlet startDot = -1;\n// \t\tlet startPart = 0;\n// \t\tlet end = -1;\n// \t\tlet matchedSlash = true;\n// \t\t// Track the state of characters (if any) we see before our first dot and\n// \t\t// after any path separator we find\n// \t\tlet preDotState = 0;\n// \t\t// Check for a drive letter prefix so as not to mistake the following\n// \t\t// path separator as an extra separator at the end of the path that can be\n// \t\t// disregarded\n// \t\tif (path.length >= 2 &&\n// \t\t\tpath.charCodeAt(1) === CHAR_COLON &&\n// \t\t\tisWindowsDeviceRoot(path.charCodeAt(0))) {\n// \t\t\tstart = startPart = 2;\n// \t\t}\n// \t\tfor (let i = path.length - 1; i >= start; --i) {\n// \t\t\tconst code = path.charCodeAt(i);\n// \t\t\tif (isPathSeparator(code)) {\n// \t\t\t\t// If we reached a path separator that was not part of a set of path\n// \t\t\t\t// separators at the end of the string, stop now\n// \t\t\t\tif (!matchedSlash) {\n// \t\t\t\t\tstartPart = i + 1;\n// \t\t\t\t\tbreak;\n// \t\t\t\t}\n// \t\t\t\tcontinue;\n// \t\t\t}\n// \t\t\tif (end === -1) {\n// \t\t\t\t// We saw the first non-path separator, mark this as the end of our\n// \t\t\t\t// extension\n// \t\t\t\tmatchedSlash = false;\n// \t\t\t\tend = i + 1;\n// \t\t\t}\n// \t\t\tif (code === CHAR_DOT) {\n// \t\t\t\t// If this is our first dot, mark it as the start of our extension\n// \t\t\t\tif (startDot === -1) {\n// \t\t\t\t\tstartDot = i;\n// \t\t\t\t}\n// \t\t\t\telse if (preDotState !== 1) {\n// \t\t\t\t\tpreDotState = 1;\n// \t\t\t\t}\n// \t\t\t} else if (startDot !== -1) {\n// \t\t\t\t// We saw a non-dot and non-path separator before our dot, so we should\n// \t\t\t\t// have a good chance at having a non-empty extension\n// \t\t\t\tpreDotState = -1;\n// \t\t\t}\n// \t\t}\n// \t\tif (startDot === -1 ||\n// \t\t\tend === -1 ||\n// \t\t\t// We saw a non-dot character immediately before the dot\n// \t\t\tpreDotState === 0 ||\n// \t\t\t// The (right-most) trimmed path component is exactly '..'\n// \t\t\t(preDotState === 1 &&\n// \t\t\t\tstartDot === end - 1 &&\n// \t\t\t\tstartDot === startPart + 1)) {\n// \t\t\treturn '';\n// \t\t}\n// \t\treturn path.slice(startDot, end);\n// \t},\n// \tformat: _format.bind(null, '\\\\'),\n// \tparse(path) {\n// \t\tvalidateString(path, 'path');\n// \t\tconst ret = { root: '', dir: '', base: '', ext: '', name: '' };\n// \t\tif (path.length === 0) {\n// \t\t\treturn ret;\n// \t\t}\n// \t\tconst len = path.length;\n// \t\tlet rootEnd = 0;\n// \t\tlet code = path.charCodeAt(0);\n// \t\tif (len === 1) {\n// \t\t\tif (isPathSeparator(code)) {\n// \t\t\t\t// `path` contains just a path separator, exit early to avoid\n// \t\t\t\t// unnecessary work\n// \t\t\t\tret.root = ret.dir = path;\n// \t\t\t\treturn ret;\n// \t\t\t}\n// \t\t\tret.base = ret.name = path;\n// \t\t\treturn ret;\n// \t\t}\n// \t\t// Try to match a root\n// \t\tif (isPathSeparator(code)) {\n// \t\t\t// Possible UNC root\n// \t\t\trootEnd = 1;\n// \t\t\tif (isPathSeparator(path.charCodeAt(1))) {\n// \t\t\t\t// Matched double path separator at beginning\n// \t\t\t\tlet j = 2;\n// \t\t\t\tlet last = j;\n// \t\t\t\t// Match 1 or more non-path separators\n// \t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n// \t\t\t\t\tj++;\n// \t\t\t\t}\n// \t\t\t\tif (j < len && j !== last) {\n// \t\t\t\t\t// Matched!\n// \t\t\t\t\tlast = j;\n// \t\t\t\t\t// Match 1 or more path separators\n// \t\t\t\t\twhile (j < len && isPathSeparator(path.charCodeAt(j))) {\n// \t\t\t\t\t\tj++;\n// \t\t\t\t\t}\n// \t\t\t\t\tif (j < len && j !== last) {\n// \t\t\t\t\t\t// Matched!\n// \t\t\t\t\t\tlast = j;\n// \t\t\t\t\t\t// Match 1 or more non-path separators\n// \t\t\t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n// \t\t\t\t\t\t\tj++;\n// \t\t\t\t\t\t}\n// \t\t\t\t\t\tif (j === len) {\n// \t\t\t\t\t\t\t// We matched a UNC root only\n// \t\t\t\t\t\t\trootEnd = j;\n// \t\t\t\t\t\t} else if (j !== last) {\n// \t\t\t\t\t\t\t// We matched a UNC root with leftovers\n// \t\t\t\t\t\t\trootEnd = j + 1;\n// \t\t\t\t\t\t}\n// \t\t\t\t\t}\n// \t\t\t\t}\n// \t\t\t}\n// \t\t} else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {\n// \t\t\t// Possible device root\n// \t\t\tif (len <= 2) {\n// \t\t\t\t// `path` contains just a drive root, exit early to avoid\n// \t\t\t\t// unnecessary work\n// \t\t\t\tret.root = ret.dir = path;\n// \t\t\t\treturn ret;\n// \t\t\t}\n// \t\t\trootEnd = 2;\n// \t\t\tif (isPathSeparator(path.charCodeAt(2))) {\n// \t\t\t\tif (len === 3) {\n// \t\t\t\t\t// `path` contains just a drive root, exit early to avoid\n// \t\t\t\t\t// unnecessary work\n// \t\t\t\t\tret.root = ret.dir = path;\n// \t\t\t\t\treturn ret;\n// \t\t\t\t}\n// \t\t\t\trootEnd = 3;\n// \t\t\t}\n// \t\t}\n// \t\tif (rootEnd > 0) {\n// \t\t\tret.root = path.slice(0, rootEnd);\n// \t\t}\n// \t\tlet startDot = -1;\n// \t\tlet startPart = rootEnd;\n// \t\tlet end = -1;\n// \t\tlet matchedSlash = true;\n// \t\tlet i = path.length - 1;\n// \t\t// Track the state of characters (if any) we see before our first dot and\n// \t\t// after any path separator we find\n// \t\tlet preDotState = 0;\n// \t\t// Get non-dir info\n// \t\tfor (; i >= rootEnd; --i) {\n// \t\t\tcode = path.charCodeAt(i);\n// \t\t\tif (isPathSeparator(code)) {\n// \t\t\t\t// If we reached a path separator that was not part of a set of path\n// \t\t\t\t// separators at the end of the string, stop now\n// \t\t\t\tif (!matchedSlash) {\n// \t\t\t\t\tstartPart = i + 1;\n// \t\t\t\t\tbreak;\n// \t\t\t\t}\n// \t\t\t\tcontinue;\n// \t\t\t}\n// \t\t\tif (end === -1) {\n// \t\t\t\t// We saw the first non-path separator, mark this as the end of our\n// \t\t\t\t// extension\n// \t\t\t\tmatchedSlash = false;\n// \t\t\t\tend = i + 1;\n// \t\t\t}\n// \t\t\tif (code === CHAR_DOT) {\n// \t\t\t\t// If this is our first dot, mark it as the start of our extension\n// \t\t\t\tif (startDot === -1) {\n// \t\t\t\t\tstartDot = i;\n// \t\t\t\t} else if (preDotState !== 1) {\n// \t\t\t\t\tpreDotState = 1;\n// \t\t\t\t}\n// \t\t\t} else if (startDot !== -1) {\n// \t\t\t\t// We saw a non-dot and non-path separator before our dot, so we should\n// \t\t\t\t// have a good chance at having a non-empty extension\n// \t\t\t\tpreDotState = -1;\n// \t\t\t}\n// \t\t}\n// \t\tif (end !== -1) {\n// \t\t\tif (startDot === -1 ||\n// \t\t\t\t// We saw a non-dot character immediately before the dot\n// \t\t\t\tpreDotState === 0 ||\n// \t\t\t\t// The (right-most) trimmed path component is exactly '..'\n// \t\t\t\t(preDotState === 1 &&\n// \t\t\t\t\tstartDot === end - 1 &&\n// \t\t\t\t\tstartDot === startPart + 1)) {\n// \t\t\t\tret.base = ret.name = path.slice(startPart, end);\n// \t\t\t} else {\n// \t\t\t\tret.name = path.slice(startPart, startDot);\n// \t\t\t\tret.base = path.slice(startPart, end);\n// \t\t\t\tret.ext = path.slice(startDot, end);\n// \t\t\t}\n// \t\t}\n// \t\t// If the directory is the root, use the entire root as the `dir` including\n// \t\t// the trailing slash if any (`C:\\abc` -> `C:\\`). Otherwise, strip out the\n// \t\t// trailing slash (`C:\\abc\\def` -> `C:\\abc`).\n// \t\tif (startPart > 0 && startPart !== rootEnd) {\n// \t\t\tret.dir = path.slice(0, startPart - 1);\n// \t\t} else {\n// \t\t\tret.dir = ret.root;\n// \t\t}\n// \t\treturn ret;\n// \t},\n// \tsep: '\\\\',\n// \tdelimiter: ';',\n// \twin32: null,\n// \tposix: null\n// };\nconst posix = {\n    // path.resolve([from ...], to)\n    resolve(...pathSegments) {\n        let resolvedPath = '';\n        let resolvedAbsolute = false;\n        for (let i = pathSegments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n            const path = i >= 0 ? pathSegments[i] : process.cwd();\n            validateString(path, 'path');\n            // Skip empty entries\n            if (path.length === 0) {\n                continue;\n            }\n            resolvedPath = `${path}/${resolvedPath}`;\n            resolvedAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n        }\n        // At this point the path should be resolved to a full absolute path, but\n        // handle relative paths to be safe (might happen when process.cwd() fails)\n        // Normalize the path\n        resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute, '/', isPosixPathSeparator);\n        if (resolvedAbsolute) {\n            return `/${resolvedPath}`;\n        }\n        return resolvedPath.length > 0 ? resolvedPath : '.';\n    },\n    normalize(path) {\n        validateString(path, 'path');\n        if (path.length === 0) {\n            return '.';\n        }\n        const isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n        const trailingSeparator = path.charCodeAt(path.length - 1) === CHAR_FORWARD_SLASH;\n        // Normalize the path\n        path = normalizeString(path, !isAbsolute, '/', isPosixPathSeparator);\n        if (path.length === 0) {\n            if (isAbsolute) {\n                return '/';\n            }\n            return trailingSeparator ? './' : '.';\n        }\n        if (trailingSeparator) {\n            path += '/';\n        }\n        return isAbsolute ? `/${path}` : path;\n    },\n    isAbsolute(path) {\n        validateString(path, 'path');\n        return path.length > 0 && path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n    },\n    join(...paths) {\n        if (paths.length === 0) {\n            return '.';\n        }\n        let joined;\n        for (let i = 0; i < paths.length; ++i) {\n            const arg = paths[i];\n            validateString(arg, 'path');\n            if (arg.length > 0) {\n                if (joined === undefined) {\n                    joined = arg;\n                }\n                else {\n                    joined += `/${arg}`;\n                }\n            }\n        }\n        if (joined === undefined) {\n            return '.';\n        }\n        return posix.normalize(joined);\n    },\n    relative(from, to) {\n        validateString(from, 'from');\n        validateString(to, 'to');\n        if (from === to) {\n            return '';\n        }\n        // Trim leading forward slashes.\n        from = posix.resolve(from);\n        to = posix.resolve(to);\n        if (from === to) {\n            return '';\n        }\n        const fromStart = 1;\n        const fromEnd = from.length;\n        const fromLen = fromEnd - fromStart;\n        const toStart = 1;\n        const toLen = to.length - toStart;\n        // Compare paths to find the longest common path from root\n        const length = fromLen < toLen ? fromLen : toLen;\n        let lastCommonSep = -1;\n        let i = 0;\n        for (; i < length; i++) {\n            const fromCode = from.charCodeAt(fromStart + i);\n            if (fromCode !== to.charCodeAt(toStart + i)) {\n                break;\n            }\n            else if (fromCode === CHAR_FORWARD_SLASH) {\n                lastCommonSep = i;\n            }\n        }\n        if (i === length) {\n            if (toLen > length) {\n                if (to.charCodeAt(toStart + i) === CHAR_FORWARD_SLASH) {\n                    // We get here if `from` is the exact base path for `to`.\n                    // For example: from='/foo/bar'; to='/foo/bar/baz'\n                    return to.slice(toStart + i + 1);\n                }\n                if (i === 0) {\n                    // We get here if `from` is the root\n                    // For example: from='/'; to='/foo'\n                    return to.slice(toStart + i);\n                }\n            }\n            else if (fromLen > length) {\n                if (from.charCodeAt(fromStart + i) === CHAR_FORWARD_SLASH) {\n                    // We get here if `to` is the exact base path for `from`.\n                    // For example: from='/foo/bar/baz'; to='/foo/bar'\n                    lastCommonSep = i;\n                }\n                else if (i === 0) {\n                    // We get here if `to` is the root.\n                    // For example: from='/foo/bar'; to='/'\n                    lastCommonSep = 0;\n                }\n            }\n        }\n        let out = '';\n        // Generate the relative path based on the path difference between `to`\n        // and `from`.\n        for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n            if (i === fromEnd || from.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n                out += out.length === 0 ? '..' : '/..';\n            }\n        }\n        // Lastly, append the rest of the destination (`to`) path that comes after\n        // the common path parts.\n        return `${out}${to.slice(toStart + lastCommonSep)}`;\n    },\n    toNamespacedPath(path) {\n        // Non-op on posix systems\n        return path;\n    },\n    dirname(path) {\n        validateString(path, 'path');\n        if (path.length === 0) {\n            return '.';\n        }\n        const hasRoot = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n        let end = -1;\n        let matchedSlash = true;\n        for (let i = path.length - 1; i >= 1; --i) {\n            if (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n                if (!matchedSlash) {\n                    end = i;\n                    break;\n                }\n            }\n            else {\n                // We saw the first non-path separator\n                matchedSlash = false;\n            }\n        }\n        if (end === -1) {\n            return hasRoot ? '/' : '.';\n        }\n        if (hasRoot && end === 1) {\n            return '//';\n        }\n        return path.slice(0, end);\n    },\n    basename(path, ext) {\n        if (ext !== undefined) {\n            validateString(ext, 'ext');\n        }\n        validateString(path, 'path');\n        let start = 0;\n        let end = -1;\n        let matchedSlash = true;\n        let i;\n        if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n            if (ext === path) {\n                return '';\n            }\n            let extIdx = ext.length - 1;\n            let firstNonSlashEnd = -1;\n            for (i = path.length - 1; i >= 0; --i) {\n                const code = path.charCodeAt(i);\n                if (code === CHAR_FORWARD_SLASH) {\n                    // If we reached a path separator that was not part of a set of path\n                    // separators at the end of the string, stop now\n                    if (!matchedSlash) {\n                        start = i + 1;\n                        break;\n                    }\n                }\n                else {\n                    if (firstNonSlashEnd === -1) {\n                        // We saw the first non-path separator, remember this index in case\n                        // we need it if the extension ends up not matching\n                        matchedSlash = false;\n                        firstNonSlashEnd = i + 1;\n                    }\n                    if (extIdx >= 0) {\n                        // Try to match the explicit extension\n                        if (code === ext.charCodeAt(extIdx)) {\n                            if (--extIdx === -1) {\n                                // We matched the extension, so mark this as the end of our path\n                                // component\n                                end = i;\n                            }\n                        }\n                        else {\n                            // Extension does not match, so our result is the entire path\n                            // component\n                            extIdx = -1;\n                            end = firstNonSlashEnd;\n                        }\n                    }\n                }\n            }\n            if (start === end) {\n                end = firstNonSlashEnd;\n            }\n            else if (end === -1) {\n                end = path.length;\n            }\n            return path.slice(start, end);\n        }\n        for (i = path.length - 1; i >= 0; --i) {\n            if (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n                // If we reached a path separator that was not part of a set of path\n                // separators at the end of the string, stop now\n                if (!matchedSlash) {\n                    start = i + 1;\n                    break;\n                }\n            }\n            else if (end === -1) {\n                // We saw the first non-path separator, mark this as the end of our\n                // path component\n                matchedSlash = false;\n                end = i + 1;\n            }\n        }\n        if (end === -1) {\n            return '';\n        }\n        return path.slice(start, end);\n    },\n    extname(path) {\n        validateString(path, 'path');\n        let startDot = -1;\n        let startPart = 0;\n        let end = -1;\n        let matchedSlash = true;\n        // Track the state of characters (if any) we see before our first dot and\n        // after any path separator we find\n        let preDotState = 0;\n        for (let i = path.length - 1; i >= 0; --i) {\n            const code = path.charCodeAt(i);\n            if (code === CHAR_FORWARD_SLASH) {\n                // If we reached a path separator that was not part of a set of path\n                // separators at the end of the string, stop now\n                if (!matchedSlash) {\n                    startPart = i + 1;\n                    break;\n                }\n                continue;\n            }\n            if (end === -1) {\n                // We saw the first non-path separator, mark this as the end of our\n                // extension\n                matchedSlash = false;\n                end = i + 1;\n            }\n            if (code === CHAR_DOT) {\n                // If this is our first dot, mark it as the start of our extension\n                if (startDot === -1) {\n                    startDot = i;\n                }\n                else if (preDotState !== 1) {\n                    preDotState = 1;\n                }\n            }\n            else if (startDot !== -1) {\n                // We saw a non-dot and non-path separator before our dot, so we should\n                // have a good chance at having a non-empty extension\n                preDotState = -1;\n            }\n        }\n        if (startDot === -1 ||\n            end === -1 ||\n            // We saw a non-dot character immediately before the dot\n            preDotState === 0 ||\n            // The (right-most) trimmed path component is exactly '..'\n            (preDotState === 1 && startDot === end - 1 && startDot === startPart + 1)) {\n            return '';\n        }\n        return path.slice(startDot, end);\n    },\n    format: _format.bind(null, '/'),\n    parse(path) {\n        validateString(path, 'path');\n        const ret = { root: '', dir: '', base: '', ext: '', name: '' };\n        if (path.length === 0) {\n            return ret;\n        }\n        const isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n        let start;\n        if (isAbsolute) {\n            ret.root = '/';\n            start = 1;\n        }\n        else {\n            start = 0;\n        }\n        let startDot = -1;\n        let startPart = 0;\n        let end = -1;\n        let matchedSlash = true;\n        let i = path.length - 1;\n        // Track the state of characters (if any) we see before our first dot and\n        // after any path separator we find\n        let preDotState = 0;\n        // Get non-dir info\n        for (; i >= start; --i) {\n            const code = path.charCodeAt(i);\n            if (code === CHAR_FORWARD_SLASH) {\n                // If we reached a path separator that was not part of a set of path\n                // separators at the end of the string, stop now\n                if (!matchedSlash) {\n                    startPart = i + 1;\n                    break;\n                }\n                continue;\n            }\n            if (end === -1) {\n                // We saw the first non-path separator, mark this as the end of our\n                // extension\n                matchedSlash = false;\n                end = i + 1;\n            }\n            if (code === CHAR_DOT) {\n                // If this is our first dot, mark it as the start of our extension\n                if (startDot === -1) {\n                    startDot = i;\n                }\n                else if (preDotState !== 1) {\n                    preDotState = 1;\n                }\n            }\n            else if (startDot !== -1) {\n                // We saw a non-dot and non-path separator before our dot, so we should\n                // have a good chance at having a non-empty extension\n                preDotState = -1;\n            }\n        }\n        if (end !== -1) {\n            const start = startPart === 0 && isAbsolute ? 1 : startPart;\n            if (startDot === -1 ||\n                // We saw a non-dot character immediately before the dot\n                preDotState === 0 ||\n                // The (right-most) trimmed path component is exactly '..'\n                (preDotState === 1 && startDot === end - 1 && startDot === startPart + 1)) {\n                ret.base = ret.name = path.slice(start, end);\n            }\n            else {\n                ret.name = path.slice(start, startDot);\n                ret.base = path.slice(start, end);\n                ret.ext = path.slice(startDot, end);\n            }\n        }\n        if (startPart > 0) {\n            ret.dir = path.slice(0, startPart - 1);\n        }\n        else if (isAbsolute) {\n            ret.dir = '/';\n        }\n        return ret;\n    },\n    sep: '/',\n    delimiter: ':',\n    win32: null,\n    posix: null,\n};\nconst normalize = posix.normalize;\nconst isAbsolute = posix.isAbsolute;\nconst join = posix.join;\nconst resolve = posix.resolve;\nconst relative = posix.relative;\nconst dirname = posix.dirname;\nconst basename = posix.basename;\nconst extname = posix.extname;\nconst format = posix.format;\nconst parse = posix.parse;\nconst toNamespacedPath = posix.toNamespacedPath;\nconst sep = posix.sep;\nconst delimiter = posix.delimiter;\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nconst _schemePattern = /^\\w[\\w\\d+.-]*$/;\nconst _singleSlashStart = /^\\//;\nconst _doubleSlashStart = /^\\/\\//;\nfunction _validateUri(ret, _strict) {\n    // scheme, must be set\n    if (!ret.scheme && _strict) {\n        throw new Error(`[UriError]: Scheme is missing: {scheme: \"\", authority: \"${ret.authority}\", path: \"${ret.path}\", query: \"${ret.query}\", fragment: \"${ret.fragment}\"}`);\n    }\n    // scheme, https://tools.ietf.org/html/rfc3986#section-3.1\n    // ALPHA *( ALPHA / DIGIT / \"+\" / \"-\" / \".\" )\n    if (ret.scheme && !_schemePattern.test(ret.scheme)) {\n        throw new Error('[UriError]: Scheme contains illegal characters.');\n    }\n    // path, http://tools.ietf.org/html/rfc3986#section-3.3\n    // If a URI contains an authority component, then the path component\n    // must either be empty or begin with a slash (\"/\") character.  If a URI\n    // does not contain an authority component, then the path cannot begin\n    // with two slash characters (\"//\").\n    if (ret.path) {\n        if (ret.authority) {\n            if (!_singleSlashStart.test(ret.path)) {\n                throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash (\"/\") character');\n            }\n        }\n        else {\n            if (_doubleSlashStart.test(ret.path)) {\n                throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters (\"//\")');\n            }\n        }\n    }\n}\n// for a while we allowed uris *without* schemes and this is the migration\n// for them, e.g. an uri without scheme and without strict-mode warns and falls\n// back to the file-scheme. that should cause the least carnage and still be a\n// clear warning\nfunction _schemeFix(scheme, _strict) {\n    if (!scheme && !_strict) {\n        return 'file';\n    }\n    return scheme;\n}\n// implements a bit of https://tools.ietf.org/html/rfc3986#section-5\nfunction _referenceResolution(scheme, path) {\n    // the slash-character is our 'default base' as we don't\n    // support constructing URIs relative to other URIs. This\n    // see https://tools.ietf.org/html/rfc3986#section-5.1.4\n    switch (scheme) {\n        case 'https':\n        case 'http':\n        case 'file':\n            if (!path) {\n                path = _slash;\n            }\n            else if (path[0] !== _slash) {\n                path = _slash + path;\n            }\n            break;\n    }\n    return path;\n}\nconst _empty = '';\nconst _slash = '/';\nconst _regexp = /^(([^:/?#]+?):)?(\\/\\/([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?/;\n/**\n * Uniform Resource Identifier (URI) http://tools.ietf.org/html/rfc3986.\n * This class is a simple parser which creates the basic component parts\n * (http://tools.ietf.org/html/rfc3986#section-3) with minimal validation\n * and encoding.\n *\n * ```txt\n *       foo://example.com:8042/over/there?name=ferret#nose\n *       \\_/   \\______________/\\_________/ \\_________/ \\__/\n *        |           |            |            |        |\n *     scheme     authority       path        query   fragment\n *        |   _____________________|__\n *       / \\ /                        \\\n *       urn:example:animal:ferret:nose\n * ```\n */\nclass Uri {\n    /**\n     * @internal\n     */\n    constructor(schemeOrData, authority, path, query, fragment, _strict = false) {\n        if (typeof schemeOrData === 'object') {\n            this.scheme = schemeOrData.scheme || _empty;\n            this.authority = schemeOrData.authority || _empty;\n            this.path = schemeOrData.path || _empty;\n            this.query = schemeOrData.query || _empty;\n            this.fragment = schemeOrData.fragment || _empty;\n            // no validation because it's this URI\n            // that creates uri components.\n            // _validateUri(this);\n        }\n        else {\n            this.scheme = _schemeFix(schemeOrData, _strict);\n            this.authority = authority || _empty;\n            this.path = _referenceResolution(this.scheme, path || _empty);\n            this.query = query || _empty;\n            this.fragment = fragment || _empty;\n            _validateUri(this, _strict);\n        }\n    }\n    static ensureTrailingSlash(uri, trailingSlash = '/') {\n        return uri.with({\n            path: uri.path.replace(TRAILING_SLASH_RX, trailingSlash),\n        });\n    }\n    static equals(l, r) {\n        return (l.authority === r.authority &&\n            l.fragment === r.fragment &&\n            l.path === r.path &&\n            l.query === r.query &&\n            l.scheme === r.scheme);\n    }\n    static getFirstPathSegmentAfterPrefix(child, parent) {\n        const childHref = child.path;\n        const parentHref = parent.path;\n        const parentOffset = parentHref.charAt(parentHref.length - 1) === '/' ? -1 : 0;\n        for (let i = 0; i <= childHref.length; i++) {\n            if (i < parentHref.length) {\n                if (childHref.charAt(i) !== parentHref.charAt(i)) {\n                    throw new Error(`The child entry ${child.toString()} does not have the pathname of ${parent.toString()} as a prefix`);\n                }\n            }\n            else if (i === parentHref.length + parentOffset) {\n                if (childHref.charAt(i) !== '/') {\n                    throw new Error(`The child entry ${child.toString()} does not have the pathname of ${parent.toString()} as a prefix`);\n                }\n            }\n            else if (childHref.charAt(i) === '/') {\n                return childHref.slice(parentHref.length + 1 + parentOffset, i);\n            }\n        }\n        return childHref.slice(parentHref.length + 1 + parentOffset);\n    }\n    static isPrefixOf(prefix, uri) {\n        return (prefix.authority === uri.authority &&\n            prefix.fragment === uri.fragment &&\n            prefix.query === uri.query &&\n            prefix.scheme === uri.scheme &&\n            uri.path.startsWith(prefix.path));\n    }\n    static isUri(thing) {\n        if (thing instanceof Uri) {\n            return true;\n        }\n        if (!thing) {\n            return false;\n        }\n        return (typeof thing.authority === 'string' &&\n            typeof thing.fragment === 'string' &&\n            typeof thing.path === 'string' &&\n            typeof thing.query === 'string' &&\n            typeof thing.scheme === 'string' &&\n            typeof thing.fsPath === 'function' &&\n            typeof thing.with === 'function' &&\n            typeof thing.toString === 'function');\n    }\n    // ---- filesystem path -----------------------\n    /**\n       * Returns a string representing the corresponding file system path of this URI.\n       * platform specific path separator.\n       *\n       * * Will *not* validate the path for invalid characters and semantics.\n       * * Will *not* look at the scheme of this URI.\n       * * The result shall *not* be used for display purposes but for accessing a file on disk.\n       *\n       *\n       * The *difference* to `URI#path` is the use of the platform specific separator and the handling\n       *\n       * ```ts\n          const u = URI.parse('file://server/c$/folder/file.txt')\n          u.authority === 'server'\n          u.path === '/shares/c$/file.txt'\n          u.fsPath === '\\\\server\\c$\\folder\\file.txt'\n      ```\n       *\n       * Using `URI#path` to read a file (using fs-apis) would not be enough because parts of the path,\n       * namely the server name, would be missing. Therefore `URI#fsPath` exists - it's sugar to ease working\n       * with URIs that represent files on disk (`file` scheme).\n       */\n    get fsPath() {\n        // if (this.scheme !== 'file') {\n        // \tconsole.warn(`[UriError] calling fsPath with scheme ${this.scheme}`);\n        // }\n        return uriToFsPath(this, false);\n    }\n    // ---- modify to new -------------------------\n    with(change) {\n        if (!change) {\n            return this;\n        }\n        let { scheme, authority, path, query, fragment } = change;\n        if (scheme === undefined) {\n            scheme = this.scheme;\n        }\n        else if (scheme === null) {\n            scheme = _empty;\n        }\n        if (authority === undefined) {\n            authority = this.authority;\n        }\n        else if (authority === null) {\n            authority = _empty;\n        }\n        if (path === undefined) {\n            path = this.path;\n        }\n        else if (path === null) {\n            path = _empty;\n        }\n        if (query === undefined) {\n            query = this.query;\n        }\n        else if (query === null) {\n            query = _empty;\n        }\n        if (fragment === undefined) {\n            fragment = this.fragment;\n        }\n        else if (fragment === null) {\n            fragment = _empty;\n        }\n        if (scheme === this.scheme &&\n            authority === this.authority &&\n            path === this.path &&\n            query === this.query &&\n            fragment === this.fragment) {\n            return this;\n        }\n        return new _URI(scheme, authority, path, query, fragment);\n    }\n    // ---- parse & validate ------------------------\n    /**\n     * Creates a new URI from a string, e.g. `http://www.msft.com/some/path`,\n     * `file:///usr/home`, or `scheme:with/path`.\n     *\n     * @param value A string which represents an URI (see `URI#toString`).\n     */\n    static parse(value, _strict = false) {\n        const match = _regexp.exec(value);\n        if (!match) {\n            return new _URI(_empty, _empty, _empty, _empty, _empty);\n        }\n        return new _URI(match[2] || _empty, percentDecode(match[4] || _empty), percentDecode(match[5] || _empty), percentDecode(match[7] || _empty), percentDecode(match[9] || _empty), _strict);\n    }\n    /**\n       * Creates a new URI from a file system path, e.g. `c:\\my\\files`,\n       * `/usr/home`, or `\\\\server\\share\\some\\path`.\n       *\n       * The *difference* between `URI#parse` and `URI#file` is that the latter treats the argument\n       * as path, not as stringified-uri. E.g. `URI.file(path)` is **not the same as**\n       * `URI.parse('file://' + path)` because the path might contain characters that are\n       * interpreted (# and ?). See the following sample:\n       * ```ts\n      const good = URI.file('/coding/c#/project1');\n      good.scheme === 'file';\n      good.path === '/coding/c#/project1';\n      good.fragment === '';\n      const bad = URI.parse('file://' + '/coding/c#/project1');\n      bad.scheme === 'file';\n      bad.path === '/coding/c'; // path is now broken\n      bad.fragment === '/project1';\n      ```\n       *\n       * @param path A file system path (see `URI#fsPath`)\n       */\n    static file(path) {\n        let authority = _empty;\n        // check for authority as used in UNC shares\n        // or use the path as given\n        if (path[0] === _slash && path[1] === _slash) {\n            const idx = path.indexOf(_slash, 2);\n            if (idx === -1) {\n                authority = path.substring(2);\n                path = _slash;\n            }\n            else {\n                authority = path.substring(2, idx);\n                path = path.substring(idx) || _slash;\n            }\n        }\n        return new _URI('file', authority, path, _empty, _empty);\n    }\n    static from(components) {\n        return new _URI(components.scheme, components.authority, components.path, components.query, components.fragment);\n    }\n    /**\n     * Join a URI path with path fragments and normalizes the resulting path.\n     *\n     * @param uri The input URI.\n     * @param pathFragment The path fragment to add to the URI path.\n     * @returns The resulting URI.\n     */\n    static joinPath(uri, ...pathFragment) {\n        if (!uri.path) {\n            throw new Error(`[UriError]: cannot call joinPaths on URI without path`);\n        }\n        const newPath = join(uri.path, ...pathFragment);\n        return uri.with({ path: newPath });\n    }\n    // ---- printing/externalize ---------------------------\n    /**\n     * Creates a string representation for this URI. It's guaranteed that calling\n     * `URI.parse` with the result of this function creates an URI which is equal\n     * to this URI.\n     *\n     * * The result shall *not* be used for display purposes but for externalization or transport.\n     * * The result will be encoded using the percentage encoding and encoding happens mostly\n     * ignore the scheme-specific encoding rules.\n     *\n     * @param skipEncoding Do not encode the result, default is `false`\n     */\n    toString(skipEncoding = true) {\n        return _asFormatted(this, skipEncoding);\n    }\n    toJSON() {\n        return this;\n    }\n    static revive(data) {\n        if (!data) {\n            return data;\n        }\n        else if (data instanceof Uri) {\n            return data;\n        }\n        else {\n            const result = new _URI(data);\n            result._formatted = data.external;\n            result._fsPath = data._sep === _pathSepMarker ? data.fsPath : null;\n            return result;\n        }\n    }\n}\nconst _pathSepMarker = undefined;\n// eslint-disable-next-line @typescript-eslint/naming-convention\nclass _URI extends Uri {\n    constructor() {\n        super(...arguments);\n        this._formatted = null;\n        this._fsPath = null;\n    }\n    get fsPath() {\n        if (!this._fsPath) {\n            this._fsPath = uriToFsPath(this, false);\n        }\n        return this._fsPath;\n    }\n    toString(skipEncoding = true) {\n        if (!skipEncoding) {\n            // we don't cache that\n            return _asFormatted(this, false);\n        }\n        else {\n            if (!this._formatted) {\n                this._formatted = _asFormatted(this, true);\n            }\n            return this._formatted;\n        }\n    }\n    toJSON() {\n        const res = {\n            $mid: 1,\n        };\n        // cached state\n        if (this._fsPath) {\n            res.fsPath = this._fsPath;\n            res._sep = _pathSepMarker;\n        }\n        if (this._formatted) {\n            res.external = this._formatted;\n        }\n        // uri components\n        if (this.path) {\n            res.path = this.path;\n        }\n        if (this.scheme) {\n            res.scheme = this.scheme;\n        }\n        if (this.authority) {\n            res.authority = this.authority;\n        }\n        if (this.query) {\n            res.query = this.query;\n        }\n        if (this.fragment) {\n            res.fragment = this.fragment;\n        }\n        return res;\n    }\n}\n// reserved characters: https://tools.ietf.org/html/rfc3986#section-2.2\nconst encodeTable = {\n    [58 /* Colon */]: '%3A',\n    [47 /* Slash */]: '%2F',\n    [63 /* QuestionMark */]: '%3F',\n    [35 /* Hash */]: '%23',\n    [91 /* OpenSquareBracket */]: '%5B',\n    [93 /* CloseSquareBracket */]: '%5D',\n    [64 /* AtSign */]: '%40',\n    [33 /* ExclamationMark */]: '%21',\n    [36 /* DollarSign */]: '%24',\n    [38 /* Ampersand */]: '%26',\n    [39 /* SingleQuote */]: '%27',\n    [40 /* OpenParen */]: '%28',\n    [41 /* CloseParen */]: '%29',\n    [42 /* Asterisk */]: '%2A',\n    [43 /* Plus */]: '%2B',\n    [44 /* Comma */]: '%2C',\n    [59 /* Semicolon */]: '%3B',\n    [61 /* Equals */]: '%3D',\n    [32 /* Space */]: '%20',\n};\nfunction encodeURIComponentFast(uriComponent, allowSlash) {\n    let res = undefined;\n    let nativeEncodePos = -1;\n    for (let pos = 0; pos < uriComponent.length; pos++) {\n        const code = uriComponent.charCodeAt(pos);\n        // unreserved characters: https://tools.ietf.org/html/rfc3986#section-2.3\n        if ((code >= 97 /* a */ && code <= 122 /* z */) ||\n            (code >= 65 /* A */ && code <= 90 /* Z */) ||\n            (code >= 48 /* Digit0 */ && code <= 57 /* Digit9 */) ||\n            code === 45 /* Dash */ ||\n            code === 46 /* Period */ ||\n            code === 95 /* Underline */ ||\n            code === 126 /* Tilde */ ||\n            (allowSlash && code === 47 /* Slash */)) {\n            // check if we are delaying native encode\n            if (nativeEncodePos !== -1) {\n                res += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));\n                nativeEncodePos = -1;\n            }\n            // check if we write into a new string (by default we try to return the param)\n            if (res !== undefined) {\n                res += uriComponent.charAt(pos);\n            }\n        }\n        else {\n            // encoding needed, we need to allocate a new string\n            if (res === undefined) {\n                res = uriComponent.substr(0, pos);\n            }\n            // check with default table first\n            const escaped = encodeTable[code];\n            if (escaped !== undefined) {\n                // check if we are delaying native encode\n                if (nativeEncodePos !== -1) {\n                    res += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));\n                    nativeEncodePos = -1;\n                }\n                // append escaped variant to result\n                res += escaped;\n            }\n            else if (nativeEncodePos === -1) {\n                // use native encode only when needed\n                nativeEncodePos = pos;\n            }\n        }\n    }\n    if (nativeEncodePos !== -1) {\n        res += encodeURIComponent(uriComponent.substring(nativeEncodePos));\n    }\n    return res !== undefined ? res : uriComponent;\n}\nfunction encodeURIComponentMinimal(path) {\n    let res = undefined;\n    for (let pos = 0; pos < path.length; pos++) {\n        const code = path.charCodeAt(pos);\n        if (code === 35 /* Hash */ || code === 63 /* QuestionMark */) {\n            if (res === undefined) {\n                res = path.substr(0, pos);\n            }\n            res += encodeTable[code];\n        }\n        else {\n            if (res !== undefined) {\n                res += path[pos];\n            }\n        }\n    }\n    return res !== undefined ? res : path;\n}\n/**\n * Compute `fsPath` for the given uri\n */\nfunction uriToFsPath(uri, keepDriveLetterCasing) {\n    let value;\n    if (uri.authority && uri.path.length > 1 && uri.scheme === 'file') {\n        // unc path: file://shares/c$/far/boo\n        value = `//${uri.authority}${uri.path}`;\n    }\n    else if (uri.path.charCodeAt(0) === 47 /* Slash */ &&\n        ((uri.path.charCodeAt(1) >= 65 /* A */ && uri.path.charCodeAt(1) <= 90 /* Z */) ||\n            (uri.path.charCodeAt(1) >= 97 /* a */ && uri.path.charCodeAt(1) <= 122 /* z */)) &&\n        uri.path.charCodeAt(2) === 58 /* Colon */) {\n        if (!keepDriveLetterCasing) {\n            // windows drive letter: file:///c:/far/boo\n            value = uri.path[1].toLowerCase() + uri.path.substr(2);\n        }\n        else {\n            value = uri.path.substr(1);\n        }\n    }\n    else {\n        // other path\n        value = uri.path;\n    }\n    return value;\n}\n/**\n * Create the external version of a uri\n */\nfunction _asFormatted(uri, skipEncoding) {\n    const encoder = !skipEncoding ? encodeURIComponentFast : encodeURIComponentMinimal;\n    let res = '';\n    let { scheme, authority, path, query, fragment } = uri;\n    if (scheme) {\n        res += scheme;\n        res += ':';\n    }\n    if (authority || scheme === 'file') {\n        res += _slash;\n        res += _slash;\n    }\n    if (authority) {\n        let idx = authority.indexOf('@');\n        if (idx !== -1) {\n            // <user>@<auth>\n            const userinfo = authority.substr(0, idx);\n            authority = authority.substr(idx + 1);\n            idx = userinfo.indexOf(':');\n            if (idx === -1) {\n                res += encoder(userinfo, false);\n            }\n            else {\n                // <user>:<pass>@<auth>\n                res += encoder(userinfo.substr(0, idx), false);\n                res += ':';\n                res += encoder(userinfo.substr(idx + 1), false);\n            }\n            res += '@';\n        }\n        authority = authority.toLowerCase();\n        idx = authority.indexOf(':');\n        if (idx === -1) {\n            res += encoder(authority, false);\n        }\n        else {\n            // <auth>:<port>\n            res += encoder(authority.substr(0, idx), false);\n            res += authority.substr(idx);\n        }\n    }\n    if (path) {\n        // lower-case windows drive letters in /C:/fff or C:/fff\n        if (path.length >= 3 &&\n            path.charCodeAt(0) === 47 /* Slash */ &&\n            path.charCodeAt(2) === 58 /* Colon */) {\n            const code = path.charCodeAt(1);\n            if (code >= 65 /* A */ && code <= 90 /* Z */) {\n                path = `/${String.fromCharCode(code + 32)}:${path.substr(3)}`; // \"/c:\".length === 3\n            }\n        }\n        else if (path.length >= 2 && path.charCodeAt(1) === 58 /* Colon */) {\n            const code = path.charCodeAt(0);\n            if (code >= 65 /* A */ && code <= 90 /* Z */) {\n                path = `${String.fromCharCode(code + 32)}:${path.substr(2)}`; // \"/c:\".length === 3\n            }\n        }\n        // encode the rest of the path\n        res += encoder(path, true);\n    }\n    if (query) {\n        res += '?';\n        res += encoder(query, false);\n    }\n    if (fragment) {\n        res += '#';\n        res += !skipEncoding ? encodeURIComponentFast(fragment, false) : fragment;\n    }\n    return res;\n}\n// --- decode\nfunction decodeURIComponentGraceful(str) {\n    try {\n        return decodeURIComponent(str);\n    }\n    catch (_a) {\n        if (str.length > 3) {\n            return str.substr(0, 3) + decodeURIComponentGraceful(str.substr(3));\n        }\n        else {\n            return str;\n        }\n    }\n}\nconst _rEncodedAsHex = /(%[0-9A-Za-z][0-9A-Za-z])+/g;\nfunction percentDecode(str) {\n    if (!str.match(_rEncodedAsHex)) {\n        return str;\n    }\n    return str.replace(_rEncodedAsHex, (match) => decodeURIComponentGraceful(match));\n}\nconst TRAILING_SLASH_RX = /\\/?$/;\n\nconst version = '0.45.1';\n\nexport { AmbiguousModuleError, Base64, CanceledError, Decoder, DependencyNotFoundError, EntryExcludedError, EntryNotFoundError, MapSet, NotResolvableError, ParseError, Uri, all, basename, checkCancellation, delimiter, dirname, extname, format, isAbsolute, isCanceledError, isThenable, isValidPackageJson, isValidPartialPackageJson, join, normalize, parse, parseBufferAsPackageJson, parseBufferAsPartialPackageJson, posix, relative, resolve, sep, toNamespacedPath, uriToFsPath, version };\n//# sourceMappingURL=index.js.map\n","import { Uri } from '@velcro/common';\nimport { AbstractResolverStrategyWithRoot, ResolverStrategy } from '@velcro/resolver';\n\nvar FileEncoding;\n(function (FileEncoding) {\n    FileEncoding[\"Base64\"] = \"base64\";\n    FileEncoding[\"UTF8\"] = \"utf-8\";\n})(FileEncoding || (FileEncoding = {}));\nconst encodeText = typeof TextEncoder === 'function'\n    ? (function () {\n        const encoder = new TextEncoder();\n        return function encodeText(data) {\n            return encoder.encode(data).buffer;\n        };\n    })()\n    : typeof Buffer === 'function'\n        ? function encodeText(data) {\n            return Buffer.from(data);\n        }\n        : function encodeText(_data) {\n            throw new Error('The environment provides neither TextEncoder nor Buffer. Please consider polyfilling one of these APIs.');\n        };\nclass MemoryStrategy extends AbstractResolverStrategyWithRoot {\n    constructor(files, rootUri = Uri.parse('memory:/')) {\n        super(Uri.ensureTrailingSlash(rootUri));\n        this.root = {\n            type: ResolverStrategy.EntryKind.Directory,\n            children: {},\n        };\n        for (const pathname in files) {\n            const file = files[pathname];\n            if (typeof file === 'string') {\n                this.addFile(pathname, file);\n            }\n            else {\n                this.addFile(pathname, file.content, { encoding: file.encoding });\n            }\n        }\n    }\n    getEntryAtPath(pathname) {\n        const segments = Array.isArray(pathname)\n            ? pathname.slice()\n            : pathname.split('/').filter(Boolean);\n        let parent = this.root;\n        for (const segment of segments) {\n            if (!parent || parent.type !== ResolverStrategy.EntryKind.Directory) {\n                throw new Error(`Failed to add ${pathname}`);\n            }\n            parent = parent.children[segment];\n        }\n        return parent;\n    }\n    addFile(pathname, content, { encoding = FileEncoding.UTF8, overwrite = false, } = {}) {\n        const segments = pathname.split('/').filter(Boolean);\n        const filename = segments.pop();\n        if (!filename) {\n            throw new Error(`Unable to add a file without a filename '${pathname}'`);\n        }\n        let parent = this.root;\n        for (const segment of segments) {\n            if (!parent || parent.type !== ResolverStrategy.EntryKind.Directory) {\n                throw new Error(`Failed to add ${pathname}`);\n            }\n            let dir = parent.children[segment];\n            if (!dir) {\n                dir = {\n                    type: ResolverStrategy.EntryKind.Directory,\n                    children: {},\n                };\n                parent.children[segment] = dir;\n            }\n            parent = dir;\n        }\n        if (parent.type !== ResolverStrategy.EntryKind.Directory) {\n            throw new Error(`Cannot add file to a non directory entry ${pathname}`);\n        }\n        if (parent.children[filename] && !overwrite) {\n            throw new Error(`Entry already exists at ${pathname}`);\n        }\n        const entry = {\n            type: ResolverStrategy.EntryKind.File,\n            content,\n            encoding,\n        };\n        parent.children[filename] = entry;\n        return entry;\n    }\n    removeFile(pathname) {\n        const segments = pathname.split('/').filter(Boolean);\n        const filename = segments.pop();\n        if (!filename) {\n            return false;\n        }\n        let parent = this.root;\n        for (const segment of segments) {\n            if (!parent || parent.type !== ResolverStrategy.EntryKind.Directory) {\n                return false;\n            }\n            parent = parent.children[segment];\n        }\n        if (!parent || parent.type !== ResolverStrategy.EntryKind.Directory) {\n            return false;\n        }\n        return delete parent.children[filename];\n    }\n    getResolveRoot() {\n        return {\n            uri: this.rootUri,\n        };\n    }\n    listEntries(_ctx, uri) {\n        const urlPathname = Uri.ensureTrailingSlash(uri).fsPath;\n        const basePathname = this.rootUri.fsPath;\n        const fsPathname = urlPathname.startsWith(basePathname)\n            ? urlPathname.slice(basePathname.length - 1)\n            : urlPathname;\n        const parent = this.getEntryAtPath(fsPathname);\n        if (!parent) {\n            throw new Error(`No such directory ${uri.toString()}`);\n        }\n        if (parent.type !== ResolverStrategy.EntryKind.Directory) {\n            throw new Error(`Cannot list entries under a file at ${uri.toString()}`);\n        }\n        const entries = Object.keys(parent.children).map((filename) => {\n            const entry = parent.children[filename];\n            return {\n                uri: Uri.joinPath(this.rootUri, fsPathname, filename),\n                type: entry.type,\n            };\n        });\n        return {\n            entries,\n        };\n    }\n    readFileContent(_ctx, uri) {\n        const urlPathname = Uri.ensureTrailingSlash(uri).fsPath;\n        const basePathname = this.rootUri.fsPath;\n        const fsPathname = urlPathname.startsWith(basePathname)\n            ? urlPathname.slice(basePathname.length - 1)\n            : urlPathname;\n        const entry = this.getEntryAtPath(fsPathname);\n        if (!entry) {\n            throw new Error(`No such file ${uri.toString()}`);\n        }\n        if (entry.type !== 'file') {\n            throw new Error(`Cannot read content of a non-file at ${uri.toString()}`);\n        }\n        switch (entry.encoding) {\n            case FileEncoding.Base64: {\n                const binSting = atob(entry.content);\n                const binArray = new Uint8Array(binSting.length);\n                Array.prototype.forEach.call(binArray, function (_el, idx, arr) {\n                    arr[idx] = binSting.charCodeAt(idx);\n                });\n                return {\n                    content: binArray.buffer,\n                };\n            }\n            case FileEncoding.UTF8: {\n                return {\n                    content: encodeText(entry.content),\n                };\n            }\n            default:\n                throw new Error(`Unsupported encoding for ${uri.toString()}: ${entry.encoding}`);\n        }\n    }\n    uriForPath(pathname) {\n        return Uri.joinPath(this.rootUri, pathname);\n    }\n}\n\nconst version = '0.45.1';\n\nexport { MemoryStrategy, version };\n//# sourceMappingURL=index.js.map\n","import { DisposableStore, Emitter, IDisposable } from '@velcro/common';\nimport * as Monaco from 'monaco-editor';\nimport { createContext, useContext, useEffect, useState } from 'react';\n\nexport class EditorManager implements IDisposable {\n  editor: Monaco.editor.IStandaloneCodeEditor | null = null;\n\n  private readonly disposableStore = new DisposableStore();\n  private readonly initialPath: string | undefined;\n  private readonly viewState = new WeakMap<\n    Monaco.editor.ITextModel,\n    Monaco.editor.ICodeEditorViewState\n  >();\n\n  private readonly onWillFocusModelEmitter = new Emitter<Monaco.editor.ITextModel>();\n  private readonly onDidChangeEmitter = new Emitter<{ model: Monaco.editor.ITextModel }>();\n\n  constructor(options: { files?: Record<string, string>; initialPath?: string } = {}) {\n    this.disposableStore.add(this.onWillFocusModelEmitter);\n    this.disposableStore.add(this.onDidChangeEmitter);\n\n    Monaco.languages.typescript.typescriptDefaults.setEagerModelSync(true);\n    Monaco.languages.typescript.typescriptDefaults.setMaximumWorkerIdleTime(-1);\n    Monaco.languages.typescript.typescriptDefaults.setCompilerOptions({\n      allowJs: true,\n      allowNonTsExtensions: true,\n      allowSyntheticDefaultImports: true,\n      baseUrl: '.',\n      checkJs: true,\n      esModuleInterop: true,\n      experimentalDecorators: true,\n      inlineSourceMap: true,\n      inlineSources: true,\n      isolatedModules: false,\n      jsx: Monaco.languages.typescript.JsxEmit.React,\n      lib: ['dom'],\n      module: Monaco.languages.typescript.ModuleKind.CommonJS,\n      moduleResolution: Monaco.languages.typescript.ModuleResolutionKind.NodeJs,\n      noEmit: false,\n      outDir: `dist`,\n      resolveJsonModule: true,\n      rootDir: '/',\n      sourceMap: true,\n      target: Monaco.languages.typescript.ScriptTarget.ES2015,\n      typeRoots: ['node_modules/@types'],\n    });\n    Monaco.languages.typescript.typescriptDefaults.setDiagnosticsOptions({\n      noSemanticValidation: true,\n      noSyntaxValidation: false,\n    });\n\n    if (options.files) {\n      for (const pathname in options.files) {\n        const content = options.files[pathname];\n\n        this.createModel(pathname, content);\n      }\n    }\n\n    this.initialPath = options.initialPath;\n  }\n\n  get dispose() {\n    return this.disposableStore.dispose;\n  }\n\n  get onDidChange() {\n    return this.onDidChangeEmitter.event;\n  }\n\n  get onWillFocusModel() {\n    return this.onWillFocusModelEmitter.event;\n  }\n\n  createModel(pathname: string, content = '') {\n    const language = this.inferLanguage(pathname);\n\n    let uri: Monaco.Uri;\n\n    try {\n      uri = Monaco.Uri.file(pathname);\n    } catch (err) {\n      throw new Error(`Invalid path '${pathname}': ${err && err.message}`);\n    }\n\n    if (Monaco.editor.getModel(uri)) {\n      throw new Error(`Cannot create file because it exists '${pathname}'`);\n    }\n\n    return Monaco.editor.createModel(content, language, uri);\n  }\n\n  focusHref(\n    href: string,\n    options: {\n      lineNumber?: number;\n      columnNumber?: number;\n      markers?: Monaco.editor.IMarkerData[];\n    } = {}\n  ) {\n    const model = this.getModelByHref(href);\n\n    if (model) {\n      this.focusModel(model, options);\n    }\n  }\n\n  focusModel(\n    model: Monaco.editor.ITextModel,\n    options: {\n      lineNumber?: number;\n      columnNumber?: number;\n      markers?: Monaco.editor.IMarkerData[];\n    } = {}\n  ) {\n    if (this.editor) {\n      this.editor.setModel(model);\n      if (options.lineNumber) {\n        this.editor.revealLineInCenter(options.lineNumber, Monaco.editor.ScrollType.Smooth);\n        this.editor.setPosition({\n          column: options.columnNumber || 0,\n          lineNumber: options.lineNumber,\n        });\n      }\n      if (options.markers) {\n        Monaco.editor.setModelMarkers(model, 'editorManager', options.markers);\n      }\n      this.editor.focus();\n    }\n  }\n\n  focusPath(\n    path: string,\n    options: {\n      lineNumber?: number;\n      columnNumber?: number;\n      markers?: Monaco.editor.IMarkerData[];\n    } = {}\n  ) {\n    const model = this.getModelByPath(path);\n\n    if (model) {\n      this.focusModel(model, options);\n    }\n  }\n\n  getModelByHref(href: string) {\n    try {\n      const uri = Monaco.Uri.parse(href);\n      return Monaco.editor.getModel(uri);\n    } catch (_) {\n      return null;\n    }\n  }\n\n  getModelByPath(path: string) {\n    return Monaco.editor.getModel(Monaco.Uri.file(path));\n  }\n\n  mount(el: HTMLElement) {\n    if (this.editor) {\n      throw new Error('Invariant violation: Editor already mounted');\n    }\n\n    this.editor = Monaco.editor.create(el, {\n      model: null,\n      automaticLayout: true,\n      minimap: {\n        enabled: false,\n      },\n      showUnused: true,\n      scrollBeyondLastLine: false,\n      theme: 'vs',\n      wordWrap: 'bounded',\n      wrappingIndent: 'same',\n    });\n\n    this.editor.onDidDispose(() => {\n      this.editor = null;\n    });\n\n    this.editor.onDidChangeModel((e) => {\n      if (e.newModelUrl && this.editor) {\n        const model = Monaco.editor.getModel(e.newModelUrl)!;\n        const viewState = this.viewState.get(model);\n\n        if (viewState) {\n          this.editor.restoreViewState(viewState);\n        }\n      }\n    });\n\n    this.editor.onDidBlurEditorText(() => {\n      if (this.editor) {\n        const model = this.editor.getModel();\n        const viewState = this.editor.saveViewState();\n\n        if (model && viewState) {\n          this.viewState.set(model, viewState);\n        }\n      }\n    });\n\n    this.disposableStore.add(this.editor);\n\n    if (this.initialPath) {\n      this.focusPath(this.initialPath);\n    }\n\n    return this.editor;\n  }\n\n  inferLanguage(pathname: string) {\n    return pathname.match(/\\.(?:tsx?|jsx?)$/) ? 'typescript' : undefined;\n  }\n}\n\nexport const EditorManagerContext = createContext<EditorManager>(undefined as any);\n\nexport function useActiveModel() {\n  const workbench = useContext(EditorManagerContext);\n  const [activeModel, setActiveModel] = useState<Monaco.editor.ITextModel | null>(\n    workbench.editor ? workbench.editor.getModel() : null\n  );\n\n  useEffect(() => {\n    const disposable = new DisposableStore();\n\n    const trackEditor = (editor: Monaco.editor.ICodeEditor) => {\n      editor.onDidChangeModel((e) => {\n        const model = e.newModelUrl ? Monaco.editor.getModel(e.newModelUrl) : null;\n\n        setActiveModel(model);\n      });\n\n      disposable.add(\n        editor.onDidBlurEditorText(() => {\n          setActiveModel(null);\n        })\n      );\n\n      disposable.add(\n        editor.onDidFocusEditorText(() => {\n          setActiveModel(editor.getModel());\n        })\n      );\n\n      if (editor.hasTextFocus()) {\n        setActiveModel(editor.getModel());\n      }\n    };\n\n    disposable.add(Monaco.editor.onDidCreateEditor(trackEditor));\n    if (workbench.editor) {\n      trackEditor(workbench.editor);\n    }\n\n    return () => disposable.dispose();\n  }, [workbench.editor, activeModel]);\n\n  return activeModel;\n}\n","import { Base64, Uri, isThenable, checkCancellation, DependencyNotFoundError, EntryExcludedError, EntryNotFoundError, MapSet, DisposableStore, Emitter, CancellationTokenSource, isCanceledError } from '@velcro/common';\nimport MagicString, { Bundle } from 'magic-string';\nimport { parse as parse$2 } from 'acorn';\n\nclass BaseError extends Error {\n    constructor() {\n        super(...arguments);\n        this.name = this.constructor.name;\n    }\n}\nclass GraphBuildError extends BaseError {\n    constructor(errors) {\n        super(`Graph building failed with errors:\\n${errors.map((err) => `  ${err.message}`).join('\\n')}`);\n        this.errors = errors;\n    }\n}\n\nvar charToInteger = {};\nvar chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\nfor (var i = 0; i < chars.length; i++) {\n    charToInteger[chars.charCodeAt(i)] = i;\n}\nfunction decode(mappings) {\n    var decoded = [];\n    var line = [];\n    var segment = [\n        0,\n        0,\n        0,\n        0,\n        0,\n    ];\n    var j = 0;\n    for (var i = 0, shift = 0, value = 0; i < mappings.length; i++) {\n        var c = mappings.charCodeAt(i);\n        if (c === 44) { // \",\"\n            segmentify(line, segment, j);\n            j = 0;\n        }\n        else if (c === 59) { // \";\"\n            segmentify(line, segment, j);\n            j = 0;\n            decoded.push(line);\n            line = [];\n            segment[0] = 0;\n        }\n        else {\n            var integer = charToInteger[c];\n            if (integer === undefined) {\n                throw new Error('Invalid character (' + String.fromCharCode(c) + ')');\n            }\n            var hasContinuationBit = integer & 32;\n            integer &= 31;\n            value += integer << shift;\n            if (hasContinuationBit) {\n                shift += 5;\n            }\n            else {\n                var shouldNegate = value & 1;\n                value >>>= 1;\n                if (shouldNegate) {\n                    value = value === 0 ? -0x80000000 : -value;\n                }\n                segment[j] += value;\n                j++;\n                value = shift = 0; // reset\n            }\n        }\n    }\n    segmentify(line, segment, j);\n    decoded.push(line);\n    return decoded;\n}\nfunction segmentify(line, segment, j) {\n    // This looks ugly, but we're creating specialized arrays with a specific\n    // length. This is much faster than creating a new array (which v8 expands to\n    // a capacity of 17 after pushing the first item), or slicing out a subarray\n    // (which is slow). Length 4 is assumed to be the most frequent, followed by\n    // length 5 (since not everything will have an associated name), followed by\n    // length 1 (it's probably rare for a source substring to not have an\n    // associated segment data).\n    if (j === 4)\n        line.push([segment[0], segment[1], segment[2], segment[3]]);\n    else if (j === 5)\n        line.push([segment[0], segment[1], segment[2], segment[3], segment[4]]);\n    else if (j === 1)\n        line.push([segment[0]]);\n}\nfunction encode(decoded) {\n    var sourceFileIndex = 0; // second field\n    var sourceCodeLine = 0; // third field\n    var sourceCodeColumn = 0; // fourth field\n    var nameIndex = 0; // fifth field\n    var mappings = '';\n    for (var i = 0; i < decoded.length; i++) {\n        var line = decoded[i];\n        if (i > 0)\n            mappings += ';';\n        if (line.length === 0)\n            continue;\n        var generatedCodeColumn = 0; // first field\n        var lineMappings = [];\n        for (var _i = 0, line_1 = line; _i < line_1.length; _i++) {\n            var segment = line_1[_i];\n            var segmentMappings = encodeInteger(segment[0] - generatedCodeColumn);\n            generatedCodeColumn = segment[0];\n            if (segment.length > 1) {\n                segmentMappings +=\n                    encodeInteger(segment[1] - sourceFileIndex) +\n                        encodeInteger(segment[2] - sourceCodeLine) +\n                        encodeInteger(segment[3] - sourceCodeColumn);\n                sourceFileIndex = segment[1];\n                sourceCodeLine = segment[2];\n                sourceCodeColumn = segment[3];\n            }\n            if (segment.length === 5) {\n                segmentMappings += encodeInteger(segment[4] - nameIndex);\n                nameIndex = segment[4];\n            }\n            lineMappings.push(segmentMappings);\n        }\n        mappings += lineMappings.join(',');\n    }\n    return mappings;\n}\nfunction encodeInteger(num) {\n    var result = '';\n    num = num < 0 ? (-num << 1) | 1 : num << 1;\n    do {\n        var clamped = num & 31;\n        num >>>= 5;\n        if (num > 0) {\n            clamped |= 32;\n        }\n        result += chars[clamped];\n    } while (num > 0);\n    return result;\n}\n\nclass SourceMap {\n    constructor(input) {\n        this.file = input.file;\n        this.mappings = input.mappings;\n        this.sourceRoot = input.sourceRoot;\n        this.names = input.names;\n        this.sources = input.sources;\n        this.sourcesContent = input.sourcesContent;\n        this.version = input.version;\n    }\n    toString() {\n        return JSON.stringify(this);\n    }\n    toDataUri() {\n        return `data:application/json;charset=utf-8;base64,${Base64.encode(this.toString())}`;\n    }\n}\nfunction getSourceMappingUrlMatch(str) {\n    const re = /(?:(?:\\/\\/|\\/\\*)[@#][\\s]*(?:source)MappingURL=([^\\s'\"]+)[\\s]*$)|(?:\\/\\*[@#][\\s]*(?:source)MappingURL=([^\\s*'\"]+)[\\s]*(?:\\*\\/)[\\s]*$)/gm;\n    // Keep executing the search to find the *last* sourceMappingURL to avoid\n    // picking up sourceMappingURLs from comments, strings, etc.\n    let lastMatch = null;\n    let match;\n    while ((match = re.exec(str)))\n        lastMatch = match;\n    return lastMatch;\n}\nfunction getSourceMappingUrl(str) {\n    const lastMatch = getSourceMappingUrlMatch(str);\n    if (!lastMatch)\n        return '';\n    return lastMatch[1];\n}\nfunction updateSourceMappingUrl(str, url) {\n    const lastMatch = getSourceMappingUrlMatch(str);\n    if (!lastMatch)\n        return str;\n    return str.slice(0, lastMatch.index) + str.slice(lastMatch.index).replace(lastMatch[1], url);\n}\nfunction decodeDataUriAsSourceMap(href) {\n    const match = href.match(/^data:application\\/json;(?:charset=([^;]+);)?base64,(.*)$/);\n    if (match) {\n        if (match[1] && match[1] !== 'utf-8') {\n            return null;\n        }\n        try {\n            const decoded = JSON.parse(Base64.decode(match[2]));\n            if (decoded.mappings === '') {\n                return {\n                    file: '',\n                    mappings: [],\n                    names: [],\n                    sources: [],\n                    sourcesContent: [],\n                };\n            }\n            if (typeof decoded.mappings === 'string') {\n                decoded.mappings = decode(decoded.mappings);\n            }\n            return decoded;\n        }\n        catch (err) {\n            return null;\n        }\n    }\n    return null;\n}\n\n/**\n * Copyright (c) Rollup 2020 authors: https://github.com/rollup/rollup/graphs/contributors)\n *\n * Copied with light modifications from:\n * https://github.com/rollup/rollup/blob/36a4527473ea1fe678ed866c9f8dfd3c2542cd22/src/utils/collapseSourcemaps.ts\n */\nclass Source {\n    constructor(filename, content) {\n        this.filename = filename;\n        this.content = content;\n    }\n    traceSegment(line, column, name) {\n        return { line, column, name, source: this };\n    }\n}\nclass Link {\n    constructor(map, sources) {\n        this.sources = sources;\n        this.names = map.names;\n        this.mappings = typeof map.mappings === 'string' ? decode(map.mappings) : map.mappings;\n    }\n    traceMappings() {\n        const sources = [];\n        const sourcesContent = [];\n        const names = [];\n        const mappings = [];\n        for (const line of this.mappings) {\n            const tracedLine = [];\n            for (const segment of line) {\n                if (segment.length == 1)\n                    continue;\n                const source = this.sources[segment[1]];\n                if (!source)\n                    continue;\n                const traced = source.traceSegment(segment[2], segment[3], segment.length === 5 ? this.names[segment[4]] : '');\n                if (traced) {\n                    // newer sources are more likely to be used, so search backwards.\n                    let sourceIndex = sources.lastIndexOf(traced.source.filename);\n                    if (sourceIndex === -1) {\n                        sourceIndex = sources.length;\n                        sources.push(traced.source.filename);\n                        sourcesContent[sourceIndex] = traced.source.content;\n                    }\n                    else if (sourcesContent[sourceIndex] == null) {\n                        sourcesContent[sourceIndex] = traced.source.content;\n                    }\n                    else if (traced.source.content != null &&\n                        sourcesContent[sourceIndex] !== traced.source.content) {\n                        return new Error(`Multiple conflicting contents for sourcemap source ${traced.source.filename}`);\n                    }\n                    const tracedSegment = [\n                        segment[0],\n                        sourceIndex,\n                        traced.line,\n                        traced.column,\n                    ];\n                    if (traced.name) {\n                        let nameIndex = names.indexOf(traced.name);\n                        if (nameIndex === -1) {\n                            nameIndex = names.length;\n                            names.push(traced.name);\n                        }\n                        tracedSegment[4] = nameIndex;\n                    }\n                    tracedLine.push(tracedSegment);\n                }\n            }\n            mappings.push(tracedLine);\n        }\n        return { sources, sourcesContent, names, mappings };\n    }\n    traceSegment(line, column, name) {\n        const segments = this.mappings[line];\n        if (!segments)\n            return null;\n        // binary search through segments for the given column\n        let i = 0;\n        let j = segments.length - 1;\n        while (i <= j) {\n            const m = (i + j) >> 1;\n            const segment = segments[m];\n            if (segment[0] === column) {\n                if (segment.length == 1)\n                    return null;\n                const source = this.sources[segment[1]];\n                if (!source)\n                    return null;\n                return source.traceSegment(segment[2], segment[3], segment.length === 5 ? this.names[segment[4]] : name);\n            }\n            if (segment[0] > column) {\n                j = m - 1;\n            }\n            else {\n                i = m + 1;\n            }\n        }\n        return null;\n    }\n}\n/**\n * This function attempts to compensate for the loss of precision when lower\n * layers of source maps have higher precision than upper layers, leading to\n * a loss of fidelity.\n *\n * The code was lifted from [Alec Larson](https://github.com/aleclarson)'s\n * [fork of sorcery](https://github.com/aleclarson/sorcery/blob/3934a3f38a6d8604fc9dbaa576cbb6e4d733040f/src/blend.js).\n *\n * NOTE: This function mutates the given node.\n *\n * @copyright [Alec Larson](https://github.com/aleclarson) 2018\n */\n// function blend(node: Link) {\n//   let mappings: SourceMapSegment[][] = []; // traced lines\n//   let sources: (Link | Source)[] = []; // traced sources\n//   let names: string[] = []; // traced symbols\n//   // Precompute which source/line/column triples are mapped by the given node.\n//   // These references are useful when interweaving old segments.\n//   const refs: number[][][] = Object.keys(node.sources).map(() => []);\n//   for (const segments of node.mappings) {\n//     let segment: SourceMapSegment;\n//     let lines: number[][];\n//     let columns: number[];\n//     for (let i = 0; i < segments.length; i++) {\n//       segment = segments[i];\n//       if (segment.length === 4 || segment.length === 5) {\n//         lines = refs[segment[1]];\n//         if (!lines) refs[segment[1]] = lines = [];\n//         columns = lines[segment[2]];\n//         if (columns) {\n//           uniqueAscendingInsert(columns, segment[3]);\n//         } else {\n//           lines[segment[2]] = [segment[3]];\n//         }\n//       }\n//     }\n//   }\n//   let traced: SourceMapSegment[] | undefined = undefined; // the traced line mapping\n//   let untraced: SourceMapSegment[] | undefined = undefined; // the untraced line mapping\n//   function addSegment(\n//     segment: SourceMapSegment,\n//     source?: { names: string[]; sources: (Link | Source)[] }\n//   ) {\n//     if (source) {\n//       segment[1] = uniq<Link | Source>(sources, source.sources[segment[1]!]);\n//       if (segment.length === 5) {\n//         segment[4] = uniq(names, source.names[segment[4]]);\n//       }\n//     } else if (segment.length === 5) {\n//       segment[4] = uniq(names, node.names[segment[4]]);\n//     }\n//     traced!.push(segment);\n//   }\n//   let tracedLine: number; // the last traced line\n//   let generatedLine = -1; // the current line\n//   let sourceIndex: number | undefined = -1; // source of last traced segment\n//   let sourceLine: number | undefined = undefined; // source line of last traced segment\n//   // Find the next line with segments.\n//   function nextLine() {\n//     tracedLine = generatedLine;\n//     while (++generatedLine < node.mappings.length) {\n//       untraced = node.mappings[generatedLine];\n//       if (untraced.length) return true;\n//     }\n//   }\n//   // Provide mappings for lines between the\n//   // last traced line and the current line.\n//   function fillSkippedLines() {\n//     const skipped = generatedLine - (tracedLine + 1);\n//     if (skipped !== 0) {\n//       let line = tracedLine;\n//       // Take line mappings from the current source.\n//       if (sourceIndex !== -1) {\n//         const source = node.sources[sourceIndex!];\n//         if (source instanceof Link) {\n//           while (line < generatedLine - 1) {\n//             if (++sourceLine! !== source.mappings.length) {\n//               mappings[++line] = traced = [];\n//               // Check referenced columns to avoid duplicate segments.\n//               const columns = refs[sourceIndex!][sourceLine!] || [];\n//               let prevColumn = -1;\n//               // Interweave old segments from the current source.\n//               const segments = source.mappings[sourceLine!];\n//               for (let i = 0; i < segments.length; i++) {\n//                 const segment = segments[i];\n//                 if (!hasValueBetween(columns, prevColumn, segment[0] + 1)) {\n//                   addSegment([...segment] as SourceMapSegment, source);\n//                   prevColumn = segment[0];\n//                 } else break;\n//               }\n//             } else {\n//               // End of source file.\n//               sourceIndex = -1;\n//               break;\n//             }\n//           }\n//         }\n//       }\n//       // Default to empty arrays for unmapped lines.\n//       while (++line < generatedLine) {\n//         mappings[line] = [];\n//       }\n//     }\n//   }\n//   while (nextLine()) {\n//     fillSkippedLines();\n//     // Trace the segments of this generated line.\n//     mappings[generatedLine] = traced = [];\n//     // Interweave old segments before the first mapped column of each line.\n//     const sourceColumn = untraced![0][3];\n//     if (sourceIndex !== -1 && sourceColumn !== 0) {\n//       const source = node.sources[sourceIndex];\n//       if (source instanceof Link) {\n//         const segments =\n//           sourceLine! < source.mappings.length - 1 ? source.mappings[++sourceLine!] : [];\n//         for (let i = 0; i < segments.length; i++) {\n//           const segment = segments[i];\n//           if (segment[0] < sourceColumn!) {\n//             addSegment(segment.slice(0) as SourceMapSegment, source);\n//           } else break;\n//         }\n//       }\n//     }\n//     const last = untraced!.length - 1;\n//     untraced!.forEach((curr: SourceMapSegment | null, i) => {\n//       [, sourceIndex, sourceLine] = curr!;\n//       const source = node.sources[sourceIndex!];\n//       if (source === null) {\n//         curr![1] = uniq(sources, null);\n//         return addSegment(curr!);\n//       }\n//       if (!(source instanceof Link)) {\n//         curr![1] = uniq(sources, source);\n//         return addSegment(curr!);\n//       }\n//       const next = i !== last ? untraced![i + 1] : null;\n//       const sourceColumn = curr![3];\n//       const generatedColumn = curr![0];\n//       // Find the first segment with a greater column.\n//       const segments = source.mappings[sourceLine!] || [];\n//       let j = findGreaterColumn(segments, sourceColumn!);\n//       // A \"base segment\" is required for tracing to a grand-parent.\n//       let base;\n//       if (--j !== -1) {\n//         base = segments[j];\n//         curr![1] = uniq(sources, source.sources[base[1]!]);\n//         curr![2] = base[2];\n//         curr![3] = base[3]! + sourceColumn! - base[0];\n//         if (base.length === 5) {\n//           // Inherit the names of aligned base segments.\n//           if (base[0] === sourceColumn) {\n//             curr![4] = uniq(names, source.names[base[4]!]);\n//           }\n//         } else if (curr!.length === 5) {\n//           // When our segment is named and the base segment is not,\n//           // assume this segment cannot be traced to its original source.\n//           if (base[0] !== sourceColumn) curr = null;\n//         }\n//       } else {\n//         curr![1] = uniq(sources, null);\n//       }\n//       curr && addSegment(curr);\n//       // Check referenced columns to avoid duplicate segments.\n//       const columns = refs[sourceIndex!][sourceLine!] || [];\n//       let baseColumn = base ? base[0] : -1;\n//       // Interweave old segments between our current and next segments.\n//       const nextColumn = next ? next[0] : 1 / 0;\n//       while (++j < segments.length) {\n//         let segment = segments[j];\n//         // The generated column is shifted to fit into the root source map.\n//         const column = segment[0] + generatedColumn - sourceColumn!;\n//         if (column >= nextColumn) break;\n//         // Avoid duplicates by checking if this segment goes elsewhere.\n//         if (!hasValueBetween(columns, baseColumn, segment[0] + 1)) {\n//           baseColumn = segment[0];\n//           segment = segment.slice(0) as SourceMapSegment;\n//           segment[0] = column;\n//           addSegment(segment, source);\n//         } else break;\n//       }\n//     });\n//   }\n//   fillSkippedLines();\n//   node.mappings = mappings;\n//   node.sources = sources;\n//   node.names = names;\n//   return node;\n// }\n// // Check if a value exists before pushing it to an array.\n// // Return the new or existing index of the value.\n// function uniq<T>(arr: T[], val: T): number {\n//   const i = arr.indexOf(val);\n//   return ~i ? i : arr.push(val) - 1;\n// }\n// // Get the first segment with a greater column.\n// function findGreaterColumn(segments: SourceMapSegment[], column: number) {\n//   let low = 0,\n//     high = segments.length;\n//   while (low < high) {\n//     const mid = (low + high) >>> 1;\n//     segments[mid][0] <= column ? (low = mid + 1) : (high = mid);\n//   }\n//   return low;\n// }\n// // The range is exclusive.\n// function hasValueBetween(arr: number[], start: number, end: number) {\n//   let low = 0,\n//     high = arr.length;\n//   while (low < high) {\n//     const mid = (low + high) >>> 1;\n//     const val = arr[mid];\n//     if (val <= start) {\n//       low = mid + 1;\n//     } else if (val >= end) {\n//       high = mid;\n//     } else {\n//       return true;\n//     }\n//   }\n//   return false;\n// }\n// // Insert unique values in ascending order.\n// function uniqueAscendingInsert(arr: number[], val: number) {\n//   let low = 0,\n//     high = arr.length;\n//   while (low < high) {\n//     const mid = (low + high) >>> 1;\n//     const x = arr[mid];\n//     if (x === val) return;\n//     if (x < val) {\n//       low = mid + 1;\n//     } else {\n//       high = mid;\n//     }\n//   }\n//   arr.splice(low, 0, val);\n// }\n\nclass PluginManager {\n    constructor(plugins) {\n        this.plugins = plugins;\n        this.plugins.push({\n            name: 'builtIn',\n            load: async (ctx, id) => {\n                const uri = Uri.parse(id);\n                const readReturn = ctx.resolver.readFileContent(uri);\n                const readResult = isThenable(readReturn)\n                    ? await checkCancellation(readReturn, ctx.token)\n                    : readReturn;\n                return {\n                    code: ctx.resolver.decode(readResult.content),\n                    visited: readResult.visited,\n                };\n            },\n            resolveDependency: async (ctx, dependency, fromSourceModule) => {\n                const resolveReturn = ctx.resolver.resolve(dependency.spec, fromSourceModule.uri);\n                const resolveResult = isThenable(resolveReturn)\n                    ? await checkCancellation(resolveReturn, ctx.token)\n                    : resolveReturn;\n                if (!resolveResult.found) {\n                    throw new DependencyNotFoundError(dependency.spec, fromSourceModule);\n                }\n                if (!resolveResult.uri) {\n                    // TODO: Inject empty module\n                    throw new EntryExcludedError(dependency.spec);\n                }\n                return {\n                    uri: resolveResult.uri,\n                    rootUri: resolveResult.rootUri,\n                    visited: resolveResult.visited,\n                };\n            },\n            resolveEntrypoint: async (ctx, uri) => {\n                const resolveResult = await ctx.resolver.resolve(uri);\n                if (!resolveResult.found) {\n                    throw new EntryNotFoundError(`Entry point not found: ${uri}`);\n                }\n                if (!resolveResult.uri) {\n                    throw new EntryExcludedError(uri);\n                }\n                return resolveResult;\n            },\n            transform: async ({ createMagicString }, id) => {\n                if (id.path.endsWith('.json')) {\n                    const magicString = createMagicString();\n                    magicString.prepend('module.exports = ');\n                    return {\n                        code: magicString.toString(),\n                        sourceMap: magicString.generateDecodedMap(),\n                    };\n                }\n            },\n        });\n    }\n    async executeLoad(ctx, uri) {\n        for (const plugin of this.plugins) {\n            if (typeof plugin.load === 'function') {\n                const loadReturn = plugin.load(ctx, uri.toString());\n                const loadResult = isThenable(loadReturn)\n                    ? await checkCancellation(loadReturn, ctx.token)\n                    : loadReturn;\n                if (!loadResult) {\n                    continue;\n                }\n                return {\n                    code: loadResult.code,\n                    visited: loadResult.visited || [],\n                };\n            }\n        }\n        throw new Error(`No plugin was found that was able to load the uri ${uri.toString()}`);\n    }\n    async executeResolveDependency(ctx, dependency, fromModule) {\n        for (const plugin of this.plugins) {\n            if (typeof plugin.resolveDependency === 'function') {\n                const loadReturn = plugin.resolveDependency(ctx, dependency, fromModule);\n                const loadResult = isThenable(loadReturn)\n                    ? await checkCancellation(loadReturn, ctx.token)\n                    : loadReturn;\n                if (!loadResult) {\n                    continue;\n                }\n                return {\n                    uri: loadResult.uri,\n                    rootUri: loadResult.rootUri,\n                    visited: loadResult.visited || [],\n                };\n            }\n        }\n        throw new Error(`No plugin was able to resolve the '${dependency.kind}' dependency, '${dependency.spec}' from '${fromModule.href}'`);\n    }\n    async executeResolveEntrypoint(ctx, uri) {\n        for (const plugin of this.plugins) {\n            if (typeof plugin.resolveEntrypoint === 'function') {\n                const loadReturn = plugin.resolveEntrypoint(ctx, uri);\n                const loadResult = isThenable(loadReturn)\n                    ? await checkCancellation(loadReturn, ctx.token)\n                    : loadReturn;\n                if (!loadResult) {\n                    continue;\n                }\n                return {\n                    uri: loadResult.uri,\n                    rootUri: loadResult.rootUri,\n                    visited: loadResult.visited || [],\n                };\n            }\n        }\n        throw new Error(`No plugin was able to resolve the entrypoint '${uri.toString()}'`);\n    }\n    async executeTransform(ctx, uri, code) {\n        if (typeof code !== 'string') {\n            code = ctx.resolver.decode(code);\n        }\n        const pluginCtx = Object.assign(ctx, {\n            createMagicString() {\n                return new MagicString(code);\n            },\n        });\n        let sourceMapTree = new Source(uri.toString(), code);\n        // Figure out if our original code, itself has a sourcemap.\n        // For now, we will not recurse beyond that depth.\n        const sourceMapRef = getSourceMappingUrl(code);\n        if (sourceMapRef) {\n            let sourceMap = decodeDataUriAsSourceMap(sourceMapRef);\n            if (!sourceMap) {\n                const sourceMapUri = Uri.joinPath(uri, `../${sourceMapRef}`);\n                code = updateSourceMappingUrl(code, sourceMapUri.toString());\n            }\n            if (sourceMap) {\n                const sources = sourceMap.sources;\n                const sourcesContent = sourceMap.sourcesContent || [];\n                const baseSources = [];\n                for (const idx in sources) {\n                    if (sources[idx] && sourcesContent[idx]) {\n                        baseSources.push(new Source(sources[idx], sourcesContent[idx]));\n                    }\n                }\n                sourceMapTree = new Link(sourceMap, baseSources);\n            }\n        }\n        const visited = [];\n        for (const plugin of this.plugins) {\n            if (typeof plugin.transform === 'function') {\n                const transformReturn = plugin.transform(pluginCtx, uri, code);\n                const transformResult = isThenable(transformReturn)\n                    ? await checkCancellation(transformReturn, ctx.token)\n                    : transformReturn;\n                if (transformResult === null || transformResult === undefined) {\n                    continue;\n                }\n                if (transformResult.sourceMap) {\n                    sourceMapTree = new Link(transformResult.sourceMap, [sourceMapTree]);\n                }\n                code = transformResult.code;\n                if (transformResult.visited) {\n                    visited.push(...transformResult.visited);\n                }\n            }\n        }\n        return {\n            code,\n            sourceMapTree,\n            visited,\n        };\n    }\n}\n\nvar SourceModuleDependencyKind;\n(function (SourceModuleDependencyKind) {\n    SourceModuleDependencyKind[\"Entrypoint\"] = \"Entrypoint\";\n    SourceModuleDependencyKind[\"Require\"] = \"Require\";\n    SourceModuleDependencyKind[\"RequireResolve\"] = \"RequireResolve\";\n    SourceModuleDependencyKind[\"GlobalObject\"] = \"GlobalObject\";\n})(SourceModuleDependencyKind || (SourceModuleDependencyKind = {}));\nclass SourceModuleDependency {\n    constructor(kind, spec, locations, options = {}) {\n        this.kind = kind;\n        this.spec = spec;\n        this.locations = locations;\n        this.options = options;\n    }\n    static areIdentical(l, r) {\n        return l.kind === r.kind && l.spec === r.spec;\n    }\n    static fromEntrypoint(uri) {\n        return new SourceModuleDependency(SourceModuleDependencyKind.Entrypoint, uri.toString(), []);\n    }\n    static fromGlobalObject(spec, locations, exportName) {\n        return new SourceModuleDependency(SourceModuleDependencyKind.GlobalObject, spec, locations, {\n            exportName,\n        });\n    }\n    static fromRequire(spec, locations) {\n        return new SourceModuleDependency(SourceModuleDependencyKind.Require, spec, locations);\n    }\n    static fromRequireResolve(spec, locations) {\n        return new SourceModuleDependency(SourceModuleDependencyKind.RequireResolve, spec, locations);\n    }\n}\n\nfunction isArrowFunctionExpression(node) {\n    return node.type === 'ArrowFunctionExpression';\n}\nfunction isArrayPattern(node) {\n    return node.type === 'ArrayPattern';\n}\nfunction isAssignmentPattern(node) {\n    return node.type === 'AssignmentPattern';\n}\nfunction isBinaryExpression(node) {\n    return node.type === 'BinaryExpression';\n}\nfunction isBlockStatement(node) {\n    return node.type === 'BlockStatement';\n}\nfunction isCallExpression(node) {\n    return node.type === 'CallExpression';\n}\nfunction isClassDeclaration(node) {\n    return node.type === 'ClassDeclaration';\n}\nfunction isFunctionDeclaration(node) {\n    return node.type === 'FunctionDeclaration';\n}\nfunction isFunctionExpression(node) {\n    return node.type === 'FunctionExpression';\n}\nfunction isIdentifier(node) {\n    return node.type === 'Identifier';\n}\nfunction isIfStatement(node) {\n    return node.type === 'IfStatement';\n}\nfunction isLiteral(node) {\n    return node.type === 'Literal';\n}\nfunction isMemberExpression(node) {\n    return node.type === 'MemberExpression';\n}\nfunction isObjectPattern(node) {\n    return node.type === 'ObjectPattern';\n}\nfunction isProperty(node) {\n    return node.type === 'Property';\n}\nfunction isRestElement(node) {\n    return node.type === 'RestElement';\n}\nfunction isProgram(node) {\n    return node.type === 'Program';\n}\nfunction isThisExpression(node) {\n    return node.type === 'ThisExpression';\n}\nfunction isTryStatement(node) {\n    return node.type === 'TryStatement';\n}\nfunction isVariableDeclaration(node) {\n    return node.type === 'VariableDeclaration';\n}\n// Refinements or groups\nfunction isFunction(node) {\n    return (isFunctionDeclaration(node) || isFunctionExpression(node) || isArrowFunctionExpression(node));\n}\nfunction isStringLiteral(node) {\n    return isLiteral(node) && typeof node.value === 'string';\n}\nfunction parse(code, options) {\n    return parse$2(code, {\n        ...options,\n        allowReturnOutsideFunction: true,\n        sourceType: 'script',\n    });\n}\n\nfunction traverse(ast, ctx, { enter, leave }) {\n    visit(ast, null, ctx, enter, leave);\n}\nlet shouldSkip = false;\nconst context = { skip: () => (shouldSkip = true) };\nconst childKeys = {};\nfunction visit(node, parent, ctx, enter, leave\n// prop?: string,\n// index?: number\n) {\n    if (!node)\n        return;\n    node.parent = parent;\n    if (enter) {\n        const _shouldSkip = shouldSkip;\n        shouldSkip = false;\n        enter.call(context, node, parent, ctx);\n        const skipped = shouldSkip;\n        shouldSkip = _shouldSkip;\n        if (skipped)\n            return;\n    }\n    const keys = childKeys[node.type] ||\n        (childKeys[node.type] = Object.keys(node).filter((key) => key !== 'parent' && typeof node[key] === 'object'));\n    const children = [];\n    for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        const value = node[key];\n        if (Array.isArray(value)) {\n            children.push(...value);\n            // for (let j = 0; j < value.length; j++) {\n            //   visit(value[j], node, ctx, enter, leave);\n            // }\n        }\n        else if (value && value.type) {\n            children.push(value);\n        }\n    }\n    children.sort((a, b) => a.start - b.start);\n    for (const child of children) {\n        visit(child, node, ctx, enter, leave);\n    }\n    if (leave) {\n        leave(node, parent, ctx);\n    }\n}\n\nconst parse$1 = function parseJavaScript(uri, code, options) {\n    const visitorCtx = {\n        unboundSymbols: new Map(),\n        locals: new Map(),\n        magicString: new MagicString(code, { filename: uri.toString(), indentExclusionRanges: [] }),\n        nodeEnv: options.nodeEnv,\n        replacedSymbols: new Set(),\n        requires: [],\n        requireResolves: [],\n        skip: new Set(),\n        skipTransform: new Set(),\n    };\n    const dependencies = [];\n    try {\n        // let lastToken: Token | undefined;\n        const ast = parse(code, {\n        // onComment: (_isBlock, _test, start, end) => {\n        //   result.changes.push({ type: 'remove', start, end });\n        // },\n        // onInsertedSemicolon(lastTokEnd) {\n        //   result.changes.push({ type: 'appendRight', position: lastTokEnd, value: ';' });\n        // },\n        // onToken: (token) => {\n        //   const start = lastToken ? lastToken.end + 1 : 0;\n        //   const end = token.start;\n        //   if (end > start) {\n        //     result.changes.push({ type: 'remove', start, end });\n        //   }\n        //   lastToken = token;\n        // },\n        });\n        traverse(ast, visitorCtx, scopingAndRequiresVisitor);\n        traverse(ast, visitorCtx, collectGlobalsVisitor);\n    }\n    catch (err) {\n        // console.log(code);\n        throw new Error(`Error parsing ${uri}: ${err.message}`);\n    }\n    // Handle explicit requires\n    const requiresBySpec = new Map();\n    for (const requireDependency of visitorCtx.requires) {\n        let locations = requiresBySpec.get(requireDependency.spec.value);\n        if (!locations) {\n            locations = [];\n            requiresBySpec.set(requireDependency.spec.value, locations);\n        }\n        locations.push({ start: requireDependency.spec.start, end: requireDependency.spec.end });\n    }\n    for (const [spec, locations] of requiresBySpec) {\n        dependencies.push(SourceModuleDependency.fromRequire(spec, locations));\n    }\n    // Handle require.resolve\n    const requireResolvesBySpec = new Map();\n    for (const requireDependency of visitorCtx.requireResolves) {\n        let locations = requiresBySpec.get(requireDependency.spec.value);\n        if (!locations) {\n            locations = [];\n            requiresBySpec.set(requireDependency.spec.value, locations);\n        }\n        locations.push({ start: requireDependency.spec.start, end: requireDependency.spec.end });\n    }\n    for (const [spec, locations] of requireResolvesBySpec) {\n        dependencies.push(SourceModuleDependency.fromRequireResolve(spec, locations));\n    }\n    for (const [symbolName, locations] of visitorCtx.unboundSymbols) {\n        const shim = options.globalModules[symbolName];\n        if (shim) {\n            dependencies.push(SourceModuleDependency.fromGlobalObject(shim.spec, locations, shim.export));\n            for (const location of locations) {\n                visitorCtx.magicString.overwrite(location.start, location.end, `require(${JSON.stringify(`${shim.spec}`)})`);\n            }\n        }\n    }\n    return {\n        code: visitorCtx.magicString,\n        dependencies,\n    };\n};\nconst scopingAndRequiresVisitor = {\n    enter(node, parent, ctx) {\n        // Get AST-node level locations in the source map\n        ctx.magicString.addSourcemapLocation(node.start);\n        ctx.magicString.addSourcemapLocation(node.end);\n        if (ctx.skip.has(node)) {\n            return this.skip();\n        }\n        visitAndCaptureScoping(node, parent, ctx);\n        visitAndSkipBranches(node, parent, ctx);\n        visitRequires(node, parent, ctx);\n    },\n    leave(node, _parent, ctx) {\n        let skipped = false;\n        let nextCheck = node;\n        while (nextCheck) {\n            if (ctx.skipTransform.has(nextCheck)) {\n                skipped = true;\n                break;\n            }\n            nextCheck = nextCheck.parent;\n        }\n        if (!skipped &&\n            isMemberExpression(node) &&\n            memberExpressionMatches(node, 'process.env.NODE_ENV')) {\n            ctx.magicString.overwrite(node.start, node.end, JSON.stringify(ctx.nodeEnv), {\n                contentOnly: true,\n                storeName: true,\n            });\n            ctx.skip.add(node);\n            ctx.skipTransform.add(node);\n        }\n    },\n};\nconst collectGlobalsVisitor = {\n    enter(node, _parent, ctx) {\n        if (ctx.skip.has(node)) {\n            return this.skip();\n        }\n        if (isBindingIdentifier(node) && isIdentifier(node)) {\n            var name = node.name;\n            if (name === 'undefined')\n                return;\n            if (ctx.replacedSymbols.has(node)) {\n                return;\n            }\n            let foundBinding = false;\n            let nextParent = node.parent;\n            while (nextParent) {\n                if (name === 'arguments' && declaresArguments(nextParent)) {\n                    foundBinding = true;\n                    break;\n                }\n                const locals = ctx.locals.get(nextParent);\n                if (locals && locals[name]) {\n                    foundBinding = true;\n                    break;\n                }\n                nextParent = nextParent.parent;\n            }\n            if (!foundBinding) {\n                let unboundSymbols = ctx.unboundSymbols.get(name);\n                if (!unboundSymbols) {\n                    unboundSymbols = [];\n                    ctx.unboundSymbols.set(name, unboundSymbols);\n                }\n                unboundSymbols.push(node);\n            }\n        }\n        else if (isThisExpression(node)) {\n            let foundBinding = false;\n            let nextParent = node.parent;\n            while (nextParent) {\n                if (declaresThis(nextParent)) {\n                    foundBinding = true;\n                    break;\n                }\n                nextParent = nextParent.parent;\n            }\n            if (!foundBinding) {\n                let unboundSymbols = ctx.unboundSymbols.get('this');\n                if (!unboundSymbols) {\n                    unboundSymbols = [];\n                    ctx.unboundSymbols.set('this', unboundSymbols);\n                }\n                unboundSymbols.push(node);\n            }\n        }\n    },\n};\nfunction visitAndCaptureScoping(node, _parent, ctx) {\n    if (isVariableDeclaration(node)) {\n        let parent;\n        let nextParent = node.parent;\n        while (nextParent) {\n            if (node.kind === 'var' ? isScope(nextParent) : isBlockScope(nextParent)) {\n                parent = nextParent;\n                break;\n            }\n            nextParent = nextParent.parent;\n        }\n        if (!parent) {\n            throw new Error(`Invariant violation: Failed to find a parent`);\n        }\n        let locals = ctx.locals.get(parent);\n        if (!locals) {\n            locals = {};\n            ctx.locals.set(parent, locals);\n        }\n        for (const declaration of node.declarations) {\n            declarePattern(declaration.id, locals);\n        }\n    }\n    else if (isFunctionDeclaration(node)) {\n        let parent;\n        let nextParent = node.parent;\n        if (nextParent && nextParent.parent) {\n            nextParent = nextParent.parent;\n        }\n        while (nextParent) {\n            if (isScope(nextParent)) {\n                parent = nextParent;\n                break;\n            }\n            nextParent = nextParent.parent;\n        }\n        if (!parent) {\n            throw new Error(`Invariant violation: Failed to find a parent`);\n        }\n        let locals = ctx.locals.get(parent);\n        if (!locals) {\n            locals = {};\n            ctx.locals.set(parent, locals);\n        }\n        declareFunction(node, locals);\n    }\n    else if (isFunction(node)) {\n        let locals = ctx.locals.get(node);\n        if (!locals) {\n            locals = {};\n            ctx.locals.set(node, locals);\n        }\n        declareFunction(node, locals);\n    }\n    else if (isClassDeclaration(node) && node.id) {\n        let parent;\n        let nextParent = node.parent;\n        if (nextParent && nextParent.parent) {\n            nextParent = nextParent.parent;\n        }\n        while (nextParent) {\n            if (isScope(nextParent)) {\n                parent = nextParent;\n                break;\n            }\n            nextParent = nextParent.parent;\n        }\n        if (!parent) {\n            throw new Error(`Invariant violation: Failed to find a parent`);\n        }\n        let locals = ctx.locals.get(parent);\n        if (!locals) {\n            locals = {};\n            ctx.locals.set(parent, locals);\n        }\n        locals[node.id.name] = true;\n    }\n    else if (isTryStatement(node)) {\n        if (node.handler) {\n            let locals = ctx.locals.get(node.handler);\n            if (!locals) {\n                locals = {};\n                ctx.locals.set(node.handler, locals);\n            }\n            if (node.handler.param) {\n                declarePattern(node.handler.param, locals);\n            }\n        }\n    }\n}\nfunction visitAndSkipBranches(node, _parent, ctx) {\n    if (isIfStatement(node) && isBinaryExpression(node.test)) {\n        const tests = {\n            '!=': (l, r) => l != r,\n            '!==': (l, r) => l !== r,\n            '==': (l, r) => l == r,\n            '===': (l, r) => l === r,\n        };\n        const test = tests[node.test.operator];\n        if (test) {\n            if (isStringLiteral(node.test.left) &&\n                isMemberExpression(node.test.right) &&\n                memberExpressionMatches(node.test.right, 'process.env.NODE_ENV')) {\n                let rootObject = node.test.right;\n                while (isMemberExpression(rootObject.object)) {\n                    rootObject = rootObject.object;\n                }\n                if (isIdentifier(rootObject.object)) {\n                    ctx.replacedSymbols.add(rootObject.object);\n                }\n                ctx.skipTransform.add(node.test.right);\n                // if ('development' === process.env.NODE_ENV) {}\n                if (!test(node.test.left.value, ctx.nodeEnv)) {\n                    ctx.skip.add(node.consequent);\n                    // We can blow away the consequent\n                    ctx.magicString.remove(node.start, node.alternate ? node.alternate.start : node.consequent.end);\n                }\n                else {\n                    // We can blow away the test\n                    ctx.magicString.remove(node.start, node.consequent.start - 1);\n                    if (node.alternate) {\n                        ctx.skip.add(node.alternate);\n                        // We can blow away the alternate but we need to start and the end of the consequent + 1 char\n                        ctx.magicString.remove(node.consequent.end + 1, node.alternate.end);\n                    }\n                }\n            }\n            else if (isStringLiteral(node.test.right) &&\n                isMemberExpression(node.test.left) &&\n                memberExpressionMatches(node.test.left, 'process.env.NODE_ENV')) {\n                let rootObject = node.test.left;\n                while (isMemberExpression(rootObject.object)) {\n                    rootObject = rootObject.object;\n                }\n                if (isIdentifier(rootObject.object)) {\n                    ctx.replacedSymbols.add(rootObject.object);\n                }\n                ctx.skipTransform.add(node.test.left);\n                // if (process.env.NODE_ENV === 'development') {}\n                if (!test(node.test.right.value, ctx.nodeEnv)) {\n                    ctx.skip.add(node.consequent);\n                    // We can blow away the consequent\n                    ctx.magicString.remove(node.start, node.alternate ? node.alternate.start : node.consequent.end);\n                }\n                else {\n                    // We can blow away the test and the alternate\n                    ctx.magicString.remove(node.start, node.consequent.start - 1);\n                    if (node.alternate) {\n                        ctx.skip.add(node.alternate);\n                        // We can blow away the alternate but we need to start and the end of the consequent + 1 char\n                        ctx.magicString.remove(node.consequent.end + 1, node.alternate.end);\n                    }\n                }\n            }\n        }\n    }\n}\nfunction visitRequires(node, _parent, ctx) {\n    if (isCallExpression(node)) {\n        const callee = node.callee;\n        if (isIdentifier(callee) && callee.name === 'require') {\n            const firstArg = node.arguments[0];\n            if (isStringLiteral(firstArg)) {\n                ctx.requires.push({\n                    spec: { start: firstArg.start, end: firstArg.end, value: firstArg.value },\n                    callee: { start: callee.start, end: callee.end },\n                });\n            }\n            else {\n                console.warn('Non string-literal first arg to require', firstArg);\n            }\n        }\n        else if (isMemberExpression(callee) &&\n            isIdentifier(callee.object) &&\n            callee.object.name === 'require' &&\n            isIdentifier(callee.property) &&\n            callee.property.name === 'resolve') {\n            const firstArg = node.arguments[0];\n            if (isStringLiteral(firstArg)) {\n                ctx.requireResolves.push({\n                    spec: { start: firstArg.start, end: firstArg.end, value: firstArg.value },\n                    callee: { start: callee.start, end: callee.end },\n                });\n            }\n            else {\n                console.warn('Non string-literal first arg to require.resolve', firstArg);\n            }\n        }\n    }\n}\nfunction declareFunction(node, locals) {\n    node.params.forEach(function (node) {\n        declarePattern(node, locals);\n    });\n    if (node.id) {\n        locals[node.id.name] = true;\n    }\n}\nfunction declarePattern(node, locals) {\n    if (isIdentifier(node)) {\n        locals[node.name] = true;\n    }\n    else if (isObjectPattern(node)) {\n        node.properties.forEach((node) => isRestElement(node)\n            ? declarePattern(node.argument, locals)\n            : declarePattern(node.value, locals));\n    }\n    else if (isArrayPattern(node)) {\n        node.elements.forEach((node) => node && declarePattern(node, locals));\n    }\n    else if (isRestElement(node)) {\n        declarePattern(node.argument, locals);\n    }\n    else if (isAssignmentPattern(node)) {\n        declarePattern(node.left, locals);\n    }\n    else {\n        throw new Error(`Invariant violation: Unexpected pattern type: ${node.type}`);\n    }\n}\nfunction isBindingIdentifier(node) {\n    return isIdentifier(node) && !isPropertyOfMemberExpression(node) && !isKeyOfProperty(node);\n}\nfunction isKeyOfProperty(node) {\n    return node.parent && isProperty(node.parent) && node.parent.key === node;\n}\nfunction isPropertyOfMemberExpression(node) {\n    return node.parent && isMemberExpression(node.parent) && node.parent.object !== node;\n}\nfunction isScope(node) {\n    return (isFunctionDeclaration(node) ||\n        isFunctionExpression(node) ||\n        isArrowFunctionExpression(node) ||\n        isProgram(node));\n}\nfunction isBlockScope(node) {\n    return isBlockStatement(node) || isScope(node);\n}\nfunction declaresArguments(node) {\n    return isFunctionDeclaration(node) || isFunctionExpression(node);\n}\nfunction declaresThis(node) {\n    return isFunctionDeclaration(node) || isFunctionExpression(node);\n}\nfunction memberExpressionMatches(node, pattern) {\n    const memberParts = pattern.split('.');\n    if (memberParts.length < 2) {\n        return false;\n    }\n    const object = memberParts.shift();\n    const property = memberParts.shift();\n    for (let i = memberParts.length - 1; i >= 0; i--) {\n        if (!isIdentifier(node.property) || node.property.name !== memberParts[i]) {\n            return false;\n        }\n        if (!isMemberExpression(node.object)) {\n            return false;\n        }\n        node = node.object;\n    }\n    if (!isIdentifier(node.object) || !isIdentifier(node.property)) {\n        return false;\n    }\n    return node.object.name === object && node.property.name === property;\n}\n\n//@ts-check\n/**\n * @param {import('./types').VelcroStaticRuntime} velcro\n * @returns {import('./runtimeInterface').VelcroRuntime}\n */\nfunction createRuntime(velcro) {\n    if (velcro.runtime)\n        return velcro.runtime;\n    class Module {\n        /**\n         * @param {Runtime} runtime\n         * @param {string} id\n         * @param {import('./types').VelcroImportMap} importMap\n         */\n        constructor(runtime, id, importMap) {\n            this.runtime = runtime;\n            this.id = id;\n            this.importMap = importMap;\n            this.module = { exports: {} };\n            this.require = runtime.createRequire(this);\n        }\n    }\n    class Runtime {\n        /**\n         *\n         * @param {import('./types').VelcroStaticRuntime} velcro\n         */\n        constructor(velcro) {\n            /** @type {Required<import('./types').VelcroImportMap>} */\n            this.importMap = { imports: {}, scopes: {} };\n            this.defs = velcro.defs;\n            /** @type {Record<string, Module | undefined>} */\n            this.modules = Object.create(null);\n            this.root = new Module(this, 'velcro:/root', {});\n            this.require = this.createRequire(this.root);\n            /** @type {Record<string, Module[] | undefined>} */\n            this.dependents = Object.create(null);\n        }\n        /**\n         *\n         * @param {Module} fromModule\n         */\n        createRequire(fromModule) {\n            var runtime = this;\n            /**\n             *\n             * @param {string} spec\n             */\n            function require(spec) {\n                var id = runtime.resolveSpecAgainstImportMap(spec, fromModule);\n                var module = runtime.modules[id];\n                if (!module) {\n                    var moduleDefinition = runtime.defs[id];\n                    if (!moduleDefinition) {\n                        throw new Error(`Unable to locate module '${id}' from '${fromModule.id}`);\n                    }\n                    var [factory, importMap] = moduleDefinition;\n                    module = new Module(runtime, id, importMap);\n                    runtime.modules[id] = module;\n                    var specParts = id.split('/');\n                    var __filename = specParts.pop() || spec;\n                    var __dirname = specParts.join('/');\n                    factory.call(module.module.exports, module.module, module.module.exports, module.require.bind(module), __dirname, __filename);\n                }\n                (runtime.dependents[id] = runtime.dependents[id] || []).push(fromModule);\n                return module.module.exports;\n            }\n            /**\n             *\n             * @param {string} _spec\n             */\n            function resolve(_spec) {\n                return '';\n            }\n            return Object.assign(require, {\n                resolve,\n            });\n        }\n        /**\n         * Inject a pre-existing module\n         *\n         * @template T\n         * @param {string} id Identifier of module\n         * @param {T} exports Value that represents the exported interface of the module\n         */\n        inject(id, exports) {\n            var module = new Module(this, id, Object.create(null));\n            module.module.exports = exports;\n            this.modules[id] = module;\n            return module;\n        }\n        /**\n         *\n         * @param {string[]} invalidations\n         */\n        invalidate(invalidations) {\n            var queue = invalidations.slice();\n            while (queue.length) {\n                var id = queue.shift();\n                //@ts-expect-error\n                var deleted = delete this.modules[id];\n                /** @type {Module[] | undefined} */\n                //@ts-expect-error\n                var dependents = this.dependents[id];\n                if (!Array.isArray(dependents))\n                    continue;\n                dependents.forEach((dependent) => {\n                    queue.push(dependent.id);\n                });\n            }\n        }\n        /**\n         *\n         * @param {string} spec\n         * @param {Module} module\n         * @private\n         */\n        resolveSpecAgainstImportMap(spec, module) {\n            var importMap = module.importMap;\n            if (!importMap.scopes) {\n                return spec;\n            }\n            var scopesForId = importMap.scopes[module.id];\n            if (!scopesForId) {\n                return spec;\n            }\n            var mappedId = scopesForId[spec];\n            if (mappedId) {\n                return mappedId;\n            }\n            return spec;\n        }\n    }\n    var runtime = new Runtime(velcro);\n    velcro.runtime = runtime;\n    return runtime;\n}\n\nclass ChunkOutput {\n    constructor(bundle, sourceModules, uri) {\n        this.bundle = bundle;\n        this.sourceModules = sourceModules;\n        this.uri = uri;\n    }\n    get code() {\n        if (typeof this.cachedCode === 'undefined') {\n            this.cachedCode = this.bundle.toString();\n        }\n        return this.cachedCode;\n    }\n    get href() {\n        return this.uri.toString();\n    }\n    get sourceMap() {\n        if (typeof this.cachedSourceMap === 'undefined') {\n            this.cachedSourceMap = this.generateSourceMap();\n        }\n        return this.cachedSourceMap;\n    }\n    get sourceMapString() {\n        if (typeof this.cachedSourceMapString === 'undefined') {\n            this.cachedSourceMapString = this.sourceMap.toString();\n        }\n        return this.cachedSourceMapString;\n    }\n    get sourceMapDataUri() {\n        if (typeof this.cachedSourceMapDataUri === 'undefined') {\n            this.cachedSourceMapDataUri = this.sourceMap.toDataUri();\n        }\n        return this.cachedSourceMapDataUri;\n    }\n    generateSourceMap() {\n        const inputMap = this.bundle.generateDecodedMap({\n            includeContent: false,\n            hires: true,\n            source: this.href,\n        });\n        const sourceMapTree = new Link(inputMap, inputMap.sources.map((sourceHref) => {\n            const sourceModule = this.sourceModules.get(sourceHref);\n            if (!sourceModule) {\n                return new Source(sourceHref, 'SOURCEMAP ERROR');\n            }\n            // All of the transformations included in the source module's magicString\n            // were baked into the bundle already. We just need to map these into any\n            // earlier sources.\n            return sourceModule.sourceMapsTree;\n        }));\n        const sourceMapTreeMappings = sourceMapTree.traceMappings();\n        if (sourceMapTreeMappings instanceof Error) {\n            return new SourceMap({\n                file: inputMap.file,\n                mappings: '',\n                names: [],\n                sources: [],\n                version: 3,\n                sourcesContent: [],\n            });\n        }\n        // Loop through generated mappings, removing mappings that are character-by-character increments\n        // from the previous mapping. Since we generated a hires bundle, this will shrink the resolution\n        // back down to something not unnecessarily large.\n        // for (const line of sourceMapTreeMappings.mappings) {\n        //   let lastSegment: SourceMapSegment | null = null;\n        //   const shrinkedLine: SourceMapSegment[] = [];\n        //   for (const segment of line) {\n        //     if (lastSegment && lastSegment.length >= 4 && lastSegment.length === segment.length) {\n        //       // We will only push the segment if it is not, effectively a direct cursor move of the\n        //       // last one.\n        //       // For example:\n        //       //   lastSegment = [1, 0, 0, 1] // Generated column 1, original column 1 of the 0th file, 0th line\n        //       //   segment = [2, 0, 0, 2] // Generated column 2, original column 2 of the 0th file, 0th line\n        //       // Given that, we can see that this segment is not adding any _new_ information so we can skip it.\n        //       if (\n        //         lastSegment.length >= 4 &&\n        //         (lastSegment[0] + 1 !== segment[0] ||\n        //           lastSegment[1] !== segment[1] ||\n        //           lastSegment[2] !== segment[2] ||\n        //           lastSegment[3]! + 1 !== segment[3] ||\n        //           lastSegment[4] !== segment[4])\n        //       ) {\n        //         shrinkedLine.push(segment);\n        //       }\n        //     } else {\n        //       shrinkedLine.push(segment);\n        //     }\n        //     lastSegment = segment;\n        //   }\n        //   // line.splice(0, line.length, ...shrinkedLine);\n        // }\n        const sourceMap = new SourceMap({\n            file: this.href,\n            mappings: encode(sourceMapTreeMappings.mappings),\n            names: sourceMapTreeMappings.names,\n            sources: sourceMapTreeMappings.sources,\n            version: 3,\n            sourcesContent: sourceMapTreeMappings.sourcesContent,\n        });\n        return sourceMap;\n    }\n}\n\nclass Chunk {\n    constructor(options) {\n        this.edgesFrom = new MapSet();\n        this.edgesTo = new MapSet();\n        this.sourceModules = new Map();\n        this.rootUri = options.rootUri;\n        for (const sourceModule of options.sourceModules) {\n            this.sourceModules.set(sourceModule.href, sourceModule);\n        }\n        for (const edge of options.edges) {\n            const fromHref = edge.fromUri.toString();\n            const toHref = edge.toUri.toString();\n            this.edgesFrom.add(fromHref, edge);\n            this.edgesTo.add(toHref, edge);\n        }\n    }\n    buildForStaticRuntime(options) {\n        // const velcroModuleFactoryParts = velcroModuleFactory\n        //   .toString()\n        //   .split(velcroModuleFactory.splitString);\n        // const velcroChunkWrapperParts = velcroChunkWrapper\n        //   .toString()\n        //   .split(velcroChunkWrapper.splitString);\n        const bundle = new Bundle({\n            separator: '\\n',\n        });\n        for (const sourceModule of this.sourceModules.values()) {\n            const moduleScopes = {};\n            const scopes = {\n                [sourceModule.href]: moduleScopes,\n            };\n            const importMap = { scopes };\n            const edgesFrom = this.edgesFrom.get(sourceModule.href);\n            if (edgesFrom) {\n                for (const edge of edgesFrom) {\n                    moduleScopes[edge.dependency.spec] = edge.toUri.toString();\n                }\n            }\n            const sourceModuleCode = sourceModule.source.clone();\n            sourceModuleCode.prepend(`velcro.defs[${JSON.stringify(sourceModule.uri.toString())}] = [function(module,exports,require,__dirname,__filename){\\n`);\n            sourceModuleCode.append(`\\n},${JSON.stringify(importMap)}];`);\n            bundle.addSource(sourceModuleCode);\n        }\n        const velcroStaticRuntime = { defs: {} };\n        bundle.prepend(`(function(velcro){\\n`);\n        bundle.prepend(`if (typeof Velcro === 'undefined') Velcro = Object.create(null);\\nif (typeof Velcro.registry === 'undefined') Velcro.registry = ${JSON.stringify(velcroStaticRuntime)};\\n`);\n        bundle.append(`\\n})(Velcro.registry);\\n`);\n        if (options && options.injectRuntime) {\n            bundle.append(`\\nVelcro.runtime = ${createRuntime.toString()}(Velcro.registry);\\n`);\n        }\n        if (options && options.invalidations) {\n            if (!options.injectRuntime) {\n                throw new Error('Setting injectRuntime to true is required when calling buildForStaticRuntime and specifying invalidations');\n            }\n            bundle.append(`\\nVelcro.runtime.invalidate(${JSON.stringify(options.invalidations)});\\n`);\n        }\n        return new ChunkOutput(bundle, this.sourceModules, this.rootUri);\n    }\n}\n\nclass Graph {\n    constructor(options) {\n        this.edgesFrom = new MapSet();\n        this.edgesTo = new MapSet();\n        this.sourceModules = new Map();\n        this.rootUri = options.rootUri;\n        for (const sourceModule of options.sourceModules) {\n            this.sourceModules.set(sourceModule.href, sourceModule);\n        }\n        for (const edge of options.edges) {\n            const fromHref = edge.fromUri.toString();\n            const toHref = edge.toUri.toString();\n            this.edgesFrom.add(fromHref, edge);\n            this.edgesTo.add(toHref, edge);\n        }\n    }\n    splitChunks() {\n        return [\n            new Chunk({\n                edges: this.edgesFrom.values(),\n                rootUri: Uri.joinPath(this.rootUri, './chunk/0.js'),\n                sourceModules: this.sourceModules.values(),\n            }),\n        ];\n    }\n}\n\nvar version = \"0.45.0\";\n\nconst DEFAULT_SHIM_GLOBALS = Object.assign(Object.create(null), {\n    Buffer: {\n        spec: `@velcro/node-libs@${version}/lib/buffer.js`,\n        export: 'Buffer',\n    },\n    global: {\n        spec: `@velcro/node-libs@${version}/lib/global.js`,\n    },\n    globalThis: {\n        spec: `@velcro/node-libs@${version}/lib/global.js`,\n    },\n    process: {\n        spec: `@velcro/node-libs@${version}/lib/process.js`,\n    },\n});\n\nclass SourceModule {\n    constructor(uri, rootUri, source, dependencies, sourceMapsTree, visits) {\n        this.uri = uri;\n        this.rootUri = rootUri;\n        this.source = source;\n        this.dependencies = dependencies;\n        this.sourceMapsTree = sourceMapsTree;\n        this.visits = visits;\n    }\n    get href() {\n        return this.uri.toString();\n    }\n    get rootHref() {\n        return this.rootUri.toString();\n    }\n}\n\nclass Build {\n    constructor(rootUri, options = {}) {\n        this.rootUri = rootUri;\n        this.disposer = new DisposableStore();\n        this.edges = new Set();\n        this.errors = [];\n        this.seen = new Set();\n        this.sourceModules = new Map();\n        this.pendingModuleOperations = new MapSet();\n        this.onCompletedEmitter = new Emitter();\n        this.onErrorEmitter = new Emitter();\n        this.onProgressEmitter = new Emitter();\n        this.done = new Promise((resolve, reject) => {\n            this.disposer.add(this.onCompleted(({ graph }) => resolve(graph)));\n            this.disposer.add(this.onError(({ error }) => reject(error)));\n        });\n        this.tokenSource = new CancellationTokenSource(options.token);\n        this.disposer.add(this.tokenSource);\n    }\n    get onCompleted() {\n        return this.onCompletedEmitter.event;\n    }\n    get onError() {\n        return this.onErrorEmitter.event;\n    }\n    get onProgress() {\n        return this.onProgressEmitter.event;\n    }\n    get token() {\n        return this.tokenSource.token;\n    }\n    addEdge(edge) {\n        this.edges.add(edge);\n    }\n    addSourceModule(sourceModule) {\n        this.sourceModules.set(sourceModule.href, sourceModule);\n    }\n    cancel() {\n        this.tokenSource.cancel();\n    }\n    dispose() {\n        this.cancel();\n        this.disposer.dispose();\n    }\n    hasSourceModule(href) {\n        return this.sourceModules.has(href);\n    }\n    runAsync(key, fn) {\n        if (this.token.isCancellationRequested) {\n            return;\n        }\n        const onError = (err) => {\n            if (ret) {\n                this.pendingModuleOperations.delete(key, ret);\n            }\n            this.cancel();\n            if (!isCanceledError(err)) {\n                this.errors.push(err);\n                this.onErrorEmitter.fire({ error: err });\n            }\n        };\n        const onSuccess = () => {\n            this.pendingModuleOperations.delete(key, ret);\n            if (!this.pendingModuleOperations.size) {\n                this.onCompletedEmitter.fire({\n                    graph: new Graph({\n                        edges: this.edges,\n                        rootUri: this.rootUri,\n                        sourceModules: this.sourceModules.values(),\n                    }),\n                });\n            }\n            else {\n                this.onProgressEmitter.fire({\n                    progress: {\n                        completed: this.sourceModules.size,\n                        pending: this.pendingModuleOperations.size,\n                    },\n                });\n            }\n        };\n        let ret;\n        try {\n            ret = fn().then(onSuccess, onError);\n            this.pendingModuleOperations.add(key, ret);\n        }\n        catch (err) {\n            onError(err);\n        }\n    }\n}\nclass GraphBuilder {\n    constructor(options) {\n        this.edgesByDependency = new WeakMap();\n        this.edgesByInvalidation = new MapSet();\n        this.sourceModules = new Map();\n        this.sourceModulesByInvalidation = new MapSet();\n        this.resolver = options.resolver;\n        this.external = options.external;\n        this.nodeEnv = options.nodeEnv || 'development';\n        this.pluginManager = new PluginManager(options.plugins || []);\n    }\n    loadDependency(build, sourceModule, dep) {\n        if (build.seen.has(dep))\n            return;\n        build.seen.add(dep);\n        if (this.external && this.external(dep, sourceModule)) {\n            return;\n        }\n        // console.debug('loadDependency(%s, %s)', sourceModule.href, dep.spec);\n        build.runAsync(`${sourceModule.href}|${dep.spec}`, async () => {\n            const result = await this.pluginManager.executeResolveDependency({\n                nodeEnv: this.nodeEnv,\n                resolver: this.resolver,\n                token: build.token,\n            }, dep, sourceModule);\n            const edge = this.createEdge(sourceModule.uri, sourceModule.rootUri, result.uri, result.rootUri, result.visited, dep);\n            build.addEdge(edge);\n            this.loadEdge(build, edge);\n        });\n    }\n    loadEdge(build, edge) {\n        const href = edge.toUri.toString();\n        if (build.hasSourceModule(href))\n            return;\n        const existingSourceModule = this.sourceModules.get(href);\n        if (existingSourceModule) {\n            build.addSourceModule(existingSourceModule);\n            return this.visitSourceModule(build, existingSourceModule);\n        }\n        // console.debug(\n        //   'loadEdge(%s, %s, %s)',\n        //   edge.fromUri.toString(),\n        //   edge.dependency.spec,\n        //   edge.toUri.toString()\n        // );\n        build.runAsync(href, async () => {\n            // We need to check again in case another 'thread' already produced this\n            // sourceModule\n            if (build.hasSourceModule(href))\n                return;\n            const loadResult = await this.pluginManager.executeLoad({\n                nodeEnv: this.nodeEnv,\n                resolver: this.resolver,\n                token: build.token,\n            }, edge.toUri);\n            // We need to check again in case another 'thread' already produced this\n            // sourceModule\n            if (build.hasSourceModule(href))\n                return;\n            const transformResult = await this.pluginManager.executeTransform({\n                nodeEnv: this.nodeEnv,\n                resolver: this.resolver,\n                token: build.token,\n            }, edge.toUri, loadResult.code);\n            // We need to check again in case another 'thread' already produced this\n            // sourceModule\n            if (build.hasSourceModule(href))\n                return;\n            const parseResult = parse$1(edge.toUri, transformResult.code, {\n                globalModules: DEFAULT_SHIM_GLOBALS,\n                nodeEnv: this.nodeEnv,\n            });\n            const sourceModule = new SourceModule(edge.toUri, edge.toRootUri, parseResult.code, new Set(parseResult.dependencies), transformResult.sourceMapTree, [...transformResult.visited, ...loadResult.visited]);\n            build.addSourceModule(sourceModule);\n            this.sourceModules.set(sourceModule.href, sourceModule);\n            for (const visit of sourceModule.visits) {\n                this.sourceModulesByInvalidation.add(visit.uri.toString(), sourceModule);\n            }\n            this.sourceModulesByInvalidation.add(sourceModule.href, sourceModule);\n            this.visitSourceModule(build, sourceModule);\n        });\n    }\n    loadEntrypoint(build, uri) {\n        const href = uri.toString();\n        // console.debug('loadEntrypoint(%s)', href);\n        build.runAsync(href, async () => {\n            const result = await this.pluginManager.executeResolveEntrypoint({\n                nodeEnv: this.nodeEnv,\n                resolver: this.resolver,\n                token: build.token,\n            }, uri);\n            const edge = this.createEdge(build.rootUri, build.rootUri, result.uri, result.rootUri, result.visited, SourceModuleDependency.fromEntrypoint(uri));\n            this.loadEdge(build, edge);\n        });\n    }\n    visitSourceModule(build, sourceModule) {\n        if (build.seen.has(sourceModule))\n            return;\n        build.seen.add(sourceModule);\n        // console.debug('visitSourceModule(%s)', sourceModule.href);\n        for (const dep of sourceModule.dependencies) {\n            const existingEdge = this.edgesByDependency.get(dep);\n            if (existingEdge) {\n                build.addEdge(existingEdge);\n                this.loadEdge(build, existingEdge);\n            }\n            else {\n                this.loadDependency(build, sourceModule, dep);\n            }\n        }\n    }\n    build(entrypoints, options = {}) {\n        const rootUri = Uri.parse('velcro:/');\n        const build = new Build(rootUri, { token: options.token });\n        for (const uri of entrypoints) {\n            this.loadEntrypoint(build, Uri.isUri(uri) ? uri : Uri.parse(uri));\n        }\n        return build;\n    }\n    invalidate(uri) {\n        const href = Uri.isUri(uri) ? uri.toString() : uri;\n        const sourceModules = this.sourceModulesByInvalidation.get(href);\n        if (sourceModules) {\n            for (const sourceModule of sourceModules) {\n                this.sourceModules.delete(sourceModule.href);\n            }\n            this.sourceModulesByInvalidation.deleteAll(href);\n        }\n        this.sourceModules.delete(href);\n        const edges = this.edgesByInvalidation.get(href);\n        if (edges) {\n            for (const edge of edges) {\n                this.edgesByDependency.delete(edge.dependency);\n            }\n            this.edgesByInvalidation.deleteAll(href);\n        }\n        this.resolver.invalidate(uri);\n    }\n    createEdge(fromUri, fromRootUri, toUri, toRootUri, visited, dependency) {\n        const edge = { dependency, fromUri, fromRootUri, toUri, toRootUri, visited };\n        this.edgesByDependency.set(dependency, edge);\n        this.edgesByInvalidation.add(toUri.toString(), edge);\n        for (const visit of visited) {\n            this.edgesByInvalidation.add(visit.uri.toString(), edge);\n        }\n        return edge;\n    }\n}\n\nconst version$1 = VERSION;\n\nexport { Build, GraphBuildError, GraphBuilder, version$1 as version };\n//# sourceMappingURL=index.js.map\n","import styled from '@emotion/styled/macro';\nimport React, { useRef, useEffect, useContext } from 'react';\nimport { EditorManagerContext } from '../lib/EditorManager';\n\nconst Editor: React.FC<{\n  className?: string;\n}> = ({ className }) => {\n  const el = useRef<HTMLDivElement | null>(null);\n  const editorManager = useContext(EditorManagerContext);\n\n  useEffect(() => {\n    if (!el.current) {\n      return;\n    }\n\n    const editor = editorManager.mount(el.current);\n\n    return () => {\n      editor.dispose();\n    };\n  }, [editorManager, el]);\n\n  return (\n    <div className={className} ref={el}>\n      <div></div>\n    </div>\n  );\n};\n\nexport default styled(Editor)``;\n","function cssPlugin() {\n    return {\n        name: 'cssPlugin',\n        transform(ctx, uri, code) {\n            if (!uri.path.endsWith('.css')) {\n                return;\n            }\n            const cssCode = code;\n            const magicString = ctx.createMagicString();\n            const BACKSLASH = '\\\\'.charCodeAt(0);\n            const SINGLE_QUOTE = \"'\".charCodeAt(0);\n            const NL = '\\n'.charCodeAt(0);\n            const CR = '\\r'.charCodeAt(0);\n            for (let i = 0; i < cssCode.length; i++) {\n                const char = cssCode.charCodeAt(i);\n                // Escape certain characters (if not already escaped)\n                switch (char) {\n                    case CR:\n                    case NL:\n                        // Break the resulting JavaScript string across new lines\n                        // so that original css lines have a 1:1 with JavaScript lines.\n                        // This allows the resulting source-map to correct show the\n                        // original source whereas if the source had been collapsed to\n                        // a JavaScript string on a single line, all the detail is lost.\n                        magicString.overwrite(i, i + 1, \"\\\\n'\\n+'\");\n                        break;\n                    case BACKSLASH:\n                    case SINGLE_QUOTE:\n                        magicString.prependRight(i, '\\\\');\n                        break;\n                }\n            }\n            magicString.prepend(`\n        function reload(){\n          var styleTag = document.createElement(\"style\");\n          styleTag.type = \"text/css\";\n          styleTag.innerHTML = '`);\n            magicString.append(`';\n          document.head.appendChild(styleTag);\n          return {\n            dispose: function() {    \n              if (styleTag && styleTag.parentElement) {\n                styleTag.parentElement.removeChild(styleTag);\n              }\n            },\n            element: styleTag\n          };\n        };\n        var result = reload();\n        module.exports = result.element;\n        if (module.hot && module.hot.dispose) {\n          module.hot.dispose(function() {\n            result.dispose();\n          });\n        }\n      `);\n            return {\n                code: magicString.toString(),\n                sourceMap: magicString.generateDecodedMap(),\n            };\n        },\n    };\n}\n\nconst version = '0.45.1';\n\nexport { cssPlugin, version };\n//# sourceMappingURL=index.js.map\n","import { transform } from 'sucrase';\n\nfunction sucrasePlugin(options = {}) {\n    const extensions = ['js'];\n    if (options.transforms) {\n        for (const transform of options.transforms) {\n            switch (transform) {\n                case 'jsx':\n                    extensions.push('jsx');\n                    break;\n                case 'typescript':\n                    extensions.push('ts', 'tsx');\n                    break;\n            }\n        }\n    }\n    const uriTestRx = new RegExp(`\\.(?:${extensions.join('|')})$`, 'i');\n    const jsxPragmaRx = /\\/\\*\\*\\s*@jsx\\s+(\\S+)\\s*\\*+\\//;\n    const jsxFragmentPragmaRx = /\\/\\*\\*\\s*@jsxFragment\\s+(\\S+)\\s*\\*+\\//;\n    return {\n        name: 'sucrasePlugin',\n        transform(ctx, uri, code) {\n            if (!uriTestRx.test(uri.path)) {\n                return;\n            }\n            const sucraseOptions = {\n                transforms: ['imports', ...(options.transforms || [])],\n                filePath: uri.toString(),\n                production: ctx.nodeEnv === 'production',\n                sourceMapOptions: {\n                    compiledFilename: uri.toString(),\n                },\n            };\n            if (!options.jsxPragma) {\n                // If not specified try to detect the pragma\n                const jsxPragmaMatches = code.match(jsxPragmaRx);\n                if (jsxPragmaMatches) {\n                    sucraseOptions.jsxPragma = jsxPragmaMatches[1];\n                }\n            }\n            if (!options.jsxFragmentPragma) {\n                // If not specified try to detect the pragma\n                const jsxFragmentPragmaMatches = code.match(jsxFragmentPragmaRx);\n                if (jsxFragmentPragmaMatches) {\n                    sucraseOptions.jsxFragmentPragma = jsxFragmentPragmaMatches[1];\n                }\n            }\n            const result = transform(code, sucraseOptions);\n            return {\n                code: result.code,\n                sourceMap: result.sourceMap,\n            };\n        },\n    };\n}\n\nconst version = '0.45.1';\n\nexport { sucrasePlugin, version };\n//# sourceMappingURL=index.js.map\n","import { Uri, isThenable, all, EntryNotFoundError, basename, checkCancellation, parseBufferAsPackageJson } from '@velcro/common';\nimport { AbstractResolverStrategyWithRoot, ResolverStrategy, ResolverContext } from '@velcro/resolver';\nimport { validRange, satisfies } from 'semver';\n\nfunction isValidEntry(entry) {\n    if (!entry || typeof entry !== 'object')\n        return false;\n    return isValidFile(entry) || isValidDirectory(entry);\n}\nfunction isValidDirectory(entry) {\n    return (typeof entry === 'object' &&\n        entry &&\n        entry.type === ResolverStrategy.EntryKind.Directory &&\n        typeof entry.path === 'string' &&\n        entry.path &&\n        (typeof entry.files === 'undefined' ||\n            (Array.isArray(entry.files) && entry.files.every(isValidEntry))));\n}\nfunction isValidFile(entry) {\n    return (typeof entry === 'object' &&\n        entry &&\n        entry.type === ResolverStrategy.EntryKind.File &&\n        typeof entry.path === 'string' &&\n        entry.path);\n}\nfunction specToString(spec) {\n    return `${spec.spec}${spec.pathname}`;\n}\nclass JSDelivrCdn {\n    constructor() {\n        this.name = 'jsdelivr';\n        this.specRx = /^\\/((@[^/]+\\/[^/@]+|[^/@]+)(?:@([^/]+))?)(.*)?$/;\n    }\n    isValidUrl(url) {\n        return url.scheme === JSDelivrCdn.protocol || url.authority === JSDelivrCdn.host;\n    }\n    normalizePackageListing(result) {\n        if (!result || typeof result !== 'object') {\n            throw new Error(`Unexpected package listing contents`);\n        }\n        const files = result.files;\n        if (!Array.isArray(files)) {\n            throw new Error(`Unexpected package listing contents`);\n        }\n        const mapChildEntry = (parent, child) => {\n            if (!child || typeof child !== 'object') {\n                throw new Error(`Unexpected entry in package listing contents`);\n            }\n            const name = child.name;\n            if (typeof name !== 'string') {\n                throw new Error(`Unexpected entry in package listing contents`);\n            }\n            const path = `${parent}/${name}`;\n            if (child.type === ResolverStrategy.EntryKind.Directory) {\n                const files = child.files;\n                if (!Array.isArray(files)) {\n                    throw new Error(`Unexpected entry in package listing contents`);\n                }\n                return {\n                    type: ResolverStrategy.EntryKind.Directory,\n                    path,\n                    files: files.map((file) => mapChildEntry(path, file)),\n                };\n            }\n            else if (child.type === ResolverStrategy.EntryKind.File) {\n                return {\n                    type: ResolverStrategy.EntryKind.File,\n                    path,\n                };\n            }\n            throw new Error(`Error mapping child entry in package file listing`);\n        };\n        return {\n            type: ResolverStrategy.EntryKind.Directory,\n            path: '/',\n            files: files.map((file) => mapChildEntry('', file)),\n        };\n    }\n    parseUrl(url) {\n        if (Uri.isUri(url)) {\n            url = url.path;\n        }\n        const prefix = `/npm`;\n        if (!url.startsWith(prefix)) {\n            throw new Error(`Unable to parse unexpected ${this.name} url: ${url}`);\n        }\n        url = url.slice(prefix.length);\n        /**\n         * 1: scope + name + version\n         * 2: scope + name\n         * 3: version?\n         * 4: pathname\n         */\n        const matches = url.match(this.specRx);\n        if (!matches) {\n            throw new Error(`Unable to parse unexpected unpkg url: ${url}`);\n        }\n        return {\n            spec: matches[1],\n            name: matches[2],\n            version: matches[3] || '',\n            pathname: matches[4] || '',\n        };\n    }\n    urlForPackageFile(spec, pathname) {\n        return Uri.from({\n            scheme: JSDelivrCdn.protocol,\n            authority: JSDelivrCdn.host,\n            path: `/npm/${spec}${pathname}`,\n        });\n    }\n    urlForPackageList(spec) {\n        return Uri.from({\n            scheme: JSDelivrCdn.protocol,\n            authority: JSDelivrCdn.dataHost,\n            path: `/v1/package/npm/${spec}/tree`,\n        });\n    }\n}\nJSDelivrCdn.protocol = 'https';\nJSDelivrCdn.host = 'cdn.jsdelivr.net';\nJSDelivrCdn.dataHost = 'data.jsdelivr.com';\nclass UnpkgCdn {\n    constructor() {\n        this.name = 'unpkg';\n        this.UNPKG_SPEC_RX = /^\\/((@[^/]+\\/[^/@]+|[^/@]+)(?:@([^/]+))?)(.*)?$/;\n    }\n    isValidUrl(url) {\n        return url.scheme === UnpkgCdn.protocol || url.authority === UnpkgCdn.host;\n    }\n    normalizePackageListing(result) {\n        if (!isValidDirectory(result)) {\n            throw new Error(`Error normalizing directory listing`);\n        }\n        return result;\n    }\n    parseUrl(url) {\n        if (Uri.isUri(url)) {\n            url = url.path;\n        }\n        /**\n         * 1: scope + name + version\n         * 2: scope + name\n         * 3: version?\n         * 4: pathname\n         */\n        const matches = url.match(this.UNPKG_SPEC_RX);\n        if (!matches) {\n            throw new Error(`Unable to parse unexpected unpkg url: ${url}`);\n        }\n        return {\n            spec: matches[1],\n            name: matches[2],\n            version: matches[3] || '',\n            pathname: matches[4] || '',\n        };\n    }\n    urlForPackageFile(spec, pathname) {\n        return Uri.from({\n            scheme: UnpkgCdn.protocol,\n            authority: UnpkgCdn.host,\n            path: `/${spec}${pathname}`,\n        });\n    }\n    urlForPackageList(spec) {\n        return Uri.from({\n            scheme: UnpkgCdn.protocol,\n            authority: UnpkgCdn.host,\n            path: `/${spec}/`,\n            query: 'meta',\n        });\n    }\n}\nUnpkgCdn.protocol = 'https';\nUnpkgCdn.host = 'unpkg.com';\nclass CdnStrategy extends AbstractResolverStrategyWithRoot {\n    constructor(readUrlFn, cdn) {\n        super(cdn.urlForPackageFile('', ''));\n        this.contentCache = new Map();\n        this.locks = new Map();\n        this.packageEntriesCache = new Map();\n        this.packageJsonCache = new Map();\n        this.cdn = cdn;\n        this.readUrlFn = readUrlFn;\n    }\n    _withRootUriCheck(uri, fn) {\n        if (!Uri.isPrefixOf(this.rootUri, uri)) {\n            throw new Error(`This strategy is only able to handle URIs under '${this.rootUri.toString()}' and is unable to handle '${uri.toString()}'`);\n        }\n        return fn(this.rootUri);\n    }\n    async getUrlForBareModule(ctx, name, spec, path) {\n        const unresolvedUri = this.cdn.urlForPackageFile(`${name}@${spec}`, path);\n        const resolveReturn = await ctx.resolveUri(unresolvedUri);\n        return resolveReturn;\n    }\n    getCanonicalUrl(ctx, uri) {\n        return this._withRootUriCheck(uri, async () => {\n            const unresolvedSpec = this.cdn.parseUrl(uri);\n            const packageJsonReturn = ctx.runInChildContext('CdnStrategy._readPackageJsonWithCache', specToString(unresolvedSpec), (ctx) => this._readPackageJsonWithCache(ctx, unresolvedSpec));\n            const packageJson = isThenable(packageJsonReturn)\n                ? await packageJsonReturn\n                : packageJsonReturn;\n            return {\n                uri: this.cdn.urlForPackageFile(`${packageJson.name}@${packageJson.version}`, unresolvedSpec.pathname),\n            };\n        });\n        // const results = all([ctx.getRootUrl(uri), ctx.getResolveRoot(uri)], ctx.token);\n        // const [rootUriResult, resolveRootResult] = isThenable(results) ? await results : results;\n    }\n    getResolveRoot(ctx, uri) {\n        return this._withRootUriCheck(uri, async () => {\n            const unresolvedSpec = this.cdn.parseUrl(uri);\n            const packageJsonReturn = this._readPackageJsonWithCache(ctx, unresolvedSpec);\n            const packageJson = isThenable(packageJsonReturn)\n                ? await packageJsonReturn\n                : packageJsonReturn;\n            return {\n                uri: this.cdn.urlForPackageFile(`${packageJson.name}@${packageJson.version}`, '/'),\n            };\n        });\n    }\n    getRootUrl() {\n        return {\n            uri: this.cdn.urlForPackageFile('', ''),\n        };\n    }\n    listEntries(ctx, uri) {\n        return this._withRootUriCheck(uri, async () => {\n            const unresolvedSpec = this.cdn.parseUrl(uri);\n            const results = all([\n                ctx.getResolveRoot(uri),\n                this._readPackageJsonWithCache(ctx, unresolvedSpec),\n                this._readPackageEntriesWithCache(ctx, unresolvedSpec),\n            ], ctx.token);\n            const [{ uri: resolveRootUri }, packageJson, entriesReturn] = isThenable(results)\n                ? await results\n                : results;\n            const canonicalizedSpec = {\n                name: packageJson.name,\n                pathname: unresolvedSpec.pathname,\n                spec: `${packageJson.name}@${packageJson.version}`,\n                version: packageJson.version,\n            };\n            // Proactively cache the canonicalized package entries\n            this.packageEntriesCache.get(packageJson.name).set(packageJson.version, entriesReturn);\n            const traversalSegments = canonicalizedSpec.pathname.split('/').filter(Boolean);\n            let parentEntry = entriesReturn;\n            while (parentEntry && traversalSegments.length) {\n                const segment = traversalSegments.shift();\n                if (parentEntry.type !== ResolverStrategy.EntryKind.Directory || !parentEntry.files) {\n                    throw new EntryNotFoundError(uri);\n                }\n                parentEntry = parentEntry.files.find((file) => file.type === ResolverStrategy.EntryKind.Directory && basename(file.path) === segment);\n            }\n            if (!parentEntry) {\n                throw new EntryNotFoundError(uri);\n            }\n            if (!parentEntry.files) {\n                return {\n                    entries: [],\n                };\n            }\n            return {\n                entries: parentEntry.files.map((entry) => {\n                    return {\n                        type: entry.type,\n                        uri: Uri.joinPath(resolveRootUri, `.${entry.path}`),\n                    };\n                }),\n            };\n        });\n    }\n    readFileContent(ctx, uri) {\n        return this._withRootUriCheck(uri, () => {\n            const uriStr = uri.toString();\n            const cached = this.contentCache.get(uriStr);\n            if (cached === null) {\n                return Promise.reject(new EntryNotFoundError(uri));\n            }\n            if (cached) {\n                return cached;\n            }\n            ctx.recordVisit(uri, ResolverContext.VisitKind.File);\n            const readReturn = this.readUrlFn(uriStr, ctx.token);\n            if (readReturn === null) {\n                this.contentCache.set(uriStr, null);\n                return Promise.reject(new EntryNotFoundError(uri));\n            }\n            if (isThenable(readReturn)) {\n                const wrappedReturn = readReturn.then((data) => {\n                    if (data === null) {\n                        this.contentCache.delete(uriStr);\n                        return Promise.reject(new EntryNotFoundError(uri));\n                    }\n                    const entry = { content: data };\n                    this.contentCache.set(uriStr, entry);\n                    return entry;\n                });\n                this.contentCache.set(uriStr, wrappedReturn);\n                return wrappedReturn;\n            }\n            const entry = { content: readReturn };\n            this.contentCache.set(uriStr, entry);\n            return entry;\n        });\n    }\n    _readPackageEntriesWithCache(ctx, spec) {\n        ctx.debug('%s._readPackageEntriesWithCache(%s)', this.constructor.name, specToString(spec));\n        return this._withLock(`packageEntries:${spec.name}`, () => {\n            let packageEntriesCacheForModule = this.packageEntriesCache.get(spec.name);\n            if (packageEntriesCacheForModule) {\n                const exactMatch = packageEntriesCacheForModule.get(spec.version);\n                if (exactMatch) {\n                    // console.log('[HIT-EXACT] readPackageJsonWithCache(%s)', spec.spec);\n                    return exactMatch;\n                }\n                const range = validRange(spec.version);\n                if (range) {\n                    for (const [version, entries] of packageEntriesCacheForModule) {\n                        if (satisfies(version, range)) {\n                            return entries;\n                        }\n                    }\n                }\n            }\n            else {\n                packageEntriesCacheForModule = new Map();\n                this.packageEntriesCache.set(spec.name, packageEntriesCacheForModule);\n            }\n            return this._readPackageEntries(ctx, spec).then((rootDir) => {\n                packageEntriesCacheForModule.set(spec.version, rootDir);\n                return rootDir;\n            });\n        });\n    }\n    async _readPackageEntries(ctx, spec) {\n        ctx.debug('%s._readPackageEntries(%s)', this.constructor.name, specToString(spec));\n        const uri = this.cdn.urlForPackageList(spec.spec);\n        const href = uri.toString();\n        ctx.recordVisit(uri, ResolverContext.VisitKind.Directory);\n        const data = await checkCancellation(this.readUrlFn(href, ctx.token), ctx.token);\n        if (data === null) {\n            throw new EntryNotFoundError(spec);\n        }\n        const dataStr = ctx.decoder.decode(data);\n        return this.cdn.normalizePackageListing(JSON.parse(dataStr));\n    }\n    _readPackageJsonWithCache(ctx, spec) {\n        return this._withLock(`packageJson:${spec.name}`, () => {\n            let packageJsonCacheForModule = this.packageJsonCache.get(spec.name);\n            if (packageJsonCacheForModule) {\n                const exactMatch = packageJsonCacheForModule.get(spec.version);\n                if (exactMatch) {\n                    // console.log('[HIT-EXACT] readPackageJsonWithCache(%s)', spec.spec);\n                    for (const visit of exactMatch.visited) {\n                        ctx.recordVisit(visit.uri, visit.type);\n                    }\n                    return exactMatch.packageJson;\n                }\n                const range = validRange(spec.version);\n                if (range) {\n                    for (const [version, entry] of packageJsonCacheForModule) {\n                        if (satisfies(version, range)) {\n                            // console.log('[HIT] readPackageJsonWithCache(%s)', spec.spec);\n                            for (const visit of entry.visited) {\n                                ctx.recordVisit(visit.uri, visit.type);\n                            }\n                            return entry.packageJson;\n                        }\n                    }\n                }\n            }\n            else {\n                packageJsonCacheForModule = new Map();\n                this.packageJsonCache.set(spec.name, packageJsonCacheForModule);\n            }\n            return this._readPackageJson(spec, ctx).then((packageJson) => {\n                packageJsonCacheForModule.set(packageJson.version, { packageJson, visited: ctx.visited });\n                return packageJson;\n            });\n        });\n    }\n    async _readPackageJson(spec, ctx) {\n        ctx.debug('%s._readPackageJson(%s)', this.constructor.name, specToString(spec));\n        const uri = this.cdn.urlForPackageFile(spec.spec, '/package.json');\n        const contentReturn = ctx.readFileContent(uri);\n        const contentResult = isThenable(contentReturn) ? await contentReturn : contentReturn;\n        let manifest;\n        try {\n            manifest = parseBufferAsPackageJson(ctx.decoder, contentResult.content, spec.spec);\n        }\n        catch (err) {\n            throw new Error(`Error parsing manifest as json for package ${spec}: ${err.message}`);\n        }\n        // Since we know what the canonicalized version is now (we didn't until the promise resolved)\n        // and the package.json was parsed), we can proactively seed the content cache for the\n        // canonical url.\n        const canonicalHref = this.cdn\n            .urlForPackageFile(`${manifest.name}@${manifest.version}`, '/package.json')\n            .toString();\n        this.contentCache.set(canonicalHref, contentResult);\n        return manifest;\n    }\n    _withLock(lockKey, fn) {\n        const lock = this.locks.get(lockKey);\n        const runCriticalSection = () => {\n            const ret = fn();\n            if (isThenable(ret)) {\n                const locked = ret.then((result) => {\n                    this.locks.delete(lockKey);\n                    return result;\n                }, (err) => {\n                    this.locks.delete(lockKey);\n                    return Promise.reject(err);\n                });\n                this.locks.set(lockKey, locked);\n                return ret;\n            }\n            // No need to lock in non-promise\n            return ret;\n        };\n        if (isThenable(lock)) {\n            return lock.then(runCriticalSection);\n        }\n        return runCriticalSection();\n    }\n    static forJsDelivr(readUrlFn) {\n        return new CdnStrategy(readUrlFn, new JSDelivrCdn());\n    }\n    static forUnpkg(readUrlFn) {\n        return new CdnStrategy(readUrlFn, new UnpkgCdn());\n    }\n}\n\nconst version = '0.45.1';\n\nexport { CdnStrategy, version };\n//# sourceMappingURL=index.js.map\n","import { AbstractResolverStrategy } from '@velcro/resolver';\nimport { Uri } from '@velcro/common';\n\nclass CompoundStrategy extends AbstractResolverStrategy {\n    constructor(options) {\n        super();\n        this.strategies = new Set(options.strategies);\n    }\n    _delegateToStrategy(method, ctx, uri) {\n        for (const strategy of this.strategies) {\n            if (Uri.isPrefixOf(strategy.rootUri, uri)) {\n                return strategy[method](ctx, uri);\n            }\n        }\n        return Promise.reject(new Error(`No strategy found whose root is a prefix of ${uri}`));\n    }\n    getCanonicalUrl(ctx, uri) {\n        return this._delegateToStrategy('getCanonicalUrl', ctx, uri);\n    }\n    getResolveRoot(ctx, uri) {\n        return this._delegateToStrategy('getResolveRoot', ctx, uri);\n    }\n    getUrlForBareModule(ctx, name, spec, path) {\n        for (const strategy of this.strategies) {\n            if (strategy.getUrlForBareModule) {\n                return strategy.getUrlForBareModule(ctx, name, spec, path);\n            }\n        }\n        return {\n            found: false,\n            uri: null,\n        };\n    }\n    listEntries(ctx, uri) {\n        return this._delegateToStrategy('listEntries', ctx, uri);\n    }\n    readFileContent(ctx, uri) {\n        return this._delegateToStrategy('readFileContent', ctx, uri);\n    }\n}\n\nconst version = '0.45.1';\n\nexport { CompoundStrategy, version };\n//# sourceMappingURL=index.js.map\n","import { Graph, GraphBuilder } from '@velcro/bundler';\nimport { CancellationTokenSource, DisposableStore, Emitter, Event, Uri } from '@velcro/common';\nimport { cssPlugin } from '@velcro/plugin-css';\nimport { sucrasePlugin } from '@velcro/plugin-sucrase';\nimport { Resolver } from '@velcro/resolver';\nimport { CdnStrategy } from '@velcro/strategy-cdn';\nimport { CompoundStrategy } from '@velcro/strategy-compound';\nimport { MemoryStrategy } from '@velcro/strategy-memory';\nimport * as Monaco from 'monaco-editor';\n\nconst readUrl = (href: string) => fetch(href).then((res) => res.arrayBuffer());\n\ntype DefineEvent<TEventName extends string, TData = never> = {\n  eventName: TEventName;\n  data: TData;\n};\ntype AnyEvent = DefineEvent<string, unknown>;\ntype EventWithData<TEvent extends AnyEvent> = TEvent extends AnyEvent\n  ? [TEvent['data']] extends [never]\n    ? never\n    : TEvent\n  : never;\ntype EventWithoutData<TEvent extends AnyEvent> = Exclude<TEvent, EventWithData<TEvent>>;\n\ntype DefineState<TStateName extends string, TData = never> = TStateName extends string\n  ? [TData] extends [never]\n    ? {\n        stateName: TStateName;\n      }\n    : {\n        stateName: TStateName;\n        data: TData;\n      }\n  : never;\ntype AnyState = DefineState<string, unknown>;\n\ntype BuilderState =\n  | DefineState<'initial'>\n  | DefineState<'dirty'>\n  | DefineState<'waiting'>\n  | DefineState<'building', { pending: number; completed: number }>\n  | DefineState<'built', { graph: Graph; latency: number }>\n  | DefineState<'error', { error: Error; latency: number }>;\n\ntype BuilderEvent =\n  | DefineEvent<'build'>\n  | DefineEvent<'change', { uri: Uri }>\n  | DefineEvent<'timer_fired'>\n  | DefineEvent<'build_error', { error: Error; start: number }>\n  | DefineEvent<'build_progress', { pending: number; completed: number }>\n  | DefineEvent<'build_complete', { graph: Graph; start: number }>;\n\nexport class VelcroMonaco {\n  private readonly disposer = new DisposableStore();\n  private readonly fsm: {\n    states: {\n      [TStateName in BuilderState['stateName']]: {\n        onEnter?(ctx: {\n          event: BuilderEvent;\n          state: Extract<BuilderState, { stateName: TStateName }>;\n        }): void;\n        onEvent?: {\n          [TEventName in BuilderEvent['eventName']]?: (ctx: {\n            event: Extract<BuilderEvent, { eventName: TEventName }>;\n            state: Extract<BuilderState, { stateName: TStateName }>;\n          }) => void;\n        };\n        onExit?(ctx: {\n          event: BuilderEvent;\n          state: Extract<BuilderState, { stateName: TStateName }>;\n        }): void;\n      };\n    };\n  } = {\n    states: {\n      initial: {\n        onEvent: {\n          build: ({ event }) =>\n            this.transitionTo({ stateName: 'building', data: { pending: 0, completed: 0 } }, event),\n          change: ({ event }) => this.transitionTo({ stateName: 'dirty' }, event),\n        },\n      },\n      dirty: {\n        onEnter: ({ event }) => {\n          if (event.eventName === 'change') {\n            // Mark the uri as invalidated so that any source files or dependencies\n            // that relied on that uri are also invalidated.\n            this.graphBuilder.invalidate(event.data.uri);\n\n            // Also invalidate the containing directory in case some resolutions\n            // might have relied on the contents of that directory. We don't need\n            // to walk up the tree though, since only the contents of the immediate\n            // parent might have changed.\n            // const parentUri = Uri.joinPath(event.data.uri, '..');\n            // if (!Uri.equals(event.data.uri, parentUri)) {\n            //   this.graphBuilder.invalidate(Uri.ensureTrailingSlash(parentUri));\n            // }\n          }\n\n          if (this.buildConfig.autoBuild) {\n            this.transitionTo({ stateName: 'waiting' }, event);\n          }\n        },\n        onEvent: {\n          build: ({ event }) =>\n            this.transitionTo({ stateName: 'building', data: { completed: 0, pending: 0 } }, event),\n        },\n      },\n      waiting: {\n        onEnter: () => {\n          const timerHandle = setTimeout(() => {\n            this.sendEvent('timer_fired');\n          }, this.buildConfig.autoBuildWaitTimeout);\n\n          this.stateDisposer.add({\n            dispose: () => {\n              clearTimeout(timerHandle);\n            },\n          });\n        },\n        onEvent: {\n          build: ({ event }) =>\n            this.transitionTo({ stateName: 'building', data: { completed: 0, pending: 0 } }, event),\n          change: ({ event }) => this.transitionTo({ stateName: 'dirty' }, event),\n          timer_fired: ({ event }) =>\n            this.transitionTo({ stateName: 'building', data: { completed: 0, pending: 0 } }, event),\n        },\n      },\n      building: {\n        onEnter: () => {\n          const tokenSource = new CancellationTokenSource();\n          const start = Date.now();\n          const build = this.graphBuilder.build([this.localStrategy.rootUri], {\n            incremental: false,\n            token: tokenSource.token,\n          });\n\n          this.stateDisposer.add({\n            dispose() {\n              tokenSource.dispose(true);\n            },\n          });\n          this.stateDisposer.add(\n            build.onCompleted(({ graph }) => this.sendEvent('build_complete', { graph, start }))\n          );\n          this.stateDisposer.add(\n            build.onProgress(({ progress }) => this.sendEvent('build_progress', progress))\n          );\n          this.stateDisposer.add(\n            build.onError(({ error }) => {\n              return this.sendEvent('build_error', { error, start });\n            })\n          );\n\n          this.graphBuilder.build([this.localStrategy.rootUri], {\n            incremental: false,\n            token: tokenSource.token,\n          });\n        },\n        onEvent: {\n          build_complete: ({ event }) =>\n            this.transitionTo(\n              {\n                stateName: 'built',\n                data: { graph: event.data.graph, latency: Date.now() - event.data.start },\n              },\n              event\n            ),\n          build_error: ({ event }) =>\n            this.transitionTo(\n              {\n                stateName: 'error',\n                data: { error: event.data.error, latency: Date.now() - event.data.start },\n              },\n              event\n            ),\n          build_progress: ({ event }) =>\n            this.transitionTo(\n              {\n                stateName: 'building',\n                data: { completed: event.data.completed, pending: event.data.pending },\n              },\n              event\n            ),\n          change: ({ event }) => this.transitionTo({ stateName: 'dirty' }, event),\n        },\n      },\n      built: {\n        onEvent: {\n          build: ({ event }) =>\n            this.transitionTo({ stateName: 'building', data: { completed: 0, pending: 0 } }, event),\n          change: ({ event }) => this.transitionTo({ stateName: 'dirty' }, event),\n        },\n      },\n      error: {\n        onEvent: {\n          build: ({ event }) =>\n            this.transitionTo({ stateName: 'building', data: { completed: 0, pending: 0 } }, event),\n          change: ({ event }) => this.transitionTo({ stateName: 'dirty' }, event),\n        },\n      },\n    },\n  };\n\n  private readonly onStateChangeEmitter = new Emitter<Readonly<BuilderState>>();\n\n  private readonly localStrategy = new MemoryStrategy({}, Uri.file('/'));\n  private readonly npmStrategy = CdnStrategy.forJsDelivr(readUrl);\n  private readonly rootStrategy = new CompoundStrategy({\n    strategies: [this.localStrategy, this.npmStrategy],\n  });\n  private readonly resolver: Resolver;\n  private readonly graphBuilder: GraphBuilder;\n\n  private mutableBuildState: BuilderState = { stateName: 'initial' };\n\n  public readonly buildConfig = {\n    autoBuild: false,\n    autoBuildWaitTimeout: 500,\n  };\n\n  private pendingEvents: BuilderEvent[] = [];\n\n  sendEvent<TSentEvent extends EventWithoutData<BuilderEvent>>(\n    event: TSentEvent['eventName']\n  ): void;\n  sendEvent<TSentEvent extends EventWithData<BuilderEvent>>(\n    event: TSentEvent['eventName'],\n    data: TSentEvent['data']\n  ): void;\n  sendEvent<TSentEvent extends BuilderEvent>(\n    eventName: TSentEvent['eventName'],\n    data?: TSentEvent['data']\n  ): void {\n    // console.group();\n    // console.log('sendEvent(%s, %s)', this.state.stateName, eventName, data);\n    this.pendingEvents.push({ eventName, data } as BuilderEvent);\n\n    while (this.pendingEvents.length) {\n      const event = this.pendingEvents.shift()!;\n      const currentStateDef = this.fsm.states[this.mutableBuildState.stateName];\n\n      // console.group();\n      // console.log('sendEvent(%s, %s) handle(%s)', this.state.stateName, eventName, event.eventName);\n\n      if (currentStateDef.onEvent) {\n        const handler = currentStateDef.onEvent[event.eventName];\n        const state = this.state;\n\n        if (handler) {\n          handler({ event, state } as any);\n        }\n      }\n      // console.groupEnd();\n    }\n    // console.groupEnd();\n  }\n\n  private readonly stateDisposer = new DisposableStore();\n\n  transitionTo<TTargetState extends BuilderState, TTriggeringEvent extends BuilderEvent>(\n    state: TTargetState,\n    event: TTriggeringEvent\n  ) {\n    // console.log('transitionTo(%s, %s, %s)', this.state.stateName, state.stateName, event.eventName);\n    // console.group();\n    const nextStateConfig = this.fsm.states[state.stateName];\n    const fromState = { ...this.mutableBuildState };\n\n    this.mutableBuildState = { ...state };\n    this.onStateChangeEmitter.fire(this.state);\n\n    if (state.stateName !== fromState.stateName) {\n      this.stateDisposer.clear();\n\n      if (nextStateConfig.onEnter) {\n        // console.log('onEnter(%s, %s)', this.state.stateName, event.eventName);\n        // console.group();\n        nextStateConfig.onEnter({ event, state } as any);\n        // console.groupEnd();\n      }\n    }\n    // console.groupEnd();\n  }\n\n  constructor(\n    monaco: typeof import('monaco-editor'),\n    options: { autoBuild?: boolean; autoBuildWaitTimeout?: number } = {}\n  ) {\n    if (options.autoBuild) {\n      this.buildConfig.autoBuild = options.autoBuild;\n    }\n    if (options.autoBuildWaitTimeout) {\n      this.buildConfig.autoBuildWaitTimeout = options.autoBuildWaitTimeout;\n    }\n\n    this.resolver = new Resolver(this.rootStrategy, {\n      debug: false,\n      extensions: ['.js', '.jsx', '.json', '.ts', '.tsx', '.mjs', '.cjs'],\n      packageMain: ['browser', 'main'],\n    });\n    this.graphBuilder = new GraphBuilder({\n      resolver: this.resolver,\n      nodeEnv: 'development',\n      plugins: [cssPlugin(), sucrasePlugin({ transforms: ['imports', 'jsx', 'typescript'] })],\n    });\n\n    this.disposer.add(this.resolver);\n    // this.disposer.add(this.graphBuilder);\n\n    // Track existing models\n    for (const model of monaco.editor.getModels()) {\n      if (!Uri.isPrefixOf(this.localStrategy.rootUri, model.uri)) {\n        continue;\n      }\n\n      this.trackModel(model);\n    }\n\n    // And future models\n    monaco.editor.onDidCreateModel((model) => {\n      if (!Uri.isPrefixOf(this.localStrategy.rootUri, model.uri)) {\n        return;\n      }\n\n      this.trackModel(model);\n    });\n  }\n\n  get onStateChange(): Event<Readonly<BuilderState>> {\n    return this.onStateChangeEmitter.event;\n  }\n\n  get state(): Readonly<BuilderState> {\n    return this.mutableBuildState;\n  }\n\n  dispose() {\n    this.disposer.dispose();\n  }\n\n  startBuild() {\n    this.sendEvent('build');\n  }\n\n  private handleChange(uri: Uri) {\n    this.sendEvent('change', { uri });\n  }\n\n  private trackModel(model: Monaco.editor.ITextModel) {\n    model.onWillDispose(() => {\n      this.localStrategy.removeFile(model.uri.fsPath);\n      this.handleChange(Uri.from(model.uri));\n      disposerReference.dispose();\n    });\n\n    this.localStrategy.addFile(model.uri.fsPath, model.getValue());\n\n    const disposerReference = this.disposer.add(\n      model.onDidChangeContent(() => {\n        this.localStrategy.addFile(model.uri.fsPath, model.getValue(), {\n          overwrite: true,\n        });\n        this.handleChange(Uri.from(model.uri));\n      })\n    );\n\n    this.handleChange(Uri.from(model.uri));\n  }\n}\n","import styled from '@emotion/styled/macro';\nimport { Uri } from '@velcro/common';\nimport * as Monaco from 'monaco-editor';\nimport React, { useContext, useEffect, useRef, useState } from 'react';\nimport { EditorManagerContext } from '../lib/EditorManager';\nimport { VelcroMonaco } from '../velcro';\n\nexport interface DeferredExecutionModuleRecord {\n  code: string;\n  dependencies: Record<string, string>;\n}\n\nexport interface DeferredExecutionManifest {\n  aliases: Record<string, string>;\n  entrypoints: Record<string, string>;\n  modules: Record<string, DeferredExecutionModuleRecord>;\n}\n\ninterface MessageLine {\n  isInternal: boolean;\n  text: string;\n}\ninterface Message {\n  lines: MessageLine[];\n}\n\nconst PreviewProgress = styled.div<{ completed: number; total: number }>`\n  z-index: 1;\n  position: absolute;\n  top: 0;\n  width: ${(props) => (props.total ? `${Math.round((100 * props.completed) / props.total)}%` : 0)};\n  left: 0;\n  height: ${(props) => (props.total ? '2px' : '0')};\n  background-color: #008cba;\n  transition: width 0.5s 0s cubic-bezier(0.455, 0.03, 0.515, 0.955);\n`;\nconst PreviewIframeWrap = styled.div`\n  position: relative;\n  overflow: hidden;\n\n  & > iframe {\n    position: absolute;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n    border: none;\n    width: 100%;\n    height: 100%;\n  }\n`;\nconst PreviewWrap = styled.div`\n  position: relative;\n  background: white;\n\n  ${PreviewIframeWrap} {\n    position: absolute;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n  }\n`;\nconst PreviewMessageError = styled.ul`\n  margin: 0;\n  padding: 1em 2em;\n  font-family: monospace;\n  font-size: 16px;\n  background-color: rgba(255, 0, 0, 0.5);\n  backdrop-filter: brightness(50%);\n  color: white;\n  list-style: none;\n`;\nconst PreviewMessageErrorText = styled.li<{ isInternal: boolean }>`\n  white-space: pre-wrap;\n  opacity: ${(props) => (props.isInternal ? 0.7 : 1.0)};\n`;\nconst PreviewMessages = styled.div`\n  z-index: 1;\n  position: absolute;\n  bottom: 0;\n  right: 0;\n  left: 0;\n  display: flex;\n  flex-direction: column-reverse;\n`;\nconst PreviewMessageLine: React.FC<{ line: MessageLine }> = ({ line }) => {\n  return (\n    <PreviewMessageErrorText isInternal={line.isInternal}>{line.text}</PreviewMessageErrorText>\n  );\n};\nconst PreviewMessage: React.FC<{ message: Message }> = ({ message }) => {\n  return message.lines.length ? (\n    <PreviewMessageError>\n      {message.lines.map((line, i) => (\n        <PreviewMessageLine key={i} line={line}></PreviewMessageLine>\n      ))}\n    </PreviewMessageError>\n  ) : null;\n};\n\nconst Preview: React.FC<{ className?: string }> = (props) => {\n  const editorManager = useContext(EditorManagerContext);\n  const previewWrapRef = useRef<HTMLDivElement | null>(null);\n  const previewIframeRef = useRef<HTMLIFrameElement | null>(null);\n  const [buildState, setBuildState] = useState<VelcroMonaco['state']>({ stateName: 'initial' });\n  const [messages, setMessages] = useState([] as Message[]);\n  const [buildProgress, setBuildProgress] = useState({ completed: 0, total: 0 });\n\n  useEffect(() => {\n    const onMessage = (e: MessageEvent) => {\n      if (\n        previewIframeRef.current &&\n        previewIframeRef.current.contentWindow === e.source &&\n        e.data.event === 'click_error'\n      ) {\n        console.log(e);\n        editorManager.focusPath(Uri.parse(e.data.entry.file).fsPath, {\n          columnNumber: e.data.entry.column,\n          lineNumber: e.data.entry.line,\n        });\n      }\n    };\n\n    window.addEventListener('message', onMessage);\n\n    return () => window.removeEventListener('message', onMessage);\n  });\n\n  useEffect(() => {\n    const velcro = new VelcroMonaco(Monaco, {\n      autoBuild: true,\n      autoBuildWaitTimeout: 500,\n    });\n\n    velcro.onStateChange((state) => {\n      setBuildState(state);\n\n      switch (state.stateName) {\n        case 'building': {\n          setBuildProgress({\n            completed: state.data.completed,\n            total: state.data.completed + state.data.pending,\n          });\n          break;\n        }\n        case 'built': {\n          const graph = state.data.graph;\n          const [chunk] = graph.splitChunks();\n          const build = chunk.buildForStaticRuntime({\n            injectRuntime: true,\n          });\n          const codeWithStart = `${build.code}\\n\\n${[Uri.file('/index.jsx')]\n            .map(\n              (entrypoint) => `Velcro.runtime.require(${JSON.stringify(entrypoint.toString())});`\n            )\n            .join('\\n')}\\n`;\n          const runtimeCode = `${codeWithStart}\\n//# sourceMappingURL=${build.sourceMapDataUri}`;\n          const codeBundleFile = new File([runtimeCode], Uri.file('/index.jsx').toString(), {\n            type: 'text/javascript',\n          });\n\n          const markup = new File(\n            [\n              `\n    <!DOCTYPE html>\n    <html lang=\"en\">\n    <head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n    <script src=\"https://cdn.jsdelivr.net/npm/panic-overlay/build/panic-overlay.browser.js\"></script>\n    <title>Document</title>\n    </head>\n    <body>\n    <div id=\"root\"></div>\n    <script src=\"${URL.createObjectURL(codeBundleFile)}\"></script>\n    <script>\n      panic.configure ({\n        stackEntryClicked (entry) {\n          if (window.parent) {\n            window.parent.postMessage({\n              event: 'click_error',\n              entry: {\n                column: entry.column,\n                file: entry.file,\n                line: entry.line,\n              }\n            });\n          }\n        }\n      })\n    </script>\n    </body>\n    </html>`,\n            ],\n            Uri.file('/index.html').toString(),\n            {\n              type: 'text/html',\n            }\n          );\n          const htmlUrl = URL.createObjectURL(markup);\n          const iframe = document.createElement('iframe');\n          iframe.style.display = 'none';\n          iframe.src = htmlUrl;\n\n          if (previewWrapRef.current) {\n            previewWrapRef.current.appendChild(iframe);\n          }\n\n          const onLoad = () => {\n            iframe.removeEventListener('error', onError);\n            iframe.style.display = '';\n\n            if (previewIframeRef.current) {\n              previewIframeRef.current.remove();\n            }\n\n            previewIframeRef.current = iframe;\n          };\n          const onError = () => {\n            iframe.removeEventListener('load', onLoad);\n            iframe.remove();\n          };\n\n          iframe.addEventListener('load', onLoad, { once: true });\n          iframe.addEventListener('error', onError, { once: true });\n\n          break;\n        }\n        case 'error': {\n          setMessages([{ lines: [{ isInternal: true, text: state.data.error.message }] }]);\n          break;\n        }\n      }\n    });\n\n    return () => velcro.dispose();\n  }, [setBuildProgress, setBuildState]);\n\n  return (\n    <PreviewWrap className={props.className}>\n      {buildState.stateName === 'building' ? (\n        <PreviewProgress\n          completed={buildProgress.completed}\n          total={buildProgress.total}\n        ></PreviewProgress>\n      ) : null}\n      <PreviewIframeWrap ref={previewWrapRef}></PreviewIframeWrap>\n      <PreviewMessages>\n        {buildState.stateName === 'error' ? (\n          <PreviewMessage\n            message={{ lines: [{ isInternal: true, text: buildState.data.error.message }] }}\n          ></PreviewMessage>\n        ) : null}\n      </PreviewMessages>\n    </PreviewWrap>\n  );\n};\n\nexport default styled(Preview)``;\n","import { DisposableStore } from '@velcro/common';\nimport * as Monaco from 'monaco-editor';\nimport { useEffect, useState } from 'react';\n\n// import { EditorContext } from './context';\n\nexport enum EntryKind {\n  Directory = 'directory',\n  File = 'file',\n}\n\nexport interface IDirectory {\n  type: EntryKind.Directory;\n  uri: Monaco.Uri;\n}\nexport interface IFile {\n  type: EntryKind.File;\n  uri: Monaco.Uri;\n  model: Monaco.editor.ITextModel;\n}\n\nexport type DirectoryEntry = IDirectory | IFile;\n\nexport function useDirectory(uri: Monaco.Uri) {\n  // Make sure the URI always ends with a trailing slash\n  const prefix = uri.toString(true).replace(/\\/?$/, '/');\n  const sortEntries = (models: DirectoryEntry[]) => {\n    return [...models].sort((a, b) => (a.uri.fsPath > b.uri.fsPath ? 1 : -1));\n  };\n\n  const initialEntries = sortEntries(\n    Monaco.editor.getModels().reduce((entries, model) => {\n      const modelUri = model.uri.toString(true);\n\n      if (modelUri.startsWith(prefix)) {\n        const nestedPath = modelUri.slice(prefix.length);\n        const nextDirIdx = nestedPath.indexOf('/');\n\n        if (nextDirIdx === 0) {\n          throw new Error('Invariant error: WAT?');\n        }\n\n        if (nextDirIdx > 0) {\n          // This is an intermediate directory\n          const uri = Monaco.Uri.parse(`${prefix}${nestedPath.slice(0, nextDirIdx + 1)}`);\n\n          entries.push({\n            type: EntryKind.Directory,\n            uri,\n          });\n        } else {\n          entries.push({\n            type: EntryKind.File,\n            uri: model.uri,\n            model,\n          });\n        }\n      }\n\n      return entries;\n    }, [] as DirectoryEntry[])\n  );\n  const [entries, setEntries] = useState(initialEntries);\n\n  useEffect(() => {\n    const disposable = new DisposableStore();\n    const prefix = uri.toString(true).replace(/\\/?$/, '/');\n\n    disposable.add(\n      Monaco.editor.onDidCreateModel((model: Monaco.editor.ITextModel) => {\n        const modelUri = model.uri.toString(true);\n\n        if (modelUri.startsWith(prefix)) {\n          const nestedPath = modelUri.slice(prefix.length);\n          const nextDirIdx = nestedPath.indexOf('/');\n\n          if (nextDirIdx === 0) {\n            throw new Error('Invariant error: WAT?');\n          }\n\n          if (nextDirIdx > 0) {\n            // This is an intermediate directory\n            const uri = Monaco.Uri.parse(`${prefix}${nestedPath.slice(0, nextDirIdx)}`);\n\n            // It is possible that we already have this directory\n            const entry = entries.find((entry) => entry.uri.toString(true) === uri.toString(true));\n\n            if (entry) {\n              if (entry.type !== EntryKind.Directory) {\n                throw new Error(\n                  `Invariant violation: A file in '${prefix}' conflicts with the path of the new file '${modelUri}'`\n                );\n              }\n\n              return;\n            }\n\n            entries.push({ type: EntryKind.Directory, uri });\n\n            return setEntries(sortEntries(entries));\n          }\n\n          if (\n            !entries.find(\n              (entry) =>\n                entry.type === EntryKind.File &&\n                entry.uri.toString(true) === model.uri.toString(true)\n            )\n          ) {\n            entries.push({ type: EntryKind.File, uri: model.uri, model });\n\n            setEntries(sortEntries(entries));\n          }\n        }\n      })\n    );\n\n    disposable.add(\n      Monaco.editor.onWillDisposeModel((model) => {\n        const idx = entries.findIndex(\n          (entry) => entry.type === EntryKind.File && entry.model === model\n        );\n\n        if (idx === -1) {\n          throw new Error(\n            `Invariant violation: Removing an untracked model: '${model.uri.fsPath}'`\n          );\n        }\n\n        entries.splice(idx, 1);\n\n        setEntries(sortEntries(entries));\n      })\n    );\n\n    return () => disposable.dispose();\n  }, [entries, uri]);\n\n  return entries;\n}\n","import styled from '@emotion/styled/macro';\nimport * as Monaco from 'monaco-editor';\nimport React, { useContext, useRef } from 'react';\nimport { Button } from 'reakit/Button';\nimport { Tooltip, TooltipReference, useTooltipState } from 'reakit/Tooltip';\nimport { useDirectory, EntryKind } from '../lib/hooks';\nimport { useActiveModel, EditorManagerContext } from '../lib/EditorManager';\n\nconst Entry = styled.div<{ modelFocused: boolean }>`\n  background-color: ${props => (props.modelFocused ? '#008cba' : 'inherit')};\n  text-decoration: none;\n  color: ${props => (props.modelFocused ? '#fff' : '#262626')};\n\n  height: 25px;\n  padding: 0 0 0 8px;\n  display: flex;\n  flex-direction: row;\n  align-items: center;\n\n  & > span {\n    flex: 1;\n  }\n\n  & > button {\n    display: none;\n  }\n\n  &:hover > button {\n    display: block;\n  }\n\n  ${props =>\n    props.modelFocused\n      ? {\n          ':hover': {\n            color: '#f5f5f5',\n            cursor: 'pointer',\n          },\n        }\n      : {\n          ':hover': {\n            backgroundColor: '#eee',\n            color: '#262626',\n            cursor: 'pointer',\n          },\n        }}\n`;\n\nconst CreateEntry = styled.div`\n  text-decoration: none;\n  color: '#262626';\n\n  height: 25px;\n  padding: 0 0 0 8px;\n  display: flex;\n  align-items: center;\n\n  :hover {\n    background-color: #eee;\n    cursor: pointer;\n  }\n`;\n\nconst SidebarFileDelete = styled(Button)`\n  border: none;\n  background: none;\n\n  :hover {\n    cursor: pointer;\n  }\n`;\n\nconst StyledTooltip = styled.div`\n  font-family: Open Sans, Helvetica Neue, Helvetica, Arial, sans-serif;\n  font-size: 14px;\n  line-height: 1.4;\n  background-color: #333;\n  color: #fff;\n  border-radius: 4px;\n  opacity: 0.9;\n  padding: 0.2em 0.4em;\n`;\n\nconst SidebarFile: React.FC<{ className?: string; model: Monaco.editor.ITextModel }> = ({ className, model }) => {\n  const activeModel = useActiveModel();\n  const editorManager = useContext(EditorManagerContext);\n  const tooltip = useTooltipState({ gutter: 0 });\n\n  const onClickDelete = () => {\n    model.dispose();\n  };\n\n  return (\n    <Entry className={className} modelFocused={model === activeModel}>\n      <span onClick={() => editorManager.focusModel(model)}>{model.uri.fsPath.slice(1)}</span>\n      <TooltipReference {...tooltip} as={SidebarFileDelete} onClick={() => onClickDelete()}>\n        <span role=\"img\" aria-label=\"Delete file\">\n          ❌\n        </span>\n      </TooltipReference>\n      <Tooltip {...tooltip} as={StyledTooltip}>\n        Delete file\n      </Tooltip>\n    </Entry>\n  );\n};\n\nconst Sidebar: React.FC<{ className?: string }> = props => {\n  const rootDir = useRef(Monaco.Uri.file('/'));\n  const entries = useDirectory(rootDir.current);\n  const editorManager = useContext(EditorManagerContext);\n\n  const onClickCreate = () => {\n    const filename = prompt('Filename?');\n\n    if (filename) {\n      editorManager.createModel(filename);\n    }\n  };\n\n  return (\n    <div className={props.className}>\n      {entries.map(entry =>\n        entry.type === EntryKind.Directory ? (\n          <div>{entry.uri.fsPath.slice(1)}</div>\n        ) : (\n          <SidebarFile key={entry.uri.toString(true)} model={entry.model}></SidebarFile>\n        )\n      )}\n      <CreateEntry onClick={() => onClickCreate()}>Create...</CreateEntry>\n    </div>\n  );\n};\n\nexport default styled(Sidebar)`\n  display: flex;\n  flex-direction: column;\n`;\n","import styled from '@emotion/styled/macro';\nimport React from 'react';\n\nimport Editor from './Editor';\nimport Preview from './Preview';\nimport Sidebar from './Sidebar';\nimport { EditorManager, EditorManagerContext } from '../lib/EditorManager';\n\nconst PlaygroundCmp: React.FC<{\n  className?: string;\n  initialPath: string;\n  project: Record<string, string>;\n}> = ({ className, initialPath, project }) => {\n  const editorManager = new EditorManager({ files: project, initialPath: initialPath });\n\n  return (\n    <div className={className}>\n      <EditorManagerContext.Provider value={editorManager}>\n        <Sidebar></Sidebar>\n        <Editor></Editor>\n        <Preview></Preview>\n      </EditorManagerContext.Provider>\n    </div>\n  );\n};\n\nexport const Playground = styled(PlaygroundCmp)`\n  display: flex;\n  flex-direction: row;\n\n  font-family: Open Sans, Helvetica Neue, Helvetica, Arial, sans-serif;\n  font-size: 14px;\n  line-height: 1.4;\n\n  color: #222;\n\n  ${Sidebar} {\n    flex: 1 1 100px;\n    min-width: 100px;\n    max-width: 400px;\n    border-right: 1px solid #ccc;\n  }\n\n  ${Editor} {\n    border-right: 1px solid #ccc;\n  }\n\n  ${Editor}, ${Preview} {\n    flex: 10;\n  }\n`;\n","export const files: Record<string, string> = {\n  'package.json':\n    JSON.stringify(\n      {\n        name: 'react-template',\n        version: '0.0.0',\n        dependencies: {\n          'github-markdown-css': '^3.0.1',\n          react: '^16.9.0',\n          'react-dom': '^16.9.0',\n        },\n      },\n      null,\n      2\n    ) + '\\n',\n  'app.jsx': `\nimport React, { Component } from 'react';\nimport 'github-markdown-css';\n\nimport { Explanation } from './explanation';\nimport { name } from './name';\nimport './style.css';\n\nclass Hello extends Component {\n  render() {\n    return <div className=\"markdown-body\">\n      <h1>Hello {name}</h1>\n      <blockquote>There is no <del>spoon</del> server</blockquote>\n      <Explanation/>\n    </div>;\n  }\n}\n\nexport default Hello\n  `.trim(),\n  'explanation.jsx':\n    `\nimport React from 'react';\n\nexport const Explanation = () => <>\n  <section>\n    <h2>What is this?</h2>\n    <p>\n      This is a demo of bundling and serving a browser-based sandbox fully from the browser. <strong>There are <em>no</em> servers involved</strong> except the static server hosting this demo and <a href=\"https://unpkg.com\" target=\"_blank\" rel=\"noopener\">unpkg.com</a>. All module resolution, transpilation and bundling is happening in the browser.\n    </p>\n    <p>\n      Try it. Go offline, and reload...\n    </p>\n    <p>\n      <strong>I dare you.</strong>\n    </p>\n  </section>\n  <section>\n    <h2>Features</h2>\n    <ul>\n      <li>Full offline support. Once your cache is seeded, you can cut the cord.</li>\n      <li>Fully browser-based bundling.</li>\n      <li>Add (almost) any node module and no server is involved.</li>\n      <li>If you want to add another module, make sure to add it to <code>package.json</code> first.</li>\n      <li>Automatic type acquisition for full typings support in the browser, in JavaScript!</li>\n      <li>Resolve source locations in stack traces</li>\n      <li>Hot module reloading</li>\n    </ul>\n  </section>\n</>;\n    `.trim() + '\\n',\n  'index.jsx':\n    `\nimport React, { Component } from 'react';\nimport ReactDOM from 'react-dom';\n\nimport App from './app';\n  \nReactDOM.render(\n  <App/>,\n  document.getElementById('root')\n);\n      `.trim() + '\\n',\n  'name.js':\n    `\nexport const name = 'Velcro';\n    `.trim() + '\\n',\n  'style.css':\n    `\n.markdown-body {\n  box-sizing: border-box;\n  min-width: 200px;\n  max-width: 980px;\n  margin: 0 auto;\n  padding: 45px;\n}\n\n@media (max-width: 767px) {\n  .markdown-body {\n    padding: 15px;\n  }\n}\n    `.trim() + '\\n',\n};\n","import React from 'react';\n\n// import * as serviceWorker from './serviceWorker';\n\ninterface ServiceWorkerEvent extends Event {\n  target: (Partial<ServiceWorker> & EventTarget) | null;\n}\n\ninterface ServiceWorkerContextValue {\n  assetsUpdateReady: boolean;\n  assetsCached: boolean;\n  updateAssets(): void;\n}\n\nconst ServiceWorkerContext = React.createContext<ServiceWorkerContextValue | undefined>(undefined);\n\nexport function ServiceWorkerProvider(props: React.PropsWithChildren<{}>) {\n  const [waitingServiceWorker, setWaitingServiceWorker] = React.useState<ServiceWorker | null>(\n    null\n  );\n  const [assetsUpdateReady, setAssetsUpdateReady] = React.useState(false);\n  const [assetsCached, setAssetsCached] = React.useState(false);\n\n  const value = React.useMemo(() => {\n    return {\n      assetsUpdateReady,\n      assetsCached,\n      // Call when the user confirm update of application and reload page\n      updateAssets: () => {\n        if (waitingServiceWorker) {\n          waitingServiceWorker.addEventListener('statechange', (event: ServiceWorkerEvent) => {\n            if (event.target && event.target.state === 'activated') {\n              window.location.reload();\n            }\n          });\n\n          waitingServiceWorker.postMessage({ type: 'SKIP_WAITING' });\n        }\n      },\n    };\n  }, [assetsUpdateReady, assetsCached, waitingServiceWorker]);\n\n  // Once on component mounted subscribe to Update and Succes events in\n  // CRA's service worker wrapper\n  // React.useEffect(() => {\n  //   serviceWorker.register({\n  //     onUpdate: (registration) => {\n  //       setWaitingServiceWorker(registration.waiting);\n  //     },\n  //     onUpdateAvailable: () => {\n  //       setAssetsUpdateReady(true);\n  //     },\n  //     onSuccess: (registration) => {\n  //       setAssetsCached(true);\n  //       setAssetsUpdateReady(false);\n\n  //       if (registration.active) {\n  //         registration.active.addEventListener('statechange', (event: ServiceWorkerEvent) => {\n  //           if (!navigator.serviceWorker.controller) {\n  //             setAssetsCached(false);\n  //           }\n  //         });\n  //       }\n  //     },\n  //   });\n  // }, []);\n\n  return <ServiceWorkerContext.Provider value={value} {...props} />;\n}\n\nexport function useServiceWorker() {\n  const context = React.useContext(ServiceWorkerContext);\n\n  if (!context) {\n    throw new Error('useServiceWorker must be used within a ServiceWorkerProvider');\n  }\n\n  return context;\n}\n","//@ts-nocheck\nimport { Global, css } from '@emotion/core';\nimport styled from '@emotion/styled/macro';\nimport CssBaseline from '@material-ui/core/CssBaseline';\nimport { OfflineBolt, Update } from '@material-ui/icons';\nimport React from 'react';\nimport { Tooltip, TooltipReference, useTooltipState } from 'reakit/Tooltip';\n\nimport { Playground } from './playground';\nimport { files } from './templates/react';\nimport { useServiceWorker, ServiceWorkerProvider } from './useServiceWorker';\nimport { Button } from 'reakit/Button';\n\nconst PlaygroundWrapper = styled.div`\n  background: white;\n  color: #666;\n  display: flex;\n  flex-direction: column;\n\n  ${Playground} {\n    border-bottom: 1px solid #ccc;\n    flex: 1;\n  }\n`;\n\nconst StatusBarItem = styled.span`\n  display: inline-flex;\n  flex-direction: row;\n  align-items: center;\n`;\n\nconst ReloadButton = styled(Button)`\n  border: 0;\n  background: #008cba;\n  margin: 0 0.5em;\n  color: white;\n  border-radius: 2px;\n  font-weight: 600;\n\n  :hover {\n    cursor: pointer;\n    text-decoration: underline;\n  }\n`;\n\nconst StyledTooltip = styled.div`\n  font-family: Open Sans, Helvetica Neue, Helvetica, Arial, sans-serif;\n  font-size: 14px;\n  line-height: 1.4;\n  background-color: #333;\n  color: #fff;\n  border-radius: 4px;\n  opacity: 0.9;\n  padding: 0.2em 0.4em;\n`;\n\nconst StatusBar: React.FC = () => {\n  const serviceWorker = useServiceWorker();\n  const offlineTooltip = useTooltipState({ gutter: 0 });\n  const reloadTooltip = useTooltipState({ gutter: 0 });\n\n  return (\n    <StatusBarStyles>\n      {serviceWorker.assetsCached ? (\n        <TooltipReference {...offlineTooltip} as={StatusBarItem}>\n          <OfflineBolt color=\"inherit\" fontSize=\"small\" />\n          &nbsp;Offline ready\n        </TooltipReference>\n      ) : null}\n      <Tooltip {...offlineTooltip} as={StyledTooltip}>\n        This application has been fully cached and can now be used offline.\n      </Tooltip>\n\n      {serviceWorker.assetsUpdateReady ? (\n        <TooltipReference {...reloadTooltip} as={StatusBarItem}>\n          <Update color=\"inherit\" fontSize=\"small\" />\n          &nbsp;Update ready:\n          <ReloadButton onClick={() => serviceWorker.updateAssets()}>Reload</ReloadButton>\n        </TooltipReference>\n      ) : null}\n      <Tooltip {...reloadTooltip} as={StyledTooltip}>\n        There is an update of this application ready to install. Click install reload to install the\n        update and reload the page.\n      </Tooltip>\n    </StatusBarStyles>\n  );\n};\n\nconst StatusBarStyles = styled.div`\n  display: flex;\n  flex-direction: row;\n\n  font-size: 90%;\n\n  height: 24px;\n  padding: 0 0.5em;\n\n  ${StatusBarItem} {\n    margin-left: 0.5em;\n    margin-right: 0.5em;\n  }\n`;\n\nconst AppWrapper = styled.div`\n  width: 100%;\n  min-width: 200px;\n  max-width: 80vw;\n  margin: 0 auto;\n  padding: 0 0 45px 0;\n\n  @media (max-width: 960px) {\n    padding: 0 15px 15px 15px;\n    max-width: initial;\n  }\n\n  display: flex;\n  flex-direction: column;\n\n  ${PlaygroundWrapper} {\n    flex: 1;\n    background: #f5f5f5;\n    border-radius: 2px;\n    box-shadow: 0 10px 20px rgba(0, 0, 0, 0.19), 0 6px 6px rgba(0, 0, 0, 0.23);\n\n    ${StatusBarStyles} {\n    }\n  }\n`;\n\nconst Title = styled.div`\n  font-family: 'Raleway', sans-serif;\n  font-size: 250%;\n  font-weight: 800;\n  font-variant: small-caps;\n  font-variant-caps: small-caps;\n  color: #00bfff;\n`;\n\nconst Subtitle = styled.div`\n  color: #ddd;\n  font-size: 120%;\n  font-weight: 400;\n`;\n\nconst Link = styled.a`\n  color: white;\n  text-decoration: none;\n\n  :hover {\n    text-decoration: underline;\n  }\n`;\n\nconst Links = styled.div`\n  display: flex;\n  flex-direction: row;\n\n  & > *:not(:last-child):after {\n    padding: 0 0.5em;\n    content: '｜';\n    color: #aaa;\n    text-decoration: none;\n  }\n\n  ${Link} {\n    color: #ccc;\n  }\n`;\n\nconst Header = styled.div`\n  display: flex;\n  flex-direction: row;\n  align-items: baseline;\n  padding: 0.8em 0 0.3em 0;\n  text-shadow: #000 1px 1px 5px;\n\n  ${Title} {\n    margin-right: 0.5em;\n  }\n\n  ${Subtitle} {\n    margin-right: 0.5em;\n  }\n\n  ${Links} {\n    flex: 1;\n    justify-content: flex-end;\n  }\n`;\n\nconst globalCss = css`\n  @import url('https://fonts.googleapis.com/css?family=Raleway:900&display=swap');\n\n  *,\n  *::before,\n  *::after {\n    box-sizing: border-box;\n  }\n\n  html,\n  body {\n    margin: 0;\n    padding: 0;\n    min-height: 100vh;\n\n    font-family: Open Sans, Helvetica Neue, Helvetica, Arial, sans-serif;\n    font-size: 14px;\n    line-height: 1.4;\n\n    background: #333;\n    color: #fff;\n\n    display: flex;\n    flex-direction: column;\n\n    #root {\n      flex: 1;\n      display: flex;\n      flex-direction: column;\n\n      ${AppWrapper} {\n        flex: 1;\n      }\n    }\n  }\n`;\n\nexport const App: React.FC = () => {\n  return (\n    <ServiceWorkerProvider>\n      <CssBaseline />\n      <AppWrapper>\n        <Global styles={globalCss}></Global>\n        <Header>\n          <Title>Velcro</Title>\n          <Subtitle>The client-side bundler and playground</Subtitle>\n          <Links>\n            <div>\n              <Link href=\"https://twitter.com/filearts\" target=\"_blank\" rel=\"nofollow noreferrer\">\n                @filearts\n              </Link>\n            </div>\n            <div>\n              <Link\n                href=\"https://github.com/ggoodman/velcro\"\n                target=\"_blank\"\n                rel=\"nofollow noreferrer\"\n              >\n                View on GitHub\n              </Link>\n            </div>\n          </Links>\n        </Header>\n        <PlaygroundWrapper>\n          <Playground project={files} initialPath=\"index.jsx\"></Playground>\n        </PlaygroundWrapper>\n      </AppWrapper>\n    </ServiceWorkerProvider>\n  );\n};\n","import React from 'react';\nimport ReactDOM from 'react-dom';\n\nimport { App } from './App';\n\nReactDOM.render(<App />, document.getElementById('root'));\n","import { CancellationTokenSource, MapSet, Decoder, Uri, isThenable, all, checkCancellation, dirname, DependencyNotFoundError, EntryExcludedError, parseBufferAsPartialPackageJson, basename, EntryNotFoundError, parseBufferAsPackageJson, CanceledError } from '@velcro/common';\n\nconst SPEC_RX = /^((@[^/]+\\/[^/@]+|[^./@][^/@]*)(?:@([^/]+))?)(.*)?$/;\nfunction parseBareModuleSpec(bareModuleSpec) {\n    const matches = bareModuleSpec.match(SPEC_RX);\n    if (matches) {\n        const [, nameSpec, name, spec, path = ''] = matches;\n        return {\n            nameSpec,\n            name,\n            spec,\n            path,\n        };\n    }\n    return null;\n}\n\nvar version = \"0.45.0\";\n\nconst NODE_CORE_SHIMS = Object.assign(Object.create(null), {\n    string_decoder: parseBareModuleSpec('string_decoder@1.2.0'),\n    punycode: parseBareModuleSpec('punycode@2.1.1'),\n});\nfor (const name of [\n    'assert',\n    'buffer',\n    'constants',\n    'crypto',\n    'events',\n    'fs',\n    'http',\n    'https',\n    'net',\n    'os',\n    'path',\n    'process',\n    'querystring',\n    'stream',\n    'tls',\n    'url',\n    'util',\n    'vm',\n    'zlib',\n]) {\n    NODE_CORE_SHIMS[name] = parseBareModuleSpec(`@velcro/node-libs@${version}/lib/${name}.js`);\n}\n\nvar ResolverStrategy;\n(function (ResolverStrategy) {\n    let EntryKind;\n    (function (EntryKind) {\n        EntryKind[\"File\"] = \"file\";\n        EntryKind[\"Directory\"] = \"directory\";\n    })(EntryKind = ResolverStrategy.EntryKind || (ResolverStrategy.EntryKind = {}));\n})(ResolverStrategy || (ResolverStrategy = {}));\nclass AbstractResolverStrategy {\n    getCanonicalUrl(_ctx, uri) {\n        return {\n            uri,\n        };\n    }\n    getSettings(ctx, _uri) {\n        return {\n            settings: ctx.settings,\n        };\n    }\n    /**\n     * Create a new ResolverStrategy having one or more methods overridden.\n     *\n     * You might use this if you want to override specific behaviour of another strategy without\n     * wanting to re-implement the whole strategy.\n     *\n     * If you need to invoke an overridden method, the overridden strategy will be available\n     * on `this.parent`.\n     *\n     * @param overrides A map of ResolverStrategy methods that you would like to override\n     */\n    withOverrides(overrides) {\n        const strategy = { ...overrides, parent: this };\n        return Object.setPrototypeOf(Object.assign(Object.create(null), strategy), this);\n    }\n}\nclass AbstractResolverStrategyWithRoot extends AbstractResolverStrategy {\n    constructor(rootUri) {\n        super();\n        this.rootUri = rootUri;\n    }\n}\n\n// type UncachedReturnType<T> = { [K in keyof T] : K extends typeof CACHE ? never : T[K] };\n// type UncachedReturn<\n//   T extends (...any: any[]) => any,\n//   TReturn = ReturnType<T>\n// > = TReturn extends Thenable<infer U>\n//   ? Thenable<UncachedReturnType<U>>\n//   : UncachedReturnType<TReturn>;\nconst CACHE = Symbol('Context.cache');\nclass Visits {\n    constructor(uri, parent) {\n        this.uri = uri;\n        this.visits = [];\n        this.parent = parent;\n    }\n    child(uri) {\n        return new Visits(uri, this);\n    }\n    push(visit) {\n        if (!this.visits.find((cmp) => cmp.type == visit.type && Uri.equals(cmp.uri, visit.uri))) {\n            this.visits.push(visit);\n            if (this.parent) {\n                this.parent.push(visit);\n            }\n        }\n    }\n    toArray() {\n        return this.parent ? this.parent.toArray() : this.visits.slice();\n    }\n}\nclass ResolverContext {\n    constructor(options) {\n        this.mapResultWithVisits = (result) => Object.assign(result, { visited: this.visits.toArray() });\n        this.cache = options.cache;\n        this.cacheInvalidations = options.cacheInvalidations;\n        this.debugMode = options.debug;\n        this.decoder = options.decoder;\n        this.path = options.path;\n        this.resolver = options.resolver;\n        this.settings = options.settings;\n        this.strategy = options.strategy;\n        this.tokenSource = new CancellationTokenSource(options.token);\n        this.visits = options.visits;\n    }\n    static create(resolver, strategy, settings, token, options = {}) {\n        return new ResolverContext({\n            cache: new Map(),\n            cacheInvalidations: new MapSet(),\n            debug: !!options.debug,\n            decoder: new Decoder(),\n            path: [],\n            resolver,\n            settings,\n            strategy,\n            token,\n            visits: new Visits(Uri.parse('velcro:/root')),\n        });\n    }\n    get token() {\n        return this.tokenSource.token;\n    }\n    get visited() {\n        return this.visits.toArray();\n    }\n    dispose() {\n        this.tokenSource.dispose(true);\n    }\n    forOperation(operationName, uri, options = {}) {\n        const encodedOperation = encodePathNode(operationName, uri);\n        if (this.path.includes(encodedOperation)) {\n            const formattedPath = this.path\n                .map((segment) => {\n                const { operationName, uri } = decodePathNode(segment);\n                return `${operationName}(${uri.toString()})`;\n            })\n                .join(' -> ');\n            throw this._wrapError(new Error(`Detected a recursive call to the operation '${operationName}' for '${uri.toString()}' at path '${formattedPath}'`));\n        }\n        return new ResolverContext({\n            cache: this.cache,\n            cacheInvalidations: this.cacheInvalidations,\n            debug: this.debugMode,\n            decoder: this.decoder,\n            path: options.resetPath ? [] : this.path.concat(encodedOperation),\n            resolver: this.resolver,\n            settings: this.settings,\n            strategy: this.strategy,\n            token: this.tokenSource.token,\n            visits: options.resetVisits ? new Visits(uri) : this.visits.child(uri),\n        });\n    }\n    getCanonicalUrl(uri) {\n        const method = this.strategy.getCanonicalUrl;\n        const receiver = this.strategy;\n        const operationName = `${this.strategy.constructor.name}.${method.name}`;\n        const href = uri.toString();\n        return this.runInChildContext(operationName, uri, (ctx) => ctx.runWithCache(operationName, href, method, receiver, ctx, uri));\n    }\n    getResolveRoot(uri) {\n        const method = this.strategy.getResolveRoot;\n        const receiver = this.strategy;\n        const operationName = `${this.strategy.constructor.name}.${method.name}`;\n        const href = uri.toString();\n        return this.runInChildContext(operationName, uri, (ctx) => ctx.runWithCache(operationName, href, method, receiver, ctx, uri));\n    }\n    getSettings(uri) {\n        const method = this.strategy.getSettings;\n        const receiver = this.strategy;\n        const operationName = `${this.strategy.constructor.name}.${method.name}`;\n        const href = uri.toString();\n        return this.runInChildContext(operationName, uri, (ctx) => ctx.runWithCache(operationName, href, method, receiver, ctx, uri));\n    }\n    getUrlForBareModule(name, spec, path) {\n        const method = this.strategy.getUrlForBareModule;\n        if (!method) {\n            return Promise.reject(new Error(`Unable to resolve bare module spec '${name}@${spec}${path}' because no strategy was found that supports resolving bare modules`));\n        }\n        const receiver = this.strategy;\n        const operationName = `${this.strategy.constructor.name}.${method.name}`;\n        const href = `${name}@${spec}${path}`;\n        return this.runInChildContext(operationName, href, (ctx) => ctx.runWithCache(operationName, href, method, receiver, ctx, name, spec, path));\n    }\n    invalidate(uri) {\n        const href = uri.toString();\n        const invalidations = this.cacheInvalidations.get(href);\n        let invalidated = false;\n        if (invalidations) {\n            for (const { cacheKey, operationCache } of invalidations) {\n                invalidated = operationCache.delete(cacheKey) || invalidated;\n            }\n        }\n        this.cacheInvalidations.deleteAll(href);\n        return invalidated;\n    }\n    listEntries(uri) {\n        const method = this.strategy.listEntries;\n        const receiver = this.strategy;\n        const operationName = `${this.strategy.constructor.name}.${method.name}`;\n        const href = uri.toString();\n        return this.runInChildContext(operationName, uri, (ctx) => ctx.runWithCache(operationName, href, method, receiver, ctx, uri));\n    }\n    readFileContent(uri) {\n        const method = this.strategy.readFileContent;\n        const receiver = this.strategy;\n        const operationName = `${this.strategy.constructor.name}.${method.name}`;\n        const href = uri.toString();\n        this.recordVisit(uri, ResolverContext.VisitKind.File);\n        return this.runInChildContext(operationName, uri, (ctx) => ctx.runWithCache(operationName, href, method, receiver, ctx, uri));\n    }\n    readParentPackageJson(uri) {\n        return this.runWithCache('readParentPackageJson', uri.toString(), readParentPackageJson, null, this, uri);\n    }\n    recordVisit(uri, type = ResolverContext.VisitKind.File) {\n        this.visits.push({ type, uri });\n    }\n    resolve(spec, fromUri) {\n        const method = resolveDependency;\n        const receiver = null;\n        const operationName = method.name;\n        const href = `${fromUri}|${spec}`;\n        return this.runInChildContext(operationName, href, (ctx) => ctx.runWithCache(operationName, href, method, receiver, ctx, fromUri, spec));\n    }\n    resolveUri(uri) {\n        const method = resolve;\n        const receiver = null;\n        const operationName = method.name;\n        const href = uri.toString();\n        return this.runInChildContext(operationName, uri, (ctx) => ctx.runWithCache(operationName, href, method, receiver, ctx, uri));\n    }\n    runInChildContext(operationName, uri, contextFn) {\n        return this.runInContext(operationName, uri, { resetPath: false, resetVisits: false }, contextFn);\n    }\n    runInIsolatedContext(operationName, uri, contextFn) {\n        return this.runInContext(operationName, uri, { resetPath: true, resetVisits: true }, contextFn);\n    }\n    runInContext(operationName, uri, options, contextFn) {\n        const ctx = this.forOperation(operationName, uri, options);\n        ctx.debug('%s(%s)', operationName, uri.toString());\n        return contextFn(ctx);\n    }\n    createStoreResultFn(operationCache, cacheKey) {\n        return (result) => {\n            const mappedResult = this.mapResultWithVisits(result);\n            const visited = mappedResult.visited;\n            if (mappedResult[CACHE]) {\n                const cacheEntries = mappedResult[CACHE];\n                delete mappedResult[CACHE];\n                for (const [cacheKey, value] of cacheEntries) {\n                    operationCache.set(cacheKey, value);\n                    for (const visit of visited) {\n                        this.cacheInvalidations.add(visit.uri.toString(), { cacheKey, operationCache });\n                    }\n                }\n            }\n            // Override the pending value with the resolved value\n            operationCache.set(cacheKey, mappedResult);\n            for (const visit of visited) {\n                this.cacheInvalidations.add(visit.uri.toString(), { cacheKey, operationCache });\n            }\n            return mappedResult;\n        };\n    }\n    runWithCache(cacheSegment, cacheKey, fn, target, ...args) {\n        let operationCache = this.cache.get(cacheSegment);\n        if (!operationCache) {\n            operationCache = new Map();\n            this.cache.set(cacheSegment, operationCache);\n        }\n        const cached = operationCache.get(cacheKey);\n        if (cached) {\n            this.debug('%s(%s) [HIT]', cacheSegment, cacheKey);\n            // We either have a cached result or a cached promise for a result. Either way, the value\n            // is suitable as a return.\n            return cached;\n        }\n        const cacheResult = this.createStoreResultFn(operationCache, cacheKey);\n        this.debug('%s(%s) [MISS]', cacheSegment, cacheKey);\n        // Nothing is cached\n        const ret = fn.apply(target, args);\n        if (isThenable(ret)) {\n            const promiseRet = ret;\n            // Produce a promise that will only be settled once the cache has been updated accordingly.\n            const wrappedRet = promiseRet.then(cacheResult, (err) => {\n                // Delete the entry from the cache in case it was a transient failure\n                operationCache.delete(cacheKey);\n                return Promise.reject(err);\n            });\n            // Set the pending value in the cache for now\n            operationCache.set(cacheKey, wrappedRet);\n            return wrappedRet;\n        }\n        return cacheResult(ret);\n    }\n    _wrapError(err) {\n        return Object.assign(err, {\n            path: this.path.map(decodePathNode),\n        });\n    }\n    debug(...args) {\n        if (this.debugMode) {\n            if (typeof args[0] === 'string') {\n                args[0] = ' '.repeat(this.path.length) + args[0];\n            }\n            console.warn(...args);\n        }\n    }\n}\nfunction encodePathNode(operationName, uri) {\n    return `${operationName}:${uri.toString()}`;\n}\nfunction decodePathNode(node) {\n    const parts = node.split(':', 2);\n    if (parts.length !== 2) {\n        console.log('WTF', { node, parts });\n        throw new Error(`Invariant violation: Unexpected path node: '${node}'`);\n    }\n    return {\n        operationName: parts[0],\n        uri: parts[1].includes(':') ? Uri.parse(parts[1]) : parts[1],\n    };\n}\nasync function resolve(ctx, uri) {\n    const bothResolved = all([ctx.getCanonicalUrl(uri), ctx.getResolveRoot(uri), ctx.getSettings(uri)], ctx.token);\n    const [canonicalizationResult, resolveRootResult, settingsResult] = isThenable(bothResolved)\n        ? await checkCancellation(bothResolved, ctx.token)\n        : bothResolved;\n    const rootUri = resolveRootResult.uri;\n    const rootUriWithoutTrailingSlash = Uri.ensureTrailingSlash(rootUri, '');\n    if (!Uri.isPrefixOf(rootUriWithoutTrailingSlash, canonicalizationResult.uri)) {\n        throw new Error(`Unable to resolve a module whose path ${canonicalizationResult.uri.toString(true)} is above the host's root ${rootUri.toString()}`);\n    }\n    const resolveReturn = Uri.equals(rootUriWithoutTrailingSlash, canonicalizationResult.uri) ||\n        Uri.equals(rootUri, canonicalizationResult.uri)\n        ? ctx.runInChildContext('resolveAsDirectory', canonicalizationResult.uri, (ctx) => resolveAsDirectory(ctx, Uri.ensureTrailingSlash(canonicalizationResult.uri), resolveRootResult.uri, settingsResult.settings))\n        : ctx.runInChildContext('resolveAsFile', canonicalizationResult.uri, (ctx) => resolveAsFile(ctx, canonicalizationResult.uri, resolveRootResult.uri, settingsResult.settings, null));\n    const readParentPackageJsonReturn = ctx.readParentPackageJson(uri);\n    const resolveAndPackageJson = all([resolveReturn, readParentPackageJsonReturn], ctx.token);\n    const [resolveResult, readParentPackageJsonResult] = isThenable(resolveAndPackageJson)\n        ? await resolveAndPackageJson\n        : resolveAndPackageJson;\n    return {\n        ...resolveResult,\n        parentPackageJson: readParentPackageJsonResult.found\n            ? {\n                packageJson: readParentPackageJsonResult.packageJson,\n                uri: readParentPackageJsonResult.uri,\n            }\n            : undefined,\n    };\n}\nasync function resolveDependency(ctx, fromUri, spec) {\n    const parsedSpec = parseBareModuleSpec(spec);\n    if (parsedSpec) {\n        return ctx.runInChildContext('resolveBareModule', fromUri, (ctx) => resolveBareModule(ctx, fromUri, parsedSpec));\n    }\n    const relativeUri = Uri.joinPath(Uri.from({\n        ...fromUri,\n        path: dirname(fromUri.path),\n    }), spec);\n    return ctx.runInChildContext('resolveUri', relativeUri, (ctx) => resolve(ctx, relativeUri));\n}\nasync function resolveBareModule(ctx, uri, parsedSpec) {\n    let locatorName = parsedSpec.name;\n    let locatorSpec = parsedSpec.spec;\n    let locatorPath = parsedSpec.path;\n    if (!locatorSpec) {\n        const resolveRootReturn = ctx.getResolveRoot(uri);\n        const resolveRootResult = isThenable(resolveRootReturn)\n            ? await checkCancellation(resolveRootReturn, ctx.token)\n            : resolveRootReturn;\n        let nextUri = uri;\n        let maxIterations = 10;\n        while (Uri.isPrefixOf(resolveRootResult.uri, nextUri)) {\n            if (--maxIterations <= 0) {\n                throw new Error('Max iterations reached');\n            }\n            const parentPackageJsonReturn = ctx.readParentPackageJson(uri);\n            const parentPackageJsonResult = isThenable(parentPackageJsonReturn)\n                ? await checkCancellation(parentPackageJsonReturn, ctx.token)\n                : parentPackageJsonReturn;\n            if (!parentPackageJsonResult.found) {\n                throw new DependencyNotFoundError(parsedSpec.nameSpec, uri);\n            }\n            ctx.recordVisit(parentPackageJsonResult.uri, ResolverContext.VisitKind.File);\n            if (parentPackageJsonResult.packageJson.name === parsedSpec.name) {\n                // We found a parent directory that *IS* the module we're looking for\n                const directoryUri = Uri.ensureTrailingSlash(Uri.joinPath(parentPackageJsonResult.uri, '../'));\n                return ctx.runInChildContext('resolveAsDirectory', directoryUri, (ctx) => resolveAsDirectory(ctx, directoryUri, resolveRootResult.uri, ctx.settings));\n            }\n            const dependencies = {\n                ...(parentPackageJsonResult.packageJson.devDependencies || {}),\n                ...(parentPackageJsonResult.packageJson.peerDependencies || {}),\n                ...(parentPackageJsonResult.packageJson.dependencies || {}),\n            };\n            locatorSpec = dependencies[parsedSpec.name];\n            if (locatorSpec) {\n                break;\n            }\n            nextUri = Uri.joinPath(parentPackageJsonResult.uri, '..');\n            if (Uri.equals(nextUri, resolveRootResult.uri)) {\n                break;\n            }\n        }\n    }\n    if (!locatorSpec) {\n        const builtIn = NODE_CORE_SHIMS[parsedSpec.name];\n        if (builtIn) {\n            locatorName = builtIn.name;\n            locatorSpec = builtIn.spec;\n            locatorPath = builtIn.path;\n        }\n    }\n    if (!locatorSpec) {\n        throw new DependencyNotFoundError(parsedSpec.nameSpec, uri);\n    }\n    const bareModuleUriReturn = ctx.getUrlForBareModule(locatorName, locatorSpec, locatorPath);\n    const bareModuleUriResult = isThenable(bareModuleUriReturn)\n        ? await checkCancellation(bareModuleUriReturn, ctx.token)\n        : bareModuleUriReturn;\n    if (!bareModuleUriResult.found) {\n        throw new DependencyNotFoundError(parsedSpec.nameSpec, uri);\n    }\n    if (!bareModuleUriResult.uri) {\n        // TODO: Inject empty module\n        throw new EntryExcludedError(parsedSpec.nameSpec);\n    }\n    const resolveReturn = ctx.resolveUri(bareModuleUriResult.uri);\n    const resolveResult = isThenable(resolveReturn)\n        ? await checkCancellation(resolveReturn, ctx.token)\n        : resolveReturn;\n    return resolveResult;\n}\n(function (ResolverContext) {\n    let VisitKind;\n    (function (VisitKind) {\n        VisitKind[\"Directory\"] = \"Directory\";\n        VisitKind[\"File\"] = \"File\";\n    })(VisitKind = ResolverContext.VisitKind || (ResolverContext.VisitKind = {}));\n})(ResolverContext || (ResolverContext = {}));\nasync function resolveAsDirectory(ctx, uri, rootUri, settings) {\n    ctx.recordVisit(uri, ResolverContext.VisitKind.Directory);\n    const listEntriesReturn = ctx.listEntries(uri);\n    const listEntriesResult = isThenable(listEntriesReturn)\n        ? await checkCancellation(listEntriesReturn, ctx.token)\n        : listEntriesReturn;\n    let mainPathname = 'index';\n    // Step 1: Look for a package.json with an main field\n    const packageJsonUri = Uri.joinPath(uri, './package.json');\n    ctx.recordVisit(packageJsonUri, ResolverContext.VisitKind.File);\n    const packageJsonEntry = listEntriesResult.entries.find((entry) => entry.type === ResolverStrategy.EntryKind.File && Uri.equals(packageJsonUri, entry.uri));\n    let packageJson = null;\n    if (packageJsonEntry) {\n        const packageJsonContentReturn = ctx.readFileContent(packageJsonUri);\n        const packageJsonContentResult = isThenable(packageJsonContentReturn)\n            ? await checkCancellation(packageJsonContentReturn, ctx.token)\n            : packageJsonContentReturn;\n        packageJson = parseBufferAsPartialPackageJson(ctx.decoder, packageJsonContentResult.content, uri.toString());\n        for (const packageMain of settings.packageMain) {\n            const pathname = packageJson[packageMain];\n            if (typeof pathname === 'string') {\n                mainPathname = pathname;\n                break;\n            }\n        }\n    }\n    const fileUri = Uri.joinPath(uri, mainPathname);\n    return ctx.runInChildContext('resolveAsFile', uri, (ctx) => resolveAsFile(ctx, fileUri, rootUri, settings, packageJson));\n}\nasync function resolveAsFile(ctx, uri, rootUri, settings, packageJson, ignoreBrowserOverrides = false) {\n    if (uri.path === '' || uri.path === '/') {\n        throw new TypeError(`Unable to resolve the root as a file: ${uri.toString()}`);\n    }\n    ctx.recordVisit(uri, ResolverContext.VisitKind.File);\n    const browserOverrides = new Map();\n    if (packageJson === null) {\n        // The parent package.json is only interesting if we are going to look at the `browser`\n        // field and then consider browser mapping overrides in there.\n        const parentPackageJsonResult = settings.packageMain.includes('browser') && !ignoreBrowserOverrides\n            ? await checkCancellation(ctx.runInChildContext('readParentPackageJsonInternal', uri, (ctx) => readParentPackageJsonInternal(ctx, uri, rootUri, { uriIsCanonicalized: true })), ctx.token)\n            : undefined;\n        if (parentPackageJsonResult && parentPackageJsonResult.found) {\n            ctx.recordVisit(parentPackageJsonResult.uri, ResolverContext.VisitKind.File);\n            packageJson = parentPackageJsonResult.packageJson;\n            if (parentPackageJsonResult.packageJson.browser &&\n                typeof parentPackageJsonResult.packageJson.browser === 'object') {\n                const browserMap = parentPackageJsonResult.packageJson.browser;\n                const packageJsonDir = Uri.joinPath(parentPackageJsonResult.uri, '..');\n                for (const entry in browserMap) {\n                    const impliedUri = Uri.joinPath(packageJsonDir, entry);\n                    const targetSpec = browserMap[entry];\n                    const target = targetSpec === false ? false : Uri.joinPath(packageJsonDir, targetSpec);\n                    if (Uri.equals(impliedUri, uri)) {\n                        if (target === false) {\n                            return {\n                                found: false,\n                                uri: null,\n                            };\n                        }\n                        // console.warn('REMAPPED %s to %s', url, target);\n                        // We found an exact match so let's make sure we resolve the re-mapped file but\n                        // also that we don't go through the browser overrides rodeo again.\n                        return ctx.runInChildContext('resolveAsFile', target, (ctx) => resolveAsFile(ctx, target, rootUri, settings, packageJson, true));\n                    }\n                    browserOverrides.set(impliedUri.toString(), target);\n                }\n            }\n        }\n    }\n    const containingDirUri = Uri.ensureTrailingSlash(Uri.joinPath(uri, '..'));\n    const filename = basename(uri.path);\n    const entriesReturn = ctx.listEntries(containingDirUri);\n    const entriesResult = isThenable(entriesReturn)\n        ? await checkCancellation(entriesReturn, ctx.token)\n        : entriesReturn;\n    const entryDirectoryMap = new Map();\n    const entryFileMap = new Map();\n    for (const entry of entriesResult.entries) {\n        if (Uri.equals(entry.uri, uri) && entry.type == ResolverStrategy.EntryKind.File) {\n            // Found an exact match\n            return {\n                found: true,\n                rootUri,\n                uri,\n            };\n        }\n        if (entry.type === ResolverStrategy.EntryKind.Directory) {\n            const childFilename = Uri.getFirstPathSegmentAfterPrefix(entry.uri, containingDirUri);\n            entryDirectoryMap.set(childFilename, entry);\n        }\n        else if (entry.type === ResolverStrategy.EntryKind.File) {\n            const childFilename = basename(entry.uri.path);\n            entryFileMap.set(childFilename, entry);\n        }\n    }\n    // Look for browser overrides\n    for (const ext of settings.extensions) {\n        const hrefWithExtensionUri = uri.with({ path: `${uri.path}${ext}` });\n        const hrefWithExtension = hrefWithExtensionUri.toString();\n        const mapping = browserOverrides.get(hrefWithExtension);\n        ctx.recordVisit(hrefWithExtensionUri, ResolverContext.VisitKind.File);\n        if (mapping === false) {\n            // console.warn('REMAPPED %s to undefined', url);\n            return {\n                found: true,\n                rootUri,\n                uri: null,\n            };\n        }\n        else if (mapping) {\n            // console.warn('REMAPPED %s to %s', url, mapping);\n            return ctx.runInChildContext('resolveAsFile', mapping, (ctx) => resolveAsFile(ctx, mapping, rootUri, settings, packageJson, true));\n        }\n        const match = entryFileMap.get(`${filename}${ext}`);\n        if (match) {\n            if (match.type !== ResolverStrategy.EntryKind.File) {\n                continue;\n            }\n            return {\n                found: true,\n                rootUri,\n                uri: match.uri,\n            };\n        }\n    }\n    // First, attempt to find a matching file or directory\n    const match = entryDirectoryMap.get(filename);\n    if (match) {\n        if (match.type !== ResolverStrategy.EntryKind.Directory) {\n            throw new Error(`Invariant violation ${match.type} is unexpected`);\n        }\n        return ctx.runInChildContext('resolveAsDirectory', match.uri, (ctx) => resolveAsDirectory(ctx, Uri.ensureTrailingSlash(match.uri), rootUri, settings));\n    }\n    throw new EntryNotFoundError(uri);\n}\nasync function readParentPackageJson(ctx, uri) {\n    const canonicalizationReturn = ctx.getCanonicalUrl(uri);\n    const resolveRootReturn = ctx.getResolveRoot(uri);\n    const bothResolved = all([canonicalizationReturn, resolveRootReturn], ctx.token);\n    const [canonicalizationResult, resolveRootResult] = isThenable(bothResolved)\n        ? await checkCancellation(bothResolved, ctx.token)\n        : bothResolved;\n    const readReturn = ctx.runInChildContext('readParentPackageJsonInternal', canonicalizationResult.uri, (ctx) => readParentPackageJsonInternal(ctx, canonicalizationResult.uri, resolveRootResult.uri, {\n        uriIsCanonicalized: true,\n    }));\n    const readResult = isThenable(readReturn) ? await readReturn : readReturn;\n    if (readResult.found && readResult.visitedDirs) {\n        const visitedDirs = readResult.visitedDirs;\n        delete readResult.visitedDirs;\n        readResult[CACHE] = visitedDirs.map((uri) => [uri.toString(), { ...readResult, uri }]);\n    }\n    return readResult;\n}\nasync function readParentPackageJsonInternal(ctx, uri, rootUri, options) {\n    if (!options.uriIsCanonicalized) {\n        const canonicalizationReturn = ctx.getCanonicalUrl(uri);\n        const canonicalizationResult = isThenable(canonicalizationReturn)\n            ? await checkCancellation(canonicalizationReturn, ctx.token)\n            : canonicalizationReturn;\n        uri = canonicalizationResult.uri;\n    }\n    const hostRootHref = Uri.ensureTrailingSlash(rootUri);\n    const containingDirUrl = Uri.ensureTrailingSlash(Uri.joinPath(uri, '..'));\n    const visitedDirs = [];\n    const readPackageJsonOrRecurse = async (ctx, dir) => {\n        if (!Uri.isPrefixOf(hostRootHref, dir)) {\n            // Terminal condition for recursion\n            return {\n                found: false,\n                packageJson: null,\n                uri: null,\n            };\n        }\n        ctx.recordVisit(dir, ResolverContext.VisitKind.Directory);\n        const entriesReturn = ctx.listEntries(dir);\n        const entriesResult = isThenable(entriesReturn)\n            ? await checkCancellation(entriesReturn, ctx.token)\n            : entriesReturn;\n        const packageJsonUri = Uri.joinPath(dir, 'package.json');\n        const packageJsonEntry = entriesResult.entries.find((entry) => entry.type === ResolverStrategy.EntryKind.File && Uri.equals(entry.uri, packageJsonUri));\n        ctx.recordVisit(packageJsonUri, ResolverContext.VisitKind.File);\n        if (packageJsonEntry) {\n            // Found! Let's try to parse\n            try {\n                const parentPackageJsonContentReturn = ctx.readFileContent(packageJsonUri);\n                const parentPackageJsonContentResult = isThenable(parentPackageJsonContentReturn)\n                    ? await checkCancellation(parentPackageJsonContentReturn, ctx.token)\n                    : parentPackageJsonContentReturn;\n                const packageJson = parseBufferAsPackageJson(ctx.decoder, parentPackageJsonContentResult.content, packageJsonUri.toString());\n                return { found: true, packageJson, uri: packageJsonUri, visitedDirs };\n            }\n            catch (err) {\n                if (err instanceof CanceledError || (err && err.name === 'CanceledError')) {\n                    throw err;\n                }\n                // TODO: Maybe issue some warning?\n            }\n        }\n        // Not found here, let's try one up\n        const parentDir = Uri.ensureTrailingSlash(Uri.joinPath(dir, '..'));\n        // Skip infinite recursion\n        if (Uri.equals(dir, parentDir) || Uri.isPrefixOf(dir, parentDir)) {\n            return {\n                found: false,\n                packageJson: null,\n                uri: null,\n            };\n        }\n        visitedDirs.push(dir);\n        return ctx.runInChildContext('readPackageJsonOrRecurse', parentDir, (ctx) => readPackageJsonOrRecurse(ctx, parentDir));\n    };\n    if (Uri.equals(uri, containingDirUrl) || Uri.isPrefixOf(uri, containingDirUrl)) {\n        return {\n            found: false,\n            packageJson: null,\n            uri: null,\n        };\n    }\n    return ctx.runInChildContext('readPackageJsonOrRecurse', containingDirUrl, (ctx) => readPackageJsonOrRecurse(ctx, containingDirUrl));\n}\n\nclass Resolver {\n    constructor(strategy, settings) {\n        this.disposed = false;\n        this.tokenSource = new CancellationTokenSource();\n        this.settings = settings;\n        this.strategy = strategy;\n        this.rootCtx = ResolverContext.create(this, this.strategy, this.settings, this.tokenSource.token, { debug: settings.debug });\n    }\n    decode(buf) {\n        if (typeof buf === 'string') {\n            return buf;\n        }\n        return this.rootCtx.decoder.decode(buf);\n    }\n    dispose() {\n        this.disposed = true;\n        return this.rootCtx.dispose();\n    }\n    getCanonicalUrl(uri) {\n        if (this.disposed) {\n            throw new Error('Resolver has been disposed');\n        }\n        return this.rootCtx.runInIsolatedContext('Resolver.getCanonicalUrl', uri, (ctx) => ctx.getCanonicalUrl(typeof uri === 'string' ? Uri.parse(uri) : uri));\n    }\n    getResolveRoot(uri) {\n        if (this.disposed) {\n            throw new Error('Resolver has been disposed');\n        }\n        return this.rootCtx.runInIsolatedContext('Resolver.getResolveRoot', uri, (ctx) => ctx.getResolveRoot(typeof uri === 'string' ? Uri.parse(uri) : uri));\n    }\n    getSettings(uri) {\n        if (this.disposed) {\n            throw new Error('Resolver has been disposed');\n        }\n        return this.rootCtx.runInIsolatedContext('Resolver.getSettings', uri, (ctx) => ctx.getSettings(typeof uri === 'string' ? Uri.parse(uri) : uri));\n    }\n    getUrlForBareModule(name, spec, path) {\n        if (this.disposed) {\n            throw new Error('Resolver has been disposed');\n        }\n        return this.rootCtx.runInIsolatedContext('Resolver.getUrlForBareModule', `${name}|${spec}|${path}`, (ctx) => ctx.getUrlForBareModule(name, spec, path));\n    }\n    invalidate(uri) {\n        if (this.disposed) {\n            throw new Error('Resolver has been disposed');\n        }\n        return this.rootCtx.runInIsolatedContext('Resolver.invalidate', uri, (ctx) => ctx.invalidate(typeof uri === 'string' ? Uri.parse(uri) : uri));\n    }\n    listEntries(uri) {\n        if (this.disposed) {\n            throw new Error('Resolver has been disposed');\n        }\n        return this.rootCtx.runInIsolatedContext('Resolver.listEntries', uri, (ctx) => ctx.listEntries(typeof uri === 'string' ? Uri.parse(uri) : uri));\n    }\n    readFileContent(uri) {\n        if (this.disposed) {\n            throw new Error('Resolver has been disposed');\n        }\n        return this.rootCtx.runInIsolatedContext('Resolver.readFileContent', uri, (ctx) => ctx.readFileContent(typeof uri === 'string' ? Uri.parse(uri) : uri));\n    }\n    readParentPackageJson(uri) {\n        if (this.disposed) {\n            throw new Error('Resolver has been disposed');\n        }\n        return this.rootCtx.runInIsolatedContext('Resolver.readParentPackageJson', uri, (ctx) => ctx.readParentPackageJson(typeof uri === 'string' ? Uri.parse(uri) : uri));\n    }\n    resolve(spec, fromUri) {\n        if (this.disposed) {\n            throw new Error('Resolver has been disposed');\n        }\n        if (Uri.isUri(spec)) {\n            return this.rootCtx.runInIsolatedContext('Resolver.resolveUri', spec, (ctx) => ctx.resolveUri(spec));\n        }\n        if (!fromUri) {\n            throw new Error('When calling Resolver.resolve with a string spec, a second \"fromUri\" argument is required');\n        }\n        return this.rootCtx.runInIsolatedContext('Resolver.resolve', `${fromUri ? fromUri.toString() : ''}|${spec}`, (ctx) => ctx.resolve(spec, fromUri));\n    }\n}\n\nconst version$1 = '0.45.1';\n\nexport { AbstractResolverStrategy, AbstractResolverStrategyWithRoot, Resolver, ResolverContext, ResolverStrategy, version$1 as version };\n//# sourceMappingURL=index.js.map\n"],"sourceRoot":""}