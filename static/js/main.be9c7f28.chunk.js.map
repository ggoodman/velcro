{"version":3,"sources":["../../../src/base64.ts","../../../src/error.ts","../../../src/path.ts","../../../src/uri.ts","velcro/monaco.ts","velcro/types.ts","velcro/velcroWorker.ts","lib/svelte.language.ts","lib/EditorManager.ts","playground/Editor.tsx","playground/Preview.tsx","lib/hooks.ts","playground/Sidebar.tsx","playground/Playground.tsx","templates/svelte.ts","useServiceWorker.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["Base64","Error","decode","global","data","from","toString","atob","decodeURIComponent","escape","_data","encode","btoa","unescape","encodeURIComponent","ErrorInvalidArgType","name","expected","actual","determiner","indexOf","replace","type","msg","code","validateString","value","isPosixPathSeparator","normalizeString","path","allowAboveRoot","separator","isPathSeparator","res","lastSegmentLength","lastSlash","dots","i","length","charCodeAt","lastSlashIndex","lastIndexOf","slice","posix","resolve","resolvedPath","resolvedAbsolute","process","cwd","normalize","isAbsolute","trailingSeparator","join","joined","arg","undefined","relative","to","fromEnd","fromLen","toLen","lastCommonSep","fromCode","out","toNamespacedPath","dirname","hasRoot","end","matchedSlash","basename","ext","start","extIdx","firstNonSlashEnd","extname","startDot","startPart","preDotState","format","sep","pathObject","dir","root","base","bind","parse","ret","delimiter","win32","_schemePattern","_singleSlashStart","_doubleSlashStart","_validateUri","_strict","scheme","authority","query","fragment","test","_schemeFix","_referenceResolution","_slash","_regexp","Uri","schemeOrData","this","change","_URI","skipEncoding","_asFormatted","uriToFsPath","uri","trailingSlash","with","TRAILING_SLASH_RX","l","r","child","parent","childHref","parentHref","parentOffset","charAt","prefix","startsWith","thing","fsPath","match","exec","percentDecode","idx","substring","components","pathFragment","newPath","result","_formatted","external","_fsPath","_sep","_pathSepMarker","$mid","encodeTable","encodeURIComponentFast","uriComponent","allowSlash","nativeEncodePos","pos","substr","escaped","encodeURIComponentMinimal","keepDriveLetterCasing","toLowerCase","encoder","userinfo","String","fromCharCode","_rEncodedAsHex","str","decodeURIComponentGraceful","trackMonaco","monaco","disposer","DisposableStore","worker","Worker","trackModel","model","onWillDispose","message","event","href","postMessage","disposerReference","dispose","add","onDidChangeContent","content","getValue","postMessageEmitter","Emitter","postMessageQueue","Event","debounce","last","Map","set","events","values","fire","editor","getModels","forEach","onDidCreateModel","terminate","emitter","addEventListener","e","WorkerState","is","FileCreateEvent","z","FileRemoveEvent","FileUpdateEvent","EditorEvent","BuiltState","state","int","BuildingState","completed","pending","ErrorState","error","InitialState","module","exports","EMPTY_ELEMENTS","conf","wordPattern","comments","blockComment","brackets","autoClosingPairs","open","close","surroundingPairs","onEnterRules","beforeText","RegExp","afterText","action","indentAction","Monaco","IndentAction","IndentOutdent","Indent","language","defaultToken","tokenPostfix","ignoreCase","tokenizer","token","next","doctype","comment","otherTag","script","nextEmbedded","scriptAfterType","scriptAfterTypeEquals","switchTo","scriptWithCustomType","scriptEmbedded","style","styleAfterType","styleAfterTypeEquals","styleWithCustomType","styleEmbedded","EditorManager","options","disposableStore","initialPath","viewState","WeakMap","onWillFocusModelEmitter","onDidChangeEmitter","typescript","typescriptDefaults","setEagerModelSync","setMaximumWorkerIdleTime","setCompilerOptions","allowJs","allowNonTsExtensions","allowSyntheticDefaultImports","baseUrl","checkJs","esModuleInterop","experimentalDecorators","inlineSourceMap","inlineSources","isolatedModules","jsx","JsxEmit","React","lib","ModuleKind","CommonJS","moduleResolution","ModuleResolutionKind","NodeJs","noEmit","outDir","resolveJsonModule","rootDir","sourceMap","target","ScriptTarget","ES2015","typeRoots","setDiagnosticsOptions","noSemanticValidation","noSyntaxValidation","register","id","extensions","mimetypes","setLanguageConfiguration","SvelteLanguage","setMonarchTokensProvider","files","pathname","createModel","inferLanguage","file","err","getModel","getModelByHref","focusModel","setModel","lineNumber","revealLineInCenter","ScrollType","Smooth","setPosition","column","columnNumber","markers","setModelMarkers","focus","getModelByPath","_","el","create","automaticLayout","minimap","enabled","showUnused","scrollBeyondLastLine","theme","wordWrap","wrappingIndent","onDidDispose","onDidChangeModel","newModelUrl","get","restoreViewState","onDidBlurEditorText","saveViewState","focusPath","EditorManagerContext","createContext","Editor","className","useRef","editorManager","useContext","useEffect","current","mount","ref","EntryKind","PreviewProgress","props","total","Math","round","PreviewIframeWrap","PreviewWrap","PreviewMessageError","PreviewMessageErrorText","isInternal","PreviewMessages","PreviewMessageLine","line","text","PreviewMessage","lines","map","key","Preview","previewWrapRef","previewIframeRef","useState","buildState","setBuildState","buildProgress","setBuildProgress","onMessage","contentWindow","source","entry","window","removeEventListener","monacoIntegration","onStateChange","console","debug","Date","now","iframe","document","createElement","display","src","appendChild","onLoad","onError","remove","once","Entry","modelFocused","color","cursor","backgroundColor","CreateEntry","SidebarFileDelete","Button","StyledTooltip","SidebarFile","activeModel","workbench","setActiveModel","disposable","trackEditor","onDidFocusEditorText","hasTextFocus","onDidCreateEditor","useActiveModel","tooltip","useTooltipState","gutter","onClick","TooltipReference","as","role","aria-label","Tooltip","Sidebar","entries","sortEntries","models","sort","a","b","initialEntries","reduce","modelUri","nestedPath","nextDirIdx","push","Directory","File","setEntries","find","onWillDisposeModel","findIndex","splice","useDirectory","filename","prompt","onClickCreate","PlaygroundCmp","project","Provider","Playground","JSON","stringify","version","dependencies","svelte","trim","ServiceWorkerContext","ServiceWorkerProvider","waitingServiceWorker","assetsUpdateReady","assetsCached","useMemo","updateAssets","location","reload","PlaygroundWrapper","StatusBarItem","StatusBarStyles","AppWrapper","Title","Subtitle","Link","Links","Header","globalCss","css","App","CssBaseline","styles","rel","Boolean","hostname","navigator","serviceWorker","ready","then","registration","unregister","catch","ReactDOM","render","getElementById"],"mappings":"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","file":"static/js/main.be9c7f28.chunk.js","sourcesContent":["type Buffer = {\n  from(\n    buf: BufferSource | string,\n    encoding?: 'base64'\n  ): {\n    toString(encoding: 'base64' | 'utf-8'): string;\n  };\n};\n\nexport namespace Base64 {\n  export const decode =\n    typeof global === 'object' && typeof global['Buffer'] === 'function'\n      ? (data: string) => (global['Buffer'] as Buffer).from(data, 'base64').toString('utf-8')\n      : typeof atob === 'function'\n      ? (data: string) => decodeURIComponent(escape(atob(data)))\n      : (_data: string) => {\n          throw new Error(\n            'The environment has neither the Buffer nor btoa functions. Please consider polyfilling one of these apis.'\n          );\n        };\n\n  export const encode =\n    typeof global === 'object' && typeof global['Buffer'] === 'function'\n      ? (data: string) => (global['Buffer'] as Buffer).from(data).toString('base64')\n      : typeof btoa === 'function'\n      ? (data: string) => btoa(unescape(encodeURIComponent(data)))\n      : (_data: string) => {\n          throw new Error(\n            'The environment has neither the Buffer nor btoa functions. Please consider polyfilling one of these apis.'\n          );\n        };\n}\n","import type { Uri } from './uri';\n\nabstract class BaseError extends Error {\n  readonly name = this.constructor.name;\n}\n\nexport class AmbiguousModuleError extends BaseError {}\n\nexport class CanceledError extends BaseError {}\n\nexport class EntryExcludedError extends BaseError {\n  constructor(uri: { toString(): string }) {\n    super(`Entry was excluded by current configuration '${uri.toString()}'`);\n  }\n}\n\nexport class EntryNotFoundError extends BaseError {\n  constructor(uri: { toString(): string }) {\n    super(`Unable to resolve '${uri.toString()}'`);\n  }\n}\n\nexport class DependencyNotFoundError extends EntryNotFoundError {\n  constructor(spec: string, parentUri: { toString(): string }) {\n    super(`The dependency '${spec}' of '${parentUri.toString()}' was not found`);\n  }\n}\n\nexport class NotResolvableError extends BaseError {}\n\nexport class ParseError extends BaseError {\n  constructor(readonly uri: Uri, message: string) {\n    super(`Parsing failed for '${uri.toString()}': ${message}`);\n  }\n}\n\nexport function isCanceledError(err: unknown): err is CanceledError {\n  return err instanceof CanceledError || (err && (err as any).name === 'CanceledError');\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n// NOTE: VSCode's copy of nodejs path library to be usable in common (non-node) namespace\n// Copied from: https://github.com/nodejs/node/blob/v12.8.1/lib/path.js\n\n/**\n * Copyright Joyent, Inc. and other Node contributors.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to permit\n * persons to whom the Software is furnished to do so, subject to the\n * following conditions:\n *\n * The above copyright notice and this permission notice shall be included\n * in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n * NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n * USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\nconst CHAR_DOT = 46; /* . */\nconst CHAR_FORWARD_SLASH = 47; /* / */\n\nclass ErrorInvalidArgType extends Error {\n  code: 'ERR_INVALID_ARG_TYPE';\n  constructor(name: string, expected: string, actual: any) {\n    // determiner: 'must be' or 'must not be'\n    let determiner;\n    if (typeof expected === 'string' && expected.indexOf('not ') === 0) {\n      determiner = 'must not be';\n      expected = expected.replace(/^not /, '');\n    } else {\n      determiner = 'must be';\n    }\n\n    const type = name.indexOf('.') !== -1 ? 'property' : 'argument';\n    let msg = `The \"${name}\" ${type} ${determiner} of type ${expected}`;\n\n    msg += `. Received type ${typeof actual}`;\n    super(msg);\n\n    this.code = 'ERR_INVALID_ARG_TYPE';\n  }\n}\n\nfunction validateString(value: string, name: string) {\n  if (typeof value !== 'string') {\n    throw new ErrorInvalidArgType(name, 'string', value);\n  }\n}\n\nfunction isPosixPathSeparator(code: number | undefined) {\n  return code === CHAR_FORWARD_SLASH;\n}\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeString(\n  path: string,\n  allowAboveRoot: boolean,\n  separator: string,\n  isPathSeparator: (code?: number) => boolean\n) {\n  let res = '';\n  let lastSegmentLength = 0;\n  let lastSlash = -1;\n  let dots = 0;\n  let code = 0;\n  for (let i = 0; i <= path.length; ++i) {\n    if (i < path.length) {\n      code = path.charCodeAt(i);\n    } else if (isPathSeparator(code)) {\n      break;\n    } else {\n      code = CHAR_FORWARD_SLASH;\n    }\n\n    if (isPathSeparator(code)) {\n      if (lastSlash === i - 1 || dots === 1) {\n        // NOOP\n      } else if (dots === 2) {\n        if (\n          res.length < 2 ||\n          lastSegmentLength !== 2 ||\n          res.charCodeAt(res.length - 1) !== CHAR_DOT ||\n          res.charCodeAt(res.length - 2) !== CHAR_DOT\n        ) {\n          if (res.length > 2) {\n            const lastSlashIndex = res.lastIndexOf(separator);\n            if (lastSlashIndex === -1) {\n              res = '';\n              lastSegmentLength = 0;\n            } else {\n              res = res.slice(0, lastSlashIndex);\n              lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);\n            }\n            lastSlash = i;\n            dots = 0;\n            continue;\n          } else if (res.length !== 0) {\n            res = '';\n            lastSegmentLength = 0;\n            lastSlash = i;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          res += res.length > 0 ? `${separator}..` : '..';\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (res.length > 0) {\n          res += `${separator}${path.slice(lastSlash + 1, i)}`;\n        } else {\n          res = path.slice(lastSlash + 1, i);\n        }\n        lastSegmentLength = i - lastSlash - 1;\n      }\n      lastSlash = i;\n      dots = 0;\n    } else if (code === CHAR_DOT && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\n\nfunction _format(sep: string, pathObject: ParsedPath) {\n  if (pathObject === null || typeof pathObject !== 'object') {\n    throw new ErrorInvalidArgType('pathObject', 'Object', pathObject);\n  }\n  const dir = pathObject.dir || pathObject.root;\n  const base = pathObject.base || `${pathObject.name || ''}${pathObject.ext || ''}`;\n  if (!dir) {\n    return base;\n  }\n  return dir === pathObject.root ? `${dir}${base}` : `${dir}${sep}${base}`;\n}\n\nexport interface ParsedPath {\n  root: string;\n  dir: string;\n  base: string;\n  ext: string;\n  name: string;\n}\n\nexport interface IPath {\n  normalize(path: string): string;\n  isAbsolute(path: string): boolean;\n  join(...paths: string[]): string;\n  resolve(...pathSegments: string[]): string;\n  relative(from: string, to: string): string;\n  dirname(path: string): string;\n  basename(path: string, ext?: string): string;\n  extname(path: string): string;\n  format(pathObject: ParsedPath): string;\n  parse(path: string): ParsedPath;\n  toNamespacedPath(path: string): string;\n  sep: '\\\\' | '/';\n  delimiter: string;\n  win32: IPath | null;\n  posix: IPath | null;\n}\n\n// export const win32: IPath = {\n// \t// path.resolve([from ...], to)\n// \tresolve(...pathSegments: string[]): string {\n// \t\tlet resolvedDevice = '';\n// \t\tlet resolvedTail = '';\n// \t\tlet resolvedAbsolute = false;\n\n// \t\tfor (let i = pathSegments.length - 1; i >= -1; i--) {\n// \t\t\tlet path;\n// \t\t\tif (i >= 0) {\n// \t\t\t\tpath = pathSegments[i];\n// \t\t\t\tvalidateString(path, 'path');\n\n// \t\t\t\t// Skip empty entries\n// \t\t\t\tif (path.length === 0) {\n// \t\t\t\t\tcontinue;\n// \t\t\t\t}\n// \t\t\t} else if (resolvedDevice.length === 0) {\n// \t\t\t\tpath = process.cwd();\n// \t\t\t} else {\n// \t\t\t\t// Windows has the concept of drive-specific current working\n// \t\t\t\t// directories. If we've resolved a drive letter but not yet an\n// \t\t\t\t// absolute path, get cwd for that drive, or the process cwd if\n// \t\t\t\t// the drive cwd is not available. We're sure the device is not\n// \t\t\t\t// a UNC path at this points, because UNC paths are always absolute.\n// \t\t\t\tpath = (process.env as any)[`=${resolvedDevice}`] || process.cwd();\n\n// \t\t\t\t// Verify that a cwd was found and that it actually points\n// \t\t\t\t// to our drive. If not, default to the drive's root.\n// \t\t\t\tif (path === undefined ||\n// \t\t\t\t\tpath.slice(0, 2).toLowerCase() !== resolvedDevice.toLowerCase() &&\n// \t\t\t\t\tpath.charCodeAt(2) === CHAR_BACKWARD_SLASH) {\n// \t\t\t\t\tpath = `${resolvedDevice}\\\\`;\n// \t\t\t\t}\n// \t\t\t}\n\n// \t\t\tconst len = path.length;\n// \t\t\tlet rootEnd = 0;\n// \t\t\tlet device = '';\n// \t\t\tlet isAbsolute = false;\n// \t\t\tconst code = path.charCodeAt(0);\n\n// \t\t\t// Try to match a root\n// \t\t\tif (len === 1) {\n// \t\t\t\tif (isPathSeparator(code)) {\n// \t\t\t\t\t// `path` contains just a path separator\n// \t\t\t\t\trootEnd = 1;\n// \t\t\t\t\tisAbsolute = true;\n// \t\t\t\t}\n// \t\t\t} else if (isPathSeparator(code)) {\n// \t\t\t\t// Possible UNC root\n\n// \t\t\t\t// If we started with a separator, we know we at least have an\n// \t\t\t\t// absolute path of some kind (UNC or otherwise)\n// \t\t\t\tisAbsolute = true;\n\n// \t\t\t\tif (isPathSeparator(path.charCodeAt(1))) {\n// \t\t\t\t\t// Matched double path separator at beginning\n// \t\t\t\t\tlet j = 2;\n// \t\t\t\t\tlet last = j;\n// \t\t\t\t\t// Match 1 or more non-path separators\n// \t\t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n// \t\t\t\t\t\tj++;\n// \t\t\t\t\t}\n// \t\t\t\t\tif (j < len && j !== last) {\n// \t\t\t\t\t\tconst firstPart = path.slice(last, j);\n// \t\t\t\t\t\t// Matched!\n// \t\t\t\t\t\tlast = j;\n// \t\t\t\t\t\t// Match 1 or more path separators\n// \t\t\t\t\t\twhile (j < len && isPathSeparator(path.charCodeAt(j))) {\n// \t\t\t\t\t\t\tj++;\n// \t\t\t\t\t\t}\n// \t\t\t\t\t\tif (j < len && j !== last) {\n// \t\t\t\t\t\t\t// Matched!\n// \t\t\t\t\t\t\tlast = j;\n// \t\t\t\t\t\t\t// Match 1 or more non-path separators\n// \t\t\t\t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n// \t\t\t\t\t\t\t\tj++;\n// \t\t\t\t\t\t\t}\n// \t\t\t\t\t\t\tif (j === len || j !== last) {\n// \t\t\t\t\t\t\t\t// We matched a UNC root\n// \t\t\t\t\t\t\t\tdevice = `\\\\\\\\${firstPart}\\\\${path.slice(last, j)}`;\n// \t\t\t\t\t\t\t\trootEnd = j;\n// \t\t\t\t\t\t\t}\n// \t\t\t\t\t\t}\n// \t\t\t\t\t}\n// \t\t\t\t} else {\n// \t\t\t\t\trootEnd = 1;\n// \t\t\t\t}\n// \t\t\t} else if (isWindowsDeviceRoot(code) &&\n// \t\t\t\tpath.charCodeAt(1) === CHAR_COLON) {\n// \t\t\t\t// Possible device root\n// \t\t\t\tdevice = path.slice(0, 2);\n// \t\t\t\trootEnd = 2;\n// \t\t\t\tif (len > 2 && isPathSeparator(path.charCodeAt(2))) {\n// \t\t\t\t\t// Treat separator following drive name as an absolute path\n// \t\t\t\t\t// indicator\n// \t\t\t\t\tisAbsolute = true;\n// \t\t\t\t\trootEnd = 3;\n// \t\t\t\t}\n// \t\t\t}\n\n// \t\t\tif (device.length > 0) {\n// \t\t\t\tif (resolvedDevice.length > 0) {\n// \t\t\t\t\tif (device.toLowerCase() !== resolvedDevice.toLowerCase()) {\n// \t\t\t\t\t\t// This path points to another device so it is not applicable\n// \t\t\t\t\t\tcontinue;\n// \t\t\t\t\t}\n// \t\t\t\t} else {\n// \t\t\t\t\tresolvedDevice = device;\n// \t\t\t\t}\n// \t\t\t}\n\n// \t\t\tif (resolvedAbsolute) {\n// \t\t\t\tif (resolvedDevice.length > 0) {\n// \t\t\t\t\tbreak;\n// \t\t\t\t}\n// \t\t\t} else {\n// \t\t\t\tresolvedTail = `${path.slice(rootEnd)}\\\\${resolvedTail}`;\n// \t\t\t\tresolvedAbsolute = isAbsolute;\n// \t\t\t\tif (isAbsolute && resolvedDevice.length > 0) {\n// \t\t\t\t\tbreak;\n// \t\t\t\t}\n// \t\t\t}\n// \t\t}\n\n// \t\t// At this point the path should be resolved to a full absolute path,\n// \t\t// but handle relative paths to be safe (might happen when process.cwd()\n// \t\t// fails)\n\n// \t\t// Normalize the tail path\n// \t\tresolvedTail = normalizeString(resolvedTail, !resolvedAbsolute, '\\\\',\n// \t\t\tisPathSeparator);\n\n// \t\treturn resolvedAbsolute ?\n// \t\t\t`${resolvedDevice}\\\\${resolvedTail}` :\n// \t\t\t`${resolvedDevice}${resolvedTail}` || '.';\n// \t},\n\n// \tnormalize(path: string): string {\n// \t\tvalidateString(path, 'path');\n// \t\tconst len = path.length;\n// \t\tif (len === 0) {\n// \t\t\treturn '.';\n// \t\t}\n// \t\tlet rootEnd = 0;\n// \t\tlet device;\n// \t\tlet isAbsolute = false;\n// \t\tconst code = path.charCodeAt(0);\n\n// \t\t// Try to match a root\n// \t\tif (len === 1) {\n// \t\t\t// `path` contains just a single char, exit early to avoid\n// \t\t\t// unnecessary work\n// \t\t\treturn isPosixPathSeparator(code) ? '\\\\' : path;\n// \t\t}\n// \t\tif (isPathSeparator(code)) {\n// \t\t\t// Possible UNC root\n\n// \t\t\t// If we started with a separator, we know we at least have an absolute\n// \t\t\t// path of some kind (UNC or otherwise)\n// \t\t\tisAbsolute = true;\n\n// \t\t\tif (isPathSeparator(path.charCodeAt(1))) {\n// \t\t\t\t// Matched double path separator at beginning\n// \t\t\t\tlet j = 2;\n// \t\t\t\tlet last = j;\n// \t\t\t\t// Match 1 or more non-path separators\n// \t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n// \t\t\t\t\tj++;\n// \t\t\t\t}\n// \t\t\t\tif (j < len && j !== last) {\n// \t\t\t\t\tconst firstPart = path.slice(last, j);\n// \t\t\t\t\t// Matched!\n// \t\t\t\t\tlast = j;\n// \t\t\t\t\t// Match 1 or more path separators\n// \t\t\t\t\twhile (j < len && isPathSeparator(path.charCodeAt(j))) {\n// \t\t\t\t\t\tj++;\n// \t\t\t\t\t}\n// \t\t\t\t\tif (j < len && j !== last) {\n// \t\t\t\t\t\t// Matched!\n// \t\t\t\t\t\tlast = j;\n// \t\t\t\t\t\t// Match 1 or more non-path separators\n// \t\t\t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n// \t\t\t\t\t\t\tj++;\n// \t\t\t\t\t\t}\n// \t\t\t\t\t\tif (j === len) {\n// \t\t\t\t\t\t\t// We matched a UNC root only\n// \t\t\t\t\t\t\t// Return the normalized version of the UNC root since there\n// \t\t\t\t\t\t\t// is nothing left to process\n// \t\t\t\t\t\t\treturn `\\\\\\\\${firstPart}\\\\${path.slice(last)}\\\\`;\n// \t\t\t\t\t\t}\n// \t\t\t\t\t\tif (j !== last) {\n// \t\t\t\t\t\t\t// We matched a UNC root with leftovers\n// \t\t\t\t\t\t\tdevice = `\\\\\\\\${firstPart}\\\\${path.slice(last, j)}`;\n// \t\t\t\t\t\t\trootEnd = j;\n// \t\t\t\t\t\t}\n// \t\t\t\t\t}\n// \t\t\t\t}\n// \t\t\t} else {\n// \t\t\t\trootEnd = 1;\n// \t\t\t}\n// \t\t} else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {\n// \t\t\t// Possible device root\n// \t\t\tdevice = path.slice(0, 2);\n// \t\t\trootEnd = 2;\n// \t\t\tif (len > 2 && isPathSeparator(path.charCodeAt(2))) {\n// \t\t\t\t// Treat separator following drive name as an absolute path\n// \t\t\t\t// indicator\n// \t\t\t\tisAbsolute = true;\n// \t\t\t\trootEnd = 3;\n// \t\t\t}\n// \t\t}\n\n// \t\tlet tail = rootEnd < len ?\n// \t\t\tnormalizeString(path.slice(rootEnd), !isAbsolute, '\\\\', isPathSeparator) :\n// \t\t\t'';\n// \t\tif (tail.length === 0 && !isAbsolute) {\n// \t\t\ttail = '.';\n// \t\t}\n// \t\tif (tail.length > 0 && isPathSeparator(path.charCodeAt(len - 1))) {\n// \t\t\ttail += '\\\\';\n// \t\t}\n// \t\tif (device === undefined) {\n// \t\t\treturn isAbsolute ? `\\\\${tail}` : tail;\n// \t\t}\n// \t\treturn isAbsolute ? `${device}\\\\${tail}` : `${device}${tail}`;\n// \t},\n\n// \tisAbsolute(path: string): boolean {\n// \t\tvalidateString(path, 'path');\n// \t\tconst len = path.length;\n// \t\tif (len === 0) {\n// \t\t\treturn false;\n// \t\t}\n\n// \t\tconst code = path.charCodeAt(0);\n// \t\treturn isPathSeparator(code) ||\n// \t\t\t// Possible device root\n// \t\t\tlen > 2 &&\n// \t\t\tisWindowsDeviceRoot(code) &&\n// \t\t\tpath.charCodeAt(1) === CHAR_COLON &&\n// \t\t\tisPathSeparator(path.charCodeAt(2));\n// \t},\n\n// \tjoin(...paths: string[]): string {\n// \t\tif (paths.length === 0) {\n// \t\t\treturn '.';\n// \t\t}\n\n// \t\tlet joined;\n// \t\tlet firstPart: string | undefined;\n// \t\tfor (let i = 0; i < paths.length; ++i) {\n// \t\t\tconst arg = paths[i];\n// \t\t\tvalidateString(arg, 'path');\n// \t\t\tif (arg.length > 0) {\n// \t\t\t\tif (joined === undefined) {\n// \t\t\t\t\tjoined = firstPart = arg;\n// \t\t\t\t}\n// \t\t\t\telse {\n// \t\t\t\t\tjoined += `\\\\${arg}`;\n// \t\t\t\t}\n// \t\t\t}\n// \t\t}\n\n// \t\tif (joined === undefined) {\n// \t\t\treturn '.';\n// \t\t}\n\n// \t\t// Make sure that the joined path doesn't start with two slashes, because\n// \t\t// normalize() will mistake it for an UNC path then.\n// \t\t//\n// \t\t// This step is skipped when it is very clear that the user actually\n// \t\t// intended to point at an UNC path. This is assumed when the first\n// \t\t// non-empty string arguments starts with exactly two slashes followed by\n// \t\t// at least one more non-slash character.\n// \t\t//\n// \t\t// Note that for normalize() to treat a path as an UNC path it needs to\n// \t\t// have at least 2 components, so we don't filter for that here.\n// \t\t// This means that the user can use join to construct UNC paths from\n// \t\t// a server name and a share name; for example:\n// \t\t//   path.join('//server', 'share') -> '\\\\\\\\server\\\\share\\\\')\n// \t\tlet needsReplace = true;\n// \t\tlet slashCount = 0;\n// \t\tif (typeof firstPart === 'string' && isPathSeparator(firstPart.charCodeAt(0))) {\n// \t\t\t++slashCount;\n// \t\t\tconst firstLen = firstPart.length;\n// \t\t\tif (firstLen > 1 && isPathSeparator(firstPart.charCodeAt(1))) {\n// \t\t\t\t++slashCount;\n// \t\t\t\tif (firstLen > 2) {\n// \t\t\t\t\tif (isPathSeparator(firstPart.charCodeAt(2))) {\n// \t\t\t\t\t\t++slashCount;\n// \t\t\t\t\t} else {\n// \t\t\t\t\t\t// We matched a UNC path in the first part\n// \t\t\t\t\t\tneedsReplace = false;\n// \t\t\t\t\t}\n// \t\t\t\t}\n// \t\t\t}\n// \t\t}\n// \t\tif (needsReplace) {\n// \t\t\t// Find any more consecutive slashes we need to replace\n// \t\t\twhile (slashCount < joined.length &&\n// \t\t\t\tisPathSeparator(joined.charCodeAt(slashCount))) {\n// \t\t\t\tslashCount++;\n// \t\t\t}\n\n// \t\t\t// Replace the slashes if needed\n// \t\t\tif (slashCount >= 2) {\n// \t\t\t\tjoined = `\\\\${joined.slice(slashCount)}`;\n// \t\t\t}\n// \t\t}\n\n// \t\treturn win32.normalize(joined);\n// \t},\n\n// \t// It will solve the relative path from `from` to `to`, for instance:\n// \t//  from = 'C:\\\\orandea\\\\test\\\\aaa'\n// \t//  to = 'C:\\\\orandea\\\\impl\\\\bbb'\n// \t// The output of the function should be: '..\\\\..\\\\impl\\\\bbb'\n// \trelative(from: string, to: string): string {\n// \t\tvalidateString(from, 'from');\n// \t\tvalidateString(to, 'to');\n\n// \t\tif (from === to) {\n// \t\t\treturn '';\n// \t\t}\n\n// \t\tconst fromOrig = win32.resolve(from);\n// \t\tconst toOrig = win32.resolve(to);\n\n// \t\tif (fromOrig === toOrig) {\n// \t\t\treturn '';\n// \t\t}\n\n// \t\tfrom = fromOrig.toLowerCase();\n// \t\tto = toOrig.toLowerCase();\n\n// \t\tif (from === to) {\n// \t\t\treturn '';\n// \t\t}\n\n// \t\t// Trim any leading backslashes\n// \t\tlet fromStart = 0;\n// \t\twhile (fromStart < from.length &&\n// \t\t\tfrom.charCodeAt(fromStart) === CHAR_BACKWARD_SLASH) {\n// \t\t\tfromStart++;\n// \t\t}\n// \t\t// Trim trailing backslashes (applicable to UNC paths only)\n// \t\tlet fromEnd = from.length;\n// \t\twhile (fromEnd - 1 > fromStart &&\n// \t\t\tfrom.charCodeAt(fromEnd - 1) === CHAR_BACKWARD_SLASH) {\n// \t\t\tfromEnd--;\n// \t\t}\n// \t\tconst fromLen = fromEnd - fromStart;\n\n// \t\t// Trim any leading backslashes\n// \t\tlet toStart = 0;\n// \t\twhile (toStart < to.length &&\n// \t\t\tto.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {\n// \t\t\ttoStart++;\n// \t\t}\n// \t\t// Trim trailing backslashes (applicable to UNC paths only)\n// \t\tlet toEnd = to.length;\n// \t\twhile (toEnd - 1 > toStart &&\n// \t\t\tto.charCodeAt(toEnd - 1) === CHAR_BACKWARD_SLASH) {\n// \t\t\ttoEnd--;\n// \t\t}\n// \t\tconst toLen = toEnd - toStart;\n\n// \t\t// Compare paths to find the longest common path from root\n// \t\tconst length = fromLen < toLen ? fromLen : toLen;\n// \t\tlet lastCommonSep = -1;\n// \t\tlet i = 0;\n// \t\tfor (; i < length; i++) {\n// \t\t\tconst fromCode = from.charCodeAt(fromStart + i);\n// \t\t\tif (fromCode !== to.charCodeAt(toStart + i)) {\n// \t\t\t\tbreak;\n// \t\t\t} else if (fromCode === CHAR_BACKWARD_SLASH) {\n// \t\t\t\tlastCommonSep = i;\n// \t\t\t}\n// \t\t}\n\n// \t\t// We found a mismatch before the first common path separator was seen, so\n// \t\t// return the original `to`.\n// \t\tif (i !== length) {\n// \t\t\tif (lastCommonSep === -1) {\n// \t\t\t\treturn toOrig;\n// \t\t\t}\n// \t\t} else {\n// \t\t\tif (toLen > length) {\n// \t\t\t\tif (to.charCodeAt(toStart + i) === CHAR_BACKWARD_SLASH) {\n// \t\t\t\t\t// We get here if `from` is the exact base path for `to`.\n// \t\t\t\t\t// For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo\\\\bar\\\\baz'\n// \t\t\t\t\treturn toOrig.slice(toStart + i + 1);\n// \t\t\t\t}\n// \t\t\t\tif (i === 2) {\n// \t\t\t\t\t// We get here if `from` is the device root.\n// \t\t\t\t\t// For example: from='C:\\\\'; to='C:\\\\foo'\n// \t\t\t\t\treturn toOrig.slice(toStart + i);\n// \t\t\t\t}\n// \t\t\t}\n// \t\t\tif (fromLen > length) {\n// \t\t\t\tif (from.charCodeAt(fromStart + i) === CHAR_BACKWARD_SLASH) {\n// \t\t\t\t\t// We get here if `to` is the exact base path for `from`.\n// \t\t\t\t\t// For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo'\n// \t\t\t\t\tlastCommonSep = i;\n// \t\t\t\t} else if (i === 2) {\n// \t\t\t\t\t// We get here if `to` is the device root.\n// \t\t\t\t\t// For example: from='C:\\\\foo\\\\bar'; to='C:\\\\'\n// \t\t\t\t\tlastCommonSep = 3;\n// \t\t\t\t}\n// \t\t\t}\n// \t\t\tif (lastCommonSep === -1) {\n// \t\t\t\tlastCommonSep = 0;\n// \t\t\t}\n// \t\t}\n\n// \t\tlet out = '';\n// \t\t// Generate the relative path based on the path difference between `to` and\n// \t\t// `from`\n// \t\tfor (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n// \t\t\tif (i === fromEnd || from.charCodeAt(i) === CHAR_BACKWARD_SLASH) {\n// \t\t\t\tout += out.length === 0 ? '..' : '\\\\..';\n// \t\t\t}\n// \t\t}\n\n// \t\ttoStart += lastCommonSep;\n\n// \t\t// Lastly, append the rest of the destination (`to`) path that comes after\n// \t\t// the common path parts\n// \t\tif (out.length > 0) {\n// \t\t\treturn `${out}${toOrig.slice(toStart, toEnd)}`;\n// \t\t}\n\n// \t\tif (toOrig.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {\n// \t\t\t++toStart;\n// \t\t}\n\n// \t\treturn toOrig.slice(toStart, toEnd);\n// \t},\n\n// \ttoNamespacedPath(path: string): string {\n// \t\t// Note: this will *probably* throw somewhere.\n// \t\tif (typeof path !== 'string') {\n// \t\t\treturn path;\n// \t\t}\n\n// \t\tif (path.length === 0) {\n// \t\t\treturn '';\n// \t\t}\n\n// \t\tconst resolvedPath = win32.resolve(path);\n\n// \t\tif (resolvedPath.length <= 2) {\n// \t\t\treturn path;\n// \t\t}\n\n// \t\tif (resolvedPath.charCodeAt(0) === CHAR_BACKWARD_SLASH) {\n// \t\t\t// Possible UNC root\n// \t\t\tif (resolvedPath.charCodeAt(1) === CHAR_BACKWARD_SLASH) {\n// \t\t\t\tconst code = resolvedPath.charCodeAt(2);\n// \t\t\t\tif (code !== CHAR_QUESTION_MARK && code !== CHAR_DOT) {\n// \t\t\t\t\t// Matched non-long UNC root, convert the path to a long UNC path\n// \t\t\t\t\treturn `\\\\\\\\?\\\\UNC\\\\${resolvedPath.slice(2)}`;\n// \t\t\t\t}\n// \t\t\t}\n// \t\t} else if (isWindowsDeviceRoot(resolvedPath.charCodeAt(0)) &&\n// \t\t\tresolvedPath.charCodeAt(1) === CHAR_COLON &&\n// \t\t\tresolvedPath.charCodeAt(2) === CHAR_BACKWARD_SLASH) {\n// \t\t\t// Matched device root, convert the path to a long UNC path\n// \t\t\treturn `\\\\\\\\?\\\\${resolvedPath}`;\n// \t\t}\n\n// \t\treturn path;\n// \t},\n\n// \tdirname(path: string): string {\n// \t\tvalidateString(path, 'path');\n// \t\tconst len = path.length;\n// \t\tif (len === 0) {\n// \t\t\treturn '.';\n// \t\t}\n// \t\tlet rootEnd = -1;\n// \t\tlet offset = 0;\n// \t\tconst code = path.charCodeAt(0);\n\n// \t\tif (len === 1) {\n// \t\t\t// `path` contains just a path separator, exit early to avoid\n// \t\t\t// unnecessary work or a dot.\n// \t\t\treturn isPathSeparator(code) ? path : '.';\n// \t\t}\n\n// \t\t// Try to match a root\n// \t\tif (isPathSeparator(code)) {\n// \t\t\t// Possible UNC root\n\n// \t\t\trootEnd = offset = 1;\n\n// \t\t\tif (isPathSeparator(path.charCodeAt(1))) {\n// \t\t\t\t// Matched double path separator at beginning\n// \t\t\t\tlet j = 2;\n// \t\t\t\tlet last = j;\n// \t\t\t\t// Match 1 or more non-path separators\n// \t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n// \t\t\t\t\tj++;\n// \t\t\t\t}\n// \t\t\t\tif (j < len && j !== last) {\n// \t\t\t\t\t// Matched!\n// \t\t\t\t\tlast = j;\n// \t\t\t\t\t// Match 1 or more path separators\n// \t\t\t\t\twhile (j < len && isPathSeparator(path.charCodeAt(j))) {\n// \t\t\t\t\t\tj++;\n// \t\t\t\t\t}\n// \t\t\t\t\tif (j < len && j !== last) {\n// \t\t\t\t\t\t// Matched!\n// \t\t\t\t\t\tlast = j;\n// \t\t\t\t\t\t// Match 1 or more non-path separators\n// \t\t\t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n// \t\t\t\t\t\t\tj++;\n// \t\t\t\t\t\t}\n// \t\t\t\t\t\tif (j === len) {\n// \t\t\t\t\t\t\t// We matched a UNC root only\n// \t\t\t\t\t\t\treturn path;\n// \t\t\t\t\t\t}\n// \t\t\t\t\t\tif (j !== last) {\n// \t\t\t\t\t\t\t// We matched a UNC root with leftovers\n\n// \t\t\t\t\t\t\t// Offset by 1 to include the separator after the UNC root to\n// \t\t\t\t\t\t\t// treat it as a \"normal root\" on top of a (UNC) root\n// \t\t\t\t\t\t\trootEnd = offset = j + 1;\n// \t\t\t\t\t\t}\n// \t\t\t\t\t}\n// \t\t\t\t}\n// \t\t\t}\n// \t\t\t// Possible device root\n// \t\t} else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {\n// \t\t\trootEnd = len > 2 && isPathSeparator(path.charCodeAt(2)) ? 3 : 2;\n// \t\t\toffset = rootEnd;\n// \t\t}\n\n// \t\tlet end = -1;\n// \t\tlet matchedSlash = true;\n// \t\tfor (let i = len - 1; i >= offset; --i) {\n// \t\t\tif (isPathSeparator(path.charCodeAt(i))) {\n// \t\t\t\tif (!matchedSlash) {\n// \t\t\t\t\tend = i;\n// \t\t\t\t\tbreak;\n// \t\t\t\t}\n// \t\t\t} else {\n// \t\t\t\t// We saw the first non-path separator\n// \t\t\t\tmatchedSlash = false;\n// \t\t\t}\n// \t\t}\n\n// \t\tif (end === -1) {\n// \t\t\tif (rootEnd === -1) {\n// \t\t\t\treturn '.';\n// \t\t\t}\n\n// \t\t\tend = rootEnd;\n// \t\t}\n// \t\treturn path.slice(0, end);\n// \t},\n\n// \tbasename(path: string, ext?: string): string {\n// \t\tif (ext !== undefined) {\n// \t\t\tvalidateString(ext, 'ext');\n// \t\t}\n// \t\tvalidateString(path, 'path');\n// \t\tlet start = 0;\n// \t\tlet end = -1;\n// \t\tlet matchedSlash = true;\n// \t\tlet i;\n\n// \t\t// Check for a drive letter prefix so as not to mistake the following\n// \t\t// path separator as an extra separator at the end of the path that can be\n// \t\t// disregarded\n// \t\tif (path.length >= 2 &&\n// \t\t\tisWindowsDeviceRoot(path.charCodeAt(0)) &&\n// \t\t\tpath.charCodeAt(1) === CHAR_COLON) {\n// \t\t\tstart = 2;\n// \t\t}\n\n// \t\tif (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n// \t\t\tif (ext === path) {\n// \t\t\t\treturn '';\n// \t\t\t}\n// \t\t\tlet extIdx = ext.length - 1;\n// \t\t\tlet firstNonSlashEnd = -1;\n// \t\t\tfor (i = path.length - 1; i >= start; --i) {\n// \t\t\t\tconst code = path.charCodeAt(i);\n// \t\t\t\tif (isPathSeparator(code)) {\n// \t\t\t\t\t// If we reached a path separator that was not part of a set of path\n// \t\t\t\t\t// separators at the end of the string, stop now\n// \t\t\t\t\tif (!matchedSlash) {\n// \t\t\t\t\t\tstart = i + 1;\n// \t\t\t\t\t\tbreak;\n// \t\t\t\t\t}\n// \t\t\t\t} else {\n// \t\t\t\t\tif (firstNonSlashEnd === -1) {\n// \t\t\t\t\t\t// We saw the first non-path separator, remember this index in case\n// \t\t\t\t\t\t// we need it if the extension ends up not matching\n// \t\t\t\t\t\tmatchedSlash = false;\n// \t\t\t\t\t\tfirstNonSlashEnd = i + 1;\n// \t\t\t\t\t}\n// \t\t\t\t\tif (extIdx >= 0) {\n// \t\t\t\t\t\t// Try to match the explicit extension\n// \t\t\t\t\t\tif (code === ext.charCodeAt(extIdx)) {\n// \t\t\t\t\t\t\tif (--extIdx === -1) {\n// \t\t\t\t\t\t\t\t// We matched the extension, so mark this as the end of our path\n// \t\t\t\t\t\t\t\t// component\n// \t\t\t\t\t\t\t\tend = i;\n// \t\t\t\t\t\t\t}\n// \t\t\t\t\t\t} else {\n// \t\t\t\t\t\t\t// Extension does not match, so our result is the entire path\n// \t\t\t\t\t\t\t// component\n// \t\t\t\t\t\t\textIdx = -1;\n// \t\t\t\t\t\t\tend = firstNonSlashEnd;\n// \t\t\t\t\t\t}\n// \t\t\t\t\t}\n// \t\t\t\t}\n// \t\t\t}\n\n// \t\t\tif (start === end) {\n// \t\t\t\tend = firstNonSlashEnd;\n// \t\t\t} else if (end === -1) {\n// \t\t\t\tend = path.length;\n// \t\t\t}\n// \t\t\treturn path.slice(start, end);\n// \t\t}\n// \t\tfor (i = path.length - 1; i >= start; --i) {\n// \t\t\tif (isPathSeparator(path.charCodeAt(i))) {\n// \t\t\t\t// If we reached a path separator that was not part of a set of path\n// \t\t\t\t// separators at the end of the string, stop now\n// \t\t\t\tif (!matchedSlash) {\n// \t\t\t\t\tstart = i + 1;\n// \t\t\t\t\tbreak;\n// \t\t\t\t}\n// \t\t\t} else if (end === -1) {\n// \t\t\t\t// We saw the first non-path separator, mark this as the end of our\n// \t\t\t\t// path component\n// \t\t\t\tmatchedSlash = false;\n// \t\t\t\tend = i + 1;\n// \t\t\t}\n// \t\t}\n\n// \t\tif (end === -1) {\n// \t\t\treturn '';\n// \t\t}\n// \t\treturn path.slice(start, end);\n// \t},\n\n// \textname(path: string): string {\n// \t\tvalidateString(path, 'path');\n// \t\tlet start = 0;\n// \t\tlet startDot = -1;\n// \t\tlet startPart = 0;\n// \t\tlet end = -1;\n// \t\tlet matchedSlash = true;\n// \t\t// Track the state of characters (if any) we see before our first dot and\n// \t\t// after any path separator we find\n// \t\tlet preDotState = 0;\n\n// \t\t// Check for a drive letter prefix so as not to mistake the following\n// \t\t// path separator as an extra separator at the end of the path that can be\n// \t\t// disregarded\n\n// \t\tif (path.length >= 2 &&\n// \t\t\tpath.charCodeAt(1) === CHAR_COLON &&\n// \t\t\tisWindowsDeviceRoot(path.charCodeAt(0))) {\n// \t\t\tstart = startPart = 2;\n// \t\t}\n\n// \t\tfor (let i = path.length - 1; i >= start; --i) {\n// \t\t\tconst code = path.charCodeAt(i);\n// \t\t\tif (isPathSeparator(code)) {\n// \t\t\t\t// If we reached a path separator that was not part of a set of path\n// \t\t\t\t// separators at the end of the string, stop now\n// \t\t\t\tif (!matchedSlash) {\n// \t\t\t\t\tstartPart = i + 1;\n// \t\t\t\t\tbreak;\n// \t\t\t\t}\n// \t\t\t\tcontinue;\n// \t\t\t}\n// \t\t\tif (end === -1) {\n// \t\t\t\t// We saw the first non-path separator, mark this as the end of our\n// \t\t\t\t// extension\n// \t\t\t\tmatchedSlash = false;\n// \t\t\t\tend = i + 1;\n// \t\t\t}\n// \t\t\tif (code === CHAR_DOT) {\n// \t\t\t\t// If this is our first dot, mark it as the start of our extension\n// \t\t\t\tif (startDot === -1) {\n// \t\t\t\t\tstartDot = i;\n// \t\t\t\t}\n// \t\t\t\telse if (preDotState !== 1) {\n// \t\t\t\t\tpreDotState = 1;\n// \t\t\t\t}\n// \t\t\t} else if (startDot !== -1) {\n// \t\t\t\t// We saw a non-dot and non-path separator before our dot, so we should\n// \t\t\t\t// have a good chance at having a non-empty extension\n// \t\t\t\tpreDotState = -1;\n// \t\t\t}\n// \t\t}\n\n// \t\tif (startDot === -1 ||\n// \t\t\tend === -1 ||\n// \t\t\t// We saw a non-dot character immediately before the dot\n// \t\t\tpreDotState === 0 ||\n// \t\t\t// The (right-most) trimmed path component is exactly '..'\n// \t\t\t(preDotState === 1 &&\n// \t\t\t\tstartDot === end - 1 &&\n// \t\t\t\tstartDot === startPart + 1)) {\n// \t\t\treturn '';\n// \t\t}\n// \t\treturn path.slice(startDot, end);\n// \t},\n\n// \tformat: _format.bind(null, '\\\\'),\n\n// \tparse(path) {\n// \t\tvalidateString(path, 'path');\n\n// \t\tconst ret = { root: '', dir: '', base: '', ext: '', name: '' };\n// \t\tif (path.length === 0) {\n// \t\t\treturn ret;\n// \t\t}\n\n// \t\tconst len = path.length;\n// \t\tlet rootEnd = 0;\n// \t\tlet code = path.charCodeAt(0);\n\n// \t\tif (len === 1) {\n// \t\t\tif (isPathSeparator(code)) {\n// \t\t\t\t// `path` contains just a path separator, exit early to avoid\n// \t\t\t\t// unnecessary work\n// \t\t\t\tret.root = ret.dir = path;\n// \t\t\t\treturn ret;\n// \t\t\t}\n// \t\t\tret.base = ret.name = path;\n// \t\t\treturn ret;\n// \t\t}\n// \t\t// Try to match a root\n// \t\tif (isPathSeparator(code)) {\n// \t\t\t// Possible UNC root\n\n// \t\t\trootEnd = 1;\n// \t\t\tif (isPathSeparator(path.charCodeAt(1))) {\n// \t\t\t\t// Matched double path separator at beginning\n// \t\t\t\tlet j = 2;\n// \t\t\t\tlet last = j;\n// \t\t\t\t// Match 1 or more non-path separators\n// \t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n// \t\t\t\t\tj++;\n// \t\t\t\t}\n// \t\t\t\tif (j < len && j !== last) {\n// \t\t\t\t\t// Matched!\n// \t\t\t\t\tlast = j;\n// \t\t\t\t\t// Match 1 or more path separators\n// \t\t\t\t\twhile (j < len && isPathSeparator(path.charCodeAt(j))) {\n// \t\t\t\t\t\tj++;\n// \t\t\t\t\t}\n// \t\t\t\t\tif (j < len && j !== last) {\n// \t\t\t\t\t\t// Matched!\n// \t\t\t\t\t\tlast = j;\n// \t\t\t\t\t\t// Match 1 or more non-path separators\n// \t\t\t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n// \t\t\t\t\t\t\tj++;\n// \t\t\t\t\t\t}\n// \t\t\t\t\t\tif (j === len) {\n// \t\t\t\t\t\t\t// We matched a UNC root only\n// \t\t\t\t\t\t\trootEnd = j;\n// \t\t\t\t\t\t} else if (j !== last) {\n// \t\t\t\t\t\t\t// We matched a UNC root with leftovers\n// \t\t\t\t\t\t\trootEnd = j + 1;\n// \t\t\t\t\t\t}\n// \t\t\t\t\t}\n// \t\t\t\t}\n// \t\t\t}\n// \t\t} else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {\n// \t\t\t// Possible device root\n// \t\t\tif (len <= 2) {\n// \t\t\t\t// `path` contains just a drive root, exit early to avoid\n// \t\t\t\t// unnecessary work\n// \t\t\t\tret.root = ret.dir = path;\n// \t\t\t\treturn ret;\n// \t\t\t}\n// \t\t\trootEnd = 2;\n// \t\t\tif (isPathSeparator(path.charCodeAt(2))) {\n// \t\t\t\tif (len === 3) {\n// \t\t\t\t\t// `path` contains just a drive root, exit early to avoid\n// \t\t\t\t\t// unnecessary work\n// \t\t\t\t\tret.root = ret.dir = path;\n// \t\t\t\t\treturn ret;\n// \t\t\t\t}\n// \t\t\t\trootEnd = 3;\n// \t\t\t}\n// \t\t}\n// \t\tif (rootEnd > 0) {\n// \t\t\tret.root = path.slice(0, rootEnd);\n// \t\t}\n\n// \t\tlet startDot = -1;\n// \t\tlet startPart = rootEnd;\n// \t\tlet end = -1;\n// \t\tlet matchedSlash = true;\n// \t\tlet i = path.length - 1;\n\n// \t\t// Track the state of characters (if any) we see before our first dot and\n// \t\t// after any path separator we find\n// \t\tlet preDotState = 0;\n\n// \t\t// Get non-dir info\n// \t\tfor (; i >= rootEnd; --i) {\n// \t\t\tcode = path.charCodeAt(i);\n// \t\t\tif (isPathSeparator(code)) {\n// \t\t\t\t// If we reached a path separator that was not part of a set of path\n// \t\t\t\t// separators at the end of the string, stop now\n// \t\t\t\tif (!matchedSlash) {\n// \t\t\t\t\tstartPart = i + 1;\n// \t\t\t\t\tbreak;\n// \t\t\t\t}\n// \t\t\t\tcontinue;\n// \t\t\t}\n// \t\t\tif (end === -1) {\n// \t\t\t\t// We saw the first non-path separator, mark this as the end of our\n// \t\t\t\t// extension\n// \t\t\t\tmatchedSlash = false;\n// \t\t\t\tend = i + 1;\n// \t\t\t}\n// \t\t\tif (code === CHAR_DOT) {\n// \t\t\t\t// If this is our first dot, mark it as the start of our extension\n// \t\t\t\tif (startDot === -1) {\n// \t\t\t\t\tstartDot = i;\n// \t\t\t\t} else if (preDotState !== 1) {\n// \t\t\t\t\tpreDotState = 1;\n// \t\t\t\t}\n// \t\t\t} else if (startDot !== -1) {\n// \t\t\t\t// We saw a non-dot and non-path separator before our dot, so we should\n// \t\t\t\t// have a good chance at having a non-empty extension\n// \t\t\t\tpreDotState = -1;\n// \t\t\t}\n// \t\t}\n\n// \t\tif (end !== -1) {\n// \t\t\tif (startDot === -1 ||\n// \t\t\t\t// We saw a non-dot character immediately before the dot\n// \t\t\t\tpreDotState === 0 ||\n// \t\t\t\t// The (right-most) trimmed path component is exactly '..'\n// \t\t\t\t(preDotState === 1 &&\n// \t\t\t\t\tstartDot === end - 1 &&\n// \t\t\t\t\tstartDot === startPart + 1)) {\n// \t\t\t\tret.base = ret.name = path.slice(startPart, end);\n// \t\t\t} else {\n// \t\t\t\tret.name = path.slice(startPart, startDot);\n// \t\t\t\tret.base = path.slice(startPart, end);\n// \t\t\t\tret.ext = path.slice(startDot, end);\n// \t\t\t}\n// \t\t}\n\n// \t\t// If the directory is the root, use the entire root as the `dir` including\n// \t\t// the trailing slash if any (`C:\\abc` -> `C:\\`). Otherwise, strip out the\n// \t\t// trailing slash (`C:\\abc\\def` -> `C:\\abc`).\n// \t\tif (startPart > 0 && startPart !== rootEnd) {\n// \t\t\tret.dir = path.slice(0, startPart - 1);\n// \t\t} else {\n// \t\t\tret.dir = ret.root;\n// \t\t}\n\n// \t\treturn ret;\n// \t},\n\n// \tsep: '\\\\',\n// \tdelimiter: ';',\n// \twin32: null,\n// \tposix: null\n// };\n\nexport const posix: IPath = {\n  // path.resolve([from ...], to)\n  resolve(...pathSegments: string[]): string {\n    let resolvedPath = '';\n    let resolvedAbsolute = false;\n\n    for (let i = pathSegments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n      const path = i >= 0 ? pathSegments[i] : process.cwd();\n\n      validateString(path, 'path');\n\n      // Skip empty entries\n      if (path.length === 0) {\n        continue;\n      }\n\n      resolvedPath = `${path}/${resolvedPath}`;\n      resolvedAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n    }\n\n    // At this point the path should be resolved to a full absolute path, but\n    // handle relative paths to be safe (might happen when process.cwd() fails)\n\n    // Normalize the path\n    resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute, '/', isPosixPathSeparator);\n\n    if (resolvedAbsolute) {\n      return `/${resolvedPath}`;\n    }\n    return resolvedPath.length > 0 ? resolvedPath : '.';\n  },\n\n  normalize(path: string): string {\n    validateString(path, 'path');\n\n    if (path.length === 0) {\n      return '.';\n    }\n\n    const isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n    const trailingSeparator = path.charCodeAt(path.length - 1) === CHAR_FORWARD_SLASH;\n\n    // Normalize the path\n    path = normalizeString(path, !isAbsolute, '/', isPosixPathSeparator);\n\n    if (path.length === 0) {\n      if (isAbsolute) {\n        return '/';\n      }\n      return trailingSeparator ? './' : '.';\n    }\n    if (trailingSeparator) {\n      path += '/';\n    }\n\n    return isAbsolute ? `/${path}` : path;\n  },\n\n  isAbsolute(path: string): boolean {\n    validateString(path, 'path');\n    return path.length > 0 && path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n  },\n\n  join(...paths: string[]): string {\n    if (paths.length === 0) {\n      return '.';\n    }\n    let joined;\n    for (let i = 0; i < paths.length; ++i) {\n      const arg = paths[i];\n      validateString(arg, 'path');\n      if (arg.length > 0) {\n        if (joined === undefined) {\n          joined = arg;\n        } else {\n          joined += `/${arg}`;\n        }\n      }\n    }\n    if (joined === undefined) {\n      return '.';\n    }\n    return posix.normalize(joined);\n  },\n\n  relative(from: string, to: string): string {\n    validateString(from, 'from');\n    validateString(to, 'to');\n\n    if (from === to) {\n      return '';\n    }\n\n    // Trim leading forward slashes.\n    from = posix.resolve(from);\n    to = posix.resolve(to);\n\n    if (from === to) {\n      return '';\n    }\n\n    const fromStart = 1;\n    const fromEnd = from.length;\n    const fromLen = fromEnd - fromStart;\n    const toStart = 1;\n    const toLen = to.length - toStart;\n\n    // Compare paths to find the longest common path from root\n    const length = fromLen < toLen ? fromLen : toLen;\n    let lastCommonSep = -1;\n    let i = 0;\n    for (; i < length; i++) {\n      const fromCode = from.charCodeAt(fromStart + i);\n      if (fromCode !== to.charCodeAt(toStart + i)) {\n        break;\n      } else if (fromCode === CHAR_FORWARD_SLASH) {\n        lastCommonSep = i;\n      }\n    }\n    if (i === length) {\n      if (toLen > length) {\n        if (to.charCodeAt(toStart + i) === CHAR_FORWARD_SLASH) {\n          // We get here if `from` is the exact base path for `to`.\n          // For example: from='/foo/bar'; to='/foo/bar/baz'\n          return to.slice(toStart + i + 1);\n        }\n        if (i === 0) {\n          // We get here if `from` is the root\n          // For example: from='/'; to='/foo'\n          return to.slice(toStart + i);\n        }\n      } else if (fromLen > length) {\n        if (from.charCodeAt(fromStart + i) === CHAR_FORWARD_SLASH) {\n          // We get here if `to` is the exact base path for `from`.\n          // For example: from='/foo/bar/baz'; to='/foo/bar'\n          lastCommonSep = i;\n        } else if (i === 0) {\n          // We get here if `to` is the root.\n          // For example: from='/foo/bar'; to='/'\n          lastCommonSep = 0;\n        }\n      }\n    }\n\n    let out = '';\n    // Generate the relative path based on the path difference between `to`\n    // and `from`.\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n      if (i === fromEnd || from.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n        out += out.length === 0 ? '..' : '/..';\n      }\n    }\n\n    // Lastly, append the rest of the destination (`to`) path that comes after\n    // the common path parts.\n    return `${out}${to.slice(toStart + lastCommonSep)}`;\n  },\n\n  toNamespacedPath(path: string): string {\n    // Non-op on posix systems\n    return path;\n  },\n\n  dirname(path: string): string {\n    validateString(path, 'path');\n    if (path.length === 0) {\n      return '.';\n    }\n    const hasRoot = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n    let end = -1;\n    let matchedSlash = true;\n    for (let i = path.length - 1; i >= 1; --i) {\n      if (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n        if (!matchedSlash) {\n          end = i;\n          break;\n        }\n      } else {\n        // We saw the first non-path separator\n        matchedSlash = false;\n      }\n    }\n\n    if (end === -1) {\n      return hasRoot ? '/' : '.';\n    }\n    if (hasRoot && end === 1) {\n      return '//';\n    }\n    return path.slice(0, end);\n  },\n\n  basename(path: string, ext?: string): string {\n    if (ext !== undefined) {\n      validateString(ext, 'ext');\n    }\n    validateString(path, 'path');\n\n    let start = 0;\n    let end = -1;\n    let matchedSlash = true;\n    let i;\n\n    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n      if (ext === path) {\n        return '';\n      }\n      let extIdx = ext.length - 1;\n      let firstNonSlashEnd = -1;\n      for (i = path.length - 1; i >= 0; --i) {\n        const code = path.charCodeAt(i);\n        if (code === CHAR_FORWARD_SLASH) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            start = i + 1;\n            break;\n          }\n        } else {\n          if (firstNonSlashEnd === -1) {\n            // We saw the first non-path separator, remember this index in case\n            // we need it if the extension ends up not matching\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            // Try to match the explicit extension\n            if (code === ext.charCodeAt(extIdx)) {\n              if (--extIdx === -1) {\n                // We matched the extension, so mark this as the end of our path\n                // component\n                end = i;\n              }\n            } else {\n              // Extension does not match, so our result is the entire path\n              // component\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n\n      if (start === end) {\n        end = firstNonSlashEnd;\n      } else if (end === -1) {\n        end = path.length;\n      }\n      return path.slice(start, end);\n    }\n    for (i = path.length - 1; i >= 0; --i) {\n      if (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          start = i + 1;\n          break;\n        }\n      } else if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // path component\n        matchedSlash = false;\n        end = i + 1;\n      }\n    }\n\n    if (end === -1) {\n      return '';\n    }\n    return path.slice(start, end);\n  },\n\n  extname(path: string): string {\n    validateString(path, 'path');\n    let startDot = -1;\n    let startPart = 0;\n    let end = -1;\n    let matchedSlash = true;\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    let preDotState = 0;\n    for (let i = path.length - 1; i >= 0; --i) {\n      const code = path.charCodeAt(i);\n      if (code === CHAR_FORWARD_SLASH) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === CHAR_DOT) {\n        // If this is our first dot, mark it as the start of our extension\n        if (startDot === -1) {\n          startDot = i;\n        } else if (preDotState !== 1) {\n          preDotState = 1;\n        }\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (\n      startDot === -1 ||\n      end === -1 ||\n      // We saw a non-dot character immediately before the dot\n      preDotState === 0 ||\n      // The (right-most) trimmed path component is exactly '..'\n      (preDotState === 1 && startDot === end - 1 && startDot === startPart + 1)\n    ) {\n      return '';\n    }\n    return path.slice(startDot, end);\n  },\n\n  format: _format.bind(null, '/'),\n\n  parse(path: string): ParsedPath {\n    validateString(path, 'path');\n\n    const ret = { root: '', dir: '', base: '', ext: '', name: '' };\n    if (path.length === 0) {\n      return ret;\n    }\n    const isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n    let start;\n    if (isAbsolute) {\n      ret.root = '/';\n      start = 1;\n    } else {\n      start = 0;\n    }\n    let startDot = -1;\n    let startPart = 0;\n    let end = -1;\n    let matchedSlash = true;\n    let i = path.length - 1;\n\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    let preDotState = 0;\n\n    // Get non-dir info\n    for (; i >= start; --i) {\n      const code = path.charCodeAt(i);\n      if (code === CHAR_FORWARD_SLASH) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === CHAR_DOT) {\n        // If this is our first dot, mark it as the start of our extension\n        if (startDot === -1) {\n          startDot = i;\n        } else if (preDotState !== 1) {\n          preDotState = 1;\n        }\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (end !== -1) {\n      const start = startPart === 0 && isAbsolute ? 1 : startPart;\n      if (\n        startDot === -1 ||\n        // We saw a non-dot character immediately before the dot\n        preDotState === 0 ||\n        // The (right-most) trimmed path component is exactly '..'\n        (preDotState === 1 && startDot === end - 1 && startDot === startPart + 1)\n      ) {\n        ret.base = ret.name = path.slice(start, end);\n      } else {\n        ret.name = path.slice(start, startDot);\n        ret.base = path.slice(start, end);\n        ret.ext = path.slice(startDot, end);\n      }\n    }\n\n    if (startPart > 0) {\n      ret.dir = path.slice(0, startPart - 1);\n    } else if (isAbsolute) {\n      ret.dir = '/';\n    }\n\n    return ret;\n  },\n\n  sep: '/',\n  delimiter: ':',\n  win32: null,\n  posix: null,\n};\n\nexport const normalize = posix.normalize;\nexport const isAbsolute = posix.isAbsolute;\nexport const join = posix.join;\nexport const resolve = posix.resolve;\nexport const relative = posix.relative;\nexport const dirname = posix.dirname;\nexport const basename = posix.basename;\nexport const extname = posix.extname;\nexport const format = posix.format;\nexport const parse = posix.parse;\nexport const toNamespacedPath = posix.toNamespacedPath;\nexport const sep = posix.sep;\nexport const delimiter = posix.delimiter;\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from './charCode';\nimport { join } from './path';\n\nconst _schemePattern = /^\\w[\\w\\d+.-]*$/;\nconst _singleSlashStart = /^\\//;\nconst _doubleSlashStart = /^\\/\\//;\n\nfunction _validateUri(ret: Uri, _strict?: boolean): void {\n  // scheme, must be set\n  if (!ret.scheme && _strict) {\n    throw new Error(\n      `[UriError]: Scheme is missing: {scheme: \"\", authority: \"${ret.authority}\", path: \"${ret.path}\", query: \"${ret.query}\", fragment: \"${ret.fragment}\"}`\n    );\n  }\n\n  // scheme, https://tools.ietf.org/html/rfc3986#section-3.1\n  // ALPHA *( ALPHA / DIGIT / \"+\" / \"-\" / \".\" )\n  if (ret.scheme && !_schemePattern.test(ret.scheme)) {\n    throw new Error('[UriError]: Scheme contains illegal characters.');\n  }\n\n  // path, http://tools.ietf.org/html/rfc3986#section-3.3\n  // If a URI contains an authority component, then the path component\n  // must either be empty or begin with a slash (\"/\") character.  If a URI\n  // does not contain an authority component, then the path cannot begin\n  // with two slash characters (\"//\").\n  if (ret.path) {\n    if (ret.authority) {\n      if (!_singleSlashStart.test(ret.path)) {\n        throw new Error(\n          '[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash (\"/\") character'\n        );\n      }\n    } else {\n      if (_doubleSlashStart.test(ret.path)) {\n        throw new Error(\n          '[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters (\"//\")'\n        );\n      }\n    }\n  }\n}\n\n// for a while we allowed uris *without* schemes and this is the migration\n// for them, e.g. an uri without scheme and without strict-mode warns and falls\n// back to the file-scheme. that should cause the least carnage and still be a\n// clear warning\nfunction _schemeFix(scheme: string, _strict: boolean): string {\n  if (!scheme && !_strict) {\n    return 'file';\n  }\n  return scheme;\n}\n\n// implements a bit of https://tools.ietf.org/html/rfc3986#section-5\nfunction _referenceResolution(scheme: string, path: string): string {\n  // the slash-character is our 'default base' as we don't\n  // support constructing URIs relative to other URIs. This\n  // see https://tools.ietf.org/html/rfc3986#section-5.1.4\n  switch (scheme) {\n    case 'https':\n    case 'http':\n    case 'file':\n      if (!path) {\n        path = _slash;\n      } else if (path[0] !== _slash) {\n        path = _slash + path;\n      }\n      break;\n  }\n  return path;\n}\n\nconst _empty = '';\nconst _slash = '/';\nconst _regexp = /^(([^:/?#]+?):)?(\\/\\/([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?/;\n\n/**\n * Uniform Resource Identifier (URI) http://tools.ietf.org/html/rfc3986.\n * This class is a simple parser which creates the basic component parts\n * (http://tools.ietf.org/html/rfc3986#section-3) with minimal validation\n * and encoding.\n *\n * ```txt\n *       foo://example.com:8042/over/there?name=ferret#nose\n *       \\_/   \\______________/\\_________/ \\_________/ \\__/\n *        |           |            |            |        |\n *     scheme     authority       path        query   fragment\n *        |   _____________________|__\n *       / \\ /                        \\\n *       urn:example:animal:ferret:nose\n * ```\n */\nexport class Uri implements UriComponents {\n  static ensureTrailingSlash(uri: Uri, trailingSlash = '/') {\n    return uri.with({\n      path: uri.path.replace(TRAILING_SLASH_RX, trailingSlash),\n    });\n  }\n\n  static equals(l: Uri, r: Uri) {\n    return (\n      l.authority === r.authority &&\n      l.fragment === r.fragment &&\n      l.path === r.path &&\n      l.query === r.query &&\n      l.scheme === r.scheme\n    );\n  }\n\n  static getFirstPathSegmentAfterPrefix(child: Uri, parent: Uri): string {\n    const childHref = child.path;\n    const parentHref = parent.path;\n    const parentOffset = parentHref.charAt(parentHref.length - 1) === '/' ? -1 : 0;\n\n    for (let i = 0; i <= childHref.length; i++) {\n      if (i < parentHref.length) {\n        if (childHref.charAt(i) !== parentHref.charAt(i)) {\n          throw new Error(\n            `The child entry ${child.toString()} does not have the pathname of ${parent.toString()} as a prefix`\n          );\n        }\n      } else if (i === parentHref.length + parentOffset) {\n        if (childHref.charAt(i) !== '/') {\n          throw new Error(\n            `The child entry ${child.toString()} does not have the pathname of ${parent.toString()} as a prefix`\n          );\n        }\n      } else if (childHref.charAt(i) === '/') {\n        return childHref.slice(parentHref.length + 1 + parentOffset, i);\n      }\n    }\n\n    return childHref.slice(parentHref.length + 1 + parentOffset);\n  }\n\n  static isPrefixOf(prefix: Uri, uri: Uri) {\n    return (\n      prefix.authority === uri.authority &&\n      prefix.fragment === uri.fragment &&\n      prefix.query === uri.query &&\n      prefix.scheme === uri.scheme &&\n      uri.path.startsWith(prefix.path)\n    );\n  }\n\n  static isUri(thing: any): thing is Uri {\n    if (thing instanceof Uri) {\n      return true;\n    }\n    if (!thing) {\n      return false;\n    }\n    return (\n      typeof (<Uri>thing).authority === 'string' &&\n      typeof (<Uri>thing).fragment === 'string' &&\n      typeof (<Uri>thing).path === 'string' &&\n      typeof (<Uri>thing).query === 'string' &&\n      typeof (<Uri>thing).scheme === 'string' &&\n      typeof (<Uri>thing).fsPath === 'function' &&\n      typeof (<Uri>thing).with === 'function' &&\n      typeof (<Uri>thing).toString === 'function'\n    );\n  }\n\n  /**\n   * scheme is the 'http' part of 'http://www.msft.com/some/path?query#fragment'.\n   * The part before the first colon.\n   */\n  readonly scheme: string;\n\n  /**\n   * authority is the 'www.msft.com' part of 'http://www.msft.com/some/path?query#fragment'.\n   * The part between the first double slashes and the next slash.\n   */\n  readonly authority: string;\n\n  /**\n   * path is the '/some/path' part of 'http://www.msft.com/some/path?query#fragment'.\n   */\n  readonly path: string;\n\n  /**\n   * query is the 'query' part of 'http://www.msft.com/some/path?query#fragment'.\n   */\n  readonly query: string;\n\n  /**\n   * fragment is the 'fragment' part of 'http://www.msft.com/some/path?query#fragment'.\n   */\n  readonly fragment: string;\n\n  /**\n   * @internal\n   */\n  protected constructor(\n    scheme: string,\n    authority?: string,\n    path?: string,\n    query?: string,\n    fragment?: string,\n    _strict?: boolean\n  );\n\n  /**\n   * @internal\n   */\n  protected constructor(components: UriComponents);\n\n  /**\n   * @internal\n   */\n  protected constructor(\n    schemeOrData: string | UriComponents,\n    authority?: string,\n    path?: string,\n    query?: string,\n    fragment?: string,\n    _strict: boolean = false\n  ) {\n    if (typeof schemeOrData === 'object') {\n      this.scheme = schemeOrData.scheme || _empty;\n      this.authority = schemeOrData.authority || _empty;\n      this.path = schemeOrData.path || _empty;\n      this.query = schemeOrData.query || _empty;\n      this.fragment = schemeOrData.fragment || _empty;\n      // no validation because it's this URI\n      // that creates uri components.\n      // _validateUri(this);\n    } else {\n      this.scheme = _schemeFix(schemeOrData, _strict);\n      this.authority = authority || _empty;\n      this.path = _referenceResolution(this.scheme, path || _empty);\n      this.query = query || _empty;\n      this.fragment = fragment || _empty;\n\n      _validateUri(this, _strict);\n    }\n  }\n\n  // ---- filesystem path -----------------------\n\n  /**\n\t * Returns a string representing the corresponding file system path of this URI.\n\t * platform specific path separator.\n\t *\n\t * * Will *not* validate the path for invalid characters and semantics.\n\t * * Will *not* look at the scheme of this URI.\n\t * * The result shall *not* be used for display purposes but for accessing a file on disk.\n\t *\n\t *\n\t * The *difference* to `URI#path` is the use of the platform specific separator and the handling\n\t *\n\t * ```ts\n\t\tconst u = URI.parse('file://server/c$/folder/file.txt')\n\t\tu.authority === 'server'\n\t\tu.path === '/shares/c$/file.txt'\n\t\tu.fsPath === '\\\\server\\c$\\folder\\file.txt'\n\t```\n\t *\n\t * Using `URI#path` to read a file (using fs-apis) would not be enough because parts of the path,\n\t * namely the server name, would be missing. Therefore `URI#fsPath` exists - it's sugar to ease working\n\t * with URIs that represent files on disk (`file` scheme).\n\t */\n  get fsPath(): string {\n    // if (this.scheme !== 'file') {\n    // \tconsole.warn(`[UriError] calling fsPath with scheme ${this.scheme}`);\n    // }\n    return uriToFsPath(this, false);\n  }\n\n  // ---- modify to new -------------------------\n\n  with(change: {\n    scheme?: string;\n    authority?: string | null;\n    path?: string | null;\n    query?: string | null;\n    fragment?: string | null;\n  }): Uri {\n    if (!change) {\n      return this;\n    }\n\n    let { scheme, authority, path, query, fragment } = change;\n    if (scheme === undefined) {\n      scheme = this.scheme;\n    } else if (scheme === null) {\n      scheme = _empty;\n    }\n    if (authority === undefined) {\n      authority = this.authority;\n    } else if (authority === null) {\n      authority = _empty;\n    }\n    if (path === undefined) {\n      path = this.path;\n    } else if (path === null) {\n      path = _empty;\n    }\n    if (query === undefined) {\n      query = this.query;\n    } else if (query === null) {\n      query = _empty;\n    }\n    if (fragment === undefined) {\n      fragment = this.fragment;\n    } else if (fragment === null) {\n      fragment = _empty;\n    }\n\n    if (\n      scheme === this.scheme &&\n      authority === this.authority &&\n      path === this.path &&\n      query === this.query &&\n      fragment === this.fragment\n    ) {\n      return this;\n    }\n\n    return new _URI(scheme, authority, path, query, fragment);\n  }\n\n  // ---- parse & validate ------------------------\n\n  /**\n   * Creates a new URI from a string, e.g. `http://www.msft.com/some/path`,\n   * `file:///usr/home`, or `scheme:with/path`.\n   *\n   * @param value A string which represents an URI (see `URI#toString`).\n   */\n  static parse(value: string, _strict: boolean = false): Uri {\n    const match = _regexp.exec(value);\n    if (!match) {\n      return new _URI(_empty, _empty, _empty, _empty, _empty);\n    }\n    return new _URI(\n      match[2] || _empty,\n      percentDecode(match[4] || _empty),\n      percentDecode(match[5] || _empty),\n      percentDecode(match[7] || _empty),\n      percentDecode(match[9] || _empty),\n      _strict\n    );\n  }\n\n  /**\n\t * Creates a new URI from a file system path, e.g. `c:\\my\\files`,\n\t * `/usr/home`, or `\\\\server\\share\\some\\path`.\n\t *\n\t * The *difference* between `URI#parse` and `URI#file` is that the latter treats the argument\n\t * as path, not as stringified-uri. E.g. `URI.file(path)` is **not the same as**\n\t * `URI.parse('file://' + path)` because the path might contain characters that are\n\t * interpreted (# and ?). See the following sample:\n\t * ```ts\n\tconst good = URI.file('/coding/c#/project1');\n\tgood.scheme === 'file';\n\tgood.path === '/coding/c#/project1';\n\tgood.fragment === '';\n\tconst bad = URI.parse('file://' + '/coding/c#/project1');\n\tbad.scheme === 'file';\n\tbad.path === '/coding/c'; // path is now broken\n\tbad.fragment === '/project1';\n\t```\n\t *\n\t * @param path A file system path (see `URI#fsPath`)\n\t */\n  static file(path: string): Uri {\n    let authority = _empty;\n\n    // check for authority as used in UNC shares\n    // or use the path as given\n    if (path[0] === _slash && path[1] === _slash) {\n      const idx = path.indexOf(_slash, 2);\n      if (idx === -1) {\n        authority = path.substring(2);\n        path = _slash;\n      } else {\n        authority = path.substring(2, idx);\n        path = path.substring(idx) || _slash;\n      }\n    }\n\n    return new _URI('file', authority, path, _empty, _empty);\n  }\n\n  static from(components: {\n    scheme: string;\n    authority?: string;\n    path?: string;\n    query?: string;\n    fragment?: string;\n  }): Uri {\n    return new _URI(\n      components.scheme,\n      components.authority,\n      components.path,\n      components.query,\n      components.fragment\n    );\n  }\n\n  /**\n   * Join a URI path with path fragments and normalizes the resulting path.\n   *\n   * @param uri The input URI.\n   * @param pathFragment The path fragment to add to the URI path.\n   * @returns The resulting URI.\n   */\n  static joinPath(uri: Uri, ...pathFragment: string[]): Uri {\n    if (!uri.path) {\n      throw new Error(`[UriError]: cannot call joinPaths on URI without path`);\n    }\n    const newPath = join(uri.path, ...pathFragment);\n    return uri.with({ path: newPath });\n  }\n\n  // ---- printing/externalize ---------------------------\n\n  /**\n   * Creates a string representation for this URI. It's guaranteed that calling\n   * `URI.parse` with the result of this function creates an URI which is equal\n   * to this URI.\n   *\n   * * The result shall *not* be used for display purposes but for externalization or transport.\n   * * The result will be encoded using the percentage encoding and encoding happens mostly\n   * ignore the scheme-specific encoding rules.\n   *\n   * @param skipEncoding Do not encode the result, default is `false`\n   */\n  toString(skipEncoding: boolean = true): string {\n    return _asFormatted(this, skipEncoding);\n  }\n\n  toJSON(): UriComponents {\n    return this;\n  }\n\n  static revive(data: UriComponents | Uri): Uri;\n  static revive(data: UriComponents | Uri | undefined): Uri | undefined;\n  static revive(data: UriComponents | Uri | null): Uri | null;\n  static revive(data: UriComponents | Uri | undefined | null): Uri | undefined | null;\n  static revive(data: UriComponents | Uri | undefined | null): Uri | undefined | null {\n    if (!data) {\n      return data;\n    } else if (data instanceof Uri) {\n      return data;\n    } else {\n      const result = new _URI(data);\n      result._formatted = (<UriState>data).external;\n      result._fsPath = (<UriState>data)._sep === _pathSepMarker ? (<UriState>data).fsPath : null;\n      return result;\n    }\n  }\n}\n\nexport interface UriComponents {\n  scheme: string;\n  authority: string;\n  path: string;\n  query: string;\n  fragment: string;\n}\n\ninterface UriState extends UriComponents {\n  $mid: number;\n  external: string;\n  fsPath: string;\n  _sep: 1 | undefined;\n}\n\nconst _pathSepMarker = undefined;\n\n// eslint-disable-next-line @typescript-eslint/naming-convention\nclass _URI extends Uri {\n  _formatted: string | null = null;\n  _fsPath: string | null = null;\n\n  get fsPath(): string {\n    if (!this._fsPath) {\n      this._fsPath = uriToFsPath(this, false);\n    }\n    return this._fsPath;\n  }\n\n  toString(skipEncoding: boolean = true): string {\n    if (!skipEncoding) {\n      // we don't cache that\n      return _asFormatted(this, false);\n    } else {\n      if (!this._formatted) {\n        this._formatted = _asFormatted(this, true);\n      }\n      return this._formatted;\n    }\n  }\n\n  toJSON(): UriComponents {\n    const res = <UriState>{\n      $mid: 1,\n    };\n    // cached state\n    if (this._fsPath) {\n      res.fsPath = this._fsPath;\n      res._sep = _pathSepMarker;\n    }\n    if (this._formatted) {\n      res.external = this._formatted;\n    }\n    // uri components\n    if (this.path) {\n      res.path = this.path;\n    }\n    if (this.scheme) {\n      res.scheme = this.scheme;\n    }\n    if (this.authority) {\n      res.authority = this.authority;\n    }\n    if (this.query) {\n      res.query = this.query;\n    }\n    if (this.fragment) {\n      res.fragment = this.fragment;\n    }\n    return res;\n  }\n}\n\n// reserved characters: https://tools.ietf.org/html/rfc3986#section-2.2\nconst encodeTable: { [ch: number]: string } = {\n  [CharCode.Colon]: '%3A', // gen-delims\n  [CharCode.Slash]: '%2F',\n  [CharCode.QuestionMark]: '%3F',\n  [CharCode.Hash]: '%23',\n  [CharCode.OpenSquareBracket]: '%5B',\n  [CharCode.CloseSquareBracket]: '%5D',\n  [CharCode.AtSign]: '%40',\n\n  [CharCode.ExclamationMark]: '%21', // sub-delims\n  [CharCode.DollarSign]: '%24',\n  [CharCode.Ampersand]: '%26',\n  [CharCode.SingleQuote]: '%27',\n  [CharCode.OpenParen]: '%28',\n  [CharCode.CloseParen]: '%29',\n  [CharCode.Asterisk]: '%2A',\n  [CharCode.Plus]: '%2B',\n  [CharCode.Comma]: '%2C',\n  [CharCode.Semicolon]: '%3B',\n  [CharCode.Equals]: '%3D',\n\n  [CharCode.Space]: '%20',\n};\n\nfunction encodeURIComponentFast(uriComponent: string, allowSlash: boolean): string {\n  let res: string | undefined = undefined;\n  let nativeEncodePos = -1;\n\n  for (let pos = 0; pos < uriComponent.length; pos++) {\n    const code = uriComponent.charCodeAt(pos);\n\n    // unreserved characters: https://tools.ietf.org/html/rfc3986#section-2.3\n    if (\n      (code >= CharCode.a && code <= CharCode.z) ||\n      (code >= CharCode.A && code <= CharCode.Z) ||\n      (code >= CharCode.Digit0 && code <= CharCode.Digit9) ||\n      code === CharCode.Dash ||\n      code === CharCode.Period ||\n      code === CharCode.Underline ||\n      code === CharCode.Tilde ||\n      (allowSlash && code === CharCode.Slash)\n    ) {\n      // check if we are delaying native encode\n      if (nativeEncodePos !== -1) {\n        res += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));\n        nativeEncodePos = -1;\n      }\n      // check if we write into a new string (by default we try to return the param)\n      if (res !== undefined) {\n        res += uriComponent.charAt(pos);\n      }\n    } else {\n      // encoding needed, we need to allocate a new string\n      if (res === undefined) {\n        res = uriComponent.substr(0, pos);\n      }\n\n      // check with default table first\n      const escaped = encodeTable[code];\n      if (escaped !== undefined) {\n        // check if we are delaying native encode\n        if (nativeEncodePos !== -1) {\n          res += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));\n          nativeEncodePos = -1;\n        }\n\n        // append escaped variant to result\n        res += escaped;\n      } else if (nativeEncodePos === -1) {\n        // use native encode only when needed\n        nativeEncodePos = pos;\n      }\n    }\n  }\n\n  if (nativeEncodePos !== -1) {\n    res += encodeURIComponent(uriComponent.substring(nativeEncodePos));\n  }\n\n  return res !== undefined ? res : uriComponent;\n}\n\nfunction encodeURIComponentMinimal(path: string): string {\n  let res: string | undefined = undefined;\n  for (let pos = 0; pos < path.length; pos++) {\n    const code = path.charCodeAt(pos);\n    if (code === CharCode.Hash || code === CharCode.QuestionMark) {\n      if (res === undefined) {\n        res = path.substr(0, pos);\n      }\n      res += encodeTable[code];\n    } else {\n      if (res !== undefined) {\n        res += path[pos];\n      }\n    }\n  }\n  return res !== undefined ? res : path;\n}\n\n/**\n * Compute `fsPath` for the given uri\n */\nexport function uriToFsPath(uri: Uri, keepDriveLetterCasing: boolean): string {\n  let value: string;\n  if (uri.authority && uri.path.length > 1 && uri.scheme === 'file') {\n    // unc path: file://shares/c$/far/boo\n    value = `//${uri.authority}${uri.path}`;\n  } else if (\n    uri.path.charCodeAt(0) === CharCode.Slash &&\n    ((uri.path.charCodeAt(1) >= CharCode.A && uri.path.charCodeAt(1) <= CharCode.Z) ||\n      (uri.path.charCodeAt(1) >= CharCode.a && uri.path.charCodeAt(1) <= CharCode.z)) &&\n    uri.path.charCodeAt(2) === CharCode.Colon\n  ) {\n    if (!keepDriveLetterCasing) {\n      // windows drive letter: file:///c:/far/boo\n      value = uri.path[1].toLowerCase() + uri.path.substr(2);\n    } else {\n      value = uri.path.substr(1);\n    }\n  } else {\n    // other path\n    value = uri.path;\n  }\n  return value;\n}\n\n/**\n * Create the external version of a uri\n */\nfunction _asFormatted(uri: Uri, skipEncoding: boolean): string {\n  const encoder = !skipEncoding ? encodeURIComponentFast : encodeURIComponentMinimal;\n\n  let res = '';\n  let { scheme, authority, path, query, fragment } = uri;\n  if (scheme) {\n    res += scheme;\n    res += ':';\n  }\n  if (authority || scheme === 'file') {\n    res += _slash;\n    res += _slash;\n  }\n  if (authority) {\n    let idx = authority.indexOf('@');\n    if (idx !== -1) {\n      // <user>@<auth>\n      const userinfo = authority.substr(0, idx);\n      authority = authority.substr(idx + 1);\n      idx = userinfo.indexOf(':');\n      if (idx === -1) {\n        res += encoder(userinfo, false);\n      } else {\n        // <user>:<pass>@<auth>\n        res += encoder(userinfo.substr(0, idx), false);\n        res += ':';\n        res += encoder(userinfo.substr(idx + 1), false);\n      }\n      res += '@';\n    }\n    authority = authority.toLowerCase();\n    idx = authority.indexOf(':');\n    if (idx === -1) {\n      res += encoder(authority, false);\n    } else {\n      // <auth>:<port>\n      res += encoder(authority.substr(0, idx), false);\n      res += authority.substr(idx);\n    }\n  }\n  if (path) {\n    // lower-case windows drive letters in /C:/fff or C:/fff\n    if (\n      path.length >= 3 &&\n      path.charCodeAt(0) === CharCode.Slash &&\n      path.charCodeAt(2) === CharCode.Colon\n    ) {\n      const code = path.charCodeAt(1);\n      if (code >= CharCode.A && code <= CharCode.Z) {\n        path = `/${String.fromCharCode(code + 32)}:${path.substr(3)}`; // \"/c:\".length === 3\n      }\n    } else if (path.length >= 2 && path.charCodeAt(1) === CharCode.Colon) {\n      const code = path.charCodeAt(0);\n      if (code >= CharCode.A && code <= CharCode.Z) {\n        path = `${String.fromCharCode(code + 32)}:${path.substr(2)}`; // \"/c:\".length === 3\n      }\n    }\n    // encode the rest of the path\n    res += encoder(path, true);\n  }\n  if (query) {\n    res += '?';\n    res += encoder(query, false);\n  }\n  if (fragment) {\n    res += '#';\n    res += !skipEncoding ? encodeURIComponentFast(fragment, false) : fragment;\n  }\n  return res;\n}\n\n// --- decode\n\nfunction decodeURIComponentGraceful(str: string): string {\n  try {\n    return decodeURIComponent(str);\n  } catch {\n    if (str.length > 3) {\n      return str.substr(0, 3) + decodeURIComponentGraceful(str.substr(3));\n    } else {\n      return str;\n    }\n  }\n}\n\nconst _rEncodedAsHex = /(%[0-9A-Za-z][0-9A-Za-z])+/g;\n\nfunction percentDecode(str: string): string {\n  if (!str.match(_rEncodedAsHex)) {\n    return str;\n  }\n  return str.replace(_rEncodedAsHex, (match) => decodeURIComponentGraceful(match));\n}\n\nconst TRAILING_SLASH_RX = /\\/?$/;\n","import { DisposableStore, Emitter, Event } from '@velcro/common';\nimport type * as Monaco from 'monaco-editor';\nimport {\n  EditorEvent,\n  FileCreateEvent,\n  FileRemoveEvent,\n  FileUpdateEvent,\n  WorkerState,\n} from './types';\n\nconst EDITOR_EVENT_THROTTLE_MS = (1000 / 16) | 0;\n\nexport function trackMonaco(monaco: typeof Monaco) {\n  const disposer = new DisposableStore();\n  const worker = new Worker('./velcroWorker.ts', { type: 'module' });\n\n  const trackModel = (model: Monaco.editor.ITextModel) => {\n    model.onWillDispose(() => {\n      const message: FileRemoveEvent = {\n        event: 'file_remove',\n        href: model.uri.toString(true),\n      };\n      postMessage(message);\n      disposerReference.dispose();\n    });\n\n    const disposerReference = disposer.add(\n      model.onDidChangeContent(() => {\n        const message: FileUpdateEvent = {\n          event: 'file_update',\n          content: model.getValue(),\n          href: model.uri.toString(true),\n        };\n        postMessage(message);\n      })\n    );\n\n    const message: FileCreateEvent = {\n      event: 'file_create',\n      content: model.getValue(),\n      href: model.uri.toString(true),\n    };\n    postMessage(message);\n  };\n\n  const postMessageEmitter = new Emitter<EditorEvent>();\n  const postMessageQueue = Event.debounce<EditorEvent, Map<string, EditorEvent>>(\n    postMessageEmitter.event,\n    (last, event) => {\n      if (!last) {\n        last = new Map();\n      }\n\n      last.set(event.href, event);\n\n      return last;\n    },\n    EDITOR_EVENT_THROTTLE_MS\n  )((events) => {\n    worker.postMessage([...events.values()]);\n  });\n\n  disposer.add(postMessageEmitter);\n  disposer.add(postMessageQueue);\n\n  const postMessage = (message: EditorEvent) => {\n    postMessageEmitter.fire(message);\n  };\n\n  // Track existing models\n  monaco.editor.getModels().forEach(trackModel);\n\n  // And future models\n  disposer.add(monaco.editor.onDidCreateModel(trackModel));\n  disposer.add({\n    dispose: () => worker.terminate(),\n  });\n\n  const emitter = new Emitter<WorkerState>();\n  disposer.add(emitter);\n\n  worker.addEventListener('message', (e) => {\n    if (WorkerState.is(e.data)) {\n      emitter.fire(e.data);\n    }\n  });\n\n  return {\n    dispose: () => disposer.dispose(),\n    get onStateChange() {\n      return emitter.event;\n    },\n  };\n}\n","import * as z from 'zod';\n\nexport const FileCreateEvent = z.object({\n  event: z.literal('file_create'),\n  content: z.string(),\n  href: z.string(),\n});\nexport type FileCreateEvent = z.infer<typeof FileCreateEvent>;\n\nexport const FileRemoveEvent = z.object({\n  event: z.literal('file_remove'),\n  href: z.string(),\n});\nexport type FileRemoveEvent = z.infer<typeof FileRemoveEvent>;\n\nexport const FileUpdateEvent = z.object({\n  event: z.literal('file_update'),\n  content: z.string(),\n  href: z.string(),\n});\nexport type FileUpdateEvent = z.infer<typeof FileUpdateEvent>;\n\nexport const EditorEvent = z.union([FileCreateEvent, FileRemoveEvent, FileUpdateEvent]);\nexport type EditorEvent = z.infer<typeof EditorEvent>;\n\nexport const EditorEvents = z.array(EditorEvent);\nexport type EditorEvents = z.infer<typeof EditorEvents>;\n\nexport const BuiltState = z.object({\n  state: z.literal('built'),\n  href: z.string(),\n  start: z.number().int(),\n  end: z.number().int(),\n});\nexport type BuiltState = z.infer<typeof BuiltState>;\n\nexport const BuildingState = z.object({\n  state: z.literal('building'),\n  completed: z.number(),\n  pending: z.number(),\n});\nexport type BuildingState = z.infer<typeof BuildingState>;\n\nexport const ErrorState = z.object({\n  state: z.literal('error'),\n  error: z.object({\n    message: z.string(),\n  }),\n});\nexport type ErrorState = z.infer<typeof ErrorState>;\n\nexport const InitialState = z.object({\n  state: z.literal('initial'),\n});\nexport type InitialState = z.infer<typeof InitialState>;\n\nexport const WorkerState = z.union([BuildingState, BuiltState, ErrorState, InitialState]);\nexport type WorkerState = z.infer<typeof WorkerState>;\n","module.exports = __webpack_public_path__ + \"static/js/0.91dab1ef.chunk.worker.js\"","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as Monaco from 'monaco-editor';\n\nconst EMPTY_ELEMENTS = [\n  'area',\n  'base',\n  'br',\n  'col',\n  'embed',\n  'hr',\n  'img',\n  'input',\n  'keygen',\n  'link',\n  'menuitem',\n  'meta',\n  'param',\n  'source',\n  'track',\n  'wbr',\n];\nexport const conf = {\n  wordPattern: /(-?\\d*\\.\\d\\w*)|([^\\`\\~\\!\\@\\$\\^\\&\\*\\(\\)\\=\\+\\[\\{\\]\\}\\\\\\|\\;\\:\\'\\\"\\,\\.\\<\\>\\/\\s]+)/g,\n  comments: {\n    blockComment: ['{!--', '--}'],\n  },\n  brackets: [\n    ['<!--', '-->'],\n    ['<', '>'],\n    ['{', '}'],\n    ['(', ')'],\n  ],\n  autoClosingPairs: [\n    { open: '{', close: '}' },\n    { open: '[', close: ']' },\n    { open: '(', close: ')' },\n    { open: '\"', close: '\"' },\n    { open: \"'\", close: \"'\" },\n  ],\n  surroundingPairs: [\n    { open: '{', close: '}' },\n    { open: '<', close: '>' },\n    { open: '\"', close: '\"' },\n    { open: \"'\", close: \"'\" },\n  ],\n  onEnterRules: [\n    {\n      beforeText: new RegExp(\n        '<(?!(?:' + EMPTY_ELEMENTS.join('|') + '))(\\\\w[\\\\w\\\\d]*)([^/>]*(?!/)>)[^<]*$',\n        'i'\n      ),\n      afterText: /^<\\/(\\w[\\w\\d]*)\\s*>$/i,\n      action: { indentAction: Monaco.languages.IndentAction.IndentOutdent },\n    },\n    {\n      beforeText: new RegExp(\n        '<(?!(?:' + EMPTY_ELEMENTS.join('|') + '))(\\\\w[\\\\w\\\\d]*)([^/>]*(?!/)>)[^<]*$',\n        'i'\n      ),\n      action: { indentAction: Monaco.languages.IndentAction.Indent },\n    },\n  ],\n};\n\nexport const language = {\n  defaultToken: '',\n  tokenPostfix: '.svelte',\n  ignoreCase: false,\n  tokenizer: {\n    root: [\n      [/<!DOCTYPE/, 'metatag', '@doctype'],\n      [/<!--/, 'comment', '@comment'],\n      [/(<)((?:[\\w\\-]+:)?[\\w\\-]+)(\\s*)(\\/>)/, ['delimiter', 'tag', '', 'delimiter']],\n      [/(<)(script)/, ['delimiter', { token: 'tag', next: '@script' }]],\n      [/(<)(style)/, ['delimiter', { token: 'tag', next: '@style' }]],\n      [/(<)((?:[\\w\\-]+:)?[\\w\\-]+)/, ['delimiter', { token: 'tag', next: '@otherTag' }]],\n      [/(<\\/)((?:[\\w\\-]+:)?[\\w\\-]+)/, ['delimiter', { token: 'tag', next: '@otherTag' }]],\n      [/</, 'delimiter'],\n      [/[^<]+/], // text\n    ],\n    doctype: [\n      [/[^>]+/, 'metatag.content'],\n      [/>/, 'metatag', '@pop'],\n    ],\n    comment: [\n      [/-->/, 'comment', '@pop'],\n      [/[^-]+/, 'comment.content'],\n      [/./, 'comment.content'],\n    ],\n    otherTag: [\n      [/\\/?>/, 'delimiter', '@pop'],\n      [/\"([^\"]*)\"/, 'attribute.value'],\n      [/'([^']*)'/, 'attribute.value'],\n      [/[\\w\\-]+/, 'attribute.name'],\n      [/=/, 'delimiter'],\n      [/[ \\t\\r\\n]+/], // whitespace\n    ],\n    script: [\n      [/type/, 'attribute.name', '@scriptAfterType'],\n      [/\"([^\"]*)\"/, 'attribute.value'],\n      [/'([^']*)'/, 'attribute.value'],\n      [/[\\w\\-]+/, 'attribute.name'],\n      [/=/, 'delimiter'],\n      [/>/, { token: 'delimiter', next: '@scriptEmbedded', nextEmbedded: 'text/javascript' }],\n      [/[ \\t\\r\\n]+/], // whitespace\n      [/(<\\/)(script\\s*)(>)/, ['delimiter', 'tag', { token: 'delimiter', next: '@pop' }]],\n    ],\n    scriptAfterType: [\n      [/=/, 'delimiter', '@scriptAfterTypeEquals'],\n      [/>/, { token: 'delimiter', next: '@scriptEmbedded', nextEmbedded: 'text/javascript' }], // cover invalid e.g. <script type>\n      [/[ \\t\\r\\n]+/], // whitespace\n      [/<\\/script\\s*>/, { token: '@rematch', next: '@pop' }],\n    ],\n    scriptAfterTypeEquals: [\n      [/\"([^\"]*)\"/, { token: 'attribute.value', switchTo: '@scriptWithCustomType.$1' }],\n      [/'([^']*)'/, { token: 'attribute.value', switchTo: '@scriptWithCustomType.$1' }],\n      [/>/, { token: 'delimiter', next: '@scriptEmbedded', nextEmbedded: 'text/javascript' }], // cover invalid e.g. <script type=>\n      [/[ \\t\\r\\n]+/], // whitespace\n      [/<\\/script\\s*>/, { token: '@rematch', next: '@pop' }],\n    ],\n    scriptWithCustomType: [\n      [/>/, { token: 'delimiter', next: '@scriptEmbedded.$S2', nextEmbedded: '$S2' }],\n      [/\"([^\"]*)\"/, 'attribute.value'],\n      [/'([^']*)'/, 'attribute.value'],\n      [/[\\w\\-]+/, 'attribute.name'],\n      [/=/, 'delimiter'],\n      [/[ \\t\\r\\n]+/], // whitespace\n      [/<\\/script\\s*>/, { token: '@rematch', next: '@pop' }],\n    ],\n    scriptEmbedded: [\n      [/<\\/script/, { token: '@rematch', next: '@pop', nextEmbedded: '@pop' }],\n      [/[^<]+/, ''],\n    ],\n    style: [\n      [/type/, 'attribute.name', '@styleAfterType'],\n      [/\"([^\"]*)\"/, 'attribute.value'],\n      [/'([^']*)'/, 'attribute.value'],\n      [/[\\w\\-]+/, 'attribute.name'],\n      [/=/, 'delimiter'],\n      [/>/, { token: 'delimiter', next: '@styleEmbedded', nextEmbedded: 'text/css' }],\n      [/[ \\t\\r\\n]+/], // whitespace\n      [/(<\\/)(style\\s*)(>)/, ['delimiter', 'tag', { token: 'delimiter', next: '@pop' }]],\n    ],\n    styleAfterType: [\n      [/=/, 'delimiter', '@styleAfterTypeEquals'],\n      [/>/, { token: 'delimiter', next: '@styleEmbedded', nextEmbedded: 'text/css' }], // cover invalid e.g. <style type>\n      [/[ \\t\\r\\n]+/], // whitespace\n      [/<\\/style\\s*>/, { token: '@rematch', next: '@pop' }],\n    ],\n    styleAfterTypeEquals: [\n      [/\"([^\"]*)\"/, { token: 'attribute.value', switchTo: '@styleWithCustomType.$1' }],\n      [/'([^']*)'/, { token: 'attribute.value', switchTo: '@styleWithCustomType.$1' }],\n      [/>/, { token: 'delimiter', next: '@styleEmbedded', nextEmbedded: 'text/css' }], // cover invalid e.g. <style type=>\n      [/[ \\t\\r\\n]+/], // whitespace\n      [/<\\/style\\s*>/, { token: '@rematch', next: '@pop' }],\n    ],\n    styleWithCustomType: [\n      [/>/, { token: 'delimiter', next: '@styleEmbedded.$S2', nextEmbedded: '$S2' }],\n      [/\"([^\"]*)\"/, 'attribute.value'],\n      [/'([^']*)'/, 'attribute.value'],\n      [/[\\w\\-]+/, 'attribute.name'],\n      [/=/, 'delimiter'],\n      [/[ \\t\\r\\n]+/], // whitespace\n      [/<\\/style\\s*>/, { token: '@rematch', next: '@pop' }],\n    ],\n    styleEmbedded: [\n      [/<\\/style/, { token: '@rematch', next: '@pop', nextEmbedded: '@pop' }],\n      [/[^<]+/, ''],\n    ],\n  },\n};\n","import { DisposableStore, Emitter, Event, IDisposable } from '@velcro/common';\nimport * as Monaco from 'monaco-editor';\nimport { createContext, useContext, useEffect, useState } from 'react';\nimport * as SvelteLanguage from './svelte.language';\n\nexport class EditorManager implements IDisposable {\n  editor: Monaco.editor.IStandaloneCodeEditor | null = null;\n\n  private readonly disposableStore = new DisposableStore();\n  private readonly initialPath: string | undefined;\n  private readonly viewState = new WeakMap<\n    Monaco.editor.ITextModel,\n    Monaco.editor.ICodeEditorViewState\n  >();\n\n  private readonly onWillFocusModelEmitter = new Emitter<Monaco.editor.ITextModel>();\n  private readonly onDidChangeEmitter = new Emitter<{ model: Monaco.editor.ITextModel }>();\n\n  constructor(options: { files?: Record<string, string>; initialPath?: string } = {}) {\n    this.disposableStore.add(this.onWillFocusModelEmitter);\n    this.disposableStore.add(this.onDidChangeEmitter);\n\n    Monaco.languages.typescript.typescriptDefaults.setEagerModelSync(true);\n    Monaco.languages.typescript.typescriptDefaults.setMaximumWorkerIdleTime(-1);\n    Monaco.languages.typescript.typescriptDefaults.setCompilerOptions({\n      allowJs: true,\n      allowNonTsExtensions: true,\n      allowSyntheticDefaultImports: true,\n      baseUrl: '.',\n      checkJs: true,\n      esModuleInterop: true,\n      experimentalDecorators: true,\n      inlineSourceMap: true,\n      inlineSources: true,\n      isolatedModules: false,\n      jsx: Monaco.languages.typescript.JsxEmit.React,\n      lib: ['dom'],\n      module: Monaco.languages.typescript.ModuleKind.CommonJS,\n      moduleResolution: Monaco.languages.typescript.ModuleResolutionKind.NodeJs,\n      noEmit: false,\n      outDir: `dist`,\n      resolveJsonModule: true,\n      rootDir: '/',\n      sourceMap: true,\n      target: Monaco.languages.typescript.ScriptTarget.ES2015,\n      typeRoots: ['node_modules/@types'],\n    });\n    Monaco.languages.typescript.typescriptDefaults.setDiagnosticsOptions({\n      noSemanticValidation: true,\n      noSyntaxValidation: false,\n    });\n\n    Monaco.languages.register({\n      id: 'svelte',\n      extensions: ['.svelte'],\n      mimetypes: ['text/x-svelte'],\n    });\n    Monaco.languages.setLanguageConfiguration(\n      'svelte',\n      SvelteLanguage.conf as Monaco.languages.LanguageConfiguration\n    );\n    Monaco.languages.setMonarchTokensProvider(\n      'svelte',\n      SvelteLanguage.language as Monaco.languages.IMonarchLanguage\n    );\n\n    if (options.files) {\n      for (const pathname in options.files) {\n        const content = options.files[pathname];\n\n        this.createModel(pathname, content);\n      }\n    }\n\n    this.initialPath = options.initialPath;\n  }\n\n  get dispose() {\n    return this.disposableStore.dispose;\n  }\n\n  get onDidChange(): Event<{ model: Monaco.editor.ITextModel }> {\n    return this.onDidChangeEmitter.event;\n  }\n\n  get onWillFocusModel(): Event<Monaco.editor.ITextModel> {\n    return this.onWillFocusModelEmitter.event;\n  }\n\n  createModel(pathname: string, content = '') {\n    const language = this.inferLanguage(pathname);\n\n    let uri: Monaco.Uri;\n\n    try {\n      uri = Monaco.Uri.file(pathname);\n    } catch (err) {\n      throw new Error(`Invalid path '${pathname}': ${err && err.message}`);\n    }\n\n    if (Monaco.editor.getModel(uri)) {\n      throw new Error(`Cannot create file because it exists '${pathname}'`);\n    }\n\n    return Monaco.editor.createModel(content, language, uri);\n  }\n\n  focusHref(\n    href: string,\n    options: {\n      lineNumber?: number;\n      columnNumber?: number;\n      markers?: Monaco.editor.IMarkerData[];\n    } = {}\n  ) {\n    const model = this.getModelByHref(href);\n\n    if (model) {\n      this.focusModel(model, options);\n    }\n  }\n\n  focusModel(\n    model: Monaco.editor.ITextModel,\n    options: {\n      lineNumber?: number;\n      columnNumber?: number;\n      markers?: Monaco.editor.IMarkerData[];\n    } = {}\n  ) {\n    if (this.editor) {\n      this.editor.setModel(model);\n      if (options.lineNumber) {\n        this.editor.revealLineInCenter(options.lineNumber, Monaco.editor.ScrollType.Smooth);\n        this.editor.setPosition({\n          column: options.columnNumber || 0,\n          lineNumber: options.lineNumber,\n        });\n      }\n      if (options.markers) {\n        Monaco.editor.setModelMarkers(model, 'editorManager', options.markers);\n      }\n      this.editor.focus();\n    }\n  }\n\n  focusPath(\n    path: string,\n    options: {\n      lineNumber?: number;\n      columnNumber?: number;\n      markers?: Monaco.editor.IMarkerData[];\n    } = {}\n  ) {\n    const model = this.getModelByPath(path);\n\n    if (model) {\n      this.focusModel(model, options);\n    }\n  }\n\n  getModelByHref(href: string) {\n    try {\n      const uri = Monaco.Uri.parse(href);\n      return Monaco.editor.getModel(uri);\n    } catch (_) {\n      return null;\n    }\n  }\n\n  getModelByPath(path: string) {\n    return Monaco.editor.getModel(Monaco.Uri.file(path));\n  }\n\n  mount(el: HTMLElement) {\n    if (this.editor) {\n      throw new Error('Invariant violation: Editor already mounted');\n    }\n\n    this.editor = Monaco.editor.create(el, {\n      model: null,\n      automaticLayout: true,\n      minimap: {\n        enabled: false,\n      },\n      showUnused: true,\n      scrollBeyondLastLine: false,\n      theme: 'vs',\n      wordWrap: 'bounded',\n      wrappingIndent: 'same',\n    });\n\n    this.editor.onDidDispose(() => {\n      this.editor = null;\n    });\n\n    this.editor.onDidChangeModel((e) => {\n      if (e.newModelUrl && this.editor) {\n        const model = Monaco.editor.getModel(e.newModelUrl)!;\n        const viewState = this.viewState.get(model);\n\n        if (viewState) {\n          this.editor.restoreViewState(viewState);\n        }\n      }\n    });\n\n    this.editor.onDidBlurEditorText(() => {\n      if (this.editor) {\n        const model = this.editor.getModel();\n        const viewState = this.editor.saveViewState();\n\n        if (model && viewState) {\n          this.viewState.set(model, viewState);\n        }\n      }\n    });\n\n    this.disposableStore.add(this.editor);\n\n    if (this.initialPath) {\n      this.focusPath(this.initialPath);\n    }\n\n    return this.editor;\n  }\n\n  inferLanguage(pathname: string) {\n    return pathname.match(/\\.(?:tsx?|jsx?)$/) ? 'typescript' : undefined;\n  }\n}\n\nexport const EditorManagerContext = createContext<EditorManager>(undefined as any);\n\nexport function useActiveModel() {\n  const workbench = useContext(EditorManagerContext);\n  const [activeModel, setActiveModel] = useState<Monaco.editor.ITextModel | null>(\n    workbench.editor ? workbench.editor.getModel() : null\n  );\n\n  useEffect(() => {\n    const disposable = new DisposableStore();\n\n    const trackEditor = (editor: Monaco.editor.ICodeEditor) => {\n      editor.onDidChangeModel((e) => {\n        const model = e.newModelUrl ? Monaco.editor.getModel(e.newModelUrl) : null;\n\n        setActiveModel(model);\n      });\n\n      disposable.add(\n        editor.onDidBlurEditorText(() => {\n          setActiveModel(null);\n        })\n      );\n\n      disposable.add(\n        editor.onDidFocusEditorText(() => {\n          setActiveModel(editor.getModel());\n        })\n      );\n\n      if (editor.hasTextFocus()) {\n        setActiveModel(editor.getModel());\n      }\n    };\n\n    disposable.add(Monaco.editor.onDidCreateEditor(trackEditor));\n    if (workbench.editor) {\n      trackEditor(workbench.editor);\n    }\n\n    return () => disposable.dispose();\n  }, [workbench.editor, activeModel]);\n\n  return activeModel;\n}\n","import styled from '@emotion/styled/macro';\nimport React, { useRef, useEffect, useContext } from 'react';\nimport { EditorManagerContext } from '../lib/EditorManager';\n\nconst Editor: React.FC<{\n  className?: string;\n}> = ({ className }) => {\n  const el = useRef<HTMLDivElement | null>(null);\n  const editorManager = useContext(EditorManagerContext);\n\n  useEffect(() => {\n    if (!el.current) {\n      return;\n    }\n\n    const editor = editorManager.mount(el.current);\n\n    return () => {\n      editor.dispose();\n    };\n  }, [editorManager, el]);\n\n  return (\n    <div className={className} ref={el}>\n      <div></div>\n    </div>\n  );\n};\n\nexport default styled(Editor)``;\n","import styled from '@emotion/styled/macro';\nimport { Uri } from '@velcro/common';\nimport * as Monaco from 'monaco-editor';\nimport React, { useContext, useEffect, useRef, useState } from 'react';\nimport { EditorManagerContext } from '../lib/EditorManager';\nimport { trackMonaco } from '../velcro/monaco';\nimport { WorkerState } from '../velcro/types';\n\nexport interface DeferredExecutionModuleRecord {\n  code: string;\n  dependencies: Record<string, string>;\n}\n\nexport interface DeferredExecutionManifest {\n  aliases: Record<string, string>;\n  entrypoints: Record<string, string>;\n  modules: Record<string, DeferredExecutionModuleRecord>;\n}\n\ninterface MessageLine {\n  isInternal: boolean;\n  text: string;\n}\ninterface Message {\n  lines: MessageLine[];\n}\n\nconst PreviewProgress = styled.div<{ completed: number; total: number }>`\n  z-index: 1;\n  position: absolute;\n  top: 0;\n  width: ${(props) => (props.total ? `${Math.round((100 * props.completed) / props.total)}%` : 0)};\n  left: 0;\n  height: ${(props) => (props.total ? '2px' : '0')};\n  background-color: #008cba;\n  transition: width 0.5s 0s cubic-bezier(0.455, 0.03, 0.515, 0.955);\n`;\nconst PreviewIframeWrap = styled.div`\n  position: relative;\n  overflow: hidden;\n\n  & > iframe {\n    position: absolute;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n    border: none;\n    width: 100%;\n    height: 100%;\n  }\n`;\nconst PreviewWrap = styled.div`\n  position: relative;\n  background: white;\n\n  ${PreviewIframeWrap} {\n    position: absolute;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n  }\n`;\nconst PreviewMessageError = styled.ul`\n  margin: 0;\n  padding: 1em 2em;\n  font-family: monospace;\n  font-size: 16px;\n  background-color: rgba(255, 0, 0, 0.5);\n  backdrop-filter: brightness(50%);\n  color: white;\n  list-style: none;\n`;\nconst PreviewMessageErrorText = styled.li<{ isInternal: boolean }>`\n  white-space: pre-wrap;\n  opacity: ${(props) => (props.isInternal ? 0.7 : 1.0)};\n`;\nconst PreviewMessages = styled.div`\n  z-index: 1;\n  position: absolute;\n  bottom: 0;\n  right: 0;\n  left: 0;\n  display: flex;\n  flex-direction: column-reverse;\n`;\nconst PreviewMessageLine: React.FC<{ line: MessageLine }> = ({ line }) => {\n  return (\n    <PreviewMessageErrorText isInternal={line.isInternal}>{line.text}</PreviewMessageErrorText>\n  );\n};\nconst PreviewMessage: React.FC<{ message: Message }> = ({ message }) => {\n  return message.lines.length ? (\n    <PreviewMessageError>\n      {message.lines.map((line, i) => (\n        <PreviewMessageLine key={i} line={line}></PreviewMessageLine>\n      ))}\n    </PreviewMessageError>\n  ) : null;\n};\n\nconst Preview: React.FC<{ className?: string }> = (props) => {\n  const editorManager = useContext(EditorManagerContext);\n  const previewWrapRef = useRef<HTMLDivElement | null>(null);\n  const previewIframeRef = useRef<HTMLIFrameElement | null>(null);\n  const [buildState, setBuildState] = useState<WorkerState>({\n    state: 'initial',\n  });\n  const [buildProgress, setBuildProgress] = useState({ completed: 0, total: 0 });\n\n  useEffect(() => {\n    const onMessage = (e: MessageEvent) => {\n      if (\n        previewIframeRef.current &&\n        previewIframeRef.current.contentWindow === e.source &&\n        e.data.event === 'click_error'\n      ) {\n        editorManager.focusPath(Uri.parse(e.data.entry.file).fsPath, {\n          columnNumber: e.data.entry.column,\n          lineNumber: e.data.entry.line,\n        });\n      }\n    };\n\n    window.addEventListener('message', onMessage);\n\n    return () => window.removeEventListener('message', onMessage);\n  });\n\n  useEffect(() => {\n    const monacoIntegration = trackMonaco(Monaco);\n\n    monacoIntegration.onStateChange((state) => {\n      setBuildState(state);\n\n      switch (state.state) {\n        case 'building': {\n          setBuildProgress({\n            completed: state.completed,\n            total: state.completed + state.pending,\n          });\n          break;\n        }\n        case 'built': {\n          console.debug(\n            'Rebuild finished, build latency: %d, end-to-end latency: %d',\n            state.end - state.start,\n            Date.now() - state.start\n          );\n\n          const iframe = document.createElement('iframe');\n          iframe.style.display = 'none';\n          iframe.src = state.href;\n\n          if (previewWrapRef.current) {\n            previewWrapRef.current.appendChild(iframe);\n          }\n\n          const onLoad = () => {\n            iframe.removeEventListener('error', onError);\n            iframe.style.display = '';\n\n            if (previewIframeRef.current) {\n              previewIframeRef.current.remove();\n            }\n\n            previewIframeRef.current = iframe;\n          };\n          const onError = () => {\n            iframe.removeEventListener('load', onLoad);\n            iframe.remove();\n          };\n\n          iframe.addEventListener('load', onLoad, { once: true });\n          iframe.addEventListener('error', onError, { once: true });\n\n          break;\n        }\n      }\n    });\n\n    return () => {\n      monacoIntegration.dispose();\n    };\n  }, [setBuildProgress, setBuildState]);\n\n  return (\n    <PreviewWrap className={props.className}>\n      {buildState.state === 'building' ? (\n        <PreviewProgress\n          completed={buildProgress.completed}\n          total={buildProgress.total}\n        ></PreviewProgress>\n      ) : null}\n      <PreviewIframeWrap ref={previewWrapRef}></PreviewIframeWrap>\n      <PreviewMessages>\n        {buildState.state === 'error' ? (\n          <PreviewMessage\n            message={{ lines: [{ isInternal: true, text: buildState.error.message }] }}\n          ></PreviewMessage>\n        ) : null}\n      </PreviewMessages>\n    </PreviewWrap>\n  );\n};\n\nexport default styled(Preview)``;\n","import { DisposableStore } from '@velcro/common';\nimport * as Monaco from 'monaco-editor';\nimport { useEffect, useState } from 'react';\n\n// import { EditorContext } from './context';\n\nexport enum EntryKind {\n  Directory = 'directory',\n  File = 'file',\n}\n\nexport interface IDirectory {\n  type: EntryKind.Directory;\n  uri: Monaco.Uri;\n}\nexport interface IFile {\n  type: EntryKind.File;\n  uri: Monaco.Uri;\n  model: Monaco.editor.ITextModel;\n}\n\nexport type DirectoryEntry = IDirectory | IFile;\n\nexport function useDirectory(uri: Monaco.Uri) {\n  // Make sure the URI always ends with a trailing slash\n  const prefix = uri.toString(true).replace(/\\/?$/, '/');\n  const sortEntries = (models: DirectoryEntry[]) => {\n    return [...models].sort((a, b) => (a.uri.fsPath > b.uri.fsPath ? 1 : -1));\n  };\n\n  const initialEntries = sortEntries(\n    Monaco.editor.getModels().reduce((entries, model) => {\n      const modelUri = model.uri.toString(true);\n\n      if (modelUri.startsWith(prefix)) {\n        const nestedPath = modelUri.slice(prefix.length);\n        const nextDirIdx = nestedPath.indexOf('/');\n\n        if (nextDirIdx === 0) {\n          throw new Error('Invariant error: WAT?');\n        }\n\n        if (nextDirIdx > 0) {\n          // This is an intermediate directory\n          const uri = Monaco.Uri.parse(`${prefix}${nestedPath.slice(0, nextDirIdx + 1)}`);\n\n          entries.push({\n            type: EntryKind.Directory,\n            uri,\n          });\n        } else {\n          entries.push({\n            type: EntryKind.File,\n            uri: model.uri,\n            model,\n          });\n        }\n      }\n\n      return entries;\n    }, [] as DirectoryEntry[])\n  );\n  const [entries, setEntries] = useState(initialEntries);\n\n  useEffect(() => {\n    const disposable = new DisposableStore();\n    const prefix = uri.toString(true).replace(/\\/?$/, '/');\n\n    disposable.add(\n      Monaco.editor.onDidCreateModel((model: Monaco.editor.ITextModel) => {\n        const modelUri = model.uri.toString(true);\n\n        if (modelUri.startsWith(prefix)) {\n          const nestedPath = modelUri.slice(prefix.length);\n          const nextDirIdx = nestedPath.indexOf('/');\n\n          if (nextDirIdx === 0) {\n            throw new Error('Invariant error: WAT?');\n          }\n\n          if (nextDirIdx > 0) {\n            // This is an intermediate directory\n            const uri = Monaco.Uri.parse(`${prefix}${nestedPath.slice(0, nextDirIdx)}`);\n\n            // It is possible that we already have this directory\n            const entry = entries.find((entry) => entry.uri.toString(true) === uri.toString(true));\n\n            if (entry) {\n              if (entry.type !== EntryKind.Directory) {\n                throw new Error(\n                  `Invariant violation: A file in '${prefix}' conflicts with the path of the new file '${modelUri}'`\n                );\n              }\n\n              return;\n            }\n\n            entries.push({ type: EntryKind.Directory, uri });\n\n            return setEntries(sortEntries(entries));\n          }\n\n          if (\n            !entries.find(\n              (entry) =>\n                entry.type === EntryKind.File &&\n                entry.uri.toString(true) === model.uri.toString(true)\n            )\n          ) {\n            entries.push({ type: EntryKind.File, uri: model.uri, model });\n\n            setEntries(sortEntries(entries));\n          }\n        }\n      })\n    );\n\n    disposable.add(\n      Monaco.editor.onWillDisposeModel((model) => {\n        const idx = entries.findIndex(\n          (entry) => entry.type === EntryKind.File && entry.model === model\n        );\n\n        if (idx === -1) {\n          throw new Error(\n            `Invariant violation: Removing an untracked model: '${model.uri.fsPath}'`\n          );\n        }\n\n        entries.splice(idx, 1);\n\n        setEntries(sortEntries(entries));\n      })\n    );\n\n    return () => disposable.dispose();\n  }, [entries, uri]);\n\n  return entries;\n}\n","import styled from '@emotion/styled/macro';\nimport * as Monaco from 'monaco-editor';\nimport React, { useContext, useRef } from 'react';\nimport { Button } from 'reakit/Button';\nimport { Tooltip, TooltipReference, useTooltipState } from 'reakit/Tooltip';\nimport { useDirectory, EntryKind } from '../lib/hooks';\nimport { useActiveModel, EditorManagerContext } from '../lib/EditorManager';\n\nconst Entry = styled.div<{ modelFocused: boolean }>`\n  background-color: ${props => (props.modelFocused ? '#008cba' : 'inherit')};\n  text-decoration: none;\n  color: ${props => (props.modelFocused ? '#fff' : '#262626')};\n\n  height: 25px;\n  padding: 0 0 0 8px;\n  display: flex;\n  flex-direction: row;\n  align-items: center;\n\n  & > span {\n    flex: 1;\n  }\n\n  & > button {\n    display: none;\n  }\n\n  &:hover > button {\n    display: block;\n  }\n\n  ${props =>\n    props.modelFocused\n      ? {\n          ':hover': {\n            color: '#f5f5f5',\n            cursor: 'pointer',\n          },\n        }\n      : {\n          ':hover': {\n            backgroundColor: '#eee',\n            color: '#262626',\n            cursor: 'pointer',\n          },\n        }}\n`;\n\nconst CreateEntry = styled.div`\n  text-decoration: none;\n  color: '#262626';\n\n  height: 25px;\n  padding: 0 0 0 8px;\n  display: flex;\n  align-items: center;\n\n  :hover {\n    background-color: #eee;\n    cursor: pointer;\n  }\n`;\n\nconst SidebarFileDelete = styled(Button)`\n  border: none;\n  background: none;\n\n  :hover {\n    cursor: pointer;\n  }\n`;\n\nconst StyledTooltip = styled.div`\n  font-family: Open Sans, Helvetica Neue, Helvetica, Arial, sans-serif;\n  font-size: 14px;\n  line-height: 1.4;\n  background-color: #333;\n  color: #fff;\n  border-radius: 4px;\n  opacity: 0.9;\n  padding: 0.2em 0.4em;\n`;\n\nconst SidebarFile: React.FC<{ className?: string; model: Monaco.editor.ITextModel }> = ({ className, model }) => {\n  const activeModel = useActiveModel();\n  const editorManager = useContext(EditorManagerContext);\n  const tooltip = useTooltipState({ gutter: 0 });\n\n  const onClickDelete = () => {\n    model.dispose();\n  };\n\n  return (\n    <Entry className={className} modelFocused={model === activeModel}>\n      <span onClick={() => editorManager.focusModel(model)}>{model.uri.fsPath.slice(1)}</span>\n      <TooltipReference {...tooltip} as={SidebarFileDelete} onClick={() => onClickDelete()}>\n        <span role=\"img\" aria-label=\"Delete file\">\n          \n        </span>\n      </TooltipReference>\n      <Tooltip {...tooltip} as={StyledTooltip}>\n        Delete file\n      </Tooltip>\n    </Entry>\n  );\n};\n\nconst Sidebar: React.FC<{ className?: string }> = props => {\n  const rootDir = useRef(Monaco.Uri.file('/'));\n  const entries = useDirectory(rootDir.current);\n  const editorManager = useContext(EditorManagerContext);\n\n  const onClickCreate = () => {\n    const filename = prompt('Filename?');\n\n    if (filename) {\n      editorManager.createModel(filename);\n    }\n  };\n\n  return (\n    <div className={props.className}>\n      {entries.map(entry =>\n        entry.type === EntryKind.Directory ? (\n          <div>{entry.uri.fsPath.slice(1)}</div>\n        ) : (\n          <SidebarFile key={entry.uri.toString(true)} model={entry.model}></SidebarFile>\n        )\n      )}\n      <CreateEntry onClick={() => onClickCreate()}>Create...</CreateEntry>\n    </div>\n  );\n};\n\nexport default styled(Sidebar)`\n  display: flex;\n  flex-direction: column;\n`;\n","import styled from '@emotion/styled/macro';\nimport React from 'react';\n\nimport Editor from './Editor';\nimport Preview from './Preview';\nimport Sidebar from './Sidebar';\nimport { EditorManager, EditorManagerContext } from '../lib/EditorManager';\n\nconst PlaygroundCmp: React.FC<{\n  className?: string;\n  initialPath: string;\n  project: Record<string, string>;\n}> = ({ className, initialPath, project }) => {\n  const editorManager = new EditorManager({ files: project, initialPath: initialPath });\n\n  return (\n    <div className={className}>\n      <EditorManagerContext.Provider value={editorManager}>\n        <Sidebar></Sidebar>\n        <Editor></Editor>\n        <Preview></Preview>\n      </EditorManagerContext.Provider>\n    </div>\n  );\n};\n\nexport const Playground = styled(PlaygroundCmp)`\n  display: flex;\n  flex-direction: row;\n\n  font-family: Open Sans, Helvetica Neue, Helvetica, Arial, sans-serif;\n  font-size: 14px;\n  line-height: 1.4;\n\n  color: #222;\n\n  ${Sidebar} {\n    flex: 1 1 100px;\n    min-width: 100px;\n    max-width: 400px;\n    border-right: 1px solid #ccc;\n  }\n\n  ${Editor} {\n    border-right: 1px solid #ccc;\n  }\n\n  ${Editor}, ${Preview} {\n    flex: 10;\n  }\n`;\n","export const files = {\n  'package.json':\n    JSON.stringify(\n      {\n        name: 'test',\n        version: '0.0.0',\n        dependencies: {\n          svelte: '^3.24.0',\n        },\n      },\n      null,\n      2\n    ) + '\\n',\n  'index.jsx':\n    `\nimport App from './App.svelte';\n\nnew App({\n  target: document.body,\n  props: {\n    name: 'World',\n  }\n});\n    `.trim() + '\\n',\n  'App.svelte':\n    `\n<script>\n  import Button from './Button.svelte';\n\n  export let name;\n</script>\n\n<h1>Hello {name}</h1>\n<Button>Click me, I do nothing</Button>\n    `.trim() + '\\n',\n  'Button.svelte':\n    `\n<button on:click|once={() => alert('well, almost nothing')}><slot /></button>\n    `.trim() + '\\n',\n};\n","import React from 'react';\n\n// import * as serviceWorker from './serviceWorker';\n\ninterface ServiceWorkerEvent extends Event {\n  target: (Partial<ServiceWorker> & EventTarget) | null;\n}\n\ninterface ServiceWorkerContextValue {\n  assetsUpdateReady: boolean;\n  assetsCached: boolean;\n  updateAssets(): void;\n}\n\nconst ServiceWorkerContext = React.createContext<ServiceWorkerContextValue | undefined>(undefined);\n\nexport function ServiceWorkerProvider(props: React.PropsWithChildren<{}>) {\n  const [waitingServiceWorker, setWaitingServiceWorker] = React.useState<ServiceWorker | null>(\n    null\n  );\n  const [assetsUpdateReady, setAssetsUpdateReady] = React.useState(false);\n  const [assetsCached, setAssetsCached] = React.useState(false);\n\n  const value = React.useMemo(() => {\n    return {\n      assetsUpdateReady,\n      assetsCached,\n      // Call when the user confirm update of application and reload page\n      updateAssets: () => {\n        if (waitingServiceWorker) {\n          waitingServiceWorker.addEventListener('statechange', (event: ServiceWorkerEvent) => {\n            if (event.target && event.target.state === 'activated') {\n              window.location.reload();\n            }\n          });\n\n          waitingServiceWorker.postMessage({ type: 'SKIP_WAITING' });\n        }\n      },\n    };\n  }, [assetsUpdateReady, assetsCached, waitingServiceWorker]);\n\n  // Once on component mounted subscribe to Update and Succes events in\n  // CRA's service worker wrapper\n  // React.useEffect(() => {\n  //   serviceWorker.register({\n  //     onUpdate: (registration) => {\n  //       setWaitingServiceWorker(registration.waiting);\n  //     },\n  //     onUpdateAvailable: () => {\n  //       setAssetsUpdateReady(true);\n  //     },\n  //     onSuccess: (registration) => {\n  //       setAssetsCached(true);\n  //       setAssetsUpdateReady(false);\n\n  //       if (registration.active) {\n  //         registration.active.addEventListener('statechange', (event: ServiceWorkerEvent) => {\n  //           if (!navigator.serviceWorker.controller) {\n  //             setAssetsCached(false);\n  //           }\n  //         });\n  //       }\n  //     },\n  //   });\n  // }, []);\n\n  return <ServiceWorkerContext.Provider value={value} {...props} />;\n}\n\nexport function useServiceWorker() {\n  const context = React.useContext(ServiceWorkerContext);\n\n  if (!context) {\n    throw new Error('useServiceWorker must be used within a ServiceWorkerProvider');\n  }\n\n  return context;\n}\n","//@ts-nocheck\nimport { Global, css } from '@emotion/core';\nimport styled from '@emotion/styled/macro';\nimport CssBaseline from '@material-ui/core/CssBaseline';\nimport { OfflineBolt, Update } from '@material-ui/icons';\nimport React from 'react';\nimport { Tooltip, TooltipReference, useTooltipState } from 'reakit/Tooltip';\n\nimport { Playground } from './playground';\nimport { files } from './templates/svelte';\nimport { useServiceWorker, ServiceWorkerProvider } from './useServiceWorker';\nimport { Button } from 'reakit/Button';\n\nconst PlaygroundWrapper = styled.div`\n  background: white;\n  color: #666;\n  display: flex;\n  flex-direction: column;\n\n  ${Playground} {\n    border-bottom: 1px solid #ccc;\n    flex: 1;\n  }\n`;\n\nconst StatusBarItem = styled.span`\n  display: inline-flex;\n  flex-direction: row;\n  align-items: center;\n`;\n\nconst ReloadButton = styled(Button)`\n  border: 0;\n  background: #008cba;\n  margin: 0 0.5em;\n  color: white;\n  border-radius: 2px;\n  font-weight: 600;\n\n  :hover {\n    cursor: pointer;\n    text-decoration: underline;\n  }\n`;\n\nconst StyledTooltip = styled.div`\n  font-family: Open Sans, Helvetica Neue, Helvetica, Arial, sans-serif;\n  font-size: 14px;\n  line-height: 1.4;\n  background-color: #333;\n  color: #fff;\n  border-radius: 4px;\n  opacity: 0.9;\n  padding: 0.2em 0.4em;\n`;\n\nconst StatusBar: React.FC = () => {\n  const serviceWorker = useServiceWorker();\n  const offlineTooltip = useTooltipState({ gutter: 0 });\n  const reloadTooltip = useTooltipState({ gutter: 0 });\n\n  return (\n    <StatusBarStyles>\n      {serviceWorker.assetsCached ? (\n        <TooltipReference {...offlineTooltip} as={StatusBarItem}>\n          <OfflineBolt color=\"inherit\" fontSize=\"small\" />\n          &nbsp;Offline ready\n        </TooltipReference>\n      ) : null}\n      <Tooltip {...offlineTooltip} as={StyledTooltip}>\n        This application has been fully cached and can now be used offline.\n      </Tooltip>\n\n      {serviceWorker.assetsUpdateReady ? (\n        <TooltipReference {...reloadTooltip} as={StatusBarItem}>\n          <Update color=\"inherit\" fontSize=\"small\" />\n          &nbsp;Update ready:\n          <ReloadButton onClick={() => serviceWorker.updateAssets()}>Reload</ReloadButton>\n        </TooltipReference>\n      ) : null}\n      <Tooltip {...reloadTooltip} as={StyledTooltip}>\n        There is an update of this application ready to install. Click install reload to install the\n        update and reload the page.\n      </Tooltip>\n    </StatusBarStyles>\n  );\n};\n\nconst StatusBarStyles = styled.div`\n  display: flex;\n  flex-direction: row;\n\n  font-size: 90%;\n\n  height: 24px;\n  padding: 0 0.5em;\n\n  ${StatusBarItem} {\n    margin-left: 0.5em;\n    margin-right: 0.5em;\n  }\n`;\n\nconst AppWrapper = styled.div`\n  width: 100%;\n  min-width: 200px;\n  max-width: 80vw;\n  margin: 0 auto;\n  padding: 0 0 45px 0;\n\n  @media (max-width: 960px) {\n    padding: 0 15px 15px 15px;\n    max-width: initial;\n  }\n\n  display: flex;\n  flex-direction: column;\n\n  ${PlaygroundWrapper} {\n    flex: 1;\n    background: #f5f5f5;\n    border-radius: 2px;\n    box-shadow: 0 10px 20px rgba(0, 0, 0, 0.19), 0 6px 6px rgba(0, 0, 0, 0.23);\n\n    ${StatusBarStyles} {\n    }\n  }\n`;\n\nconst Title = styled.div`\n  font-family: 'Raleway', sans-serif;\n  font-size: 250%;\n  font-weight: 800;\n  font-variant: small-caps;\n  font-variant-caps: small-caps;\n  color: #00bfff;\n`;\n\nconst Subtitle = styled.div`\n  color: #ddd;\n  font-size: 120%;\n  font-weight: 400;\n`;\n\nconst Link = styled.a`\n  color: white;\n  text-decoration: none;\n\n  :hover {\n    text-decoration: underline;\n  }\n`;\n\nconst Links = styled.div`\n  display: flex;\n  flex-direction: row;\n\n  & > *:not(:last-child):after {\n    padding: 0 0.5em;\n    content: '';\n    color: #aaa;\n    text-decoration: none;\n  }\n\n  ${Link} {\n    color: #ccc;\n  }\n`;\n\nconst Header = styled.div`\n  display: flex;\n  flex-direction: row;\n  align-items: baseline;\n  padding: 0.8em 0 0.3em 0;\n  text-shadow: #000 1px 1px 5px;\n\n  ${Title} {\n    margin-right: 0.5em;\n  }\n\n  ${Subtitle} {\n    margin-right: 0.5em;\n  }\n\n  ${Links} {\n    flex: 1;\n    justify-content: flex-end;\n  }\n`;\n\nconst globalCss = css`\n  @import url('https://fonts.googleapis.com/css?family=Raleway:900&display=swap');\n\n  *,\n  *::before,\n  *::after {\n    box-sizing: border-box;\n  }\n\n  html,\n  body {\n    margin: 0;\n    padding: 0;\n    min-height: 100vh;\n\n    font-family: Open Sans, Helvetica Neue, Helvetica, Arial, sans-serif;\n    font-size: 14px;\n    line-height: 1.4;\n\n    background: #333;\n    color: #fff;\n\n    display: flex;\n    flex-direction: column;\n\n    #root {\n      flex: 1;\n      display: flex;\n      flex-direction: column;\n\n      ${AppWrapper} {\n        flex: 1;\n      }\n    }\n  }\n`;\n\nexport const App: React.FC = () => {\n  return (\n    <ServiceWorkerProvider>\n      <CssBaseline />\n      <AppWrapper>\n        <Global styles={globalCss}></Global>\n        <Header>\n          <Title>Velcro</Title>\n          <Subtitle>The client-side bundler and playground</Subtitle>\n          <Links>\n            <div>\n              <Link href=\"https://twitter.com/filearts\" target=\"_blank\" rel=\"nofollow noreferrer\">\n                @filearts\n              </Link>\n            </div>\n            <div>\n              <Link\n                href=\"https://github.com/ggoodman/velcro\"\n                target=\"_blank\"\n                rel=\"nofollow noreferrer\"\n              >\n                View on GitHub\n              </Link>\n            </div>\n          </Links>\n        </Header>\n        <PlaygroundWrapper>\n          <Playground project={files} initialPath=\"index.jsx\"></Playground>\n        </PlaygroundWrapper>\n      </AppWrapper>\n    </ServiceWorkerProvider>\n  );\n};\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://cra.link/PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(/^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/)\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://cra.link/PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://cra.link/PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch((error) => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log('No internet connection found. App is running in offline mode.');\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then((registration) => {\n        registration.unregister();\n      })\n      .catch((error) => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\n\nimport { App } from './App';\nimport * as serviceWorker from './serviceWorker';\n\nserviceWorker.unregister();\n\nReactDOM.render(<App />, document.getElementById('root'));\n"],"sourceRoot":""}