{"version":3,"sources":["../../@velcro/common/dist/dist-module/index.js","velcro/monaco.ts","velcro/types.ts","velcro/velcroWorker.ts","lib/EditorManager.ts","playground/Editor.tsx","playground/Preview.tsx","lib/hooks.ts","playground/Sidebar.tsx","playground/Playground.tsx","templates/react.ts","useServiceWorker.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["Base64","Error","decode","global","data","from","toString","atob","decodeURIComponent","escape","_data","encode","btoa","unescape","encodeURIComponent","ErrorInvalidArgType","name","expected","actual","determiner","indexOf","replace","type","msg","code","validateString","value","isPosixPathSeparator","normalizeString","path","allowAboveRoot","separator","isPathSeparator","res","lastSegmentLength","lastSlash","dots","i","length","charCodeAt","lastSlashIndex","lastIndexOf","slice","posix","resolve","resolvedPath","resolvedAbsolute","process","cwd","normalize","isAbsolute","trailingSeparator","join","joined","arg","undefined","relative","to","fromEnd","fromLen","toLen","lastCommonSep","fromCode","out","toNamespacedPath","dirname","hasRoot","end","matchedSlash","basename","ext","start","extIdx","firstNonSlashEnd","extname","startDot","startPart","preDotState","format","sep","pathObject","dir","root","base","bind","parse","ret","delimiter","win32","_schemePattern","_singleSlashStart","_doubleSlashStart","_validateUri","_strict","scheme","authority","query","fragment","test","_schemeFix","_referenceResolution","_slash","_regexp","Uri","schemeOrData","this","change","_URI","skipEncoding","_asFormatted","uriToFsPath","uri","trailingSlash","with","TRAILING_SLASH_RX","l","r","child","parent","childHref","parentHref","parentOffset","charAt","prefix","startsWith","thing","fsPath","match","exec","percentDecode","idx","substring","components","pathFragment","newPath","result","_formatted","external","_fsPath","_sep","_pathSepMarker","arguments","$mid","encodeTable","encodeURIComponentFast","uriComponent","allowSlash","nativeEncodePos","pos","substr","escaped","encodeURIComponentMinimal","keepDriveLetterCasing","toLowerCase","encoder","userinfo","String","fromCharCode","_rEncodedAsHex","str","decodeURIComponentGraceful","_a","trackMonaco","monaco","disposer","DisposableStore","worker","Worker","trackModel","model","onWillDispose","message","event","href","postMessage","disposerReference","dispose","add","onDidChangeContent","content","getValue","postMessageEmitter","Emitter","postMessageQueue","Event","debounce","last","Map","set","events","values","fire","editor","getModels","forEach","onDidCreateModel","terminate","emitter","addEventListener","e","WorkerState","is","FileCreateEvent","z","FileRemoveEvent","FileUpdateEvent","EditorEvent","BuiltState","state","int","BuildingState","completed","pending","ErrorState","error","InitialState","module","exports","EditorManager","options","disposableStore","initialPath","viewState","WeakMap","onWillFocusModelEmitter","onDidChangeEmitter","Monaco","typescript","typescriptDefaults","setEagerModelSync","setMaximumWorkerIdleTime","setCompilerOptions","allowJs","allowNonTsExtensions","allowSyntheticDefaultImports","baseUrl","checkJs","esModuleInterop","experimentalDecorators","inlineSourceMap","inlineSources","isolatedModules","jsx","JsxEmit","React","lib","ModuleKind","CommonJS","moduleResolution","ModuleResolutionKind","NodeJs","noEmit","outDir","resolveJsonModule","rootDir","sourceMap","target","ScriptTarget","ES2015","typeRoots","setDiagnosticsOptions","noSemanticValidation","noSyntaxValidation","files","pathname","createModel","language","inferLanguage","file","err","getModel","getModelByHref","focusModel","setModel","lineNumber","revealLineInCenter","ScrollType","Smooth","setPosition","column","columnNumber","markers","setModelMarkers","focus","getModelByPath","_","el","create","automaticLayout","minimap","enabled","showUnused","scrollBeyondLastLine","theme","wordWrap","wrappingIndent","onDidDispose","onDidChangeModel","newModelUrl","get","restoreViewState","onDidBlurEditorText","saveViewState","focusPath","EditorManagerContext","createContext","Editor","className","useRef","editorManager","useContext","useEffect","current","mount","ref","EntryKind","PreviewProgress","props","total","Math","round","PreviewIframeWrap","PreviewWrap","PreviewMessageError","PreviewMessageErrorText","isInternal","PreviewMessages","PreviewMessageLine","line","text","PreviewMessage","lines","map","key","Preview","previewWrapRef","previewIframeRef","useState","buildState","setBuildState","buildProgress","setBuildProgress","onMessage","contentWindow","source","entry","window","removeEventListener","monacoIntegration","onStateChange","console","debug","Date","now","iframe","document","createElement","style","display","src","appendChild","onLoad","onError","remove","once","Entry","modelFocused","color","cursor","backgroundColor","CreateEntry","SidebarFileDelete","Button","StyledTooltip","SidebarFile","activeModel","workbench","setActiveModel","disposable","trackEditor","onDidFocusEditorText","hasTextFocus","onDidCreateEditor","useActiveModel","tooltip","useTooltipState","gutter","onClick","TooltipReference","as","role","aria-label","Tooltip","Sidebar","entries","sortEntries","models","sort","a","b","initialEntries","reduce","modelUri","nestedPath","nextDirIdx","push","Directory","File","setEntries","find","onWillDisposeModel","findIndex","splice","useDirectory","filename","prompt","onClickCreate","PlaygroundCmp","project","Provider","Playground","JSON","stringify","version","dependencies","react","trim","ServiceWorkerContext","ServiceWorkerProvider","waitingServiceWorker","assetsUpdateReady","assetsCached","useMemo","updateAssets","location","reload","PlaygroundWrapper","StatusBarItem","StatusBarStyles","AppWrapper","Title","Subtitle","Link","Links","Header","globalCss","css","App","CssBaseline","styles","rel","Boolean","hostname","navigator","serviceWorker","ready","then","registration","unregister","catch","ReactDOM","render","getElementById"],"mappings":"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","file":"static/js/main.152755e2.chunk.js","sourcesContent":["export { CancellationToken, CancellationTokenSource, DisposableStore, Emitter, Event } from 'ts-primitives';\n\nclass BaseError extends Error {\n    constructor() {\n        super(...arguments);\n        this.name = this.constructor.name;\n    }\n}\nclass AmbiguousModuleError extends BaseError {\n}\nclass CanceledError extends BaseError {\n}\nclass EntryExcludedError extends BaseError {\n    constructor(uri) {\n        super(`Entry was excluded by current configuration '${uri.toString()}'`);\n    }\n}\nclass EntryNotFoundError extends BaseError {\n    constructor(uri) {\n        super(`Unable to resolve '${uri.toString()}'`);\n    }\n}\nclass DependencyNotFoundError extends EntryNotFoundError {\n    constructor(spec, parentUri) {\n        super(`The dependency '${spec}' of '${parentUri.toString()}' was not found`);\n    }\n}\nclass NotResolvableError extends BaseError {\n}\nclass ParseError extends BaseError {\n    constructor(uri, message) {\n        super(`Parsing failed for '${uri.toString()}': ${message}`);\n        this.uri = uri;\n    }\n}\nfunction isCanceledError(err) {\n    return err instanceof CanceledError || (err && err.name === 'CanceledError');\n}\n\n// See: https://github.com/microsoft/TypeScript/pull/26063#issuecomment-461576933\nfunction all(values, token) {\n    let shouldAwait = false;\n    const result = values.map((element) => {\n        if (isThenable(element)) {\n            shouldAwait = true;\n            return checkCancellation(element, token);\n        }\n        return element;\n    });\n    if (shouldAwait) {\n        return Promise.all(result);\n    }\n    return values;\n}\nasync function checkCancellation(promise, token) {\n    try {\n        const result = await promise;\n        if (token.isCancellationRequested) {\n            return Promise.reject(new CanceledError());\n        }\n        return result;\n    }\n    catch (err) {\n        if (token.isCancellationRequested) {\n            return Promise.reject(new CanceledError());\n        }\n        throw err;\n    }\n}\nfunction isThenable(object) {\n    return (object &&\n        // Detection of 'normal' thenable\n        (typeof object.then === 'function' ||\n            // Detection for regenerator runtime state\n            (typeof object.done === 'boolean' &&\n                typeof object.next === 'number' &&\n                typeof object.pre === 'number')));\n}\n\nvar Base64;\n(function (Base64) {\n    Base64.decode = typeof global === 'object' && typeof global['Buffer'] === 'function'\n        ? (data) => global['Buffer'].from(data, 'base64').toString('utf-8')\n        : typeof atob === 'function'\n            ? (data) => decodeURIComponent(escape(atob(data)))\n            : (_data) => {\n                throw new Error('The environment has neither the Buffer nor btoa functions. Please consider polyfilling one of these apis.');\n            };\n    Base64.encode = typeof global === 'object' && typeof global['Buffer'] === 'function'\n        ? (data) => global['Buffer'].from(data).toString('base64')\n        : typeof btoa === 'function'\n            ? (data) => btoa(unescape(encodeURIComponent(data)))\n            : (_data) => {\n                throw new Error('The environment has neither the Buffer nor btoa functions. Please consider polyfilling one of these apis.');\n            };\n})(Base64 || (Base64 = {}));\n\nclass Decoder {\n    constructor() {\n        if (typeof TextDecoder !== 'undefined') {\n            this.decoder = new TextDecoder();\n        }\n        else if (typeof Buffer !== 'function' || typeof Buffer['from'] !== 'function') {\n            throw new Error('The environment supports neither the TextDecoder nor Buffer API. Please consider polyfilling one of these.');\n        }\n    }\n    decode(buf) {\n        const str = this.decoder\n            ? this.decoder.decode(buf)\n            : Buffer.from(buf).toString('utf-8');\n        return str.charCodeAt(0) === 0xfeff ? str.slice(1) : str;\n    }\n}\n\nclass MapSet {\n    constructor() {\n        this._data = new Map();\n    }\n    get size() {\n        return this._data.size;\n    }\n    add(key, value) {\n        let values = this._data.get(key);\n        if (!values) {\n            values = new Set();\n            this._data.set(key, values);\n        }\n        values.add(value);\n        return this;\n    }\n    clear() {\n        this._data.clear();\n    }\n    delete(key, value) {\n        const values = this._data.get(key);\n        if (values) {\n            const ret = values.delete(value);\n            if (!values.size) {\n                this._data.delete(key);\n            }\n            return ret;\n        }\n        return false;\n    }\n    deleteAll(key) {\n        return this._data.delete(key);\n    }\n    get(key) {\n        return this._data.get(key);\n    }\n    has(key) {\n        return this._data.has(key);\n    }\n    hasValue(key, value) {\n        const values = this._data.get(key);\n        return values ? values.has(value) : false;\n    }\n    *entries() {\n        for (const [key, values] of this._data.entries()) {\n            for (const value of values) {\n                yield [key, value];\n            }\n        }\n    }\n    *values() {\n        for (const values of this._data.values()) {\n            yield* values.values();\n        }\n    }\n}\n\nfunction isValidPartialPackageJson(json) {\n    return (typeof json === 'object' &&\n        json !== null &&\n        !hasInvalidOptionalStringField(json, 'name') &&\n        !hasInvalidOptionalStringField(json, 'version') &&\n        !hasInvalidBrowserField(json) &&\n        !hasInvalidOptionalStringField(json, 'main') &&\n        !hasInvalidOptionalStringField(json, 'module') &&\n        !hasInvalidOptionalStringField(json, 'jsnext:main') &&\n        !hasInvalidOptionalStringField(json, 'unpkg') &&\n        !hasInvalidDependenciesField(json, 'dependencies') &&\n        !hasInvalidDependenciesField(json, 'devDependencies') &&\n        !hasInvalidDependenciesField(json, 'peerDependencies'));\n}\nfunction isValidPackageJson(json) {\n    return (typeof json === 'object' &&\n        json !== null &&\n        !hasInvalidRequiredStringField(json, 'name') &&\n        !hasInvalidRequiredStringField(json, 'version') &&\n        !hasInvalidBrowserField(json) &&\n        !hasInvalidOptionalStringField(json, 'main') &&\n        !hasInvalidOptionalStringField(json, 'module') &&\n        !hasInvalidOptionalStringField(json, 'jsnext:main') &&\n        !hasInvalidOptionalStringField(json, 'unpkg') &&\n        !hasInvalidDependenciesField(json, 'dependencies') &&\n        !hasInvalidDependenciesField(json, 'devDependencies') &&\n        !hasInvalidDependenciesField(json, 'peerDependencies'));\n}\nfunction hasInvalidBrowserField(json) {\n    let error = '';\n    const browser = json.browser;\n    if (browser) {\n        if (typeof browser === 'object') {\n            for (const key in browser) {\n                if (typeof key !== 'string') {\n                    error = `The key ${key} of .browser must be a string`;\n                    break;\n                }\n                if (typeof browser[key] !== 'string' && browser[key] !== false) {\n                    error = `The value ${key} of .browser must be a string or false`;\n                    break;\n                }\n            }\n        }\n    }\n    return error;\n}\nfunction hasInvalidRequiredStringField(json, field) {\n    return typeof json[field] !== 'string';\n}\nfunction hasInvalidOptionalStringField(json, field) {\n    return json[field] !== undefined && typeof json[field] !== 'string';\n}\nfunction hasInvalidDependenciesField(json, field) {\n    return (json[field] !== undefined &&\n        typeof json[field] === 'object' &&\n        json[field] !== null &&\n        !Object.keys(json[field]).every((key) => typeof key === 'string' && typeof json[field][key] === 'string'));\n}\nfunction parseBufferAsPartialPackageJson(decoder, content, spec) {\n    try {\n        const text = decoder.decode(content);\n        return parseTextAsPartialPackageJson(text, spec);\n    }\n    catch (err) {\n        throw new Error(`Error decoding manifest buffer for package ${spec}: ${err.message}`);\n    }\n}\nfunction parseBufferAsPackageJson(decoder, content, spec) {\n    try {\n        const text = decoder.decode(content);\n        return parseTextAsPackageJson(text, spec);\n    }\n    catch (err) {\n        throw new Error(`Error decoding manifest buffer for package ${spec}: ${err.message}`);\n    }\n}\nfunction parseTextAsPartialPackageJson(text, spec) {\n    let json;\n    try {\n        json = JSON.parse(text);\n    }\n    catch (err) {\n        throw new Error(`Error parsing manifest as json for package ${spec}: ${err.message}`);\n    }\n    if (!isValidPartialPackageJson(json)) {\n        throw new Error(`Invalid manifest for the package ${spec}`);\n    }\n    return json;\n}\nfunction parseTextAsPackageJson(text, spec) {\n    const json = parseTextAsPartialPackageJson(text, spec);\n    if (!isValidPackageJson(json)) {\n        throw new Error(`Invalid manifest for the package ${spec}`);\n    }\n    return json;\n}\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n// NOTE: VSCode's copy of nodejs path library to be usable in common (non-node) namespace\n// Copied from: https://github.com/nodejs/node/blob/v12.8.1/lib/path.js\n/**\n * Copyright Joyent, Inc. and other Node contributors.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to permit\n * persons to whom the Software is furnished to do so, subject to the\n * following conditions:\n *\n * The above copyright notice and this permission notice shall be included\n * in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n * NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n * USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\nconst CHAR_DOT = 46; /* . */\nconst CHAR_FORWARD_SLASH = 47; /* / */\nclass ErrorInvalidArgType extends Error {\n    constructor(name, expected, actual) {\n        // determiner: 'must be' or 'must not be'\n        let determiner;\n        if (typeof expected === 'string' && expected.indexOf('not ') === 0) {\n            determiner = 'must not be';\n            expected = expected.replace(/^not /, '');\n        }\n        else {\n            determiner = 'must be';\n        }\n        const type = name.indexOf('.') !== -1 ? 'property' : 'argument';\n        let msg = `The \"${name}\" ${type} ${determiner} of type ${expected}`;\n        msg += `. Received type ${typeof actual}`;\n        super(msg);\n        this.code = 'ERR_INVALID_ARG_TYPE';\n    }\n}\nfunction validateString(value, name) {\n    if (typeof value !== 'string') {\n        throw new ErrorInvalidArgType(name, 'string', value);\n    }\n}\nfunction isPosixPathSeparator(code) {\n    return code === CHAR_FORWARD_SLASH;\n}\n// Resolves . and .. elements in a path with directory names\nfunction normalizeString(path, allowAboveRoot, separator, isPathSeparator) {\n    let res = '';\n    let lastSegmentLength = 0;\n    let lastSlash = -1;\n    let dots = 0;\n    let code = 0;\n    for (let i = 0; i <= path.length; ++i) {\n        if (i < path.length) {\n            code = path.charCodeAt(i);\n        }\n        else if (isPathSeparator(code)) {\n            break;\n        }\n        else {\n            code = CHAR_FORWARD_SLASH;\n        }\n        if (isPathSeparator(code)) {\n            if (lastSlash === i - 1 || dots === 1) ;\n            else if (dots === 2) {\n                if (res.length < 2 ||\n                    lastSegmentLength !== 2 ||\n                    res.charCodeAt(res.length - 1) !== CHAR_DOT ||\n                    res.charCodeAt(res.length - 2) !== CHAR_DOT) {\n                    if (res.length > 2) {\n                        const lastSlashIndex = res.lastIndexOf(separator);\n                        if (lastSlashIndex === -1) {\n                            res = '';\n                            lastSegmentLength = 0;\n                        }\n                        else {\n                            res = res.slice(0, lastSlashIndex);\n                            lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);\n                        }\n                        lastSlash = i;\n                        dots = 0;\n                        continue;\n                    }\n                    else if (res.length !== 0) {\n                        res = '';\n                        lastSegmentLength = 0;\n                        lastSlash = i;\n                        dots = 0;\n                        continue;\n                    }\n                }\n                if (allowAboveRoot) {\n                    res += res.length > 0 ? `${separator}..` : '..';\n                    lastSegmentLength = 2;\n                }\n            }\n            else {\n                if (res.length > 0) {\n                    res += `${separator}${path.slice(lastSlash + 1, i)}`;\n                }\n                else {\n                    res = path.slice(lastSlash + 1, i);\n                }\n                lastSegmentLength = i - lastSlash - 1;\n            }\n            lastSlash = i;\n            dots = 0;\n        }\n        else if (code === CHAR_DOT && dots !== -1) {\n            ++dots;\n        }\n        else {\n            dots = -1;\n        }\n    }\n    return res;\n}\nfunction _format(sep, pathObject) {\n    if (pathObject === null || typeof pathObject !== 'object') {\n        throw new ErrorInvalidArgType('pathObject', 'Object', pathObject);\n    }\n    const dir = pathObject.dir || pathObject.root;\n    const base = pathObject.base || `${pathObject.name || ''}${pathObject.ext || ''}`;\n    if (!dir) {\n        return base;\n    }\n    return dir === pathObject.root ? `${dir}${base}` : `${dir}${sep}${base}`;\n}\n// export const win32: IPath = {\n// \t// path.resolve([from ...], to)\n// \tresolve(...pathSegments: string[]): string {\n// \t\tlet resolvedDevice = '';\n// \t\tlet resolvedTail = '';\n// \t\tlet resolvedAbsolute = false;\n// \t\tfor (let i = pathSegments.length - 1; i >= -1; i--) {\n// \t\t\tlet path;\n// \t\t\tif (i >= 0) {\n// \t\t\t\tpath = pathSegments[i];\n// \t\t\t\tvalidateString(path, 'path');\n// \t\t\t\t// Skip empty entries\n// \t\t\t\tif (path.length === 0) {\n// \t\t\t\t\tcontinue;\n// \t\t\t\t}\n// \t\t\t} else if (resolvedDevice.length === 0) {\n// \t\t\t\tpath = process.cwd();\n// \t\t\t} else {\n// \t\t\t\t// Windows has the concept of drive-specific current working\n// \t\t\t\t// directories. If we've resolved a drive letter but not yet an\n// \t\t\t\t// absolute path, get cwd for that drive, or the process cwd if\n// \t\t\t\t// the drive cwd is not available. We're sure the device is not\n// \t\t\t\t// a UNC path at this points, because UNC paths are always absolute.\n// \t\t\t\tpath = (process.env as any)[`=${resolvedDevice}`] || process.cwd();\n// \t\t\t\t// Verify that a cwd was found and that it actually points\n// \t\t\t\t// to our drive. If not, default to the drive's root.\n// \t\t\t\tif (path === undefined ||\n// \t\t\t\t\tpath.slice(0, 2).toLowerCase() !== resolvedDevice.toLowerCase() &&\n// \t\t\t\t\tpath.charCodeAt(2) === CHAR_BACKWARD_SLASH) {\n// \t\t\t\t\tpath = `${resolvedDevice}\\\\`;\n// \t\t\t\t}\n// \t\t\t}\n// \t\t\tconst len = path.length;\n// \t\t\tlet rootEnd = 0;\n// \t\t\tlet device = '';\n// \t\t\tlet isAbsolute = false;\n// \t\t\tconst code = path.charCodeAt(0);\n// \t\t\t// Try to match a root\n// \t\t\tif (len === 1) {\n// \t\t\t\tif (isPathSeparator(code)) {\n// \t\t\t\t\t// `path` contains just a path separator\n// \t\t\t\t\trootEnd = 1;\n// \t\t\t\t\tisAbsolute = true;\n// \t\t\t\t}\n// \t\t\t} else if (isPathSeparator(code)) {\n// \t\t\t\t// Possible UNC root\n// \t\t\t\t// If we started with a separator, we know we at least have an\n// \t\t\t\t// absolute path of some kind (UNC or otherwise)\n// \t\t\t\tisAbsolute = true;\n// \t\t\t\tif (isPathSeparator(path.charCodeAt(1))) {\n// \t\t\t\t\t// Matched double path separator at beginning\n// \t\t\t\t\tlet j = 2;\n// \t\t\t\t\tlet last = j;\n// \t\t\t\t\t// Match 1 or more non-path separators\n// \t\t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n// \t\t\t\t\t\tj++;\n// \t\t\t\t\t}\n// \t\t\t\t\tif (j < len && j !== last) {\n// \t\t\t\t\t\tconst firstPart = path.slice(last, j);\n// \t\t\t\t\t\t// Matched!\n// \t\t\t\t\t\tlast = j;\n// \t\t\t\t\t\t// Match 1 or more path separators\n// \t\t\t\t\t\twhile (j < len && isPathSeparator(path.charCodeAt(j))) {\n// \t\t\t\t\t\t\tj++;\n// \t\t\t\t\t\t}\n// \t\t\t\t\t\tif (j < len && j !== last) {\n// \t\t\t\t\t\t\t// Matched!\n// \t\t\t\t\t\t\tlast = j;\n// \t\t\t\t\t\t\t// Match 1 or more non-path separators\n// \t\t\t\t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n// \t\t\t\t\t\t\t\tj++;\n// \t\t\t\t\t\t\t}\n// \t\t\t\t\t\t\tif (j === len || j !== last) {\n// \t\t\t\t\t\t\t\t// We matched a UNC root\n// \t\t\t\t\t\t\t\tdevice = `\\\\\\\\${firstPart}\\\\${path.slice(last, j)}`;\n// \t\t\t\t\t\t\t\trootEnd = j;\n// \t\t\t\t\t\t\t}\n// \t\t\t\t\t\t}\n// \t\t\t\t\t}\n// \t\t\t\t} else {\n// \t\t\t\t\trootEnd = 1;\n// \t\t\t\t}\n// \t\t\t} else if (isWindowsDeviceRoot(code) &&\n// \t\t\t\tpath.charCodeAt(1) === CHAR_COLON) {\n// \t\t\t\t// Possible device root\n// \t\t\t\tdevice = path.slice(0, 2);\n// \t\t\t\trootEnd = 2;\n// \t\t\t\tif (len > 2 && isPathSeparator(path.charCodeAt(2))) {\n// \t\t\t\t\t// Treat separator following drive name as an absolute path\n// \t\t\t\t\t// indicator\n// \t\t\t\t\tisAbsolute = true;\n// \t\t\t\t\trootEnd = 3;\n// \t\t\t\t}\n// \t\t\t}\n// \t\t\tif (device.length > 0) {\n// \t\t\t\tif (resolvedDevice.length > 0) {\n// \t\t\t\t\tif (device.toLowerCase() !== resolvedDevice.toLowerCase()) {\n// \t\t\t\t\t\t// This path points to another device so it is not applicable\n// \t\t\t\t\t\tcontinue;\n// \t\t\t\t\t}\n// \t\t\t\t} else {\n// \t\t\t\t\tresolvedDevice = device;\n// \t\t\t\t}\n// \t\t\t}\n// \t\t\tif (resolvedAbsolute) {\n// \t\t\t\tif (resolvedDevice.length > 0) {\n// \t\t\t\t\tbreak;\n// \t\t\t\t}\n// \t\t\t} else {\n// \t\t\t\tresolvedTail = `${path.slice(rootEnd)}\\\\${resolvedTail}`;\n// \t\t\t\tresolvedAbsolute = isAbsolute;\n// \t\t\t\tif (isAbsolute && resolvedDevice.length > 0) {\n// \t\t\t\t\tbreak;\n// \t\t\t\t}\n// \t\t\t}\n// \t\t}\n// \t\t// At this point the path should be resolved to a full absolute path,\n// \t\t// but handle relative paths to be safe (might happen when process.cwd()\n// \t\t// fails)\n// \t\t// Normalize the tail path\n// \t\tresolvedTail = normalizeString(resolvedTail, !resolvedAbsolute, '\\\\',\n// \t\t\tisPathSeparator);\n// \t\treturn resolvedAbsolute ?\n// \t\t\t`${resolvedDevice}\\\\${resolvedTail}` :\n// \t\t\t`${resolvedDevice}${resolvedTail}` || '.';\n// \t},\n// \tnormalize(path: string): string {\n// \t\tvalidateString(path, 'path');\n// \t\tconst len = path.length;\n// \t\tif (len === 0) {\n// \t\t\treturn '.';\n// \t\t}\n// \t\tlet rootEnd = 0;\n// \t\tlet device;\n// \t\tlet isAbsolute = false;\n// \t\tconst code = path.charCodeAt(0);\n// \t\t// Try to match a root\n// \t\tif (len === 1) {\n// \t\t\t// `path` contains just a single char, exit early to avoid\n// \t\t\t// unnecessary work\n// \t\t\treturn isPosixPathSeparator(code) ? '\\\\' : path;\n// \t\t}\n// \t\tif (isPathSeparator(code)) {\n// \t\t\t// Possible UNC root\n// \t\t\t// If we started with a separator, we know we at least have an absolute\n// \t\t\t// path of some kind (UNC or otherwise)\n// \t\t\tisAbsolute = true;\n// \t\t\tif (isPathSeparator(path.charCodeAt(1))) {\n// \t\t\t\t// Matched double path separator at beginning\n// \t\t\t\tlet j = 2;\n// \t\t\t\tlet last = j;\n// \t\t\t\t// Match 1 or more non-path separators\n// \t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n// \t\t\t\t\tj++;\n// \t\t\t\t}\n// \t\t\t\tif (j < len && j !== last) {\n// \t\t\t\t\tconst firstPart = path.slice(last, j);\n// \t\t\t\t\t// Matched!\n// \t\t\t\t\tlast = j;\n// \t\t\t\t\t// Match 1 or more path separators\n// \t\t\t\t\twhile (j < len && isPathSeparator(path.charCodeAt(j))) {\n// \t\t\t\t\t\tj++;\n// \t\t\t\t\t}\n// \t\t\t\t\tif (j < len && j !== last) {\n// \t\t\t\t\t\t// Matched!\n// \t\t\t\t\t\tlast = j;\n// \t\t\t\t\t\t// Match 1 or more non-path separators\n// \t\t\t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n// \t\t\t\t\t\t\tj++;\n// \t\t\t\t\t\t}\n// \t\t\t\t\t\tif (j === len) {\n// \t\t\t\t\t\t\t// We matched a UNC root only\n// \t\t\t\t\t\t\t// Return the normalized version of the UNC root since there\n// \t\t\t\t\t\t\t// is nothing left to process\n// \t\t\t\t\t\t\treturn `\\\\\\\\${firstPart}\\\\${path.slice(last)}\\\\`;\n// \t\t\t\t\t\t}\n// \t\t\t\t\t\tif (j !== last) {\n// \t\t\t\t\t\t\t// We matched a UNC root with leftovers\n// \t\t\t\t\t\t\tdevice = `\\\\\\\\${firstPart}\\\\${path.slice(last, j)}`;\n// \t\t\t\t\t\t\trootEnd = j;\n// \t\t\t\t\t\t}\n// \t\t\t\t\t}\n// \t\t\t\t}\n// \t\t\t} else {\n// \t\t\t\trootEnd = 1;\n// \t\t\t}\n// \t\t} else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {\n// \t\t\t// Possible device root\n// \t\t\tdevice = path.slice(0, 2);\n// \t\t\trootEnd = 2;\n// \t\t\tif (len > 2 && isPathSeparator(path.charCodeAt(2))) {\n// \t\t\t\t// Treat separator following drive name as an absolute path\n// \t\t\t\t// indicator\n// \t\t\t\tisAbsolute = true;\n// \t\t\t\trootEnd = 3;\n// \t\t\t}\n// \t\t}\n// \t\tlet tail = rootEnd < len ?\n// \t\t\tnormalizeString(path.slice(rootEnd), !isAbsolute, '\\\\', isPathSeparator) :\n// \t\t\t'';\n// \t\tif (tail.length === 0 && !isAbsolute) {\n// \t\t\ttail = '.';\n// \t\t}\n// \t\tif (tail.length > 0 && isPathSeparator(path.charCodeAt(len - 1))) {\n// \t\t\ttail += '\\\\';\n// \t\t}\n// \t\tif (device === undefined) {\n// \t\t\treturn isAbsolute ? `\\\\${tail}` : tail;\n// \t\t}\n// \t\treturn isAbsolute ? `${device}\\\\${tail}` : `${device}${tail}`;\n// \t},\n// \tisAbsolute(path: string): boolean {\n// \t\tvalidateString(path, 'path');\n// \t\tconst len = path.length;\n// \t\tif (len === 0) {\n// \t\t\treturn false;\n// \t\t}\n// \t\tconst code = path.charCodeAt(0);\n// \t\treturn isPathSeparator(code) ||\n// \t\t\t// Possible device root\n// \t\t\tlen > 2 &&\n// \t\t\tisWindowsDeviceRoot(code) &&\n// \t\t\tpath.charCodeAt(1) === CHAR_COLON &&\n// \t\t\tisPathSeparator(path.charCodeAt(2));\n// \t},\n// \tjoin(...paths: string[]): string {\n// \t\tif (paths.length === 0) {\n// \t\t\treturn '.';\n// \t\t}\n// \t\tlet joined;\n// \t\tlet firstPart: string | undefined;\n// \t\tfor (let i = 0; i < paths.length; ++i) {\n// \t\t\tconst arg = paths[i];\n// \t\t\tvalidateString(arg, 'path');\n// \t\t\tif (arg.length > 0) {\n// \t\t\t\tif (joined === undefined) {\n// \t\t\t\t\tjoined = firstPart = arg;\n// \t\t\t\t}\n// \t\t\t\telse {\n// \t\t\t\t\tjoined += `\\\\${arg}`;\n// \t\t\t\t}\n// \t\t\t}\n// \t\t}\n// \t\tif (joined === undefined) {\n// \t\t\treturn '.';\n// \t\t}\n// \t\t// Make sure that the joined path doesn't start with two slashes, because\n// \t\t// normalize() will mistake it for an UNC path then.\n// \t\t//\n// \t\t// This step is skipped when it is very clear that the user actually\n// \t\t// intended to point at an UNC path. This is assumed when the first\n// \t\t// non-empty string arguments starts with exactly two slashes followed by\n// \t\t// at least one more non-slash character.\n// \t\t//\n// \t\t// Note that for normalize() to treat a path as an UNC path it needs to\n// \t\t// have at least 2 components, so we don't filter for that here.\n// \t\t// This means that the user can use join to construct UNC paths from\n// \t\t// a server name and a share name; for example:\n// \t\t//   path.join('//server', 'share') -> '\\\\\\\\server\\\\share\\\\')\n// \t\tlet needsReplace = true;\n// \t\tlet slashCount = 0;\n// \t\tif (typeof firstPart === 'string' && isPathSeparator(firstPart.charCodeAt(0))) {\n// \t\t\t++slashCount;\n// \t\t\tconst firstLen = firstPart.length;\n// \t\t\tif (firstLen > 1 && isPathSeparator(firstPart.charCodeAt(1))) {\n// \t\t\t\t++slashCount;\n// \t\t\t\tif (firstLen > 2) {\n// \t\t\t\t\tif (isPathSeparator(firstPart.charCodeAt(2))) {\n// \t\t\t\t\t\t++slashCount;\n// \t\t\t\t\t} else {\n// \t\t\t\t\t\t// We matched a UNC path in the first part\n// \t\t\t\t\t\tneedsReplace = false;\n// \t\t\t\t\t}\n// \t\t\t\t}\n// \t\t\t}\n// \t\t}\n// \t\tif (needsReplace) {\n// \t\t\t// Find any more consecutive slashes we need to replace\n// \t\t\twhile (slashCount < joined.length &&\n// \t\t\t\tisPathSeparator(joined.charCodeAt(slashCount))) {\n// \t\t\t\tslashCount++;\n// \t\t\t}\n// \t\t\t// Replace the slashes if needed\n// \t\t\tif (slashCount >= 2) {\n// \t\t\t\tjoined = `\\\\${joined.slice(slashCount)}`;\n// \t\t\t}\n// \t\t}\n// \t\treturn win32.normalize(joined);\n// \t},\n// \t// It will solve the relative path from `from` to `to`, for instance:\n// \t//  from = 'C:\\\\orandea\\\\test\\\\aaa'\n// \t//  to = 'C:\\\\orandea\\\\impl\\\\bbb'\n// \t// The output of the function should be: '..\\\\..\\\\impl\\\\bbb'\n// \trelative(from: string, to: string): string {\n// \t\tvalidateString(from, 'from');\n// \t\tvalidateString(to, 'to');\n// \t\tif (from === to) {\n// \t\t\treturn '';\n// \t\t}\n// \t\tconst fromOrig = win32.resolve(from);\n// \t\tconst toOrig = win32.resolve(to);\n// \t\tif (fromOrig === toOrig) {\n// \t\t\treturn '';\n// \t\t}\n// \t\tfrom = fromOrig.toLowerCase();\n// \t\tto = toOrig.toLowerCase();\n// \t\tif (from === to) {\n// \t\t\treturn '';\n// \t\t}\n// \t\t// Trim any leading backslashes\n// \t\tlet fromStart = 0;\n// \t\twhile (fromStart < from.length &&\n// \t\t\tfrom.charCodeAt(fromStart) === CHAR_BACKWARD_SLASH) {\n// \t\t\tfromStart++;\n// \t\t}\n// \t\t// Trim trailing backslashes (applicable to UNC paths only)\n// \t\tlet fromEnd = from.length;\n// \t\twhile (fromEnd - 1 > fromStart &&\n// \t\t\tfrom.charCodeAt(fromEnd - 1) === CHAR_BACKWARD_SLASH) {\n// \t\t\tfromEnd--;\n// \t\t}\n// \t\tconst fromLen = fromEnd - fromStart;\n// \t\t// Trim any leading backslashes\n// \t\tlet toStart = 0;\n// \t\twhile (toStart < to.length &&\n// \t\t\tto.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {\n// \t\t\ttoStart++;\n// \t\t}\n// \t\t// Trim trailing backslashes (applicable to UNC paths only)\n// \t\tlet toEnd = to.length;\n// \t\twhile (toEnd - 1 > toStart &&\n// \t\t\tto.charCodeAt(toEnd - 1) === CHAR_BACKWARD_SLASH) {\n// \t\t\ttoEnd--;\n// \t\t}\n// \t\tconst toLen = toEnd - toStart;\n// \t\t// Compare paths to find the longest common path from root\n// \t\tconst length = fromLen < toLen ? fromLen : toLen;\n// \t\tlet lastCommonSep = -1;\n// \t\tlet i = 0;\n// \t\tfor (; i < length; i++) {\n// \t\t\tconst fromCode = from.charCodeAt(fromStart + i);\n// \t\t\tif (fromCode !== to.charCodeAt(toStart + i)) {\n// \t\t\t\tbreak;\n// \t\t\t} else if (fromCode === CHAR_BACKWARD_SLASH) {\n// \t\t\t\tlastCommonSep = i;\n// \t\t\t}\n// \t\t}\n// \t\t// We found a mismatch before the first common path separator was seen, so\n// \t\t// return the original `to`.\n// \t\tif (i !== length) {\n// \t\t\tif (lastCommonSep === -1) {\n// \t\t\t\treturn toOrig;\n// \t\t\t}\n// \t\t} else {\n// \t\t\tif (toLen > length) {\n// \t\t\t\tif (to.charCodeAt(toStart + i) === CHAR_BACKWARD_SLASH) {\n// \t\t\t\t\t// We get here if `from` is the exact base path for `to`.\n// \t\t\t\t\t// For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo\\\\bar\\\\baz'\n// \t\t\t\t\treturn toOrig.slice(toStart + i + 1);\n// \t\t\t\t}\n// \t\t\t\tif (i === 2) {\n// \t\t\t\t\t// We get here if `from` is the device root.\n// \t\t\t\t\t// For example: from='C:\\\\'; to='C:\\\\foo'\n// \t\t\t\t\treturn toOrig.slice(toStart + i);\n// \t\t\t\t}\n// \t\t\t}\n// \t\t\tif (fromLen > length) {\n// \t\t\t\tif (from.charCodeAt(fromStart + i) === CHAR_BACKWARD_SLASH) {\n// \t\t\t\t\t// We get here if `to` is the exact base path for `from`.\n// \t\t\t\t\t// For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo'\n// \t\t\t\t\tlastCommonSep = i;\n// \t\t\t\t} else if (i === 2) {\n// \t\t\t\t\t// We get here if `to` is the device root.\n// \t\t\t\t\t// For example: from='C:\\\\foo\\\\bar'; to='C:\\\\'\n// \t\t\t\t\tlastCommonSep = 3;\n// \t\t\t\t}\n// \t\t\t}\n// \t\t\tif (lastCommonSep === -1) {\n// \t\t\t\tlastCommonSep = 0;\n// \t\t\t}\n// \t\t}\n// \t\tlet out = '';\n// \t\t// Generate the relative path based on the path difference between `to` and\n// \t\t// `from`\n// \t\tfor (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n// \t\t\tif (i === fromEnd || from.charCodeAt(i) === CHAR_BACKWARD_SLASH) {\n// \t\t\t\tout += out.length === 0 ? '..' : '\\\\..';\n// \t\t\t}\n// \t\t}\n// \t\ttoStart += lastCommonSep;\n// \t\t// Lastly, append the rest of the destination (`to`) path that comes after\n// \t\t// the common path parts\n// \t\tif (out.length > 0) {\n// \t\t\treturn `${out}${toOrig.slice(toStart, toEnd)}`;\n// \t\t}\n// \t\tif (toOrig.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {\n// \t\t\t++toStart;\n// \t\t}\n// \t\treturn toOrig.slice(toStart, toEnd);\n// \t},\n// \ttoNamespacedPath(path: string): string {\n// \t\t// Note: this will *probably* throw somewhere.\n// \t\tif (typeof path !== 'string') {\n// \t\t\treturn path;\n// \t\t}\n// \t\tif (path.length === 0) {\n// \t\t\treturn '';\n// \t\t}\n// \t\tconst resolvedPath = win32.resolve(path);\n// \t\tif (resolvedPath.length <= 2) {\n// \t\t\treturn path;\n// \t\t}\n// \t\tif (resolvedPath.charCodeAt(0) === CHAR_BACKWARD_SLASH) {\n// \t\t\t// Possible UNC root\n// \t\t\tif (resolvedPath.charCodeAt(1) === CHAR_BACKWARD_SLASH) {\n// \t\t\t\tconst code = resolvedPath.charCodeAt(2);\n// \t\t\t\tif (code !== CHAR_QUESTION_MARK && code !== CHAR_DOT) {\n// \t\t\t\t\t// Matched non-long UNC root, convert the path to a long UNC path\n// \t\t\t\t\treturn `\\\\\\\\?\\\\UNC\\\\${resolvedPath.slice(2)}`;\n// \t\t\t\t}\n// \t\t\t}\n// \t\t} else if (isWindowsDeviceRoot(resolvedPath.charCodeAt(0)) &&\n// \t\t\tresolvedPath.charCodeAt(1) === CHAR_COLON &&\n// \t\t\tresolvedPath.charCodeAt(2) === CHAR_BACKWARD_SLASH) {\n// \t\t\t// Matched device root, convert the path to a long UNC path\n// \t\t\treturn `\\\\\\\\?\\\\${resolvedPath}`;\n// \t\t}\n// \t\treturn path;\n// \t},\n// \tdirname(path: string): string {\n// \t\tvalidateString(path, 'path');\n// \t\tconst len = path.length;\n// \t\tif (len === 0) {\n// \t\t\treturn '.';\n// \t\t}\n// \t\tlet rootEnd = -1;\n// \t\tlet offset = 0;\n// \t\tconst code = path.charCodeAt(0);\n// \t\tif (len === 1) {\n// \t\t\t// `path` contains just a path separator, exit early to avoid\n// \t\t\t// unnecessary work or a dot.\n// \t\t\treturn isPathSeparator(code) ? path : '.';\n// \t\t}\n// \t\t// Try to match a root\n// \t\tif (isPathSeparator(code)) {\n// \t\t\t// Possible UNC root\n// \t\t\trootEnd = offset = 1;\n// \t\t\tif (isPathSeparator(path.charCodeAt(1))) {\n// \t\t\t\t// Matched double path separator at beginning\n// \t\t\t\tlet j = 2;\n// \t\t\t\tlet last = j;\n// \t\t\t\t// Match 1 or more non-path separators\n// \t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n// \t\t\t\t\tj++;\n// \t\t\t\t}\n// \t\t\t\tif (j < len && j !== last) {\n// \t\t\t\t\t// Matched!\n// \t\t\t\t\tlast = j;\n// \t\t\t\t\t// Match 1 or more path separators\n// \t\t\t\t\twhile (j < len && isPathSeparator(path.charCodeAt(j))) {\n// \t\t\t\t\t\tj++;\n// \t\t\t\t\t}\n// \t\t\t\t\tif (j < len && j !== last) {\n// \t\t\t\t\t\t// Matched!\n// \t\t\t\t\t\tlast = j;\n// \t\t\t\t\t\t// Match 1 or more non-path separators\n// \t\t\t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n// \t\t\t\t\t\t\tj++;\n// \t\t\t\t\t\t}\n// \t\t\t\t\t\tif (j === len) {\n// \t\t\t\t\t\t\t// We matched a UNC root only\n// \t\t\t\t\t\t\treturn path;\n// \t\t\t\t\t\t}\n// \t\t\t\t\t\tif (j !== last) {\n// \t\t\t\t\t\t\t// We matched a UNC root with leftovers\n// \t\t\t\t\t\t\t// Offset by 1 to include the separator after the UNC root to\n// \t\t\t\t\t\t\t// treat it as a \"normal root\" on top of a (UNC) root\n// \t\t\t\t\t\t\trootEnd = offset = j + 1;\n// \t\t\t\t\t\t}\n// \t\t\t\t\t}\n// \t\t\t\t}\n// \t\t\t}\n// \t\t\t// Possible device root\n// \t\t} else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {\n// \t\t\trootEnd = len > 2 && isPathSeparator(path.charCodeAt(2)) ? 3 : 2;\n// \t\t\toffset = rootEnd;\n// \t\t}\n// \t\tlet end = -1;\n// \t\tlet matchedSlash = true;\n// \t\tfor (let i = len - 1; i >= offset; --i) {\n// \t\t\tif (isPathSeparator(path.charCodeAt(i))) {\n// \t\t\t\tif (!matchedSlash) {\n// \t\t\t\t\tend = i;\n// \t\t\t\t\tbreak;\n// \t\t\t\t}\n// \t\t\t} else {\n// \t\t\t\t// We saw the first non-path separator\n// \t\t\t\tmatchedSlash = false;\n// \t\t\t}\n// \t\t}\n// \t\tif (end === -1) {\n// \t\t\tif (rootEnd === -1) {\n// \t\t\t\treturn '.';\n// \t\t\t}\n// \t\t\tend = rootEnd;\n// \t\t}\n// \t\treturn path.slice(0, end);\n// \t},\n// \tbasename(path: string, ext?: string): string {\n// \t\tif (ext !== undefined) {\n// \t\t\tvalidateString(ext, 'ext');\n// \t\t}\n// \t\tvalidateString(path, 'path');\n// \t\tlet start = 0;\n// \t\tlet end = -1;\n// \t\tlet matchedSlash = true;\n// \t\tlet i;\n// \t\t// Check for a drive letter prefix so as not to mistake the following\n// \t\t// path separator as an extra separator at the end of the path that can be\n// \t\t// disregarded\n// \t\tif (path.length >= 2 &&\n// \t\t\tisWindowsDeviceRoot(path.charCodeAt(0)) &&\n// \t\t\tpath.charCodeAt(1) === CHAR_COLON) {\n// \t\t\tstart = 2;\n// \t\t}\n// \t\tif (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n// \t\t\tif (ext === path) {\n// \t\t\t\treturn '';\n// \t\t\t}\n// \t\t\tlet extIdx = ext.length - 1;\n// \t\t\tlet firstNonSlashEnd = -1;\n// \t\t\tfor (i = path.length - 1; i >= start; --i) {\n// \t\t\t\tconst code = path.charCodeAt(i);\n// \t\t\t\tif (isPathSeparator(code)) {\n// \t\t\t\t\t// If we reached a path separator that was not part of a set of path\n// \t\t\t\t\t// separators at the end of the string, stop now\n// \t\t\t\t\tif (!matchedSlash) {\n// \t\t\t\t\t\tstart = i + 1;\n// \t\t\t\t\t\tbreak;\n// \t\t\t\t\t}\n// \t\t\t\t} else {\n// \t\t\t\t\tif (firstNonSlashEnd === -1) {\n// \t\t\t\t\t\t// We saw the first non-path separator, remember this index in case\n// \t\t\t\t\t\t// we need it if the extension ends up not matching\n// \t\t\t\t\t\tmatchedSlash = false;\n// \t\t\t\t\t\tfirstNonSlashEnd = i + 1;\n// \t\t\t\t\t}\n// \t\t\t\t\tif (extIdx >= 0) {\n// \t\t\t\t\t\t// Try to match the explicit extension\n// \t\t\t\t\t\tif (code === ext.charCodeAt(extIdx)) {\n// \t\t\t\t\t\t\tif (--extIdx === -1) {\n// \t\t\t\t\t\t\t\t// We matched the extension, so mark this as the end of our path\n// \t\t\t\t\t\t\t\t// component\n// \t\t\t\t\t\t\t\tend = i;\n// \t\t\t\t\t\t\t}\n// \t\t\t\t\t\t} else {\n// \t\t\t\t\t\t\t// Extension does not match, so our result is the entire path\n// \t\t\t\t\t\t\t// component\n// \t\t\t\t\t\t\textIdx = -1;\n// \t\t\t\t\t\t\tend = firstNonSlashEnd;\n// \t\t\t\t\t\t}\n// \t\t\t\t\t}\n// \t\t\t\t}\n// \t\t\t}\n// \t\t\tif (start === end) {\n// \t\t\t\tend = firstNonSlashEnd;\n// \t\t\t} else if (end === -1) {\n// \t\t\t\tend = path.length;\n// \t\t\t}\n// \t\t\treturn path.slice(start, end);\n// \t\t}\n// \t\tfor (i = path.length - 1; i >= start; --i) {\n// \t\t\tif (isPathSeparator(path.charCodeAt(i))) {\n// \t\t\t\t// If we reached a path separator that was not part of a set of path\n// \t\t\t\t// separators at the end of the string, stop now\n// \t\t\t\tif (!matchedSlash) {\n// \t\t\t\t\tstart = i + 1;\n// \t\t\t\t\tbreak;\n// \t\t\t\t}\n// \t\t\t} else if (end === -1) {\n// \t\t\t\t// We saw the first non-path separator, mark this as the end of our\n// \t\t\t\t// path component\n// \t\t\t\tmatchedSlash = false;\n// \t\t\t\tend = i + 1;\n// \t\t\t}\n// \t\t}\n// \t\tif (end === -1) {\n// \t\t\treturn '';\n// \t\t}\n// \t\treturn path.slice(start, end);\n// \t},\n// \textname(path: string): string {\n// \t\tvalidateString(path, 'path');\n// \t\tlet start = 0;\n// \t\tlet startDot = -1;\n// \t\tlet startPart = 0;\n// \t\tlet end = -1;\n// \t\tlet matchedSlash = true;\n// \t\t// Track the state of characters (if any) we see before our first dot and\n// \t\t// after any path separator we find\n// \t\tlet preDotState = 0;\n// \t\t// Check for a drive letter prefix so as not to mistake the following\n// \t\t// path separator as an extra separator at the end of the path that can be\n// \t\t// disregarded\n// \t\tif (path.length >= 2 &&\n// \t\t\tpath.charCodeAt(1) === CHAR_COLON &&\n// \t\t\tisWindowsDeviceRoot(path.charCodeAt(0))) {\n// \t\t\tstart = startPart = 2;\n// \t\t}\n// \t\tfor (let i = path.length - 1; i >= start; --i) {\n// \t\t\tconst code = path.charCodeAt(i);\n// \t\t\tif (isPathSeparator(code)) {\n// \t\t\t\t// If we reached a path separator that was not part of a set of path\n// \t\t\t\t// separators at the end of the string, stop now\n// \t\t\t\tif (!matchedSlash) {\n// \t\t\t\t\tstartPart = i + 1;\n// \t\t\t\t\tbreak;\n// \t\t\t\t}\n// \t\t\t\tcontinue;\n// \t\t\t}\n// \t\t\tif (end === -1) {\n// \t\t\t\t// We saw the first non-path separator, mark this as the end of our\n// \t\t\t\t// extension\n// \t\t\t\tmatchedSlash = false;\n// \t\t\t\tend = i + 1;\n// \t\t\t}\n// \t\t\tif (code === CHAR_DOT) {\n// \t\t\t\t// If this is our first dot, mark it as the start of our extension\n// \t\t\t\tif (startDot === -1) {\n// \t\t\t\t\tstartDot = i;\n// \t\t\t\t}\n// \t\t\t\telse if (preDotState !== 1) {\n// \t\t\t\t\tpreDotState = 1;\n// \t\t\t\t}\n// \t\t\t} else if (startDot !== -1) {\n// \t\t\t\t// We saw a non-dot and non-path separator before our dot, so we should\n// \t\t\t\t// have a good chance at having a non-empty extension\n// \t\t\t\tpreDotState = -1;\n// \t\t\t}\n// \t\t}\n// \t\tif (startDot === -1 ||\n// \t\t\tend === -1 ||\n// \t\t\t// We saw a non-dot character immediately before the dot\n// \t\t\tpreDotState === 0 ||\n// \t\t\t// The (right-most) trimmed path component is exactly '..'\n// \t\t\t(preDotState === 1 &&\n// \t\t\t\tstartDot === end - 1 &&\n// \t\t\t\tstartDot === startPart + 1)) {\n// \t\t\treturn '';\n// \t\t}\n// \t\treturn path.slice(startDot, end);\n// \t},\n// \tformat: _format.bind(null, '\\\\'),\n// \tparse(path) {\n// \t\tvalidateString(path, 'path');\n// \t\tconst ret = { root: '', dir: '', base: '', ext: '', name: '' };\n// \t\tif (path.length === 0) {\n// \t\t\treturn ret;\n// \t\t}\n// \t\tconst len = path.length;\n// \t\tlet rootEnd = 0;\n// \t\tlet code = path.charCodeAt(0);\n// \t\tif (len === 1) {\n// \t\t\tif (isPathSeparator(code)) {\n// \t\t\t\t// `path` contains just a path separator, exit early to avoid\n// \t\t\t\t// unnecessary work\n// \t\t\t\tret.root = ret.dir = path;\n// \t\t\t\treturn ret;\n// \t\t\t}\n// \t\t\tret.base = ret.name = path;\n// \t\t\treturn ret;\n// \t\t}\n// \t\t// Try to match a root\n// \t\tif (isPathSeparator(code)) {\n// \t\t\t// Possible UNC root\n// \t\t\trootEnd = 1;\n// \t\t\tif (isPathSeparator(path.charCodeAt(1))) {\n// \t\t\t\t// Matched double path separator at beginning\n// \t\t\t\tlet j = 2;\n// \t\t\t\tlet last = j;\n// \t\t\t\t// Match 1 or more non-path separators\n// \t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n// \t\t\t\t\tj++;\n// \t\t\t\t}\n// \t\t\t\tif (j < len && j !== last) {\n// \t\t\t\t\t// Matched!\n// \t\t\t\t\tlast = j;\n// \t\t\t\t\t// Match 1 or more path separators\n// \t\t\t\t\twhile (j < len && isPathSeparator(path.charCodeAt(j))) {\n// \t\t\t\t\t\tj++;\n// \t\t\t\t\t}\n// \t\t\t\t\tif (j < len && j !== last) {\n// \t\t\t\t\t\t// Matched!\n// \t\t\t\t\t\tlast = j;\n// \t\t\t\t\t\t// Match 1 or more non-path separators\n// \t\t\t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n// \t\t\t\t\t\t\tj++;\n// \t\t\t\t\t\t}\n// \t\t\t\t\t\tif (j === len) {\n// \t\t\t\t\t\t\t// We matched a UNC root only\n// \t\t\t\t\t\t\trootEnd = j;\n// \t\t\t\t\t\t} else if (j !== last) {\n// \t\t\t\t\t\t\t// We matched a UNC root with leftovers\n// \t\t\t\t\t\t\trootEnd = j + 1;\n// \t\t\t\t\t\t}\n// \t\t\t\t\t}\n// \t\t\t\t}\n// \t\t\t}\n// \t\t} else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {\n// \t\t\t// Possible device root\n// \t\t\tif (len <= 2) {\n// \t\t\t\t// `path` contains just a drive root, exit early to avoid\n// \t\t\t\t// unnecessary work\n// \t\t\t\tret.root = ret.dir = path;\n// \t\t\t\treturn ret;\n// \t\t\t}\n// \t\t\trootEnd = 2;\n// \t\t\tif (isPathSeparator(path.charCodeAt(2))) {\n// \t\t\t\tif (len === 3) {\n// \t\t\t\t\t// `path` contains just a drive root, exit early to avoid\n// \t\t\t\t\t// unnecessary work\n// \t\t\t\t\tret.root = ret.dir = path;\n// \t\t\t\t\treturn ret;\n// \t\t\t\t}\n// \t\t\t\trootEnd = 3;\n// \t\t\t}\n// \t\t}\n// \t\tif (rootEnd > 0) {\n// \t\t\tret.root = path.slice(0, rootEnd);\n// \t\t}\n// \t\tlet startDot = -1;\n// \t\tlet startPart = rootEnd;\n// \t\tlet end = -1;\n// \t\tlet matchedSlash = true;\n// \t\tlet i = path.length - 1;\n// \t\t// Track the state of characters (if any) we see before our first dot and\n// \t\t// after any path separator we find\n// \t\tlet preDotState = 0;\n// \t\t// Get non-dir info\n// \t\tfor (; i >= rootEnd; --i) {\n// \t\t\tcode = path.charCodeAt(i);\n// \t\t\tif (isPathSeparator(code)) {\n// \t\t\t\t// If we reached a path separator that was not part of a set of path\n// \t\t\t\t// separators at the end of the string, stop now\n// \t\t\t\tif (!matchedSlash) {\n// \t\t\t\t\tstartPart = i + 1;\n// \t\t\t\t\tbreak;\n// \t\t\t\t}\n// \t\t\t\tcontinue;\n// \t\t\t}\n// \t\t\tif (end === -1) {\n// \t\t\t\t// We saw the first non-path separator, mark this as the end of our\n// \t\t\t\t// extension\n// \t\t\t\tmatchedSlash = false;\n// \t\t\t\tend = i + 1;\n// \t\t\t}\n// \t\t\tif (code === CHAR_DOT) {\n// \t\t\t\t// If this is our first dot, mark it as the start of our extension\n// \t\t\t\tif (startDot === -1) {\n// \t\t\t\t\tstartDot = i;\n// \t\t\t\t} else if (preDotState !== 1) {\n// \t\t\t\t\tpreDotState = 1;\n// \t\t\t\t}\n// \t\t\t} else if (startDot !== -1) {\n// \t\t\t\t// We saw a non-dot and non-path separator before our dot, so we should\n// \t\t\t\t// have a good chance at having a non-empty extension\n// \t\t\t\tpreDotState = -1;\n// \t\t\t}\n// \t\t}\n// \t\tif (end !== -1) {\n// \t\t\tif (startDot === -1 ||\n// \t\t\t\t// We saw a non-dot character immediately before the dot\n// \t\t\t\tpreDotState === 0 ||\n// \t\t\t\t// The (right-most) trimmed path component is exactly '..'\n// \t\t\t\t(preDotState === 1 &&\n// \t\t\t\t\tstartDot === end - 1 &&\n// \t\t\t\t\tstartDot === startPart + 1)) {\n// \t\t\t\tret.base = ret.name = path.slice(startPart, end);\n// \t\t\t} else {\n// \t\t\t\tret.name = path.slice(startPart, startDot);\n// \t\t\t\tret.base = path.slice(startPart, end);\n// \t\t\t\tret.ext = path.slice(startDot, end);\n// \t\t\t}\n// \t\t}\n// \t\t// If the directory is the root, use the entire root as the `dir` including\n// \t\t// the trailing slash if any (`C:\\abc` -> `C:\\`). Otherwise, strip out the\n// \t\t// trailing slash (`C:\\abc\\def` -> `C:\\abc`).\n// \t\tif (startPart > 0 && startPart !== rootEnd) {\n// \t\t\tret.dir = path.slice(0, startPart - 1);\n// \t\t} else {\n// \t\t\tret.dir = ret.root;\n// \t\t}\n// \t\treturn ret;\n// \t},\n// \tsep: '\\\\',\n// \tdelimiter: ';',\n// \twin32: null,\n// \tposix: null\n// };\nconst posix = {\n    // path.resolve([from ...], to)\n    resolve(...pathSegments) {\n        let resolvedPath = '';\n        let resolvedAbsolute = false;\n        for (let i = pathSegments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n            const path = i >= 0 ? pathSegments[i] : process.cwd();\n            validateString(path, 'path');\n            // Skip empty entries\n            if (path.length === 0) {\n                continue;\n            }\n            resolvedPath = `${path}/${resolvedPath}`;\n            resolvedAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n        }\n        // At this point the path should be resolved to a full absolute path, but\n        // handle relative paths to be safe (might happen when process.cwd() fails)\n        // Normalize the path\n        resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute, '/', isPosixPathSeparator);\n        if (resolvedAbsolute) {\n            return `/${resolvedPath}`;\n        }\n        return resolvedPath.length > 0 ? resolvedPath : '.';\n    },\n    normalize(path) {\n        validateString(path, 'path');\n        if (path.length === 0) {\n            return '.';\n        }\n        const isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n        const trailingSeparator = path.charCodeAt(path.length - 1) === CHAR_FORWARD_SLASH;\n        // Normalize the path\n        path = normalizeString(path, !isAbsolute, '/', isPosixPathSeparator);\n        if (path.length === 0) {\n            if (isAbsolute) {\n                return '/';\n            }\n            return trailingSeparator ? './' : '.';\n        }\n        if (trailingSeparator) {\n            path += '/';\n        }\n        return isAbsolute ? `/${path}` : path;\n    },\n    isAbsolute(path) {\n        validateString(path, 'path');\n        return path.length > 0 && path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n    },\n    join(...paths) {\n        if (paths.length === 0) {\n            return '.';\n        }\n        let joined;\n        for (let i = 0; i < paths.length; ++i) {\n            const arg = paths[i];\n            validateString(arg, 'path');\n            if (arg.length > 0) {\n                if (joined === undefined) {\n                    joined = arg;\n                }\n                else {\n                    joined += `/${arg}`;\n                }\n            }\n        }\n        if (joined === undefined) {\n            return '.';\n        }\n        return posix.normalize(joined);\n    },\n    relative(from, to) {\n        validateString(from, 'from');\n        validateString(to, 'to');\n        if (from === to) {\n            return '';\n        }\n        // Trim leading forward slashes.\n        from = posix.resolve(from);\n        to = posix.resolve(to);\n        if (from === to) {\n            return '';\n        }\n        const fromStart = 1;\n        const fromEnd = from.length;\n        const fromLen = fromEnd - fromStart;\n        const toStart = 1;\n        const toLen = to.length - toStart;\n        // Compare paths to find the longest common path from root\n        const length = fromLen < toLen ? fromLen : toLen;\n        let lastCommonSep = -1;\n        let i = 0;\n        for (; i < length; i++) {\n            const fromCode = from.charCodeAt(fromStart + i);\n            if (fromCode !== to.charCodeAt(toStart + i)) {\n                break;\n            }\n            else if (fromCode === CHAR_FORWARD_SLASH) {\n                lastCommonSep = i;\n            }\n        }\n        if (i === length) {\n            if (toLen > length) {\n                if (to.charCodeAt(toStart + i) === CHAR_FORWARD_SLASH) {\n                    // We get here if `from` is the exact base path for `to`.\n                    // For example: from='/foo/bar'; to='/foo/bar/baz'\n                    return to.slice(toStart + i + 1);\n                }\n                if (i === 0) {\n                    // We get here if `from` is the root\n                    // For example: from='/'; to='/foo'\n                    return to.slice(toStart + i);\n                }\n            }\n            else if (fromLen > length) {\n                if (from.charCodeAt(fromStart + i) === CHAR_FORWARD_SLASH) {\n                    // We get here if `to` is the exact base path for `from`.\n                    // For example: from='/foo/bar/baz'; to='/foo/bar'\n                    lastCommonSep = i;\n                }\n                else if (i === 0) {\n                    // We get here if `to` is the root.\n                    // For example: from='/foo/bar'; to='/'\n                    lastCommonSep = 0;\n                }\n            }\n        }\n        let out = '';\n        // Generate the relative path based on the path difference between `to`\n        // and `from`.\n        for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n            if (i === fromEnd || from.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n                out += out.length === 0 ? '..' : '/..';\n            }\n        }\n        // Lastly, append the rest of the destination (`to`) path that comes after\n        // the common path parts.\n        return `${out}${to.slice(toStart + lastCommonSep)}`;\n    },\n    toNamespacedPath(path) {\n        // Non-op on posix systems\n        return path;\n    },\n    dirname(path) {\n        validateString(path, 'path');\n        if (path.length === 0) {\n            return '.';\n        }\n        const hasRoot = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n        let end = -1;\n        let matchedSlash = true;\n        for (let i = path.length - 1; i >= 1; --i) {\n            if (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n                if (!matchedSlash) {\n                    end = i;\n                    break;\n                }\n            }\n            else {\n                // We saw the first non-path separator\n                matchedSlash = false;\n            }\n        }\n        if (end === -1) {\n            return hasRoot ? '/' : '.';\n        }\n        if (hasRoot && end === 1) {\n            return '//';\n        }\n        return path.slice(0, end);\n    },\n    basename(path, ext) {\n        if (ext !== undefined) {\n            validateString(ext, 'ext');\n        }\n        validateString(path, 'path');\n        let start = 0;\n        let end = -1;\n        let matchedSlash = true;\n        let i;\n        if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n            if (ext === path) {\n                return '';\n            }\n            let extIdx = ext.length - 1;\n            let firstNonSlashEnd = -1;\n            for (i = path.length - 1; i >= 0; --i) {\n                const code = path.charCodeAt(i);\n                if (code === CHAR_FORWARD_SLASH) {\n                    // If we reached a path separator that was not part of a set of path\n                    // separators at the end of the string, stop now\n                    if (!matchedSlash) {\n                        start = i + 1;\n                        break;\n                    }\n                }\n                else {\n                    if (firstNonSlashEnd === -1) {\n                        // We saw the first non-path separator, remember this index in case\n                        // we need it if the extension ends up not matching\n                        matchedSlash = false;\n                        firstNonSlashEnd = i + 1;\n                    }\n                    if (extIdx >= 0) {\n                        // Try to match the explicit extension\n                        if (code === ext.charCodeAt(extIdx)) {\n                            if (--extIdx === -1) {\n                                // We matched the extension, so mark this as the end of our path\n                                // component\n                                end = i;\n                            }\n                        }\n                        else {\n                            // Extension does not match, so our result is the entire path\n                            // component\n                            extIdx = -1;\n                            end = firstNonSlashEnd;\n                        }\n                    }\n                }\n            }\n            if (start === end) {\n                end = firstNonSlashEnd;\n            }\n            else if (end === -1) {\n                end = path.length;\n            }\n            return path.slice(start, end);\n        }\n        for (i = path.length - 1; i >= 0; --i) {\n            if (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n                // If we reached a path separator that was not part of a set of path\n                // separators at the end of the string, stop now\n                if (!matchedSlash) {\n                    start = i + 1;\n                    break;\n                }\n            }\n            else if (end === -1) {\n                // We saw the first non-path separator, mark this as the end of our\n                // path component\n                matchedSlash = false;\n                end = i + 1;\n            }\n        }\n        if (end === -1) {\n            return '';\n        }\n        return path.slice(start, end);\n    },\n    extname(path) {\n        validateString(path, 'path');\n        let startDot = -1;\n        let startPart = 0;\n        let end = -1;\n        let matchedSlash = true;\n        // Track the state of characters (if any) we see before our first dot and\n        // after any path separator we find\n        let preDotState = 0;\n        for (let i = path.length - 1; i >= 0; --i) {\n            const code = path.charCodeAt(i);\n            if (code === CHAR_FORWARD_SLASH) {\n                // If we reached a path separator that was not part of a set of path\n                // separators at the end of the string, stop now\n                if (!matchedSlash) {\n                    startPart = i + 1;\n                    break;\n                }\n                continue;\n            }\n            if (end === -1) {\n                // We saw the first non-path separator, mark this as the end of our\n                // extension\n                matchedSlash = false;\n                end = i + 1;\n            }\n            if (code === CHAR_DOT) {\n                // If this is our first dot, mark it as the start of our extension\n                if (startDot === -1) {\n                    startDot = i;\n                }\n                else if (preDotState !== 1) {\n                    preDotState = 1;\n                }\n            }\n            else if (startDot !== -1) {\n                // We saw a non-dot and non-path separator before our dot, so we should\n                // have a good chance at having a non-empty extension\n                preDotState = -1;\n            }\n        }\n        if (startDot === -1 ||\n            end === -1 ||\n            // We saw a non-dot character immediately before the dot\n            preDotState === 0 ||\n            // The (right-most) trimmed path component is exactly '..'\n            (preDotState === 1 && startDot === end - 1 && startDot === startPart + 1)) {\n            return '';\n        }\n        return path.slice(startDot, end);\n    },\n    format: _format.bind(null, '/'),\n    parse(path) {\n        validateString(path, 'path');\n        const ret = { root: '', dir: '', base: '', ext: '', name: '' };\n        if (path.length === 0) {\n            return ret;\n        }\n        const isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n        let start;\n        if (isAbsolute) {\n            ret.root = '/';\n            start = 1;\n        }\n        else {\n            start = 0;\n        }\n        let startDot = -1;\n        let startPart = 0;\n        let end = -1;\n        let matchedSlash = true;\n        let i = path.length - 1;\n        // Track the state of characters (if any) we see before our first dot and\n        // after any path separator we find\n        let preDotState = 0;\n        // Get non-dir info\n        for (; i >= start; --i) {\n            const code = path.charCodeAt(i);\n            if (code === CHAR_FORWARD_SLASH) {\n                // If we reached a path separator that was not part of a set of path\n                // separators at the end of the string, stop now\n                if (!matchedSlash) {\n                    startPart = i + 1;\n                    break;\n                }\n                continue;\n            }\n            if (end === -1) {\n                // We saw the first non-path separator, mark this as the end of our\n                // extension\n                matchedSlash = false;\n                end = i + 1;\n            }\n            if (code === CHAR_DOT) {\n                // If this is our first dot, mark it as the start of our extension\n                if (startDot === -1) {\n                    startDot = i;\n                }\n                else if (preDotState !== 1) {\n                    preDotState = 1;\n                }\n            }\n            else if (startDot !== -1) {\n                // We saw a non-dot and non-path separator before our dot, so we should\n                // have a good chance at having a non-empty extension\n                preDotState = -1;\n            }\n        }\n        if (end !== -1) {\n            const start = startPart === 0 && isAbsolute ? 1 : startPart;\n            if (startDot === -1 ||\n                // We saw a non-dot character immediately before the dot\n                preDotState === 0 ||\n                // The (right-most) trimmed path component is exactly '..'\n                (preDotState === 1 && startDot === end - 1 && startDot === startPart + 1)) {\n                ret.base = ret.name = path.slice(start, end);\n            }\n            else {\n                ret.name = path.slice(start, startDot);\n                ret.base = path.slice(start, end);\n                ret.ext = path.slice(startDot, end);\n            }\n        }\n        if (startPart > 0) {\n            ret.dir = path.slice(0, startPart - 1);\n        }\n        else if (isAbsolute) {\n            ret.dir = '/';\n        }\n        return ret;\n    },\n    sep: '/',\n    delimiter: ':',\n    win32: null,\n    posix: null,\n};\nconst normalize = posix.normalize;\nconst isAbsolute = posix.isAbsolute;\nconst join = posix.join;\nconst resolve = posix.resolve;\nconst relative = posix.relative;\nconst dirname = posix.dirname;\nconst basename = posix.basename;\nconst extname = posix.extname;\nconst format = posix.format;\nconst parse = posix.parse;\nconst toNamespacedPath = posix.toNamespacedPath;\nconst sep = posix.sep;\nconst delimiter = posix.delimiter;\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nconst _schemePattern = /^\\w[\\w\\d+.-]*$/;\nconst _singleSlashStart = /^\\//;\nconst _doubleSlashStart = /^\\/\\//;\nfunction _validateUri(ret, _strict) {\n    // scheme, must be set\n    if (!ret.scheme && _strict) {\n        throw new Error(`[UriError]: Scheme is missing: {scheme: \"\", authority: \"${ret.authority}\", path: \"${ret.path}\", query: \"${ret.query}\", fragment: \"${ret.fragment}\"}`);\n    }\n    // scheme, https://tools.ietf.org/html/rfc3986#section-3.1\n    // ALPHA *( ALPHA / DIGIT / \"+\" / \"-\" / \".\" )\n    if (ret.scheme && !_schemePattern.test(ret.scheme)) {\n        throw new Error('[UriError]: Scheme contains illegal characters.');\n    }\n    // path, http://tools.ietf.org/html/rfc3986#section-3.3\n    // If a URI contains an authority component, then the path component\n    // must either be empty or begin with a slash (\"/\") character.  If a URI\n    // does not contain an authority component, then the path cannot begin\n    // with two slash characters (\"//\").\n    if (ret.path) {\n        if (ret.authority) {\n            if (!_singleSlashStart.test(ret.path)) {\n                throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash (\"/\") character');\n            }\n        }\n        else {\n            if (_doubleSlashStart.test(ret.path)) {\n                throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters (\"//\")');\n            }\n        }\n    }\n}\n// for a while we allowed uris *without* schemes and this is the migration\n// for them, e.g. an uri without scheme and without strict-mode warns and falls\n// back to the file-scheme. that should cause the least carnage and still be a\n// clear warning\nfunction _schemeFix(scheme, _strict) {\n    if (!scheme && !_strict) {\n        return 'file';\n    }\n    return scheme;\n}\n// implements a bit of https://tools.ietf.org/html/rfc3986#section-5\nfunction _referenceResolution(scheme, path) {\n    // the slash-character is our 'default base' as we don't\n    // support constructing URIs relative to other URIs. This\n    // see https://tools.ietf.org/html/rfc3986#section-5.1.4\n    switch (scheme) {\n        case 'https':\n        case 'http':\n        case 'file':\n            if (!path) {\n                path = _slash;\n            }\n            else if (path[0] !== _slash) {\n                path = _slash + path;\n            }\n            break;\n    }\n    return path;\n}\nconst _empty = '';\nconst _slash = '/';\nconst _regexp = /^(([^:/?#]+?):)?(\\/\\/([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?/;\n/**\n * Uniform Resource Identifier (URI) http://tools.ietf.org/html/rfc3986.\n * This class is a simple parser which creates the basic component parts\n * (http://tools.ietf.org/html/rfc3986#section-3) with minimal validation\n * and encoding.\n *\n * ```txt\n *       foo://example.com:8042/over/there?name=ferret#nose\n *       \\_/   \\______________/\\_________/ \\_________/ \\__/\n *        |           |            |            |        |\n *     scheme     authority       path        query   fragment\n *        |   _____________________|__\n *       / \\ /                        \\\n *       urn:example:animal:ferret:nose\n * ```\n */\nclass Uri {\n    /**\n     * @internal\n     */\n    constructor(schemeOrData, authority, path, query, fragment, _strict = false) {\n        if (typeof schemeOrData === 'object') {\n            this.scheme = schemeOrData.scheme || _empty;\n            this.authority = schemeOrData.authority || _empty;\n            this.path = schemeOrData.path || _empty;\n            this.query = schemeOrData.query || _empty;\n            this.fragment = schemeOrData.fragment || _empty;\n            // no validation because it's this URI\n            // that creates uri components.\n            // _validateUri(this);\n        }\n        else {\n            this.scheme = _schemeFix(schemeOrData, _strict);\n            this.authority = authority || _empty;\n            this.path = _referenceResolution(this.scheme, path || _empty);\n            this.query = query || _empty;\n            this.fragment = fragment || _empty;\n            _validateUri(this, _strict);\n        }\n    }\n    static ensureTrailingSlash(uri, trailingSlash = '/') {\n        return uri.with({\n            path: uri.path.replace(TRAILING_SLASH_RX, trailingSlash),\n        });\n    }\n    static equals(l, r) {\n        return (l.authority === r.authority &&\n            l.fragment === r.fragment &&\n            l.path === r.path &&\n            l.query === r.query &&\n            l.scheme === r.scheme);\n    }\n    static getFirstPathSegmentAfterPrefix(child, parent) {\n        const childHref = child.path;\n        const parentHref = parent.path;\n        const parentOffset = parentHref.charAt(parentHref.length - 1) === '/' ? -1 : 0;\n        for (let i = 0; i <= childHref.length; i++) {\n            if (i < parentHref.length) {\n                if (childHref.charAt(i) !== parentHref.charAt(i)) {\n                    throw new Error(`The child entry ${child.toString()} does not have the pathname of ${parent.toString()} as a prefix`);\n                }\n            }\n            else if (i === parentHref.length + parentOffset) {\n                if (childHref.charAt(i) !== '/') {\n                    throw new Error(`The child entry ${child.toString()} does not have the pathname of ${parent.toString()} as a prefix`);\n                }\n            }\n            else if (childHref.charAt(i) === '/') {\n                return childHref.slice(parentHref.length + 1 + parentOffset, i);\n            }\n        }\n        return childHref.slice(parentHref.length + 1 + parentOffset);\n    }\n    static isPrefixOf(prefix, uri) {\n        return (prefix.authority === uri.authority &&\n            prefix.fragment === uri.fragment &&\n            prefix.query === uri.query &&\n            prefix.scheme === uri.scheme &&\n            uri.path.startsWith(prefix.path));\n    }\n    static isUri(thing) {\n        if (thing instanceof Uri) {\n            return true;\n        }\n        if (!thing) {\n            return false;\n        }\n        return (typeof thing.authority === 'string' &&\n            typeof thing.fragment === 'string' &&\n            typeof thing.path === 'string' &&\n            typeof thing.query === 'string' &&\n            typeof thing.scheme === 'string' &&\n            typeof thing.fsPath === 'function' &&\n            typeof thing.with === 'function' &&\n            typeof thing.toString === 'function');\n    }\n    // ---- filesystem path -----------------------\n    /**\n       * Returns a string representing the corresponding file system path of this URI.\n       * platform specific path separator.\n       *\n       * * Will *not* validate the path for invalid characters and semantics.\n       * * Will *not* look at the scheme of this URI.\n       * * The result shall *not* be used for display purposes but for accessing a file on disk.\n       *\n       *\n       * The *difference* to `URI#path` is the use of the platform specific separator and the handling\n       *\n       * ```ts\n          const u = URI.parse('file://server/c$/folder/file.txt')\n          u.authority === 'server'\n          u.path === '/shares/c$/file.txt'\n          u.fsPath === '\\\\server\\c$\\folder\\file.txt'\n      ```\n       *\n       * Using `URI#path` to read a file (using fs-apis) would not be enough because parts of the path,\n       * namely the server name, would be missing. Therefore `URI#fsPath` exists - it's sugar to ease working\n       * with URIs that represent files on disk (`file` scheme).\n       */\n    get fsPath() {\n        // if (this.scheme !== 'file') {\n        // \tconsole.warn(`[UriError] calling fsPath with scheme ${this.scheme}`);\n        // }\n        return uriToFsPath(this, false);\n    }\n    // ---- modify to new -------------------------\n    with(change) {\n        if (!change) {\n            return this;\n        }\n        let { scheme, authority, path, query, fragment } = change;\n        if (scheme === undefined) {\n            scheme = this.scheme;\n        }\n        else if (scheme === null) {\n            scheme = _empty;\n        }\n        if (authority === undefined) {\n            authority = this.authority;\n        }\n        else if (authority === null) {\n            authority = _empty;\n        }\n        if (path === undefined) {\n            path = this.path;\n        }\n        else if (path === null) {\n            path = _empty;\n        }\n        if (query === undefined) {\n            query = this.query;\n        }\n        else if (query === null) {\n            query = _empty;\n        }\n        if (fragment === undefined) {\n            fragment = this.fragment;\n        }\n        else if (fragment === null) {\n            fragment = _empty;\n        }\n        if (scheme === this.scheme &&\n            authority === this.authority &&\n            path === this.path &&\n            query === this.query &&\n            fragment === this.fragment) {\n            return this;\n        }\n        return new _URI(scheme, authority, path, query, fragment);\n    }\n    // ---- parse & validate ------------------------\n    /**\n     * Creates a new URI from a string, e.g. `http://www.msft.com/some/path`,\n     * `file:///usr/home`, or `scheme:with/path`.\n     *\n     * @param value A string which represents an URI (see `URI#toString`).\n     */\n    static parse(value, _strict = false) {\n        const match = _regexp.exec(value);\n        if (!match) {\n            return new _URI(_empty, _empty, _empty, _empty, _empty);\n        }\n        return new _URI(match[2] || _empty, percentDecode(match[4] || _empty), percentDecode(match[5] || _empty), percentDecode(match[7] || _empty), percentDecode(match[9] || _empty), _strict);\n    }\n    /**\n       * Creates a new URI from a file system path, e.g. `c:\\my\\files`,\n       * `/usr/home`, or `\\\\server\\share\\some\\path`.\n       *\n       * The *difference* between `URI#parse` and `URI#file` is that the latter treats the argument\n       * as path, not as stringified-uri. E.g. `URI.file(path)` is **not the same as**\n       * `URI.parse('file://' + path)` because the path might contain characters that are\n       * interpreted (# and ?). See the following sample:\n       * ```ts\n      const good = URI.file('/coding/c#/project1');\n      good.scheme === 'file';\n      good.path === '/coding/c#/project1';\n      good.fragment === '';\n      const bad = URI.parse('file://' + '/coding/c#/project1');\n      bad.scheme === 'file';\n      bad.path === '/coding/c'; // path is now broken\n      bad.fragment === '/project1';\n      ```\n       *\n       * @param path A file system path (see `URI#fsPath`)\n       */\n    static file(path) {\n        let authority = _empty;\n        // check for authority as used in UNC shares\n        // or use the path as given\n        if (path[0] === _slash && path[1] === _slash) {\n            const idx = path.indexOf(_slash, 2);\n            if (idx === -1) {\n                authority = path.substring(2);\n                path = _slash;\n            }\n            else {\n                authority = path.substring(2, idx);\n                path = path.substring(idx) || _slash;\n            }\n        }\n        return new _URI('file', authority, path, _empty, _empty);\n    }\n    static from(components) {\n        return new _URI(components.scheme, components.authority, components.path, components.query, components.fragment);\n    }\n    /**\n     * Join a URI path with path fragments and normalizes the resulting path.\n     *\n     * @param uri The input URI.\n     * @param pathFragment The path fragment to add to the URI path.\n     * @returns The resulting URI.\n     */\n    static joinPath(uri, ...pathFragment) {\n        if (!uri.path) {\n            throw new Error(`[UriError]: cannot call joinPaths on URI without path`);\n        }\n        const newPath = join(uri.path, ...pathFragment);\n        return uri.with({ path: newPath });\n    }\n    // ---- printing/externalize ---------------------------\n    /**\n     * Creates a string representation for this URI. It's guaranteed that calling\n     * `URI.parse` with the result of this function creates an URI which is equal\n     * to this URI.\n     *\n     * * The result shall *not* be used for display purposes but for externalization or transport.\n     * * The result will be encoded using the percentage encoding and encoding happens mostly\n     * ignore the scheme-specific encoding rules.\n     *\n     * @param skipEncoding Do not encode the result, default is `false`\n     */\n    toString(skipEncoding = true) {\n        return _asFormatted(this, skipEncoding);\n    }\n    toJSON() {\n        return this;\n    }\n    static revive(data) {\n        if (!data) {\n            return data;\n        }\n        else if (data instanceof Uri) {\n            return data;\n        }\n        else {\n            const result = new _URI(data);\n            result._formatted = data.external;\n            result._fsPath = data._sep === _pathSepMarker ? data.fsPath : null;\n            return result;\n        }\n    }\n}\nconst _pathSepMarker = undefined;\n// eslint-disable-next-line @typescript-eslint/naming-convention\nclass _URI extends Uri {\n    constructor() {\n        super(...arguments);\n        this._formatted = null;\n        this._fsPath = null;\n    }\n    get fsPath() {\n        if (!this._fsPath) {\n            this._fsPath = uriToFsPath(this, false);\n        }\n        return this._fsPath;\n    }\n    toString(skipEncoding = true) {\n        if (!skipEncoding) {\n            // we don't cache that\n            return _asFormatted(this, false);\n        }\n        else {\n            if (!this._formatted) {\n                this._formatted = _asFormatted(this, true);\n            }\n            return this._formatted;\n        }\n    }\n    toJSON() {\n        const res = {\n            $mid: 1,\n        };\n        // cached state\n        if (this._fsPath) {\n            res.fsPath = this._fsPath;\n            res._sep = _pathSepMarker;\n        }\n        if (this._formatted) {\n            res.external = this._formatted;\n        }\n        // uri components\n        if (this.path) {\n            res.path = this.path;\n        }\n        if (this.scheme) {\n            res.scheme = this.scheme;\n        }\n        if (this.authority) {\n            res.authority = this.authority;\n        }\n        if (this.query) {\n            res.query = this.query;\n        }\n        if (this.fragment) {\n            res.fragment = this.fragment;\n        }\n        return res;\n    }\n}\n// reserved characters: https://tools.ietf.org/html/rfc3986#section-2.2\nconst encodeTable = {\n    [58 /* Colon */]: '%3A',\n    [47 /* Slash */]: '%2F',\n    [63 /* QuestionMark */]: '%3F',\n    [35 /* Hash */]: '%23',\n    [91 /* OpenSquareBracket */]: '%5B',\n    [93 /* CloseSquareBracket */]: '%5D',\n    [64 /* AtSign */]: '%40',\n    [33 /* ExclamationMark */]: '%21',\n    [36 /* DollarSign */]: '%24',\n    [38 /* Ampersand */]: '%26',\n    [39 /* SingleQuote */]: '%27',\n    [40 /* OpenParen */]: '%28',\n    [41 /* CloseParen */]: '%29',\n    [42 /* Asterisk */]: '%2A',\n    [43 /* Plus */]: '%2B',\n    [44 /* Comma */]: '%2C',\n    [59 /* Semicolon */]: '%3B',\n    [61 /* Equals */]: '%3D',\n    [32 /* Space */]: '%20',\n};\nfunction encodeURIComponentFast(uriComponent, allowSlash) {\n    let res = undefined;\n    let nativeEncodePos = -1;\n    for (let pos = 0; pos < uriComponent.length; pos++) {\n        const code = uriComponent.charCodeAt(pos);\n        // unreserved characters: https://tools.ietf.org/html/rfc3986#section-2.3\n        if ((code >= 97 /* a */ && code <= 122 /* z */) ||\n            (code >= 65 /* A */ && code <= 90 /* Z */) ||\n            (code >= 48 /* Digit0 */ && code <= 57 /* Digit9 */) ||\n            code === 45 /* Dash */ ||\n            code === 46 /* Period */ ||\n            code === 95 /* Underline */ ||\n            code === 126 /* Tilde */ ||\n            (allowSlash && code === 47 /* Slash */)) {\n            // check if we are delaying native encode\n            if (nativeEncodePos !== -1) {\n                res += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));\n                nativeEncodePos = -1;\n            }\n            // check if we write into a new string (by default we try to return the param)\n            if (res !== undefined) {\n                res += uriComponent.charAt(pos);\n            }\n        }\n        else {\n            // encoding needed, we need to allocate a new string\n            if (res === undefined) {\n                res = uriComponent.substr(0, pos);\n            }\n            // check with default table first\n            const escaped = encodeTable[code];\n            if (escaped !== undefined) {\n                // check if we are delaying native encode\n                if (nativeEncodePos !== -1) {\n                    res += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));\n                    nativeEncodePos = -1;\n                }\n                // append escaped variant to result\n                res += escaped;\n            }\n            else if (nativeEncodePos === -1) {\n                // use native encode only when needed\n                nativeEncodePos = pos;\n            }\n        }\n    }\n    if (nativeEncodePos !== -1) {\n        res += encodeURIComponent(uriComponent.substring(nativeEncodePos));\n    }\n    return res !== undefined ? res : uriComponent;\n}\nfunction encodeURIComponentMinimal(path) {\n    let res = undefined;\n    for (let pos = 0; pos < path.length; pos++) {\n        const code = path.charCodeAt(pos);\n        if (code === 35 /* Hash */ || code === 63 /* QuestionMark */) {\n            if (res === undefined) {\n                res = path.substr(0, pos);\n            }\n            res += encodeTable[code];\n        }\n        else {\n            if (res !== undefined) {\n                res += path[pos];\n            }\n        }\n    }\n    return res !== undefined ? res : path;\n}\n/**\n * Compute `fsPath` for the given uri\n */\nfunction uriToFsPath(uri, keepDriveLetterCasing) {\n    let value;\n    if (uri.authority && uri.path.length > 1 && uri.scheme === 'file') {\n        // unc path: file://shares/c$/far/boo\n        value = `//${uri.authority}${uri.path}`;\n    }\n    else if (uri.path.charCodeAt(0) === 47 /* Slash */ &&\n        ((uri.path.charCodeAt(1) >= 65 /* A */ && uri.path.charCodeAt(1) <= 90 /* Z */) ||\n            (uri.path.charCodeAt(1) >= 97 /* a */ && uri.path.charCodeAt(1) <= 122 /* z */)) &&\n        uri.path.charCodeAt(2) === 58 /* Colon */) {\n        if (!keepDriveLetterCasing) {\n            // windows drive letter: file:///c:/far/boo\n            value = uri.path[1].toLowerCase() + uri.path.substr(2);\n        }\n        else {\n            value = uri.path.substr(1);\n        }\n    }\n    else {\n        // other path\n        value = uri.path;\n    }\n    return value;\n}\n/**\n * Create the external version of a uri\n */\nfunction _asFormatted(uri, skipEncoding) {\n    const encoder = !skipEncoding ? encodeURIComponentFast : encodeURIComponentMinimal;\n    let res = '';\n    let { scheme, authority, path, query, fragment } = uri;\n    if (scheme) {\n        res += scheme;\n        res += ':';\n    }\n    if (authority || scheme === 'file') {\n        res += _slash;\n        res += _slash;\n    }\n    if (authority) {\n        let idx = authority.indexOf('@');\n        if (idx !== -1) {\n            // <user>@<auth>\n            const userinfo = authority.substr(0, idx);\n            authority = authority.substr(idx + 1);\n            idx = userinfo.indexOf(':');\n            if (idx === -1) {\n                res += encoder(userinfo, false);\n            }\n            else {\n                // <user>:<pass>@<auth>\n                res += encoder(userinfo.substr(0, idx), false);\n                res += ':';\n                res += encoder(userinfo.substr(idx + 1), false);\n            }\n            res += '@';\n        }\n        authority = authority.toLowerCase();\n        idx = authority.indexOf(':');\n        if (idx === -1) {\n            res += encoder(authority, false);\n        }\n        else {\n            // <auth>:<port>\n            res += encoder(authority.substr(0, idx), false);\n            res += authority.substr(idx);\n        }\n    }\n    if (path) {\n        // lower-case windows drive letters in /C:/fff or C:/fff\n        if (path.length >= 3 &&\n            path.charCodeAt(0) === 47 /* Slash */ &&\n            path.charCodeAt(2) === 58 /* Colon */) {\n            const code = path.charCodeAt(1);\n            if (code >= 65 /* A */ && code <= 90 /* Z */) {\n                path = `/${String.fromCharCode(code + 32)}:${path.substr(3)}`; // \"/c:\".length === 3\n            }\n        }\n        else if (path.length >= 2 && path.charCodeAt(1) === 58 /* Colon */) {\n            const code = path.charCodeAt(0);\n            if (code >= 65 /* A */ && code <= 90 /* Z */) {\n                path = `${String.fromCharCode(code + 32)}:${path.substr(2)}`; // \"/c:\".length === 3\n            }\n        }\n        // encode the rest of the path\n        res += encoder(path, true);\n    }\n    if (query) {\n        res += '?';\n        res += encoder(query, false);\n    }\n    if (fragment) {\n        res += '#';\n        res += !skipEncoding ? encodeURIComponentFast(fragment, false) : fragment;\n    }\n    return res;\n}\n// --- decode\nfunction decodeURIComponentGraceful(str) {\n    try {\n        return decodeURIComponent(str);\n    }\n    catch (_a) {\n        if (str.length > 3) {\n            return str.substr(0, 3) + decodeURIComponentGraceful(str.substr(3));\n        }\n        else {\n            return str;\n        }\n    }\n}\nconst _rEncodedAsHex = /(%[0-9A-Za-z][0-9A-Za-z])+/g;\nfunction percentDecode(str) {\n    if (!str.match(_rEncodedAsHex)) {\n        return str;\n    }\n    return str.replace(_rEncodedAsHex, (match) => decodeURIComponentGraceful(match));\n}\nconst TRAILING_SLASH_RX = /\\/?$/;\n\nconst version = '0.46.0';\n\nexport { AmbiguousModuleError, Base64, CanceledError, Decoder, DependencyNotFoundError, EntryExcludedError, EntryNotFoundError, MapSet, NotResolvableError, ParseError, Uri, all, basename, checkCancellation, delimiter, dirname, extname, format, isAbsolute, isCanceledError, isThenable, isValidPackageJson, isValidPartialPackageJson, join, normalize, parse, parseBufferAsPackageJson, parseBufferAsPartialPackageJson, posix, relative, resolve, sep, toNamespacedPath, uriToFsPath, version };\n//# sourceMappingURL=index.js.map\n","import { DisposableStore, Emitter, Event } from '@velcro/common';\nimport type * as Monaco from 'monaco-editor';\nimport {\n  EditorEvent,\n  FileCreateEvent,\n  FileRemoveEvent,\n  FileUpdateEvent,\n  WorkerState,\n} from './types';\n\nconst EDITOR_EVENT_THROTTLE_MS = (1000 / 16) | 0;\n\nexport function trackMonaco(monaco: typeof Monaco) {\n  const disposer = new DisposableStore();\n  const worker = new Worker('./velcroWorker.ts', { type: 'module' });\n\n  const trackModel = (model: Monaco.editor.ITextModel) => {\n    model.onWillDispose(() => {\n      const message: FileRemoveEvent = {\n        event: 'file_remove',\n        href: model.uri.toString(true),\n      };\n      postMessage(message);\n      disposerReference.dispose();\n    });\n\n    const disposerReference = disposer.add(\n      model.onDidChangeContent(() => {\n        const message: FileUpdateEvent = {\n          event: 'file_update',\n          content: model.getValue(),\n          href: model.uri.toString(true),\n        };\n        postMessage(message);\n      })\n    );\n\n    const message: FileCreateEvent = {\n      event: 'file_create',\n      content: model.getValue(),\n      href: model.uri.toString(true),\n    };\n    postMessage(message);\n  };\n\n  const postMessageEmitter = new Emitter<EditorEvent>();\n  const postMessageQueue = Event.debounce<EditorEvent, Map<string, EditorEvent>>(\n    postMessageEmitter.event,\n    (last, event) => {\n      if (!last) {\n        last = new Map();\n      }\n\n      last.set(event.href, event);\n\n      return last;\n    },\n    EDITOR_EVENT_THROTTLE_MS\n  )((events) => {\n    worker.postMessage([...events.values()]);\n  });\n\n  disposer.add(postMessageEmitter);\n  disposer.add(postMessageQueue);\n\n  const postMessage = (message: EditorEvent) => {\n    postMessageEmitter.fire(message);\n  };\n\n  // Track existing models\n  monaco.editor.getModels().forEach(trackModel);\n\n  // And future models\n  disposer.add(monaco.editor.onDidCreateModel(trackModel));\n  disposer.add({\n    dispose: () => worker.terminate(),\n  });\n\n  const emitter = new Emitter<WorkerState>();\n  disposer.add(emitter);\n\n  worker.addEventListener('message', (e) => {\n    if (WorkerState.is(e.data)) {\n      emitter.fire(e.data);\n    }\n  });\n\n  return {\n    dispose: () => disposer.dispose(),\n    get onStateChange() {\n      return emitter.event;\n    },\n  };\n}\n","import * as z from 'zod';\n\nexport const FileCreateEvent = z.object({\n  event: z.literal('file_create'),\n  content: z.string(),\n  href: z.string(),\n});\nexport type FileCreateEvent = z.infer<typeof FileCreateEvent>;\n\nexport const FileRemoveEvent = z.object({\n  event: z.literal('file_remove'),\n  href: z.string(),\n});\nexport type FileRemoveEvent = z.infer<typeof FileRemoveEvent>;\n\nexport const FileUpdateEvent = z.object({\n  event: z.literal('file_update'),\n  content: z.string(),\n  href: z.string(),\n});\nexport type FileUpdateEvent = z.infer<typeof FileUpdateEvent>;\n\nexport const EditorEvent = z.union([FileCreateEvent, FileRemoveEvent, FileUpdateEvent]);\nexport type EditorEvent = z.infer<typeof EditorEvent>;\n\nexport const EditorEvents = z.array(EditorEvent);\nexport type EditorEvents = z.infer<typeof EditorEvents>;\n\nexport const BuiltState = z.object({\n  state: z.literal('built'),\n  href: z.string(),\n  start: z.number().int(),\n  end: z.number().int(),\n});\nexport type BuiltState = z.infer<typeof BuiltState>;\n\nexport const BuildingState = z.object({\n  state: z.literal('building'),\n  completed: z.number(),\n  pending: z.number(),\n});\nexport type BuildingState = z.infer<typeof BuildingState>;\n\nexport const ErrorState = z.object({\n  state: z.literal('error'),\n  error: z.object({\n    message: z.string(),\n  }),\n});\nexport type ErrorState = z.infer<typeof ErrorState>;\n\nexport const InitialState = z.object({\n  state: z.literal('initial'),\n});\nexport type InitialState = z.infer<typeof InitialState>;\n\nexport const WorkerState = z.union([BuildingState, BuiltState, ErrorState, InitialState]);\nexport type WorkerState = z.infer<typeof WorkerState>;\n","module.exports = __webpack_public_path__ + \"static/js/0.4109523c.chunk.worker.js\"","import { DisposableStore, Emitter, IDisposable } from '@velcro/common';\nimport * as Monaco from 'monaco-editor';\nimport { createContext, useContext, useEffect, useState } from 'react';\n\nexport class EditorManager implements IDisposable {\n  editor: Monaco.editor.IStandaloneCodeEditor | null = null;\n\n  private readonly disposableStore = new DisposableStore();\n  private readonly initialPath: string | undefined;\n  private readonly viewState = new WeakMap<\n    Monaco.editor.ITextModel,\n    Monaco.editor.ICodeEditorViewState\n  >();\n\n  private readonly onWillFocusModelEmitter = new Emitter<Monaco.editor.ITextModel>();\n  private readonly onDidChangeEmitter = new Emitter<{ model: Monaco.editor.ITextModel }>();\n\n  constructor(options: { files?: Record<string, string>; initialPath?: string } = {}) {\n    this.disposableStore.add(this.onWillFocusModelEmitter);\n    this.disposableStore.add(this.onDidChangeEmitter);\n\n    Monaco.languages.typescript.typescriptDefaults.setEagerModelSync(true);\n    Monaco.languages.typescript.typescriptDefaults.setMaximumWorkerIdleTime(-1);\n    Monaco.languages.typescript.typescriptDefaults.setCompilerOptions({\n      allowJs: true,\n      allowNonTsExtensions: true,\n      allowSyntheticDefaultImports: true,\n      baseUrl: '.',\n      checkJs: true,\n      esModuleInterop: true,\n      experimentalDecorators: true,\n      inlineSourceMap: true,\n      inlineSources: true,\n      isolatedModules: false,\n      jsx: Monaco.languages.typescript.JsxEmit.React,\n      lib: ['dom'],\n      module: Monaco.languages.typescript.ModuleKind.CommonJS,\n      moduleResolution: Monaco.languages.typescript.ModuleResolutionKind.NodeJs,\n      noEmit: false,\n      outDir: `dist`,\n      resolveJsonModule: true,\n      rootDir: '/',\n      sourceMap: true,\n      target: Monaco.languages.typescript.ScriptTarget.ES2015,\n      typeRoots: ['node_modules/@types'],\n    });\n    Monaco.languages.typescript.typescriptDefaults.setDiagnosticsOptions({\n      noSemanticValidation: true,\n      noSyntaxValidation: false,\n    });\n\n    if (options.files) {\n      for (const pathname in options.files) {\n        const content = options.files[pathname];\n\n        this.createModel(pathname, content);\n      }\n    }\n\n    this.initialPath = options.initialPath;\n  }\n\n  get dispose() {\n    return this.disposableStore.dispose;\n  }\n\n  get onDidChange() {\n    return this.onDidChangeEmitter.event;\n  }\n\n  get onWillFocusModel() {\n    return this.onWillFocusModelEmitter.event;\n  }\n\n  createModel(pathname: string, content = '') {\n    const language = this.inferLanguage(pathname);\n\n    let uri: Monaco.Uri;\n\n    try {\n      uri = Monaco.Uri.file(pathname);\n    } catch (err) {\n      throw new Error(`Invalid path '${pathname}': ${err && err.message}`);\n    }\n\n    if (Monaco.editor.getModel(uri)) {\n      throw new Error(`Cannot create file because it exists '${pathname}'`);\n    }\n\n    return Monaco.editor.createModel(content, language, uri);\n  }\n\n  focusHref(\n    href: string,\n    options: {\n      lineNumber?: number;\n      columnNumber?: number;\n      markers?: Monaco.editor.IMarkerData[];\n    } = {}\n  ) {\n    const model = this.getModelByHref(href);\n\n    if (model) {\n      this.focusModel(model, options);\n    }\n  }\n\n  focusModel(\n    model: Monaco.editor.ITextModel,\n    options: {\n      lineNumber?: number;\n      columnNumber?: number;\n      markers?: Monaco.editor.IMarkerData[];\n    } = {}\n  ) {\n    if (this.editor) {\n      this.editor.setModel(model);\n      if (options.lineNumber) {\n        this.editor.revealLineInCenter(options.lineNumber, Monaco.editor.ScrollType.Smooth);\n        this.editor.setPosition({\n          column: options.columnNumber || 0,\n          lineNumber: options.lineNumber,\n        });\n      }\n      if (options.markers) {\n        Monaco.editor.setModelMarkers(model, 'editorManager', options.markers);\n      }\n      this.editor.focus();\n    }\n  }\n\n  focusPath(\n    path: string,\n    options: {\n      lineNumber?: number;\n      columnNumber?: number;\n      markers?: Monaco.editor.IMarkerData[];\n    } = {}\n  ) {\n    const model = this.getModelByPath(path);\n\n    if (model) {\n      this.focusModel(model, options);\n    }\n  }\n\n  getModelByHref(href: string) {\n    try {\n      const uri = Monaco.Uri.parse(href);\n      return Monaco.editor.getModel(uri);\n    } catch (_) {\n      return null;\n    }\n  }\n\n  getModelByPath(path: string) {\n    return Monaco.editor.getModel(Monaco.Uri.file(path));\n  }\n\n  mount(el: HTMLElement) {\n    if (this.editor) {\n      throw new Error('Invariant violation: Editor already mounted');\n    }\n\n    this.editor = Monaco.editor.create(el, {\n      model: null,\n      automaticLayout: true,\n      minimap: {\n        enabled: false,\n      },\n      showUnused: true,\n      scrollBeyondLastLine: false,\n      theme: 'vs',\n      wordWrap: 'bounded',\n      wrappingIndent: 'same',\n    });\n\n    this.editor.onDidDispose(() => {\n      this.editor = null;\n    });\n\n    this.editor.onDidChangeModel((e) => {\n      if (e.newModelUrl && this.editor) {\n        const model = Monaco.editor.getModel(e.newModelUrl)!;\n        const viewState = this.viewState.get(model);\n\n        if (viewState) {\n          this.editor.restoreViewState(viewState);\n        }\n      }\n    });\n\n    this.editor.onDidBlurEditorText(() => {\n      if (this.editor) {\n        const model = this.editor.getModel();\n        const viewState = this.editor.saveViewState();\n\n        if (model && viewState) {\n          this.viewState.set(model, viewState);\n        }\n      }\n    });\n\n    this.disposableStore.add(this.editor);\n\n    if (this.initialPath) {\n      this.focusPath(this.initialPath);\n    }\n\n    return this.editor;\n  }\n\n  inferLanguage(pathname: string) {\n    return pathname.match(/\\.(?:tsx?|jsx?)$/) ? 'typescript' : undefined;\n  }\n}\n\nexport const EditorManagerContext = createContext<EditorManager>(undefined as any);\n\nexport function useActiveModel() {\n  const workbench = useContext(EditorManagerContext);\n  const [activeModel, setActiveModel] = useState<Monaco.editor.ITextModel | null>(\n    workbench.editor ? workbench.editor.getModel() : null\n  );\n\n  useEffect(() => {\n    const disposable = new DisposableStore();\n\n    const trackEditor = (editor: Monaco.editor.ICodeEditor) => {\n      editor.onDidChangeModel((e) => {\n        const model = e.newModelUrl ? Monaco.editor.getModel(e.newModelUrl) : null;\n\n        setActiveModel(model);\n      });\n\n      disposable.add(\n        editor.onDidBlurEditorText(() => {\n          setActiveModel(null);\n        })\n      );\n\n      disposable.add(\n        editor.onDidFocusEditorText(() => {\n          setActiveModel(editor.getModel());\n        })\n      );\n\n      if (editor.hasTextFocus()) {\n        setActiveModel(editor.getModel());\n      }\n    };\n\n    disposable.add(Monaco.editor.onDidCreateEditor(trackEditor));\n    if (workbench.editor) {\n      trackEditor(workbench.editor);\n    }\n\n    return () => disposable.dispose();\n  }, [workbench.editor, activeModel]);\n\n  return activeModel;\n}\n","import styled from '@emotion/styled/macro';\nimport React, { useRef, useEffect, useContext } from 'react';\nimport { EditorManagerContext } from '../lib/EditorManager';\n\nconst Editor: React.FC<{\n  className?: string;\n}> = ({ className }) => {\n  const el = useRef<HTMLDivElement | null>(null);\n  const editorManager = useContext(EditorManagerContext);\n\n  useEffect(() => {\n    if (!el.current) {\n      return;\n    }\n\n    const editor = editorManager.mount(el.current);\n\n    return () => {\n      editor.dispose();\n    };\n  }, [editorManager, el]);\n\n  return (\n    <div className={className} ref={el}>\n      <div></div>\n    </div>\n  );\n};\n\nexport default styled(Editor)``;\n","import styled from '@emotion/styled/macro';\nimport { Uri } from '@velcro/common';\nimport * as Monaco from 'monaco-editor';\nimport React, { useContext, useEffect, useRef, useState } from 'react';\nimport { EditorManagerContext } from '../lib/EditorManager';\nimport { trackMonaco } from '../velcro/monaco';\nimport { WorkerState } from '../velcro/types';\n\nexport interface DeferredExecutionModuleRecord {\n  code: string;\n  dependencies: Record<string, string>;\n}\n\nexport interface DeferredExecutionManifest {\n  aliases: Record<string, string>;\n  entrypoints: Record<string, string>;\n  modules: Record<string, DeferredExecutionModuleRecord>;\n}\n\ninterface MessageLine {\n  isInternal: boolean;\n  text: string;\n}\ninterface Message {\n  lines: MessageLine[];\n}\n\nconst PreviewProgress = styled.div<{ completed: number; total: number }>`\n  z-index: 1;\n  position: absolute;\n  top: 0;\n  width: ${(props) => (props.total ? `${Math.round((100 * props.completed) / props.total)}%` : 0)};\n  left: 0;\n  height: ${(props) => (props.total ? '2px' : '0')};\n  background-color: #008cba;\n  transition: width 0.5s 0s cubic-bezier(0.455, 0.03, 0.515, 0.955);\n`;\nconst PreviewIframeWrap = styled.div`\n  position: relative;\n  overflow: hidden;\n\n  & > iframe {\n    position: absolute;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n    border: none;\n    width: 100%;\n    height: 100%;\n  }\n`;\nconst PreviewWrap = styled.div`\n  position: relative;\n  background: white;\n\n  ${PreviewIframeWrap} {\n    position: absolute;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n  }\n`;\nconst PreviewMessageError = styled.ul`\n  margin: 0;\n  padding: 1em 2em;\n  font-family: monospace;\n  font-size: 16px;\n  background-color: rgba(255, 0, 0, 0.5);\n  backdrop-filter: brightness(50%);\n  color: white;\n  list-style: none;\n`;\nconst PreviewMessageErrorText = styled.li<{ isInternal: boolean }>`\n  white-space: pre-wrap;\n  opacity: ${(props) => (props.isInternal ? 0.7 : 1.0)};\n`;\nconst PreviewMessages = styled.div`\n  z-index: 1;\n  position: absolute;\n  bottom: 0;\n  right: 0;\n  left: 0;\n  display: flex;\n  flex-direction: column-reverse;\n`;\nconst PreviewMessageLine: React.FC<{ line: MessageLine }> = ({ line }) => {\n  return (\n    <PreviewMessageErrorText isInternal={line.isInternal}>{line.text}</PreviewMessageErrorText>\n  );\n};\nconst PreviewMessage: React.FC<{ message: Message }> = ({ message }) => {\n  return message.lines.length ? (\n    <PreviewMessageError>\n      {message.lines.map((line, i) => (\n        <PreviewMessageLine key={i} line={line}></PreviewMessageLine>\n      ))}\n    </PreviewMessageError>\n  ) : null;\n};\n\nconst Preview: React.FC<{ className?: string }> = (props) => {\n  const editorManager = useContext(EditorManagerContext);\n  const previewWrapRef = useRef<HTMLDivElement | null>(null);\n  const previewIframeRef = useRef<HTMLIFrameElement | null>(null);\n  const [buildState, setBuildState] = useState<WorkerState>({\n    state: 'initial',\n  });\n  const [buildProgress, setBuildProgress] = useState({ completed: 0, total: 0 });\n\n  useEffect(() => {\n    const onMessage = (e: MessageEvent) => {\n      if (\n        previewIframeRef.current &&\n        previewIframeRef.current.contentWindow === e.source &&\n        e.data.event === 'click_error'\n      ) {\n        editorManager.focusPath(Uri.parse(e.data.entry.file).fsPath, {\n          columnNumber: e.data.entry.column,\n          lineNumber: e.data.entry.line,\n        });\n      }\n    };\n\n    window.addEventListener('message', onMessage);\n\n    return () => window.removeEventListener('message', onMessage);\n  });\n\n  useEffect(() => {\n    const monacoIntegration = trackMonaco(Monaco);\n\n    monacoIntegration.onStateChange((state) => {\n      setBuildState(state);\n\n      switch (state.state) {\n        case 'building': {\n          setBuildProgress({\n            completed: state.completed,\n            total: state.completed + state.pending,\n          });\n          break;\n        }\n        case 'built': {\n          console.debug(\n            'Rebuild finished, build latency: %d, end-to-end latency: %d',\n            state.end - state.start,\n            Date.now() - state.start\n          );\n\n          const iframe = document.createElement('iframe');\n          iframe.style.display = 'none';\n          iframe.src = state.href;\n\n          if (previewWrapRef.current) {\n            previewWrapRef.current.appendChild(iframe);\n          }\n\n          const onLoad = () => {\n            iframe.removeEventListener('error', onError);\n            iframe.style.display = '';\n\n            if (previewIframeRef.current) {\n              previewIframeRef.current.remove();\n            }\n\n            previewIframeRef.current = iframe;\n          };\n          const onError = () => {\n            iframe.removeEventListener('load', onLoad);\n            iframe.remove();\n          };\n\n          iframe.addEventListener('load', onLoad, { once: true });\n          iframe.addEventListener('error', onError, { once: true });\n\n          break;\n        }\n      }\n    });\n\n    return () => {\n      monacoIntegration.dispose();\n    };\n  }, [setBuildProgress, setBuildState]);\n\n  return (\n    <PreviewWrap className={props.className}>\n      {buildState.state === 'building' ? (\n        <PreviewProgress\n          completed={buildProgress.completed}\n          total={buildProgress.total}\n        ></PreviewProgress>\n      ) : null}\n      <PreviewIframeWrap ref={previewWrapRef}></PreviewIframeWrap>\n      <PreviewMessages>\n        {buildState.state === 'error' ? (\n          <PreviewMessage\n            message={{ lines: [{ isInternal: true, text: buildState.error.message }] }}\n          ></PreviewMessage>\n        ) : null}\n      </PreviewMessages>\n    </PreviewWrap>\n  );\n};\n\nexport default styled(Preview)``;\n","import { DisposableStore } from '@velcro/common';\nimport * as Monaco from 'monaco-editor';\nimport { useEffect, useState } from 'react';\n\n// import { EditorContext } from './context';\n\nexport enum EntryKind {\n  Directory = 'directory',\n  File = 'file',\n}\n\nexport interface IDirectory {\n  type: EntryKind.Directory;\n  uri: Monaco.Uri;\n}\nexport interface IFile {\n  type: EntryKind.File;\n  uri: Monaco.Uri;\n  model: Monaco.editor.ITextModel;\n}\n\nexport type DirectoryEntry = IDirectory | IFile;\n\nexport function useDirectory(uri: Monaco.Uri) {\n  // Make sure the URI always ends with a trailing slash\n  const prefix = uri.toString(true).replace(/\\/?$/, '/');\n  const sortEntries = (models: DirectoryEntry[]) => {\n    return [...models].sort((a, b) => (a.uri.fsPath > b.uri.fsPath ? 1 : -1));\n  };\n\n  const initialEntries = sortEntries(\n    Monaco.editor.getModels().reduce((entries, model) => {\n      const modelUri = model.uri.toString(true);\n\n      if (modelUri.startsWith(prefix)) {\n        const nestedPath = modelUri.slice(prefix.length);\n        const nextDirIdx = nestedPath.indexOf('/');\n\n        if (nextDirIdx === 0) {\n          throw new Error('Invariant error: WAT?');\n        }\n\n        if (nextDirIdx > 0) {\n          // This is an intermediate directory\n          const uri = Monaco.Uri.parse(`${prefix}${nestedPath.slice(0, nextDirIdx + 1)}`);\n\n          entries.push({\n            type: EntryKind.Directory,\n            uri,\n          });\n        } else {\n          entries.push({\n            type: EntryKind.File,\n            uri: model.uri,\n            model,\n          });\n        }\n      }\n\n      return entries;\n    }, [] as DirectoryEntry[])\n  );\n  const [entries, setEntries] = useState(initialEntries);\n\n  useEffect(() => {\n    const disposable = new DisposableStore();\n    const prefix = uri.toString(true).replace(/\\/?$/, '/');\n\n    disposable.add(\n      Monaco.editor.onDidCreateModel((model: Monaco.editor.ITextModel) => {\n        const modelUri = model.uri.toString(true);\n\n        if (modelUri.startsWith(prefix)) {\n          const nestedPath = modelUri.slice(prefix.length);\n          const nextDirIdx = nestedPath.indexOf('/');\n\n          if (nextDirIdx === 0) {\n            throw new Error('Invariant error: WAT?');\n          }\n\n          if (nextDirIdx > 0) {\n            // This is an intermediate directory\n            const uri = Monaco.Uri.parse(`${prefix}${nestedPath.slice(0, nextDirIdx)}`);\n\n            // It is possible that we already have this directory\n            const entry = entries.find((entry) => entry.uri.toString(true) === uri.toString(true));\n\n            if (entry) {\n              if (entry.type !== EntryKind.Directory) {\n                throw new Error(\n                  `Invariant violation: A file in '${prefix}' conflicts with the path of the new file '${modelUri}'`\n                );\n              }\n\n              return;\n            }\n\n            entries.push({ type: EntryKind.Directory, uri });\n\n            return setEntries(sortEntries(entries));\n          }\n\n          if (\n            !entries.find(\n              (entry) =>\n                entry.type === EntryKind.File &&\n                entry.uri.toString(true) === model.uri.toString(true)\n            )\n          ) {\n            entries.push({ type: EntryKind.File, uri: model.uri, model });\n\n            setEntries(sortEntries(entries));\n          }\n        }\n      })\n    );\n\n    disposable.add(\n      Monaco.editor.onWillDisposeModel((model) => {\n        const idx = entries.findIndex(\n          (entry) => entry.type === EntryKind.File && entry.model === model\n        );\n\n        if (idx === -1) {\n          throw new Error(\n            `Invariant violation: Removing an untracked model: '${model.uri.fsPath}'`\n          );\n        }\n\n        entries.splice(idx, 1);\n\n        setEntries(sortEntries(entries));\n      })\n    );\n\n    return () => disposable.dispose();\n  }, [entries, uri]);\n\n  return entries;\n}\n","import styled from '@emotion/styled/macro';\nimport * as Monaco from 'monaco-editor';\nimport React, { useContext, useRef } from 'react';\nimport { Button } from 'reakit/Button';\nimport { Tooltip, TooltipReference, useTooltipState } from 'reakit/Tooltip';\nimport { useDirectory, EntryKind } from '../lib/hooks';\nimport { useActiveModel, EditorManagerContext } from '../lib/EditorManager';\n\nconst Entry = styled.div<{ modelFocused: boolean }>`\n  background-color: ${props => (props.modelFocused ? '#008cba' : 'inherit')};\n  text-decoration: none;\n  color: ${props => (props.modelFocused ? '#fff' : '#262626')};\n\n  height: 25px;\n  padding: 0 0 0 8px;\n  display: flex;\n  flex-direction: row;\n  align-items: center;\n\n  & > span {\n    flex: 1;\n  }\n\n  & > button {\n    display: none;\n  }\n\n  &:hover > button {\n    display: block;\n  }\n\n  ${props =>\n    props.modelFocused\n      ? {\n          ':hover': {\n            color: '#f5f5f5',\n            cursor: 'pointer',\n          },\n        }\n      : {\n          ':hover': {\n            backgroundColor: '#eee',\n            color: '#262626',\n            cursor: 'pointer',\n          },\n        }}\n`;\n\nconst CreateEntry = styled.div`\n  text-decoration: none;\n  color: '#262626';\n\n  height: 25px;\n  padding: 0 0 0 8px;\n  display: flex;\n  align-items: center;\n\n  :hover {\n    background-color: #eee;\n    cursor: pointer;\n  }\n`;\n\nconst SidebarFileDelete = styled(Button)`\n  border: none;\n  background: none;\n\n  :hover {\n    cursor: pointer;\n  }\n`;\n\nconst StyledTooltip = styled.div`\n  font-family: Open Sans, Helvetica Neue, Helvetica, Arial, sans-serif;\n  font-size: 14px;\n  line-height: 1.4;\n  background-color: #333;\n  color: #fff;\n  border-radius: 4px;\n  opacity: 0.9;\n  padding: 0.2em 0.4em;\n`;\n\nconst SidebarFile: React.FC<{ className?: string; model: Monaco.editor.ITextModel }> = ({ className, model }) => {\n  const activeModel = useActiveModel();\n  const editorManager = useContext(EditorManagerContext);\n  const tooltip = useTooltipState({ gutter: 0 });\n\n  const onClickDelete = () => {\n    model.dispose();\n  };\n\n  return (\n    <Entry className={className} modelFocused={model === activeModel}>\n      <span onClick={() => editorManager.focusModel(model)}>{model.uri.fsPath.slice(1)}</span>\n      <TooltipReference {...tooltip} as={SidebarFileDelete} onClick={() => onClickDelete()}>\n        <span role=\"img\" aria-label=\"Delete file\">\n          ❌\n        </span>\n      </TooltipReference>\n      <Tooltip {...tooltip} as={StyledTooltip}>\n        Delete file\n      </Tooltip>\n    </Entry>\n  );\n};\n\nconst Sidebar: React.FC<{ className?: string }> = props => {\n  const rootDir = useRef(Monaco.Uri.file('/'));\n  const entries = useDirectory(rootDir.current);\n  const editorManager = useContext(EditorManagerContext);\n\n  const onClickCreate = () => {\n    const filename = prompt('Filename?');\n\n    if (filename) {\n      editorManager.createModel(filename);\n    }\n  };\n\n  return (\n    <div className={props.className}>\n      {entries.map(entry =>\n        entry.type === EntryKind.Directory ? (\n          <div>{entry.uri.fsPath.slice(1)}</div>\n        ) : (\n          <SidebarFile key={entry.uri.toString(true)} model={entry.model}></SidebarFile>\n        )\n      )}\n      <CreateEntry onClick={() => onClickCreate()}>Create...</CreateEntry>\n    </div>\n  );\n};\n\nexport default styled(Sidebar)`\n  display: flex;\n  flex-direction: column;\n`;\n","import styled from '@emotion/styled/macro';\nimport React from 'react';\n\nimport Editor from './Editor';\nimport Preview from './Preview';\nimport Sidebar from './Sidebar';\nimport { EditorManager, EditorManagerContext } from '../lib/EditorManager';\n\nconst PlaygroundCmp: React.FC<{\n  className?: string;\n  initialPath: string;\n  project: Record<string, string>;\n}> = ({ className, initialPath, project }) => {\n  const editorManager = new EditorManager({ files: project, initialPath: initialPath });\n\n  return (\n    <div className={className}>\n      <EditorManagerContext.Provider value={editorManager}>\n        <Sidebar></Sidebar>\n        <Editor></Editor>\n        <Preview></Preview>\n      </EditorManagerContext.Provider>\n    </div>\n  );\n};\n\nexport const Playground = styled(PlaygroundCmp)`\n  display: flex;\n  flex-direction: row;\n\n  font-family: Open Sans, Helvetica Neue, Helvetica, Arial, sans-serif;\n  font-size: 14px;\n  line-height: 1.4;\n\n  color: #222;\n\n  ${Sidebar} {\n    flex: 1 1 100px;\n    min-width: 100px;\n    max-width: 400px;\n    border-right: 1px solid #ccc;\n  }\n\n  ${Editor} {\n    border-right: 1px solid #ccc;\n  }\n\n  ${Editor}, ${Preview} {\n    flex: 10;\n  }\n`;\n","export const files: Record<string, string> = {\n  'package.json':\n    JSON.stringify(\n      {\n        name: 'react-template',\n        version: '0.0.0',\n        dependencies: {\n          'github-markdown-css': '^3.0.1',\n          react: '^16.9.0',\n          'react-dom': '^16.9.0',\n        },\n      },\n      null,\n      2\n    ) + '\\n',\n  'App.jsx': `\nimport React, { Component } from 'react';\nimport 'github-markdown-css';\n\nimport { Explanation } from './explanation';\nimport './style.css';\n\nclass App extends Component {\n  render() {\n    return <div className=\"markdown-body\">\n      <h1>Velcro Playground</h1>\n      <blockquote>Example of 💯 % browser module loading and bundling.</blockquote>\n      <Explanation/>\n    </div>;\n  }\n}\n\nexport default App\n  `.trim(),\n  'explanation.jsx':\n    `\nimport React from 'react';\n\nexport const Explanation = () => <>\n  <section>\n    <h2>Give it a try</h2>\n    <p>Here's what you should try:</p>\n    <ul>\n      <li>✍️ Change any of the code you see.</li>\n      <li>📦 Change any of the dependencies versions or introduce your own in the <code>package.json</code> file.</li>\n      <li>💄 Try writing some css, or maybe making a TypeScript file...</li>\n      <li>🕵🏼‍♂️ Checking out the action in the network tab of Developer Tools or seeing the generated source maps in the sources tab.</li>\n    </ul>\n  </section>\n  <section>\n    <h2>How does it work</h2>\n    <p>\n      Velcro is a fully web-based dependency resolver, loader and bundler. In this playground, it has been configured to treat files\n      in the editor as being at <code>file://</code>, and npm modules as being at <code>https://cdn.jsdelivr.net</code>. Inter-module\n      dependencies are all resolved to satisfy the requested ranges and are loaded at maximum concurrency from jsDelivr.\n    </p>\n    <p>\n      As each file is resolved and read, it is run through a series of plugin hooks that are heavily inspired by Rollup.\n      Each hook has a default fallback implementation that allows us to resolve, load and transform individual files.\n      In the playground, Velcro has been configured with a css plugin and a <a href=\"https://github.com/alangpierce/sucrase\" target=\"blank\" rel=\"noopener\">sucrase</a>\n      plugin (for ESM and TypeScript).\n    </p>\n    <p>\n      After processing each individual file, we parse it so that its AST can be traversed to:\n    </p>\n    <ul>\n      <li>Calculate scope metadata and identifier bindings</li>\n      <li>Identify calls to <code>require</code></li>\n      <li>Identify calls Node.js global objects so that shims can be injected</li>\n      <li>Prune branches based on <code>process.env.NODE_ENV</code></li>\n    </ul>\n    <p>\n      This work allows us to build out a full dependency graph of modules. This graph has information about\n      every url consulted at each step of the process, so small parts of it can be efficiently invalidated.\n      Once the graph is complete, it can be serialized into a bundle of JavaScript code. At this point, we\n      can decide if we want to include source maps or not.\n    </p>\n    <p>\n      The bundled code is written to browser-internal storage using the <code>File</code> API and an\n      <code>iframe</code> is constructed dynamically that links to this. Every new generation of bundle\n      will cause the <code>iframe</code> to be replaced.\n    </p>\n  </section>\n</>;\n    `.trim() + '\\n',\n  'index.jsx':\n    `\nimport React, { Component } from 'react';\nimport ReactDOM from 'react-dom';\n\nimport App from './App';\n  \nReactDOM.render(\n  <App/>,\n  document.getElementById('root')\n);\n      `.trim() + '\\n',\n  'style.css':\n    `\n.markdown-body {\n  box-sizing: border-box;\n  min-width: 200px;\n  max-width: 980px;\n  margin: 0 auto;\n  padding: 45px;\n}\n\n@media (max-width: 767px) {\n  .markdown-body {\n    padding: 15px;\n  }\n}\n    `.trim() + '\\n',\n};\n","import React from 'react';\n\n// import * as serviceWorker from './serviceWorker';\n\ninterface ServiceWorkerEvent extends Event {\n  target: (Partial<ServiceWorker> & EventTarget) | null;\n}\n\ninterface ServiceWorkerContextValue {\n  assetsUpdateReady: boolean;\n  assetsCached: boolean;\n  updateAssets(): void;\n}\n\nconst ServiceWorkerContext = React.createContext<ServiceWorkerContextValue | undefined>(undefined);\n\nexport function ServiceWorkerProvider(props: React.PropsWithChildren<{}>) {\n  const [waitingServiceWorker, setWaitingServiceWorker] = React.useState<ServiceWorker | null>(\n    null\n  );\n  const [assetsUpdateReady, setAssetsUpdateReady] = React.useState(false);\n  const [assetsCached, setAssetsCached] = React.useState(false);\n\n  const value = React.useMemo(() => {\n    return {\n      assetsUpdateReady,\n      assetsCached,\n      // Call when the user confirm update of application and reload page\n      updateAssets: () => {\n        if (waitingServiceWorker) {\n          waitingServiceWorker.addEventListener('statechange', (event: ServiceWorkerEvent) => {\n            if (event.target && event.target.state === 'activated') {\n              window.location.reload();\n            }\n          });\n\n          waitingServiceWorker.postMessage({ type: 'SKIP_WAITING' });\n        }\n      },\n    };\n  }, [assetsUpdateReady, assetsCached, waitingServiceWorker]);\n\n  // Once on component mounted subscribe to Update and Succes events in\n  // CRA's service worker wrapper\n  // React.useEffect(() => {\n  //   serviceWorker.register({\n  //     onUpdate: (registration) => {\n  //       setWaitingServiceWorker(registration.waiting);\n  //     },\n  //     onUpdateAvailable: () => {\n  //       setAssetsUpdateReady(true);\n  //     },\n  //     onSuccess: (registration) => {\n  //       setAssetsCached(true);\n  //       setAssetsUpdateReady(false);\n\n  //       if (registration.active) {\n  //         registration.active.addEventListener('statechange', (event: ServiceWorkerEvent) => {\n  //           if (!navigator.serviceWorker.controller) {\n  //             setAssetsCached(false);\n  //           }\n  //         });\n  //       }\n  //     },\n  //   });\n  // }, []);\n\n  return <ServiceWorkerContext.Provider value={value} {...props} />;\n}\n\nexport function useServiceWorker() {\n  const context = React.useContext(ServiceWorkerContext);\n\n  if (!context) {\n    throw new Error('useServiceWorker must be used within a ServiceWorkerProvider');\n  }\n\n  return context;\n}\n","//@ts-nocheck\nimport { Global, css } from '@emotion/core';\nimport styled from '@emotion/styled/macro';\nimport CssBaseline from '@material-ui/core/CssBaseline';\nimport { OfflineBolt, Update } from '@material-ui/icons';\nimport React from 'react';\nimport { Tooltip, TooltipReference, useTooltipState } from 'reakit/Tooltip';\n\nimport { Playground } from './playground';\nimport { files } from './templates/react';\nimport { useServiceWorker, ServiceWorkerProvider } from './useServiceWorker';\nimport { Button } from 'reakit/Button';\n\nconst PlaygroundWrapper = styled.div`\n  background: white;\n  color: #666;\n  display: flex;\n  flex-direction: column;\n\n  ${Playground} {\n    border-bottom: 1px solid #ccc;\n    flex: 1;\n  }\n`;\n\nconst StatusBarItem = styled.span`\n  display: inline-flex;\n  flex-direction: row;\n  align-items: center;\n`;\n\nconst ReloadButton = styled(Button)`\n  border: 0;\n  background: #008cba;\n  margin: 0 0.5em;\n  color: white;\n  border-radius: 2px;\n  font-weight: 600;\n\n  :hover {\n    cursor: pointer;\n    text-decoration: underline;\n  }\n`;\n\nconst StyledTooltip = styled.div`\n  font-family: Open Sans, Helvetica Neue, Helvetica, Arial, sans-serif;\n  font-size: 14px;\n  line-height: 1.4;\n  background-color: #333;\n  color: #fff;\n  border-radius: 4px;\n  opacity: 0.9;\n  padding: 0.2em 0.4em;\n`;\n\nconst StatusBar: React.FC = () => {\n  const serviceWorker = useServiceWorker();\n  const offlineTooltip = useTooltipState({ gutter: 0 });\n  const reloadTooltip = useTooltipState({ gutter: 0 });\n\n  return (\n    <StatusBarStyles>\n      {serviceWorker.assetsCached ? (\n        <TooltipReference {...offlineTooltip} as={StatusBarItem}>\n          <OfflineBolt color=\"inherit\" fontSize=\"small\" />\n          &nbsp;Offline ready\n        </TooltipReference>\n      ) : null}\n      <Tooltip {...offlineTooltip} as={StyledTooltip}>\n        This application has been fully cached and can now be used offline.\n      </Tooltip>\n\n      {serviceWorker.assetsUpdateReady ? (\n        <TooltipReference {...reloadTooltip} as={StatusBarItem}>\n          <Update color=\"inherit\" fontSize=\"small\" />\n          &nbsp;Update ready:\n          <ReloadButton onClick={() => serviceWorker.updateAssets()}>Reload</ReloadButton>\n        </TooltipReference>\n      ) : null}\n      <Tooltip {...reloadTooltip} as={StyledTooltip}>\n        There is an update of this application ready to install. Click install reload to install the\n        update and reload the page.\n      </Tooltip>\n    </StatusBarStyles>\n  );\n};\n\nconst StatusBarStyles = styled.div`\n  display: flex;\n  flex-direction: row;\n\n  font-size: 90%;\n\n  height: 24px;\n  padding: 0 0.5em;\n\n  ${StatusBarItem} {\n    margin-left: 0.5em;\n    margin-right: 0.5em;\n  }\n`;\n\nconst AppWrapper = styled.div`\n  width: 100%;\n  min-width: 200px;\n  max-width: 80vw;\n  margin: 0 auto;\n  padding: 0 0 45px 0;\n\n  @media (max-width: 960px) {\n    padding: 0 15px 15px 15px;\n    max-width: initial;\n  }\n\n  display: flex;\n  flex-direction: column;\n\n  ${PlaygroundWrapper} {\n    flex: 1;\n    background: #f5f5f5;\n    border-radius: 2px;\n    box-shadow: 0 10px 20px rgba(0, 0, 0, 0.19), 0 6px 6px rgba(0, 0, 0, 0.23);\n\n    ${StatusBarStyles} {\n    }\n  }\n`;\n\nconst Title = styled.div`\n  font-family: 'Raleway', sans-serif;\n  font-size: 250%;\n  font-weight: 800;\n  font-variant: small-caps;\n  font-variant-caps: small-caps;\n  color: #00bfff;\n`;\n\nconst Subtitle = styled.div`\n  color: #ddd;\n  font-size: 120%;\n  font-weight: 400;\n`;\n\nconst Link = styled.a`\n  color: white;\n  text-decoration: none;\n\n  :hover {\n    text-decoration: underline;\n  }\n`;\n\nconst Links = styled.div`\n  display: flex;\n  flex-direction: row;\n\n  & > *:not(:last-child):after {\n    padding: 0 0.5em;\n    content: '｜';\n    color: #aaa;\n    text-decoration: none;\n  }\n\n  ${Link} {\n    color: #ccc;\n  }\n`;\n\nconst Header = styled.div`\n  display: flex;\n  flex-direction: row;\n  align-items: baseline;\n  padding: 0.8em 0 0.3em 0;\n  text-shadow: #000 1px 1px 5px;\n\n  ${Title} {\n    margin-right: 0.5em;\n  }\n\n  ${Subtitle} {\n    margin-right: 0.5em;\n  }\n\n  ${Links} {\n    flex: 1;\n    justify-content: flex-end;\n  }\n`;\n\nconst globalCss = css`\n  @import url('https://fonts.googleapis.com/css?family=Raleway:900&display=swap');\n\n  *,\n  *::before,\n  *::after {\n    box-sizing: border-box;\n  }\n\n  html,\n  body {\n    margin: 0;\n    padding: 0;\n    min-height: 100vh;\n\n    font-family: Open Sans, Helvetica Neue, Helvetica, Arial, sans-serif;\n    font-size: 14px;\n    line-height: 1.4;\n\n    background: #333;\n    color: #fff;\n\n    display: flex;\n    flex-direction: column;\n\n    #root {\n      flex: 1;\n      display: flex;\n      flex-direction: column;\n\n      ${AppWrapper} {\n        flex: 1;\n      }\n    }\n  }\n`;\n\nexport const App: React.FC = () => {\n  return (\n    <ServiceWorkerProvider>\n      <CssBaseline />\n      <AppWrapper>\n        <Global styles={globalCss}></Global>\n        <Header>\n          <Title>Velcro</Title>\n          <Subtitle>The client-side bundler and playground</Subtitle>\n          <Links>\n            <div>\n              <Link href=\"https://twitter.com/filearts\" target=\"_blank\" rel=\"nofollow noreferrer\">\n                @filearts\n              </Link>\n            </div>\n            <div>\n              <Link\n                href=\"https://github.com/ggoodman/velcro\"\n                target=\"_blank\"\n                rel=\"nofollow noreferrer\"\n              >\n                View on GitHub\n              </Link>\n            </div>\n          </Links>\n        </Header>\n        <PlaygroundWrapper>\n          <Playground project={files} initialPath=\"index.jsx\"></Playground>\n        </PlaygroundWrapper>\n      </AppWrapper>\n    </ServiceWorkerProvider>\n  );\n};\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://cra.link/PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(/^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/)\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://cra.link/PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://cra.link/PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch((error) => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log('No internet connection found. App is running in offline mode.');\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then((registration) => {\n        registration.unregister();\n      })\n      .catch((error) => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\n\nimport { App } from './App';\nimport * as serviceWorker from './serviceWorker';\n\nserviceWorker.unregister();\n\nReactDOM.render(<App />, document.getElementById('root'));\n"],"sourceRoot":""}