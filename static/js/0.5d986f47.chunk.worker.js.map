{"version":3,"sources":["../webpack/bootstrap","../../../src/base64.ts","../../../src/error.ts","../../../src/async.ts","../../../src/decoder.ts","../../../src/mapSet.ts","../../../src/packageJson.ts","../../../src/path.ts","../../../src/uri.ts","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator/index.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/typeof.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/nonIterableRest.js","../../../src/bareModules.ts","../../../src/shims.ts","../../../src/strategy.ts","../../../src/context.ts","../../../src/resolver.ts","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/iterableToArray.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js","../../@velcro/plugin-sucrase/node_modules/ts-interface-checker/dist/index.js","../../@velcro/strategy-cdn/node_modules/semver/classes/semver.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js","../../@velcro/strategy-cdn/node_modules/semver/functions/compare.js","../../@velcro/strategy-cdn/node_modules/semver/classes/range.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/construct.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/isNativeFunction.js","../../src/vs/base/common/errors.ts","../../src/vs/base/common/iterator.ts","../../src/vs/base/common/lifecycle.ts","../../src/vs/base/common/linkedList.ts","../../src/vs/base/common/event.ts","../../src/vs/base/common/cancellation.ts","../../src/vs/base/common/async.ts","../../src/vs/base/common/platform.ts","../../src/vs/base/common/process.ts","../../src/vs/base/common/path.ts","../../src/vs/base/common/uri.ts","../../@velcro/strategy-cdn/node_modules/semver/internal/re.js","../../@velcro/strategy-cdn/node_modules/semver/functions/parse.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js","../../@velcro/strategy-cdn/node_modules/semver/index.js","../node_modules/buffer/index.js","../../@velcro/strategy-cdn/node_modules/semver/internal/constants.js","../../@velcro/strategy-cdn/node_modules/semver/internal/debug.js","../../@velcro/strategy-cdn/node_modules/semver/functions/gt.js","../../@velcro/strategy-cdn/node_modules/semver/classes/comparator.js","../../@velcro/strategy-cdn/node_modules/semver/functions/satisfies.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/isNativeReflectConstruct.js","../../../src/memoryStrategy.ts","../../src/BitSet.js","../../src/Chunk.js","../../src/SourceMap.js","../../src/utils/guessIndent.js","../../src/utils/getRelativePath.js","../../src/utils/isObject.js","../../src/utils/getLocator.js","../../src/utils/Mappings.js","../../src/MagicString.js","../../src/Bundle.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/superPropBase.js","../node_modules/webpack/buildin/global.js","../node_modules/process/browser.js","../../@velcro/plugin-sucrase/node_modules/ts-interface-checker/dist/util.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass.js","../../@velcro/strategy-cdn/node_modules/semver/internal/identifiers.js","../../@velcro/strategy-cdn/node_modules/semver/functions/eq.js","../../@velcro/strategy-cdn/node_modules/semver/functions/compare-build.js","../../@velcro/strategy-cdn/node_modules/semver/functions/lt.js","../../@velcro/strategy-cdn/node_modules/semver/functions/gte.js","../../@velcro/strategy-cdn/node_modules/semver/functions/lte.js","../../@velcro/strategy-cdn/node_modules/semver/ranges/outside.js","../../@velcro/plugin-sucrase/node_modules/ts-interface-checker/dist/types.js","../../@velcro/strategy-cdn/node_modules/semver/functions/neq.js","../../@velcro/strategy-cdn/node_modules/semver/functions/cmp.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js","../../src/sourcemap-codec.ts","../../@velcro/plugin-sucrase/node_modules/lines-and-columns/dist/index.js","../node_modules/regenerator-runtime/runtime.js","../node_modules/base64-js/index.js","../node_modules/ieee754/index.js","../node_modules/isarray/index.js","../../@velcro/strategy-cdn/node_modules/semver/functions/valid.js","../../@velcro/strategy-cdn/node_modules/semver/functions/clean.js","../../@velcro/strategy-cdn/node_modules/semver/functions/inc.js","../../@velcro/strategy-cdn/node_modules/semver/functions/diff.js","../../@velcro/strategy-cdn/node_modules/semver/functions/major.js","../../@velcro/strategy-cdn/node_modules/semver/functions/minor.js","../../@velcro/strategy-cdn/node_modules/semver/functions/patch.js","../../@velcro/strategy-cdn/node_modules/semver/functions/prerelease.js","../../@velcro/strategy-cdn/node_modules/semver/functions/rcompare.js","../../@velcro/strategy-cdn/node_modules/semver/functions/compare-loose.js","../../@velcro/strategy-cdn/node_modules/semver/functions/sort.js","../../@velcro/strategy-cdn/node_modules/semver/functions/rsort.js","../../@velcro/strategy-cdn/node_modules/semver/functions/coerce.js","../../@velcro/strategy-cdn/node_modules/semver/ranges/to-comparators.js","../../@velcro/strategy-cdn/node_modules/semver/ranges/max-satisfying.js","../../@velcro/strategy-cdn/node_modules/semver/ranges/min-satisfying.js","../../@velcro/strategy-cdn/node_modules/semver/ranges/min-version.js","../../@velcro/strategy-cdn/node_modules/semver/ranges/valid.js","../../@velcro/strategy-cdn/node_modules/semver/ranges/gtr.js","../../@velcro/strategy-cdn/node_modules/semver/ranges/ltr.js","../../@velcro/strategy-cdn/node_modules/semver/ranges/intersects.js","../../@velcro/strategy-cdn/node_modules/semver/ranges/simplify.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/arrayWithHoles.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/iterableToArrayLimit.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/arrayLikeToArray.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/nonIterableRest.js","../../@velcro/strategy-cdn/node_modules/semver/ranges/subset.js","../../@velcro/bundler/node_modules/acorn/dist/acorn.mjs","../../../src/graph/errors.ts","../../../node_modules/sourcemap-codec/dist/sourcemap-codec.es.js","../../../src/build/sourceMap.ts","../../../src/build/sourceMapTree.ts","../../../src/graph/sourceModuleDependency.ts","../../../src/plugins/pluginManager.ts","../../../src/graph/commonjs/ast.ts","../../../src/graph/commonjs/traverse.ts","../../../src/graph/commonjs/parser.ts","../../../src/build/chunkOutput.ts","../../../src/build/chunk.ts","../../../src/code.ts","../../../src/graph/graph.ts","../../../src/graph/shims.ts","../../../src/graph/sourceModule.ts","../../../src/graph/graphBuilder.ts","../../@velcro/plugin-sucrase/node_modules/sucrase/dist/parser/tokenizer/keywords.mjs","../../@velcro/plugin-sucrase/node_modules/sucrase/dist/parser/tokenizer/types.mjs","../../@velcro/plugin-sucrase/node_modules/sucrase/dist/parser/tokenizer/state.mjs","../../@velcro/plugin-sucrase/node_modules/sucrase/dist/parser/util/charcodes.mjs","../../@velcro/plugin-sucrase/node_modules/sucrase/dist/parser/traverser/base.mjs","../../@velcro/plugin-sucrase/node_modules/sucrase/dist/parser/traverser/util.mjs","../../@velcro/plugin-sucrase/node_modules/sucrase/dist/parser/util/whitespace.mjs","../../@velcro/plugin-sucrase/node_modules/sucrase/dist/parser/util/identifier.mjs","../../@velcro/plugin-sucrase/node_modules/sucrase/dist/parser/tokenizer/readWordTree.mjs","../../@velcro/plugin-sucrase/node_modules/sucrase/dist/parser/tokenizer/index.mjs","../../@velcro/plugin-sucrase/node_modules/sucrase/dist/parser/tokenizer/readWord.mjs","../../@velcro/plugin-sucrase/node_modules/sucrase/dist/parser/plugins/jsx/xhtml.mjs","../../@velcro/plugin-sucrase/node_modules/sucrase/dist/util/getJSXPragmaInfo.mjs","../../@velcro/plugin-sucrase/node_modules/sucrase/dist/transformers/Transformer.mjs","../../@velcro/plugin-sucrase/node_modules/sucrase/dist/transformers/JSXTransformer.mjs","../../@velcro/plugin-sucrase/node_modules/sucrase/dist/util/getNonTypeIdentifiers.mjs","../../@velcro/plugin-sucrase/node_modules/sucrase/dist/CJSImportProcessor.mjs","../../@velcro/plugin-sucrase/node_modules/sucrase/dist/computeSourceMap.mjs","../../@velcro/plugin-sucrase/node_modules/sucrase/dist/HelperManager.mjs","../../@velcro/plugin-sucrase/node_modules/sucrase/dist/identifyShadowedGlobals.mjs","../../@velcro/plugin-sucrase/node_modules/sucrase/dist/parser/plugins/typescript.mjs","../../@velcro/plugin-sucrase/node_modules/sucrase/dist/NameManager.mjs","../../@velcro/plugin-sucrase/node_modules/sucrase/dist/util/getIdentifierNames.mjs","../../@velcro/plugin-sucrase/node_modules/sucrase/dist/Options-gen-types.mjs","../../@velcro/plugin-sucrase/node_modules/sucrase/dist/Options.mjs","../../@velcro/plugin-sucrase/node_modules/sucrase/dist/parser/traverser/lval.mjs","../../@velcro/plugin-sucrase/node_modules/sucrase/dist/parser/plugins/flow.mjs","../../@velcro/plugin-sucrase/node_modules/sucrase/dist/parser/plugins/jsx/index.mjs","../../@velcro/plugin-sucrase/node_modules/sucrase/dist/parser/traverser/expression.mjs","../../@velcro/plugin-sucrase/node_modules/sucrase/dist/parser/plugins/types.mjs","../../@velcro/plugin-sucrase/node_modules/sucrase/dist/parser/traverser/statement.mjs","../../@velcro/plugin-sucrase/node_modules/sucrase/dist/parser/traverser/index.mjs","../../@velcro/plugin-sucrase/node_modules/sucrase/dist/parser/index.mjs","../../@velcro/plugin-sucrase/node_modules/sucrase/dist/TokenProcessor.mjs","../../@velcro/plugin-sucrase/node_modules/sucrase/dist/util/isAsyncOperation.mjs","../../@velcro/plugin-sucrase/node_modules/sucrase/dist/util/getClassInfo.mjs","../../@velcro/plugin-sucrase/node_modules/sucrase/dist/util/elideImportEquals.mjs","../../@velcro/plugin-sucrase/node_modules/sucrase/dist/util/getDeclarationInfo.mjs","../../@velcro/plugin-sucrase/node_modules/sucrase/dist/util/shouldElideDefaultExport.mjs","../../@velcro/plugin-sucrase/node_modules/sucrase/dist/transformers/CJSImportTransformer.mjs","../../@velcro/plugin-sucrase/node_modules/sucrase/dist/transformers/ESMImportTransformer.mjs","../../@velcro/plugin-sucrase/node_modules/sucrase/dist/transformers/FlowTransformer.mjs","../../@velcro/plugin-sucrase/node_modules/sucrase/dist/transformers/NumericSeparatorTransformer.mjs","../../@velcro/plugin-sucrase/node_modules/sucrase/dist/transformers/OptionalCatchBindingTransformer.mjs","../../@velcro/plugin-sucrase/node_modules/sucrase/dist/transformers/OptionalChainingNullishTransformer.mjs","../../@velcro/plugin-sucrase/node_modules/sucrase/dist/transformers/ReactDisplayNameTransformer.mjs","../../@velcro/plugin-sucrase/node_modules/sucrase/dist/transformers/ReactHotLoaderTransformer.mjs","../../@velcro/plugin-sucrase/node_modules/sucrase/dist/util/isIdentifier.mjs","../../@velcro/plugin-sucrase/node_modules/sucrase/dist/transformers/TypeScriptTransformer.mjs","../../@velcro/plugin-sucrase/node_modules/sucrase/dist/transformers/RootTransformer.mjs","../../@velcro/plugin-sucrase/node_modules/sucrase/dist/util/getTSImportedNames.mjs","../../@velcro/plugin-sucrase/node_modules/sucrase/dist/index.mjs","../../../src/sucrase.ts","../../../src/cdnStrategy.ts","../../../src/compoundStrategy.ts","velcro/fsm.ts","../../../src/execute.ts","velcro/util.ts","velcro/plugins/svelte.ts","velcro/server.ts","../../../src/css.ts","../node_modules/fp-ts/es6/function.js","../node_modules/fp-ts/es6/Either.js","../node_modules/io-ts/es6/index.js","velcro/messages.ts","velcro/worker.ts","velcro/wireWorker.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","Base64","uri","parentUri","err","shouldAwait","result","values","element","isThenable","checkCancellation","Promise","a","token","decode","global","data","atob","decodeURIComponent","escape","_data","Error","encode","btoa","unescape","encodeURIComponent","TextDecoder","this","Buffer","str","decoder","ret","delete","has","hasInvalidBrowserField","json","error","browser","hasInvalidRequiredStringField","hasInvalidOptionalStringField","hasInvalidDependenciesField","parseTextAsPartialPackageJson","text","isValidPackageJson","parseTextAsPackageJson","JSON","isValidPartialPackageJson","expected","determiner","type","msg","validateString","ErrorInvalidArgType","isPosixPathSeparator","code","normalizeString","res","lastSegmentLength","lastSlash","dots","path","isPathSeparator","lastSlashIndex","posix","resolve","resolvedPath","resolvedAbsolute","process","normalize","isAbsolute","trailingSeparator","join","arg","joined","relative","from","to","fromEnd","fromLen","toLen","length","lastCommonSep","fromCode","out","toNamespacedPath","dirname","hasRoot","end","matchedSlash","basename","ext","start","extIdx","firstNonSlashEnd","extname","startDot","startPart","preDotState","format","sep","pathObject","dir","base","parse","root","delimiter","win32","_schemePattern","_singleSlashStart","_doubleSlashStart","_validateUri","_schemeFix","scheme","_referenceResolution","_slash","_regexp","_strict","schemeOrData","authority","query","fragment","_URI","skipEncoding","_asFormatted","uriToFsPath","trailingSlash","childHref","child","parentHref","parent","parentOffset","prefix","thing","match","percentDecode","idx","components","newPath","_pathSepMarker","_formatted","_fsPath","$mid","encodeTable","encodeURIComponentFast","uriComponent","nativeEncodePos","pos","allowSlash","escaped","encodeURIComponentMinimal","encoder","userinfo","String","_rEncodedAsHex","decodeURIComponentGraceful","TRAILING_SLASH_RX","_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","descriptor","configurable","writable","_createClass","protoProps","staticProps","_createForOfIteratorHelper","iterator","Array","isArray","F","done","e","_e","f","it","normalCompletion","didErr","step","next","_e2","_inherits","subClass","superClass","constructor","_typeof","obj","_possibleConstructorReturn","self","assertThisInitialized","_createSuper","Derived","Super","getPrototypeOf","isNativeReflectConstruct","NewTarget","Reflect","construct","arguments","apply","_defineProperty","asyncGeneratorStep","gen","reject","_next","_throw","info","then","_asyncToGenerator","fn","args","undefined","_slicedToArray","arr","_arr","_n","_d","_s","_i","push","unsupportedIterableToArray","SPEC_RX","matches","bareModuleSpec","nameSpec","spec","ResolverStrategy","NODE_CORE_SHIMS","string_decoder","parseBareModuleSpec","punycode","EntryKind","settings","ctx","strategy","rootUri","CACHE","visits","Visits","find","cmp","visit","mapResultWithVisits","visited","options","encodedOperation","encodePathNode","operationName","includes","formattedPath","segment","decodePathNode","_wrapError","ResolverContext","cache","cacheInvalidations","debug","concat","resolver","tokenSource","method","receiver","href","runInChildContext","invalidations","invalidated","operationCache","runWithCache","runInContext","resetPath","resetVisits","forOperation","contextFn","mappedResult","cacheEntries","cacheKey","cached","cacheResult","createStoreResultFn","promiseRet","wrappedRet","map","repeat","console","node","parts","bothResolved","resolveRootResult","rootUriWithoutTrailingSlash","canonicalizationResult","resolveReturn","resolveAsDirectory","settingsResult","resolveAsFile","readParentPackageJsonReturn","resolveAndPackageJson","parentPackageJson","readParentPackageJsonResult","packageJson","parsedSpec","resolveBareModule","fromUri","relativeUri","locatorName","locatorSpec","locatorPath","resolveRootReturn","nextUri","maxIterations","parentPackageJsonReturn","parentPackageJsonResult","directoryUri","dependencies","builtIn","bareModuleUriReturn","bareModuleUriResult","resolveResult","listEntriesReturn","listEntriesResult","mainPathname","packageJsonUri","packageJsonEntry","entry","packageJsonContentReturn","packageJsonContentResult","pathname","fileUri","ignoreBrowserOverrides","browserOverrides","readParentPackageJsonInternal","uriIsCanonicalized","browserMap","packageJsonDir","impliedUri","targetSpec","found","containingDirUri","filename","entriesReturn","entriesResult","entryDirectoryMap","entryFileMap","childFilename","hrefWithExtensionUri","hrefWithExtension","mapping","canonicalizationReturn","readReturn","readResult","visitedDirs","hostRootHref","containingDirUrl","readPackageJsonOrRecurse","entries","parentPackageJsonContentReturn","parentPackageJsonContentResult","parentDir","VisitKind","disposed","buf","rootCtx","runInIsolatedContext","ownKeys","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","_objectSpread2","source","forEach","getOwnPropertyDescriptors","defineProperties","_toConsumableArray","arrayLikeToArray","iter","__spreadArrays","il","k","j","jl","Checker","createCheckers","types_1","require","util_1","types_2","TArray","TEnumType","TEnumLiteral","TFunc","TIface","TLiteral","TName","TOptional","TParam","TParamList","TProp","TTuple","TType","TUnion","TIntersection","array","enumlit","enumtype","func","iface","lit","opt","param","tuple","union","intersection","BasicType","util_2","VError","typeSuite","fullSuite","assign","basicTypes","checkers","_a","typeSuite_1","suite_1","_b","_c","suite","ttype","_path","Map","set","checkerPlain","getChecker","checkerStrict","setReportedPath","check","_doCheck","test","NoopContext","validate","_doValidate","strictCheck","strictTest","strictValidate","getProp","prop","methodArgs","methodName","tfunc","_getMethod","paramList","methodResult","getArgs","getResult","getType","checkerFunc","detailCtx","DetailContext","getError","getErrorDetail","MAX_LENGTH","MAX_SAFE_INTEGER","re","compareIdentifiers","SemVer","version","loose","includePrerelease","trim","LOOSE","FULL","raw","major","minor","patch","prerelease","split","id","num","build","other","compareMain","comparePre","b","release","identifier","inc","isNaN","_assertThisInitialized","ReferenceError","compare","Range","range","Comparator","parseRange","comps","hr","HYPHENRANGELOOSE","HYPHENRANGE","replace","hyphenReplace","COMPARATORTRIM","comparatorTrimReplace","TILDETRIM","tildeTrimReplace","CARETTRIM","caretTrimReplace","compRe","COMPARATORLOOSE","COMPARATOR","comp","parseComparator","replaceGTE0","some","thisComparators","isSatisfiable","rangeComparators","every","thisComparator","rangeComparator","intersects","er","testSet","comparators","remainingComparators","slice","testComparator","pop","otherComparator","replaceCarets","replaceTildes","replaceXRanges","replaceStars","isX","toLowerCase","replaceTilde","TILDELOOSE","TILDE","_","M","pr","replaceCaret","CARETLOOSE","CARET","z","replaceXRange","XRANGELOOSE","XRANGE","gtlt","xM","xm","xp","anyX","STAR","GTE0PRE","GTE0","incPr","$0","fM","fm","fp","fpr","fb","tM","tm","tp","tpr","tb","semver","ANY","allowed","_getPrototypeOf","setPrototypeOf","__proto__","Parent","Class","Function","_cache","toString","indexOf","Wrapper","errorHandler","listeners","unexpectedErrorHandler","setTimeout","stack","message","listener","_removeListener","splice","newUnexpectedErrorHandler","emit","onUnexpectedError","Iterable","markTracked","x","is","dispose","combinedDisposable","disposables","single","_empty","freeze","iterable","predicate","iterables","empty","first","consume","atMost","Number","POSITIVE_INFINITY","consumed","DisposableStore","_toDispose","Set","_isDisposed","clear","item","DISABLE_DISPOSED_WARNING","warn","add","Disposable","_store","None","Node","Undefined","prev","Event","LinkedList","_first","_last","_size","_insert","atTheEnd","newNode","oldLast","oldFirst","didRemove","_remove","anchor","event","thisArgs","didFire","snapshot","each","merge","initial","output","emitter","Emitter","onFirstListenerAdd","fire","onLastListenerRemove","subscription","delay","leading","leakWarningThreshold","handle","numDebouncedCalls","cur","clearTimeout","_output","firstCall","shouldEmit","once","signal","any","events","reduce","debounce","stopwatch","Date","getTime","latch","buffer","nextTick","_buffer","flush","onFirstListenerDidAdd","ChainableEvent","chain","fromNodeEventEmitter","eventName","on","removeListener","fromDOMEventEmitter","addEventListener","removeEventListener","fromPromise","promise","toPromise","_globalLeakWarningThreshold","LeakageMonitor","customThreshold","Math","random","_warnCountdown","_stacks","listenerCount","threshold","count","topStack","topCount","_disposed","_options","_leakageMon","_listeners","_deliveryQueue","size","shift","_event","firstListener","isEmpty","removeMonitor","remove","onListenerDidAdd","_noop","CancellationToken","shortcutEvent","callback","context","isCancellationToken","Cancelled","MutableToken","isCancellationRequested","onCancellationRequested","_isCancelled","_emitter","CancellationTokenSource","_token","_parentListener","cancel","requestIdleCallback","cancelIdleCallback","didTimeout","timeRemaining","globals","setImmediate","postMessage","importScripts","pending","vscodeSetImmediateId","len","candidate","lastId","myId","_promise","safeProcess","cwd","env","platform","actual","isWindowsDeviceRoot","allowAboveRoot","separator","charCodeAt","lastIndexOf","_format","resolvedDevice","resolvedTail","process.cwd","process.env","rootEnd","device","last","firstPart","tail","needsReplace","slashCount","firstLen","fromOrig","toOrig","fromStart","toStart","toEnd","offset","process.platform","MAX_SAFE_COMPONENT_LENGTH","src","R","createToken","isGlobal","index","RegExp","NUMERICIDENTIFIER","NUMERICIDENTIFIERLOOSE","NONNUMERICIDENTIFIER","PRERELEASEIDENTIFIER","PRERELEASEIDENTIFIERLOOSE","BUILDIDENTIFIER","MAINVERSION","PRERELEASE","BUILD","FULLPLAIN","MAINVERSIONLOOSE","PRERELEASELOOSE","LOOSEPLAIN","XRANGEIDENTIFIER","XRANGEIDENTIFIERLOOSE","GTLT","XRANGEPLAIN","XRANGEPLAINLOOSE","COERCE","LONETILDE","LONECARET","_unsupportedIterableToArray","minLen","_setPrototypeOf","_arrayLikeToArray","arr2","internalRe","tokens","SEMVER_SPEC_VERSION","rcompareIdentifiers","valid","clean","diff","rcompare","compareLoose","compareBuild","sort","rsort","gt","lt","eq","neq","gte","lte","coerce","satisfies","toComparators","maxSatisfying","minSatisfying","minVersion","validRange","outside","gtr","ltr","simplifyRange","subset","base64","ieee754","kMaxLength","TYPED_ARRAY_SUPPORT","createBuffer","that","RangeError","Uint8Array","encodingOrOffset","allocUnsafe","ArrayBuffer","byteOffset","byteLength","fromArrayLike","fromArrayBuffer","string","encoding","isEncoding","write","fromString","isBuffer","checked","copy","val","fromObject","assertSize","isView","loweredCase","utf8ToBytes","base64ToBytes","slowToString","hexSlice","utf8Slice","asciiSlice","latin1Slice","base64Slice","utf16leSlice","swap","bidirectionalIndexOf","arrayIndexOf","indexSize","arrLength","valLength","read","readUInt16BE","foundIndex","hexWrite","remaining","strLen","parsed","parseInt","substr","utf8Write","blitBuffer","asciiWrite","byteArray","asciiToBytes","latin1Write","base64Write","ucs2Write","units","hi","lo","utf16leToBytes","fromByteArray","min","secondByte","thirdByte","fourthByte","tempCodePoint","firstByte","codePoint","bytesPerSequence","codePoints","fromCharCode","decodeCodePointsArray","SlowBuffer","alloc","INSPECT_MAX_BYTES","foo","subarray","typedArraySupport","poolSize","_augment","species","fill","allocUnsafeSlow","_isBuffer","y","list","swap16","swap32","swap64","equals","inspect","max","thisStart","thisEnd","thisCopy","targetCopy","isFinite","toJSON","toHex","bytes","checkOffset","checkInt","objectWriteUInt16","littleEndian","objectWriteUInt32","checkIEEE754","writeFloat","noAssert","writeDouble","newBuf","sliceLen","readUIntLE","mul","readUIntBE","readUInt8","readUInt16LE","readUInt32LE","readUInt32BE","readIntLE","pow","readIntBE","readInt8","readInt16LE","readInt16BE","readInt32LE","readInt32BE","readFloatLE","readFloatBE","readDoubleLE","readDoubleBE","writeUIntLE","writeUIntBE","writeUInt8","floor","writeUInt16LE","writeUInt16BE","writeUInt32LE","writeUInt32BE","writeIntLE","limit","sub","writeIntBE","writeInt8","writeInt16LE","writeInt16BE","writeInt32LE","writeInt32BE","writeFloatLE","writeFloatBE","writeDoubleLE","writeDoubleBE","targetStart","INVALID_BASE64_RE","Infinity","leadSurrogate","toByteArray","stringtrim","base64clean","dst","NODE_DEBUG","operator","sameDirectionIncreasing","sameDirectionDecreasing","sameSemVer","differentDirectionsInclusive","oppositeDirectionsLessThan","oppositeDirectionsGreaterThan","_isNativeReflectConstruct","sham","Proxy","FileEncoding","encodeText","TextEncoder","children","file","files","segments","overwrite","content","urlPathname","basePathname","fsPathname","getEntryAtPath","binSting","binArray","_el","BitSet","bits","Chunk","original","intro","outro","storeName","edited","appendLeft","appendRight","clone","const","chunk","contains","eachNext","let","eachPrevious","previous","edit","contentOnly","prependLeft","prependRight","sliceIndex","originalBefore","originalAfter","newChunk","trimEnd","rx","trimmed","trimStart","window","SourceMap","properties","sources","sourcesContent","names","mappings","guessIndent","lines","tabbed","line","spaced","current","numSpaces","exec","getRelativePath","fromParts","toParts","stringify","toUrl","isObject","getLocator","originalLines","lineOffsets","Mappings","hires","generatedCodeLine","generatedCodeColumn","rawSegments","addEdit","sourceIndex","loc","nameIndex","column","advance","addUneditedChunk","sourcemapLocations","originalCharIndex","warned","insertLeft","insertRight","MagicString","indentExclusionRanges","indentStr","byStart","byEnd","addSourcemapLocation","char","append","_split","cloned","originalChunk","firstChunk","clonedChunk","lastSearchedChunk","nextOriginalChunk","nextClonedChunk","lastChunk","generateDecodedMap","storedNames","locate","includeContent","generateMap","getIndentString","indent","pattern","isExcluded","exclude","exclusion","shouldIndentNextCharacter","indentStart","replacer","charIndex","_splitChunk","insert","move","oldLeft","oldRight","newRight","newLeft","prepend","lastChar","lastLine","lineIndex","lineStr","startChunk","containsEnd","sliceStart","sliceEnd","snip","searchForward","trimLines","charType","trimEndAborted","aborted","trimStartAborted","hasOwnProp","Bundle","uniqueSources","uniqueSourceIndexByFilename","addSource","option","uniqueSource","bundle","magicString","indentStringCounts","trailingNewline","body","desc","g","cachedSetTimeout","cachedClearTimeout","defaultSetTimout","defaultClearTimeout","runTimeout","fun","currentQueue","queue","draining","queueIndex","cleanUpNextTick","drainQueue","timeout","run","marker","runClearTimeout","Item","noop","title","argv","versions","addListener","off","removeAllListeners","prependListener","prependOnceListener","binding","chdir","umask","__extends","extendStatics","__","_super","_this","fail","relPath","score","unionResolver","createContext","resolveUnion","ur","_propNames","_messages","_score","DetailUnionResolver","best","contexts","msgParts","details","detail","nested","numeric","anum","bnum","versionA","versionB","hilo","gtfn","ltefn","ltfn","ecomp","high","low","comparator","parseSpec","typeSpec","getNamedType","_failMsg","strict","allowedProps","checker","itemChecker","ttypes","itemCheckers","otherTypes","members","validValues","enumName","makeIfaceProps","makeIfaceProp","bases","propSet","baseCheckers","propCheckers","testCtx","isPropRequired","isOpt","name_1","v","resultSpec","params","Boolean","isParamRequired","validator","number","boolean","symbol","void","null","never","getIsNativeChecker","nativeToString","tag","_loop_1","array_1","Int8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","op","charToInteger","chars","decoded","sourceFileIndex","sourceCodeLine","sourceCodeColumn","lineMappings","segmentMappings","encodeInteger","clamped","LinesAndColumns","offsets","locationForIndex","indexForLocation","location","lengthOfLine","runtime","Op","hasOwn","$Symbol","iteratorSymbol","asyncIteratorSymbol","asyncIterator","toStringTagSymbol","define","wrap","innerFn","outerFn","tryLocsList","protoGenerator","Generator","generator","Context","_invoke","state","doneResult","delegate","delegateResult","maybeInvokeDelegate","ContinueSentinel","sent","_sent","dispatchException","abrupt","record","tryCatch","makeInvokeMethod","GeneratorFunction","GeneratorFunctionPrototype","IteratorPrototype","getProto","NativeIteratorPrototype","Gp","defineIteratorMethods","AsyncIterator","PromiseImpl","previousPromise","callInvokeWithMethodAndArg","invoke","__await","unwrapped","resultName","nextLoc","pushTryEntry","locs","tryLoc","catchLoc","finallyLoc","afterLoc","tryEntries","resetTryEntry","completion","reset","iteratorMethod","displayName","isGeneratorFunction","genFun","ctor","mark","awrap","async","reverse","skipTempReset","charAt","stop","rootRecord","rval","exception","caught","hasCatch","hasFinally","finallyEntry","complete","finish","thrown","delegateYield","regeneratorRuntime","accidentalStrictMode","b64","lens","getLens","validLen","placeHoldersLen","tmp","Arr","_byteLength","curByte","revLookup","uint8","extraBytes","len2","encodeChunk","lookup","isLE","mLen","nBytes","eLen","eMax","eBias","nBits","NaN","rt","abs","log","LN2","version1","version2","v1","v2","hasPre","defaultResult","rtl","COERCERTL","lastIndex","maxSV","rangeObj","minSV","minver","compver","r1","r2","ranges","simplified","arrayWithHoles","iterableToArrayLimit","nonIterableRest","simpleSubset","dom","gtltComp","eqSet","higherGT","lowerLT","hasDomLT","hasDomGT","sawNonNull","OUTER","simpleSub","simpleDom","isSub","reservedWords","3","5","6","strictBind","ecma5AndLessKeywords","keywords","keywordRelationalOperator","nonASCIIidentifierStartChars","nonASCIIidentifierChars","nonASCIIidentifierStart","nonASCIIidentifier","astralIdentifierStartCodes","astralIdentifierCodes","isInAstralSet","isIdentifierStart","astral","isIdentifierChar","TokenType","label","conf","keyword","beforeExpr","startsExpr","isLoop","isAssign","postfix","binop","updateContext","prec","keywords$1","kw","types","regexp","eof","bracketL","bracketR","braceL","braceR","parenL","parenR","comma","semi","colon","dot","question","questionDot","arrow","template","invalidTemplate","ellipsis","backQuote","dollarBraceL","incDec","logicalOR","logicalAND","bitwiseOR","bitwiseXOR","bitwiseAND","equality","relational","bitShift","plusMin","modulo","star","slash","starstar","coalesce","_break","_case","_catch","_continue","_debugger","_default","_do","_else","_finally","_for","_function","_if","_return","_switch","_try","_var","_const","_while","_with","_new","_class","_extends","_export","_import","_null","_true","_false","_in","_instanceof","_void","_delete","lineBreak","lineBreakG","isNewLine","ecma2019String","nonASCIIwhitespace","skipWhiteSpace","ref","propName","wordsRegexp","words","Position","col","SourceLocation","sourceFile","getLineInfo","input","defaultOptions","ecmaVersion","sourceType","onInsertedSemicolon","onTrailingComma","allowReserved","allowReturnOutsideFunction","allowImportExportEverywhere","allowAwaitOutsideFunction","allowHashBang","locations","onToken","onComment","program","directSourceFile","preserveParens","getOptions","opts","block","startLoc","endLoc","comment","pushComment","functionFlags","Parser","startPos","reserved","reservedStrict","reservedWordsStrict","reservedWordsStrictBind","containsEsc","lineStart","curLine","curPosition","lastTokEndLoc","lastTokStartLoc","lastTokStart","lastTokEnd","initialContext","exprAllowed","inModule","strictDirective","potentialArrowAt","yieldPos","awaitPos","awaitIdentPos","labels","undefinedExports","skipLineComment","scopeStack","enterScope","regexpState","prototypeAccessors","inFunction","inGenerator","inAsync","allowSuper","allowDirectSuper","treatFunctionsAsVar","startNode","nextToken","parseTopLevel","currentVarScope","flags","currentThisScope","treatFunctionsAsVarInScope","currentScope","inNonArrowFunction","extend","plugins","cls","parseExpressionAt","parser","parseExpression","tokenizer","pp","literal","DestructuringErrors","shorthandAssign","trailingComma","parenthesizedAssign","parenthesizedBind","doubleProto","spaceAfter","eat","isContextual","eatContextual","expectContextual","unexpected","canInsertSemicolon","insertSemicolon","semicolon","afterTrailingComma","tokType","notNext","expect","raise","checkPatternErrors","refDestructuringErrors","raiseRecoverable","parens","checkExpressionErrors","andThrow","checkYieldAwaitInDefaultParams","isSimpleAssignTarget","expr","expression","pp$1","stmt","parseStatement","adaptDirectivePrologue","finishNode","loopLabel","kind","switchLabel","isLet","skip","nextCh","ident","isAsyncFunction","topLevel","starttype","parseBreakContinueStatement","parseDebuggerStatement","parseDoStatement","parseForStatement","parseFunctionStatement","parseClass","parseIfStatement","parseReturnStatement","parseSwitchStatement","parseThrowStatement","parseTryStatement","parseVarStatement","parseWhileStatement","parseWithStatement","parseBlock","parseEmptyStatement","parseExpressionStatement","parseImport","parseExport","maybeName","parseLabeledStatement","isBreak","parseIdent","lab","parseParenExpression","awaitAt","parseFor","init$1","parseVar","declarations","await","parseForIn","init","toAssignable","checkLVal","isAsync","declarationPosition","parseFunction","FUNC_STATEMENT","FUNC_HANGING_STATEMENT","consequent","alternate","argument","discriminant","cases","sawDefault","isCase","exitScope","handler","clause","parseBindingAtom","simple","finalizer","i$1","label$1","statementStart","createNewLexicalScope","exitStrict","update","isForIn","left","right","parseMaybeAssign","isFor","decl","parseVarId","statement","allowExpressionBody","initFunction","oldYieldPos","oldAwaitPos","oldAwaitIdentPos","parseFunctionParams","parseFunctionBody","parseBindingList","isStatement","oldStrict","parseClassId","parseClassSuper","classBody","hadConstructor","parseClassElement","constructorAllowsSuper","this$1","tryContextual","noLineBreak","computed","startNodeAt","static","isGenerator","parsePropertyName","allowsDirectSuper","parseClassMethod","parseMethod","parseExprSubscripts","exported","checkExport","parseExprAtom","fNode","declaration","cNode","shouldParseExportStatement","checkVariableExport","specifiers","parseExportSpecifiers","checkUnreserved","local","checkLocalExport","checkPatternExport","pat","list$1","elements","elt","decls","nodes","parseImportSpecifiers","node$1","node$2","imported","statements","isDirectiveCandidate","directive","pp$2","isBinding","toAssignableList","exprList","parseSpread","parseRestBinding","parseObj","close","allowEmpty","allowTrailingComma","elts","rest","parseBindingListItem","elem","parseMaybeDefault","bindingType","checkClashes","declareName","pp$3","checkPropClash","propHash","shorthand","proto","noIn","expressions","afterLeftParse","parseYield","ownDestructuringErrors","oldParenAssign","oldTrailingComma","parseMaybeConditional","parseExprOps","parseMaybeUnary","parseExprOp","leftStartPos","leftStartLoc","minPrec","logical","buildBinary","sawUnary","parseAwait","parseSubscripts","noCalls","maybeAsyncArrow","optionalChained","parseSubscript","optional","chainNode","optionalSupported","parseExprList","parseArrowExpression","callee","quasi","parseTemplate","isTagged","readRegexp","canBeArrow","parseLiteral","regex","parseParenAndDistinguishExpression","parseNew","parseExprImport","meta","parseDynamicImport","parseImportMeta","errorPos","bigint","spreadStart","innerStartPos","innerStartLoc","lastIsComma","parseParenItem","innerEndPos","innerEndLoc","parseParenArrowList","finishNodeAt","par","empty$1","isImport","parseTemplateElement","cooked","curElt","quasis","isAsyncProp","isPattern","parseProperty","parsePropertyValue","paramCount","isArrowFunction","isMethod","isExpression","useStrict","checkParams","nonSimple","isSimpleParamList","oldLabels","allowDuplicates","nameHash","liberal","pp$4","SyntaxError","raisedAt","pp$5","Scope","var","lexical","functions","scope","redeclared","scope$2","scope$3","SCOPE_TOP","pp$6","TokContext","isExpr","preserveSpace","override","types$1","b_stat","b_expr","b_tmpl","p_stat","p_expr","q_tmpl","tryReadTemplateToken","f_stat","f_expr","f_expr_gen","f_gen","pp$7","braceIsBlock","prevType","curContext","inGeneratorContext","statementParens","ecma9BinaryProperties","ecma10BinaryProperties","unicodeBinaryProperties","9","10","11","unicodeGeneralCategoryValues","ecma9ScriptValues","ecma10ScriptValues","unicodeScriptValues","buildUnicodeData","binary","nonBinary","General_Category","Script","Script_Extensions","gc","sc","scx","pp$8","RegExpValidationState","validFlags","unicodeProperties","switchU","switchN","lastIntValue","lastStringValue","lastAssertionIsQuantifiable","numCapturingParens","maxBackReference","groupNames","backReferenceNames","codePointToString","ch","isSyntaxCharacter","isControlLetter","isUnicodePropertyNameCharacter","isUnicodePropertyValueCharacter","isDecimalDigit","isHexDigit","hexToInt","isOctalDigit","unicode","at","forceU","nextIndex","lookahead","validateRegExpFlags","flag","validateRegExpPattern","regexp_pattern","regexp_disjunction","regexp_alternative","regexp_eatQuantifier","regexp_eatTerm","regexp_eatAssertion","regexp_eatAtom","regexp_eatExtendedAtom","lookbehind","noError","regexp_eatQuantifierPrefix","regexp_eatBracedQuantifier","regexp_eatDecimalDigits","regexp_eatPatternCharacters","regexp_eatReverseSolidusAtomEscape","regexp_eatCharacterClass","regexp_eatUncapturingGroup","regexp_eatCapturingGroup","regexp_eatAtomEscape","regexp_groupSpecifier","regexp_eatInvalidBracedQuantifier","regexp_eatExtendedPatternCharacter","regexp_eatSyntaxCharacter","regexp_eatGroupName","regexp_eatRegExpIdentifierName","regexp_eatRegExpIdentifierStart","regexp_eatRegExpIdentifierPart","regexp_eatRegExpUnicodeEscapeSequence","isRegExpIdentifierStart","isRegExpIdentifierPart","regexp_eatBackReference","regexp_eatCharacterClassEscape","regexp_eatCharacterEscape","regexp_eatKGroupName","regexp_eatDecimalEscape","regexp_eatControlEscape","regexp_eatCControlLetter","regexp_eatZero","regexp_eatHexEscapeSequence","regexp_eatLegacyOctalEscapeSequence","regexp_eatIdentityEscape","regexp_eatControlLetter","regexp_eatFixedHexDigits","lead","leadSurrogateEnd","trail","regexp_eatHexDigits","isCharacterClassEscape","regexp_eatUnicodePropertyValueExpression","regexp_eatUnicodePropertyName","regexp_eatUnicodePropertyValue","regexp_validateUnicodePropertyNameAndValue","regexp_eatLoneUnicodePropertyNameOrValue","nameOrValue","regexp_validateUnicodePropertyNameOrValue","regexp_classRanges","regexp_eatClassAtom","regexp_eatClassEscape","ch$1","regexp_eatClassControlLetter","regexp_eatOctalDigit","n1","n2","Token","pp$9","stringToBigInt","BigInt","codePointToString$1","ignoreEscapeSequenceInKeyword","getToken","skipSpace","finishToken","readToken","fullCharCodeAtPos","readWord","getTokenFromCode","skipBlockComment","startSkip","loop","readToken_dot","readNumber","next2","readToken_slash","finishOp","readToken_mult_modulo_exp","tokentype","readToken_pipe_amp","readToken_caret","readToken_plus_min","readToken_lt_gt","readToken_eq_excl","readToken_question","readRadixNumber","readString","inClass","flagsStart","readWord1","readInt","radix","maybeLegacyOctalNumericLiteral","allowSeparators","isLegacyOctalNumericLiteral","total","lastCode","startsWithDot","octal","val$1","parseFloat","readCodePoint","codePos","readHexChar","invalidStringToken","quote","chunkStart","readEscapedChar","INVALID_TEMPLATE_ESCAPE_ERROR","inTemplateElement","readTmplToken","readInvalidTemplateToken","position","inTemplate","octalStr","word","escStart","esc","acorn","tokTypes","keywordTypes","tokContexts","segmentify","integer","hasContinuationBit","shouldNegate","line_1","getSourceMappingUrlMatch","lastMatch","loadLink","link","tracedLine","traced","tracedSegment","load","resolveDependency","dependency","fromSourceModule","resolveEntrypoint","transform","createMagicString","sourceMap","loadReturn","plugin","loadResult","fromModule","pluginCtx","sourceMapTree","sourceMapRef","getSourceMappingUrl","decodeDataUriAsSourceMap","sourceMapUri","updateSourceMappingUrl","baseSources","transformReturn","transformResult","SourceModuleDependencyKind","SourceModuleDependency","exportName","isLiteral","_shouldSkip","shouldSkip","enter","skipped","childKeys","leave","ast","visitorCtx","unboundSymbols","locals","nodeEnv","replacedSymbols","requires","requireResolves","skipTransform","parseAst","traverse","requiresBySpec","requireDependency","requireResolvesBySpec","shim","scopingAndRequiresVisitor","isVariableDeclaration","nextParent","isScope","declarePattern","isFunctionDeclaration","declareFunction","isFunctionExpression","isArrowFunctionExpression","isFunction","isClassDeclaration","isTryStatement","visitAndCaptureScoping","isIfStatement","isBinaryExpression","isStringLiteral","isMemberExpression","memberExpressionMatches","rootObject","isIdentifier","visitAndSkipBranches","isCallExpression","firstArg","isTemplateLiteral","visitRequires","nextCheck","collectGlobalsVisitor","isPropertyOfMemberExpression","isProperty","isKeyOfProperty","isMethodDefinition","isKeyOfMethodDefinition","isBindingIdentifier","isUnaryExpression","isArgumentOfTypeOf","foundBinding","declaresArguments","isThisExpression","declaresThis","isObjectPattern","isRestElement","isArrayPattern","isAssignmentPattern","isProgram","isBlockStatement","memberParts","sourceMapTreeMappings","edgesFrom","edgesTo","sourceModules","sourceModule","fromHref","edge","toHref","moduleScopes","importMap","scopes","sourceModuleCode","defs","inputMap","sourceHref","edges","DEFAULT_SHIM_GLOBALS","export","globalThis","sourceMapsTree","disposer","errors","seen","pendingModuleOperations","onCompletedEmitter","onErrorEmitter","onProgressEmitter","graph","onError","progress","completed","edgesByDependency","edgesByInvalidation","sourceModulesByInvalidation","external","dep","existingSourceModule","visitSourceModule","parseResult","globalModules","existingEdge","fromRootUri","toUri","toRootUri","ContextualKeyword","formatTokenType","tokenType","braceBarL","braceBarR","doubleColon","hash","preIncDec","postIncDec","bang","tilde","pipeline","nullishCoalescing","lessThan","greaterThan","relationalOrEqual","plus","minus","exponent","jsxName","jsxText","jsxTagStart","jsxTagEnd","typeParameterStart","nonNullAssertion","_let","_yield","_async","_get","_set","_declare","_readonly","_abstract","_static","_public","_private","_protected","_as","_enum","_type","_implements","NONE","_asserts","_await","_checks","_constructor","_exports","_from","_global","_infer","_interface","_is","_keyof","_mixins","_module","_namespace","_of","_opaque","_proto","_require","charCodes","isJSXEnabled","isTypeScriptEnabled","isFlowEnabled","nextContextId","startTokenIndex","endTokenIndex","isFunctionScope","StateSnapshot","noAnonFunctionType","tokensLength","scopesLength","contextualKeyword","isType","scopeDepth","State","__init","__init2","__init3","__init4","__init5","__init6","__init7","__init8","__init9","__init10","__init11","__init12","tt","getNextContextId","augmentError","lineFeed","Loc","isLookaheadContextual","lookaheadTypeAndKeyword","hasPrecedingLineBreak","prevToken","carriageReturn","isLineTerminator","WHITESPACE_CHARS","space","nonBreakingSpace","oghamSpaceMark","IS_WHITESPACE","computeIsIdentifierChar","IS_IDENTIFIER_CHAR","whitespaceChar","IS_IDENTIFIER_START","numChar","digit0","digit9","IdentifierRole","READ_WORD_TREE","_unique","isDeclaration","role","identifierRole","TopLevelDeclaration","FunctionScopedDeclaration","BlockScopedDeclaration","ObjectShorthandTopLevelDeclaration","ObjectShorthandFunctionScopedDeclaration","ObjectShorthandBlockScopedDeclaration","isNonTopLevelDeclaration","isTopLevelDeclaration","ImportDeclaration","isBlockScopedDeclaration","isFunctionScopedDeclaration","isObjectShorthandDeclaration","Access","ExportAccess","ObjectShorthand","ObjectKey","shadowsGlobal","contextId","rhsEndIndex","numNullishCoalesceStarts","numNullishCoalesceEnds","isOptionalChainStart","isOptionalChainEnd","subscriptStartIndex","nullishStartIndex","nextTemplateToken","graveAccent","dollarSign","leftCurlyBrace","backslash","retokenizeSlashAsRegex","leftSquareBracket","rightSquareBracket","rightCurlyBrace","skipWord","pushTypeContext","existingTokensInType","oldIsType","popTypeContext","lookaheadType","restoreFromSnapshot","TypeAndKeyword","atSign","treePos","lowercaseA","lowercaseZ","keywordValue","asterisk","lineSeparator","paragraphSeparator","numberSign","nextChar","leftParenthesis","rightParenthesis","verticalBar","questionMark","nextChar2","equalsTo","lowercaseX","uppercaseX","lowercaseO","uppercaseO","lowercaseB","uppercaseB","isBigInt","lowercaseN","digit1","digit2","digit3","digit4","digit5","digit6","digit7","digit8","quotationMark","apostrophe","percentSign","width","readToken_mult_modulo","ampersand","caret","plusSign","dash","exclamationMark","lowercaseF","uppercaseA","uppercaseF","underscore","uppercaseE","lowercaseE","entities","quot","amp","apos","nbsp","iexcl","cent","pound","curren","yen","brvbar","sect","uml","ordf","laquo","not","shy","reg","macr","deg","plusmn","sup2","sup3","acute","micro","para","middot","cedil","sup1","ordm","raquo","frac14","frac12","frac34","iquest","Agrave","Aacute","Acirc","Atilde","Auml","Aring","AElig","Ccedil","Egrave","Eacute","Ecirc","Euml","Igrave","Iacute","Icirc","Iuml","ETH","Ntilde","Ograve","Oacute","Ocirc","Otilde","Ouml","times","Oslash","Ugrave","Uacute","Ucirc","Uuml","Yacute","THORN","szlig","agrave","aacute","acirc","atilde","auml","aring","aelig","ccedil","egrave","eacute","ecirc","euml","igrave","iacute","icirc","iuml","eth","ntilde","ograve","oacute","ocirc","otilde","ouml","divide","oslash","ugrave","uacute","ucirc","uuml","yacute","thorn","yuml","OElig","oelig","Scaron","scaron","Yuml","fnof","circ","Alpha","Beta","Gamma","Delta","Epsilon","Zeta","Eta","Theta","Iota","Kappa","Lambda","Mu","Nu","Xi","Omicron","Pi","Rho","Sigma","Tau","Upsilon","Phi","Chi","Psi","Omega","alpha","beta","gamma","delta","epsilon","zeta","eta","theta","iota","kappa","lambda","mu","nu","xi","omicron","pi","rho","sigmaf","sigma","tau","upsilon","phi","chi","psi","omega","thetasym","upsih","piv","ensp","emsp","thinsp","zwnj","zwj","lrm","rlm","ndash","mdash","lsquo","rsquo","sbquo","ldquo","rdquo","bdquo","dagger","Dagger","bull","hellip","permil","prime","Prime","lsaquo","rsaquo","oline","frasl","euro","image","weierp","real","trade","alefsym","larr","uarr","rarr","darr","harr","crarr","lArr","uArr","rArr","dArr","hArr","forall","part","exist","nabla","isin","notin","ni","prod","sum","lowast","radic","infin","ang","and","or","cap","cup","int","there4","sim","cong","asymp","ne","equiv","le","ge","sup","nsub","sube","supe","oplus","otimes","perp","sdot","lceil","rceil","lfloor","rfloor","lang","rang","loz","spades","clubs","hearts","diams","getJSXPragmaInfo","splitPragma","jsxPragma","suffix","jsxFragmentPragma","fragmentBase","fragmentSuffix","pragma","dotIndex","Transformer","HEX_NUMBER","DECIMAL_NUMBER","JSXTransformer","rootTransformer","importProcessor","nameManager","jsxPragmaInfo","lastLineNumber","filenameVarName","matches1","processJSXTag","filePath","claimFreeName","firstTokenStart","lineNumber","getLineNumberForIndex","devProps","production","getFilenameVarName","appendCode","matches2","processPropKeyName","replaceToken","processBalancedCode","processStringPropValue","keyName","identifierName","copyToken","currentToken","valueCode","replacementCode","formatJSXTextReplacement","literalCode","processEntity","entity","newI","formatJSXStringValueLiteral","introEnd","currentIndex","matches2AtIndex","matches1AtIndex","tagName","startsWithLowerCase","processToken","processChildTextElement","whitespace","isInInitialLineWhitespace","seenNonWhitespace","formatJSXTextLiteral","resolvedPragmaBaseName","getIdentifierReplacement","resolvedFragmentPragmaBaseName","processChildren","processTagIntro","processProps","firstChar","numNewlines","indexAfterAmpersand","fromCodePoint","XHTMLEntities","getNonTypeIdentifiers","nonTypeIdentifiers","identifierNameForToken","CJSImportProcessor","enableLegacyTypeScriptModuleInterop","isTypeScriptTransformEnabled","helperManager","importInfoByPath","importsToReplace","identifierReplacements","exportBindingsByLocalName","matches3AtIndex","preprocessImportAtIndex","preprocessExportAtIndex","generateImportReplacements","importInfo","hasBareImport","hasStarExport","exportStarNames","namedExports","defaultNames","wildcardNames","namedImports","localName","isTypeName","primaryImportName","getFreeIdentifierForPath","secondaryImportName","requireCode","wildcardName","moduleExpr","getHelperName","importedName","exportStarName","defaultName","baseName","matchesContextualAtIndex","identifierNameAtIndex","getNamedImports","newIndex","stringValueAtIndex","getImportInfo","preprocessVarExportAtIndex","addExportBinding","preprocessNamedExportAtIndex","preprocessExportStarAtIndex","depth","endIndex","exportedName","isTypeImport","existingInfo","newInfo","importPath","assignedName","exportedNames","computeSourceMap","compiledFilename","HELPERS","interopRequireWildcard","interopRequireDefault","createNamedExportFrom","createStarExport","nullishCoalesce","asyncNullishCoalesce","optionalChain","asyncOptionalChain","optionalChainDelete","asyncOptionalChainDelete","HelperManager","helperNames","helperName","resultCode","helperCodeTemplate","helperCode","identifyShadowedGlobals","globalNames","hasShadowedGlobals","scopeIndex","markShadowedForScope","stackIndex","markShadowedGlobals","FunctionType","NameManager","usedNames","getIdentifierNames","newName","findFreeName","suffixNum","exportedTypeSuite","Transform","SourceMapOptions","Options","transforms","enableLegacyBabel5ModuleInterop","sourceMapOptions","OptionsChecker","OptionsGenTypes","parseRest","isBlockScope","parseBindingIdentifier","parseIdentifier","markPriorBindingIdentifier","parseImportedIdentifier","allowModifiers","hasRemovedComma","firstItemTokenIndex","parseAssignableListItemTypes","parseAssignableListItem","tsParseAccessModifier","tsParseModifier","flowParseTypeAnnotation","flowParseAssignableListItemTypes","tsTryParseTypeAnnotation","tsParseAssignableListItemTypes","leftAlreadyParsed","eqIndex","tsIsIdentifier","allowedModifiers","modifier","tsNextTokenCanFollowModifier","tsParseEntityName","tsParseImportType","tsParseTypeArguments","tsTryParseTypeParameters","tsParseTypeParameters","tsParseType","tsFillSignature","returnToken","returnTokenRequired","tsParseTypeOrTypePredicateAnnotation","tsParseTypeMemberSemicolon","tsParseSignatureMember","tsTryParseIndexSignature","isIndexSignature","tsIsUnambiguouslyIndexSignature","tsParseTypeAnnotation","tsParsePropertyOrMethodSignature","isReadonly","tsParseTypeMember","readonly","tsParseObjectTypeMembers","tsLookaheadIsStartOfMappedType","isStartOfMappedType","tsIsStartOfMappedType","tsParseMappedType","tsParseTupleElementType","tsParseFunctionOrConstructorType","TSConstructorType","tsParseNonArrayType","tsParseTupleType","IS_KEYWORD","tsParseTypeOperatorOrHigher","tsParseArrayTypeOrHigher","tsParseIntersectionTypeOrHigher","tsIsStartOfFunctionType","isUnambiguouslyStartOfFunctionType","tsSkipParameterStart","tsIsUnambiguouslyStartOfFunctionType","tsLookaheadIsUnambiguouslyStartOfFunctionType","tsParseTypePredicateOrAssertsPrefix","tsParseNonConditionalType","TSFunctionType","tsParseUnionTypeOrHigher","tsParseHeritageClause","tsParseExpressionWithTypeArguments","tsParseEnumMember","tsParseEnumDeclaration","tsParseModuleBlock","parseBlockBody","tsParseModuleOrNamespaceDeclaration","tsParseAmbientExternalModuleDeclaration","tsParseImportEqualsDeclaration","tsTryParseExportDeclaration","tsParseDeclaration","tsParseExpressionStatement","declareTokenIndex","matched","tsTryParseDeclare","isBeforeToken","tsCheckLineTerminatorAndMatch","tsTryParseGenericAsyncArrowFunction","tsIsDeclarationStart","tsParseFunctionBodyAndFinish","functionStart","funcContextId","tsStartParseFunctionParams","tsParseMaybeAssign","isWithinParens","baseParseMaybeAssign","wasArrow","tsParseMaybeAssignWithJSX","tsParseMaybeAssignWithoutJSX","jsxParseIdentifier","nextJSXTagToken","jsxParseNamespacedName","jsxParseElementName","jsxParseExpressionContainer","jsxParseAttribute","jsxParseElement","jsxParseAttributeValue","jsxParseOpeningElement","tsTryParseJSXTypeArgument","isSelfClosing","jsxParseElementAt","nextJSXExprToken","jsxReadWord","jsxReadString","jsxReadToken","StopState","flowParseMaybeAssign","PRECEDENCE_MASK","rhsStartTokenIndex","IS_RIGHT_ASSOCIATIVE","nextType","baseParseConditional","typedParseConditional","parseConditional","IS_ASSIGN","tsParseTypeAssertion","IS_PREFIX","IS_POSTFIX","flowParseSubscripts","baseParseSubscripts","stopState","atPossibleAsync","parseCallExpressionArguments","baseParseSubscript","tsParseSubscript","flowParseTypeParameterInstantiation","flowParseSubscript","parseNoCallExpr","parseMaybePrivateName","asyncStartTokenIndex","callContextId","oldNoAnonFunctionType","flowStartParseAsyncArrowFromCallExpression","parseAsyncArrowFromCallExpression","parseExprListItem","shouldParseArrow","parseArrow","parseFunctionExpression","parseDecorators","tsStartParseNewArguments","flowStartParseNewArguments","parseNewArguments","tsParseArrow","flowParseTypeAndPredicateInitialiser","flowParseArrow","previousIndex","parseObjPropValue","parseObjectMethod","objectContextId","isGetterOrSetterMethod","flowParseTypeParameterDeclaration","parseObjectProperty","flowParseVariance","isConstructor","parseFunctionBodyAndFinish","flowParseFunctionBodyAndFinish","allowExpression","flowParseTypeInitialiser","tok","flowParseType","flowParsePredicate","flowParseDeclare","flowParseInterfaceish","flowParseFunctionTypeParams","flowParseTypeAnnotatableIdentifier","flowParseDeclareModule","flowParseTypeAlias","flowParseOpaqueType","isClass","flowParseRestrictedIdentifier","flowParseInterfaceExtends","flowParseObjectType","flowParseQualifiedTypeIdentifier","flowParseInterface","declare","flowParseObjectPropertyKey","flowParseObjectTypeMethodish","flowParseFunctionTypeParam","allowStatic","allowExact","allowProto","endDelim","flowParseObjectTypeProperty","flowObjectTypeSemicolon","initialIdAlreadyParsed","flowParsePrimaryType","isGroupedType","flowParseInterfaceType","flowParseTupleType","flowParsePrefixType","flowParsePostfixType","flowParseAnonFunctionWithoutParens","flowParseIntersectionType","flowParseUnionType","flowStartParseImportSpecifiers","lh","flowStartParseFunctionParams","parseAsyncArrowWithTypeParameters","flowTryParseStatement","ahead","tsTryParseStatementContent","forAwait","varKind","parseAmbiguousForStatement","catchBindingStartTokenIndex","initialTokensLength","simpleName","tsParseIdentifierStatement","flowParseIdentifierStatement","parseStatementContent","parseDecorator","baseParseMaybeDecoratorArguments","parseVarHead","tsAfterParseVarHead","optionalId","nameScopeStartTokenIndex","openBraceIndex","parseClassBody","isClassProperty","isClassMethod","classContextId","parseClassMember","memberStart","isStatic","parseClassProperty","isAbstract","mod","parseClassPropertyName","parsePostMemberNameModifiers","tsTryParseClassMemberWithIsStatic","parseClassMemberWithIsStatic","equalsTokenIndex","hasSuper","tsAfterParseClassSuper","flowAfterParseClassSuper","exportIndex","baseParseExportStar","flowParseExportStar","isExportDefaultSpecifier","parseExportSpecifiersMaybe","parseExportFrom","tsTryParseExportDefaultExpression","parseExportDefaultExpression","isDeclare","matchedDeclaration","tsParseExportDeclaration","flowParseExportDeclaration","parseImportSpecifierLocal","parseImportSpecifier","isTypeKeyword","flowParseImportSpecifier","ImportAccess","parseFile","File","isJSXEnabledArg","isTypeScriptEnabledArg","isFlowEnabledArg","TokenProcessor","tokenIndex","stringValueForToken","t1","t2","t3","t4","t5","whitespaceAndComments","newCode","previousWhitespaceAndComments","appendTokenPrefix","appendTokenSuffix","replaceTokenTrimmingLeftWhitespace","isAsyncOperation","startToken","tokenAtRelativeIndex","relativeIndex","getClassInfo","headerInfo","classToken","className","hasSuperclass","matchesContextIdAndLabel","processClassHeader","constructorInitializerStatements","instanceInitializerNames","staticInitializerNames","constructorInsertPos","fields","rangesToRemove","matchesContextual","processConstructor","statementStartIndex","isAccessModifier","nameStartIndex","skipFieldName","previousToken","equalsIndex","valueEnd","initializerName","restoreToSnapshot","constructorContextId","foundSuperCall","superCallContextId","elideImportEquals","removeInitialToken","removeToken","EMPTY_DECLARATION_INFO","typeDeclarations","valueDeclarations","getDeclarationInfo","shouldElideDefaultExport","declarationInfo","exportToken","numTokens","identifierToken","CJSImportTransformer","reactHotLoaderTransformer","hadExport","hadNamedExport","hadDefaultExport","matches3","processImportEquals","processImport","processExport","processPostIncDec","processIdentifier","processAssignment","processComplexAssignment","processPreIncDec","importName","removeImportAndDetectIfType","stringValue","claimImportCode","removeRemainingImport","foundNonType","matches4","processObjectShorthand","replacement","possibleOpenParenIndex","copyExpectedToken","processExportDefault","processExportVar","processExportFunction","processExportClass","processExportBindings","processExportStar","assignmentSnippet","resolveExportBinding","operatorToken","operatorCode","rawCodeForToken","matches5","processNamedFunction","processNamedClass","defaultVarName","setExtractedDefaultExportName","isSimpleExportVar","processSimpleExportVar","processComplexExportVar","varName","needsParens","processPossibleTypeRange","exportStatements","shouldElideExportedIdentifier","newLocalName","ESMImportTransformer","processNamedExports","removeImportTypeBindings","foundNonTypeImport","shouldElideExportedName","isAtEnd","FlowTransformer","processPossibleArrowParamEnd","processPossibleAsyncArrowWithTypeParams","NumericSeparatorTransformer","currentTokenCode","OptionalCatchBindingTransformer","OptionalChainingNullishTransformer","chainStart","arrowStartSnippet","isLastSubscriptInChain","justSkippedSuper","ReactDisplayNameTransformer","startIndex","tryProcessCreateClassCall","findDisplayName","classNeedsDisplayName","getDisplayNameFromFilename","pathSegments","baseFilename","objectStartIndex","ReactHotLoaderTransformer","extractedDefaultExportName","topLevelNames","namesToRegister","variableName","uniqueLocalName","RESERVED_WORDS","TypeScriptTransformer","isImportsTransformEnabled","processEnum","isExport","processEnumBody","isPreviousValidIdentifier","lastValueReference","nameToken","nameStringCode","isValidIdentifier","valueIsString","valueReference","RootTransformer","sucraseContext","tokenProcessor","isReactHotLoaderTransformEnabled","transformers","generatedVariables","getPrefixCode","emitHelpers","getSuffixCode","startsWith","newlineIndex","braceDepth","parenDepth","processClass","classInfo","needsCommaExpression","processClassBody","staticInitializerStatements","fieldIndex","rangeToRemoveIndex","needsConstructorInit","constructorInitializersCode","makeConstructorInitCode","argsName","needsCloseBrace","copyTokenWithPrefix","nextNonTypeIndex","collectNamesForImport","importedNames","collectNamesForNamedImport","validateOptions","getSucraseContext","preprocessTokens","getGlobalNames","pruneTypeOnlyImports","getTSImportedNames","extensions","uriTestRx","jsxPragmaRx","jsxFragmentPragmaRx","sucraseOptions","jsxPragmaMatches","jsxFragmentPragmaMatches","isValidEntry","isValidFile","isValidDirectory","specToString","specRx","url","JSDelivrCdn","mapChildEntry","protocol","host","dataHost","UNPKG_SPEC_RX","UnpkgCdn","cdn","contentCache","locks","packageEntriesCache","packageJsonCache","unresolvedUri","urlForPackageFile","_withRootUriCheck","unresolvedSpec","packageJsonReturn","results","resolveRootUri","canonicalizedSpec","traversalSegments","parentEntry","uriStr","wrappedReturn","_withLock","packageEntriesCacheForModule","exactMatch","rootDir","urlForPackageList","readUrlFn","dataStr","normalizePackageListing","packageJsonCacheForModule","contentReturn","contentResult","manifest","canonicalHref","lock","runCriticalSection","locked","CdnStrategy","_delegateToStrategy","FSM","states","initialState","actions","onEventEmitter","onStateChangeEmitter","handlingEvents","isDisposed","pendingExternalEvents","pendingInternalEvents","stateDisposer","mutableState","processEvents","stateName","onEvent","registerDisposable","sendEvent","sendEventInternal","transitionTo","fromStateConfig","nextStateConfig","fromState","onExit","onEnterDef","onEnter","onEnterHandler","defaultExtensions","defaultPackageMain","cdnStrategy","memoryStrategy","entrypointUri","compoundStrategy","strategies","packageMain","graphBuilder","injectRuntime","injectedModuleSpecs","optionsExternal","isExternal","codeWithStart","runtimeCode","runtimeFn","velcro","readUrl","fetch","ok","arrayBuffer","status","statusText","sveltePlugin","svelteCompilerPromise","loadCompiler","execute","svelte","svelteVersion","catch","trace","fsPath","endsWith","compiler","compilationResult","compile","css","outputFilename","js","VelcroBuilderServer","file_create","onFileCreate","file_remove","onFileRemove","file_update","onFileUpdate","start_build","generateSourceMap","now","idle","dirty_reset","dirty","build_in_progress","localStrategy","incremental","onCompleted","splitChunks","buildForStaticRuntime","sourceMapDataUri","sourceMapString","onProgress","build_progress","build_complete","build_error","MemoryStrategy","Uri","npmStrategy","forJsDelivr","rootStrategy","CompoundStrategy","Resolver","GraphBuilder","cssCode","BACKSLASH","SINGLE_QUOTE","NL","CR","sucrasePlugin","isPrefixOf","addFile","invalidate","joinPath","removeFile","isLeft","ma","_tag","isRight","__assign","Type","pipe","ab","identity","asDecoder","asEncoder","appendContext","failures","failure","success","pushAll","xs","ys","undefinedType","NullType","u","UndefinedType","VoidType","UnknownType","StringType","NumberType","UnknownArray","BigIntType","BooleanType","AnyArrayType","UnknownRecord","AnyDictionaryType","RefinementType","LiteralType","refinement","isInteger","KeyofType","RecursiveType","runDefinition","ArrayType","us","as","ui","ai","InterfaceType","getNameFromProps","useIdentity","codecs","getInterfaceTypeName","uk","ak","type_1","vak","PartialType","DictionaryType","domain","codomain","UnionType","getUnionName","tags","getTags","all","keys_1","state_1","getIndex","tag_1","groups_1","len_1","find_1","TaggedUnionType","codec","codecs_1","IntersectionType","TupleType","ReadonlyType","ReadonlyArrayType","ExactType","NeverType","AnyType","ObjectType","StrictType","emptyTags","intersect","a_1","isLiteralC","isTypeC","isUnionC","lazyCodecs","isStrictC","isExactC","isRefinementC","isIntersectionC","intersection_1","mergeTags","intersectTags","isRecursiveC","StartBuildEvent","entrypoints","FileCreateEvent","FileRemoveEvent","FileUpdateEvent","Client","BuildProgress","BuildComplete","BuildError","Server","worker","server","wireWorkerEventsToServer","builder","Any","wireClientEvents","stateChangeEvent","debounceInterval","onStateChange","wireBuilderStateChanges"],"mappings":"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,EAAE,EAAE,GAAG,EAAE,GAAG,GAAG,IAAI,GAAG,GAAG,IAAI,GAAG,EAAE,GAAG,GAAG,GAAG,GAAG,GAAG,EAAE,GAAG,GAAG,GAAG,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,GAAG,IAAI,GAAG,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,IAAI,IAAI,GAAG,GAAG,GAAG,EAAE,IAAI,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,EAAE,EAAE,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,EAAE,EAAE,GAAG,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,GAAG,GAAG,GAAG,EAAE,GAAG,GAAG,EAAE,EAAE,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,EAAE,EAAE,GAAG,GAAG,GAAG,EAAE,EAAE,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,GAAG,GAAG,GAAG,EAAE,GAAG,EAAE,EAAE,EAAE,GAAG,GAAG,EAAE,GAAG,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,GAAG,GAAG,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,GAAG,GAAG,EAAE,GAAG,EAAE,GAAG,GAAG,GAAG,EAAE,EAAE,EAAE,IAAI,GAAG,GAAG,EAAE,GAAG,GAAG,GAAG,EAAE,GAAG,GAAG,GAAG,EAAE,GAAG,GAAG,IAAI,GAAG,IAAI,GAAG,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,GAAG,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,GAAG,GAAG,EAAE,EAAE,EAAE,GAAG,EAAE,GAAG,GAAG,EAAE,EAAE,GAAG,EAAE,GAAG,GAAG,GAAG,EAAE,GAAG,GAAG,IAAI,EAAE,EAAE,GAAG,GAAG,EAAE,GAAG,GAAG,IAAI,EAAE,EAAE,EAAE,EAAE,GAAG,GAAG,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,GAAG,GAAG,EAAE,IAAI,GAAG,IAAI,EAAE,GAAG,IAAI,IAAI,IAAI,GAAG,IAAI,KAAK,KAAK,KAAK,IAAI,KAAK,IAAI,EAAE,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,EAAE,GAAG,GAAG,EAAE,GAAG,IAAI,GAAG,IAAI,GAAG,EAAE,EAAE,GAAG,GAAG,GAAG,EAAE,EAAE,EAAE,GAAG,KAAK,EAAE,KAAK,GAAG,EAAE,KAAK,IAAI,GAAG,EAAE,GAAG,EAAE,EAAE,IAAI,KAAK,IAAI,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,KAAK,GAAG,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,IAAI,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,EAAE,KAAK,GAAG,GAAG,EAAE,GAAG,EAAE,IAAI,GAAG,KAAK,IAAI,GAAG,GAAG,EAAE,EAAE,KAAK,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,KAAK,MAAM,GAAG,KAAK,GAAG,IAAI,EAAE,KAAK,GAAG,KAAK,KAAK,IAAI,KAAK,MAGpyCC,EAAwB,CAAC,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,KAAK,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,IAAI,EAAE,IAAI,EAAE,EAAE,EAAE,IAAI,EAAE,IAAI,GAAG,IAAI,EAAE,GAAG,GAAG,GAAG,EAAE,GAAG,EAAE,GAAG,GAAG,GAAG,EAAE,EAAE,EAAE,GAAG,GAAG,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,GAAG,EAAE,EAAE,EAAE,GAAG,GAAG,GAAG,EAAE,EAAE,IAAI,GAAG,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,IAAI,GAAG,GAAG,EAAE,EAAE,EAAE,GAAG,GAAG,GAAG,EAAE,IAAI,EAAE,EAAE,EAAE,GAAG,EAAE,GAAG,GAAG,GAAG,EAAE,GAAG,GAAG,EAAE,EAAE,GAAG,GAAG,EAAE,EAAE,IAAI,GAAG,IAAI,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,IAAI,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,GAAG,GAAG,GAAG,IAAI,EAAE,EAAE,EAAE,GAAG,EAAE,GAAG,GAAG,EAAE,GAAG,IAAI,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,IAAI,EAAE,MAAM,EAAE,IAAI,EAAE,GAAG,EAAE,GAAG,EAAE,KAAK,EAAE,EAAE,GAAG,EAAE,EAAE,GAAG,EAAE,GAAG,EAAE,MAAM,EAAE,KAAK,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,IAAI,EAAE,KAAK,GAAG,IAAI,GAAG,EAAE,GAAG,EAAE,EAAE,GAAG,EAAE,GAAG,EAAE,EAAE,GAAG,KAAK,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,IAAI,EAAE,GAAG,EAAE,IAAI,GAAG,KAAK,EAAE,IAAI,EAAE,EAAE,EAAE,KAAK,EAAE,OAAO,KAKjqB,SAASC,EAAcj4C,EAAM6X,GAE3B,IADA,IAAIjS,EAAM,MACDjL,EAAI,EAAGA,EAAIkd,EAAInW,OAAQ/G,GAAK,EAAG,CAEtC,IADAiL,GAAOiS,EAAIld,IACDqF,EAAQ,OAAO,EAEzB,IADA4F,GAAOiS,EAAIld,EAAI,KACJqF,EAAQ,OAAO,GAM9B,SAASk4C,EAAkBl4C,EAAMm4C,GAC/B,OAAIn4C,EAAO,GAAsB,KAATA,EACpBA,EAAO,KACPA,EAAO,GAAsB,KAATA,EACpBA,EAAO,MACPA,GAAQ,MAAiBA,GAAQ,KAAQ63C,EAAwBz/B,KAAKlS,OAAOgwB,aAAal2B,KAC/E,IAAXm4C,GACGF,EAAcj4C,EAAM+3C,KAK7B,SAASK,EAAiBp4C,EAAMm4C,GAC9B,OAAIn4C,EAAO,GAAsB,KAATA,EACpBA,EAAO,MACPA,EAAO,MACPA,EAAO,KACPA,EAAO,GAAsB,KAATA,EACpBA,EAAO,MACPA,GAAQ,MAAiBA,GAAQ,KAAQ83C,EAAmB1/B,KAAKlS,OAAOgwB,aAAal2B,KAC1E,IAAXm4C,IACGF,EAAcj4C,EAAM+3C,IAA+BE,EAAcj4C,EAAMg4C,OA0BhF,IAAIK,EAAY,SAAmBC,EAAOC,QAC1B,IAATA,IAAkBA,EAAO,IAE9Bl6C,KAAKi6C,MAAQA,EACbj6C,KAAKm6C,QAAUD,EAAKC,QACpBn6C,KAAKo6C,aAAeF,EAAKE,WACzBp6C,KAAKq6C,aAAeH,EAAKG,WACzBr6C,KAAKs6C,SAAWJ,EAAKI,OACrBt6C,KAAKu6C,WAAaL,EAAKK,SACvBv6C,KAAKwG,SAAW0zC,EAAK1zC,OACrBxG,KAAKw6C,UAAYN,EAAKM,QACtBx6C,KAAKy6C,MAAQP,EAAKO,OAAS,KAC3Bz6C,KAAK06C,cAAgB,MAGvB,SAASD,EAAM59C,EAAM89C,GACnB,OAAO,IAAIX,EAAUn9C,EAAM,CAACu9C,YAAY,EAAMK,MAAOE,IAEvD,IAAIP,EAAa,CAACA,YAAY,GAAOC,EAAa,CAACA,YAAY,GAI3DO,EAAa,GAGjB,SAASC,EAAGh+C,EAAM+Q,GAIhB,YAHiB,IAAZA,IAAqBA,EAAU,IAEpCA,EAAQusC,QAAUt9C,EACX+9C,EAAW/9C,GAAQ,IAAIm9C,EAAUn9C,EAAM+Q,GAGhD,IAAIktC,EAAQ,CACVt+B,IAAK,IAAIw9B,EAAU,MAAOK,GAC1BU,OAAQ,IAAIf,EAAU,SAAUK,GAChCnmB,OAAQ,IAAI8lB,EAAU,SAAUK,GAChCx9C,KAAM,IAAIm9C,EAAU,OAAQK,GAC5BW,IAAK,IAAIhB,EAAU,OAGnBiB,SAAU,IAAIjB,EAAU,IAAK,CAACI,YAAY,EAAMC,YAAY,IAC5Da,SAAU,IAAIlB,EAAU,KACxBmB,OAAQ,IAAInB,EAAU,IAAK,CAACI,YAAY,EAAMC,YAAY,IAC1De,OAAQ,IAAIpB,EAAU,KACtBqB,OAAQ,IAAIrB,EAAU,IAAK,CAACI,YAAY,EAAMC,YAAY,IAC1DiB,OAAQ,IAAItB,EAAU,KACtBuB,MAAO,IAAIvB,EAAU,IAAKI,GAC1BoB,KAAM,IAAIxB,EAAU,IAAKI,GACzBqB,MAAO,IAAIzB,EAAU,IAAKI,GAC1BsB,IAAK,IAAI1B,EAAU,KACnB2B,SAAU,IAAI3B,EAAU,IAAKI,GAC7BwB,YAAa,IAAI5B,EAAU,MAC3B6B,MAAO,IAAI7B,EAAU,KAAMI,GAC3B0B,SAAU,IAAI9B,EAAU,YACxB+B,gBAAiB,IAAI/B,EAAU,mBAC/BgC,SAAU,IAAIhC,EAAU,MAAOI,GAC/B6B,UAAW,IAAIjC,EAAU,IAAKK,GAC9B6B,aAAc,IAAIlC,EAAU,KAAM,CAACI,YAAY,EAAMC,YAAY,IAgBjEloB,GAAI,IAAI6nB,EAAU,IAAK,CAACI,YAAY,EAAMG,UAAU,IACpD3hC,OAAQ,IAAIohC,EAAU,KAAM,CAACI,YAAY,EAAMG,UAAU,IACzD4B,OAAQ,IAAInC,EAAU,QAAS,CAACxzC,QAAQ,EAAMg0C,SAAS,EAAMH,YAAY,IACzE7zC,OAAQ,IAAIwzC,EAAU,MAAO,CAACI,YAAY,EAAM5zC,QAAQ,EAAM6zC,YAAY,IAC1E+B,UAAW3B,EAAM,KAAM,GACvB4B,WAAY5B,EAAM,KAAM,GACxB6B,UAAW7B,EAAM,IAAK,GACtB8B,WAAY9B,EAAM,IAAK,GACvB+B,WAAY/B,EAAM,IAAK,GACvBgC,SAAUhC,EAAM,gBAAiB,GACjCiC,WAAYjC,EAAM,YAAa,GAC/BkC,SAAUlC,EAAM,YAAa,GAC7BmC,QAAS,IAAI5C,EAAU,MAAO,CAACI,YAAY,EAAMK,MAAO,EAAGj0C,QAAQ,EAAM6zC,YAAY,IACrFwC,OAAQpC,EAAM,IAAK,IACnBqC,KAAMrC,EAAM,IAAK,IACjBsC,MAAOtC,EAAM,IAAK,IAClBuC,SAAU,IAAIhD,EAAU,KAAM,CAACI,YAAY,IAC3C6C,SAAUxC,EAAM,KAAM,GAGtByC,OAAQrC,EAAG,SACXsC,MAAOtC,EAAG,OAAQT,GAClBgD,OAAQvC,EAAG,SACXwC,UAAWxC,EAAG,YACdyC,UAAWzC,EAAG,YACd0C,SAAU1C,EAAG,UAAWT,GACxBoD,IAAK3C,EAAG,KAAM,CAACP,QAAQ,EAAMF,YAAY,IACzCqD,MAAO5C,EAAG,OAAQT,GAClBsD,SAAU7C,EAAG,WACb8C,KAAM9C,EAAG,MAAO,CAACP,QAAQ,IACzBsD,UAAW/C,EAAG,WAAYR,GAC1BwD,IAAKhD,EAAG,MACRiD,QAASjD,EAAG,SAAUT,GACtB2D,QAASlD,EAAG,UACZxvC,OAAQwvC,EAAG,QAAST,GACpB4D,KAAMnD,EAAG,OACToD,KAAMpD,EAAG,OACTqD,OAAQrD,EAAG,SACXsD,OAAQtD,EAAG,QAAS,CAACP,QAAQ,IAC7B8D,MAAOvD,EAAG,QACVwD,KAAMxD,EAAG,MAAO,CAACT,YAAY,EAAMC,YAAY,IAC/CvQ,MAAO+Q,EAAG,OAAQR,GAClBxQ,OAAQgR,EAAG,QAASR,GACpBiE,OAAQzD,EAAG,QAASR,GACpBkE,SAAU1D,EAAG,UAAWT,GACxBoE,QAAS3D,EAAG,UACZ4D,QAAS5D,EAAG,SAAUR,GACtBqE,MAAO7D,EAAG,OAAQR,GAClBsE,MAAO9D,EAAG,OAAQR,GAClBuE,OAAQ/D,EAAG,QAASR,GACpBwE,IAAKhE,EAAG,KAAM,CAACT,YAAY,EAAMK,MAAO,IACxCqE,YAAajE,EAAG,aAAc,CAACT,YAAY,EAAMK,MAAO,IACxDxwC,QAAS4wC,EAAG,SAAU,CAACT,YAAY,EAAM5zC,QAAQ,EAAM6zC,YAAY,IACnE0E,MAAOlE,EAAG,OAAQ,CAACT,YAAY,EAAM5zC,QAAQ,EAAM6zC,YAAY,IAC/D2E,QAASnE,EAAG,SAAU,CAACT,YAAY,EAAM5zC,QAAQ,EAAM6zC,YAAY,KAMjE4E,EAAY,yBACZC,EAAa,IAAIxvB,OAAOuvB,EAAUtpC,OAAQ,KAE9C,SAASwpC,EAAUx9C,EAAMy9C,GACvB,OAAgB,KAATz9C,GAAwB,KAATA,IAAiBy9C,IAA4B,OAATz9C,GAA4B,OAATA,GAG/E,IAAI09C,EAAqB,gDAErBC,EAAiB,gCAEjBC,EAAMviD,OAAOkB,UACbC,EAAiBohD,EAAIphD,eACrBykB,EAAW28B,EAAI38B,SAInB,SAAStiB,EAAI4J,EAAKs1C,GAChB,OAAOrhD,EAAe1B,KAAKyN,EAAKs1C,GAGlC,IAAIv2C,EAAUD,MAAMC,SAAY,SAAUiB,GAAO,MACxB,mBAAvB0Y,EAASnmB,KAAKyN,IAGhB,SAASu1C,EAAYC,GACnB,OAAO,IAAIhwB,OAAO,OAASgwB,EAAM7hC,QAAQ,KAAM,KAAO,MAMxD,IAAI8hC,EAAW,SAAkBle,EAAMme,GACrC5/C,KAAKyhC,KAAOA,EACZzhC,KAAKgjC,OAAS4c,GAGhBD,EAASzhD,UAAUgxB,OAAS,SAAiBnxB,GAC3C,OAAO,IAAI4hD,EAAS3/C,KAAKyhC,KAAMzhC,KAAKgjC,OAASjlC,IAG/C,IAAI8hD,EAAiB,SAAwBzhD,EAAG4F,EAAOJ,GACrD5D,KAAKgE,MAAQA,EACbhE,KAAK4D,IAAMA,EACU,OAAjBxF,EAAE0hD,aAAuB9/C,KAAK2V,OAASvX,EAAE0hD,aAS/C,SAASC,EAAYC,EAAO9wB,GAC1B,IAAK,IAAIuS,EAAO,EAAG3Z,EAAM,IAAK,CAC5Bo3B,EAAW9H,UAAYtvB,EACvB,IAAIphB,EAAQw4C,EAAWrd,KAAKme,GAC5B,KAAIt5C,GAASA,EAAM+oB,MAAQP,GAIzB,OAAO,IAAIywB,EAASle,EAAMvS,EAASpH,KAHjC2Z,EACF3Z,EAAMphB,EAAM+oB,MAAQ/oB,EAAM,GAAGrD,QAUnC,IAAI48C,EAAiB,CAMnBC,YAAa,GAIbC,WAAY,SAMZC,oBAAqB,KAGrBC,gBAAiB,KAKjBC,cAAe,KAGfC,4BAA4B,EAG5BC,6BAA6B,EAG7BC,2BAA2B,EAG3BC,eAAe,EAKfC,WAAW,EAMXC,QAAS,KAWTC,UAAW,KASXjJ,QAAQ,EAMRkJ,QAAS,KAGThB,WAAY,KAGZiB,iBAAkB,KAGlBC,gBAAgB,GAKlB,SAASC,EAAWC,GAClB,IAAItzC,EAAU,GAEd,IAAK,IAAIsK,KAAO+nC,EACZryC,EAAQsK,GAAOgpC,GAAQ5gD,EAAI4gD,EAAMhpC,GAAOgpC,EAAKhpC,GAAO+nC,EAAe/nC,GAQvE,GANItK,EAAQsyC,aAAe,OACvBtyC,EAAQsyC,aAAe,MAEE,MAAzBtyC,EAAQ0yC,gBACR1yC,EAAQ0yC,cAAgB1yC,EAAQsyC,YAAc,GAE9Cj3C,EAAQ2E,EAAQgzC,SAAU,CAC5B,IAAItvB,EAAS1jB,EAAQgzC,QACrBhzC,EAAQgzC,QAAU,SAAU1hD,GAAS,OAAOoyB,EAAOnlB,KAAKjN,IAK1D,OAHI+J,EAAQ2E,EAAQizC,aAChBjzC,EAAQizC,UAKd,SAAqBjzC,EAASgK,GAC5B,OAAO,SAASupC,EAAOpgD,EAAMiD,EAAOJ,EAAKw9C,EAAUC,GACjD,IAAIC,EAAU,CACZhgD,KAAM6/C,EAAQ,QAAU,OACxB5jD,MAAOwD,EACPiD,MAAOA,EACPJ,IAAKA,GAEHgK,EAAQ+yC,YACRW,EAAQxe,IAAM,IAAI+c,EAAe7/C,KAAMohD,EAAUC,IACjDzzC,EAAQgqC,SACR0J,EAAQhkC,MAAQ,CAACtZ,EAAOJ,IAC5BgU,EAAMzL,KAAKm1C,IAjBWC,CAAY3zC,EAASA,EAAQizC,YAE9CjzC,EA+BT,SAAS4zC,GAAczN,EAAOjD,GAC5B,OAVmB,GAUMiD,EART,EAQ+B,IAAMjD,EAPjC,EAO+D,GAIrF,IAQI2Q,GAAS,SAAgB7zC,EAASoyC,EAAO0B,GAC3C1hD,KAAK4N,QAAUA,EAAUqzC,EAAWrzC,GACpC5N,KAAK8/C,WAAalyC,EAAQkyC,WAC1B9/C,KAAKo5C,SAAWqG,EAAYrG,EAASxrC,EAAQsyC,aAAe,EAAI,EAA2B,WAAvBtyC,EAAQuyC,WAA0B,UAAY,IAClH,IAAIwB,EAAW,GACf,IAA8B,IAA1B/zC,EAAQ0yC,cAAwB,CAClC,IAAK,IAAIjT,EAAIz/B,EAAQsyC,cACbyB,EAAW7I,EAAczL,IADEA,KAER,WAAvBz/B,EAAQuyC,aAA2BwB,GAAY,UAErD3hD,KAAK84C,cAAgB2G,EAAYkC,GACjC,IAAIC,GAAkBD,EAAWA,EAAW,IAAM,IAAM7I,EAAc7M,OACtEjsC,KAAK6hD,oBAAsBpC,EAAYmC,GACvC5hD,KAAK8hD,wBAA0BrC,EAAYmC,EAAiB,IAAM9I,EAAcI,YAChFl5C,KAAKggD,MAAQn4C,OAAOm4C,GAKpBhgD,KAAK+hD,aAAc,EAKfL,GACF1hD,KAAKuH,IAAMm6C,EACX1hD,KAAKgiD,UAAYhiD,KAAKggD,MAAMjyB,YAAY,KAAM2zB,EAAW,GAAK,EAC9D1hD,KAAKiiD,QAAUjiD,KAAKggD,MAAMzgC,MAAM,EAAGvf,KAAKgiD,WAAW1lC,MAAM2iC,GAAW57C,SAEpErD,KAAKuH,IAAMvH,KAAKgiD,UAAY,EAC5BhiD,KAAKiiD,QAAU,GAKjBjiD,KAAKsB,KAAOw5C,EAAME,IAElBh7C,KAAKzC,MAAQ,KAEbyC,KAAKgE,MAAQhE,KAAK4D,IAAM5D,KAAKuH,IAG7BvH,KAAKohD,SAAWphD,KAAKqhD,OAASrhD,KAAKkiD,cAGnCliD,KAAKmiD,cAAgBniD,KAAKoiD,gBAAkB,KAC5CpiD,KAAKqiD,aAAeriD,KAAKsiD,WAAatiD,KAAKuH,IAK3CvH,KAAK2rB,QAAU3rB,KAAKuiD,iBACpBviD,KAAKwiD,aAAc,EAGnBxiD,KAAKyiD,SAAkC,WAAvB70C,EAAQuyC,WACxBngD,KAAKisC,OAASjsC,KAAKyiD,UAAYziD,KAAK0iD,gBAAgB1iD,KAAKuH,KAGzDvH,KAAK2iD,kBAAoB,EAGzB3iD,KAAK4iD,SAAW5iD,KAAK6iD,SAAW7iD,KAAK8iD,cAAgB,EAErD9iD,KAAK+iD,OAAS,GAEd/iD,KAAKgjD,iBAAmB,GAGP,IAAbhjD,KAAKuH,KAAaqG,EAAQ8yC,eAA4C,OAA3B1gD,KAAKggD,MAAMzgC,MAAM,EAAG,IAC/Dvf,KAAKijD,gBAAgB,GAGzBjjD,KAAKkjD,WAAa,GAClBljD,KAAKmjD,WAjGS,GAoGdnjD,KAAKojD,YAAc,MAGjBC,GAAqB,CAAEC,WAAY,CAAE76C,cAAc,GAAO86C,YAAa,CAAE96C,cAAc,GAAO+6C,QAAS,CAAE/6C,cAAc,GAAOg7C,WAAY,CAAEh7C,cAAc,GAAOi7C,iBAAkB,CAAEj7C,cAAc,GAAOk7C,oBAAqB,CAAEl7C,cAAc,IAEnPg5C,GAAOvjD,UAAU0G,MAAQ,WACvB,IAAIwL,EAAOpQ,KAAK4N,QAAQkzC,SAAW9gD,KAAK4jD,YAExC,OADA5jD,KAAK6jD,YACE7jD,KAAK8jD,cAAc1zC,IAG5BizC,GAAmBC,WAAWnmD,IAAM,WAAc,OA9G7B,EA8GqC6C,KAAK+jD,kBAAkBC,OAA0B,GAC3GX,GAAmBE,YAAYpmD,IAAM,WAAc,OA5G7B,EA4GqC6C,KAAK+jD,kBAAkBC,OAA2B,GAC7GX,GAAmBG,QAAQrmD,IAAM,WAAc,OA9G7B,EA8GqC6C,KAAK+jD,kBAAkBC,OAAuB,GACrGX,GAAmBI,WAAWtmD,IAAM,WAAc,OA3GhC,GA2GwC6C,KAAKikD,mBAAmBD,OAAuB,GACzGX,GAAmBK,iBAAiBvmD,IAAM,WAAc,OA3G/B,IA2GuC6C,KAAKikD,mBAAmBD,OAA8B,GACtHX,GAAmBM,oBAAoBxmD,IAAM,WAAc,OAAO6C,KAAKkkD,2BAA2BlkD,KAAKmkD,iBAGvG1C,GAAOvjD,UAAUkmD,mBAAqB,WAAiC,OAtHlD,EAsH0DpkD,KAAKikD,mBAAmBD,OAA0B,GAEjIvC,GAAO4C,OAAS,WAEZ,IADA,IAAIC,EAAU,GAAIr3B,EAAMniB,UAAUzH,OAC1B4pB,KAAQq3B,EAASr3B,GAAQniB,UAAWmiB,GAG9C,IADA,IAAIs3B,EAAMvkD,KACD1D,EAAI,EAAGA,EAAIgoD,EAAQjhD,OAAQ/G,IAAOioD,EAAMD,EAAQhoD,GAAGioD,GAC5D,OAAOA,GAGT9C,GAAO78C,MAAQ,SAAgBo7C,EAAOpyC,GACpC,OAAO,IAAI5N,KAAK4N,EAASoyC,GAAOp7C,SAGlC68C,GAAO+C,kBAAoB,SAA4BxE,EAAOz4C,EAAKqG,GACjE,IAAI62C,EAAS,IAAIzkD,KAAK4N,EAASoyC,EAAOz4C,GAEtC,OADAk9C,EAAOZ,YACAY,EAAOC,mBAGhBjD,GAAOkD,UAAY,SAAoB3E,EAAOpyC,GAC5C,OAAO,IAAI5N,KAAK4N,EAASoyC,IAG3BhjD,OAAO8Y,iBAAkB2rC,GAAOvjD,UAAWmlD,IAE3C,IAAIuB,GAAKnD,GAAOvjD,UAIZ2mD,GAAU,6CAwGd,SAASC,KACP9kD,KAAK+kD,gBACL/kD,KAAKglD,cACLhlD,KAAKilD,oBACLjlD,KAAKklD,kBACLllD,KAAKmlD,aACF,EA7GLP,GAAGlC,gBAAkB,SAAS1+C,GAC5B,OAAS,CAEPs7C,EAAelI,UAAYpzC,EAC3BA,GAASs7C,EAAezd,KAAK7hC,KAAKggD,OAAO,GAAG38C,OAC5C,IAAIqD,EAAQm+C,GAAQhjB,KAAK7hC,KAAKggD,MAAMzgC,MAAMvb,IAC1C,IAAK0C,EAAS,OAAO,EACrB,GAA+B,gBAA1BA,EAAM,IAAMA,EAAM,IAAsB,CAC3C44C,EAAelI,UAAYpzC,EAAQ0C,EAAM,GAAGrD,OAC5C,IAAI+hD,EAAa9F,EAAezd,KAAK7hC,KAAKggD,OAAQp8C,EAAMwhD,EAAW31B,MAAQ21B,EAAW,GAAG/hD,OACrFsG,EAAO3J,KAAKggD,MAAM9L,OAAOtwC,GAC7B,MAAgB,MAAT+F,GAAyB,MAATA,GACpBs1C,EAAUllC,KAAKqrC,EAAW,OACxB,sBAAsBrrC,KAAKpQ,IAAkB,MAATA,GAA+C,MAA/B3J,KAAKggD,MAAM9L,OAAOtwC,EAAM,IAEnFI,GAAS0C,EAAM,GAAGrD,OAGlBi8C,EAAelI,UAAYpzC,EAC3BA,GAASs7C,EAAezd,KAAK7hC,KAAKggD,OAAO,GAAG38C,OAClB,MAAtBrD,KAAKggD,MAAMh8C,IACXA,MAOR4gD,GAAGS,IAAM,SAAS/jD,GAChB,OAAItB,KAAKsB,OAASA,IAChBtB,KAAK2J,QACE,IAQXi7C,GAAGU,aAAe,SAASzoD,GACzB,OAAOmD,KAAKsB,OAASw5C,EAAMj+C,MAAQmD,KAAKzC,QAAUV,IAASmD,KAAK+hD,aAKlE6C,GAAGW,cAAgB,SAAS1oD,GAC1B,QAAKmD,KAAKslD,aAAazoD,KACvBmD,KAAK2J,QACE,IAKTi7C,GAAGY,iBAAmB,SAAS3oD,GACxBmD,KAAKulD,cAAc1oD,IAASmD,KAAKylD,cAKxCb,GAAGc,mBAAqB,WACtB,OAAO1lD,KAAKsB,OAASw5C,EAAME,KACzBh7C,KAAKsB,OAASw5C,EAAMM,QACpB6D,EAAUllC,KAAK/Z,KAAKggD,MAAMzgC,MAAMvf,KAAKsiD,WAAYtiD,KAAKgE,SAG1D4gD,GAAGe,gBAAkB,WACnB,GAAI3lD,KAAK0lD,qBAGP,OAFI1lD,KAAK4N,QAAQwyC,qBACbpgD,KAAK4N,QAAQwyC,oBAAoBpgD,KAAKsiD,WAAYtiD,KAAKmiD,gBACpD,GAOXyC,GAAGgB,UAAY,WACR5lD,KAAKqlD,IAAIvK,EAAMU,OAAUx7C,KAAK2lD,mBAAqB3lD,KAAKylD,cAG/Db,GAAGiB,mBAAqB,SAASC,EAASC,GACxC,GAAI/lD,KAAKsB,OAASwkD,EAKhB,OAJI9lD,KAAK4N,QAAQyyC,iBACbrgD,KAAK4N,QAAQyyC,gBAAgBrgD,KAAKqiD,aAAcriD,KAAKoiD,iBACpD2D,GACD/lD,KAAK2J,QACF,GAOXi7C,GAAGoB,OAAS,SAAS1kD,GACnBtB,KAAKqlD,IAAI/jD,IAAStB,KAAKylD,cAKzBb,GAAGa,WAAa,SAASl+C,GACvBvH,KAAKimD,MAAa,MAAP1+C,EAAcA,EAAMvH,KAAKgE,MAAO,qBAY7C4gD,GAAGsB,mBAAqB,SAASC,EAAwB5L,GACvD,GAAK4L,EAAL,CACIA,EAAuBnB,eAAiB,GACxChlD,KAAKomD,iBAAiBD,EAAuBnB,cAAe,iDAChE,IAAIqB,EAAS9L,EAAW4L,EAAuBlB,oBAAsBkB,EAAuBjB,kBACxFmB,GAAU,GAAKrmD,KAAKomD,iBAAiBC,EAAQ,2BAGnDzB,GAAG0B,sBAAwB,SAASH,EAAwBI,GAC1D,IAAKJ,EAA0B,OAAO,EACtC,IAAIpB,EAAkBoB,EAAuBpB,gBACzCI,EAAcgB,EAAuBhB,YACzC,IAAKoB,EAAY,OAAOxB,GAAmB,GAAKI,GAAe,EAC3DJ,GAAmB,GACnB/kD,KAAKimD,MAAMlB,EAAiB,2EAC5BI,GAAe,GACfnlD,KAAKomD,iBAAiBjB,EAAa,uCAGzCP,GAAG4B,+BAAiC,WAC9BxmD,KAAK4iD,YAAc5iD,KAAK6iD,UAAY7iD,KAAK4iD,SAAW5iD,KAAK6iD,WACzD7iD,KAAKimD,MAAMjmD,KAAK4iD,SAAU,8CAC1B5iD,KAAK6iD,UACL7iD,KAAKimD,MAAMjmD,KAAK6iD,SAAU,+CAGhC+B,GAAG6B,qBAAuB,SAASC,GACjC,MAAkB,4BAAdA,EAAKplD,KACEtB,KAAKymD,qBAAqBC,EAAKC,YACrB,eAAdD,EAAKplD,MAAuC,qBAAdolD,EAAKplD,MAG5C,IAAIslD,GAAOnF,GAAOvjD,UASlB0oD,GAAK9C,cAAgB,SAAS1zC,GAC5B,IAAIhU,EAAU,GAEd,IADKgU,EAAKs3B,OAAQt3B,EAAKs3B,KAAO,IACvB1nC,KAAKsB,OAASw5C,EAAME,KAAK,CAC9B,IAAI6L,EAAO7mD,KAAK8mD,eAAe,MAAM,EAAM1qD,GAC3CgU,EAAKs3B,KAAKv7B,KAAK06C,GAEjB,GAAI7mD,KAAKyiD,SACL,IAAK,IAAInmD,EAAI,EAAGs8B,EAAO57B,OAAOoY,KAAKpV,KAAKgjD,kBAAmB1mD,EAAIs8B,EAAKv1B,OAAQ/G,GAAK,EACjF,CACE,IAAIO,EAAO+7B,EAAKt8B,GAEhB0D,KAAKomD,iBAAiBpmD,KAAKgjD,iBAAiBnmD,GAAMmH,MAAQ,WAAanH,EAAO,oBAKpF,OAHAmD,KAAK+mD,uBAAuB32C,EAAKs3B,MACjC1nC,KAAK2J,OACLyG,EAAK+vC,WAAangD,KAAK4N,QAAQuyC,WACxBngD,KAAKgnD,WAAW52C,EAAM,YAG/B,IAAI62C,GAAY,CAACC,KAAM,QAASC,GAAc,CAACD,KAAM,UAErDN,GAAKQ,MAAQ,SAASz7B,GACpB,GAAI3rB,KAAK4N,QAAQsyC,YAAc,IAAMlgD,KAAKslD,aAAa,OAAU,OAAO,EACxEhG,EAAelI,UAAYp3C,KAAKuH,IAChC,IAAI8/C,EAAO/H,EAAezd,KAAK7hC,KAAKggD,OAChCr2C,EAAO3J,KAAKuH,IAAM8/C,EAAK,GAAGhkD,OAAQikD,EAAStnD,KAAKggD,MAAMlyB,WAAWnkB,GAKrE,GAAe,KAAX29C,EAAiB,OAAO,EAC5B,GAAI37B,EAAW,OAAO,EAEtB,GAAe,MAAX27B,EAAkB,OAAO,EAC7B,GAAIzN,EAAkByN,GAAQ,GAAO,CAEnC,IADA,IAAI//C,EAAMoC,EAAO,EACVowC,EAAiB/5C,KAAKggD,MAAMlyB,WAAWvmB,IAAM,MAAWA,EAC/D,IAAIggD,EAAQvnD,KAAKggD,MAAMzgC,MAAM5V,EAAMpC,GACnC,IAAK8xC,EAA0Bt/B,KAAKwtC,GAAU,OAAO,EAEvD,OAAO,GAMTX,GAAKY,gBAAkB,WACrB,GAAIxnD,KAAK4N,QAAQsyC,YAAc,IAAMlgD,KAAKslD,aAAa,SACnD,OAAO,EAEXhG,EAAelI,UAAYp3C,KAAKuH,IAChC,IAAI8/C,EAAO/H,EAAezd,KAAK7hC,KAAKggD,OAChCr2C,EAAO3J,KAAKuH,IAAM8/C,EAAK,GAAGhkD,OAC9B,OAAQ47C,EAAUllC,KAAK/Z,KAAKggD,MAAMzgC,MAAMvf,KAAKuH,IAAKoC,KACX,aAArC3J,KAAKggD,MAAMzgC,MAAM5V,EAAMA,EAAO,KAC7BA,EAAO,IAAM3J,KAAKggD,MAAM38C,SAAW02C,EAAiB/5C,KAAKggD,MAAM9L,OAAOvqC,EAAO,MAUlFi9C,GAAKE,eAAiB,SAASn7B,EAAS87B,EAAUrrD,GAChD,IAAoD8qD,EAAhDQ,EAAY1nD,KAAKsB,KAAM8O,EAAOpQ,KAAK4jD,YAWvC,OATI5jD,KAAKonD,MAAMz7B,KACb+7B,EAAY5M,EAAMmD,KAClBiJ,EAAO,OAODQ,GACR,KAAK5M,EAAMoC,OAAQ,KAAKpC,EAAMuC,UAAW,OAAOr9C,KAAK2nD,4BAA4Bv3C,EAAMs3C,EAAUvN,SACjG,KAAKW,EAAMwC,UAAW,OAAOt9C,KAAK4nD,uBAAuBx3C,GACzD,KAAK0qC,EAAM0C,IAAK,OAAOx9C,KAAK6nD,iBAAiBz3C,GAC7C,KAAK0qC,EAAM6C,KAAM,OAAO39C,KAAK8nD,kBAAkB13C,GAC/C,KAAK0qC,EAAM8C,UAKT,OADKjyB,IAAY3rB,KAAKisC,QAAsB,OAAZtgB,GAAgC,UAAZA,IAAyB3rB,KAAK4N,QAAQsyC,aAAe,GAAKlgD,KAAKylD,aAC5GzlD,KAAK+nD,uBAAuB33C,GAAM,GAAQub,GACnD,KAAKmvB,EAAMwD,OAET,OADI3yB,GAAW3rB,KAAKylD,aACbzlD,KAAKgoD,WAAW53C,GAAM,GAC/B,KAAK0qC,EAAM+C,IAAK,OAAO79C,KAAKioD,iBAAiB73C,GAC7C,KAAK0qC,EAAMgD,QAAS,OAAO99C,KAAKkoD,qBAAqB93C,GACrD,KAAK0qC,EAAMiD,QAAS,OAAO/9C,KAAKmoD,qBAAqB/3C,GACrD,KAAK0qC,EAAMzvC,OAAQ,OAAOrL,KAAKooD,oBAAoBh4C,GACnD,KAAK0qC,EAAMkD,KAAM,OAAOh+C,KAAKqoD,kBAAkBj4C,GAC/C,KAAK0qC,EAAMoD,OAAQ,KAAKpD,EAAMmD,KAG5B,OAFAiJ,EAAOA,GAAQlnD,KAAKzC,MAChBouB,GAAoB,QAATu7B,GAAkBlnD,KAAKylD,aAC/BzlD,KAAKsoD,kBAAkBl4C,EAAM82C,GACtC,KAAKpM,EAAMqD,OAAQ,OAAOn+C,KAAKuoD,oBAAoBn4C,GACnD,KAAK0qC,EAAMsD,MAAO,OAAOp+C,KAAKwoD,mBAAmBp4C,GACjD,KAAK0qC,EAAMK,OAAQ,OAAOn7C,KAAKyoD,YAAW,EAAMr4C,GAChD,KAAK0qC,EAAMU,KAAM,OAAOx7C,KAAK0oD,oBAAoBt4C,GACjD,KAAK0qC,EAAM0D,QACX,KAAK1D,EAAM2D,QACT,GAAIz+C,KAAK4N,QAAQsyC,YAAc,IAAMwH,IAAc5M,EAAM2D,QAAS,CAChEa,EAAelI,UAAYp3C,KAAKuH,IAChC,IAAI8/C,EAAO/H,EAAezd,KAAK7hC,KAAKggD,OAChCr2C,EAAO3J,KAAKuH,IAAM8/C,EAAK,GAAGhkD,OAAQikD,EAAStnD,KAAKggD,MAAMlyB,WAAWnkB,GACrE,GAAe,KAAX29C,GAA4B,KAAXA,EACjB,OAAOtnD,KAAK2oD,yBAAyBv4C,EAAMpQ,KAAK0kD,mBAStD,OANK1kD,KAAK4N,QAAQ4yC,8BACXiH,GACDznD,KAAKimD,MAAMjmD,KAAKgE,MAAO,0DACtBhE,KAAKyiD,UACNziD,KAAKimD,MAAMjmD,KAAKgE,MAAO,oEAEtB0jD,IAAc5M,EAAM2D,QAAUz+C,KAAK4oD,YAAYx4C,GAAQpQ,KAAK6oD,YAAYz4C,EAAMhU,GAOvF,QACE,GAAI4D,KAAKwnD,kBAGP,OAFI77B,GAAW3rB,KAAKylD,aACpBzlD,KAAK2J,OACE3J,KAAK+nD,uBAAuB33C,GAAM,GAAOub,GAGlD,IAAIm9B,EAAY9oD,KAAKzC,MAAOmpD,EAAO1mD,KAAK0kD,kBACxC,OAAIgD,IAAc5M,EAAMj+C,MAAsB,eAAd6pD,EAAKplD,MAAyBtB,KAAKqlD,IAAIvK,EAAMW,OAClEz7C,KAAK+oD,sBAAsB34C,EAAM04C,EAAWpC,EAAM/6B,GAC/C3rB,KAAK2oD,yBAAyBv4C,EAAMs2C,KAItDE,GAAKe,4BAA8B,SAASv3C,EAAM+pC,GAChD,IAAI6O,EAAsB,UAAZ7O,EACdn6C,KAAK2J,OACD3J,KAAKqlD,IAAIvK,EAAMU,OAASx7C,KAAK2lD,kBAAqBv1C,EAAK6pC,MAAQ,KAC1Dj6C,KAAKsB,OAASw5C,EAAMj+C,KAAQmD,KAAKylD,cAExCr1C,EAAK6pC,MAAQj6C,KAAKipD,aAClBjpD,KAAK4lD,aAMP,IADA,IAAItpD,EAAI,EACDA,EAAI0D,KAAK+iD,OAAO1/C,SAAU/G,EAAG,CAClC,IAAI4sD,EAAMlpD,KAAK+iD,OAAOzmD,GACtB,GAAkB,MAAd8T,EAAK6pC,OAAiBiP,EAAIrsD,OAASuT,EAAK6pC,MAAMp9C,KAAM,CACtD,GAAgB,MAAZqsD,EAAIhC,OAAiB8B,GAAwB,SAAbE,EAAIhC,MAAoB,MAC5D,GAAI92C,EAAK6pC,OAAS+O,EAAW,OAIjC,OADI1sD,IAAM0D,KAAK+iD,OAAO1/C,QAAUrD,KAAKimD,MAAM71C,EAAKpM,MAAO,eAAiBm2C,GACjEn6C,KAAKgnD,WAAW52C,EAAM44C,EAAU,iBAAmB,sBAG5DpC,GAAKgB,uBAAyB,SAASx3C,GAGrC,OAFApQ,KAAK2J,OACL3J,KAAK4lD,YACE5lD,KAAKgnD,WAAW52C,EAAM,sBAG/Bw2C,GAAKiB,iBAAmB,SAASz3C,GAW/B,OAVApQ,KAAK2J,OACL3J,KAAK+iD,OAAO52C,KAAK86C,IACjB72C,EAAKs3B,KAAO1nC,KAAK8mD,eAAe,MAChC9mD,KAAK+iD,OAAOtjC,MACZzf,KAAKgmD,OAAOlL,EAAMqD,QAClB/tC,EAAK2J,KAAO/Z,KAAKmpD,uBACbnpD,KAAK4N,QAAQsyC,aAAe,EAC5BlgD,KAAKqlD,IAAIvK,EAAMU,MAEfx7C,KAAK4lD,YACF5lD,KAAKgnD,WAAW52C,EAAM,qBAW/Bw2C,GAAKkB,kBAAoB,SAAS13C,GAChCpQ,KAAK2J,OACL,IAAIy/C,EAAWppD,KAAK4N,QAAQsyC,aAAe,IAAMlgD,KAAKwjD,UAAaxjD,KAAKsjD,YAActjD,KAAK4N,QAAQ6yC,4BAA+BzgD,KAAKulD,cAAc,SAAYvlD,KAAKqiD,cAAgB,EAItL,GAHAriD,KAAK+iD,OAAO52C,KAAK86C,IACjBjnD,KAAKmjD,WAAW,GAChBnjD,KAAKgmD,OAAOlL,EAAMO,QACdr7C,KAAKsB,OAASw5C,EAAMU,KAEtB,OADI4N,GAAW,GAAKppD,KAAKylD,WAAW2D,GAC7BppD,KAAKqpD,SAASj5C,EAAM,MAE7B,IAAIg3C,EAAQpnD,KAAKonD,QACjB,GAAIpnD,KAAKsB,OAASw5C,EAAMmD,MAAQj+C,KAAKsB,OAASw5C,EAAMoD,QAAUkJ,EAAO,CACnE,IAAIkC,EAAStpD,KAAK4jD,YAAasD,EAAOE,EAAQ,MAAQpnD,KAAKzC,MAI3D,OAHAyC,KAAK2J,OACL3J,KAAKupD,SAASD,GAAQ,EAAMpC,GAC5BlnD,KAAKgnD,WAAWsC,EAAQ,wBACnBtpD,KAAKsB,OAASw5C,EAAM+D,KAAQ7+C,KAAK4N,QAAQsyC,aAAe,GAAKlgD,KAAKslD,aAAa,QAA0C,IAA/BgE,EAAOE,aAAanmD,QAC7GrD,KAAK4N,QAAQsyC,aAAe,IAC1BlgD,KAAKsB,OAASw5C,EAAM+D,IAClBuK,GAAW,GAAKppD,KAAKylD,WAAW2D,GAC7Bh5C,EAAKq5C,MAAQL,GAAW,GAE5BppD,KAAK0pD,WAAWt5C,EAAMk5C,KAE3BF,GAAW,GAAKppD,KAAKylD,WAAW2D,GAC7BppD,KAAKqpD,SAASj5C,EAAMk5C,IAE7B,IAAInD,EAAyB,IAAIrB,GAC7B6E,EAAO3pD,KAAK0kD,iBAAgB,EAAMyB,GACtC,OAAInmD,KAAKsB,OAASw5C,EAAM+D,KAAQ7+C,KAAK4N,QAAQsyC,aAAe,GAAKlgD,KAAKslD,aAAa,OAC7EtlD,KAAK4N,QAAQsyC,aAAe,IAC1BlgD,KAAKsB,OAASw5C,EAAM+D,IAClBuK,GAAW,GAAKppD,KAAKylD,WAAW2D,GAC7Bh5C,EAAKq5C,MAAQL,GAAW,GAEnCppD,KAAK4pD,aAAaD,GAAM,EAAOxD,GAC/BnmD,KAAK6pD,UAAUF,GACR3pD,KAAK0pD,WAAWt5C,EAAMu5C,KAE7B3pD,KAAKsmD,sBAAsBH,GAAwB,GAEjDiD,GAAW,GAAKppD,KAAKylD,WAAW2D,GAC7BppD,KAAKqpD,SAASj5C,EAAMu5C,KAG7B/C,GAAKmB,uBAAyB,SAAS33C,EAAM05C,EAASC,GAEpD,OADA/pD,KAAK2J,OACE3J,KAAKgqD,cAAc55C,EAAM65C,IAAkBF,EAAsB,EAAIG,KAAyB,EAAOJ,IAG9GlD,GAAKqB,iBAAmB,SAAS73C,GAM/B,OALApQ,KAAK2J,OACLyG,EAAK2J,KAAO/Z,KAAKmpD,uBAEjB/4C,EAAK+5C,WAAanqD,KAAK8mD,eAAe,MACtC12C,EAAKg6C,UAAYpqD,KAAKqlD,IAAIvK,EAAM2C,OAASz9C,KAAK8mD,eAAe,MAAQ,KAC9D9mD,KAAKgnD,WAAW52C,EAAM,gBAG/Bw2C,GAAKsB,qBAAuB,SAAS93C,GAWnC,OAVKpQ,KAAKsjD,YAAetjD,KAAK4N,QAAQ2yC,4BAClCvgD,KAAKimD,MAAMjmD,KAAKgE,MAAO,gCAC3BhE,KAAK2J,OAMD3J,KAAKqlD,IAAIvK,EAAMU,OAASx7C,KAAK2lD,kBAAqBv1C,EAAKi6C,SAAW,MAC/Dj6C,EAAKi6C,SAAWrqD,KAAK0kD,kBAAmB1kD,KAAK4lD,aAC7C5lD,KAAKgnD,WAAW52C,EAAM,oBAG/Bw2C,GAAKuB,qBAAuB,SAAS/3C,GAYnC,IAAI0X,EAXJ9nB,KAAK2J,OACLyG,EAAKk6C,aAAetqD,KAAKmpD,uBACzB/4C,EAAKm6C,MAAQ,GACbvqD,KAAKgmD,OAAOlL,EAAMK,QAClBn7C,KAAK+iD,OAAO52C,KAAKg7C,IACjBnnD,KAAKmjD,WAAW,GAOhB,IAAK,IAAIqH,GAAa,EAAOxqD,KAAKsB,OAASw5C,EAAMM,QAC/C,GAAIp7C,KAAKsB,OAASw5C,EAAMqC,OAASn9C,KAAKsB,OAASw5C,EAAMyC,SAAU,CAC7D,IAAIkN,EAASzqD,KAAKsB,OAASw5C,EAAMqC,MAC7Br1B,GAAO9nB,KAAKgnD,WAAWl/B,EAAK,cAChC1X,EAAKm6C,MAAMp+C,KAAK2b,EAAM9nB,KAAK4jD,aAC3B97B,EAAIqiC,WAAa,GACjBnqD,KAAK2J,OACD8gD,EACF3iC,EAAI/N,KAAO/Z,KAAK0kD,mBAEZ8F,GAAcxqD,KAAKomD,iBAAiBpmD,KAAKqiD,aAAc,4BAC3DmI,GAAa,EACb1iC,EAAI/N,KAAO,MAEb/Z,KAAKgmD,OAAOlL,EAAMW,YAEb3zB,GAAO9nB,KAAKylD,aACjB39B,EAAIqiC,WAAWh+C,KAAKnM,KAAK8mD,eAAe,OAO5C,OAJA9mD,KAAK0qD,YACD5iC,GAAO9nB,KAAKgnD,WAAWl/B,EAAK,cAChC9nB,KAAK2J,OACL3J,KAAK+iD,OAAOtjC,MACLzf,KAAKgnD,WAAW52C,EAAM,oBAG/Bw2C,GAAKwB,oBAAsB,SAASh4C,GAMlC,OALApQ,KAAK2J,OACDs1C,EAAUllC,KAAK/Z,KAAKggD,MAAMzgC,MAAMvf,KAAKsiD,WAAYtiD,KAAKgE,SACtDhE,KAAKimD,MAAMjmD,KAAKsiD,WAAY,+BAChClyC,EAAKi6C,SAAWrqD,KAAK0kD,kBACrB1kD,KAAK4lD,YACE5lD,KAAKgnD,WAAW52C,EAAM,mBAK/B,IAAIoU,GAAQ,GAEZoiC,GAAKyB,kBAAoB,SAASj4C,GAIhC,GAHApQ,KAAK2J,OACLyG,EAAK+wC,MAAQnhD,KAAKyoD,aAClBr4C,EAAKu6C,QAAU,KACX3qD,KAAKsB,OAASw5C,EAAMsC,OAAQ,CAC9B,IAAIwN,EAAS5qD,KAAK4jD,YAElB,GADA5jD,KAAK2J,OACD3J,KAAKqlD,IAAIvK,EAAMO,QAAS,CAC1BuP,EAAOzyC,MAAQnY,KAAK6qD,mBACpB,IAAIC,EAA+B,eAAtBF,EAAOzyC,MAAM7W,KAC1BtB,KAAKmjD,WAAW2H,EApnBG,GAonB2B,GAC9C9qD,KAAK6pD,UAAUe,EAAOzyC,MAAO2yC,EAvmBX,EAFL,GA0mBb9qD,KAAKgmD,OAAOlL,EAAMQ,aAEdt7C,KAAK4N,QAAQsyC,YAAc,IAAMlgD,KAAKylD,aAC1CmF,EAAOzyC,MAAQ,KACfnY,KAAKmjD,WAAW,GAElByH,EAAOljB,KAAO1nC,KAAKyoD,YAAW,GAC9BzoD,KAAK0qD,YACLt6C,EAAKu6C,QAAU3qD,KAAKgnD,WAAW4D,EAAQ,eAKzC,OAHAx6C,EAAK26C,UAAY/qD,KAAKqlD,IAAIvK,EAAM4C,UAAY19C,KAAKyoD,aAAe,KAC3Dr4C,EAAKu6C,SAAYv6C,EAAK26C,WACvB/qD,KAAKimD,MAAM71C,EAAKpM,MAAO,mCACpBhE,KAAKgnD,WAAW52C,EAAM,iBAG/Bw2C,GAAK0B,kBAAoB,SAASl4C,EAAM82C,GAItC,OAHAlnD,KAAK2J,OACL3J,KAAKupD,SAASn5C,GAAM,EAAO82C,GAC3BlnD,KAAK4lD,YACE5lD,KAAKgnD,WAAW52C,EAAM,wBAG/Bw2C,GAAK2B,oBAAsB,SAASn4C,GAMlC,OALApQ,KAAK2J,OACLyG,EAAK2J,KAAO/Z,KAAKmpD,uBACjBnpD,KAAK+iD,OAAO52C,KAAK86C,IACjB72C,EAAKs3B,KAAO1nC,KAAK8mD,eAAe,SAChC9mD,KAAK+iD,OAAOtjC,MACLzf,KAAKgnD,WAAW52C,EAAM,mBAG/Bw2C,GAAK4B,mBAAqB,SAASp4C,GAKjC,OAJIpQ,KAAKisC,QAAUjsC,KAAKimD,MAAMjmD,KAAKgE,MAAO,yBAC1ChE,KAAK2J,OACLyG,EAAKpS,OAASgC,KAAKmpD,uBACnB/4C,EAAKs3B,KAAO1nC,KAAK8mD,eAAe,QACzB9mD,KAAKgnD,WAAW52C,EAAM,kBAG/Bw2C,GAAK8B,oBAAsB,SAASt4C,GAElC,OADApQ,KAAK2J,OACE3J,KAAKgnD,WAAW52C,EAAM,mBAG/Bw2C,GAAKmC,sBAAwB,SAAS34C,EAAM04C,EAAWpC,EAAM/6B,GAC3D,IAAK,IAAIq/B,EAAM,EAAGpyB,EAAO54B,KAAK+iD,OAAQiI,EAAMpyB,EAAKv1B,OAAQ2nD,GAAO,EAC9D,CACYpyB,EAAKoyB,GAEPnuD,OAASisD,GACf9oD,KAAKimD,MAAMS,EAAK1iD,MAAO,UAAY8kD,EAAY,yBAGrD,IADA,IAAI5B,EAAOlnD,KAAKsB,KAAKg5C,OAAS,OAASt6C,KAAKsB,OAASw5C,EAAMiD,QAAU,SAAW,KACvEzhD,EAAI0D,KAAK+iD,OAAO1/C,OAAS,EAAG/G,GAAK,EAAGA,IAAK,CAChD,IAAI2uD,EAAUjrD,KAAK+iD,OAAOzmD,GAC1B,GAAI2uD,EAAQC,iBAAmB96C,EAAKpM,MAI3B,MAFPinD,EAAQC,eAAiBlrD,KAAKgE,MAC9BinD,EAAQ/D,KAAOA,EAOnB,OAJAlnD,KAAK+iD,OAAO52C,KAAK,CAACtP,KAAMisD,EAAW5B,KAAMA,EAAMgE,eAAgBlrD,KAAKgE,QACpEoM,EAAKs3B,KAAO1nC,KAAK8mD,eAAen7B,GAAwC,IAA9BA,EAAQ9I,QAAQ,SAAkB8I,EAAU,QAAUA,EAAU,SAC1G3rB,KAAK+iD,OAAOtjC,MACZrP,EAAK6pC,MAAQyM,EACN1mD,KAAKgnD,WAAW52C,EAAM,qBAG/Bw2C,GAAK+B,yBAA2B,SAASv4C,EAAMs2C,GAG7C,OAFAt2C,EAAKu2C,WAAaD,EAClB1mD,KAAK4lD,YACE5lD,KAAKgnD,WAAW52C,EAAM,wBAO/Bw2C,GAAK6B,WAAa,SAAS0C,EAAuB/6C,EAAMg7C,GAOtD,SAN+B,IAA1BD,IAAmCA,GAAwB,QAClD,IAAT/6C,IAAkBA,EAAOpQ,KAAK4jD,aAEnCxzC,EAAKs3B,KAAO,GACZ1nC,KAAKgmD,OAAOlL,EAAMK,QACdgQ,GAAyBnrD,KAAKmjD,WAAW,GACtCnjD,KAAKsB,OAASw5C,EAAMM,QAAQ,CACjC,IAAIyL,EAAO7mD,KAAK8mD,eAAe,MAC/B12C,EAAKs3B,KAAKv7B,KAAK06C,GAKjB,OAHIuE,IAAcprD,KAAKisC,QAAS,GAChCjsC,KAAK2J,OACDwhD,GAAyBnrD,KAAK0qD,YAC3B1qD,KAAKgnD,WAAW52C,EAAM,mBAO/Bw2C,GAAKyC,SAAW,SAASj5C,EAAMu5C,GAU7B,OATAv5C,EAAKu5C,KAAOA,EACZ3pD,KAAKgmD,OAAOlL,EAAMU,MAClBprC,EAAK2J,KAAO/Z,KAAKsB,OAASw5C,EAAMU,KAAO,KAAOx7C,KAAK0kD,kBACnD1kD,KAAKgmD,OAAOlL,EAAMU,MAClBprC,EAAKi7C,OAASrrD,KAAKsB,OAASw5C,EAAMQ,OAAS,KAAOt7C,KAAK0kD,kBACvD1kD,KAAKgmD,OAAOlL,EAAMQ,QAClBlrC,EAAKs3B,KAAO1nC,KAAK8mD,eAAe,OAChC9mD,KAAK0qD,YACL1qD,KAAK+iD,OAAOtjC,MACLzf,KAAKgnD,WAAW52C,EAAM,iBAM/Bw2C,GAAK8C,WAAa,SAASt5C,EAAMu5C,GAC/B,IAAI2B,EAAUtrD,KAAKsB,OAASw5C,EAAM+D,IA2BlC,OA1BA7+C,KAAK2J,OAGW,wBAAdggD,EAAKroD,MACwB,MAA7BqoD,EAAKH,aAAa,GAAGG,QAElB2B,GACDtrD,KAAK4N,QAAQsyC,YAAc,GAC3BlgD,KAAKisC,QACS,QAAd0d,EAAKzC,MAC4B,eAAjCyC,EAAKH,aAAa,GAAGjtC,GAAGjb,MAG1BtB,KAAKimD,MACH0D,EAAK3lD,OACHsnD,EAAU,SAAW,UAAY,0DAEd,sBAAd3B,EAAKroD,MACdtB,KAAKimD,MAAM0D,EAAK3lD,MAAO,sCAEzBoM,EAAKm7C,KAAO5B,EACZv5C,EAAKo7C,MAAQF,EAAUtrD,KAAK0kD,kBAAoB1kD,KAAKyrD,mBACrDzrD,KAAKgmD,OAAOlL,EAAMQ,QAClBlrC,EAAKs3B,KAAO1nC,KAAK8mD,eAAe,OAChC9mD,KAAK0qD,YACL1qD,KAAK+iD,OAAOtjC,MACLzf,KAAKgnD,WAAW52C,EAAMk7C,EAAU,iBAAmB,mBAK5D1E,GAAK2C,SAAW,SAASn5C,EAAMs7C,EAAOxE,GAGpC,IAFA92C,EAAKo5C,aAAe,GACpBp5C,EAAK82C,KAAOA,IACH,CACP,IAAIyE,EAAO3rD,KAAK4jD,YAYhB,GAXA5jD,KAAK4rD,WAAWD,EAAMzE,GAClBlnD,KAAKqlD,IAAIvK,EAAM3oB,IACjBw5B,EAAKhC,KAAO3pD,KAAKyrD,iBAAiBC,GAChB,UAATxE,GAAsBlnD,KAAKsB,OAASw5C,EAAM+D,KAAQ7+C,KAAK4N,QAAQsyC,aAAe,GAAKlgD,KAAKslD,aAAa,MAEpF,eAAjBqG,EAAKpvC,GAAGjb,MAA2BoqD,IAAU1rD,KAAKsB,OAASw5C,EAAM+D,KAAO7+C,KAAKslD,aAAa,OAGnGqG,EAAKhC,KAAO,KAFZ3pD,KAAKimD,MAAMjmD,KAAKsiD,WAAY,4DAF5BtiD,KAAKylD,aAMPr1C,EAAKo5C,aAAar9C,KAAKnM,KAAKgnD,WAAW2E,EAAM,wBACxC3rD,KAAKqlD,IAAIvK,EAAMS,OAAU,MAEhC,OAAOnrC,GAGTw2C,GAAKgF,WAAa,SAASD,EAAMzE,GAC/ByE,EAAKpvC,GAAKvc,KAAK6qD,mBACf7qD,KAAK6pD,UAAU8B,EAAKpvC,GAAa,QAAT2qC,EAvxBX,EACI,GAsxBiD,IAGpE,IAAI+C,GAAiB,EAAGC,GAAyB,EAMjDtD,GAAKoD,cAAgB,SAAS55C,EAAMy7C,EAAWC,EAAqBhC,GAClE9pD,KAAK+rD,aAAa37C,IACdpQ,KAAK4N,QAAQsyC,aAAe,GAAKlgD,KAAK4N,QAAQsyC,aAAe,IAAM4J,KACjE9pD,KAAKsB,OAASw5C,EAAMgC,MAAS+O,EAAY3B,IACzClqD,KAAKylD,aACTr1C,EAAK0gC,UAAY9wC,KAAKqlD,IAAIvK,EAAMgC,OAE9B98C,KAAK4N,QAAQsyC,aAAe,IAC5B9vC,EAAK2jC,QAAU+V,GAEf+B,EAAY5B,KACd75C,EAAKmM,GAjB8D,EAiBxDsvC,GAAiC7rD,KAAKsB,OAASw5C,EAAMj+C,KAAO,KAAOmD,KAAKipD,cAC/E74C,EAAKmM,IAAQsvC,EAAY3B,IAKzBlqD,KAAK6pD,UAAUz5C,EAAKmM,GAAKvc,KAAKisC,QAAU77B,EAAK0gC,WAAa1gC,EAAK2jC,MAAS/zC,KAAK2jD,oBAjzBtE,EACI,EACC,IAkzBlB,IAAIqI,EAAchsD,KAAK4iD,SAAUqJ,EAAcjsD,KAAK6iD,SAAUqJ,EAAmBlsD,KAAK8iD,cAetF,OAdA9iD,KAAK4iD,SAAW,EAChB5iD,KAAK6iD,SAAW,EAChB7iD,KAAK8iD,cAAgB,EACrB9iD,KAAKmjD,WAAW3B,GAAcpxC,EAAK2jC,MAAO3jC,EAAK0gC,YAEzC+a,EAAY5B,KACd75C,EAAKmM,GAAKvc,KAAKsB,OAASw5C,EAAMj+C,KAAOmD,KAAKipD,aAAe,MAE7DjpD,KAAKmsD,oBAAoB/7C,GACzBpQ,KAAKosD,kBAAkBh8C,EAAM07C,GAAqB,GAElD9rD,KAAK4iD,SAAWoJ,EAChBhsD,KAAK6iD,SAAWoJ,EAChBjsD,KAAK8iD,cAAgBoJ,EACdlsD,KAAKgnD,WAAW52C,EAAOy7C,EAAY5B,GAAkB,sBAAwB,uBAGtFrD,GAAKuF,oBAAsB,SAAS/7C,GAClCpQ,KAAKgmD,OAAOlL,EAAMO,QAClBjrC,EAAKm9B,OAASvtC,KAAKqsD,iBAAiBvR,EAAMQ,QAAQ,EAAOt7C,KAAK4N,QAAQsyC,aAAe,GACrFlgD,KAAKwmD,kCAMPI,GAAKoB,WAAa,SAAS53C,EAAMk8C,GAC/BtsD,KAAK2J,OAIL,IAAI4iD,EAAYvsD,KAAKisC,OACrBjsC,KAAKisC,QAAS,EAEdjsC,KAAKwsD,aAAap8C,EAAMk8C,GACxBtsD,KAAKysD,gBAAgBr8C,GACrB,IAAIs8C,EAAY1sD,KAAK4jD,YACjB+I,GAAiB,EAGrB,IAFAD,EAAUhlB,KAAO,GACjB1nC,KAAKgmD,OAAOlL,EAAMK,QACXn7C,KAAKsB,OAASw5C,EAAMM,QAAQ,CACjC,IAAIv8C,EAAUmB,KAAK4sD,kBAAsC,OAApBx8C,EAAKrG,YACtClL,IACF6tD,EAAUhlB,KAAKv7B,KAAKtN,GACC,qBAAjBA,EAAQyC,MAAgD,gBAAjBzC,EAAQqoD,OAC7CyF,GAAkB3sD,KAAKimD,MAAMpnD,EAAQmF,MAAO,2CAChD2oD,GAAiB,IAOvB,OAHA3sD,KAAKisC,OAASsgB,EACdvsD,KAAK2J,OACLyG,EAAKs3B,KAAO1nC,KAAKgnD,WAAW0F,EAAW,aAChC1sD,KAAKgnD,WAAW52C,EAAMk8C,EAAc,mBAAqB,oBAGlE1F,GAAKgG,kBAAoB,SAASC,GAChC,IAAIC,EAAS9sD,KAEb,GAAIA,KAAKqlD,IAAIvK,EAAMU,MAAS,OAAO,KAEnC,IAAI5sC,EAAS5O,KAAK4jD,YACdmJ,EAAgB,SAAU32C,EAAG42C,QACV,IAAhBA,IAAyBA,GAAc,GAE5C,IAAIhpD,EAAQ8oD,EAAO9oD,MAAOo9C,EAAW0L,EAAO1L,SAC5C,QAAK0L,EAAOvH,cAAcnvC,OACtB02C,EAAOxrD,OAASw5C,EAAMO,QAAY2R,GAAgBF,EAAOpH,wBACzD92C,EAAO/Q,KAAOivD,EAAOrH,aACzB72C,EAAOq+C,UAAW,EAClBr+C,EAAO/Q,IAAMivD,EAAOI,YAAYlpD,EAAOo9C,GACvCxyC,EAAO/Q,IAAIhB,KAAOuZ,EAClB02C,EAAO9F,WAAWp4C,EAAO/Q,IAAK,eACvB,KAGT+Q,EAAOs4C,KAAO,SACdt4C,EAAOu+C,OAASJ,EAAc,UAC9B,IAAIK,EAAcptD,KAAKqlD,IAAIvK,EAAMgC,MAC7BgN,GAAU,EACTsD,IACCptD,KAAK4N,QAAQsyC,aAAe,GAAK6M,EAAc,SAAS,IAC1DjD,GAAU,EACVsD,EAAcptD,KAAK4N,QAAQsyC,aAAe,GAAKlgD,KAAKqlD,IAAIvK,EAAMgC,OACrDiQ,EAAc,OACvBn+C,EAAOs4C,KAAO,MACL6F,EAAc,SACvBn+C,EAAOs4C,KAAO,QAGbt4C,EAAO/Q,KAAOmC,KAAKqtD,kBAAkBz+C,GAC1C,IAAI/Q,EAAM+Q,EAAO/Q,IACbyvD,GAAoB,EAkBxB,OAjBK1+C,EAAOq+C,UAAar+C,EAAOu+C,UAAwB,eAAbtvD,EAAIyD,MAAsC,gBAAbzD,EAAIhB,MAC3D,YAAbgB,EAAIyD,MAAoC,gBAAdzD,EAAIN,OAMvBqR,EAAOu+C,QAAuB,eAAbtvD,EAAIyD,MAAsC,cAAbzD,EAAIhB,MAC3DmD,KAAKimD,MAAMpoD,EAAImG,MAAO,2DANF,WAAhB4K,EAAOs4C,MAAqBlnD,KAAKimD,MAAMpoD,EAAImG,MAAO,2CAClDopD,GAAeptD,KAAKimD,MAAMpoD,EAAImG,MAAO,oCACrC8lD,GAAW9pD,KAAKimD,MAAMpoD,EAAImG,MAAO,wCACrC4K,EAAOs4C,KAAO,cACdoG,EAAoBT,GAItB7sD,KAAKutD,iBAAiB3+C,EAAQw+C,EAAatD,EAASwD,GAChC,QAAhB1+C,EAAOs4C,MAAiD,IAA/Bt4C,EAAOrR,MAAMgwC,OAAOlqC,QAC7CrD,KAAKomD,iBAAiBx3C,EAAOrR,MAAMyG,MAAO,gCAC1B,QAAhB4K,EAAOs4C,MAAiD,IAA/Bt4C,EAAOrR,MAAMgwC,OAAOlqC,QAC7CrD,KAAKomD,iBAAiBx3C,EAAOrR,MAAMyG,MAAO,wCAC1B,QAAhB4K,EAAOs4C,MAAkD,gBAAhCt4C,EAAOrR,MAAMgwC,OAAO,GAAGjsC,MAChDtB,KAAKomD,iBAAiBx3C,EAAOrR,MAAMgwC,OAAO,GAAGvpC,MAAO,iCACjD4K,GAGTg4C,GAAK2G,iBAAmB,SAAS3+C,EAAQw+C,EAAatD,EAASwD,GAE7D,OADA1+C,EAAOrR,MAAQyC,KAAKwtD,YAAYJ,EAAatD,EAASwD,GAC/CttD,KAAKgnD,WAAWp4C,EAAQ,qBAGjCg4C,GAAK4F,aAAe,SAASp8C,EAAMk8C,GAC7BtsD,KAAKsB,OAASw5C,EAAMj+C,MACtBuT,EAAKmM,GAAKvc,KAAKipD,aACXqD,GACAtsD,KAAK6pD,UAAUz5C,EAAKmM,GA96BT,GA86B2B,MAEtB,IAAhB+vC,GACAtsD,KAAKylD,aACTr1C,EAAKmM,GAAK,OAIdqqC,GAAK6F,gBAAkB,SAASr8C,GAC9BA,EAAKrG,WAAa/J,KAAKqlD,IAAIvK,EAAMyD,UAAYv+C,KAAKytD,sBAAwB,MAK5E7G,GAAKiC,YAAc,SAASz4C,EAAMhU,GAGhC,GAFA4D,KAAK2J,OAED3J,KAAKqlD,IAAIvK,EAAMgC,MAajB,OAZI98C,KAAK4N,QAAQsyC,aAAe,KAC1BlgD,KAAKulD,cAAc,OACrBn1C,EAAKs9C,SAAW1tD,KAAKipD,YAAW,GAChCjpD,KAAK2tD,YAAYvxD,EAASgU,EAAKs9C,SAAS7wD,KAAMmD,KAAKqiD,eAEnDjyC,EAAKs9C,SAAW,MAGpB1tD,KAAKwlD,iBAAiB,QAClBxlD,KAAKsB,OAASw5C,EAAM5mB,QAAUl0B,KAAKylD,aACvCr1C,EAAKuF,OAAS3V,KAAK4tD,gBACnB5tD,KAAK4lD,YACE5lD,KAAKgnD,WAAW52C,EAAM,wBAE/B,GAAIpQ,KAAKqlD,IAAIvK,EAAMyC,UAAW,CAE5B,IAAIuM,EACJ,GAFA9pD,KAAK2tD,YAAYvxD,EAAS,UAAW4D,KAAKqiD,cAEtCriD,KAAKsB,OAASw5C,EAAM8C,YAAckM,EAAU9pD,KAAKwnD,mBAAoB,CACvE,IAAIqG,EAAQ7tD,KAAK4jD,YACjB5jD,KAAK2J,OACDmgD,GAAW9pD,KAAK2J,OACpByG,EAAK09C,YAAc9tD,KAAKgqD,cAAc6D,EA5L2B,EA4LpB5D,IAAmC,EAAOH,QAClF,GAAI9pD,KAAKsB,OAASw5C,EAAMwD,OAAQ,CACrC,IAAIyP,EAAQ/tD,KAAK4jD,YACjBxzC,EAAK09C,YAAc9tD,KAAKgoD,WAAW+F,EAAO,mBAE1C39C,EAAK09C,YAAc9tD,KAAKyrD,mBACxBzrD,KAAK4lD,YAEP,OAAO5lD,KAAKgnD,WAAW52C,EAAM,4BAG/B,GAAIpQ,KAAKguD,6BACP59C,EAAK09C,YAAc9tD,KAAK8mD,eAAe,MACT,wBAA1B12C,EAAK09C,YAAYxsD,KACjBtB,KAAKiuD,oBAAoB7xD,EAASgU,EAAK09C,YAAYtE,cAEnDxpD,KAAK2tD,YAAYvxD,EAASgU,EAAK09C,YAAYvxC,GAAG1f,KAAMuT,EAAK09C,YAAYvxC,GAAGvY,OAC5EoM,EAAK89C,WAAa,GAClB99C,EAAKuF,OAAS,SACT,CAGL,GAFAvF,EAAK09C,YAAc,KACnB19C,EAAK89C,WAAaluD,KAAKmuD,sBAAsB/xD,GACzC4D,KAAKulD,cAAc,QACjBvlD,KAAKsB,OAASw5C,EAAM5mB,QAAUl0B,KAAKylD,aACvCr1C,EAAKuF,OAAS3V,KAAK4tD,oBACd,CACL,IAAK,IAAItxD,EAAI,EAAGs8B,EAAOxoB,EAAK89C,WAAY5xD,EAAIs8B,EAAKv1B,OAAQ/G,GAAK,EAAG,CAE/D,IAAImQ,EAAOmsB,EAAKt8B,GAEhB0D,KAAKouD,gBAAgB3hD,EAAK4hD,OAE1BruD,KAAKsuD,iBAAiB7hD,EAAK4hD,OAG7Bj+C,EAAKuF,OAAS,KAEhB3V,KAAK4lD,YAEP,OAAO5lD,KAAKgnD,WAAW52C,EAAM,2BAG/Bw2C,GAAK+G,YAAc,SAASvxD,EAASS,EAAM0K,GACpCnL,IACDkE,EAAIlE,EAASS,IACbmD,KAAKomD,iBAAiB7+C,EAAK,qBAAuB1K,EAAO,KAC7DT,EAAQS,IAAQ,IAGlB+pD,GAAK2H,mBAAqB,SAASnyD,EAASoyD,GAC1C,IAAIltD,EAAOktD,EAAIltD,KACf,GAAa,eAATA,EACAtB,KAAK2tD,YAAYvxD,EAASoyD,EAAI3xD,KAAM2xD,EAAIxqD,YACvC,GAAa,kBAAT1C,EACL,IAAK,IAAIhF,EAAI,EAAGs8B,EAAO41B,EAAIvtB,WAAY3kC,EAAIs8B,EAAKv1B,OAAQ/G,GAAK,EAC7D,CACE,IAAIie,EAAOqe,EAAKt8B,GAEhB0D,KAAKuuD,mBAAmBnyD,EAASme,QAElC,GAAa,iBAATjZ,EACL,IAAK,IAAI0pD,EAAM,EAAGyD,EAASD,EAAIE,SAAU1D,EAAMyD,EAAOprD,OAAQ2nD,GAAO,EAAG,CACxE,IAAI2D,EAAMF,EAAOzD,GAEX2D,GAAO3uD,KAAKuuD,mBAAmBnyD,EAASuyD,OAEhC,aAATrtD,EACLtB,KAAKuuD,mBAAmBnyD,EAASoyD,EAAIjxD,OACvB,sBAAT+D,EACLtB,KAAKuuD,mBAAmBnyD,EAASoyD,EAAIjD,MACvB,gBAATjqD,EACLtB,KAAKuuD,mBAAmBnyD,EAASoyD,EAAInE,UACvB,4BAAT/oD,GACLtB,KAAKuuD,mBAAmBnyD,EAASoyD,EAAI7H,aAG3CC,GAAKqH,oBAAsB,SAAS7xD,EAASwyD,GAC3C,GAAKxyD,EACL,IAAK,IAAIE,EAAI,EAAGs8B,EAAOg2B,EAAOtyD,EAAIs8B,EAAKv1B,OAAQ/G,GAAK,EAClD,CACA,IAAIqvD,EAAO/yB,EAAKt8B,GAEhB0D,KAAKuuD,mBAAmBnyD,EAASuvD,EAAKpvC,MAI1CqqC,GAAKoH,2BAA6B,WAChC,MAA6B,QAAtBhuD,KAAKsB,KAAK64C,SACO,UAAtBn6C,KAAKsB,KAAK64C,SACY,UAAtBn6C,KAAKsB,KAAK64C,SACY,aAAtBn6C,KAAKsB,KAAK64C,SACVn6C,KAAKonD,SACLpnD,KAAKwnD,mBAKTZ,GAAKuH,sBAAwB,SAAS/xD,GACpC,IAAIyyD,EAAQ,GAAIpqC,GAAQ,EAGxB,IADAzkB,KAAKgmD,OAAOlL,EAAMK,SACVn7C,KAAKqlD,IAAIvK,EAAMM,SAAS,CAC9B,GAAK32B,EAGIA,GAAQ,OADf,GADAzkB,KAAKgmD,OAAOlL,EAAMS,OACdv7C,KAAK6lD,mBAAmB/K,EAAMM,QAAW,MAG/C,IAAIhrC,EAAOpQ,KAAK4jD,YAChBxzC,EAAKi+C,MAAQruD,KAAKipD,YAAW,GAC7B74C,EAAKs9C,SAAW1tD,KAAKulD,cAAc,MAAQvlD,KAAKipD,YAAW,GAAQ74C,EAAKi+C,MACxEruD,KAAK2tD,YAAYvxD,EAASgU,EAAKs9C,SAAS7wD,KAAMuT,EAAKs9C,SAAS1pD,OAC5D6qD,EAAM1iD,KAAKnM,KAAKgnD,WAAW52C,EAAM,oBAEnC,OAAOy+C,GAKTjI,GAAKgC,YAAc,SAASx4C,GAY1B,OAXApQ,KAAK2J,OAED3J,KAAKsB,OAASw5C,EAAM5mB,QACtB9jB,EAAK89C,WAAa1pC,GAClBpU,EAAKuF,OAAS3V,KAAK4tD,kBAEnBx9C,EAAK89C,WAAaluD,KAAK8uD,wBACvB9uD,KAAKwlD,iBAAiB,QACtBp1C,EAAKuF,OAAS3V,KAAKsB,OAASw5C,EAAM5mB,OAASl0B,KAAK4tD,gBAAkB5tD,KAAKylD,cAEzEzlD,KAAK4lD,YACE5lD,KAAKgnD,WAAW52C,EAAM,sBAK/Bw2C,GAAKkI,sBAAwB,WAC3B,IAAID,EAAQ,GAAIpqC,GAAQ,EACxB,GAAIzkB,KAAKsB,OAASw5C,EAAMj+C,KAAM,CAE5B,IAAIuT,EAAOpQ,KAAK4jD,YAIhB,GAHAxzC,EAAKi+C,MAAQruD,KAAKipD,aAClBjpD,KAAK6pD,UAAUz5C,EAAKi+C,MAlmCL,GAmmCfQ,EAAM1iD,KAAKnM,KAAKgnD,WAAW52C,EAAM,4BAC5BpQ,KAAKqlD,IAAIvK,EAAMS,OAAU,OAAOsT,EAEvC,GAAI7uD,KAAKsB,OAASw5C,EAAMgC,KAAM,CAC5B,IAAIiS,EAAS/uD,KAAK4jD,YAMlB,OALA5jD,KAAK2J,OACL3J,KAAKwlD,iBAAiB,MACtBuJ,EAAOV,MAAQruD,KAAKipD,aACpBjpD,KAAK6pD,UAAUkF,EAAOV,MA3mCP,GA4mCfQ,EAAM1iD,KAAKnM,KAAKgnD,WAAW+H,EAAQ,6BAC5BF,EAGT,IADA7uD,KAAKgmD,OAAOlL,EAAMK,SACVn7C,KAAKqlD,IAAIvK,EAAMM,SAAS,CAC9B,GAAK32B,EAGIA,GAAQ,OADf,GADAzkB,KAAKgmD,OAAOlL,EAAMS,OACdv7C,KAAK6lD,mBAAmB/K,EAAMM,QAAW,MAG/C,IAAI4T,EAAShvD,KAAK4jD,YAClBoL,EAAOC,SAAWjvD,KAAKipD,YAAW,GAC9BjpD,KAAKulD,cAAc,MACrByJ,EAAOX,MAAQruD,KAAKipD,cAEpBjpD,KAAKouD,gBAAgBY,EAAOC,UAC5BD,EAAOX,MAAQW,EAAOC,UAExBjvD,KAAK6pD,UAAUmF,EAAOX,MA9nCP,GA+nCfQ,EAAM1iD,KAAKnM,KAAKgnD,WAAWgI,EAAQ,oBAErC,OAAOH,GAITjI,GAAKG,uBAAyB,SAASmI,GACrC,IAAK,IAAI5yD,EAAI,EAAGA,EAAI4yD,EAAW7rD,QAAUrD,KAAKmvD,qBAAqBD,EAAW5yD,MAAOA,EACnF4yD,EAAW5yD,GAAG8yD,UAAYF,EAAW5yD,GAAGqqD,WAAW1qC,IAAIsD,MAAM,GAAI,IAGrEqnC,GAAKuI,qBAAuB,SAAStD,GACnC,MACqB,wBAAnBA,EAAUvqD,MACoB,YAA9BuqD,EAAUlF,WAAWrlD,MACiB,kBAA/BuqD,EAAUlF,WAAWppD,QAEK,MAAhCyC,KAAKggD,MAAM6L,EAAU7nD,QAAmD,MAAhChE,KAAKggD,MAAM6L,EAAU7nD,SAIlE,IAAIqrD,GAAO5N,GAAOvjD,UAKlBmxD,GAAKzF,aAAe,SAASx5C,EAAMk/C,EAAWnJ,GAC5C,GAAInmD,KAAK4N,QAAQsyC,aAAe,GAAK9vC,EACnC,OAAQA,EAAK9O,MACb,IAAK,aACCtB,KAAKwjD,SAAyB,UAAdpzC,EAAKvT,MACrBmD,KAAKimD,MAAM71C,EAAKpM,MAAO,6DAC3B,MAEF,IAAK,gBACL,IAAK,eACL,IAAK,cACH,MAEF,IAAK,mBACHoM,EAAK9O,KAAO,gBACR6kD,GAA0BnmD,KAAKkmD,mBAAmBC,GAAwB,GAC9E,IAAK,IAAI7pD,EAAI,EAAGs8B,EAAOxoB,EAAK6wB,WAAY3kC,EAAIs8B,EAAKv1B,OAAQ/G,GAAK,EAAG,CAC/D,IAAIie,EAAOqe,EAAKt8B,GAElB0D,KAAK4pD,aAAarvC,EAAM+0C,GAON,gBAAd/0C,EAAKjZ,MACmB,iBAAvBiZ,EAAK8vC,SAAS/oD,MAAkD,kBAAvBiZ,EAAK8vC,SAAS/oD,MAExDtB,KAAKimD,MAAM1rC,EAAK8vC,SAASrmD,MAAO,oBAGpC,MAEF,IAAK,WAEe,SAAdoM,EAAK82C,MAAmBlnD,KAAKimD,MAAM71C,EAAKvS,IAAImG,MAAO,iDACvDhE,KAAK4pD,aAAax5C,EAAK7S,MAAO+xD,GAC9B,MAEF,IAAK,kBACHl/C,EAAK9O,KAAO,eACR6kD,GAA0BnmD,KAAKkmD,mBAAmBC,GAAwB,GAC9EnmD,KAAKuvD,iBAAiBn/C,EAAKs+C,SAAUY,GACrC,MAEF,IAAK,gBACHl/C,EAAK9O,KAAO,cACZtB,KAAK4pD,aAAax5C,EAAKi6C,SAAUiF,GACN,sBAAvBl/C,EAAKi6C,SAAS/oD,MACdtB,KAAKimD,MAAM71C,EAAKi6C,SAASrmD,MAAO,6CACpC,MAEF,IAAK,uBACmB,MAAlBoM,EAAKmtB,UAAoBv9B,KAAKimD,MAAM71C,EAAKm7C,KAAK3nD,IAAK,+DACvDwM,EAAK9O,KAAO,2BACL8O,EAAKmtB,SACZv9B,KAAK4pD,aAAax5C,EAAKm7C,KAAM+D,GAG/B,IAAK,oBACH,MAEF,IAAK,0BACHtvD,KAAK4pD,aAAax5C,EAAKu2C,WAAY2I,EAAWnJ,GAC9C,MAEF,IAAK,kBACHnmD,KAAKomD,iBAAiBh2C,EAAKpM,MAAO,qDAClC,MAEF,IAAK,mBACH,IAAKsrD,EAAa,MAEpB,QACEtvD,KAAKimD,MAAM71C,EAAKpM,MAAO,4BAEhBmiD,GAA0BnmD,KAAKkmD,mBAAmBC,GAAwB,GACrF,OAAO/1C,GAKTi/C,GAAKE,iBAAmB,SAASC,EAAUF,GAEzC,IADA,IAAI1rD,EAAM4rD,EAASnsD,OACV/G,EAAI,EAAGA,EAAIsH,EAAKtH,IAAK,CAC5B,IAAIqyD,EAAMa,EAASlzD,GACfqyD,GAAO3uD,KAAK4pD,aAAa+E,EAAKW,GAEpC,GAAI1rD,EAAK,CACP,IAAI2qB,EAAOihC,EAAS5rD,EAAM,GACO,IAA7B5D,KAAK4N,QAAQsyC,aAAqBoP,GAAa/gC,GAAsB,gBAAdA,EAAKjtB,MAAiD,eAAvBitB,EAAK87B,SAAS/oD,MACpGtB,KAAKylD,WAAWl3B,EAAK87B,SAASrmD,OAEpC,OAAOwrD,GAKTH,GAAKI,YAAc,SAAStJ,GAC1B,IAAI/1C,EAAOpQ,KAAK4jD,YAGhB,OAFA5jD,KAAK2J,OACLyG,EAAKi6C,SAAWrqD,KAAKyrD,kBAAiB,EAAOtF,GACtCnmD,KAAKgnD,WAAW52C,EAAM,kBAG/Bi/C,GAAKK,iBAAmB,WACtB,IAAIt/C,EAAOpQ,KAAK4jD,YAShB,OARA5jD,KAAK2J,OAG4B,IAA7B3J,KAAK4N,QAAQsyC,aAAqBlgD,KAAKsB,OAASw5C,EAAMj+C,MACtDmD,KAAKylD,aAETr1C,EAAKi6C,SAAWrqD,KAAK6qD,mBAEd7qD,KAAKgnD,WAAW52C,EAAM,gBAK/Bi/C,GAAKxE,iBAAmB,WACtB,GAAI7qD,KAAK4N,QAAQsyC,aAAe,EAC9B,OAAQlgD,KAAKsB,MACb,KAAKw5C,EAAMG,SACT,IAAI7qC,EAAOpQ,KAAK4jD,YAGhB,OAFA5jD,KAAK2J,OACLyG,EAAKs+C,SAAW1uD,KAAKqsD,iBAAiBvR,EAAMI,UAAU,GAAM,GACrDl7C,KAAKgnD,WAAW52C,EAAM,gBAE/B,KAAK0qC,EAAMK,OACT,OAAOn7C,KAAK2vD,UAAS,GAGzB,OAAO3vD,KAAKipD,cAGdoG,GAAKhD,iBAAmB,SAASuD,EAAOC,EAAYC,GAElD,IADA,IAAIC,EAAO,GAAItrC,GAAQ,GACfzkB,KAAKqlD,IAAIuK,IAGf,GAFInrC,EAASA,GAAQ,EACdzkB,KAAKgmD,OAAOlL,EAAMS,OACrBsU,GAAc7vD,KAAKsB,OAASw5C,EAAMS,MACpCwU,EAAK5jD,KAAK,UACL,IAAI2jD,GAAsB9vD,KAAK6lD,mBAAmB+J,GACvD,MACK,GAAI5vD,KAAKsB,OAASw5C,EAAMkB,SAAU,CACvC,IAAIgU,EAAOhwD,KAAK0vD,mBAChB1vD,KAAKiwD,qBAAqBD,GAC1BD,EAAK5jD,KAAK6jD,GACNhwD,KAAKsB,OAASw5C,EAAMS,OAASv7C,KAAKimD,MAAMjmD,KAAKgE,MAAO,iDACxDhE,KAAKgmD,OAAO4J,GACZ,MAEA,IAAIM,EAAOlwD,KAAKmwD,kBAAkBnwD,KAAKgE,MAAOhE,KAAKohD,UACnDphD,KAAKiwD,qBAAqBC,GAC1BH,EAAK5jD,KAAK+jD,GAGd,OAAOH,GAGTV,GAAKY,qBAAuB,SAAS93C,GACnC,OAAOA,GAKTk3C,GAAKc,kBAAoB,SAASzO,EAAUN,EAAUmK,GAEpD,GADAA,EAAOA,GAAQvrD,KAAK6qD,mBAChB7qD,KAAK4N,QAAQsyC,YAAc,IAAMlgD,KAAKqlD,IAAIvK,EAAM3oB,IAAO,OAAOo5B,EAClE,IAAIn7C,EAAOpQ,KAAKktD,YAAYxL,EAAUN,GAGtC,OAFAhxC,EAAKm7C,KAAOA,EACZn7C,EAAKo7C,MAAQxrD,KAAKyrD,mBACXzrD,KAAKgnD,WAAW52C,EAAM,sBAU/Bi/C,GAAKxF,UAAY,SAASnD,EAAM0J,EAAaC,GAG3C,YAFqB,IAAhBD,IAAyBA,EAp1ChB,GAs1CN1J,EAAKplD,MACb,IAAK,aAr1CY,IAs1CX8uD,GAA8C,QAAd1J,EAAK7pD,MACrCmD,KAAKomD,iBAAiBM,EAAK1iD,MAAO,+CAClChE,KAAKisC,QAAUjsC,KAAK8hD,wBAAwB/nC,KAAK2sC,EAAK7pD,OACtDmD,KAAKomD,iBAAiBM,EAAK1iD,OAAQosD,EAAc,WAAa,iBAAmB1J,EAAK7pD,KAAO,mBAC7FwzD,IACE/vD,EAAI+vD,EAAc3J,EAAK7pD,OACvBmD,KAAKomD,iBAAiBM,EAAK1iD,MAAO,uBACtCqsD,EAAa3J,EAAK7pD,OAAQ,GA/1ChB,IAi2CRuzD,GA51CW,IA41CkBA,GAAgCpwD,KAAKswD,YAAY5J,EAAK7pD,KAAMuzD,EAAa1J,EAAK1iD,OAC/G,MAEF,IAAK,kBACHhE,KAAKomD,iBAAiBM,EAAK1iD,MAAO,qDAClC,MAEF,IAAK,mBACCosD,GAAepwD,KAAKomD,iBAAiBM,EAAK1iD,MAAO,6BACrD,MAEF,IAAK,gBACH,IAAK,IAAI1H,EAAI,EAAGs8B,EAAO8tB,EAAKzlB,WAAY3kC,EAAIs8B,EAAKv1B,OAAQ/G,GAAK,EAC5D,CACF,IAAIie,EAAOqe,EAAKt8B,GAEhB0D,KAAK6pD,UAAUtvC,EAAM61C,EAAaC,GAElC,MAEF,IAAK,WAEHrwD,KAAK6pD,UAAUnD,EAAKnpD,MAAO6yD,EAAaC,GACxC,MAEF,IAAK,eACH,IAAK,IAAIrF,EAAM,EAAGyD,EAAS/H,EAAKgI,SAAU1D,EAAMyD,EAAOprD,OAAQ2nD,GAAO,EAAG,CACvE,IAAIkF,EAAOzB,EAAOzD,GAEhBkF,GAAQlwD,KAAK6pD,UAAUqG,EAAME,EAAaC,GAE9C,MAEF,IAAK,oBACHrwD,KAAK6pD,UAAUnD,EAAK6E,KAAM6E,EAAaC,GACvC,MAEF,IAAK,cACHrwD,KAAK6pD,UAAUnD,EAAK2D,SAAU+F,EAAaC,GAC3C,MAEF,IAAK,0BACHrwD,KAAK6pD,UAAUnD,EAAKC,WAAYyJ,EAAaC,GAC7C,MAEF,QACErwD,KAAKimD,MAAMS,EAAK1iD,OAAQosD,EAAc,UAAY,gBAAkB,aAMxE,IAAIG,GAAO9O,GAAOvjD,UAOlBqyD,GAAKC,eAAiB,SAASj2C,EAAMk2C,EAAUtK,GAC7C,KAAInmD,KAAK4N,QAAQsyC,aAAe,GAAmB,kBAAd3lC,EAAKjZ,SAEtCtB,KAAK4N,QAAQsyC,aAAe,IAAM3lC,EAAK0yC,UAAY1yC,EAAK3L,QAAU2L,EAAKm2C,YAA3E,CAEA,IACI7zD,EADAgB,EAAM0c,EAAK1c,IAEf,OAAQA,EAAIyD,MACZ,IAAK,aAAczE,EAAOgB,EAAIhB,KAAM,MACpC,IAAK,UAAWA,EAAOgL,OAAOhK,EAAIN,OAAQ,MAC1C,QAAS,OAET,IAAI2pD,EAAO3sC,EAAK2sC,KAChB,GAAIlnD,KAAK4N,QAAQsyC,aAAe,EACjB,cAATrjD,GAAiC,SAATqqD,IACtBuJ,EAASE,QACPxK,EACEA,EAAuBhB,YAAc,IACrCgB,EAAuBhB,YAActnD,EAAImG,OAEtChE,KAAKomD,iBAAiBvoD,EAAImG,MAAO,uCAE5CysD,EAASE,OAAQ,OATrB,CAcA,IAAIj0C,EAAQ+zC,EADZ5zD,EAAO,IAAMA,GAEb,GAAI6f,GAEW,SAATwqC,EACalnD,KAAKisC,QAAUvvB,EAAMitC,MAAQjtC,EAAMvf,KAAOuf,EAAMlD,IAEhDkD,EAAMitC,MAAQjtC,EAAMwqC,KAGjClnD,KAAKomD,iBAAiBvoD,EAAImG,MAAO,iCAErC0Y,EAAQ+zC,EAAS5zD,GAAQ,CACvB8sD,MAAM,EACNxsD,KAAK,EACLqc,KAAK,GAGTkD,EAAMwqC,IAAQ,KAkBhBqJ,GAAK7L,gBAAkB,SAASkM,EAAMzK,GACpC,IAAIzE,EAAW1hD,KAAKgE,MAAOo9C,EAAWphD,KAAKohD,SACvCsF,EAAO1mD,KAAKyrD,iBAAiBmF,EAAMzK,GACvC,GAAInmD,KAAKsB,OAASw5C,EAAMS,MAAO,CAC7B,IAAInrC,EAAOpQ,KAAKktD,YAAYxL,EAAUN,GAEtC,IADAhxC,EAAKygD,YAAc,CAACnK,GACb1mD,KAAKqlD,IAAIvK,EAAMS,QAAUnrC,EAAKygD,YAAY1kD,KAAKnM,KAAKyrD,iBAAiBmF,EAAMzK,IAClF,OAAOnmD,KAAKgnD,WAAW52C,EAAM,sBAE/B,OAAOs2C,GAMT6J,GAAK9E,iBAAmB,SAASmF,EAAMzK,EAAwB2K,GAC7D,GAAI9wD,KAAKslD,aAAa,SAAU,CAC9B,GAAItlD,KAAKujD,YAAe,OAAOvjD,KAAK+wD,WAAWH,GAGxC5wD,KAAKwiD,aAAc,EAG5B,IAAIwO,GAAyB,EAAOC,GAAkB,EAAGC,GAAoB,EACzE/K,GACF8K,EAAiB9K,EAAuBlB,oBACxCiM,EAAmB/K,EAAuBnB,cAC1CmB,EAAuBlB,oBAAsBkB,EAAuBnB,eAAiB,IAErFmB,EAAyB,IAAIrB,GAC7BkM,GAAyB,GAG3B,IAAItP,EAAW1hD,KAAKgE,MAAOo9C,EAAWphD,KAAKohD,SACvCphD,KAAKsB,OAASw5C,EAAMO,QAAUr7C,KAAKsB,OAASw5C,EAAMj+C,OAClDmD,KAAK2iD,iBAAmB3iD,KAAKgE,OACjC,IAAIunD,EAAOvrD,KAAKmxD,sBAAsBP,EAAMzK,GAE5C,GADI2K,IAAkBvF,EAAOuF,EAAer0D,KAAKuD,KAAMurD,EAAM7J,EAAUN,IACnEphD,KAAKsB,KAAKi5C,SAAU,CACtB,IAAInqC,EAAOpQ,KAAKktD,YAAYxL,EAAUN,GAWtC,OAVAhxC,EAAKmtB,SAAWv9B,KAAKzC,MACrB6S,EAAKm7C,KAAOvrD,KAAKsB,OAASw5C,EAAM3oB,GAAKnyB,KAAK4pD,aAAa2B,GAAM,EAAOpF,GAA0BoF,EACzFyF,IACH7K,EAAuBlB,oBAAsBkB,EAAuBnB,cAAgBmB,EAAuBhB,aAAe,GAExHgB,EAAuBpB,iBAAmB30C,EAAKm7C,KAAKvnD,QACpDmiD,EAAuBpB,iBAAmB,GAC9C/kD,KAAK6pD,UAAU0B,GACfvrD,KAAK2J,OACLyG,EAAKo7C,MAAQxrD,KAAKyrD,iBAAiBmF,GAC5B5wD,KAAKgnD,WAAW52C,EAAM,wBAM/B,OAJM4gD,GAA0BhxD,KAAKsmD,sBAAsBH,GAAwB,GAE/E8K,GAAkB,IAAK9K,EAAuBlB,oBAAsBgM,GACpEC,GAAoB,IAAK/K,EAAuBnB,cAAgBkM,GAC7D3F,GAKTgF,GAAKY,sBAAwB,SAASP,EAAMzK,GAC1C,IAAIzE,EAAW1hD,KAAKgE,MAAOo9C,EAAWphD,KAAKohD,SACvCsF,EAAO1mD,KAAKoxD,aAAaR,EAAMzK,GACnC,GAAInmD,KAAKsmD,sBAAsBH,GAA2B,OAAOO,EACjE,GAAI1mD,KAAKqlD,IAAIvK,EAAMa,UAAW,CAC5B,IAAIvrC,EAAOpQ,KAAKktD,YAAYxL,EAAUN,GAKtC,OAJAhxC,EAAK2J,KAAO2sC,EACZt2C,EAAK+5C,WAAanqD,KAAKyrD,mBACvBzrD,KAAKgmD,OAAOlL,EAAMW,OAClBrrC,EAAKg6C,UAAYpqD,KAAKyrD,iBAAiBmF,GAChC5wD,KAAKgnD,WAAW52C,EAAM,yBAE/B,OAAOs2C,GAKT6J,GAAKa,aAAe,SAASR,EAAMzK,GACjC,IAAIzE,EAAW1hD,KAAKgE,MAAOo9C,EAAWphD,KAAKohD,SACvCsF,EAAO1mD,KAAKqxD,gBAAgBlL,GAAwB,GACxD,OAAInmD,KAAKsmD,sBAAsBH,IACxBO,EAAK1iD,QAAU09C,GAA0B,4BAAdgF,EAAKplD,KAD0BolD,EACkB1mD,KAAKsxD,YAAY5K,EAAMhF,EAAUN,GAAW,EAAGwP,IASpIL,GAAKe,YAAc,SAAS/F,EAAMgG,EAAcC,EAAcC,EAASb,GACrE,IAAIjW,EAAO36C,KAAKsB,KAAKm5C,MACrB,GAAY,MAARE,KAAkBiW,GAAQ5wD,KAAKsB,OAASw5C,EAAM+D,MAC5ClE,EAAO8W,EAAS,CAClB,IAAIC,EAAU1xD,KAAKsB,OAASw5C,EAAMsB,WAAap8C,KAAKsB,OAASw5C,EAAMuB,WAC/DY,EAAWj9C,KAAKsB,OAASw5C,EAAMmC,SAC/BA,IAGFtC,EAAOG,EAAMuB,WAAW5B,OAE1B,IAAI3L,EAAK9uC,KAAKzC,MACdyC,KAAK2J,OACL,IAAI+3C,EAAW1hD,KAAKgE,MAAOo9C,EAAWphD,KAAKohD,SACvCoK,EAAQxrD,KAAKsxD,YAAYtxD,KAAKqxD,gBAAgB,MAAM,GAAQ3P,EAAUN,EAAUzG,EAAMiW,GACtFxgD,EAAOpQ,KAAK2xD,YAAYJ,EAAcC,EAAcjG,EAAMC,EAAO1c,EAAI4iB,GAAWzU,GAIpF,OAHKyU,GAAW1xD,KAAKsB,OAASw5C,EAAMmC,UAAcA,IAAaj9C,KAAKsB,OAASw5C,EAAMsB,WAAap8C,KAAKsB,OAASw5C,EAAMuB,cAClHr8C,KAAKomD,iBAAiBpmD,KAAKgE,MAAO,4FAE7BhE,KAAKsxD,YAAYlhD,EAAMmhD,EAAcC,EAAcC,EAASb,GAGvE,OAAOrF,GAGTgF,GAAKoB,YAAc,SAASjQ,EAAUN,EAAUmK,EAAMC,EAAO1c,EAAI4iB,GAC/D,IAAIthD,EAAOpQ,KAAKktD,YAAYxL,EAAUN,GAItC,OAHAhxC,EAAKm7C,KAAOA,EACZn7C,EAAKmtB,SAAWuR,EAChB1+B,EAAKo7C,MAAQA,EACNxrD,KAAKgnD,WAAW52C,EAAMshD,EAAU,oBAAsB,qBAK/DnB,GAAKc,gBAAkB,SAASlL,EAAwByL,GACtD,IAAqDlL,EAAjDhF,EAAW1hD,KAAKgE,MAAOo9C,EAAWphD,KAAKohD,SAC3C,GAAIphD,KAAKslD,aAAa,WAAatlD,KAAKwjD,UAAaxjD,KAAKsjD,YAActjD,KAAK4N,QAAQ6yC,2BACnFiG,EAAO1mD,KAAK6xD,aACZD,GAAW,OACN,GAAI5xD,KAAKsB,KAAKkF,OAAQ,CAC3B,IAAI4J,EAAOpQ,KAAK4jD,YAAayH,EAASrrD,KAAKsB,OAASw5C,EAAMqB,OAC1D/rC,EAAKmtB,SAAWv9B,KAAKzC,MACrB6S,EAAK5J,QAAS,EACdxG,KAAK2J,OACLyG,EAAKi6C,SAAWrqD,KAAKqxD,gBAAgB,MAAM,GAC3CrxD,KAAKsmD,sBAAsBH,GAAwB,GAC/CkF,EAAUrrD,KAAK6pD,UAAUz5C,EAAKi6C,UACzBrqD,KAAKisC,QAA4B,WAAlB77B,EAAKmtB,UACG,eAAvBntB,EAAKi6C,SAAS/oD,KACnBtB,KAAKomD,iBAAiBh2C,EAAKpM,MAAO,0CAC/B4tD,GAAW,EAClBlL,EAAO1mD,KAAKgnD,WAAW52C,EAAMi7C,EAAS,mBAAqB,uBACtD,CAEL,GADA3E,EAAO1mD,KAAKytD,oBAAoBtH,GAC5BnmD,KAAKsmD,sBAAsBH,GAA2B,OAAOO,EACjE,KAAO1mD,KAAKsB,KAAKk5C,UAAYx6C,KAAK0lD,sBAAsB,CACtD,IAAIqJ,EAAS/uD,KAAKktD,YAAYxL,EAAUN,GACxC2N,EAAOxxB,SAAWv9B,KAAKzC,MACvBwxD,EAAOvoD,QAAS,EAChBuoD,EAAO1E,SAAW3D,EAClB1mD,KAAK6pD,UAAUnD,GACf1mD,KAAK2J,OACL+8C,EAAO1mD,KAAKgnD,WAAW+H,EAAQ,qBAInC,OAAK6C,GAAY5xD,KAAKqlD,IAAIvK,EAAMkC,UACrBh9C,KAAK2xD,YAAYjQ,EAAUN,EAAUsF,EAAM1mD,KAAKqxD,gBAAgB,MAAM,GAAQ,MAAM,GAEpF3K,GAKb6J,GAAK9C,oBAAsB,SAAStH,GAClC,IAAIzE,EAAW1hD,KAAKgE,MAAOo9C,EAAWphD,KAAKohD,SACvCsF,EAAO1mD,KAAK4tD,cAAczH,GAC9B,GAAkB,4BAAdO,EAAKplD,MAA+F,MAAzDtB,KAAKggD,MAAMzgC,MAAMvf,KAAKqiD,aAAcriD,KAAKsiD,YACpF,OAAOoE,EACX,IAAI/nD,EAASqB,KAAK8xD,gBAAgBpL,EAAMhF,EAAUN,GAKlD,OAJI+E,GAA0C,qBAAhBxnD,EAAO2C,OAC/B6kD,EAAuBlB,qBAAuBtmD,EAAOqF,QAASmiD,EAAuBlB,qBAAuB,GAC5GkB,EAAuBjB,mBAAqBvmD,EAAOqF,QAASmiD,EAAuBjB,mBAAqB,IAEvGvmD,GAGT4xD,GAAKuB,gBAAkB,SAASntD,EAAM+8C,EAAUN,EAAU2Q,GAMxD,IALA,IAAIC,EAAkBhyD,KAAK4N,QAAQsyC,aAAe,GAAmB,eAAdv7C,EAAKrD,MAAuC,UAAdqD,EAAK9H,MACtFmD,KAAKsiD,aAAe39C,EAAKf,MAAQ5D,KAAK0lD,sBAAwB/gD,EAAKf,IAAMe,EAAKX,QAAU,GACxFhE,KAAK2iD,mBAAqBh+C,EAAKX,MAC/BiuD,GAAkB,IAET,CACX,IAAIpzD,EAAUmB,KAAKkyD,eAAevtD,EAAM+8C,EAAUN,EAAU2Q,EAASC,EAAiBC,GAGtF,GADIpzD,EAAQszD,WAAYF,GAAkB,GACtCpzD,IAAY8F,GAAyB,4BAAjB9F,EAAQyC,KAAoC,CAClE,GAAI2wD,EAAiB,CACnB,IAAIG,EAAYpyD,KAAKktD,YAAYxL,EAAUN,GAC3CgR,EAAUzL,WAAa9nD,EACvBA,EAAUmB,KAAKgnD,WAAWoL,EAAW,mBAEvC,OAAOvzD,EAGT8F,EAAO9F,IAIX0xD,GAAK2B,eAAiB,SAASvtD,EAAM+8C,EAAUN,EAAU2Q,EAASC,EAAiBC,GACjF,IAAII,EAAoBryD,KAAK4N,QAAQsyC,aAAe,GAChDiS,EAAWE,GAAqBryD,KAAKqlD,IAAIvK,EAAMc,aAC/CmW,GAAWI,GAAYnyD,KAAKimD,MAAMjmD,KAAKqiD,aAAc,oEAEzD,IAAI4K,EAAWjtD,KAAKqlD,IAAIvK,EAAMG,UAC9B,GAAIgS,GAAakF,GAAYnyD,KAAKsB,OAASw5C,EAAMO,QAAUr7C,KAAKsB,OAASw5C,EAAMmB,WAAcj8C,KAAKqlD,IAAIvK,EAAMY,KAAM,CAChH,IAAItrC,EAAOpQ,KAAKktD,YAAYxL,EAAUN,GACtChxC,EAAKpS,OAAS2G,EACdyL,EAAKnS,SAAWgvD,EAAWjtD,KAAK0kD,kBAAoB1kD,KAAKipD,WAA0C,UAA/BjpD,KAAK4N,QAAQ0yC,eACjFlwC,EAAK68C,WAAaA,EACdA,GAAYjtD,KAAKgmD,OAAOlL,EAAMI,UAC9BmX,IACFjiD,EAAK+hD,SAAWA,GAElBxtD,EAAO3E,KAAKgnD,WAAW52C,EAAM,yBACxB,IAAK2hD,GAAW/xD,KAAKqlD,IAAIvK,EAAMO,QAAS,CAC7C,IAAI8K,EAAyB,IAAIrB,GAAqBkH,EAAchsD,KAAK4iD,SAAUqJ,EAAcjsD,KAAK6iD,SAAUqJ,EAAmBlsD,KAAK8iD,cACxI9iD,KAAK4iD,SAAW,EAChB5iD,KAAK6iD,SAAW,EAChB7iD,KAAK8iD,cAAgB,EACrB,IAAI0M,EAAWxvD,KAAKsyD,cAAcxX,EAAMQ,OAAQt7C,KAAK4N,QAAQsyC,aAAe,GAAG,EAAOiG,GACtF,GAAI6L,IAAoBG,IAAanyD,KAAK0lD,sBAAwB1lD,KAAKqlD,IAAIvK,EAAMe,OAQ/E,OAPA77C,KAAKkmD,mBAAmBC,GAAwB,GAChDnmD,KAAKwmD,iCACDxmD,KAAK8iD,cAAgB,GACrB9iD,KAAKimD,MAAMjmD,KAAK8iD,cAAe,6DACnC9iD,KAAK4iD,SAAWoJ,EAChBhsD,KAAK6iD,SAAWoJ,EAChBjsD,KAAK8iD,cAAgBoJ,EACdlsD,KAAKuyD,qBAAqBvyD,KAAKktD,YAAYxL,EAAUN,GAAWoO,GAAU,GAEnFxvD,KAAKsmD,sBAAsBH,GAAwB,GACnDnmD,KAAK4iD,SAAWoJ,GAAehsD,KAAK4iD,SACpC5iD,KAAK6iD,SAAWoJ,GAAejsD,KAAK6iD,SACpC7iD,KAAK8iD,cAAgBoJ,GAAoBlsD,KAAK8iD,cAC9C,IAAIiM,EAAS/uD,KAAKktD,YAAYxL,EAAUN,GACxC2N,EAAOyD,OAAS7tD,EAChBoqD,EAAOjkD,UAAY0kD,EACf6C,IACFtD,EAAOoD,SAAWA,GAEpBxtD,EAAO3E,KAAKgnD,WAAW+H,EAAQ,uBAC1B,GAAI/uD,KAAKsB,OAASw5C,EAAMmB,UAAW,EACpCkW,GAAYF,IACdjyD,KAAKimD,MAAMjmD,KAAKgE,MAAO,6EAEzB,IAAIgrD,EAAShvD,KAAKktD,YAAYxL,EAAUN,GACxC4N,EAAO7gB,IAAMxpC,EACbqqD,EAAOyD,MAAQzyD,KAAK0yD,cAAc,CAACC,UAAU,IAC7ChuD,EAAO3E,KAAKgnD,WAAWgI,EAAQ,4BAEjC,OAAOrqD,GAQT4rD,GAAK3C,cAAgB,SAASzH,GAGxBnmD,KAAKsB,OAASw5C,EAAMiC,OAAS/8C,KAAK4yD,aAEtC,IAAIxiD,EAAMyiD,EAAa7yD,KAAK2iD,mBAAqB3iD,KAAKgE,MACtD,OAAQhE,KAAKsB,MACb,KAAKw5C,EAAMjR,OAeT,OAdK7pC,KAAKyjD,YACNzjD,KAAKimD,MAAMjmD,KAAKgE,MAAO,oCAC3BoM,EAAOpQ,KAAK4jD,YACZ5jD,KAAK2J,OACD3J,KAAKsB,OAASw5C,EAAMO,QAAWr7C,KAAK0jD,kBACpC1jD,KAAKimD,MAAM71C,EAAKpM,MAAO,kDAOvBhE,KAAKsB,OAASw5C,EAAMY,KAAO17C,KAAKsB,OAASw5C,EAAMG,UAAYj7C,KAAKsB,OAASw5C,EAAMO,QAC/Er7C,KAAKylD,aACFzlD,KAAKgnD,WAAW52C,EAAM,SAE/B,KAAK0qC,EAAMhR,MAGT,OAFA15B,EAAOpQ,KAAK4jD,YACZ5jD,KAAK2J,OACE3J,KAAKgnD,WAAW52C,EAAM,kBAE/B,KAAK0qC,EAAMj+C,KACT,IAAI6kD,EAAW1hD,KAAKgE,MAAOo9C,EAAWphD,KAAKohD,SAAUW,EAAc/hD,KAAK+hD,YACpExlC,EAAKvc,KAAKipD,YAAW,GACzB,GAAIjpD,KAAK4N,QAAQsyC,aAAe,IAAM6B,GAA2B,UAAZxlC,EAAG1f,OAAqBmD,KAAK0lD,sBAAwB1lD,KAAKqlD,IAAIvK,EAAM8C,WACrH,OAAO59C,KAAKgqD,cAAchqD,KAAKktD,YAAYxL,EAAUN,GAAW,GAAG,GAAO,GAC9E,GAAIyR,IAAe7yD,KAAK0lD,qBAAsB,CAC5C,GAAI1lD,KAAKqlD,IAAIvK,EAAMe,OACf,OAAO77C,KAAKuyD,qBAAqBvyD,KAAKktD,YAAYxL,EAAUN,GAAW,CAAC7kC,IAAK,GACjF,GAAIvc,KAAK4N,QAAQsyC,aAAe,GAAiB,UAAZ3jC,EAAG1f,MAAoBmD,KAAKsB,OAASw5C,EAAMj+C,OAASklD,EAIvF,OAHAxlC,EAAKvc,KAAKipD,YAAW,IACjBjpD,KAAK0lD,sBAAyB1lD,KAAKqlD,IAAIvK,EAAMe,QAC7C77C,KAAKylD,aACFzlD,KAAKuyD,qBAAqBvyD,KAAKktD,YAAYxL,EAAUN,GAAW,CAAC7kC,IAAK,GAGjF,OAAOA,EAET,KAAKu+B,EAAMC,OACT,IAAIx9C,EAAQyC,KAAKzC,MAGjB,OAFA6S,EAAOpQ,KAAK8yD,aAAav1D,EAAMA,QAC1Bw1D,MAAQ,CAAC/tB,QAASznC,EAAMynC,QAASgf,MAAOzmD,EAAMymD,OAC5C5zC,EAET,KAAK0qC,EAAMt+B,IAAK,KAAKs+B,EAAM5mB,OACzB,OAAOl0B,KAAK8yD,aAAa9yD,KAAKzC,OAEhC,KAAKu9C,EAAM4D,MAAO,KAAK5D,EAAM6D,MAAO,KAAK7D,EAAM8D,OAK7C,OAJAxuC,EAAOpQ,KAAK4jD,aACPrmD,MAAQyC,KAAKsB,OAASw5C,EAAM4D,MAAQ,KAAO1+C,KAAKsB,OAASw5C,EAAM6D,MACpEvuC,EAAK6L,IAAMjc,KAAKsB,KAAK64C,QACrBn6C,KAAK2J,OACE3J,KAAKgnD,WAAW52C,EAAM,WAE/B,KAAK0qC,EAAMO,OACT,IAAIr3C,EAAQhE,KAAKgE,MAAO0iD,EAAO1mD,KAAKgzD,mCAAmCH,GAOvE,OANI1M,IACEA,EAAuBlB,oBAAsB,IAAMjlD,KAAKymD,qBAAqBC,KAC7EP,EAAuBlB,oBAAsBjhD,GAC7CmiD,EAAuBjB,kBAAoB,IAC3CiB,EAAuBjB,kBAAoBlhD,IAE1C0iD,EAET,KAAK5L,EAAMG,SAIT,OAHA7qC,EAAOpQ,KAAK4jD,YACZ5jD,KAAK2J,OACLyG,EAAKs+C,SAAW1uD,KAAKsyD,cAAcxX,EAAMI,UAAU,GAAM,EAAMiL,GACxDnmD,KAAKgnD,WAAW52C,EAAM,mBAE/B,KAAK0qC,EAAMK,OACT,OAAOn7C,KAAK2vD,UAAS,EAAOxJ,GAE9B,KAAKrL,EAAM8C,UAGT,OAFAxtC,EAAOpQ,KAAK4jD,YACZ5jD,KAAK2J,OACE3J,KAAKgqD,cAAc55C,EAAM,GAElC,KAAK0qC,EAAMwD,OACT,OAAOt+C,KAAKgoD,WAAWhoD,KAAK4jD,aAAa,GAE3C,KAAK9I,EAAMuD,KACT,OAAOr+C,KAAKizD,WAEd,KAAKnY,EAAMmB,UACT,OAAOj8C,KAAK0yD,gBAEd,KAAK5X,EAAM2D,QACT,OAAIz+C,KAAK4N,QAAQsyC,aAAe,GACvBlgD,KAAKkzD,kBAELlzD,KAAKylD,aAGhB,QACEzlD,KAAKylD,eAIT8K,GAAK2C,gBAAkB,WACrB,IAAI9iD,EAAOpQ,KAAK4jD,YAIZ5jD,KAAK+hD,aAAe/hD,KAAKomD,iBAAiBpmD,KAAKgE,MAAO,qCAC1D,IAAImvD,EAAOnzD,KAAKipD,YAAW,GAE3B,OAAQjpD,KAAKsB,MACb,KAAKw5C,EAAMO,OACT,OAAOr7C,KAAKozD,mBAAmBhjD,GACjC,KAAK0qC,EAAMY,IAET,OADAtrC,EAAK+iD,KAAOA,EACLnzD,KAAKqzD,gBAAgBjjD,GAC9B,QACEpQ,KAAKylD,eAIT8K,GAAK6C,mBAAqB,SAAShjD,GAOjC,GANApQ,KAAK2J,OAGLyG,EAAKuF,OAAS3V,KAAKyrD,oBAGdzrD,KAAKqlD,IAAIvK,EAAMQ,QAAS,CAC3B,IAAIgY,EAAWtzD,KAAKgE,MAChBhE,KAAKqlD,IAAIvK,EAAMS,QAAUv7C,KAAKqlD,IAAIvK,EAAMQ,QAC1Ct7C,KAAKomD,iBAAiBkN,EAAU,6CAEhCtzD,KAAKylD,WAAW6N,GAIpB,OAAOtzD,KAAKgnD,WAAW52C,EAAM,qBAG/BmgD,GAAK8C,gBAAkB,SAASjjD,GAC9BpQ,KAAK2J,OAEL,IAAIo4C,EAAc/hD,KAAK+hD,YAUvB,OATA3xC,EAAKnS,SAAW+B,KAAKipD,YAAW,GAEL,SAAvB74C,EAAKnS,SAASpB,MACdmD,KAAKomD,iBAAiBh2C,EAAKnS,SAAS+F,MAAO,4DAC3C+9C,GACA/hD,KAAKomD,iBAAiBh2C,EAAKpM,MAAO,qDACN,WAA5BhE,KAAK4N,QAAQuyC,YACbngD,KAAKomD,iBAAiBh2C,EAAKpM,MAAO,6CAE/BhE,KAAKgnD,WAAW52C,EAAM,iBAG/BmgD,GAAKuC,aAAe,SAASv1D,GAC3B,IAAI6S,EAAOpQ,KAAK4jD,YAKhB,OAJAxzC,EAAK7S,MAAQA,EACb6S,EAAK6L,IAAMjc,KAAKggD,MAAMzgC,MAAMvf,KAAKgE,MAAOhE,KAAK4D,KACI,MAA7CwM,EAAK6L,IAAI6R,WAAW1d,EAAK6L,IAAI5Y,OAAS,KAAc+M,EAAKmjD,OAASnjD,EAAK6L,IAAIsD,MAAM,GAAI,GAAG1B,QAAQ,KAAM,KAC1G7d,KAAK2J,OACE3J,KAAKgnD,WAAW52C,EAAM,YAG/BmgD,GAAKpH,qBAAuB,WAC1BnpD,KAAKgmD,OAAOlL,EAAMO,QAClB,IAAI3mB,EAAM10B,KAAK0kD,kBAEf,OADA1kD,KAAKgmD,OAAOlL,EAAMQ,QACX5mB,GAGT67B,GAAKyC,mCAAqC,SAASH,GACjD,IAAqDn+B,EAAjDgtB,EAAW1hD,KAAKgE,MAAOo9C,EAAWphD,KAAKohD,SAAe0O,EAAqB9vD,KAAK4N,QAAQsyC,aAAe,EAC3G,GAAIlgD,KAAK4N,QAAQsyC,aAAe,EAAG,CACjClgD,KAAK2J,OAEL,IAEgH6pD,EAF5GC,EAAgBzzD,KAAKgE,MAAO0vD,EAAgB1zD,KAAKohD,SACjDoO,EAAW,GAAI/qC,GAAQ,EAAMkvC,GAAc,EAC3CxN,EAAyB,IAAIrB,GAAqBkH,EAAchsD,KAAK4iD,SAAUqJ,EAAcjsD,KAAK6iD,SAItG,IAHA7iD,KAAK4iD,SAAW,EAChB5iD,KAAK6iD,SAAW,EAET7iD,KAAKsB,OAASw5C,EAAMQ,QAAQ,CAEjC,GADA72B,EAAQA,GAAQ,EAAQzkB,KAAKgmD,OAAOlL,EAAMS,OACtCuU,GAAsB9vD,KAAK6lD,mBAAmB/K,EAAMQ,QAAQ,GAAO,CACrEqY,GAAc,EACd,MACK,GAAI3zD,KAAKsB,OAASw5C,EAAMkB,SAAU,CACvCwX,EAAcxzD,KAAKgE,MACnBwrD,EAASrjD,KAAKnM,KAAK4zD,eAAe5zD,KAAK0vD,qBACnC1vD,KAAKsB,OAASw5C,EAAMS,OAASv7C,KAAKimD,MAAMjmD,KAAKgE,MAAO,iDACxD,MAEAwrD,EAASrjD,KAAKnM,KAAKyrD,kBAAiB,EAAOtF,EAAwBnmD,KAAK4zD,iBAG5E,IAAIC,EAAc7zD,KAAKgE,MAAO8vD,EAAc9zD,KAAKohD,SAGjD,GAFAphD,KAAKgmD,OAAOlL,EAAMQ,QAEduX,IAAe7yD,KAAK0lD,sBAAwB1lD,KAAKqlD,IAAIvK,EAAMe,OAK7D,OAJA77C,KAAKkmD,mBAAmBC,GAAwB,GAChDnmD,KAAKwmD,iCACLxmD,KAAK4iD,SAAWoJ,EAChBhsD,KAAK6iD,SAAWoJ,EACTjsD,KAAK+zD,oBAAoBrS,EAAUN,EAAUoO,GAGjDA,EAASnsD,SAAUswD,GAAe3zD,KAAKylD,WAAWzlD,KAAKqiD,cACxDmR,GAAexzD,KAAKylD,WAAW+N,GACnCxzD,KAAKsmD,sBAAsBH,GAAwB,GACnDnmD,KAAK4iD,SAAWoJ,GAAehsD,KAAK4iD,SACpC5iD,KAAK6iD,SAAWoJ,GAAejsD,KAAK6iD,SAEhC2M,EAASnsD,OAAS,IACpBqxB,EAAM10B,KAAKktD,YAAYuG,EAAeC,IAClC7C,YAAcrB,EAClBxvD,KAAKg0D,aAAat/B,EAAK,qBAAsBm/B,EAAaC,IAE1Dp/B,EAAM86B,EAAS,QAGjB96B,EAAM10B,KAAKmpD,uBAGb,GAAInpD,KAAK4N,QAAQozC,eAAgB,CAC/B,IAAIiT,EAAMj0D,KAAKktD,YAAYxL,EAAUN,GAErC,OADA6S,EAAItN,WAAajyB,EACV10B,KAAKgnD,WAAWiN,EAAK,2BAE5B,OAAOv/B,GAIX67B,GAAKqD,eAAiB,SAASxuC,GAC7B,OAAOA,GAGTmrC,GAAKwD,oBAAsB,SAASrS,EAAUN,EAAUoO,GACtD,OAAOxvD,KAAKuyD,qBAAqBvyD,KAAKktD,YAAYxL,EAAUN,GAAWoO,IASzE,IAAI0E,GAAU,GAEd3D,GAAK0C,SAAW,WACVjzD,KAAK+hD,aAAe/hD,KAAKomD,iBAAiBpmD,KAAKgE,MAAO,kCAC1D,IAAIoM,EAAOpQ,KAAK4jD,YACZuP,EAAOnzD,KAAKipD,YAAW,GAC3B,GAAIjpD,KAAK4N,QAAQsyC,aAAe,GAAKlgD,KAAKqlD,IAAIvK,EAAMY,KAAM,CACxDtrC,EAAK+iD,KAAOA,EACZ,IAAIpR,EAAc/hD,KAAK+hD,YAQvB,OAPA3xC,EAAKnS,SAAW+B,KAAKipD,YAAW,GACL,WAAvB74C,EAAKnS,SAASpB,MACdmD,KAAKomD,iBAAiBh2C,EAAKnS,SAAS+F,MAAO,wDAC3C+9C,GACA/hD,KAAKomD,iBAAiBh2C,EAAKpM,MAAO,oDACjChE,KAAKokD,sBACNpkD,KAAKomD,iBAAiBh2C,EAAKpM,MAAO,8CAC/BhE,KAAKgnD,WAAW52C,EAAM,gBAE/B,IAAIsxC,EAAW1hD,KAAKgE,MAAOo9C,EAAWphD,KAAKohD,SAAU+S,EAAWn0D,KAAKsB,OAASw5C,EAAM2D,QAOpF,OANAruC,EAAKoiD,OAASxyD,KAAK8xD,gBAAgB9xD,KAAK4tD,gBAAiBlM,EAAUN,GAAU,GACzE+S,GAAiC,qBAArB/jD,EAAKoiD,OAAOlxD,MAC1BtB,KAAKimD,MAAMvE,EAAU,gCAEnB1hD,KAAKqlD,IAAIvK,EAAMO,QAAWjrC,EAAKtF,UAAY9K,KAAKsyD,cAAcxX,EAAMQ,OAAQt7C,KAAK4N,QAAQsyC,aAAe,GAAG,GACxG9vC,EAAKtF,UAAYopD,GACjBl0D,KAAKgnD,WAAW52C,EAAM,kBAK/BmgD,GAAK6D,qBAAuB,SAAS7U,GACnC,IAAIoT,EAAWpT,EAAIoT,SAEfzC,EAAOlwD,KAAK4jD,YAiBhB,OAhBI5jD,KAAKsB,OAASw5C,EAAMiB,iBACjB4W,GACH3yD,KAAKomD,iBAAiBpmD,KAAKgE,MAAO,oDAEpCksD,EAAK3yD,MAAQ,CACX0e,IAAKjc,KAAKzC,MACV82D,OAAQ,OAGVnE,EAAK3yD,MAAQ,CACX0e,IAAKjc,KAAKggD,MAAMzgC,MAAMvf,KAAKgE,MAAOhE,KAAK4D,KAAKia,QAAQ,SAAU,MAC9Dw2C,OAAQr0D,KAAKzC,OAGjByC,KAAK2J,OACLumD,EAAKzhC,KAAOzuB,KAAKsB,OAASw5C,EAAMmB,UACzBj8C,KAAKgnD,WAAWkJ,EAAM,oBAG/BK,GAAKmC,cAAgB,SAASnT,QACf,IAARA,IAAiBA,EAAM,IAC5B,IAAIoT,EAAWpT,EAAIoT,cAA4B,IAAbA,IAAsBA,GAAW,GAEnE,IAAIviD,EAAOpQ,KAAK4jD,YAChB5jD,KAAK2J,OACLyG,EAAKygD,YAAc,GACnB,IAAIyD,EAASt0D,KAAKo0D,qBAAqB,CAACzB,SAAUA,IAElD,IADAviD,EAAKmkD,OAAS,CAACD,IACPA,EAAO7lC,MACTzuB,KAAKsB,OAASw5C,EAAME,KAAOh7C,KAAKimD,MAAMjmD,KAAKuH,IAAK,iCACpDvH,KAAKgmD,OAAOlL,EAAMoB,cAClB9rC,EAAKygD,YAAY1kD,KAAKnM,KAAK0kD,mBAC3B1kD,KAAKgmD,OAAOlL,EAAMM,QAClBhrC,EAAKmkD,OAAOpoD,KAAKmoD,EAASt0D,KAAKo0D,qBAAqB,CAACzB,SAAUA,KAGjE,OADA3yD,KAAK2J,OACE3J,KAAKgnD,WAAW52C,EAAM,oBAG/BmgD,GAAKiE,YAAc,SAASj6C,GAC1B,OAAQA,EAAK0yC,UAA8B,eAAlB1yC,EAAK1c,IAAIyD,MAA2C,UAAlBiZ,EAAK1c,IAAIhB,OACjEmD,KAAKsB,OAASw5C,EAAMj+C,MAAQmD,KAAKsB,OAASw5C,EAAMt+B,KAAOxc,KAAKsB,OAASw5C,EAAM5mB,QAAUl0B,KAAKsB,OAASw5C,EAAMG,UAAYj7C,KAAKsB,KAAK64C,SAAYn6C,KAAK4N,QAAQsyC,aAAe,GAAKlgD,KAAKsB,OAASw5C,EAAMgC,QAChMmC,EAAUllC,KAAK/Z,KAAKggD,MAAMzgC,MAAMvf,KAAKsiD,WAAYtiD,KAAKgE,SAK3DusD,GAAKZ,SAAW,SAAS8E,EAAWtO,GAClC,IAAI/1C,EAAOpQ,KAAK4jD,YAAan/B,GAAQ,EAAMgsC,EAAW,GAGtD,IAFArgD,EAAK6wB,WAAa,GAClBjhC,KAAK2J,QACG3J,KAAKqlD,IAAIvK,EAAMM,SAAS,CAC9B,GAAK32B,EAGIA,GAAQ,OADf,GADAzkB,KAAKgmD,OAAOlL,EAAMS,OACdv7C,KAAK4N,QAAQsyC,aAAe,GAAKlgD,KAAK6lD,mBAAmB/K,EAAMM,QAAW,MAGhF,IAAI7gC,EAAOva,KAAK00D,cAAcD,EAAWtO,GACpCsO,GAAaz0D,KAAKwwD,eAAej2C,EAAMk2C,EAAUtK,GACtD/1C,EAAK6wB,WAAW90B,KAAKoO,GAEvB,OAAOva,KAAKgnD,WAAW52C,EAAMqkD,EAAY,gBAAkB,qBAG7DlE,GAAKmE,cAAgB,SAASD,EAAWtO,GACvC,IAA6BiH,EAAatD,EAASpI,EAAUN,EAAzD7mC,EAAOva,KAAK4jD,YAChB,GAAI5jD,KAAK4N,QAAQsyC,aAAe,GAAKlgD,KAAKqlD,IAAIvK,EAAMkB,UAClD,OAAIyY,GACFl6C,EAAK8vC,SAAWrqD,KAAKipD,YAAW,GAC5BjpD,KAAKsB,OAASw5C,EAAMS,OACtBv7C,KAAKimD,MAAMjmD,KAAKgE,MAAO,iDAElBhE,KAAKgnD,WAAWzsC,EAAM,iBAG3Bva,KAAKsB,OAASw5C,EAAMO,QAAU8K,IAC5BA,EAAuBlB,oBAAsB,IAC/CkB,EAAuBlB,oBAAsBjlD,KAAKgE,OAEhDmiD,EAAuBjB,kBAAoB,IAC7CiB,EAAuBjB,kBAAoBllD,KAAKgE,QAIpDuW,EAAK8vC,SAAWrqD,KAAKyrD,kBAAiB,EAAOtF,GAEzCnmD,KAAKsB,OAASw5C,EAAMS,OAAS4K,GAA0BA,EAAuBnB,cAAgB,IAChGmB,EAAuBnB,cAAgBhlD,KAAKgE,OAGvChE,KAAKgnD,WAAWzsC,EAAM,kBAE3Bva,KAAK4N,QAAQsyC,aAAe,IAC9B3lC,EAAK3L,QAAS,EACd2L,EAAKm2C,WAAY,GACb+D,GAAatO,KACfzE,EAAW1hD,KAAKgE,MAChBo9C,EAAWphD,KAAKohD,UAEbqT,IACDrH,EAAcptD,KAAKqlD,IAAIvK,EAAMgC,QAEnC,IAAIiF,EAAc/hD,KAAK+hD,YAUvB,OATA/hD,KAAKqtD,kBAAkB9yC,IAClBk6C,IAAc1S,GAAe/hD,KAAK4N,QAAQsyC,aAAe,IAAMkN,GAAeptD,KAAKw0D,YAAYj6C,IAClGuvC,GAAU,EACVsD,EAAcptD,KAAK4N,QAAQsyC,aAAe,GAAKlgD,KAAKqlD,IAAIvK,EAAMgC,MAC9D98C,KAAKqtD,kBAAkB9yC,EAAM4rC,IAE7B2D,GAAU,EAEZ9pD,KAAK20D,mBAAmBp6C,EAAMk6C,EAAWrH,EAAatD,EAASpI,EAAUN,EAAU+E,EAAwBpE,GACpG/hD,KAAKgnD,WAAWzsC,EAAM,aAG/Bg2C,GAAKoE,mBAAqB,SAASp6C,EAAMk6C,EAAWrH,EAAatD,EAASpI,EAAUN,EAAU+E,EAAwBpE,GAIpH,IAHKqL,GAAetD,IAAY9pD,KAAKsB,OAASw5C,EAAMW,OAChDz7C,KAAKylD,aAELzlD,KAAKqlD,IAAIvK,EAAMW,OACjBlhC,EAAKhd,MAAQk3D,EAAYz0D,KAAKmwD,kBAAkBnwD,KAAKgE,MAAOhE,KAAKohD,UAAYphD,KAAKyrD,kBAAiB,EAAOtF,GAC1G5rC,EAAK2sC,KAAO,YACP,GAAIlnD,KAAK4N,QAAQsyC,aAAe,GAAKlgD,KAAKsB,OAASw5C,EAAMO,OAC1DoZ,GAAaz0D,KAAKylD,aACtBlrC,EAAK2sC,KAAO,OACZ3sC,EAAK3L,QAAS,EACd2L,EAAKhd,MAAQyC,KAAKwtD,YAAYJ,EAAatD,QACtC,GAAK2K,GAAc1S,KACf/hD,KAAK4N,QAAQsyC,aAAe,IAAM3lC,EAAK0yC,UAA8B,eAAlB1yC,EAAK1c,IAAIyD,MACzC,QAAlBiZ,EAAK1c,IAAIhB,MAAoC,QAAlB0d,EAAK1c,IAAIhB,MACpCmD,KAAKsB,OAASw5C,EAAMS,OAASv7C,KAAKsB,OAASw5C,EAAMM,QAAUp7C,KAAKsB,OAASw5C,EAAM3oB,GAgBhFnyB,KAAK4N,QAAQsyC,aAAe,IAAM3lC,EAAK0yC,UAA8B,eAAlB1yC,EAAK1c,IAAIyD,OACjE8rD,GAAetD,IAAW9pD,KAAKylD,aACnCzlD,KAAKouD,gBAAgB7zC,EAAK1c,KACJ,UAAlB0c,EAAK1c,IAAIhB,MAAqBmD,KAAK8iD,gBACnC9iD,KAAK8iD,cAAgBpB,GACzBnnC,EAAK2sC,KAAO,OACRuN,EACFl6C,EAAKhd,MAAQyC,KAAKmwD,kBAAkBzO,EAAUN,EAAU7mC,EAAK1c,KACpDmC,KAAKsB,OAASw5C,EAAM3oB,IAAMg0B,GAC/BA,EAAuBpB,gBAAkB,IACzCoB,EAAuBpB,gBAAkB/kD,KAAKgE,OAClDuW,EAAKhd,MAAQyC,KAAKmwD,kBAAkBzO,EAAUN,EAAU7mC,EAAK1c,MAE7D0c,EAAKhd,MAAQgd,EAAK1c,IAEpB0c,EAAKm2C,WAAY,GACV1wD,KAAKylD,iBAhCkF,EAC1F2H,GAAetD,IAAW9pD,KAAKylD,aACnClrC,EAAK2sC,KAAO3sC,EAAK1c,IAAIhB,KACrBmD,KAAKqtD,kBAAkB9yC,GACvBA,EAAKhd,MAAQyC,KAAKwtD,aAAY,GAC9B,IAAIoH,EAA2B,QAAdr6C,EAAK2sC,KAAiB,EAAI,EAC3C,GAAI3sC,EAAKhd,MAAMgwC,OAAOlqC,SAAWuxD,EAAY,CAC3C,IAAI5wD,EAAQuW,EAAKhd,MAAMyG,MACL,QAAduW,EAAK2sC,KACLlnD,KAAKomD,iBAAiBpiD,EAAO,gCAE7BhE,KAAKomD,iBAAiBpiD,EAAO,4CAEf,QAAduW,EAAK2sC,MAAgD,gBAA9B3sC,EAAKhd,MAAMgwC,OAAO,GAAGjsC,MAC5CtB,KAAKomD,iBAAiB7rC,EAAKhd,MAAMgwC,OAAO,GAAGvpC,MAAO,mCAqB5DusD,GAAKlD,kBAAoB,SAAS9yC,GAChC,GAAIva,KAAK4N,QAAQsyC,aAAe,EAAG,CACjC,GAAIlgD,KAAKqlD,IAAIvK,EAAMG,UAIjB,OAHA1gC,EAAK0yC,UAAW,EAChB1yC,EAAK1c,IAAMmC,KAAKyrD,mBAChBzrD,KAAKgmD,OAAOlL,EAAMI,UACX3gC,EAAK1c,IAEZ0c,EAAK0yC,UAAW,EAGpB,OAAO1yC,EAAK1c,IAAMmC,KAAKsB,OAASw5C,EAAMt+B,KAAOxc,KAAKsB,OAASw5C,EAAM5mB,OAASl0B,KAAK4tD,gBAAkB5tD,KAAKipD,WAA0C,UAA/BjpD,KAAK4N,QAAQ0yC,gBAKhIiQ,GAAKxE,aAAe,SAAS37C,GAC3BA,EAAKmM,GAAK,KACNvc,KAAK4N,QAAQsyC,aAAe,IAAK9vC,EAAK0gC,UAAY1gC,EAAKu2C,YAAa,GACpE3mD,KAAK4N,QAAQsyC,aAAe,IAAK9vC,EAAK2jC,OAAQ,IAKpDwc,GAAK/C,YAAc,SAASJ,EAAatD,EAASpG,GAChD,IAAItzC,EAAOpQ,KAAK4jD,YAAaoI,EAAchsD,KAAK4iD,SAAUqJ,EAAcjsD,KAAK6iD,SAAUqJ,EAAmBlsD,KAAK8iD,cAqB/G,OAnBA9iD,KAAK+rD,aAAa37C,GACdpQ,KAAK4N,QAAQsyC,aAAe,IAC5B9vC,EAAK0gC,UAAYsc,GACjBptD,KAAK4N,QAAQsyC,aAAe,IAC5B9vC,EAAK2jC,QAAU+V,GAEnB9pD,KAAK4iD,SAAW,EAChB5iD,KAAK6iD,SAAW,EAChB7iD,KAAK8iD,cAAgB,EACrB9iD,KAAKmjD,WAjtEW,GAitEA3B,GAAcsI,EAAS15C,EAAK0gC,YAA4B4S,EAhtEjD,IAgtEyF,IAEhH1jD,KAAKgmD,OAAOlL,EAAMO,QAClBjrC,EAAKm9B,OAASvtC,KAAKqsD,iBAAiBvR,EAAMQ,QAAQ,EAAOt7C,KAAK4N,QAAQsyC,aAAe,GACrFlgD,KAAKwmD,iCACLxmD,KAAKosD,kBAAkBh8C,GAAM,GAAO,GAEpCpQ,KAAK4iD,SAAWoJ,EAChBhsD,KAAK6iD,SAAWoJ,EAChBjsD,KAAK8iD,cAAgBoJ,EACdlsD,KAAKgnD,WAAW52C,EAAM,uBAK/BmgD,GAAKgC,qBAAuB,SAASniD,EAAMm9B,EAAQuc,GACjD,IAAIkC,EAAchsD,KAAK4iD,SAAUqJ,EAAcjsD,KAAK6iD,SAAUqJ,EAAmBlsD,KAAK8iD,cAgBtF,OAdA9iD,KAAKmjD,WAruEW,GAquEA3B,GAAcsI,GAAS,IACvC9pD,KAAK+rD,aAAa37C,GACdpQ,KAAK4N,QAAQsyC,aAAe,IAAK9vC,EAAK2jC,QAAU+V,GAEpD9pD,KAAK4iD,SAAW,EAChB5iD,KAAK6iD,SAAW,EAChB7iD,KAAK8iD,cAAgB,EAErB1yC,EAAKm9B,OAASvtC,KAAKuvD,iBAAiBhiB,GAAQ,GAC5CvtC,KAAKosD,kBAAkBh8C,GAAM,GAAM,GAEnCpQ,KAAK4iD,SAAWoJ,EAChBhsD,KAAK6iD,SAAWoJ,EAChBjsD,KAAK8iD,cAAgBoJ,EACdlsD,KAAKgnD,WAAW52C,EAAM,4BAK/BmgD,GAAKnE,kBAAoB,SAASh8C,EAAMykD,EAAiBC,GACvD,IAAIC,EAAeF,GAAmB70D,KAAKsB,OAASw5C,EAAMK,OACtDoR,EAAYvsD,KAAKisC,OAAQ+oB,GAAY,EAEzC,GAAID,EACF3kD,EAAKs3B,KAAO1nC,KAAKyrD,mBACjBr7C,EAAKu2C,YAAa,EAClB3mD,KAAKi1D,YAAY7kD,GAAM,OAClB,CACL,IAAI8kD,EAAYl1D,KAAK4N,QAAQsyC,aAAe,IAAMlgD,KAAKm1D,kBAAkB/kD,EAAKm9B,QACzEgf,IAAa2I,IAChBF,EAAYh1D,KAAK0iD,gBAAgB1iD,KAAK4D,OAIrBsxD,GACbl1D,KAAKomD,iBAAiBh2C,EAAKpM,MAAO,6EAIxC,IAAIoxD,EAAYp1D,KAAK+iD,OACrB/iD,KAAK+iD,OAAS,GACViS,IAAah1D,KAAKisC,QAAS,GAI/BjsC,KAAKi1D,YAAY7kD,GAAOm8C,IAAcyI,IAAcH,IAAoBC,GAAY90D,KAAKm1D,kBAAkB/kD,EAAKm9B,SAE5GvtC,KAAKisC,QAAU77B,EAAKmM,IAAMvc,KAAK6pD,UAAUz5C,EAAKmM,GApwEnC,GAqwEfnM,EAAKs3B,KAAO1nC,KAAKyoD,YAAW,OAAO98C,EAAWqpD,IAAczI,GAC5Dn8C,EAAKu2C,YAAa,EAClB3mD,KAAK+mD,uBAAuB32C,EAAKs3B,KAAKA,MACtC1nC,KAAK+iD,OAASqS,EAEhBp1D,KAAK0qD,aAGP6F,GAAK4E,kBAAoB,SAAS5nB,GAChC,IAAK,IAAIjxC,EAAI,EAAGs8B,EAAO2U,EAAQjxC,EAAIs8B,EAAKv1B,OAAQ/G,GAAK,EACnD,CAGA,GAAmB,eAFPs8B,EAAKt8B,GAEPgF,KAAyB,OAAO,EAE5C,OAAO,GAMTivD,GAAK0E,YAAc,SAAS7kD,EAAMilD,GAEhC,IADA,IAAIC,EAAW,GACNh5D,EAAI,EAAGs8B,EAAOxoB,EAAKm9B,OAAQjxC,EAAIs8B,EAAKv1B,OAAQ/G,GAAK,EACxD,CACA,IAAI6b,EAAQygB,EAAKt8B,GAEjB0D,KAAK6pD,UAAU1xC,EApyEJ,EAoyEqBk9C,EAAkB,KAAOC,KAU7D/E,GAAK+B,cAAgB,SAAS1C,EAAOE,EAAoBD,EAAY1J,GAEnE,IADA,IAAI4J,EAAO,GAAItrC,GAAQ,GACfzkB,KAAKqlD,IAAIuK,IAAQ,CACvB,GAAKnrC,EAGIA,GAAQ,OADf,GADAzkB,KAAKgmD,OAAOlL,EAAMS,OACduU,GAAsB9vD,KAAK6lD,mBAAmB+J,GAAU,MAG9D,IAAIjB,OAAO,EACPkB,GAAc7vD,KAAKsB,OAASw5C,EAAMS,MAClCoT,EAAM,KACD3uD,KAAKsB,OAASw5C,EAAMkB,UAC3B2S,EAAM3uD,KAAKyvD,YAAYtJ,GACnBA,GAA0BnmD,KAAKsB,OAASw5C,EAAMS,OAAS4K,EAAuBnB,cAAgB,IAC9FmB,EAAuBnB,cAAgBhlD,KAAKgE,QAEhD2qD,EAAM3uD,KAAKyrD,kBAAiB,EAAOtF,GAErC4J,EAAK5jD,KAAKwiD,GAEZ,OAAOoB,GAGTQ,GAAKnC,gBAAkB,SAAS7O,GAC9B,IAAIv7C,EAAQu7C,EAAIv7C,MACZJ,EAAM27C,EAAI37C,IACV/G,EAAO0iD,EAAI1iD,MAEXmD,KAAKujD,aAAwB,UAAT1mD,GACpBmD,KAAKomD,iBAAiBpiD,EAAO,uDAC7BhE,KAAKwjD,SAAoB,UAAT3mD,GAChBmD,KAAKomD,iBAAiBpiD,EAAO,6DAC7BhE,KAAKo5C,SAASr/B,KAAKld,IACnBmD,KAAKimD,MAAMjiD,EAAQ,uBAAyBnH,EAAO,KACnDmD,KAAK4N,QAAQsyC,YAAc,IACmB,IAAhDlgD,KAAKggD,MAAMzgC,MAAMvb,EAAOJ,GAAKif,QAAQ,SAC9B7iB,KAAKisC,OAASjsC,KAAK6hD,oBAAsB7hD,KAAK84C,eAChD/+B,KAAKld,KACLmD,KAAKwjD,SAAoB,UAAT3mD,GACjBmD,KAAKomD,iBAAiBpiD,EAAO,wDACjChE,KAAKomD,iBAAiBpiD,EAAQ,gBAAkBnH,EAAO,mBAQ3D0zD,GAAKtH,WAAa,SAASsM,EAASjG,GAClC,IAAIl/C,EAAOpQ,KAAK4jD,YAwBhB,OAvBI5jD,KAAKsB,OAASw5C,EAAMj+C,KACtBuT,EAAKvT,KAAOmD,KAAKzC,MACRyC,KAAKsB,KAAK64C,SACnB/pC,EAAKvT,KAAOmD,KAAKsB,KAAK64C,QAMH,UAAd/pC,EAAKvT,MAAkC,aAAduT,EAAKvT,MAC9BmD,KAAKsiD,aAAetiD,KAAKqiD,aAAe,GAAkD,KAA7CriD,KAAKggD,MAAMlyB,WAAW9tB,KAAKqiD,eAC3EriD,KAAK2rB,QAAQlM,OAGfzf,KAAKylD,aAEPzlD,KAAK2J,OAAO4rD,GACZv1D,KAAKgnD,WAAW52C,EAAM,cACjBmlD,IACHv1D,KAAKouD,gBAAgBh+C,GACH,UAAdA,EAAKvT,MAAqBmD,KAAK8iD,gBAC/B9iD,KAAK8iD,cAAgB1yC,EAAKpM,QAEzBoM,GAKTmgD,GAAKQ,WAAa,SAASH,GACpB5wD,KAAK4iD,WAAY5iD,KAAK4iD,SAAW5iD,KAAKgE,OAE3C,IAAIoM,EAAOpQ,KAAK4jD,YAShB,OARA5jD,KAAK2J,OACD3J,KAAKsB,OAASw5C,EAAMU,MAAQx7C,KAAK0lD,sBAAyB1lD,KAAKsB,OAASw5C,EAAMgC,OAAS98C,KAAKsB,KAAK+4C,YACnGjqC,EAAK+gC,UAAW,EAChB/gC,EAAKi6C,SAAW,OAEhBj6C,EAAK+gC,SAAWnxC,KAAKqlD,IAAIvK,EAAMgC,MAC/B1sC,EAAKi6C,SAAWrqD,KAAKyrD,iBAAiBmF,IAEjC5wD,KAAKgnD,WAAW52C,EAAM,oBAG/BmgD,GAAKsB,WAAa,WACX7xD,KAAK6iD,WAAY7iD,KAAK6iD,SAAW7iD,KAAKgE,OAE3C,IAAIoM,EAAOpQ,KAAK4jD,YAGhB,OAFA5jD,KAAK2J,OACLyG,EAAKi6C,SAAWrqD,KAAKqxD,gBAAgB,MAAM,GACpCrxD,KAAKgnD,WAAW52C,EAAM,oBAG/B,IAAIolD,GAAO/T,GAAOvjD,UAQlBs3D,GAAKvP,MAAQ,SAAS1+C,EAAK6b,GACzB,IAAI0f,EAAMid,EAAY//C,KAAKggD,MAAOz4C,GAClC6b,GAAW,KAAO0f,EAAIrB,KAAO,IAAMqB,EAAIE,OAAS,IAChD,IAAIvkC,EAAM,IAAIg3D,YAAYryC,GAE1B,MADA3kB,EAAI8I,IAAMA,EAAK9I,EAAIqkC,IAAMA,EAAKrkC,EAAIi3D,SAAW11D,KAAKuH,IAC5C9I,GAGR+2D,GAAKpP,iBAAmBoP,GAAKvP,MAE7BuP,GAAKtT,YAAc,WACjB,GAAIliD,KAAK4N,QAAQ+yC,UACf,OAAO,IAAIhB,EAAS3/C,KAAKiiD,QAASjiD,KAAKuH,IAAMvH,KAAKgiD,YAItD,IAAI2T,GAAOlU,GAAOvjD,UAEd03D,GAAQ,SAAe5R,GACzBhkD,KAAKgkD,MAAQA,EAEbhkD,KAAK61D,IAAM,GAEX71D,KAAK81D,QAAU,GAEf91D,KAAK+1D,UAAY,IAKnBJ,GAAKxS,WAAa,SAASa,GACzBhkD,KAAKkjD,WAAW/2C,KAAK,IAAIypD,GAAM5R,KAGjC2R,GAAKjL,UAAY,WACf1qD,KAAKkjD,WAAWzjC,OAMlBk2C,GAAKzR,2BAA6B,SAAS8R,GACzC,OAt9EmB,EAs9EXA,EAAMhS,QAA4BhkD,KAAKyiD,UAv9EjC,EAu9E8CuT,EAAMhS,OAGpE2R,GAAKrF,YAAc,SAASzzD,EAAMuzD,EAAa7oD,GAC7C,IAAI0uD,GAAa,EACjB,GA18EiB,IA08Eb7F,EAA8B,CAChC,IAAI4F,EAAQh2D,KAAKmkD,eACjB8R,EAAaD,EAAMF,QAAQjzC,QAAQhmB,IAAS,GAAKm5D,EAAMD,UAAUlzC,QAAQhmB,IAAS,GAAKm5D,EAAMH,IAAIhzC,QAAQhmB,IAAS,EAClHm5D,EAAMF,QAAQ3pD,KAAKtP,GACfmD,KAAKyiD,UAh+EG,EAg+EUuT,EAAMhS,cACjBhkD,KAAKgjD,iBAAiBnmD,QAC5B,GA98Ee,IA88EXuzD,EAAmC,CAC9BpwD,KAAKmkD,eACX2R,QAAQ3pD,KAAKtP,QAChB,GAl9EW,IAk9EPuzD,EAA+B,CACxC,IAAI8F,EAAUl2D,KAAKmkD,eAEf8R,EADAj2D,KAAK2jD,oBACQuS,EAAQJ,QAAQjzC,QAAQhmB,IAAS,EAEjCq5D,EAAQJ,QAAQjzC,QAAQhmB,IAAS,GAAKq5D,EAAQL,IAAIhzC,QAAQhmB,IAAS,EACpFq5D,EAAQH,UAAU5pD,KAAKtP,QAEvB,IAAK,IAAIP,EAAI0D,KAAKkjD,WAAW7/C,OAAS,EAAG/G,GAAK,IAAKA,EAAG,CACpD,IAAI65D,EAAUn2D,KAAKkjD,WAAW5mD,GAC9B,GAAI65D,EAAQL,QAAQjzC,QAAQhmB,IAAS,KAz+ElB,GAy+E0Bs5D,EAAQnS,OAA+BmS,EAAQL,QAAQ,KAAOj5D,KACtGmD,KAAKkkD,2BAA2BiS,IAAYA,EAAQJ,UAAUlzC,QAAQhmB,IAAS,EAAG,CACrFo5D,GAAa,EACb,MAKF,GAHAE,EAAQN,IAAI1pD,KAAKtP,GACbmD,KAAKyiD,UAr/EC,EAq/EY0T,EAAQnS,cACnBhkD,KAAKgjD,iBAAiBnmD,GAp/EvBu5D,EAq/END,EAAQnS,MAAqB,MAGjCiS,GAAcj2D,KAAKomD,iBAAiB7+C,EAAM,eAAiB1K,EAAO,gCAGxE84D,GAAKrH,iBAAmB,SAAS/xC,IAEsB,IAAjDvc,KAAKkjD,WAAW,GAAG4S,QAAQjzC,QAAQtG,EAAG1f,QACO,IAA7CmD,KAAKkjD,WAAW,GAAG2S,IAAIhzC,QAAQtG,EAAG1f,QACpCmD,KAAKgjD,iBAAiBzmC,EAAG1f,MAAQ0f,IAIrCo5C,GAAKxR,aAAe,WAClB,OAAOnkD,KAAKkjD,WAAWljD,KAAKkjD,WAAW7/C,OAAS,IAGlDsyD,GAAK5R,gBAAkB,WACrB,IAAK,IAAIznD,EAAI0D,KAAKkjD,WAAW7/C,OAAS,GAAI/G,IAAK,CAC7C,IAAI05D,EAAQh2D,KAAKkjD,WAAW5mD,GAC5B,GA1gFY85D,EA0gFRJ,EAAMhS,MAAqB,OAAOgS,IAK1CL,GAAK1R,iBAAmB,WACtB,IAAK,IAAI3nD,EAAI0D,KAAKkjD,WAAW7/C,OAAS,GAAI/G,IAAK,CAC7C,IAAI05D,EAAQh2D,KAAKkjD,WAAW5mD,GAC5B,GAlhFY85D,EAkhFRJ,EAAMhS,SA/gFI,GA+gFmBgS,EAAMhS,OAAwB,OAAOgS,IAI1E,IAAIrwC,GAAO,SAAc8+B,EAAQl9C,EAAKu7B,GACpC9iC,KAAKsB,KAAO,GACZtB,KAAKgE,MAAQuD,EACbvH,KAAK4D,IAAM,EACP6gD,EAAO72C,QAAQ+yC,YACf3gD,KAAK8iC,IAAM,IAAI+c,EAAe4E,EAAQ3hB,IACtC2hB,EAAO72C,QAAQmzC,mBACf/gD,KAAK8/C,WAAa2E,EAAO72C,QAAQmzC,kBACjC0D,EAAO72C,QAAQgqC,SACf53C,KAAKsd,MAAQ,CAAC/V,EAAK,KAKrB8uD,GAAO5U,GAAOvjD,UAYlB,SAAS81D,GAAa5jD,EAAM9O,EAAMiG,EAAKu7B,GAOrC,OANA1yB,EAAK9O,KAAOA,EACZ8O,EAAKxM,IAAM2D,EACPvH,KAAK4N,QAAQ+yC,YACbvwC,EAAK0yB,IAAIl/B,IAAMk/B,GACf9iC,KAAK4N,QAAQgqC,SACbxnC,EAAKkN,MAAM,GAAK/V,GACb6I,EAjBTimD,GAAKzS,UAAY,WACf,OAAO,IAAIj+B,GAAK3lB,KAAMA,KAAKgE,MAAOhE,KAAKohD,WAGzCiV,GAAKnJ,YAAc,SAAS3lD,EAAKu7B,GAC/B,OAAO,IAAInd,GAAK3lB,KAAMuH,EAAKu7B,IAe7BuzB,GAAKrP,WAAa,SAAS52C,EAAM9O,GAC/B,OAAO0yD,GAAav3D,KAAKuD,KAAMoQ,EAAM9O,EAAMtB,KAAKsiD,WAAYtiD,KAAKmiD,gBAKnEkU,GAAKrC,aAAe,SAAS5jD,EAAM9O,EAAMiG,EAAKu7B,GAC5C,OAAOkxB,GAAav3D,KAAKuD,KAAMoQ,EAAM9O,EAAMiG,EAAKu7B,IAKlD,IAAIwzB,GAAa,SAAoBp3D,EAAOq3D,EAAQC,EAAeC,EAAU3lB,GAC3E9wC,KAAKd,MAAQA,EACbc,KAAKu2D,SAAWA,EAChBv2D,KAAKw2D,gBAAkBA,EACvBx2D,KAAKy2D,SAAWA,EAChBz2D,KAAK8wC,YAAcA,GAGjB4lB,GAAU,CACZC,OAAQ,IAAIL,GAAW,KAAK,GAC5BM,OAAQ,IAAIN,GAAW,KAAK,GAC5BO,OAAQ,IAAIP,GAAW,MAAM,GAC7BQ,OAAQ,IAAIR,GAAW,KAAK,GAC5BS,OAAQ,IAAIT,GAAW,KAAK,GAC5BU,OAAQ,IAAIV,GAAW,KAAK,GAAM,GAAM,SAAUl4D,GAAK,OAAOA,EAAE64D,0BAChEC,OAAQ,IAAIZ,GAAW,YAAY,GACnCa,OAAQ,IAAIb,GAAW,YAAY,GACnCc,WAAY,IAAId,GAAW,YAAY,GAAM,EAAO,MAAM,GAC1De,MAAO,IAAIf,GAAW,YAAY,GAAO,EAAO,MAAM,IAGpDgB,GAAO7V,GAAOvjD,UAElBo5D,GAAK/U,eAAiB,WACpB,MAAO,CAACmU,GAAQC,SAGlBW,GAAKC,aAAe,SAASC,GAC3B,IAAIlxD,EAAStG,KAAKy3D,aAClB,OAAInxD,IAAWowD,GAAQS,QAAU7wD,IAAWowD,GAAQQ,SAEhDM,IAAa1c,EAAMW,OAAUn1C,IAAWowD,GAAQC,QAAUrwD,IAAWowD,GAAQE,OAM7EY,IAAa1c,EAAMgD,SAAW0Z,IAAa1c,EAAMj+C,MAAQmD,KAAKwiD,YACvDvD,EAAUllC,KAAK/Z,KAAKggD,MAAMzgC,MAAMvf,KAAKsiD,WAAYtiD,KAAKgE,QAC7DwzD,IAAa1c,EAAM2C,OAAS+Z,IAAa1c,EAAMU,MAAQgc,IAAa1c,EAAME,KAAOwc,IAAa1c,EAAMQ,QAAUkc,IAAa1c,EAAMe,QAEjI2b,IAAa1c,EAAMK,OACZ70C,IAAWowD,GAAQC,OAC1Ba,IAAa1c,EAAMmD,MAAQuZ,IAAa1c,EAAMoD,QAAUsZ,IAAa1c,EAAMj+C,OAEvEmD,KAAKwiD,cAbDl8C,EAAOiwD,SAgBrBe,GAAKI,mBAAqB,WACxB,IAAK,IAAIp7D,EAAI0D,KAAK2rB,QAAQtoB,OAAS,EAAG/G,GAAK,EAAGA,IAAK,CACjD,IAAIqvB,EAAU3rB,KAAK2rB,QAAQrvB,GAC3B,GAAsB,aAAlBqvB,EAAQzsB,MACR,OAAOysB,EAAQmlB,UAErB,OAAO,GAGTwmB,GAAK5c,cAAgB,SAAS8c,GAC5B,IAAInM,EAAQ/pD,EAAOtB,KAAKsB,KACpBA,EAAK64C,SAAWqd,IAAa1c,EAAMY,IACnC17C,KAAKwiD,aAAc,GACd6I,EAAS/pD,EAAKo5C,eACnB2Q,EAAO5uD,KAAKuD,KAAMw3D,GAElBx3D,KAAKwiD,YAAclhD,EAAK84C,YAK9BU,EAAMQ,OAAOZ,cAAgBI,EAAMM,OAAOV,cAAgB,WACxD,GAA4B,IAAxB16C,KAAK2rB,QAAQtoB,OAAjB,CAIA,IAAIG,EAAMxD,KAAK2rB,QAAQlM,MACnBjc,IAAQkzD,GAAQC,QAAsC,aAA5B32D,KAAKy3D,aAAav4D,QAC9CsE,EAAMxD,KAAK2rB,QAAQlM,OAErBzf,KAAKwiD,aAAeh/C,EAAI+yD,YAPtBv2D,KAAKwiD,aAAc,GAUvB1H,EAAMK,OAAOT,cAAgB,SAAS8c,GACpCx3D,KAAK2rB,QAAQxf,KAAKnM,KAAKu3D,aAAaC,GAAYd,GAAQC,OAASD,GAAQE,QACzE52D,KAAKwiD,aAAc,GAGrB1H,EAAMoB,aAAaxB,cAAgB,WACjC16C,KAAK2rB,QAAQxf,KAAKuqD,GAAQG,QAC1B72D,KAAKwiD,aAAc,GAGrB1H,EAAMO,OAAOX,cAAgB,SAAS8c,GACpC,IAAIG,EAAkBH,IAAa1c,EAAM+C,KAAO2Z,IAAa1c,EAAM6C,MAAQ6Z,IAAa1c,EAAMsD,OAASoZ,IAAa1c,EAAMqD,OAC1Hn+C,KAAK2rB,QAAQxf,KAAKwrD,EAAkBjB,GAAQI,OAASJ,GAAQK,QAC7D/2D,KAAKwiD,aAAc,GAGrB1H,EAAMqB,OAAOzB,cAAgB,aAI7BI,EAAM8C,UAAUlD,cAAgBI,EAAMwD,OAAO5D,cAAgB,SAAS8c,IAChEA,EAASpd,YAAcod,IAAa1c,EAAMU,MAAQgc,IAAa1c,EAAM2C,OACnE+Z,IAAa1c,EAAMgD,SAAWmB,EAAUllC,KAAK/Z,KAAKggD,MAAMzgC,MAAMvf,KAAKsiD,WAAYtiD,KAAKgE,UACnFwzD,IAAa1c,EAAMW,OAAS+b,IAAa1c,EAAMK,SAAWn7C,KAAKy3D,eAAiBf,GAAQC,OAG3F32D,KAAK2rB,QAAQxf,KAAKuqD,GAAQQ,QAF1Bl3D,KAAK2rB,QAAQxf,KAAKuqD,GAAQS,QAG9Bn3D,KAAKwiD,aAAc,GAGrB1H,EAAMmB,UAAUvB,cAAgB,WAC1B16C,KAAKy3D,eAAiBf,GAAQM,OAC9Bh3D,KAAK2rB,QAAQlM,MAEbzf,KAAK2rB,QAAQxf,KAAKuqD,GAAQM,QAC9Bh3D,KAAKwiD,aAAc,GAGrB1H,EAAMgC,KAAKpC,cAAgB,SAAS8c,GAClC,GAAIA,IAAa1c,EAAM8C,UAAW,CAChC,IAAInuB,EAAQzvB,KAAK2rB,QAAQtoB,OAAS,EAC9BrD,KAAK2rB,QAAQ8D,KAAWinC,GAAQS,OAChCn3D,KAAK2rB,QAAQ8D,GAASinC,GAAQU,WAE9Bp3D,KAAK2rB,QAAQ8D,GAASinC,GAAQW,MAEpCr3D,KAAKwiD,aAAc,GAGrB1H,EAAMj+C,KAAK69C,cAAgB,SAAS8c,GAClC,IAAIp1C,GAAU,EACVpiB,KAAK4N,QAAQsyC,aAAe,GAAKsX,IAAa1c,EAAMY,MACnC,OAAf17C,KAAKzC,QAAmByC,KAAKwiD,aACd,UAAfxiD,KAAKzC,OAAqByC,KAAK03D,wBAC/Bt1C,GAAU,GAEhBpiB,KAAKwiD,YAAcpgC,GAQrB,IAAIw1C,GAAwB,89BACxBC,GAAyBD,GAAwB,yBAEjDE,GAA0B,CAC5BC,EAAGH,GACHI,GAAIH,GACJI,GAJ2BJ,q/BAQzBK,GAA+B,qpBAG/BC,GAAoB,2+DACpBC,GAAqBD,GAAoB,kHAEzCE,GAAsB,CACxBN,EAAGI,GACHH,GAAII,GACJH,GAJuBG,iqEAOrB/4D,GAAO,GACX,SAASi5D,GAAiBpY,GACxB,IAAItjD,EAAIyC,GAAK6gD,GAAe,CAC1BqY,OAAQ9Y,EAAYqY,GAAwB5X,GAAe,IAAMgY,IACjEM,UAAW,CACTC,iBAAkBhZ,EAAYyY,IAC9BQ,OAAQjZ,EAAY4Y,GAAoBnY,MAG5CtjD,EAAE47D,UAAUG,kBAAoB/7D,EAAE47D,UAAUE,OAE5C97D,EAAE47D,UAAUI,GAAKh8D,EAAE47D,UAAUC,iBAC7B77D,EAAE47D,UAAUK,GAAKj8D,EAAE47D,UAAUE,OAC7B97D,EAAE47D,UAAUM,IAAMl8D,EAAE47D,UAAUG,kBAEhCL,GAAiB,GACjBA,GAAiB,IACjBA,GAAiB,IAEjB,IAAIS,GAAOtX,GAAOvjD,UAEd86D,GAAwB,SAA+BvU,GACzDzkD,KAAKykD,OAASA,EACdzkD,KAAKi5D,WAAa,OAASxU,EAAO72C,QAAQsyC,aAAe,EAAI,KAAO,KAAOuE,EAAO72C,QAAQsyC,aAAe,EAAI,IAAM,IACnHlgD,KAAKk5D,kBAAoB75D,GAAKolD,EAAO72C,QAAQsyC,aAAe,GAAK,GAAKuE,EAAO72C,QAAQsyC,aACrFlgD,KAAK2V,OAAS,GACd3V,KAAKgkD,MAAQ,GACbhkD,KAAKgE,MAAQ,EACbhE,KAAKm5D,SAAU,EACfn5D,KAAKo5D,SAAU,EACfp5D,KAAKuH,IAAM,EACXvH,KAAKq5D,aAAe,EACpBr5D,KAAKs5D,gBAAkB,GACvBt5D,KAAKu5D,6BAA8B,EACnCv5D,KAAKw5D,mBAAqB,EAC1Bx5D,KAAKy5D,iBAAmB,EACxBz5D,KAAK05D,WAAa,GAClB15D,KAAK25D,mBAAqB,IA8E5B,SAASC,GAAkBC,GACzB,OAAIA,GAAM,MAAiBhyD,OAAOgwB,aAAagiC,IAC/CA,GAAM,MACChyD,OAAOgwB,aAA0B,OAAZgiC,GAAM,IAA8B,OAAV,KAALA,KAiSnD,SAASC,GAAkBD,GACzB,OACS,KAAPA,GACAA,GAAM,IAAgBA,GAAM,IACrB,KAAPA,GACO,KAAPA,GACAA,GAAM,IAAgBA,GAAM,IAC5BA,GAAM,KAAgBA,GAAM,IA8PhC,SAASE,GAAgBF,GACvB,OACGA,GAAM,IAAgBA,GAAM,IAC5BA,GAAM,IAAgBA,GAAM,IA6KjC,SAASG,GAA+BH,GACtC,OAAOE,GAAgBF,IAAc,KAAPA,EAchC,SAASI,GAAgCJ,GACvC,OAAOG,GAA+BH,IAAOK,GAAeL,GAuI9D,SAASK,GAAeL,GACtB,OAAOA,GAAM,IAAgBA,GAAM,GAcrC,SAASM,GAAWN,GAClB,OACGA,GAAM,IAAgBA,GAAM,IAC5BA,GAAM,IAAgBA,GAAM,IAC5BA,GAAM,IAAgBA,GAAM,IAGjC,SAASO,GAASP,GAChB,OAAIA,GAAM,IAAgBA,GAAM,GACjBA,EAAK,GAAX,GAELA,GAAM,IAAgBA,GAAM,IACjBA,EAAK,GAAX,GAEFA,EAAK,GAkCd,SAASQ,GAAaR,GACpB,OAAOA,GAAM,IAAgBA,GAAM,GA3/BrCb,GAAsB96D,UAAUq1C,MAAQ,SAAgBvvC,EAAOghC,EAASgf,GACtE,IAAIsW,GAAkC,IAAxBtW,EAAMnhC,QAAQ,KAC5B7iB,KAAKgE,MAAgB,EAARA,EACbhE,KAAK2V,OAASqvB,EAAU,GACxBhlC,KAAKgkD,MAAQA,EACbhkD,KAAKm5D,QAAUmB,GAAWt6D,KAAKykD,OAAO72C,QAAQsyC,aAAe,EAC7DlgD,KAAKo5D,QAAUkB,GAAWt6D,KAAKykD,OAAO72C,QAAQsyC,aAAe,GAG/D8Y,GAAsB96D,UAAU+nD,MAAQ,SAAgB7iC,GACtDpjB,KAAKykD,OAAO2B,iBAAiBpmD,KAAKgE,MAAQ,gCAAmChE,KAAK2V,OAAU,MAAQyN,IAKtG41C,GAAsB96D,UAAUq8D,GAAK,SAAaj+D,EAAGk+D,QACjC,IAAXA,IAAoBA,GAAS,GAEpC,IAAIn8D,EAAI2B,KAAK2V,OACTpZ,EAAI8B,EAAEgF,OACV,GAAI/G,GAAKC,EACP,OAAQ,EAEV,IAAII,EAAI0B,EAAEyvB,WAAWxxB,GACrB,IAAMk+D,IAAUx6D,KAAKm5D,SAAYx8D,GAAK,OAAUA,GAAK,OAAUL,EAAI,GAAKC,EACtE,OAAOI,EAET,IAAIgN,EAAOtL,EAAEyvB,WAAWxxB,EAAI,GAC5B,OAAOqN,GAAQ,OAAUA,GAAQ,OAAUhN,GAAK,IAAMgN,EAAO,SAAYhN,GAG3Eq8D,GAAsB96D,UAAUu8D,UAAY,SAAoBn+D,EAAGk+D,QAC/C,IAAXA,IAAoBA,GAAS,GAEpC,IAAIn8D,EAAI2B,KAAK2V,OACTpZ,EAAI8B,EAAEgF,OACV,GAAI/G,GAAKC,EACP,OAAOA,EAET,IAAyBoN,EAArBhN,EAAI0B,EAAEyvB,WAAWxxB,GACrB,OAAMk+D,IAAUx6D,KAAKm5D,SAAYx8D,GAAK,OAAUA,GAAK,OAAUL,EAAI,GAAKC,IACnEoN,EAAOtL,EAAEyvB,WAAWxxB,EAAI,IAAM,OAAUqN,EAAO,MAC3CrN,EAAI,EAENA,EAAI,GAGb08D,GAAsB96D,UAAUyjC,QAAU,SAAkB64B,GAG1D,YAFkB,IAAXA,IAAoBA,GAAS,GAE7Bx6D,KAAKu6D,GAAGv6D,KAAKuH,IAAKizD,IAG3BxB,GAAsB96D,UAAUw8D,UAAY,SAAoBF,GAG9D,YAFkB,IAAXA,IAAoBA,GAAS,GAE7Bx6D,KAAKu6D,GAAGv6D,KAAKy6D,UAAUz6D,KAAKuH,IAAKizD,GAASA,IAGnDxB,GAAsB96D,UAAU+kC,QAAU,SAAkBu3B,QACxC,IAAXA,IAAoBA,GAAS,GAEpCx6D,KAAKuH,IAAMvH,KAAKy6D,UAAUz6D,KAAKuH,IAAKizD,IAGtCxB,GAAsB96D,UAAUmnD,IAAM,SAAcwU,EAAIW,GAGtD,YAFkB,IAAXA,IAAoBA,GAAS,GAEhCx6D,KAAK2hC,QAAQ64B,KAAYX,IAC3B75D,KAAKijC,QAAQu3B,IACN,IAiBXzB,GAAK4B,oBAAsB,SAAS1pB,GAIlC,IAHA,IAAIgoB,EAAahoB,EAAMgoB,WACnBjV,EAAQ/S,EAAM+S,MAET1nD,EAAI,EAAGA,EAAI0nD,EAAM3gD,OAAQ/G,IAAK,CACrC,IAAIs+D,EAAO5W,EAAM9P,OAAO53C,IACU,IAA9B28D,EAAWp2C,QAAQ+3C,IACrB56D,KAAKimD,MAAMhV,EAAMjtC,MAAO,mCAEtBggD,EAAMnhC,QAAQ+3C,EAAMt+D,EAAI,IAAM,GAChC0D,KAAKimD,MAAMhV,EAAMjtC,MAAO,uCAW9B+0D,GAAK8B,sBAAwB,SAAS5pB,GACpCjxC,KAAK86D,eAAe7pB,IAOfA,EAAMmoB,SAAWp5D,KAAK4N,QAAQsyC,aAAe,GAAKjP,EAAMyoB,WAAWr2D,OAAS,IAC/E4tC,EAAMmoB,SAAU,EAChBp5D,KAAK86D,eAAe7pB,KAKxB8nB,GAAK+B,eAAiB,SAAS7pB,GAC7BA,EAAM1pC,IAAM,EACZ0pC,EAAMooB,aAAe,EACrBpoB,EAAMqoB,gBAAkB,GACxBroB,EAAMsoB,6BAA8B,EACpCtoB,EAAMuoB,mBAAqB,EAC3BvoB,EAAMwoB,iBAAmB,EACzBxoB,EAAMyoB,WAAWr2D,OAAS,EAC1B4tC,EAAM0oB,mBAAmBt2D,OAAS,EAElCrD,KAAK+6D,mBAAmB9pB,GAEpBA,EAAM1pC,MAAQ0pC,EAAMt7B,OAAOtS,SAEzB4tC,EAAMoU,IAAI,KACZpU,EAAMgV,MAAM,kBAEVhV,EAAMoU,IAAI,KAAiBpU,EAAMoU,IAAI,OACvCpU,EAAMgV,MAAM,6BAGZhV,EAAMwoB,iBAAmBxoB,EAAMuoB,oBACjCvoB,EAAMgV,MAAM,kBAEd,IAAK,IAAI3pD,EAAI,EAAGs8B,EAAOqY,EAAM0oB,mBAAoBr9D,EAAIs8B,EAAKv1B,OAAQ/G,GAAK,EAAG,CACxE,IAAIO,EAAO+7B,EAAKt8B,IAEwB,IAApC20C,EAAMyoB,WAAW72C,QAAQhmB,IAC3Bo0C,EAAMgV,MAAM,sCAMlB8S,GAAKgC,mBAAqB,SAAS9pB,GAEjC,IADAjxC,KAAKg7D,mBAAmB/pB,GACjBA,EAAMoU,IAAI,MACfrlD,KAAKg7D,mBAAmB/pB,GAItBjxC,KAAKi7D,qBAAqBhqB,GAAO,IACnCA,EAAMgV,MAAM,qBAEVhV,EAAMoU,IAAI,MACZpU,EAAMgV,MAAM,6BAKhB8S,GAAKiC,mBAAqB,SAAS/pB,GACjC,KAAOA,EAAM1pC,IAAM0pC,EAAMt7B,OAAOtS,QAAUrD,KAAKk7D,eAAejqB,OAKhE8nB,GAAKmC,eAAiB,SAASjqB,GAC7B,OAAIjxC,KAAKm7D,oBAAoBlqB,IAIvBA,EAAMsoB,6BAA+Bv5D,KAAKi7D,qBAAqBhqB,IAE7DA,EAAMkoB,SACRloB,EAAMgV,MAAM,uBAGT,MAGLhV,EAAMkoB,QAAUn5D,KAAKo7D,eAAenqB,GAASjxC,KAAKq7D,uBAAuBpqB,MAC3EjxC,KAAKi7D,qBAAqBhqB,IACnB,IAOX8nB,GAAKoC,oBAAsB,SAASlqB,GAClC,IAAIjtC,EAAQitC,EAAM1pC,IAIlB,GAHA0pC,EAAMsoB,6BAA8B,EAGhCtoB,EAAMoU,IAAI,KAAiBpU,EAAMoU,IAAI,IACvC,OAAO,EAIT,GAAIpU,EAAMoU,IAAI,IAAe,CAC3B,GAAIpU,EAAMoU,IAAI,KAAiBpU,EAAMoU,IAAI,IACvC,OAAO,EAETpU,EAAM1pC,IAAMvD,EAId,GAAIitC,EAAMoU,IAAI,KAAiBpU,EAAMoU,IAAI,IAAe,CACtD,IAAIiW,GAAa,EAIjB,GAHIt7D,KAAK4N,QAAQsyC,aAAe,IAC9Bob,EAAarqB,EAAMoU,IAAI,KAErBpU,EAAMoU,IAAI,KAAiBpU,EAAMoU,IAAI,IAMvC,OALArlD,KAAK+6D,mBAAmB9pB,GACnBA,EAAMoU,IAAI,KACbpU,EAAMgV,MAAM,sBAEdhV,EAAMsoB,6BAA+B+B,GAC9B,EAKX,OADArqB,EAAM1pC,IAAMvD,GACL,GAIT+0D,GAAKkC,qBAAuB,SAAShqB,EAAOsqB,GAG1C,YAFiB,IAAZA,IAAqBA,GAAU,KAEhCv7D,KAAKw7D,2BAA2BvqB,EAAOsqB,KACzCtqB,EAAMoU,IAAI,KACH,IAMX0T,GAAKyC,2BAA6B,SAASvqB,EAAOsqB,GAChD,OACEtqB,EAAMoU,IAAI,KACVpU,EAAMoU,IAAI,KACVpU,EAAMoU,IAAI,KACVrlD,KAAKy7D,2BAA2BxqB,EAAOsqB,IAG3CxC,GAAK0C,2BAA6B,SAASxqB,EAAOsqB,GAChD,IAAIv3D,EAAQitC,EAAM1pC,IAClB,GAAI0pC,EAAMoU,IAAI,KAAe,CAC3B,IAAIjuB,EAAM,EAAG8B,GAAO,EACpB,GAAIl5B,KAAK07D,wBAAwBzqB,KAC/B7Z,EAAM6Z,EAAMooB,aACRpoB,EAAMoU,IAAI,KAAiBrlD,KAAK07D,wBAAwBzqB,KAC1D/X,EAAM+X,EAAMooB,cAEVpoB,EAAMoU,IAAI,MAKZ,OAHa,IAATnsB,GAAcA,EAAM9B,IAAQmkC,GAC9BtqB,EAAMgV,MAAM,0CAEP,EAGPhV,EAAMkoB,UAAYoC,GACpBtqB,EAAMgV,MAAM,yBAEdhV,EAAM1pC,IAAMvD,EAEd,OAAO,GAIT+0D,GAAKqC,eAAiB,SAASnqB,GAC7B,OACEjxC,KAAK27D,4BAA4B1qB,IACjCA,EAAMoU,IAAI,KACVrlD,KAAK47D,mCAAmC3qB,IACxCjxC,KAAK67D,yBAAyB5qB,IAC9BjxC,KAAK87D,2BAA2B7qB,IAChCjxC,KAAK+7D,yBAAyB9qB,IAGlC8nB,GAAK6C,mCAAqC,SAAS3qB,GACjD,IAAIjtC,EAAQitC,EAAM1pC,IAClB,GAAI0pC,EAAMoU,IAAI,IAAe,CAC3B,GAAIrlD,KAAKg8D,qBAAqB/qB,GAC5B,OAAO,EAETA,EAAM1pC,IAAMvD,EAEd,OAAO,GAET+0D,GAAK+C,2BAA6B,SAAS7qB,GACzC,IAAIjtC,EAAQitC,EAAM1pC,IAClB,GAAI0pC,EAAMoU,IAAI,IAAe,CAC3B,GAAIpU,EAAMoU,IAAI,KAAiBpU,EAAMoU,IAAI,IAAe,CAEtD,GADArlD,KAAK+6D,mBAAmB9pB,GACpBA,EAAMoU,IAAI,IACZ,OAAO,EAETpU,EAAMgV,MAAM,sBAEdhV,EAAM1pC,IAAMvD,EAEd,OAAO,GAET+0D,GAAKgD,yBAA2B,SAAS9qB,GACvC,GAAIA,EAAMoU,IAAI,IAAe,CAO3B,GANIrlD,KAAK4N,QAAQsyC,aAAe,EAC9BlgD,KAAKi8D,sBAAsBhrB,GACE,KAApBA,EAAMtP,WACfsP,EAAMgV,MAAM,iBAEdjmD,KAAK+6D,mBAAmB9pB,GACpBA,EAAMoU,IAAI,IAEZ,OADApU,EAAMuoB,oBAAsB,GACrB,EAETvoB,EAAMgV,MAAM,sBAEd,OAAO,GAIT8S,GAAKsC,uBAAyB,SAASpqB,GACrC,OACEA,EAAMoU,IAAI,KACVrlD,KAAK47D,mCAAmC3qB,IACxCjxC,KAAK67D,yBAAyB5qB,IAC9BjxC,KAAK87D,2BAA2B7qB,IAChCjxC,KAAK+7D,yBAAyB9qB,IAC9BjxC,KAAKk8D,kCAAkCjrB,IACvCjxC,KAAKm8D,mCAAmClrB,IAK5C8nB,GAAKmD,kCAAoC,SAASjrB,GAIhD,OAHIjxC,KAAKy7D,2BAA2BxqB,GAAO,IACzCA,EAAMgV,MAAM,sBAEP,GAIT8S,GAAKqD,0BAA4B,SAASnrB,GACxC,IAAI4oB,EAAK5oB,EAAMtP,UACf,QAAIm4B,GAAkBD,KACpB5oB,EAAMooB,aAAeQ,EACrB5oB,EAAMhO,WACC,IAiBX81B,GAAK4C,4BAA8B,SAAS1qB,GAG1C,IAFA,IAAIjtC,EAAQitC,EAAM1pC,IACdsyD,EAAK,GAC0B,KAA3BA,EAAK5oB,EAAMtP,aAAsBm4B,GAAkBD,IACzD5oB,EAAMhO,UAER,OAAOgO,EAAM1pC,MAAQvD,GAIvB+0D,GAAKoD,mCAAqC,SAASlrB,GACjD,IAAI4oB,EAAK5oB,EAAMtP,UACf,SACU,IAARk4B,GACO,KAAPA,GACEA,GAAM,IAAgBA,GAAM,IACvB,KAAPA,GACO,KAAPA,GACO,KAAPA,GACO,KAAPA,GACO,MAAPA,KAEA5oB,EAAMhO,WACC,IAQX81B,GAAKkD,sBAAwB,SAAShrB,GACpC,GAAIA,EAAMoU,IAAI,IAAe,CAC3B,GAAIrlD,KAAKq8D,oBAAoBprB,GAK3B,OAJyD,IAArDA,EAAMyoB,WAAW72C,QAAQouB,EAAMqoB,kBACjCroB,EAAMgV,MAAM,qCAEdhV,EAAMyoB,WAAWvtD,KAAK8kC,EAAMqoB,iBAG9BroB,EAAMgV,MAAM,mBAOhB8S,GAAKsD,oBAAsB,SAASprB,GAElC,GADAA,EAAMqoB,gBAAkB,GACpBroB,EAAMoU,IAAI,IAAe,CAC3B,GAAIrlD,KAAKs8D,+BAA+BrrB,IAAUA,EAAMoU,IAAI,IAC1D,OAAO,EAETpU,EAAMgV,MAAM,8BAEd,OAAO,GAOT8S,GAAKuD,+BAAiC,SAASrrB,GAE7C,GADAA,EAAMqoB,gBAAkB,GACpBt5D,KAAKu8D,gCAAgCtrB,GAAQ,CAE/C,IADAA,EAAMqoB,iBAAmBM,GAAkB3oB,EAAMooB,cAC1Cr5D,KAAKw8D,+BAA+BvrB,IACzCA,EAAMqoB,iBAAmBM,GAAkB3oB,EAAMooB,cAEnD,OAAO,EAET,OAAO,GAQTN,GAAKwD,gCAAkC,SAAStrB,GAC9C,IAAIjtC,EAAQitC,EAAM1pC,IACdizD,EAASx6D,KAAK4N,QAAQsyC,aAAe,GACrC2Z,EAAK5oB,EAAMtP,QAAQ64B,GAMvB,OALAvpB,EAAMhO,QAAQu3B,GAEH,KAAPX,GAAuB75D,KAAKy8D,sCAAsCxrB,EAAOupB,KAC3EX,EAAK5oB,EAAMooB,cAUf,SAAiCQ,GAC/B,OAAOhgB,EAAkBggB,GAAI,IAAgB,KAAPA,GAA8B,KAAPA,EATzD6C,CAAwB7C,IAC1B5oB,EAAMooB,aAAeQ,GACd,IAGT5oB,EAAM1pC,IAAMvD,GACL,IAaT+0D,GAAKyD,+BAAiC,SAASvrB,GAC7C,IAAIjtC,EAAQitC,EAAM1pC,IACdizD,EAASx6D,KAAK4N,QAAQsyC,aAAe,GACrC2Z,EAAK5oB,EAAMtP,QAAQ64B,GAMvB,OALAvpB,EAAMhO,QAAQu3B,GAEH,KAAPX,GAAuB75D,KAAKy8D,sCAAsCxrB,EAAOupB,KAC3EX,EAAK5oB,EAAMooB,cAUf,SAAgCQ,GAC9B,OAAO9f,EAAiB8f,GAAI,IAAgB,KAAPA,GAA8B,KAAPA,GAA8B,OAAPA,GAAqC,OAAPA,EAT7G8C,CAAuB9C,IACzB5oB,EAAMooB,aAAeQ,GACd,IAGT5oB,EAAM1pC,IAAMvD,GACL,IAOT+0D,GAAKiD,qBAAuB,SAAS/qB,GACnC,SACEjxC,KAAK48D,wBAAwB3rB,IAC7BjxC,KAAK68D,+BAA+B5rB,IACpCjxC,KAAK88D,0BAA0B7rB,IAC9BA,EAAMmoB,SAAWp5D,KAAK+8D,qBAAqB9rB,MAI1CA,EAAMkoB,UAEgB,KAApBloB,EAAMtP,WACRsP,EAAMgV,MAAM,0BAEdhV,EAAMgV,MAAM,oBAEP,IAET8S,GAAK6D,wBAA0B,SAAS3rB,GACtC,IAAIjtC,EAAQitC,EAAM1pC,IAClB,GAAIvH,KAAKg9D,wBAAwB/rB,GAAQ,CACvC,IAAIlzC,EAAIkzC,EAAMooB,aACd,GAAIpoB,EAAMkoB,QAKR,OAHIp7D,EAAIkzC,EAAMwoB,mBACZxoB,EAAMwoB,iBAAmB17D,IAEpB,EAET,GAAIA,GAAKkzC,EAAMuoB,mBACb,OAAO,EAETvoB,EAAM1pC,IAAMvD,EAEd,OAAO,GAET+0D,GAAKgE,qBAAuB,SAAS9rB,GACnC,GAAIA,EAAMoU,IAAI,KAAe,CAC3B,GAAIrlD,KAAKq8D,oBAAoBprB,GAE3B,OADAA,EAAM0oB,mBAAmBxtD,KAAK8kC,EAAMqoB,kBAC7B,EAETroB,EAAMgV,MAAM,2BAEd,OAAO,GAIT8S,GAAK+D,0BAA4B,SAAS7rB,GACxC,OACEjxC,KAAKi9D,wBAAwBhsB,IAC7BjxC,KAAKk9D,yBAAyBjsB,IAC9BjxC,KAAKm9D,eAAelsB,IACpBjxC,KAAKo9D,4BAA4BnsB,IACjCjxC,KAAKy8D,sCAAsCxrB,GAAO,KAChDA,EAAMkoB,SAAWn5D,KAAKq9D,oCAAoCpsB,IAC5DjxC,KAAKs9D,yBAAyBrsB,IAGlC8nB,GAAKmE,yBAA2B,SAASjsB,GACvC,IAAIjtC,EAAQitC,EAAM1pC,IAClB,GAAI0pC,EAAMoU,IAAI,IAAe,CAC3B,GAAIrlD,KAAKu9D,wBAAwBtsB,GAC/B,OAAO,EAETA,EAAM1pC,IAAMvD,EAEd,OAAO,GAET+0D,GAAKoE,eAAiB,SAASlsB,GAC7B,OAAwB,KAApBA,EAAMtP,YAA+Bu4B,GAAejpB,EAAMypB,eAC5DzpB,EAAMooB,aAAe,EACrBpoB,EAAMhO,WACC,IAMX81B,GAAKkE,wBAA0B,SAAShsB,GACtC,IAAI4oB,EAAK5oB,EAAMtP,UACf,OAAW,MAAPk4B,GACF5oB,EAAMooB,aAAe,EACrBpoB,EAAMhO,WACC,GAEE,MAAP42B,GACF5oB,EAAMooB,aAAe,GACrBpoB,EAAMhO,WACC,GAEE,MAAP42B,GACF5oB,EAAMooB,aAAe,GACrBpoB,EAAMhO,WACC,GAEE,MAAP42B,GACF5oB,EAAMooB,aAAe,GACrBpoB,EAAMhO,WACC,GAEE,MAAP42B,IACF5oB,EAAMooB,aAAe,GACrBpoB,EAAMhO,WACC,IAMX81B,GAAKwE,wBAA0B,SAAStsB,GACtC,IAAI4oB,EAAK5oB,EAAMtP,UACf,QAAIo4B,GAAgBF,KAClB5oB,EAAMooB,aAAeQ,EAAK,GAC1B5oB,EAAMhO,WACC,IAYX81B,GAAK0D,sCAAwC,SAASxrB,EAAOupB,QAC3C,IAAXA,IAAoBA,GAAS,GAElC,IAqCsBX,EArClB71D,EAAQitC,EAAM1pC,IACd4xD,EAAUqB,GAAUvpB,EAAMkoB,QAE9B,GAAIloB,EAAMoU,IAAI,KAAe,CAC3B,GAAIrlD,KAAKw9D,yBAAyBvsB,EAAO,GAAI,CAC3C,IAAIwsB,EAAOxsB,EAAMooB,aACjB,GAAIF,GAAWsE,GAAQ,OAAUA,GAAQ,MAAQ,CAC/C,IAAIC,EAAmBzsB,EAAM1pC,IAC7B,GAAI0pC,EAAMoU,IAAI,KAAiBpU,EAAMoU,IAAI,MAAiBrlD,KAAKw9D,yBAAyBvsB,EAAO,GAAI,CACjG,IAAI0sB,EAAQ1sB,EAAMooB,aAClB,GAAIsE,GAAS,OAAUA,GAAS,MAE9B,OADA1sB,EAAMooB,aAAiC,MAAjBoE,EAAO,QAAmBE,EAAQ,OAAU,OAC3D,EAGX1sB,EAAM1pC,IAAMm2D,EACZzsB,EAAMooB,aAAeoE,EAEvB,OAAO,EAET,GACEtE,GACAloB,EAAMoU,IAAI,MACVrlD,KAAK49D,oBAAoB3sB,IACzBA,EAAMoU,IAAI,QAaQwU,EAZH5oB,EAAMooB,eAaZ,GAAKQ,GAAM,SAXpB,OAAO,EAELV,GACFloB,EAAMgV,MAAM,0BAEdhV,EAAM1pC,IAAMvD,EAGd,OAAO,GAOT+0D,GAAKuE,yBAA2B,SAASrsB,GACvC,GAAIA,EAAMkoB,QACR,QAAIn5D,KAAKo8D,0BAA0BnrB,MAG/BA,EAAMoU,IAAI,MACZpU,EAAMooB,aAAe,IACd,GAKX,IAAIQ,EAAK5oB,EAAMtP,UACf,QAAW,KAAPk4B,GAAyB5oB,EAAMmoB,SAAkB,MAAPS,KAC5C5oB,EAAMooB,aAAeQ,EACrB5oB,EAAMhO,WACC,IAOX81B,GAAKiE,wBAA0B,SAAS/rB,GACtCA,EAAMooB,aAAe,EACrB,IAAIQ,EAAK5oB,EAAMtP,UACf,GAAIk4B,GAAM,IAAgBA,GAAM,GAAc,CAC5C,GACE5oB,EAAMooB,aAAe,GAAKpoB,EAAMooB,cAAgBQ,EAAK,IACrD5oB,EAAMhO,iBACE42B,EAAK5oB,EAAMtP,YAAc,IAAgBk4B,GAAM,IACzD,OAAO,EAET,OAAO,GAITd,GAAK8D,+BAAiC,SAAS5rB,GAC7C,IAAI4oB,EAAK5oB,EAAMtP,UAEf,GAyBF,SAAgCk4B,GAC9B,OACS,MAAPA,GACO,KAAPA,GACO,MAAPA,GACO,KAAPA,GACO,MAAPA,GACO,KAAPA,EAhCEgE,CAAuBhE,GAGzB,OAFA5oB,EAAMooB,cAAgB,EACtBpoB,EAAMhO,WACC,EAGT,GACEgO,EAAMkoB,SACNn5D,KAAK4N,QAAQsyC,aAAe,IACpB,KAAP2Z,GAA8B,MAAPA,GACxB,CAGA,GAFA5oB,EAAMooB,cAAgB,EACtBpoB,EAAMhO,UAEJgO,EAAMoU,IAAI,MACVrlD,KAAK89D,yCAAyC7sB,IAC9CA,EAAMoU,IAAI,KAEV,OAAO,EAETpU,EAAMgV,MAAM,yBAGd,OAAO,GAgBT8S,GAAK+E,yCAA2C,SAAS7sB,GACvD,IAAIjtC,EAAQitC,EAAM1pC,IAGlB,GAAIvH,KAAK+9D,8BAA8B9sB,IAAUA,EAAMoU,IAAI,IAAe,CACxE,IAAIxoD,EAAOo0C,EAAMqoB,gBACjB,GAAIt5D,KAAKg+D,+BAA+B/sB,GAAQ,CAC9C,IAAI1zC,EAAQ0zC,EAAMqoB,gBAElB,OADAt5D,KAAKi+D,2CAA2ChtB,EAAOp0C,EAAMU,IACtD,GAMX,GAHA0zC,EAAM1pC,IAAMvD,EAGRhE,KAAKk+D,yCAAyCjtB,GAAQ,CACxD,IAAIktB,EAAcltB,EAAMqoB,gBAExB,OADAt5D,KAAKo+D,0CAA0CntB,EAAOktB,IAC/C,EAET,OAAO,GAETpF,GAAKkF,2CAA6C,SAAShtB,EAAOp0C,EAAMU,GACjE+C,EAAI2wC,EAAMioB,kBAAkBV,UAAW37D,IACxCo0C,EAAMgV,MAAM,yBACXhV,EAAMioB,kBAAkBV,UAAU37D,GAAMkd,KAAKxc,IAC9C0zC,EAAMgV,MAAM,2BAElB8S,GAAKqF,0CAA4C,SAASntB,EAAOktB,GAC1DltB,EAAMioB,kBAAkBX,OAAOx+C,KAAKokD,IACrCltB,EAAMgV,MAAM,0BAKlB8S,GAAKgF,8BAAgC,SAAS9sB,GAC5C,IAAI4oB,EAAK,EAET,IADA5oB,EAAMqoB,gBAAkB,GACjBU,GAA+BH,EAAK5oB,EAAMtP,YAC/CsP,EAAMqoB,iBAAmBM,GAAkBC,GAC3C5oB,EAAMhO,UAER,MAAiC,KAA1BgO,EAAMqoB,iBAQfP,GAAKiF,+BAAiC,SAAS/sB,GAC7C,IAAI4oB,EAAK,EAET,IADA5oB,EAAMqoB,gBAAkB,GACjBW,GAAgCJ,EAAK5oB,EAAMtP,YAChDsP,EAAMqoB,iBAAmBM,GAAkBC,GAC3C5oB,EAAMhO,UAER,MAAiC,KAA1BgO,EAAMqoB,iBAQfP,GAAKmF,yCAA2C,SAASjtB,GACvD,OAAOjxC,KAAKg+D,+BAA+B/sB,IAI7C8nB,GAAK8C,yBAA2B,SAAS5qB,GACvC,GAAIA,EAAMoU,IAAI,IAAe,CAG3B,GAFApU,EAAMoU,IAAI,IACVrlD,KAAKq+D,mBAAmBptB,GACpBA,EAAMoU,IAAI,IACZ,OAAO,EAGTpU,EAAMgV,MAAM,gCAEd,OAAO,GAMT8S,GAAKsF,mBAAqB,SAASptB,GACjC,KAAOjxC,KAAKs+D,oBAAoBrtB,IAAQ,CACtC,IAAIsa,EAAOta,EAAMooB,aACjB,GAAIpoB,EAAMoU,IAAI,KAAiBrlD,KAAKs+D,oBAAoBrtB,GAAQ,CAC9D,IAAIua,EAAQva,EAAMooB,cACdpoB,EAAMkoB,UAAsB,IAAV5N,IAA0B,IAAXC,GACnCva,EAAMgV,MAAM,4BAEA,IAAVsF,IAA0B,IAAXC,GAAgBD,EAAOC,GACxCva,EAAMgV,MAAM,4CAQpB8S,GAAKuF,oBAAsB,SAASrtB,GAClC,IAAIjtC,EAAQitC,EAAM1pC,IAElB,GAAI0pC,EAAMoU,IAAI,IAAe,CAC3B,GAAIrlD,KAAKu+D,sBAAsBttB,GAC7B,OAAO,EAET,GAAIA,EAAMkoB,QAAS,CAEjB,IAAIqF,EAAOvtB,EAAMtP,WACJ,KAAT68B,GAAyBnE,GAAamE,KACxCvtB,EAAMgV,MAAM,wBAEdhV,EAAMgV,MAAM,kBAEdhV,EAAM1pC,IAAMvD,EAGd,IAAI61D,EAAK5oB,EAAMtP,UACf,OAAW,KAAPk4B,IACF5oB,EAAMooB,aAAeQ,EACrB5oB,EAAMhO,WACC,IAOX81B,GAAKwF,sBAAwB,SAASttB,GACpC,IAAIjtC,EAAQitC,EAAM1pC,IAElB,GAAI0pC,EAAMoU,IAAI,IAEZ,OADApU,EAAMooB,aAAe,GACd,EAGT,GAAIpoB,EAAMkoB,SAAWloB,EAAMoU,IAAI,IAE7B,OADApU,EAAMooB,aAAe,IACd,EAGT,IAAKpoB,EAAMkoB,SAAWloB,EAAMoU,IAAI,IAAe,CAC7C,GAAIrlD,KAAKy+D,6BAA6BxtB,GACpC,OAAO,EAETA,EAAM1pC,IAAMvD,EAGd,OACEhE,KAAK68D,+BAA+B5rB,IACpCjxC,KAAK88D,0BAA0B7rB,IAKnC8nB,GAAK0F,6BAA+B,SAASxtB,GAC3C,IAAI4oB,EAAK5oB,EAAMtP,UACf,SAAIu4B,GAAeL,IAAc,KAAPA,KACxB5oB,EAAMooB,aAAeQ,EAAK,GAC1B5oB,EAAMhO,WACC,IAMX81B,GAAKqE,4BAA8B,SAASnsB,GAC1C,IAAIjtC,EAAQitC,EAAM1pC,IAClB,GAAI0pC,EAAMoU,IAAI,KAAe,CAC3B,GAAIrlD,KAAKw9D,yBAAyBvsB,EAAO,GACvC,OAAO,EAELA,EAAMkoB,SACRloB,EAAMgV,MAAM,kBAEdhV,EAAM1pC,IAAMvD,EAEd,OAAO,GAIT+0D,GAAK2C,wBAA0B,SAASzqB,GACtC,IAAIjtC,EAAQitC,EAAM1pC,IACdsyD,EAAK,EAET,IADA5oB,EAAMooB,aAAe,EACda,GAAeL,EAAK5oB,EAAMtP,YAC/BsP,EAAMooB,aAAe,GAAKpoB,EAAMooB,cAAgBQ,EAAK,IACrD5oB,EAAMhO,UAER,OAAOgO,EAAM1pC,MAAQvD,GAOvB+0D,GAAK6E,oBAAsB,SAAS3sB,GAClC,IAAIjtC,EAAQitC,EAAM1pC,IACdsyD,EAAK,EAET,IADA5oB,EAAMooB,aAAe,EACdc,GAAWN,EAAK5oB,EAAMtP,YAC3BsP,EAAMooB,aAAe,GAAKpoB,EAAMooB,aAAee,GAASP,GACxD5oB,EAAMhO,UAER,OAAOgO,EAAM1pC,MAAQvD,GAqBvB+0D,GAAKsE,oCAAsC,SAASpsB,GAClD,GAAIjxC,KAAK0+D,qBAAqBztB,GAAQ,CACpC,IAAI0tB,EAAK1tB,EAAMooB,aACf,GAAIr5D,KAAK0+D,qBAAqBztB,GAAQ,CACpC,IAAI2tB,EAAK3tB,EAAMooB,aACXsF,GAAM,GAAK3+D,KAAK0+D,qBAAqBztB,GACvCA,EAAMooB,aAAoB,GAALsF,EAAe,EAALC,EAAS3tB,EAAMooB,aAE9CpoB,EAAMooB,aAAoB,EAALsF,EAASC,OAGhC3tB,EAAMooB,aAAesF,EAEvB,OAAO,EAET,OAAO,GAIT5F,GAAK2F,qBAAuB,SAASztB,GACnC,IAAI4oB,EAAK5oB,EAAMtP,UACf,OAAI04B,GAAaR,IACf5oB,EAAMooB,aAAeQ,EAAK,GAC1B5oB,EAAMhO,WACC,IAETgO,EAAMooB,aAAe,GACd,IASTN,GAAKyE,yBAA2B,SAASvsB,EAAO5tC,GAC9C,IAAIW,EAAQitC,EAAM1pC,IAClB0pC,EAAMooB,aAAe,EACrB,IAAK,IAAI/8D,EAAI,EAAGA,EAAI+G,IAAU/G,EAAG,CAC/B,IAAIu9D,EAAK5oB,EAAMtP,UACf,IAAKw4B,GAAWN,GAEd,OADA5oB,EAAM1pC,IAAMvD,GACL,EAETitC,EAAMooB,aAAe,GAAKpoB,EAAMooB,aAAee,GAASP,GACxD5oB,EAAMhO,UAER,OAAO,GAOT,IAAI47B,GAAQ,SAAezgE,GACzB4B,KAAKsB,KAAOlD,EAAEkD,KACdtB,KAAKzC,MAAQa,EAAEb,MACfyC,KAAKgE,MAAQ5F,EAAE4F,MACfhE,KAAK4D,IAAMxF,EAAEwF,IACTxF,EAAEwP,QAAQ+yC,YACV3gD,KAAK8iC,IAAM,IAAI+c,EAAezhD,EAAGA,EAAEgjD,SAAUhjD,EAAEijD,SAC/CjjD,EAAEwP,QAAQgqC,SACV53C,KAAKsd,MAAQ,CAAClf,EAAE4F,MAAO5F,EAAEwF,OAK3Bk7D,GAAOrd,GAAOvjD,UA6clB,SAAS6gE,GAAe7+D,GACtB,MAAsB,oBAAX8+D,OACF,KAIFA,OAAO9+D,EAAI2d,QAAQ,KAAM,KA+DlC,SAASohD,GAAoBt9D,GAE3B,OAAIA,GAAQ,MAAiBkG,OAAOgwB,aAAal2B,IACjDA,GAAQ,MACDkG,OAAOgwB,aAA4B,OAAdl2B,GAAQ,IAA8B,OAAR,KAAPA,KAlhBrDm9D,GAAKn1D,KAAO,SAASu1D,IACdA,GAAiCl/D,KAAKsB,KAAK64C,SAAWn6C,KAAK+hD,aAC5D/hD,KAAKomD,iBAAiBpmD,KAAKgE,MAAO,8BAAgChE,KAAKsB,KAAK64C,SAC5En6C,KAAK4N,QAAQgzC,SACb5gD,KAAK4N,QAAQgzC,QAAQ,IAAIie,GAAM7+D,OAEnCA,KAAKsiD,WAAatiD,KAAK4D,IACvB5D,KAAKqiD,aAAeriD,KAAKgE,MACzBhE,KAAKmiD,cAAgBniD,KAAKqhD,OAC1BrhD,KAAKoiD,gBAAkBpiD,KAAKohD,SAC5BphD,KAAK6jD,aAGPib,GAAKK,SAAW,WAEd,OADAn/D,KAAK2J,OACE,IAAIk1D,GAAM7+D,OAIG,qBAAX3C,SACPyhE,GAAKzhE,OAAO0L,UAAY,WACxB,IAAI+jD,EAAS9sD,KAEb,MAAO,CACL2J,KAAM,WACJ,IAAIzK,EAAQ4tD,EAAOqS,WACnB,MAAO,CACLh2D,KAAMjK,EAAMoC,OAASw5C,EAAME,IAC3Bz9C,MAAO2B,OASjB4/D,GAAKrH,WAAa,WAChB,OAAOz3D,KAAK2rB,QAAQ3rB,KAAK2rB,QAAQtoB,OAAS,IAM5Cy7D,GAAKjb,UAAY,WACf,IAAI4T,EAAaz3D,KAAKy3D,aAKtB,OAJKA,GAAeA,EAAWjB,eAAiBx2D,KAAKo/D,YAErDp/D,KAAKgE,MAAQhE,KAAKuH,IACdvH,KAAK4N,QAAQ+yC,YAAa3gD,KAAKohD,SAAWphD,KAAKkiD,eAC/CliD,KAAKuH,KAAOvH,KAAKggD,MAAM38C,OAAiBrD,KAAKq/D,YAAYvkB,EAAME,KAE/Dyc,EAAWhB,SAAmBgB,EAAWhB,SAASz2D,WAC/CA,KAAKs/D,UAAUt/D,KAAKu/D,sBAG7BT,GAAKQ,UAAY,SAAS39D,GAGxB,OAAIk4C,EAAkBl4C,EAAM3B,KAAK4N,QAAQsyC,aAAe,IAAe,KAATv+C,EACnD3B,KAAKw/D,WAETx/D,KAAKy/D,iBAAiB99D,IAG/Bm9D,GAAKS,kBAAoB,WACvB,IAAI59D,EAAO3B,KAAKggD,MAAMlyB,WAAW9tB,KAAKuH,KACtC,OAAI5F,GAAQ,OAAUA,GAAQ,MAAiBA,GAEvCA,GAAQ,IADL3B,KAAKggD,MAAMlyB,WAAW9tB,KAAKuH,IAAM,GACf,UAG/Bu3D,GAAKY,iBAAmB,WACtB,IAMMh5D,EANF06C,EAAWphD,KAAK4N,QAAQizC,WAAa7gD,KAAKkiD,cAC1Cl+C,EAAQhE,KAAKuH,IAAK3D,EAAM5D,KAAKggD,MAAMn9B,QAAQ,KAAM7iB,KAAKuH,KAAO,GAGjE,IAFa,IAAT3D,GAAc5D,KAAKimD,MAAMjmD,KAAKuH,IAAM,EAAG,wBAC3CvH,KAAKuH,IAAM3D,EAAM,EACb5D,KAAK4N,QAAQ+yC,UAGf,IAFAzB,EAAW9H,UAAYpzC,GAEf0C,EAAQw4C,EAAWrd,KAAK7hC,KAAKggD,SAAWt5C,EAAM+oB,MAAQzvB,KAAKuH,OAC/DvH,KAAKiiD,QACPjiD,KAAKgiD,UAAYt7C,EAAM+oB,MAAQ/oB,EAAM,GAAGrD,OAGxCrD,KAAK4N,QAAQizC,WACb7gD,KAAK4N,QAAQizC,WAAU,EAAM7gD,KAAKggD,MAAMzgC,MAAMvb,EAAQ,EAAGJ,GAAMI,EAAOhE,KAAKuH,IACtD65C,EAAUphD,KAAKkiD,gBAG1C4c,GAAK7b,gBAAkB,SAAS0c,GAI9B,IAHA,IAAI37D,EAAQhE,KAAKuH,IACb65C,EAAWphD,KAAK4N,QAAQizC,WAAa7gD,KAAKkiD,cAC1C2X,EAAK75D,KAAKggD,MAAMlyB,WAAW9tB,KAAKuH,KAAOo4D,GACpC3/D,KAAKuH,IAAMvH,KAAKggD,MAAM38C,SAAW87C,EAAU0a,IAChDA,EAAK75D,KAAKggD,MAAMlyB,aAAa9tB,KAAKuH,KAEhCvH,KAAK4N,QAAQizC,WACb7gD,KAAK4N,QAAQizC,WAAU,EAAO7gD,KAAKggD,MAAMzgC,MAAMvb,EAAQ27D,EAAW3/D,KAAKuH,KAAMvD,EAAOhE,KAAKuH,IACpE65C,EAAUphD,KAAKkiD,gBAM1C4c,GAAKM,UAAY,WACfQ,EAAM,KAAO5/D,KAAKuH,IAAMvH,KAAKggD,MAAM38C,QAAQ,CACzC,IAAIw2D,EAAK75D,KAAKggD,MAAMlyB,WAAW9tB,KAAKuH,KACpC,OAAQsyD,GACR,KAAK,GAAI,KAAK,MACV75D,KAAKuH,IACP,MACF,KAAK,GACyC,KAAxCvH,KAAKggD,MAAMlyB,WAAW9tB,KAAKuH,IAAM,MACjCvH,KAAKuH,IAEX,KAAK,GAAI,KAAK,KAAM,KAAK,OACrBvH,KAAKuH,IACHvH,KAAK4N,QAAQ+yC,cACb3gD,KAAKiiD,QACPjiD,KAAKgiD,UAAYhiD,KAAKuH,KAExB,MACF,KAAK,GACH,OAAQvH,KAAKggD,MAAMlyB,WAAW9tB,KAAKuH,IAAM,IACzC,KAAK,GACHvH,KAAK0/D,mBACL,MACF,KAAK,GACH1/D,KAAKijD,gBAAgB,GACrB,MACF,QACE,MAAM2c,EAER,MACF,QACE,KAAI/F,EAAK,GAAKA,EAAK,IAAMA,GAAM,MAAQxa,EAAmBtlC,KAAKlS,OAAOgwB,aAAagiC,KAGjF,MAAM+F,IAFJ5/D,KAAKuH,OAafu3D,GAAKO,YAAc,SAAS/9D,EAAMozB,GAChC10B,KAAK4D,IAAM5D,KAAKuH,IACZvH,KAAK4N,QAAQ+yC,YAAa3gD,KAAKqhD,OAASrhD,KAAKkiD,eACjD,IAAIsV,EAAWx3D,KAAKsB,KACpBtB,KAAKsB,KAAOA,EACZtB,KAAKzC,MAAQm3B,EAEb10B,KAAK06C,cAAc8c,IAYrBsH,GAAKe,cAAgB,WACnB,IAAIl2D,EAAO3J,KAAKggD,MAAMlyB,WAAW9tB,KAAKuH,IAAM,GAC5C,GAAIoC,GAAQ,IAAMA,GAAQ,GAAM,OAAO3J,KAAK8/D,YAAW,GACvD,IAAIC,EAAQ//D,KAAKggD,MAAMlyB,WAAW9tB,KAAKuH,IAAM,GAC7C,OAAIvH,KAAK4N,QAAQsyC,aAAe,GAAc,KAATv2C,GAAyB,KAAVo2D,GAClD//D,KAAKuH,KAAO,EACLvH,KAAKq/D,YAAYvkB,EAAMkB,cAE5Bh8C,KAAKuH,IACAvH,KAAKq/D,YAAYvkB,EAAMY,OAIlCojB,GAAKkB,gBAAkB,WACrB,IAAIr2D,EAAO3J,KAAKggD,MAAMlyB,WAAW9tB,KAAKuH,IAAM,GAC5C,OAAIvH,KAAKwiD,eAAiBxiD,KAAKuH,IAAYvH,KAAK4yD,cACnC,KAATjpD,EAAsB3J,KAAKigE,SAASnlB,EAAMliC,OAAQ,GAC/C5Y,KAAKigE,SAASnlB,EAAMiC,MAAO,IAGpC+hB,GAAKoB,0BAA4B,SAASv+D,GACxC,IAAIgI,EAAO3J,KAAKggD,MAAMlyB,WAAW9tB,KAAKuH,IAAM,GACxCwjB,EAAO,EACPo1C,EAAqB,KAATx+D,EAAcm5C,EAAMgC,KAAOhC,EAAM+B,OASjD,OANI78C,KAAK4N,QAAQsyC,aAAe,GAAc,KAATv+C,GAAwB,KAATgI,MAChDohB,EACFo1C,EAAYrlB,EAAMkC,SAClBrzC,EAAO3J,KAAKggD,MAAMlyB,WAAW9tB,KAAKuH,IAAM,IAG7B,KAAToC,EAAsB3J,KAAKigE,SAASnlB,EAAMliC,OAAQmS,EAAO,GACtD/qB,KAAKigE,SAASE,EAAWp1C,IAGlC+zC,GAAKsB,mBAAqB,SAASz+D,GACjC,IAAIgI,EAAO3J,KAAKggD,MAAMlyB,WAAW9tB,KAAKuH,IAAM,GAC5C,GAAIoC,IAAShI,EAAM,CACjB,GAAI3B,KAAK4N,QAAQsyC,aAAe,GAE9B,GAAc,KADFlgD,KAAKggD,MAAMlyB,WAAW9tB,KAAKuH,IAAM,GACzB,OAAOvH,KAAKigE,SAASnlB,EAAMliC,OAAQ,GAEzD,OAAO5Y,KAAKigE,SAAkB,MAATt+D,EAAem5C,EAAMsB,UAAYtB,EAAMuB,WAAY,GAE1E,OAAa,KAAT1yC,EAAsB3J,KAAKigE,SAASnlB,EAAMliC,OAAQ,GAC/C5Y,KAAKigE,SAAkB,MAATt+D,EAAem5C,EAAMwB,UAAYxB,EAAM0B,WAAY,IAG1EsiB,GAAKuB,gBAAkB,WAErB,OAAa,KADFrgE,KAAKggD,MAAMlyB,WAAW9tB,KAAKuH,IAAM,GAClBvH,KAAKigE,SAASnlB,EAAMliC,OAAQ,GAC/C5Y,KAAKigE,SAASnlB,EAAMyB,WAAY,IAGzCuiB,GAAKwB,mBAAqB,SAAS3+D,GACjC,IAAIgI,EAAO3J,KAAKggD,MAAMlyB,WAAW9tB,KAAKuH,IAAM,GAC5C,OAAIoC,IAAShI,EACE,KAATgI,GAAgB3J,KAAKyiD,UAAoD,KAAxCziD,KAAKggD,MAAMlyB,WAAW9tB,KAAKuH,IAAM,IAC7C,IAApBvH,KAAKsiD,aAAoBrD,EAAUllC,KAAK/Z,KAAKggD,MAAMzgC,MAAMvf,KAAKsiD,WAAYtiD,KAAKuH,MAM7EvH,KAAKigE,SAASnlB,EAAMqB,OAAQ,IAJjCn8C,KAAKijD,gBAAgB,GACrBjjD,KAAKo/D,YACEp/D,KAAK6jD,aAIH,KAATl6C,EAAsB3J,KAAKigE,SAASnlB,EAAMliC,OAAQ,GAC/C5Y,KAAKigE,SAASnlB,EAAM8B,QAAS,IAGtCkiB,GAAKyB,gBAAkB,SAAS5+D,GAC9B,IAAIgI,EAAO3J,KAAKggD,MAAMlyB,WAAW9tB,KAAKuH,IAAM,GACxCwjB,EAAO,EACX,OAAIphB,IAAShI,GACXopB,EAAgB,KAATppB,GAAuD,KAAxC3B,KAAKggD,MAAMlyB,WAAW9tB,KAAKuH,IAAM,GAAY,EAAI,EACxB,KAA3CvH,KAAKggD,MAAMlyB,WAAW9tB,KAAKuH,IAAMwjB,GAAuB/qB,KAAKigE,SAASnlB,EAAMliC,OAAQmS,EAAO,GACxF/qB,KAAKigE,SAASnlB,EAAM6B,SAAU5xB,IAE1B,KAATphB,GAAwB,KAAThI,GAAgB3B,KAAKyiD,UAAoD,KAAxCziD,KAAKggD,MAAMlyB,WAAW9tB,KAAKuH,IAAM,IACzC,KAAxCvH,KAAKggD,MAAMlyB,WAAW9tB,KAAKuH,IAAM,IAMxB,KAAToC,IAAeohB,EAAO,GACnB/qB,KAAKigE,SAASnlB,EAAM4B,WAAY3xB,KALrC/qB,KAAKijD,gBAAgB,GACrBjjD,KAAKo/D,YACEp/D,KAAK6jD,cAMhBib,GAAK0B,kBAAoB,SAAS7+D,GAChC,IAAIgI,EAAO3J,KAAKggD,MAAMlyB,WAAW9tB,KAAKuH,IAAM,GAC5C,OAAa,KAAToC,EAAsB3J,KAAKigE,SAASnlB,EAAM2B,SAAkD,KAAxCz8C,KAAKggD,MAAMlyB,WAAW9tB,KAAKuH,IAAM,GAAY,EAAI,GAC5F,KAAT5F,GAAwB,KAATgI,GAAe3J,KAAK4N,QAAQsyC,aAAe,GAC5DlgD,KAAKuH,KAAO,EACLvH,KAAKq/D,YAAYvkB,EAAMe,QAEzB77C,KAAKigE,SAAkB,KAATt+D,EAAcm5C,EAAM3oB,GAAK2oB,EAAMt0C,OAAQ,IAG9Ds4D,GAAK2B,mBAAqB,WACxB,IAAIvgB,EAAclgD,KAAK4N,QAAQsyC,YAC/B,GAAIA,GAAe,GAAI,CACrB,IAAIv2C,EAAO3J,KAAKggD,MAAMlyB,WAAW9tB,KAAKuH,IAAM,GAC5C,GAAa,KAAToC,EAAa,CACf,IAAIo2D,EAAQ//D,KAAKggD,MAAMlyB,WAAW9tB,KAAKuH,IAAM,GAC7C,GAAIw4D,EAAQ,IAAMA,EAAQ,GAAM,OAAO//D,KAAKigE,SAASnlB,EAAMc,YAAa,GAE1E,GAAa,KAATjyC,EAAa,CACf,GAAIu2C,GAAe,GAEjB,GAAgB,KADFlgD,KAAKggD,MAAMlyB,WAAW9tB,KAAKuH,IAAM,GACzB,OAAOvH,KAAKigE,SAASnlB,EAAMliC,OAAQ,GAE3D,OAAO5Y,KAAKigE,SAASnlB,EAAMmC,SAAU,IAGzC,OAAOj9C,KAAKigE,SAASnlB,EAAMa,SAAU,IAGvCmjB,GAAKW,iBAAmB,SAAS99D,GAC/B,OAAQA,GAGR,KAAK,GACH,OAAO3B,KAAK6/D,gBAGd,KAAK,GAAgB,QAAV7/D,KAAKuH,IAAYvH,KAAKq/D,YAAYvkB,EAAMO,QACnD,KAAK,GAAgB,QAAVr7C,KAAKuH,IAAYvH,KAAKq/D,YAAYvkB,EAAMQ,QACnD,KAAK,GAAgB,QAAVt7C,KAAKuH,IAAYvH,KAAKq/D,YAAYvkB,EAAMU,MACnD,KAAK,GAAgB,QAAVx7C,KAAKuH,IAAYvH,KAAKq/D,YAAYvkB,EAAMS,OACnD,KAAK,GAAgB,QAAVv7C,KAAKuH,IAAYvH,KAAKq/D,YAAYvkB,EAAMG,UACnD,KAAK,GAAgB,QAAVj7C,KAAKuH,IAAYvH,KAAKq/D,YAAYvkB,EAAMI,UACnD,KAAK,IAAiB,QAAVl7C,KAAKuH,IAAYvH,KAAKq/D,YAAYvkB,EAAMK,QACpD,KAAK,IAAiB,QAAVn7C,KAAKuH,IAAYvH,KAAKq/D,YAAYvkB,EAAMM,QACpD,KAAK,GAAgB,QAAVp7C,KAAKuH,IAAYvH,KAAKq/D,YAAYvkB,EAAMW,OAEnD,KAAK,GACH,GAAIz7C,KAAK4N,QAAQsyC,YAAc,EAAK,MAEpC,QADElgD,KAAKuH,IACAvH,KAAKq/D,YAAYvkB,EAAMmB,WAEhC,KAAK,GACH,IAAItyC,EAAO3J,KAAKggD,MAAMlyB,WAAW9tB,KAAKuH,IAAM,GAC5C,GAAa,MAAToC,GAAyB,KAATA,EAAe,OAAO3J,KAAK0gE,gBAAgB,IAC/D,GAAI1gE,KAAK4N,QAAQsyC,aAAe,EAAG,CACjC,GAAa,MAATv2C,GAAyB,KAATA,EAAe,OAAO3J,KAAK0gE,gBAAgB,GAC/D,GAAa,KAAT/2D,GAAwB,KAATA,EAAe,OAAO3J,KAAK0gE,gBAAgB,GAKlE,KAAK,GAAI,KAAK,GAAI,KAAK,GAAI,KAAK,GAAI,KAAK,GAAI,KAAK,GAAI,KAAK,GAAI,KAAK,GAAI,KAAK,GAC3E,OAAO1gE,KAAK8/D,YAAW,GAGzB,KAAK,GAAI,KAAK,GACZ,OAAO9/D,KAAK2gE,WAAWh/D,GAOzB,KAAK,GACH,OAAO3B,KAAKggE,kBAEd,KAAK,GAAI,KAAK,GACZ,OAAOhgE,KAAKkgE,0BAA0Bv+D,GAExC,KAAK,IAAK,KAAK,GACb,OAAO3B,KAAKogE,mBAAmBz+D,GAEjC,KAAK,GACH,OAAO3B,KAAKqgE,kBAEd,KAAK,GAAI,KAAK,GACZ,OAAOrgE,KAAKsgE,mBAAmB3+D,GAEjC,KAAK,GAAI,KAAK,GACZ,OAAO3B,KAAKugE,gBAAgB5+D,GAE9B,KAAK,GAAI,KAAK,GACZ,OAAO3B,KAAKwgE,kBAAkB7+D,GAEhC,KAAK,GACH,OAAO3B,KAAKygE,qBAEd,KAAK,IACH,OAAOzgE,KAAKigE,SAASnlB,EAAMt0C,OAAQ,GAGrCxG,KAAKimD,MAAMjmD,KAAKuH,IAAK,yBAA2B03D,GAAoBt9D,GAAQ,MAG9Em9D,GAAKmB,SAAW,SAAS3+D,EAAMypB,GAC7B,IAAI7qB,EAAMF,KAAKggD,MAAMzgC,MAAMvf,KAAKuH,IAAKvH,KAAKuH,IAAMwjB,GAEhD,OADA/qB,KAAKuH,KAAOwjB,EACL/qB,KAAKq/D,YAAY/9D,EAAMpB,IAGhC4+D,GAAKlM,WAAa,WAEhB,IADA,IAAInrD,EAASm5D,EAAS58D,EAAQhE,KAAKuH,MAC1B,CACHvH,KAAKuH,KAAOvH,KAAKggD,MAAM38C,QAAUrD,KAAKimD,MAAMjiD,EAAO,mCACvD,IAAI61D,EAAK75D,KAAKggD,MAAM9L,OAAOl0C,KAAKuH,KAEhC,GADI03C,EAAUllC,KAAK8/C,IAAO75D,KAAKimD,MAAMjiD,EAAO,mCACvCyD,EAKIA,GAAU,MALL,CACZ,GAAW,MAAPoyD,EAAc+G,GAAU,OACvB,GAAW,MAAP/G,GAAc+G,EAAWA,GAAU,OACvC,GAAW,MAAP/G,IAAe+G,EAAW,MACnCn5D,EAAiB,OAAPoyD,IAEV75D,KAAKuH,IAET,IAAIy9B,EAAUhlC,KAAKggD,MAAMzgC,MAAMvb,EAAOhE,KAAKuH,OACzCvH,KAAKuH,IACP,IAAIs5D,EAAa7gE,KAAKuH,IAClBy8C,EAAQhkD,KAAK8gE,YACb9gE,KAAK+hD,aAAe/hD,KAAKylD,WAAWob,GAGxC,IAAI5vB,EAAQjxC,KAAKojD,cAAgBpjD,KAAKojD,YAAc,IAAI4V,GAAsBh5D,OAC9EixC,EAAMsC,MAAMvvC,EAAOghC,EAASgf,GAC5BhkD,KAAK26D,oBAAoB1pB,GACzBjxC,KAAK66D,sBAAsB5pB,GAG3B,IAAI1zC,EAAQ,KACZ,IACEA,EAAQ,IAAImyB,OAAOsV,EAASgf,GAC5B,MAAO56C,IAKT,OAAOpJ,KAAKq/D,YAAYvkB,EAAMC,OAAQ,CAAC/V,QAASA,EAASgf,MAAOA,EAAOzmD,MAAOA,KAOhFuhE,GAAKiC,QAAU,SAASC,EAAO/zC,EAAKg0C,GAUlC,IARA,IAAIC,EAAkBlhE,KAAK4N,QAAQsyC,aAAe,SAAcv0C,IAARshB,EAKpDk0C,EAA8BF,GAAsE,KAApCjhE,KAAKggD,MAAMlyB,WAAW9tB,KAAKuH,KAE3FvD,EAAQhE,KAAKuH,IAAK65D,EAAQ,EAAGC,EAAW,EACnC/kE,EAAI,EAAG8M,EAAW,MAAP6jB,EAAc+P,IAAW/P,EAAK3wB,EAAI8M,IAAK9M,IAAK0D,KAAKuH,IAAK,CACxE,IAAI5F,EAAO3B,KAAKggD,MAAMlyB,WAAW9tB,KAAKuH,KAAMmtB,OAAO,EAEnD,GAAIwsC,GAA4B,KAATv/D,EACjBw/D,GAA+BnhE,KAAKomD,iBAAiBpmD,KAAKuH,IAAK,qEAClD,KAAb85D,GAAmBrhE,KAAKomD,iBAAiBpmD,KAAKuH,IAAK,oDAC7C,IAANjL,GAAW0D,KAAKomD,iBAAiBpmD,KAAKuH,IAAK,2DAC/C85D,EAAW1/D,MAJb,CAYA,IAJkB+yB,EAAd/yB,GAAQ,GAAYA,EAAO,GAAK,GAC3BA,GAAQ,GAAYA,EAAO,GAAK,GAChCA,GAAQ,IAAMA,GAAQ,GAAYA,EAAO,GACrCq7B,MACFgkC,EAAS,MACpBK,EAAW1/D,EACXy/D,EAAQA,EAAQJ,EAAQtsC,GAI1B,OADIwsC,GAAgC,KAAbG,GAAmBrhE,KAAKomD,iBAAiBpmD,KAAKuH,IAAM,EAAG,0DAC1EvH,KAAKuH,MAAQvD,GAAgB,MAAPipB,GAAejtB,KAAKuH,IAAMvD,IAAUipB,EAAc,KAErEm0C,GAqBTtC,GAAK4B,gBAAkB,SAASM,GAC9B,IAAIh9D,EAAQhE,KAAKuH,IACjBvH,KAAKuH,KAAO,EACZ,IAAImtB,EAAM10B,KAAK+gE,QAAQC,GAMvB,OALW,MAAPtsC,GAAe10B,KAAKimD,MAAMjmD,KAAKgE,MAAQ,EAAG,4BAA8Bg9D,GACxEhhE,KAAK4N,QAAQsyC,aAAe,IAA0C,MAApClgD,KAAKggD,MAAMlyB,WAAW9tB,KAAKuH,MAC/DmtB,EAAMqqC,GAAe/+D,KAAKggD,MAAMzgC,MAAMvb,EAAOhE,KAAKuH,QAChDvH,KAAKuH,KACEsyC,EAAkB75C,KAAKu/D,sBAAwBv/D,KAAKimD,MAAMjmD,KAAKuH,IAAK,oCACxEvH,KAAKq/D,YAAYvkB,EAAMt+B,IAAKkY,IAKrCoqC,GAAKgB,WAAa,SAASwB,GACzB,IAAIt9D,EAAQhE,KAAKuH,IACZ+5D,GAAuD,OAAtCthE,KAAK+gE,QAAQ,QAAIp1D,GAAW,IAAkB3L,KAAKimD,MAAMjiD,EAAO,kBACtF,IAAIu9D,EAAQvhE,KAAKuH,IAAMvD,GAAS,GAAsC,KAAjChE,KAAKggD,MAAMlyB,WAAW9pB,GACvDu9D,GAASvhE,KAAKisC,QAAUjsC,KAAKimD,MAAMjiD,EAAO,kBAC9C,IAAI2F,EAAO3J,KAAKggD,MAAMlyB,WAAW9tB,KAAKuH,KACtC,IAAKg6D,IAAUD,GAAiBthE,KAAK4N,QAAQsyC,aAAe,IAAe,MAATv2C,EAAc,CAC9E,IAAI63D,EAAQzC,GAAe/+D,KAAKggD,MAAMzgC,MAAMvb,EAAOhE,KAAKuH,MAGxD,QAFEvH,KAAKuH,IACHsyC,EAAkB75C,KAAKu/D,sBAAwBv/D,KAAKimD,MAAMjmD,KAAKuH,IAAK,oCACjEvH,KAAKq/D,YAAYvkB,EAAMt+B,IAAKglD,GAEjCD,GAAS,OAAOxnD,KAAK/Z,KAAKggD,MAAMzgC,MAAMvb,EAAOhE,KAAKuH,QAASg6D,GAAQ,GAC1D,KAAT53D,GAAgB43D,MAChBvhE,KAAKuH,IACPvH,KAAK+gE,QAAQ,IACbp3D,EAAO3J,KAAKggD,MAAMlyB,WAAW9tB,KAAKuH,MAEtB,KAAToC,GAAwB,MAATA,GAAkB43D,IAEvB,MADb53D,EAAO3J,KAAKggD,MAAMlyB,aAAa9tB,KAAKuH,OACR,KAAToC,KAAiB3J,KAAKuH,IAChB,OAArBvH,KAAK+gE,QAAQ,KAAgB/gE,KAAKimD,MAAMjiD,EAAO,mBAEjD61C,EAAkB75C,KAAKu/D,sBAAwBv/D,KAAKimD,MAAMjmD,KAAKuH,IAAK,oCAExE,IAzDsBrH,EAyDlBw0B,GAzDkBx0B,EAyDGF,KAAKggD,MAAMzgC,MAAMvb,EAAOhE,KAAKuH,KAAMg6D,EAvDnDlrC,SAASn2B,EAAK,GAIhBuhE,WAAWvhE,EAAI2d,QAAQ,KAAM,MAoDpC,OAAO7d,KAAKq/D,YAAYvkB,EAAMt+B,IAAKkY,IAKrCoqC,GAAK4C,cAAgB,WACnB,IAA0C//D,EAE1C,GAAW,MAFF3B,KAAKggD,MAAMlyB,WAAW9tB,KAAKuH,KAEpB,CACVvH,KAAK4N,QAAQsyC,YAAc,GAAKlgD,KAAKylD,aACzC,IAAIkc,IAAY3hE,KAAKuH,IACrB5F,EAAO3B,KAAK4hE,YAAY5hE,KAAKggD,MAAMn9B,QAAQ,IAAK7iB,KAAKuH,KAAOvH,KAAKuH,OAC/DvH,KAAKuH,IACH5F,EAAO,SAAY3B,KAAK6hE,mBAAmBF,EAAS,iCAExDhgE,EAAO3B,KAAK4hE,YAAY,GAE1B,OAAOjgE,GAUTm9D,GAAK6B,WAAa,SAASmB,GAEzB,IADA,IAAIt+D,EAAM,GAAIu+D,IAAe/hE,KAAKuH,MACzB,CACHvH,KAAKuH,KAAOvH,KAAKggD,MAAM38C,QAAUrD,KAAKimD,MAAMjmD,KAAKgE,MAAO,gCAC5D,IAAI61D,EAAK75D,KAAKggD,MAAMlyB,WAAW9tB,KAAKuH,KACpC,GAAIsyD,IAAOiI,EAAS,MACT,KAAPjI,GACFr2D,GAAOxD,KAAKggD,MAAMzgC,MAAMwiD,EAAY/hE,KAAKuH,KACzC/D,GAAOxD,KAAKgiE,iBAAgB,GAC5BD,EAAa/hE,KAAKuH,MAEd43C,EAAU0a,EAAI75D,KAAK4N,QAAQsyC,aAAe,KAAOlgD,KAAKimD,MAAMjmD,KAAKgE,MAAO,kCAC1EhE,KAAKuH,KAIX,OADA/D,GAAOxD,KAAKggD,MAAMzgC,MAAMwiD,EAAY/hE,KAAKuH,OAClCvH,KAAKq/D,YAAYvkB,EAAM5mB,OAAQ1wB,IAKxC,IAAIy+D,GAAgC,GAEpCnD,GAAK7H,qBAAuB,WAC1Bj3D,KAAKkiE,mBAAoB,EACzB,IACEliE,KAAKmiE,gBACL,MAAO1jE,GACP,GAAIA,IAAQwjE,GAGV,MAAMxjE,EAFNuB,KAAKoiE,2BAMTpiE,KAAKkiE,mBAAoB,GAG3BpD,GAAK+C,mBAAqB,SAASQ,EAAUj/C,GAC3C,GAAIpjB,KAAKkiE,mBAAqBliE,KAAK4N,QAAQsyC,aAAe,EACxD,MAAM+hB,GAENjiE,KAAKimD,MAAMoc,EAAUj/C,IAIzB07C,GAAKqD,cAAgB,WAEnB,IADA,IAAI3+D,EAAM,GAAIu+D,EAAa/hE,KAAKuH,MACvB,CACHvH,KAAKuH,KAAOvH,KAAKggD,MAAM38C,QAAUrD,KAAKimD,MAAMjmD,KAAKgE,MAAO,yBAC5D,IAAI61D,EAAK75D,KAAKggD,MAAMlyB,WAAW9tB,KAAKuH,KACpC,GAAW,KAAPsyD,GAAoB,KAAPA,GAAqD,MAAxC75D,KAAKggD,MAAMlyB,WAAW9tB,KAAKuH,IAAM,GAC7D,OAAIvH,KAAKuH,MAAQvH,KAAKgE,OAAUhE,KAAKsB,OAASw5C,EAAMgB,UAAY97C,KAAKsB,OAASw5C,EAAMiB,iBASpFv4C,GAAOxD,KAAKggD,MAAMzgC,MAAMwiD,EAAY/hE,KAAKuH,KAClCvH,KAAKq/D,YAAYvkB,EAAMgB,SAAUt4C,IAT3B,KAAPq2D,GACF75D,KAAKuH,KAAO,EACLvH,KAAKq/D,YAAYvkB,EAAMoB,kBAE5Bl8C,KAAKuH,IACAvH,KAAKq/D,YAAYvkB,EAAMmB,YAMpC,GAAW,KAAP4d,EACFr2D,GAAOxD,KAAKggD,MAAMzgC,MAAMwiD,EAAY/hE,KAAKuH,KACzC/D,GAAOxD,KAAKgiE,iBAAgB,GAC5BD,EAAa/hE,KAAKuH,SACb,GAAI43C,EAAU0a,GAAK,CAGxB,OAFAr2D,GAAOxD,KAAKggD,MAAMzgC,MAAMwiD,EAAY/hE,KAAKuH,OACvCvH,KAAKuH,IACCsyD,GACR,KAAK,GACqC,KAApC75D,KAAKggD,MAAMlyB,WAAW9tB,KAAKuH,QAAiBvH,KAAKuH,IACvD,KAAK,GACH/D,GAAO,KACP,MACF,QACEA,GAAOqE,OAAOgwB,aAAagiC,GAGzB75D,KAAK4N,QAAQ+yC,cACb3gD,KAAKiiD,QACPjiD,KAAKgiD,UAAYhiD,KAAKuH,KAExBw6D,EAAa/hE,KAAKuH,UAEhBvH,KAAKuH,MAMbu3D,GAAKsD,yBAA2B,WAC9B,KAAOpiE,KAAKuH,IAAMvH,KAAKggD,MAAM38C,OAAQrD,KAAKuH,MACxC,OAAQvH,KAAKggD,MAAMhgD,KAAKuH,MACxB,IAAK,OACDvH,KAAKuH,IACP,MAEF,IAAK,IACH,GAAiC,MAA7BvH,KAAKggD,MAAMhgD,KAAKuH,IAAM,GACxB,MAIJ,IAAK,IACH,OAAOvH,KAAKq/D,YAAYvkB,EAAMiB,gBAAiB/7C,KAAKggD,MAAMzgC,MAAMvf,KAAKgE,MAAOhE,KAAKuH,MAKrFvH,KAAKimD,MAAMjmD,KAAKgE,MAAO,0BAKzB86D,GAAKkD,gBAAkB,SAASM,GAC9B,IAAIzI,EAAK75D,KAAKggD,MAAMlyB,aAAa9tB,KAAKuH,KAEtC,SADEvH,KAAKuH,IACCsyD,GACR,KAAK,IAAK,MAAO,KACjB,KAAK,IAAK,MAAO,KACjB,KAAK,IAAK,OAAOhyD,OAAOgwB,aAAa73B,KAAK4hE,YAAY,IACtD,KAAK,IAAK,OAAO3C,GAAoBj/D,KAAK0hE,iBAC1C,KAAK,IAAK,MAAO,KACjB,KAAK,GAAI,MAAO,KAChB,KAAK,IAAK,MAAO,KACjB,KAAK,IAAK,MAAO,KACjB,KAAK,GAA4C,KAApC1hE,KAAKggD,MAAMlyB,WAAW9tB,KAAKuH,QAAiBvH,KAAKuH,IAC9D,KAAK,GAEH,OADIvH,KAAK4N,QAAQ+yC,YAAa3gD,KAAKgiD,UAAYhiD,KAAKuH,MAAOvH,KAAKiiD,SACzD,GACT,KAAK,GACL,KAAK,GACH,GAAIqgB,EAAY,CACd,IAAIX,EAAU3hE,KAAKuH,IAAM,EAOzB,OALAvH,KAAK6hE,mBACHF,EACA,8CAGK,KAEX,QACE,GAAI9H,GAAM,IAAMA,GAAM,GAAI,CACxB,IAAI0I,EAAWviE,KAAKggD,MAAM1pB,OAAOt2B,KAAKuH,IAAM,EAAG,GAAGb,MAAM,WAAW,GAC/D66D,EAAQlrC,SAASksC,EAAU,GAe/B,OAdIhB,EAAQ,MACVgB,EAAWA,EAAShjD,MAAM,GAAI,GAC9BgiD,EAAQlrC,SAASksC,EAAU,IAE7BviE,KAAKuH,KAAOg7D,EAASl/D,OAAS,EAC9Bw2D,EAAK75D,KAAKggD,MAAMlyB,WAAW9tB,KAAKuH,KACd,MAAbg7D,GAA2B,KAAP1I,GAAoB,KAAPA,IAAe75D,KAAKisC,SAAUq2B,GAClEtiE,KAAK6hE,mBACH7hE,KAAKuH,IAAM,EAAIg7D,EAASl/D,OACxBi/D,EACI,mCACA,gCAGDz6D,OAAOgwB,aAAa0pC,GAE7B,OAAIpiB,EAAU0a,GAGL,GAEFhyD,OAAOgwB,aAAagiC,KAM/BiF,GAAK8C,YAAc,SAAS30C,GAC1B,IAAI00C,EAAU3hE,KAAKuH,IACfxJ,EAAIiC,KAAK+gE,QAAQ,GAAI9zC,GAEzB,OADU,OAANlvB,GAAciC,KAAK6hE,mBAAmBF,EAAS,iCAC5C5jE,GAST+gE,GAAKgC,UAAY,WACf9gE,KAAK+hD,aAAc,EAGnB,IAFA,IAAIygB,EAAO,GAAI/9C,GAAQ,EAAMs9C,EAAa/hE,KAAKuH,IAC3CuyC,EAAS95C,KAAK4N,QAAQsyC,aAAe,EAClClgD,KAAKuH,IAAMvH,KAAKggD,MAAM38C,QAAQ,CACnC,IAAIw2D,EAAK75D,KAAKu/D,oBACd,GAAIxlB,EAAiB8f,EAAI/f,GACvB95C,KAAKuH,KAAOsyD,GAAM,MAAS,EAAI,MAC1B,IAAW,KAAPA,EAaT,MAZA75D,KAAK+hD,aAAc,EACnBygB,GAAQxiE,KAAKggD,MAAMzgC,MAAMwiD,EAAY/hE,KAAKuH,KAC1C,IAAIk7D,EAAWziE,KAAKuH,IACsB,MAAtCvH,KAAKggD,MAAMlyB,aAAa9tB,KAAKuH,MAC7BvH,KAAK6hE,mBAAmB7hE,KAAKuH,IAAK,+CACpCvH,KAAKuH,IACP,IAAIm7D,EAAM1iE,KAAK0hE,iBACTj9C,EAAQo1B,EAAoBE,GAAkB2oB,EAAK5oB,IACrD95C,KAAK6hE,mBAAmBY,EAAU,0BACtCD,GAAQvD,GAAoByD,GAC5BX,EAAa/hE,KAAKuH,IAIpBkd,GAAQ,EAEV,OAAO+9C,EAAOxiE,KAAKggD,MAAMzgC,MAAMwiD,EAAY/hE,KAAKuH,MAMlDu3D,GAAKU,SAAW,WACd,IAAIgD,EAAOxiE,KAAK8gE,YACZx/D,EAAOw5C,EAAMj+C,KAIjB,OAHImD,KAAKo5C,SAASr/B,KAAKyoD,KACrBlhE,EAAOs5C,EAAW4nB,IAEbxiE,KAAKq/D,YAAY/9D,EAAMkhE,IAOhC/gB,GAAOkhB,MAAQ,CACblhB,OAAQA,GACR9lC,QAJY,QAKZskC,eAAgBA,EAChBN,SAAUA,EACVE,eAAgBA,EAChBE,YAAaA,EACbp6B,KAAMA,GACNq0B,UAAWA,EACX4oB,SAAU9nB,EACV+nB,aAAcjoB,EACd0b,WAAYA,GACZwM,YAAapM,GACb3c,iBAAkBA,EAClBF,kBAAmBA,EACnBglB,MAAOA,GACP1f,UAAWA,EACXF,UAAWA,EACXC,WAAYA,EACZG,mBAAoBA,GCrgKtB,MCEA,I,IAFItQ,GAAgB,GAChBC,GAAQ,oEACH,GAAI,EAAG,GAAIA,GAAM3rC,OAAQ,KAC9B0rC,GAAcC,GAAMlhB,WAAW,KAAM,GAEzC,SAAS3uB,GAAOkiC,GAWZ,IAVA,IAAI4N,EAAU,GACVxN,EAAO,GACPvzB,EAAU,CACV,EACA,EACA,EACA,EACA,GAEAmI,EAAI,EACC/Z,EAAI,EAAG0uB,EAAQ,EAAGztB,EAAQ,EAAGjB,EAAI+kC,EAASh+B,OAAQ/G,IAAK,CAC5D,IAAIK,EAAI0kC,EAASvT,WAAWxxB,GAC5B,GAAU,KAANK,EACAomE,GAAWthC,EAAMvzB,EAASmI,GAC1BA,EAAI,OAEH,GAAU,KAAN1Z,EACLomE,GAAWthC,EAAMvzB,EAASmI,GAC1BA,EAAI,EACJ44B,EAAQ9iC,KAAKs1B,GACbA,EAAO,GACPvzB,EAAQ,GAAK,MAEZ,CACD,IAAI80D,EAAUj0B,GAAcpyC,GAC5B,QAAgBgP,IAAZq3D,EACA,MAAM,IAAItjE,MAAM,sBAAwBmI,OAAOgwB,aAAal7B,GAAK,KAErE,IAAIsmE,EAA+B,GAAVD,EAGzB,GADAzlE,IADAylE,GAAW,KACSh4C,EAChBi4C,EACAj4C,GAAS,MAER,CACD,IAAIk4C,EAAuB,EAAR3lE,EACnBA,KAAW,EACP2lE,IACA3lE,EAAkB,IAAVA,GAAe,YAAcA,GAEzC2Q,EAAQmI,IAAM9Y,EACd8Y,IACA9Y,EAAQytB,EAAQ,IAM5B,OAFA+3C,GAAWthC,EAAMvzB,EAASmI,GAC1B44B,EAAQ9iC,KAAKs1B,GACNwN,EAEX,SAAS8zB,GAAWthC,EAAMvzB,EAASmI,GAQrB,IAANA,EACAorB,EAAKt1B,KAAK,CAAC+B,EAAQ,GAAIA,EAAQ,GAAIA,EAAQ,GAAIA,EAAQ,KAC5C,IAANmI,EACLorB,EAAKt1B,KAAK,CAAC+B,EAAQ,GAAIA,EAAQ,GAAIA,EAAQ,GAAIA,EAAQ,GAAIA,EAAQ,KACxD,IAANmI,GACLorB,EAAKt1B,KAAK,CAAC+B,EAAQ,KAE3B,SAASvO,GAAOsvC,GAMZ,IALA,IAAIC,EAAkB,EAClBC,EAAiB,EACjBC,EAAmB,EACnBrM,EAAY,EACZ1B,EAAW,GACN/kC,EAAI,EAAGA,EAAI2yC,EAAQ5rC,OAAQ/G,IAAK,CACrC,IAAImlC,EAAOwN,EAAQ3yC,GAGnB,GAFIA,EAAI,IACJ+kC,GAAY,KACI,IAAhBI,EAAKp+B,OAAT,CAIA,IAFA,IAAIq/B,EAAsB,EACtB2M,EAAe,GACVnjC,EAAK,EAAGi3D,EAAS1hC,EAAMv1B,EAAKi3D,EAAO9/D,OAAQ6I,IAAM,CACtD,IAAIgC,EAAUi1D,EAAOj3D,GACjBojC,EAAkBC,GAAcrhC,EAAQ,GAAKw0B,GACjDA,EAAsBx0B,EAAQ,GAC1BA,EAAQ7K,OAAS,IACjBisC,GACIC,GAAcrhC,EAAQ,GAAKghC,GACvBK,GAAcrhC,EAAQ,GAAKihC,GAC3BI,GAAcrhC,EAAQ,GAAKkhC,GACnCF,EAAkBhhC,EAAQ,GAC1BihC,EAAiBjhC,EAAQ,GACzBkhC,EAAmBlhC,EAAQ,IAER,IAAnBA,EAAQ7K,SACRisC,GAAmBC,GAAcrhC,EAAQ,GAAK60B,GAC9CA,EAAY70B,EAAQ,IAExBmhC,EAAaljC,KAAKmjC,GAEtBjO,GAAYgO,EAAazsC,KAAK,MAElC,OAAOy+B,EAEX,SAASkO,GAAc/yB,GACnB,IAAI7d,EAAS,GACb6d,EAAMA,EAAM,GAAMA,GAAO,EAAK,EAAIA,GAAO,EACzC,EAAG,CACC,IAAIgzB,EAAgB,GAANhzB,GACdA,KAAS,GACC,IACNgzB,GAAW,IAEf7wC,GAAUqwC,GAAMQ,SACXhzB,EAAM,GACf,OAAO7d,E,ICnHL,G,WASJ,cAQC,oBACCqB,KAAA,KAAYggD,EAAZ,KACAhgD,KAAA,SAAgBggD,EAAhB,SACAhgD,KAAA,WAAkBggD,EAAlB,WACAhgD,KAAA,MAAaggD,EAAb,MACAhgD,KAAA,QAAeggD,EAAf,QACAhgD,KAAA,eAAsBggD,EAAtB,eACAhgD,KAAA,QAAeggD,EAAf,Q,uDAIA,OAAO9+C,KAAA,UAAP,Q,kCAIA,2DAAqD,WAAclB,KAAnE,iB,KAIJ,SAASojE,GAAyBljE,GAOhC,IANA,IAIA,EAJMsb,EADqC,yIAIvC6nD,EAAJ,KAGQ38D,EAAQ8U,EAAA,KAAhB,IAA+B6nD,EAAA,EAE/B,SAGI,eACJ,IAAMA,EAAYD,GAAlB,GAEA,SAEOC,EAAP,GAFuB,GAKnB,iBACJ,IAAMA,EAAYD,GAAlB,GAEA,SAEOljE,EAAA,QAAamjE,EAAb,OAAgCnjE,EAAA,MAAUmjE,EAAV,eAAmCA,EAAnC,GAAvC,GAFuBnjE,EAKnB,eACJ,IAAMwG,EAAQoI,EAAA,MAAd,6DAEA,KAAW,CACT,GAAIpI,EAAA,IAAJ,UAAgBA,EAAA,GACd,YAGF,IACE,IAAMuoC,EAAU/tC,KAAA,MAAW,WAAcwF,EAAzC,KAEA,WAAIuoC,EAAA,SACK,CACL5Q,KADK,GAELgD,SAFK,GAGLD,MAHK,GAILF,QAJK,GAKLC,eAAgB,KAIpB,kBAAW8N,EAAP,WACFA,EAAA,SAAmB9vC,GAAO8vC,EAA1B,WAGF,GACA,MAAOxwC,GACP,aAIJ,Y,ICrFI,G,WAIJ,gBAAoD,oBAClDuB,KAAA,WACAA,KAAA,U,yDAGU,OACV,MAAO,CAAEyhC,OAAMuB,SAAQnmC,OAAM8Y,OAAQ3V,U,KAWnC,G,WAKJ,gBAE4B,oBAE1BA,KAAA,UACAA,KAAA,MAAaiQ,EAAb,MACAjQ,KAAA,SAAgB,kBAAOiQ,EAAP,SAAmC9Q,GAAO8Q,EAA1C,UAA0DA,EAA1E,S,4DAIA,OAAO,GAAP,Q,mCAGU,OACV,OAAO,GAAajQ,KAAMyhC,EAAMuB,EAAhC,O,KAIE,G,WAGJ,cAAiD,oBAApB,KAAAsgC,WAFrB,KAAAC,UAAA,E,sDAKN,IAAIA,EAAOvjE,KAAX,KAOA,OALA,IACEujE,EAAOvjE,KAAP,WACAA,KAAA,QAGF,I,sCAIA,OAAO,GAAcA,KAArB,a,mCAGU,OACV,OAAO,GAAaA,KAAD,cAAnB,O,KAIJ,SAAS,GAAT,GAIE,IAFoF,EAE9EkhC,EAAN,GACMC,EAAN,GACMC,EAAN,GACMC,EAAN,GALoF,cAOjEpxB,EAAnB,UAPoF,IAOpF,2BAAiC,OAAjC,EAAiC,QACzBuzD,EAAN,GAD+B,cAG/B,GAH+B,IAG/B,2BAA4B,KAA5B,EAA4B,QAC1B,MAAIt1D,EAAA,OAAJ,CACA,IAAMyH,EAAS1F,EAAA,QAAY/B,EAA3B,IACA,MAEA,IAAMu1D,EAAS9tD,EAAA,aACbzH,EADa,GAEbA,EAFa,GAGb,IAAAA,EAAA,OAAuB+B,EAAA,MAAU/B,EAAjC,IAHF,IAMA,KAAY,CAEV,IAAI20B,EAAc3B,EAAA,YAAoBuiC,EAAA,OAAtC,UACA,QAAI5gC,EACFA,EAAc3B,EAAd,OACAA,EAAA,KAAauiC,EAAA,OAAb,UACAtiC,EAAA,GAA8BsiC,EAAA,OAA9B,aACK,SAAItiC,EAAA,GACTA,EAAA,GAA8BsiC,EAAA,OAA9B,aACK,GACL,MAAAA,EAAA,gBACAtiC,EAAA,KAAgCsiC,EAAA,OAF3B,QAIL,OAAO,IAAI/jE,MAAM,sDAAV,OACiD+jE,EAAA,OADxD,WAKF,IAAMC,EAAkC,CACtCx1D,EADsC,KAGtCu1D,EAHsC,KAItCA,EAJF,QAOA,GAAIA,EAAJ,KAAiB,CACf,IAAI1gC,EAAY3B,EAAA,QAAcqiC,EAA9B,OACA,IAAI1gC,IACFA,EAAY3B,EAAZ,OACAA,EAAA,KAAWqiC,EAAX5mE,OAGD6mE,EAAA,KAGHF,EAAA,YAjD2B,8BAqD/BniC,EAAA,SA5DkF,8BA+DpF,MAAO,CAAEH,UAASC,iBAAgBC,QAAOC,YAG3C,SAAS,GAAT,SAOE,IAAM9C,EAAWtuB,EAAA,SAAjB,GACA,MAAe,OAHH,KAWZ,IALA,IAAI3T,EAAJ,EACI+Z,EAAIkoB,EAAA,OAAR,EAIOjiC,GAAP,GAAe,CACb,IAAMI,EAAKJ,EAAD,GAAV,EACM4R,EAAUqwB,EAAhB,GAEA,GAAIrwB,EAAA,KAAJ,EAA2B,CACzB,MAAIA,EAAA,OAAqB,OAAO,KAChC,IAAMyH,EAAS1F,EAAA,QAAY/B,EAA3B,IACA,SAEOyH,EAAA,aACLzH,EADK,GAELA,EAFK,GAGL,IAAAA,EAAA,OAAuB+B,EAAA,MAAU/B,EAAjC,IAHF,GAFoB,KAQlBA,EAAA,GAAJ,EACEmI,EAAI3Z,EAAJ,EAEAJ,EAAII,EAAJ,EAIJ,Y,IC3LF,GCwBM,G,WACJ,cAA8C,oBAAjB,KAAA4nD,UAC3BtkD,KAAA,aAAkB,CAChBnD,KADgB,UAEhB8mE,KAAM,WAAF,4BAAE,mCAAA1kE,EAAA,yDACEV,EAAM,UAAZ,GACM4V,EAAalH,EAAA,yBAAnB,IACmB,eAHf,gCAIM,YAAkBkH,EAAYlH,EADrB,OAHf,8CAGJ,EAHI,cAGEmH,EAHF,uBAOG,CACLzS,KAAMsL,EAAA,gBAAoBmH,EADrB,SAELzG,QAASyG,EAAWzG,UATlB,4CAAF,qDAAE,GAYNi2D,kBAAmB,WAAF,4BAAE,mCAAA3kE,EAAA,yDACXyR,EAAgBzD,EAAA,iBAAqB42D,EAArB,KAAsCC,EAA5D,MACsB,eAFL,gCAGP,YAAkBpzD,EAAezD,EADrB,OAFL,8CAEjB,EAFiB,WAEXmF,EAFW,MAMjB,MANiB,uBAOT,IAAI,EAAJ,EAA4ByxD,EAA5B,KAAN,GAPe,WAUZzxD,EAAL,IAViB,uBAYT,IAAI,EAAJ,EAAuByxD,EAA7B,MAZe,iCAeV,CACLtlE,IAAK6T,EADA,IAELjF,QAASiF,EAFJ,QAGLzE,QAASyE,EAAczE,UAlBR,4CAAF,uDAAE,GAqBnBo2D,kBAAmB,WAAF,4BAAE,+BAAA9kE,EAAA,sEACWgO,EAAA,iBAA5B,GADiB,WACXmF,EADW,QAGjB,MAHiB,sBAIT,IAAI,EAAJ,mCAAN,IAJe,UAOZA,EAAL,IAPiB,sBAQT,IAAI,EAAJ,EAAN,GARe,gCAWjB,GAXiB,2CAAF,qDAAE,GAanB4xD,UAAW,WAAF,4BAAE,iCAAA/kE,EAAA,yDAASglE,EAAT,EAASA,mBACd1nD,EAAA,cAAJ,SADS,uBAEDgrB,EAAc08B,KACpB,6BAHO,kBAKA,CACLtiE,KAAM4lC,EADD,WAEL28B,UAAW38B,EAAA,uBAPN,2CAAF,qDAAE,K,iGAcf,K,6FACuBvnC,KAArB,S,4DACE,oBADF,E,SACM,K,oBACImkE,EAAaC,EAAA,OAAiB7lE,EAApC,aACmB,e,kCACT,YAAkB4lE,EAAYl3D,EADrB,O,iDAAnB,E,WAAMo3D,E,sFAQC,CACL1iE,KAAM0iE,EADD,KAEL12D,QAAS02D,EAAA,SAAsB,K,qJAK/B,IAAI3kE,MAAM,qDAAV,OAA+DnB,EAArE,a,iNAGF,O,6FAKuByB,KAArB,S,4DACE,oBADF,E,SACM,kB,oBACImkE,EAAaC,EAAA,sBAAnB,IACmB,e,kCACT,YAAkBD,EAAYl3D,EADrB,O,iDAAnB,E,WAAMo3D,E,sFAQC,CACL9lE,IAAK8lE,EADA,IAELl3D,QAASk3D,EAFJ,QAGL12D,QAAS02D,EAAA,SAAsB,K,qJAK/B,IAAI3kE,MAAM,sCAAV,OACkCmkE,EADlC,+BACmEA,EADnE,wBAC6FS,EAD7F,KAAN,M,mNAKF,K,6FACuBtkE,KAArB,S,4DACE,oBADF,E,SACM,kB,oBACImkE,EAAaC,EAAA,oBAAnB,IACmB,e,kCACT,YAAkBD,EAAYl3D,EADrB,O,iDAAnB,E,WAAMo3D,E,sFAQC,CACL9lE,IAAK8lE,EADA,IAELl3D,QAASk3D,EAFJ,QAGL12D,QAAS02D,EAAA,SAAsB,K,qJAK/B,IAAI3kE,MAAM,iDAAV,OAA2DnB,EAA3D,WAAN,M,yMAGF,O,mGAoBE,GAfA,kBAAWoD,IACTA,EAAOsL,EAAA,gBAAPtL,IAGI4iE,EAAoCvnE,OAAA,SAAmB,CAC3DinE,kBAD2D,WAEzD,OAAO,IAAI,EAAJ,EAAP,MAIAO,EAA+B,IAAI,GAAOjmE,EAAX,WAZT,IAgBpBkmE,EAAeC,GAArB,OAEMR,EAAiDS,GAArD,MAGQC,EAAe,4BAArB,IAEAjjE,EAAOkjE,GAAuBljE,EAAMijE,EAApC,aAGF,GAAe,CAKb,SAJM1jC,EAAUgjC,EAAhB,QACM/iC,EAAiB+iC,EAAA,gBAAvB,GACMY,EAAN,GAEA,EACM5jC,EAAA,IAAgBC,EAApB,IACE2jC,EAAA,KAAiB,IAAI,GAAO5jC,EAAX,GAA0BC,EAA3C,KAIJqjC,EAAgB,IAAI,GAAJ,EAAhB,GAIE72D,EAAN,G,cAEqB3N,KAArB,S,4DACE,oBADF,E,SACM,U,oBACI+kE,EAAkBX,EAAA,cAAxB,IACwB,e,kCACd,YAAkBW,EAAiB93D,EADrB,O,iDAAxB,E,WAII,QAJE+3D,E,YAIN,IAAgCA,E,wDAI5BA,EAAJ,YACER,EAAgB,IAAI,GAAKQ,EAAT,UAAoC,CAApDR,KAGF7iE,EAAOqjE,EAAPrjE,KAEIqjE,EAAJ,SACEr3D,EAAA,WAAAA,EAAO,YAASq3D,EAAhBr3D,U,wKAKC,CACLhM,OACA6iE,gBACA72D,Y,mID1ON,YACE,0BACA,oBACA,kCACA,8BAJF,CAAYs3D,QAAZ,K,IAaM,G,WAGJ,kBAI4C,IAAjCr3D,EAAiC,uDAJ5C,GAI4C,oBAHjC,KAAAs5C,OACA,KAAAz6C,OACA,KAAAk0C,YACA,KAAA/yC,U,8DAGX,KACE,OAAOrR,EAAA,OAAWa,EAAX,MAAqBb,EAAA,OAAWa,EAAvC,O,qCAGF,GACE,OAAO,IAAI8nE,EAAuBD,GAA3B,WAAkE1mE,EAAlE,WAAP,M,uCAGF,OACE,OAAO,IAAI2mE,EAAuBD,GAA3B,iBAAqF,CAC1FE,iB,kCAIJ,KACE,OAAO,IAAID,EAAuBD,GAA3B,UAAP,K,yCAGF,KACE,OAAO,IAAIC,EAAuBD,GAA3B,iBAAP,O,KEPE,eACJ,kCAAO70D,EAAA,KA2BH,eACJ,8BAAOA,EAAA,KAGH,eACJ,6BAAOA,EAAA,KAGH,eACJ,qBAAOA,EAAA,KAWH,eACJ,2BAAOA,EAAA,KAeH,eACJ,sBAAOA,EAAA,KAkCH,eACJ,OAxDI,YACJ,kBAAOA,EAAA,KAuDAg1D,CAAA,IAAP,kBAAiCh1D,EAAP,MAGtB,iBACJ,OPk4JF,SAAe4vC,EAAOpyC,GACpB,OAAO6zC,GAAO78C,MAAMo7C,EAAOpyC,GOn4JnB,8BAAkB,GAAlB,IAEN2yC,4BAFwB,EAGxBJ,WAAY,YCpHV,oBAWN,SAAS,EAAT,WASE,MAAW,OAIX,GAFA/vC,EAAA,SAEA,EAAW,CACT,IAAMi1D,EAAN,GACAC,IAAA,EACAC,EAAA,eACA,IAAMC,EAAN,GAGA,GAFAF,GAAA,EAEA,EAAa,OAWf,IARA,IAAMlwD,EACJqwD,GAAUr1D,EAAV,QACCq1D,GAAUr1D,EAAV,MAAuBpT,OAAA,gBACrB,SAAAa,GAAD,MAAS,WAAAA,GAHb,kBAGyCuS,EAAR,OAG3BguB,EAAN,GAES,EAAT,EAAgB,EAAIhpB,EAApB,OAAiC,IAAK,CACpC,IAAMvX,EAAMuX,EAAZ,GACM7X,EAAS6S,EAAf,GAEA,GAAIpH,MAAA,QAAJ,GACE,IAAK,IAAIqN,EAAT,EAAgBA,EAAI9Y,EAApB,OAAkC8Y,IAC5B9Y,EAAJ,IAAc6gC,EAAA,KAAc7gC,EAAd,SAEPA,GAASA,EAAb,MACL6gC,EAAA,QAIJA,EAAA,MAAc,qBAAUn/B,EAAA,MAAU4d,EAAlC,SAEA,+BAA8B,CAAzB,IAAMzW,EAAX,KACE,EAAMA,EAAOgK,EAAMnD,EAAKs4D,EAAxB,GAGF,GACEG,EAAMt1D,EAAM9J,EAAZ,GA7DF,CAAMq/D,EAAD,OADyF,EAAnC,MAAmC,EAA1BD,OAItE,IAAIJ,IAAJ,EACM35C,GAAU,CAAE07B,KAAM,kBAAOie,IAAa,IAE/BG,GAAN,GCSA,IAAM7gE,GAAQ,SAAyB,EAAzB,KAQnB,IAAMghE,EAAuC,CAC3CC,eAAgB,IAD2B,IAE3CC,OAAQ,IAFmC,IAG3Cv+B,YAAa,IAAI,EAAJ,IAAsB,CAAE9zB,SAAUlV,EAAZ,WAA4BklC,sBAAuB,KACtFsiC,QAASn4D,EAJkC,QAK3Co4D,gBAAiB,IAL0B,IAM3CC,SAN2C,GAO3CC,gBAP2C,GAQ3C7e,KAAM,IARqC,IAS3C8e,cAAe,IAAIlhD,KAEfjT,EAAN,GAEA,IAEE,IAAM2zD,EAAMS,GAASzkE,EAAM,IAiB3B0kE,GAASV,EAAKC,EAAd,IACAS,GAASV,EAAKC,EAAd,IACA,MAAOnnE,GAGP,MAAM,IAAIiB,MAAM,iBAAV,sBAAmCjB,EAAzC,UAIF,IA3CC,EA2CK6nE,EAAiB,IAAvB,IA3CC,cA4C+BV,EAAhC,UA5CC,IA4CD,2BAAqD,KAArD,EAAqD,QAC/CjlB,EAAY2lB,EAAA,IAAmBC,EAAA,KAAnC,OACA,IACE5lB,EAAA,GACA2lB,EAAA,IAAmBC,EAAA,KAAnB,UAGF5lB,EAAA,KAAe,CAAE38C,MAAOuiE,EAAA,KAAT,MAAuC3iE,IAAK2iE,EAAA,KAAuB3iE,OAnDnF,kDAqDD,GArDC,IAqDD,2BAAgD,8BAArC,EAAqC,KAAhD,EAAgD,KAC9CoO,EAAA,KAAkB,iBAAlB,KAtDD,8BA0DD,IA1DC,EA0DKw0D,EAAwB,IAA9B,IA1DC,cA2D+BZ,EAAhC,iBA3DC,IA2DD,2BAA4D,KAA5D,EAA4D,QACtD,EAAYU,EAAA,IAAmB,OAAnC,OACA,IACE,KACAA,EAAA,IAAmB,OAAnB,UAGF,OAAe,CAAEtiE,MAAO,OAAT,MAAuCJ,IAAK,OAAuBA,OAlEnF,kDAoED,GApEC,IAoED,2BAAuD,8BAA5C,EAA4C,KAAvD,EAAuD,KACrDoO,EAAA,KAAkB,wBAAlB,KArED,kDAwEqC4zD,EAAtC,gBAxEC,IAwED,2BAAiE,8BAAtD,EAAsD,KAAjE,EAAiE,KACzDa,EAAO74D,EAAA,cAAb,GAEA,KAAU,CACRoE,EAAA,KAAkB,oBAAwCy0D,EAAxC,OAA8DA,EAAhF,SADQ,oBAGR,GAHQ,IAGR,2BAAkC,KAAlC,EAAkC,QAChCb,EAAA,sBACE/1B,EADF,MAEEA,EAFF,sBAGa3uC,KAAA,oBAAkBulE,EAH/B,mBAG+CA,EAAA,kBAAkBA,EAAlB,QAH/C,MAJM,iCA3EX,8BAwFD,MAAO,CACL9kE,KAAMikE,EADD,YAEL5zD,iBA0BS00D,GAA+D,CAC1EnB,MAD0E,SACrE,OAKH,GAHAt4D,EAAA,iCAAqCmD,EAArC,OACAnD,EAAA,iCAAqCmD,EAArC,KAEInD,EAAA,SAAJ,GACE,OAAOjN,KAAP,QAoGN,SAAgC,EAAhC,KAKE,GFzJI,YACJ,8BAAOoQ,EAAA,KEwJHu2D,CAAJ,GAAiC,CAI/B,IAHA,MACIC,EAAax2D,EAAjB,OAEA,GAAmB,CACjB,GAAI,QAAAA,EAAA,KAAsBy2D,GAAtB,GAA4C,GAAhD,GAA0E,CACxEvgE,EAAA,EACA,MAGFsgE,EAAaA,EAAb,OAGF,MACE,MAAM,IAAIlnE,MAAV,gDAGF,IAAIomE,EAAS74D,EAAA,WAAb,GAEA,IACE64D,EAAA,GACA74D,EAAA,iBArB6B,oBAwBLmD,EAA1B,cAxB+B,IAwB/B,2BAA6C,CAC3C02D,GAD2C,QAC7B,GAAd,IAzB6B,oCA2B1B,GAAIC,GAAJ,GAAiC,CACtC,MACI,EAAa32D,EAAjB,OAMA,IAJI,GAAc,EAAlB,SACE,EAAa,EAAb,QAGF,GAAmB,CACjB,GAAIy2D,GAAJ,GAAyB,CACvB,IACA,MAGF,EAAa,EAAb,OAGF,MACE,MAAM,IAAInnE,MAAV,gDAGF,IAAI,EAASuN,EAAA,WAAb,GAEA,IACE,KACAA,EAAA,iBAGF+5D,GAAgB52D,EAAhB,QACK,GF5MH,YACJ,OACE22D,GAAA,IAA+BE,GAA/B,IAA6DC,GAD/D,GE2MWC,CAAJ,GAAsB,CAC3B,IAAI,EAASl6D,EAAA,WAAb,GAEA,IACE,KACAA,EAAA,iBAGF+5D,GAAgB52D,EAAhB,QACK,GF1RH,YACJ,2BAAOA,EAAA,KEyRIg3D,CAAA,IAA4Bh3D,EAAhC,GAAyC,CAC9C,MACI,EAAaA,EAAjB,OAMA,IAJI,GAAc,EAAlB,SACE,EAAa,EAAb,QAGF,GAAmB,CACjB,GAAIy2D,GAAJ,GAAyB,CACvB,IACA,MAGF,EAAa,EAAb,OAGF,MACE,MAAM,IAAInnE,MAAV,gDAGF,IAAI,EAASuN,EAAA,WAAb,GAEA,IACE,KACAA,EAAA,iBAGF,EAAOmD,EAAA,GAAP,cACK,GF/PH,YACJ,uBAAOA,EAAA,KE8PIi3D,CAAJ,IACDj3D,EAAJ,QAAkB,CAChB,IAAI,EAASnD,EAAA,WAAemD,EAA5B,SAEA,IACE,KACAnD,EAAA,WAAemD,EAAf,YAGEA,EAAA,QAAJ,OACE02D,GAAe12D,EAAA,QAAD,MAAd,IA9MJk3D,CAAuBl3D,EAAM9J,EAA7B,GAoNJ,SAA8B,EAA9B,KAKE,GF5TI,YACJ,sBAAO8J,EAAA,KE2THm3D,CAAA,IFxVA,YACJ,2BAAOn3D,EAAA,KEuVoBo3D,CAAmBp3D,EAA9C,MAA0D,CACxD,IAMM2J,EANQ,CACZ,KAAM,qBAA0Bxd,GADpB,GAEZ,MAAO,qBAA0BA,IAFrB,GAGZ,KAAM,qBAA0BA,GAHpB,GAIZ,MAAO,qBAA0BA,IAAMa,IAEtBgT,EAAA,KAAnB,UAEA,KACE,GACEq3D,GAAgBr3D,EAAA,KAAhB,OACAs3D,GAAmBt3D,EAAA,KADnB,QAEAu3D,GAAwBv3D,EAAA,KAAD,MAHzB,wBAIE,CAEA,IADA,IAAIw3D,EAAax3D,EAAA,KAAjB,MACOs3D,GAAmBE,EAA1B,SACEA,EAAaA,EAAb,OAEEC,GAAaD,EAAjB,SACE36D,EAAA,oBAAwB26D,EAAxB,QAGF36D,EAAA,kBAAsBmD,EAAA,KATtB,OAaK2J,EAAK3J,EAAA,UAAD,MAAuBnD,EAAhC,UASEA,EAAA,mBAAuBmD,EAAvB,MAAmCA,EAAA,iBAAnC,GAEIA,EAAJ,YACEnD,EAAA,SAAamD,EADK,WAGlBnD,EAAA,mBAAuBmD,EAAA,eAAvB,EAAgDA,EAAA,UAAhD,QAbFnD,EAAA,SAAamD,EAD+B,YAG5CnD,EAAA,mBACEmD,EADF,MAEEA,EAAA,UAAiBA,EAAA,UAAjB,MAAwCA,EAAA,WAF1C,WAcG,GACLq3D,GAAgBr3D,EAAA,KAAhB,QACAs3D,GAAmBt3D,EAAA,KADnB,OAEAu3D,GAAwBv3D,EAAA,KAAD,KAHlB,wBAIL,CAEA,IADA,IAAI,EAAaA,EAAA,KAAjB,KACOs3D,GAAmB,EAA1B,SACE,EAAa,EAAb,OAEEG,GAAa,EAAjB,SACE56D,EAAA,oBAAwB,EAAxB,QAGFA,EAAA,kBAAsBmD,EAAA,KATtB,MAaK2J,EAAK3J,EAAA,WAAD,MAAwBnD,EAAjC,UASEA,EAAA,mBAAuBmD,EAAvB,MAAmCA,EAAA,iBAAnC,GAEIA,EAAJ,YACEnD,EAAA,SAAamD,EADK,WAGlBnD,EAAA,mBAAuBmD,EAAA,eAAvB,EAAgDA,EAAA,UAAhD,QAbFnD,EAAA,SAAamD,EADgC,YAG7CnD,EAAA,mBACEmD,EADF,MAEEA,EAAA,UAAiBA,EAAA,UAAjB,MAAwCA,EAAA,WAF1C,QAxRN03D,CAAqB13D,EAAM9J,EAA3B,GA2SJ,SAAuB,EAAvB,KAKE,GFxaI,YACJ,yBAAO8J,EAAA,KEuaH23D,CAAJ,GAA4B,CAC1B,IAAMvV,EAASpiD,EAAf,OACA,GAAIy3D,GAAA,IAAJ,YAA4BrV,EAAA,KAA2B,CACrD,IAAMwV,EAAW53D,EAAA,UAAjB,GAEIq3D,GAAJ,GACEx6D,EAAA,cAAkB,CAChBR,KAAM,CAAEzI,MAAOgkE,EAAT,MAAyBpkE,IAAKokE,EAA9B,IAA4CzqE,MAAOyqE,EAASzqE,OAClEi1D,OAAQ,CAAExuD,MAAOwuD,EAAT,MAAuB5uD,IAAK4uD,EAAO5uD,QF5X/C,YACJ,0BAAOwM,EAAA,KE8XD63D,CAAA,QACAD,EAAA,oBAFK,IAGLA,EAAA,cAWA73D,QAAA,kDATAlD,EAAA,cAAkB,CAChBR,KAAM,CACJzI,MAAOgkE,EAAA,UADH,MAEJpkE,IAAKokE,EAAA,UAFD,IAGJzqE,MAAOyqE,EAAA,gBAAyB/rD,KAElCu2C,OAAQ,CAAExuD,MAAOwuD,EAAT,MAAuB5uD,IAAK4uD,EAAO5uD,YAK1C,GACL8jE,GAAA,IACAG,GAAarV,EADb,qBAEAA,EAAA,aACAqV,GAAarV,EAHb,WADK,YAKLA,EAAA,cACA,CACA,IAAM,EAAWpiD,EAAA,UAAjB,GAEIq3D,GAAJ,GACEx6D,EAAA,qBAAyB,CACvBR,KAAM,CAAEzI,MAAO,EAAT,MAAyBJ,IAAK,EAA9B,IAA4CrG,MAAO,EAASA,OAClEi1D,OAAQ,CAAExuD,MAAOwuD,EAAT,MAAuB5uD,IAAK4uD,EAAO5uD,OAG7CuM,QAAA,4DAxVJ+3D,CAAc93D,EAAM9J,EAApB,IAEFo/D,MAd0E,SAcrE,OAIH,IAHA,IAAIF,GAAJ,EACI2C,EAAJ,EAEA,GAAkB,CAChB,GAAIl7D,EAAA,kBAAJ,GAAsC,CACpCu4D,GAAA,EACA,MAGF2C,EAAYA,EAAZ,QAIC3C,GACDkC,GADA,IAEAC,GAAwBv3D,EAH1B,0BAKEnD,EAAA,sBAA0BmD,EAA1B,MAAsCA,EAAtC,IAAgDlP,KAAA,UAAe+L,EAA/D,SAA6E,CAC3EmzB,aAD2E,EAE3Eb,WAAW,IAEbtyB,EAAA,YACAA,EAAA,wBAKOm7D,GAA2D,CACtE7C,MADsE,SACjE,OACH,GAAIt4D,EAAA,SAAJ,GACE,OAAOjN,KAAP,OAGF,GA6VJ,SAA6BoQ,GAC3B,OACEy3D,GAAA,KAWJ,SAAsCz3D,GACpC,OAAOA,EAAA,QAAes3D,GAAmBt3D,EAAlC,SAAkDA,EAAA,gBAAzD,EAXGi4D,CADD,KAOJ,SAAyBj4D,GACvB,OAAOA,EAAA,QF5dH,YACJ,mBAAOA,EAAA,KE2dek4D,CAAWl4D,EAA1B,SAA0CA,EAAA,aAAjD,EANGm4D,CAFD,KAeJ,SAAiCn4D,GAC/B,OAAOA,EAAA,QF5eH,YACJ,2BAAOA,EAAA,KE2eeo4D,CAAmBp4D,EAAzC,QAbGq4D,CAJH,GA9VMC,CAAA,IAA6Bb,GAA7B,KAuVR,SAA4Bz3D,GAC1B,IAAM9J,EAAS8J,EAAf,OAEA,OFvbI,YACJ,0BAAOA,EAAA,KEsbAu4D,CAAA,IAAP,WAAoCriE,EAAA,SA1VsBsiE,CAAxD,GAAkF,CAChF,IAAI/rE,EAAOuT,EAAX,KACA,iBAAIvT,EAAsB,OAC1B,GAAIoQ,EAAA,oBAAJ,GACE,OAMF,IAHA,IAAI47D,GAAJ,EACIjC,EAAax2D,EAAjB,OAEA,GAAmB,CACjB,GAAI,cAAAvT,GAAwBisE,GAA5B,GAA2D,CACzDD,GAAA,EACA,MAGF,IAAM/C,EAAS74D,EAAA,WAAf,GAEA,GAAI64D,GAAUA,EAAd,GAA4B,CAC1B+C,GAAA,EACA,MAGFjC,EAAaA,EAAb,OAGF,MAAmB,CACjB,IAAIf,EAAiB54D,EAAA,mBAArB,GACA,IACE44D,EAAA,GACA54D,EAAA,yBAEF44D,EAAA,cAEG,GFvIL,YACJ,yBAAOz1D,EAAA,KEsIM24D,CAAJ,GAA4B,CAIjC,IAHA,IAAI,GAAJ,EACI,EAAa34D,EAAjB,OAEA,GAAmB,CACjB,GAAI44D,GAAJ,GAA8B,CAC5B,KACA,MAGF,EAAa,EAAb,OAGF,MAAmB,CACjB,IAAI,EAAiB/7D,EAAA,mBAArB,QACA,IACE,KACAA,EAAA,8BAEF,cAqQR,SAAS+5D,GAAgB52D,EAAzB,GACEA,EAAA,gBAAoB,SAAUA,GAC5B02D,GAAe12D,EAAf,MAEGA,EAAL,KACE01D,EAAQ11D,EAAA,GAAR,UAIJ,SAAS02D,GAAe12D,EAAxB,GACE,GAAIy3D,GAAJ,GACE/B,EAAO11D,EAAP,cACK,GF/bH,YACJ,wBAAOA,EAAA,KE8bI64D,CAAJ,GACL74D,EAAA,oBAAyB,SAAAA,GAAD,OACtB84D,GAAA,GACIpC,GAAe12D,EAAD,SADlB,GAEI02D,GAAe12D,EAAD,MAHpB,WAKK,GFzfH,YACJ,uBAAOA,EAAA,KEwfI+4D,CAAJ,GACL/4D,EAAA,kBAAuB,SAAAA,GAAD,OAAUA,GAAQ02D,GAAe12D,EAAvD,WACK,GAAI84D,GAAJ,GACLpC,GAAe12D,EAAD,SAAd,OACK,KFzfH,YACJ,4BAAOA,EAAA,KEwfIg5D,CAAJ,GAGL,MAAM,IAAI1pE,MAAM,iDAAV,OAA2D0Q,EAAjE,OAFA02D,GAAe12D,EAAD,KAAd,IAiCJ,SAASy2D,GAAQz2D,GACf,OACE22D,GAAA,IACAE,GADA,IAEAC,GAFA,IFjeE,YACJ,kBAAO92D,EAAA,KEmeLi5D,CAJF,GAQF,SAAS,GAAT,GACE,OF7hBI,YACJ,yBAAOj5D,EAAA,KE4hBAk5D,CAAA,IAA0BzC,GAAjC,GAGF,SAASiC,GAAkB14D,GACzB,OAAO22D,GAAA,IAA+BE,GAAtC,GAGF,SAAS+B,GAAa54D,GACpB,OAAO22D,GAAA,IAA+BE,GAAtC,GAGF,SAASU,GAAwBv3D,EAAjC,GACE,IAAMm5D,EAAcvkC,EAAA,MAApB,KAEA,GAAIukC,EAAA,OAAJ,EACE,SAMF,IAHA,IAAMvrE,EAASurE,EAAf,QACMtrE,EAAWsrE,EAAjB,QAES,EAAIA,EAAA,OAAb,EAAqC,GAArC,EAA6C,IAAK,CAChD,IAAK1B,GAAaz3D,EAAd,WAAgCA,EAAA,gBAAuBm5D,EAA3D,GACE,SAGF,IAAK7B,GAAmBt3D,EAAxB,QACE,SAGFA,EAAOA,EAAP,OAGF,SAAKy3D,GAAaz3D,EAAd,UAA+By3D,GAAaz3D,EAAhD,aAIOA,EAAA,iBAA+BA,EAAA,gBAAtC,G,ICjnBI,G,WAMJ,kBAGmB,oBAFA,KAAAk3B,SACA,KAAAk9B,gBACR,KAAAjmE,M,gEAwCT,IAAMirE,EAAwBxpE,KAAKwkE,cAAnC,gBAEA,OAAIgF,aAAJ,MACS,IAAI,GAAU,CACnBnrC,KAAMr+B,KADa,KAEnBqhC,SAFmB,GAGnBD,MAHmB,GAInBF,QAJmB,GAKnBvlB,QALmB,EAMnBwlB,eAAgB,KAuCF,IAAI,GAAU,CAC9B9C,KAAMr+B,KADwB,KAE9BqhC,SAAU1hC,GAAO6pE,EAFa,UAG9BpoC,MAAOooC,EAHuB,MAI9BtoC,QAASsoC,EAJqB,QAK9B7tD,QAL8B,EAM9BwlB,eAAgBqoC,EAAsBroC,mB,2BAtFxC,MAJA,qBAAWnhC,KAAP,aACFA,KAAA,WAAkBA,KAAKsnC,OAAvB,YAGKtnC,KAAP,a,2BAIA,OAAOA,KAAKzB,IAAZ,a,gCAQA,MAJA,qBAAWyB,KAAP,kBACFA,KAAA,gBAAuBA,KAAvB,qBAGKA,KAAP,kB,sCAQA,MAJA,qBAAWA,KAAP,wBACFA,KAAA,sBAA6BA,KAAKkkE,UAAlC,YAGKlkE,KAAP,wB,uCAQA,MAJA,qBAAWA,KAAP,yBACFA,KAAA,uBAA8BA,KAAKkkE,UAAnC,aAGKlkE,KAAP,2B,KCxCE,G,WAOJ,cAAkC,oBANjB,KAAAypE,UAAY,IAAZ,IACA,KAAAC,QAAU,IAAV,IAGA,KAAAC,cAAgB,IAAhB,IAGf3pE,KAAA,QAAe4N,EAAf,QADgC,oBAGLA,EAA3B,eAHgC,IAGhC,2BAAkD,KAAlD,EAAkD,QAChD5N,KAAA,kBAAuB4pE,EAAvB,SAJ8B,kDAObh8D,EAAnB,OAPgC,IAOhC,2BAAkC,KAAlC,EAAkC,QAC1Bi8D,EAAWC,EAAA,QAAjB,WACMC,EAASD,EAAA,MAAf,WAEA9pE,KAAA,mBACAA,KAAA,kBAZ8B,+B,kEAgBb,GAAgC,aAQ7CsnC,EAAS,IAAI,EAAJ,EAAW,CACxBzZ,UAAW,OATsC,cAYxB7tB,KAAK2pE,cAAhC,UAZmD,IAYnD,2BAAwD,KAAxD,EAAwD,QAChDK,EAAN,GAIMC,EAA6B,CAAEC,OAHzB,eACTN,EAAD,KAAqBI,IAGjBP,EAAYzpE,KAAKypE,UAAUtsE,IAAIysE,EAArC,MAEA,KAAe,qBACb,GADa,IACb,2BAA8B,KAA9B,EAA8B,QAC5BI,EAAaF,EAAA,WAAb,MAAqCA,EAAA,MAArC,YAFW,+BAKf,IAAMK,EAAmBP,EAAAj0D,OAAzB,QAEAw0D,EAAA,8BACiBjpE,KAAA,UACb0oE,EAAA,IAFJ,8EAKAO,EAAA,qBAA+BjpE,KAAA,UAA/B,UACAomC,EAAA,cAjCiD,8BAkDnD,GAZAA,EAAA,gCACAA,EAAA,kJACqIpmC,KAAA,UAJpF,CAAEkpE,KAAM,KAGzD,QAKA9iC,EAAA,mCAEI15B,GAAWA,EAAf,eACE05B,EAAA,mBC/EiB,8iDD+EjB,gBAGE15B,GAAWA,EAAf,cAAsC,CACpC,IAAKA,EAAL,cACE,MAAM,IAAIlO,MAAV,6GAKF4nC,EAAA,6CAA6CpmC,KAAA,UAAe0M,EAA5D,wBAGF,IAAM42D,EAAgB,IAAI,IAAS,WACjC,IAAM6F,EAAW/iC,EAAA,mBAA0B,CACzC1C,gBADyC,EAEzCpC,OAFyC,EAGzC7sB,OAAQ,uBAEV,OAAO,IAAI,GAAJ,EAEL00D,EAAA,aAAsB,SAAAC,GACpB,IAAMV,EAAe,oBAArB,GAEA,SAOOA,EAAP,eANS,IAAI,GAAJ,EAAP,0BAWR,OAAO,IAAI,GAAJ,IAAuC5pE,KAA9C,a,KEhHE,G,WAOJ,cAAkC,oBANjB,KAAAypE,UAAY,IAAZ,IACA,KAAAC,QAAU,IAAV,IAGA,KAAAC,cAAgB,IAAhB,IAGf3pE,KAAA,QAAe4N,EAAf,QADgC,oBAGLA,EAA3B,eAHgC,IAGhC,2BAAkD,KAAlD,EAAkD,QAChD5N,KAAA,kBAAuB4pE,EAAvB,SAJ8B,kDAObh8D,EAAnB,OAPgC,IAOhC,2BAAkC,KAAlC,EAAkC,QAC1Bi8D,EAAWC,EAAA,QAAjB,WACMC,EAASD,EAAA,MAAf,WAEA9pE,KAAA,mBACAA,KAAA,kBAZ8B,+B,0DAiBhC,MAAO,CACL,IAAI,GAAM,CACRuqE,MAAOvqE,KAAKypE,UADJ,SAERt8D,QAAS,aAAanN,KAAb,QAFD,gBAGR2pE,cAAe3pE,KAAK2pE,cAAc/qE,gB,KC/B7B4rE,GAGTxtE,OAAA,OAAcA,OAAA,OAAd,MAAmC,CACrCiD,OAAQ,CACNwM,KAAM,qBAAF,O,SADE,kBAENg+D,OAAQ,UAEVrrE,OAAQ,CACNqN,KAAM,qBAAF,O,SAAA,mBAENi+D,WAAY,CACVj+D,KAAM,qBAAF,O,SAAA,mBAENjK,QAAS,CACPiK,KAAM,qBAAF,O,SAAA,sBCXF,G,WACJ,wBAM0C,oBAL/B,KAAAlO,MACA,KAAA4O,UACA,KAAAwI,SACA,KAAA3D,eACA,KAAA24D,iBACA,KAAAt9D,S,iDAIT,OAAOrN,KAAKzB,IAAZ,a,+BAIA,OAAOyB,KAAKmN,QAAZ,e,KCGE,G,WAwBJ,cAA8E,WAA3CS,EAA2C,uDAA9E,GAA8E,oBAAzD,KAAAT,UAvBJ,KAAAy9D,SAAW,IAAX,IACA,KAAAL,MAAQ,IAAR,IACR,KAAAM,OAAA,GACA,KAAAC,KAAO,IAAP,IACQ,KAAAnB,cAAgB,IAAhB,IAEA,KAAAoB,wBAA0B,IAA1B,IAGA,KAAAC,mBAAqB,IAArB,IACA,KAAAC,eAAiB,IAAjB,IACA,KAAAC,kBAAoB,IAApB,IAOR,KAAA/hE,KAAO,IAAInK,SAAe,cACjC,eAAkB,eAAiB,gBAAGmsE,EAAH,EAAGA,MAAH,OAAe9oE,EAAlD,OACA,eAAkB,WAAa,gBAAG5B,EAAH,EAAGA,MAAH,OAAe0K,EAA9C,UAIAnL,KAAA,YAAmB,IAAI,EAAJ,EAA4B4N,EAA/C,OAEA5N,KAAA,aAAkBA,KAAlB,aACAA,KAAA,YAAgB,e,oDA0BX,GACLA,KAAA,e,sCAGa,GACbA,KAAA,kBAAuB4pE,EAAvB,U,+BAIA5pE,KAAA,uB,gCAIAA,KAAA,SACAA,KAAA,qB,sCAGa,GACb,OAAOA,KAAK2pE,cAAcrpE,IAA1B,K,+BAGM,KAAwC,WAC9C,IAAIN,KAAKd,MAAT,yBAIA,IAiCA,EAjCMksE,EAAW,SAAA3sE,GACf,GACE,sCAEF,WAEK,YAAL,KACE,iBAEA,sBAAyB,CAAEgC,MAAOhC,MA0BtC,IACE2B,EAAMqL,IAAA,MAxBU,WAChB,sCAEK,0BAAL,KASE,yBAA4B,CAC1B4/D,SAAU,CACRC,UAAW,gBADH,KAERv+C,QAAS,0BAA6BhC,QAX1C,0BAA6B,CAC3BogD,MAAO,IAAI,GAAM,CACfZ,MAAO,EADQ,MAEfp9D,QAAS,EAFM,QAGfw8D,cAAe,+BAgBrB,GACA3pE,KAAA,iCACA,MAAOvB,GACP2sE,EAAA,O,kCArFF,OAAOprE,KAAKgrE,mBAAZ,Q,8BAIA,OAAOhrE,KAAKirE,eAAZ,Q,iCASA,OAAOjrE,KAAKkrE,kBAAZ,Q,4BAIA,OAAOlrE,KAAK2O,YAAZ,U,KAyEE,G,WAUJ,cAAyC,oBATxB,KAAA48D,kBAAoB,IAApB,QACA,KAAAC,oBAAsB,IAAtB,IAKA,KAAA7B,cAAgB,IAAhB,IACA,KAAA8B,4BAA8B,IAA9B,IAGfzrE,KAAA,SAAgB4N,EAAhB,SACA5N,KAAA,SAAgB4N,EAAhB,SACA5N,KAAA,QAAe4N,EAAA,SAAf,cACA5N,KAAA,cAAqB,IAAI,GAAc4N,EAAA,SAAvC,I,2DAGoB,OAAsE,WACtF6O,EAAA,SAAJ,KACAA,EAAA,YAEIzc,KAAK0rE,UAAY1rE,KAAK0rE,SAASC,EAAnC,IAMAlvD,EAAA,mBAAkBmtD,EAAlB,iBAAuC+B,EAAvC,4BAAmD,8BAAA1sE,EAAA,sEAC5B,yCACnB,CACE8mE,QAAS,EADX,QAEEr3D,SAAU,EAFZ,SAGExP,MAAOud,EAAMvd,OAJI,EAArB,GADiD,OAC3CP,EAD2C,OAU3CmrE,EAAO,aACXF,EADW,IAEXA,EAFW,QAGXjrE,EAHW,IAIXA,EAJW,QAKXA,EALW,QAAb,GASA8d,EAAA,WAEA,gBArBiD,+C,+BAyBrC,KAAmC,WAC3C3N,EAAOg7D,EAAA,MAAb,WAEA,IAAIrtD,EAAA,gBAAJ,IAEA,IAAMmvD,EAAuB5rE,KAAK2pE,cAAcxsE,IAAhD,GAEA,KAGE,OAFAsf,EAAA,mBAEOzc,KAAK6rE,kBAAkBpvD,EAA9B,GAUFA,EAAA,iCAAqB,wCAAAxd,EAAA,0DAGfwd,EAAA,gBAAJ,GAHmB,iEAKM,4BACvB,CACEspD,QAAS,EADX,QAEEr3D,SAAU,EAFZ,SAGExP,MAAOud,EAAMvd,OAEf4qE,EAX4B,OAAX,UAKbzF,EALa,QAgBf5nD,EAAA,gBAAJ,GAhBmB,iEAkBW,iCAC5B,CACEspD,QAAS,EADX,QAEEr3D,SAAU,EAFZ,SAGExP,MAAOud,EAAMvd,OAEf4qE,EAN4B,MAO5BzF,EAzB4B,MAAX,UAkBbW,EAlBa,QA8BfvoD,EAAA,gBAAJ,GA9BmB,mDAgCbqvD,EAAclnE,GAAMklE,EAAD,MAAa9E,EAAb,KAAmC,CAC1D+G,cAD0D,GAE1DhG,QAAS,EAAKA,UAEV6D,EAAe,IAAI,GACvBE,EADmB,MAEnBA,EAFmB,UAGnBgC,EAHmB,KAInB,IAAI7mD,IAAI6mD,EAJW,cAKnB9G,EALmB,oCAMfA,EAAJ,SANmB,YAMaX,EANlC,WASA5nD,EAAA,mBACA,oBAAuBmtD,EAAvB,QA9CmB,cAgDCA,EAApB,QAhDmB,IAgDnB,6BAAyC,QACvC,kCAAqC,MAArC,cAjDiB,8BAoDnB,kCAAqCA,EAArC,QAEA,yBAtDmB,gD,qCA0DD,KAAuB,WACrC96D,EAAOvQ,EAD8B,WAI3Cke,EAAA,iCAAqB,8BAAAxd,EAAA,sEACE,yCACnB,CACE8mE,QAAS,EADX,QAEEr3D,SAAU,EAFZ,SAGExP,MAAOud,EAAMvd,OAJjB,GADmB,OACbP,EADa,OASbmrE,EAAO,aACXrtD,EADW,QAEXA,EAFW,QAGX9d,EAHW,IAIXA,EAJW,QAKXA,EALW,QAMX,kBANF,IASA,gBAlBmB,8C,wCAsBE,KACvB,IAAI8d,EAAA,SAAJ,IACAA,EAAA,SAFgE,uBAK9CmtD,EAAlB,cALgE,IAKhE,2BAA6C,KAA7C,EAA6C,QACrCoC,EAAehsE,KAAKurE,kBAAkBpuE,IAA5C,GAEA,GACEsf,EAAA,WAEAzc,KAAA,eAEAA,KAAA,uBAb4D,kC,4BAkB7D,GAE+D,MAAlE4N,EAAkE,uDAF/D,GAIGT,EAAU,UAAhB,YACMsP,EAAQ,IAAI,GAAJ,EAAmB,CAAEvd,MAAO0O,EAAQ1O,QAHgB,cAKlE,GALkE,IAKlE,2BAA+B,KAA/B,EAA+B,QAC7Bc,KAAA,iBAA2B,eAAuB,UAAlD,KANgE,8BASlE,W,iCAGQ,GACR,IAAM8O,EAAO,aAAiBvQ,EAAjB,WAAb,EACMorE,EAAgB3pE,KAAKyrE,4BAA4BtuE,IAAvD,GAEA,KAAmB,qBACjB,GADiB,IACjB,2BAA0C,KAA1C,EAA0C,QACxC6C,KAAA,qBAA0B4pE,EAA1B,OAFe,8BAIjB5pE,KAAA,yCAGFA,KAAA,wBAEA,IAAMuqE,EAAQvqE,KAAKwrE,oBAAoBruE,IAAvC,GAEA,KAAW,qBACT,GADS,IACT,2BAA0B,KAA1B,EAA0B,QACxB6C,KAAA,yBAA8B8pE,EAA9B,aAFO,8BAIT9pE,KAAA,iCAGFA,KAAA,yB,iCAGgB,aAQhB,IAAM8pE,EAAO,CAAEjG,aAAYxyD,UAAS46D,cAAaC,QAAOC,YAAWx+D,WAEnE3N,KAAA,2BAEAA,KAAA,wBAA6BksE,EAA7B,cANkC,oBAOlC,GAPkC,IAOlC,2BAA6B,KAA7B,EAA6B,QAC3BlsE,KAAA,wBAA6B,MAA7B,eARgC,8BAWlC,a,SC1XOosE,GCIApyB,GAuHJ,SAASqyB,GAAgBC,GAC9B,OAAQA,GACN,KAAKtyB,GAAUx9B,IACb,MAAO,MACT,KAAKw9B,GAAUuZ,OACb,MAAO,SACT,KAAKvZ,GAAUe,OACb,MAAO,SACT,KAAKf,GAAU9lB,OACb,MAAO,SACT,KAAK8lB,GAAUn9C,KACb,MAAO,OACT,KAAKm9C,GAAUgB,IACb,MAAO,MACT,KAAKhB,GAAUiB,SACb,MAAO,IACT,KAAKjB,GAAUkB,SACb,MAAO,IACT,KAAKlB,GAAUmB,OACb,MAAO,IACT,KAAKnB,GAAUuyB,UACb,MAAO,KACT,KAAKvyB,GAAUoB,OACb,MAAO,IACT,KAAKpB,GAAUwyB,UACb,MAAO,KACT,KAAKxyB,GAAUqB,OACb,MAAO,IACT,KAAKrB,GAAUsB,OACb,MAAO,IACT,KAAKtB,GAAUuB,MACb,MAAO,IACT,KAAKvB,GAAUwB,KACb,MAAO,IACT,KAAKxB,GAAUyB,MACb,MAAO,IACT,KAAKzB,GAAUyyB,YACb,MAAO,KACT,KAAKzyB,GAAU0B,IACb,MAAO,IACT,KAAK1B,GAAU2B,SACb,MAAO,IACT,KAAK3B,GAAU4B,YACb,MAAO,KACT,KAAK5B,GAAU6B,MACb,MAAO,KACT,KAAK7B,GAAU8B,SACb,MAAO,WACT,KAAK9B,GAAUgC,SACb,MAAO,MACT,KAAKhC,GAAUiC,UACb,MAAO,IACT,KAAKjC,GAAUkC,aACb,MAAO,KACT,KAAKlC,GAAUugB,GACb,MAAO,IACT,KAAKvgB,GAAU0yB,KACb,MAAO,IACT,KAAK1yB,GAAU7nB,GACb,MAAO,IACT,KAAK6nB,GAAUphC,OACb,MAAO,KACT,KAAKohC,GAAU2yB,UAEf,KAAK3yB,GAAU4yB,WACb,MAAO,QACT,KAAK5yB,GAAU6yB,KACb,MAAO,IACT,KAAK7yB,GAAU8yB,MACb,MAAO,IACT,KAAK9yB,GAAU+yB,SACb,MAAO,KACT,KAAK/yB,GAAUgzB,kBACb,MAAO,KACT,KAAKhzB,GAAUoC,UACb,MAAO,KACT,KAAKpC,GAAUqC,WACb,MAAO,KACT,KAAKrC,GAAUsC,UACb,MAAO,IACT,KAAKtC,GAAUuC,WACb,MAAO,IACT,KAAKvC,GAAUwC,WACb,MAAO,IACT,KAAKxC,GAAUyC,SACb,MAAO,QACT,KAAKzC,GAAUizB,SACb,MAAO,IACT,KAAKjzB,GAAUkzB,YACb,MAAO,IACT,KAAKlzB,GAAUmzB,kBACb,MAAO,QACT,KAAKnzB,GAAU2C,SACb,MAAO,QACT,KAAK3C,GAAUozB,KACb,MAAO,IACT,KAAKpzB,GAAUqzB,MACb,MAAO,IACT,KAAKrzB,GAAU6C,OACb,MAAO,IACT,KAAK7C,GAAU8C,KACb,MAAO,IACT,KAAK9C,GAAU+C,MACb,MAAO,IACT,KAAK/C,GAAUszB,SACb,MAAO,KACT,KAAKtzB,GAAUuzB,QACb,MAAO,UACT,KAAKvzB,GAAUwzB,QACb,MAAO,UACT,KAAKxzB,GAAUyzB,YACb,MAAO,cACT,KAAKzzB,GAAU0zB,UACb,MAAO,YACT,KAAK1zB,GAAU2zB,mBACb,MAAO,qBACT,KAAK3zB,GAAU4zB,iBACb,MAAO,mBACT,KAAK5zB,GAAUkD,OACb,MAAO,QACT,KAAKlD,GAAUmD,MACb,MAAO,OACT,KAAKnD,GAAUoD,OACb,MAAO,QACT,KAAKpD,GAAUqD,UACb,MAAO,WACT,KAAKrD,GAAUsD,UACb,MAAO,WACT,KAAKtD,GAAUuD,SACb,MAAO,UACT,KAAKvD,GAAUwD,IACb,MAAO,KACT,KAAKxD,GAAUyD,MACb,MAAO,OACT,KAAKzD,GAAU0D,SACb,MAAO,UACT,KAAK1D,GAAU2D,KACb,MAAO,MACT,KAAK3D,GAAU4D,UACb,MAAO,WACT,KAAK5D,GAAU6D,IACb,MAAO,KACT,KAAK7D,GAAU8D,QACb,MAAO,SACT,KAAK9D,GAAU+D,QACb,MAAO,SACT,KAAK/D,GAAU3uC,OACb,MAAO,QACT,KAAK2uC,GAAUgE,KACb,MAAO,MACT,KAAKhE,GAAUiE,KACb,MAAO,MACT,KAAKjE,GAAU6zB,KACb,MAAO,MACT,KAAK7zB,GAAUkE,OACb,MAAO,QACT,KAAKlE,GAAUmE,OACb,MAAO,QACT,KAAKnE,GAAUoE,MACb,MAAO,OACT,KAAKpE,GAAUqE,KACb,MAAO,MACT,KAAKrE,GAAUlQ,MACb,MAAO,OACT,KAAKkQ,GAAUnQ,OACb,MAAO,QACT,KAAKmQ,GAAUsE,OACb,MAAO,QACT,KAAKtE,GAAUuE,SACb,MAAO,UACT,KAAKvE,GAAUwE,QACb,MAAO,SACT,KAAKxE,GAAUyE,QACb,MAAO,SACT,KAAKzE,GAAU8zB,OACb,MAAO,QACT,KAAK9zB,GAAU0E,MACb,MAAO,OACT,KAAK1E,GAAU2E,MACb,MAAO,OACT,KAAK3E,GAAU4E,OACb,MAAO,QACT,KAAK5E,GAAU6E,IACb,MAAO,KACT,KAAK7E,GAAU8E,YACb,MAAO,aACT,KAAK9E,GAAU/vC,QACb,MAAO,SACT,KAAK+vC,GAAU+E,MACb,MAAO,OACT,KAAK/E,GAAUgF,QACb,MAAO,SACT,KAAKhF,GAAU+zB,OACb,MAAO,QACT,KAAK/zB,GAAUg0B,KACb,MAAO,MACT,KAAKh0B,GAAUi0B,KACb,MAAO,MACT,KAAKj0B,GAAUk0B,SACb,MAAO,UACT,KAAKl0B,GAAUm0B,UACb,MAAO,WACT,KAAKn0B,GAAUo0B,UACb,MAAO,WACT,KAAKp0B,GAAUq0B,QACb,MAAO,SACT,KAAKr0B,GAAUs0B,QACb,MAAO,SACT,KAAKt0B,GAAUu0B,SACb,MAAO,UACT,KAAKv0B,GAAUw0B,WACb,MAAO,YACT,KAAKx0B,GAAUy0B,IACb,MAAO,KACT,KAAKz0B,GAAU00B,MACb,MAAO,OACT,KAAK10B,GAAU20B,MACb,MAAO,OACT,KAAK30B,GAAU40B,YACb,MAAO,aACT,QACE,MAAO,KDxViB,SAAWxC,GACvBA,EAAkBA,EAAiB,KAAtC,GAAyD,OAC1CA,EAAkBA,EAAiB,UAA7CyC,GAA0E,YACjEzC,EAAkBA,EAAiB,IAAlDgC,GAAmE,MACrDhC,EAAkBA,EAAiB,SAA5CqC,GAAuE,WAC3DrC,EAAkBA,EAAiB,OAAjD0C,GAAwE,SAC5D1C,EAAkBA,EAAiB,OAA/C2B,GAAsE,SACzD3B,EAAkBA,EAAiB,QAA/C2C,GAAwE,UACtD3C,EAAkBA,EAAiB,aAAhD4C,GAAmF,eACrE5C,EAAkBA,EAAiB,SAArD6C,GAAgF,WACrE7C,EAAkBA,EAAiB,MAAjD8B,GAAsE,QACxD9B,EAAkBA,EAAiB,SAA9CsC,IAAyE,WAC9DtC,EAAkBA,EAAiB,MAAjD8C,IAAsE,QAC5D9C,EAAkBA,EAAiB,KAA9C+C,IAAiE,OACpD/C,EAAkBA,EAAiB,QAA7C4B,IAAsE,UACrD5B,EAAkBA,EAAiB,YAAhDgD,IAAiF,cACrEhD,EAAkBA,EAAiB,OAApDwC,IAA2E,SAC3DxC,EAAkBA,EAAiB,WAA/CiD,IAA8E,aACrEjD,EAAkBA,EAAiB,IAAnDkD,IAAoE,MACxDlD,EAAkBA,EAAiB,OAA5CmD,IAAmE,SACtDnD,EAAkBA,EAAiB,QAA/CoD,IAAwE,UAC3DpD,EAAkBA,EAAiB,QAAhDqD,IAAyE,UACzDrD,EAAkBA,EAAiB,WAAhDsD,IAA+E,aACtEtD,EAAkBA,EAAiB,IAAnDuD,IAAoE,MACvDvD,EAAkBA,EAAiB,QAA5CwD,IAAqE,UACvDxD,EAAkBA,EAAiB,SAAhDyD,IAA2E,WAC3DzD,EAAkBA,EAAiB,WAAjDmC,IAAgF,aACpEnC,EAAkBA,EAAiB,OAAnDoC,IAA0E,SAC7DpC,EAAkBA,EAAiB,QAA/C0D,IAAwE,UACzD1D,EAAkBA,EAAiB,UAAhDkC,IAA6E,YAC/DlC,EAAkBA,EAAiB,SAAlD+B,IAA6E,WACnE/B,EAAkBA,EAAiB,KAAjD2D,IAAoE,OACvD3D,EAAkBA,EAAiB,QAA7C6B,IAAsE,UAC3D7B,EAAkBA,EAAiB,MAAhDiC,IAAqE,QACxDjC,EAAkBA,EAAiB,QAA9CuC,IAAuE,UAlC3D,CAmC3BvC,KAAsBA,GAAoB,KC/BvB,SAAWpyB,GAEFA,EAAUA,EAAS,gBAAxB,IAAiE,kBAC9DA,EAAUA,EAAS,WAA3B,IAA0D,aACnDA,EAAUA,EAAS,UAA3B,IAAwD,YACrCA,EAAUA,EAAS,qBAA3B,IAA8E,uBACjFA,EAAUA,EAAS,UAA3B,KAAwD,YAC/CA,EAAUA,EAAS,WAA3B,KAA0D,aAE9DA,EAAUA,EAAS,IAAtB,GAAuC,MAC/BA,EAAUA,EAAS,OAAxB,KAA+C,SACzCA,EAAUA,EAAS,OAAzB,MAAgD,SAC1CA,EAAUA,EAAS,OAAzB,MAAgD,SAC5CA,EAAUA,EAAS,KAAzB,MAA4C,OACvCA,EAAUA,EAAS,IAAzB,MAA0C,MAC/BA,EAAUA,EAAS,SAAzB,MAAoD,WAC9CA,EAAUA,EAAS,SAAzB,MAAoD,WAChDA,EAAUA,EAAS,OAAzB,MAAgD,SACvCA,EAAUA,EAAS,UAAzB,MAAsD,YACnDA,EAAUA,EAAS,OAAzB,MAAgD,SACvCA,EAAUA,EAAS,UAAzB,MAAsD,YACnDA,EAAUA,EAAS,OAAzB,MAAgD,SAC1CA,EAAUA,EAAS,OAAzB,MAAgD,SAC3CA,EAAUA,EAAS,MAAzB,MAA8C,QACzCA,EAAUA,EAAS,KAAzB,MAA4C,OACrCA,EAAUA,EAAS,MAAzB,MAA8C,QAClCA,EAAUA,EAAS,YAAzB,MAA0D,cAC5DA,EAAUA,EAAS,IAAzB,MAA0C,MAC/BA,EAAUA,EAAS,SAAzB,MAAoD,WAC1CA,EAAUA,EAAS,YAA1B,OAA2D,cAC1DA,EAAUA,EAAS,MAA1B,OAA+C,QACrCA,EAAUA,EAAS,SAA1B,OAAqD,WAC9CA,EAAUA,EAAS,SAA1B,OAAqD,WAC7CA,EAAUA,EAAS,UAA1B,OAAuD,YAC7CA,EAAUA,EAAS,aAA1B,OAA6D,eAChEA,EAAUA,EAAS,GAA1B,OAAyC,KAChCA,EAAUA,EAAS,KAA1B,OAA6C,OACxCA,EAAUA,EAAS,GAA1B,OAAyC,KAC9BA,EAAUA,EAAS,OAA1B,OAAiD,SACvCA,EAAUA,EAAS,UAA1B,OAAuD,YAC/CA,EAAUA,EAAS,WAA1B,OAAyD,aACxDA,EAAUA,EAAS,KAA1B,OAA6C,OACrCA,EAAUA,EAAS,MAA1B,OAA+C,QACrCA,EAAUA,EAAS,SAA1B,OAAqD,WACrCA,EAAUA,EAAS,kBAA1B,OAAuE,oBACxEA,EAAUA,EAAS,UAA1B,OAAuD,YAC/CA,EAAUA,EAAS,WAA1B,OAAyD,aACnDA,EAAUA,EAAS,UAA1B,OAAuD,YAC/CA,EAAUA,EAAS,WAA1B,OAAyD,aAClDA,EAAUA,EAAS,WAA1B,OAAyD,aACpDA,EAAUA,EAAS,SAA1B,OAAqD,WAC9CA,EAAUA,EAAS,SAA1B,OAAqD,WAC3CA,EAAUA,EAAS,YAA1B,OAA2D,cAC9CA,EAAUA,EAAS,kBAA1B,OAAuE,oBACzEA,EAAUA,EAAS,SAA1B,OAAqD,WAClDA,EAAUA,EAAS,KAA1B,OAA6C,OACrCA,EAAUA,EAAS,MAA1B,OAA+C,QACvCA,EAAUA,EAAS,OAA1B,OAAiD,SAC5CA,EAAUA,EAAS,KAA1B,OAA6C,OACrCA,EAAUA,EAAS,MAA1B,OAA+C,QACrCA,EAAUA,EAAS,SAA1B,OAAqD,WAC/CA,EAAUA,EAAS,QAA1B,OAAmD,UAC5CA,EAAUA,EAAS,QAA1B,OAAmD,UACxCA,EAAUA,EAAS,YAA1B,OAA2D,cACtDA,EAAUA,EAAS,UAA1B,OAAuD,YACvCA,EAAUA,EAAS,mBAA1B,OAAyE,qBACpEA,EAAUA,EAAS,iBAA1B,OAAqE,mBACxEA,EAAUA,EAAS,OAA1B,OAAiD,SAC3CA,EAAUA,EAAS,MAA1B,OAA+C,QACvCA,EAAUA,EAAS,OAA1B,OAAiD,SACvCA,EAAUA,EAAS,UAA1B,OAAuD,YAChDA,EAAUA,EAAS,UAA1B,OAAuD,YACjDA,EAAUA,EAAS,SAA1B,OAAqD,WACnDA,EAAUA,EAAS,IAA1B,OAA2C,MAClCA,EAAUA,EAAS,MAA1B,OAA+C,QACrCA,EAAUA,EAAS,SAA1B,OAAqD,WAClDA,EAAUA,EAAS,KAA1B,OAA6C,OACjCA,EAAUA,EAAS,UAA1B,OAAuD,YACtDA,EAAUA,EAAS,IAA1B,OAA2C,MAChCA,EAAUA,EAAS,QAA1B,OAAmD,UAC5CA,EAAUA,EAAS,QAA1B,OAAmD,UAC7CA,EAAUA,EAAS,OAA1B,OAAiD,SAC5CA,EAAUA,EAAS,KAA1B,OAA6C,OACtCA,EAAUA,EAAS,KAA1B,OAA6C,OACtCA,EAAUA,EAAS,KAA1B,OAA6C,OACpCA,EAAUA,EAAS,OAA1B,OAAiD,SAC1CA,EAAUA,EAAS,OAA1B,OAAiD,SAC3CA,EAAUA,EAAS,MAA1B,OAA+C,QACzCA,EAAUA,EAAS,KAA1B,OAA6C,OACrCA,EAAUA,EAAS,MAA1B,OAA+C,QACvCA,EAAUA,EAAS,OAA1B,OAAiD,SAC1CA,EAAUA,EAAS,OAA1B,MAAiD,SACxCA,EAAUA,EAAS,SAA1B,OAAqD,WAC/CA,EAAUA,EAAS,QAA1B,OAAmD,UAC5CA,EAAUA,EAAS,QAA1B,OAAmD,UAC7CA,EAAUA,EAAS,OAA1B,OAAiD,SAC3CA,EAAUA,EAAS,MAA1B,OAA+C,QACxCA,EAAUA,EAAS,MAA1B,OAA+C,QACvCA,EAAUA,EAAS,OAA1B,OAAiD,SAC7CA,EAAUA,EAAS,IAA1B,OAA2C,MAC5BA,EAAUA,EAAS,YAA1B,OAA2D,cACxDA,EAAUA,EAAS,QAA1B,OAAmD,UAC9CA,EAAUA,EAAS,MAA1B,OAA+C,QACtCA,EAAUA,EAAS,QAA1B,OAAmD,UAC7CA,EAAUA,EAAS,OAA1B,OAAiD,SAC5CA,EAAUA,EAAS,KAA1B,OAA6C,OACtCA,EAAUA,EAAS,KAA1B,OAA6C,OAClCA,EAAUA,EAAS,SAA1B,OAAqD,WAC7CA,EAAUA,EAAS,UAA1B,OAAuD,YAChDA,EAAUA,EAAS,UAA1B,OAAuD,YAClDA,EAAUA,EAAS,QAA1B,OAAmD,UAC5CA,EAAUA,EAAS,QAA1B,OAAmD,UAC3CA,EAAUA,EAAS,SAA1B,OAAqD,WAC5CA,EAAUA,EAAS,WAA1B,OAAyD,aACzDA,EAAUA,EAAS,IAA1B,OAA2C,MAClCA,EAAUA,EAAS,MAA1B,OAA+C,QACxCA,EAAUA,EAAS,MAA1B,OAA+C,QAClCA,EAAUA,EAAS,YAA1B,OAA2D,cArH3D,CAsHnBA,KAAcA,GAAY,KCtHtB,ICJIg2B,GCGAC,GACAC,GACAC,GACAl/B,GACA+O,GACAowB,GFJExa,GAKX,WAAYya,EAAiBC,EAAeC,GAAiB,oBAC3DvwE,KAAKqwE,gBAAkBA,EACvBrwE,KAAKswE,cAAgBA,EACrBtwE,KAAKuwE,gBAAkBA,GAIdC,GACX,WACG7tB,EACA8tB,EACAC,EACAC,EACAppE,EACAjG,EACAsvE,EACA5sE,EACAJ,EACAitE,EACAC,EACArwE,GACD,oBAAET,KAAK2iD,iBAAmBA,EAAiB3iD,KAAKywE,mBAAqBA,EAAmBzwE,KAAK0wE,aAAeA,EAAa1wE,KAAK2wE,aAAeA,EAAa3wE,KAAKuH,IAAMA,EAAIvH,KAAKsB,KAAOA,EAAKtB,KAAK4wE,kBAAoBA,EAAkB5wE,KAAKgE,MAAQA,EAAMhE,KAAK4D,IAAMA,EAAI5D,KAAK6wE,OAASA,EAAO7wE,KAAK8wE,WAAaA,EAAW9wE,KAAKS,MAAQA,GAGrTswE,G,WAAO,aAAc,oBAAEA,EAAM7yE,UAAU8yE,OAAOv0E,KAAKuD,MAAM+wE,EAAM7yE,UAAU+yE,QAAQx0E,KAAKuD,MAAM+wE,EAAM7yE,UAAUgzE,QAAQz0E,KAAKuD,MAAM+wE,EAAM7yE,UAAUizE,QAAQ10E,KAAKuD,MAAM+wE,EAAM7yE,UAAUkzE,QAAQ30E,KAAKuD,MAAM+wE,EAAM7yE,UAAUmzE,QAAQ50E,KAAKuD,MAAM+wE,EAAM7yE,UAAUozE,QAAQ70E,KAAKuD,MAAM+wE,EAAM7yE,UAAUqzE,QAAQ90E,KAAKuD,MAAM+wE,EAAM7yE,UAAUszE,QAAQ/0E,KAAKuD,MAAM+wE,EAAM7yE,UAAUuzE,SAASh1E,KAAKuD,MAAM+wE,EAAM7yE,UAAUwzE,SAASj1E,KAAKuD,MAAM+wE,EAAM7yE,UAAUyzE,SAASl1E,KAAKuD,M,qDAEhcA,KAAK2iD,kBAAoB,I,gCAGxB3iD,KAAKywE,oBAAqB,I,gCAG1BzwE,KAAKsxB,OAAS,K,gCAGdtxB,KAAKkqE,OAAS,K,gCAGdlqE,KAAKuH,IAAM,I,gCAGXvH,KAAKsB,KAAOswE,GAAG52B,M,gCACfh7C,KAAK4wE,kBAAoBxE,GAAkByC,O,gCAC3C7uE,KAAKgE,MAAQ,I,gCACbhE,KAAK4D,IAAM,I,iCAEV5D,KAAK6wE,QAAS,I,iCACd7wE,KAAK8wE,WAAa,I,iCAUlB9wE,KAAKS,MAAQ,O,iCAGvB,OAAO,IAAI+vE,GACTxwE,KAAK2iD,iBACL3iD,KAAKywE,mBACLzwE,KAAKsxB,OAAOjuB,OACZrD,KAAKkqE,OAAO7mE,OACZrD,KAAKuH,IACLvH,KAAKsB,KACLtB,KAAK4wE,kBACL5wE,KAAKgE,MACLhE,KAAK4D,IACL5D,KAAK6wE,OACL7wE,KAAK8wE,WACL9wE,KAAKS,S,0CAIWqmB,GAClB9mB,KAAK2iD,iBAAmB77B,EAAS67B,iBACjC3iD,KAAKywE,mBAAqB3pD,EAAS2pD,mBACnCzwE,KAAKsxB,OAAOjuB,OAASyjB,EAAS4pD,aAC9B1wE,KAAKkqE,OAAO7mE,OAASyjB,EAAS6pD,aAC9B3wE,KAAKuH,IAAMuf,EAASvf,IACpBvH,KAAKsB,KAAOwlB,EAASxlB,KACrBtB,KAAK4wE,kBAAoB9pD,EAAS8pD,kBAClC5wE,KAAKgE,MAAQ8iB,EAAS9iB,MACtBhE,KAAK4D,IAAMkjB,EAASljB,IACpB5D,KAAK6wE,OAAS/pD,EAAS+pD,OACvB7wE,KAAK8wE,WAAahqD,EAASgqD,WAC3B9wE,KAAKS,MAAQqmB,EAASrmB,U,KEvFnB,SAASoxE,KACd,OAAOzB,KAIF,SAAS0B,GAAarxE,GAC3B,GAAI,QAASA,EAAO,CAClB,IAAMqiC,EAgBH,SAA0Bv7B,GAG/B,IAFA,IAAIk6B,EAAO,EACPuB,EAAS,EACJ1mC,EAAI,EAAGA,EAAIiL,EAAKjL,IACnB0jD,GAAMlyB,WAAWxxB,KAAO0zE,GAAU+B,UACpCtwC,IACAuB,EAAS,GAETA,IAGJ,OAAO,IAAIgvC,GAAIvwC,EAAMuB,GA3BP2M,CAAiBlvC,EAAM8G,KACnC9G,EAAM2iB,SAAN,YAAsB0f,EAAIrB,KAA1B,YAAkCqB,EAAIE,OAAtC,KACAviC,EAAMqiC,IAAMA,EAEd,OAAOriC,GDrBa,SAAWuvE,GACVA,EAAUA,EAAS,UAAtB,GAAmD,YAChDA,EAAUA,EAAS,SAAvB,IAAkD,WACxCA,EAAUA,EAAS,eAAvB,IAA8D,iBAChEA,EAAUA,EAAS,SAAvB,IAAkD,WACjDA,EAAUA,EAAS,MAAvB,IAA4C,QAC9BA,EAAUA,EAAS,gBAAvB,IAAgE,kBAC9DA,EAAUA,EAAS,cAAvB,IAA4D,gBAC3DA,EAAUA,EAAS,WAAvB,IAAsD,aAClDA,EAAUA,EAAS,WAAvB,IAAsD,aACjDA,EAAUA,EAAS,YAAvB,IAAwD,cACtDA,EAAUA,EAAS,UAAvB,IAAoD,YAC/CA,EAAUA,EAAS,WAAvB,IAAsD,aAC7CA,EAAUA,EAAS,gBAAvB,IAAgE,kBAC3DA,EAAUA,EAAS,iBAAvB,IAAkE,mBACtEA,EAAUA,EAAS,SAAvB,IAAkD,WAC9CA,EAAUA,EAAS,SAAvB,IAAkD,WACjDA,EAAUA,EAAS,MAAvB,IAA4C,QACzCA,EAAUA,EAAS,KAAvB,IAA0C,OACvCA,EAAUA,EAAS,IAAvB,IAAwC,MAClCA,EAAUA,EAAS,MAAvB,IAA4C,QACvCA,EAAUA,EAAS,OAAvB,IAA8C,SAC1CA,EAAUA,EAAS,OAAvB,IAA8C,SAC1CA,EAAUA,EAAS,OAAvB,IAA8C,SAC1CA,EAAUA,EAAS,OAAvB,IAA8C,SAC1CA,EAAUA,EAAS,OAAvB,IAA8C,SAC1CA,EAAUA,EAAS,OAAvB,IAA8C,SAC1CA,EAAUA,EAAS,OAAvB,IAA8C,SAC1CA,EAAUA,EAAS,OAAvB,IAA8C,SAC1CA,EAAUA,EAAS,OAAvB,IAA8C,SAC1CA,EAAUA,EAAS,OAAvB,IAA8C,SAC3CA,EAAUA,EAAS,MAAvB,IAA4C,QACpCA,EAAUA,EAAS,UAAvB,IAAoD,YACjDA,EAAUA,EAAS,SAAvB,IAAkD,WAC9CA,EAAUA,EAAS,SAAvB,IAAkD,WAC3CA,EAAUA,EAAS,YAAvB,IAAwD,cACnDA,EAAUA,EAAS,aAAvB,IAA0D,eAC5DA,EAAUA,EAAS,OAAvB,IAA8C,SACtCA,EAAUA,EAAS,WAAvB,IAAsD,aAClDA,EAAUA,EAAS,WAAvB,IAAsD,aAClDA,EAAUA,EAAS,WAAvB,IAAsD,aAClDA,EAAUA,EAAS,WAAvB,IAAsD,aAClDA,EAAUA,EAAS,WAAvB,IAAsD,aAClDA,EAAUA,EAAS,WAAvB,IAAsD,aAClDA,EAAUA,EAAS,WAAvB,IAAsD,aAClDA,EAAUA,EAAS,WAAvB,IAAsD,aAClDA,EAAUA,EAAS,WAAvB,IAAsD,aAClDA,EAAUA,EAAS,WAAvB,IAAsD,aAClDA,EAAUA,EAAS,WAAvB,IAAsD,aAClDA,EAAUA,EAAS,WAAvB,IAAsD,aAClDA,EAAUA,EAAS,WAAvB,IAAsD,aAClDA,EAAUA,EAAS,WAAvB,IAAsD,aAClDA,EAAUA,EAAS,WAAvB,IAAsD,aAClDA,EAAUA,EAAS,WAAvB,IAAsD,aAClDA,EAAUA,EAAS,WAAvB,IAAsD,aAClDA,EAAUA,EAAS,WAAvB,IAAsD,aAClDA,EAAUA,EAAS,WAAvB,IAAsD,aAClDA,EAAUA,EAAS,WAAvB,IAAsD,aAClDA,EAAUA,EAAS,WAAvB,IAAsD,aAClDA,EAAUA,EAAS,WAAvB,IAAsD,aAClDA,EAAUA,EAAS,WAAvB,IAAsD,aAClDA,EAAUA,EAAS,WAAvB,IAAsD,aAClDA,EAAUA,EAAS,WAAvB,IAAsD,aAClDA,EAAUA,EAAS,WAAvB,IAAsD,aAC3CA,EAAUA,EAAS,kBAAvB,IAAoE,oBACxEA,EAAUA,EAAS,UAAvB,IAAoD,YACvCA,EAAUA,EAAS,mBAAvB,IAAsE,qBAC/EA,EAAUA,EAAS,MAAvB,IAA4C,QACnCA,EAAUA,EAAS,WAAvB,IAAsD,aACjDA,EAAUA,EAAS,YAAvB,IAAwD,cACrDA,EAAUA,EAAS,WAAvB,IAAsD,aAClDA,EAAUA,EAAS,WAAvB,IAAsD,aAClDA,EAAUA,EAAS,WAAvB,IAAsD,aACjDA,EAAUA,EAAS,WAAxB,KAAuD,aAClDA,EAAUA,EAAS,WAAxB,KAAuD,aAClDA,EAAUA,EAAS,WAAxB,KAAuD,aAClDA,EAAUA,EAAS,WAAxB,KAAuD,aAClDA,EAAUA,EAAS,WAAxB,KAAuD,aAClDA,EAAUA,EAAS,WAAxB,KAAuD,aAClDA,EAAUA,EAAS,WAAxB,KAAuD,aAClDA,EAAUA,EAAS,WAAxB,KAAuD,aAClDA,EAAUA,EAAS,WAAxB,KAAuD,aAClDA,EAAUA,EAAS,WAAxB,KAAuD,aAClDA,EAAUA,EAAS,WAAxB,KAAuD,aAClDA,EAAUA,EAAS,WAAxB,KAAuD,aAClDA,EAAUA,EAAS,WAAxB,KAAuD,aAClDA,EAAUA,EAAS,WAAxB,KAAuD,aAClDA,EAAUA,EAAS,WAAxB,KAAuD,aAClDA,EAAUA,EAAS,WAAxB,KAAuD,aAClDA,EAAUA,EAAS,WAAxB,KAAuD,aAClDA,EAAUA,EAAS,WAAxB,KAAuD,aAClDA,EAAUA,EAAS,WAAxB,KAAuD,aAClDA,EAAUA,EAAS,WAAxB,KAAuD,aAClDA,EAAUA,EAAS,WAAxB,KAAuD,aAClDA,EAAUA,EAAS,WAAxB,KAAuD,aAClDA,EAAUA,EAAS,WAAxB,KAAuD,aAC9CA,EAAUA,EAAS,eAAxB,KAA+D,iBAC7DA,EAAUA,EAAS,YAAxB,KAAyD,cAChDA,EAAUA,EAAS,gBAAxB,KAAiE,kBACtEA,EAAUA,EAAS,MAAxB,KAA6C,QAC7BA,EAAUA,EAAS,iBAAxB,KAAmE,mBAE/DA,EAAUA,EAAS,eAAzB,MAAgE,iBAC3DA,EAAUA,EAAS,cAAzB,MAA8D,gBACnDA,EAAUA,EAAS,mBAAzB,MAAwE,qBAxG/E,CAyGnBA,KAAcA,GAAY,KCjFtB,IAAMgC,GAGX,WAAYvwC,EAAMuB,GAAQ,oBACxBhjC,KAAKyhC,KAAOA,EACZzhC,KAAKgjC,OAASA,GCpBX,SAASsiB,GAAasrB,GAC3B,OAAO3/B,GAAM2/B,oBAAsBA,EAG9B,SAASqB,GAAsBrB,GACpC,IAAMr0E,EAAI21E,KACV,OAAO31E,EAAE+E,OAASswE,GAAG/0E,MAAQN,EAAEq0E,oBAAsBA,EAIhD,SAASrrB,GAAcqrB,GAC5B,OAAO3/B,GAAM2/B,oBAAsBA,GAAqBvrB,GAAIusB,GAAG/0E,MAI1D,SAAS2oD,GAAiBorB,GAC1BrrB,GAAcqrB,IACjBnrB,KAKG,SAASC,KACd,OAAOh/C,GAAMkrE,GAAG52B,MAAQt0C,GAAMkrE,GAAGx2B,SAAW+2B,KAGvC,SAASA,KAGd,IAFA,IAAMC,EAAYnhC,GAAM3f,OAAO2f,GAAM3f,OAAOjuB,OAAS,GAE5C/G,EADU81E,EAAYA,EAAUxuE,IAAM,EACtBtH,EAAI20C,GAAMjtC,MAAO1H,IAAK,CAC7C,IAAMqF,EAAOq+C,GAAMlyB,WAAWxxB,GAC9B,GACEqF,IAASquE,GAAU+B,UACnBpwE,IAASquE,GAAUqC,gBACV,OAAT1wE,GACS,OAATA,EAEA,OAAO,EAGX,OAAO,EAGF,SAAS2wE,KACd,OAAOjtB,GAAIusB,GAAGp2B,OAASkK,KAKlB,SAASE,KACT0sB,MACH7sB,GAAW,kCAMR,SAASO,GAAO1kD,GACL+jD,GAAI/jD,IAElBmkD,GAAW,+BAAD,OAAgC4mB,GAAgB/qE,GAAhD,MAQP,SAASmkD,KAA4D,IAAjDriC,EAAiD,uDAAvC,mBAAoB7b,EAAmB,uDAAb0pC,GAAMjtC,MACnE,IAAIitC,GAAMxwC,MAAV,CAIA,IAAMhC,EAAM,IAAIg3D,YAAYryC,GAC5B3kB,EAAI8I,IAAMA,EACV0pC,GAAMxwC,MAAQhC,EACdwyC,GAAM1pC,IAAMy4C,GAAM38C,OAClBg8D,GAAYuS,GAAG52B,MC1DjB,IAzBO,IAAMu3B,GAAmB,CAC9B,EACA,GACA,GACAvC,GAAUwC,MACVxC,GAAUyC,iBACVzC,GAAU0C,eACV,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,MACA,OAGWC,GAAgB,IAAIj/C,WAAW,OAC5C,QAAmB6+C,GAAnB,kBAAqC,CACnCI,GADa,QACS,EC1BxB,SAASC,GAAwBjxE,GAC/B,GAAIA,EAAO,GAAI,OAAgB,KAATA,EACtB,GAAIA,EAAO,GAAI,OAAO,EACtB,GAAIA,EAAO,GAAI,OAAO,EACtB,GAAIA,EAAO,GAAI,OAAO,EACtB,GAAIA,EAAO,GAAI,OAAgB,KAATA,EACtB,GAAIA,EAAO,IAAK,OAAO,EACvB,GAAIA,EAAO,IAAK,OAAO,EACvB,MAAM,IAAIjC,MAAM,kDAIlB,IADO,IAAMmzE,GAAqB,IAAIn/C,WAAW,OACxCp3B,GAAI,EAAGA,GAAI,IAAKA,KACvBu2E,GAAmBv2E,IAAKs2E,GAAwBt2E,IAAK,EAAI,EAE3D,IAAK,IAAIA,GAAI,IAAKA,GAAI,MAAOA,KAC3Bu2E,GAAmBv2E,IAAK,E,sBAKGi2E,I,IAA7B,8BAA+C,KAApCO,GAAoC,SAC7CD,GAAmBC,IAAkB,G,kCAEvCD,GAAmB,MAAU,EAC7BA,GAAmB,MAAU,EAG7B,IADO,IAAME,GAAsBF,GAAmBtzD,QAC7CyzD,GAAUhD,GAAUiD,OAAQD,IAAWhD,GAAUkD,OAAQF,KAChED,GAAoBC,IAAW,EC3B1B,ICMIG,GDNEC,GAAiB,IAAI1kC,WAAW,EAE1C,EAAG,GAAI,IAAK,IAAK,KAAM,KAAM,KAAM,MAAO,EAAG,MAAO,EAAG,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAG,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAG,MAAO,GAE9I,GAAI,EAAG,IAAK,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,KAAM,GAAI,GAAI,EAAG,KAAM,GAAI,GAAI,GAE1G,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,IAAK,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAExG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,KAAM,GAAI,GAAI,GAAI,GAAI,GAAI,GAEzG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,KAAM,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAEzG,EAAG,KAAM,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAEzG,GAAI,GAAI,EAAG,KAAM,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAEzG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,KAAM,GAAI,GAAI,GAAI,GAAI,GAAI,EAE1G09B,GAAkBgC,WAAa,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAEvIhC,GAAkBqC,KAAO,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,KAAM,GAAI,GAAI,GAAI,GAAI,EAAG,KAAM,GAElI,GAAI,GAAI,GAAI,GAAI,EAAG,KAAM,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAEzG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,KAAM,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAEzG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,KAAM,GAAI,GAAI,GAAI,GAAI,GAAI,GAEzG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,KAAM,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAE1GrC,GAAkB0C,UAAY,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAErI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,KAAM,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAEzG,GAAI,GAAI,EAAG,KAAM,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAE1G1C,GAAkB2B,QAAU,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAEnI,EAAG,KAAM,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAEzG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,KAAM,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAEzG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,KAAM,GAAI,GAAI,GAAI,GAAI,GAAI,EAE1G3B,GAAkB2C,QAAU,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAEnI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,KAAM,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAEzG,GAAI,GAAI,GAAI,GAAI,EAAG,KAAM,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAEzG,EAAG,KAAM,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAEzG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,KAAM,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAEvF,GAAlB6C,GAAG10B,QAAU,IAAS,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAE1H,EAAG,KAAM,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,KAAM,GAAI,GAAI,EAAG,MAAO,GAAI,EAAG,MAAO,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAE9G,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,IAAK,KAAM,GAAI,GAAI,GAAI,GAAI,GAAI,GAE1G,GAAI,GAAI,GAAI,GAAI,EAAG,KAAM,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAExF,GAAjB00B,GAAGz0B,OAAS,IAAS,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAEzH,GAAI,GAAI,EAAG,KAAM,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAEzG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,KAAM,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAEvF,GAAlBy0B,GAAGx0B,QAAU,IAAS,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAE1H,GAAI,GAAI,GAAI,GAAI,EAAG,KAAM,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAEzG,GAAI,GAAI,EAAG,KAAM,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAEzG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,KAAM,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAEzG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,MAAO,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAE3GgvB,GAAkB4C,SAAW,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAEpI,EAAG,MAAO,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAE1G,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,MAAO,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAE1G,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,MAAO,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAExF,GAAlB4C,GAAGtzB,QAAU,IAAS,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAE1H,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,MAAO,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAE1G,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,KAAM,MAAO,GAAI,GAAI,GAAI,GAAI,GAAI,GAE5G,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,MAAO,GAAI,GAAI,GAAI,GAAI,GAAI,EAExF,GAAlBszB,GAAG1zB,QAAU,IAAS,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,MAAO,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAE5H,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,MAAO,GAAI,GAAI,GAAI,GAAI,GAE1G,GAAI,GAAI,EAAG,MAAO,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAE1G,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,MAAO,GAAI,GAAI,GAAI,GAAI,GAAI,GAE1G,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,MAAO,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAE1G,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,MAAO,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAE3GkuB,GAAkB6C,cAAgB,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAEzI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,MAAO,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAE1G,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,MAAO,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAE1G,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,MAAO,GAAI,GAAI,GAAI,GAAI,GAE1G,GAAI,GAAI,GAAI,GAAI,EAAG,MAAO,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAErF,GAArB2C,GAAGv0B,WAAa,IAAS,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAE7H,GAAI,GAAI,GAAI,GAAI,EAAG,MAAO,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,MAAO,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAE5G,GAAI,EAAG,KAAM,MAAO,GAAI,EAAG,MAAO,GAAI,GAAI,GAAI,GAAI,EAAG,MAAO,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAEhH,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,MAAO,GAAI,GAAI,GAAI,GAAI,GAE1G,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,MAAO,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAE1G,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,MAAO,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAE1G,GAAI,GAAI,GAAI,GAAI,EAAG,MAAO,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAE1G,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,MAAO,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAErF,GAArBu0B,GAAGt0B,WAAa,IAAS,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAE7H,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,MAAO,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAE1G,EAAG,MAAO,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAE1G,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,MAAO,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAE1G,GAAI,GAAI,GAAI,GAAI,EAAG,MAAO,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAE3G8uB,GAAkB8B,UAAY,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAErI,EAAG,MAAO,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAE1G,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,MAAO,GAAI,GAAI,GAAI,GAAI,GAE1G,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,MAAO,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAE1G,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,MAAO,GAAI,GAAI,GAAI,GAAI,GAAI,EAEtF,GAApB0D,GAAGr0B,UAAY,IAAS,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAE5H,GAAI,GAAI,GAAI,GAAI,EAAG,MAAO,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAE1G,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,MAAO,GAAI,GAAI,GAAI,GAAI,GAAI,GAE1G,GAAI,GAAI,GAAI,GAAI,EAAG,MAAO,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAEvF,GAAnBq0B,GAAG5yB,SAAW,IAAS,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAE5G,GAAf4yB,GAAGp0B,KAAO,IAAS,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAEvH,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,MAAO,EAAG,MAAO,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,MAAO,GAAI,GAE9G,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,MAAO,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAE1G,GAAI,GAAI,GAAI,GAAI,EAAG,MAAO,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAEzF,GAAjBo0B,GAAGn0B,OAAS,IAAS,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAEzH,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,MAAO,GAAI,GAAI,GAAI,GAAI,GAE1G,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,MAAO,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAE3G2uB,GAAkBsC,OAAS,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAElI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,MAAO,GAAI,GAAI,EAAG,MAAO,GAAI,GAAI,GAAI,GAAI,GAAI,GAE5G,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,MAAO,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAE1G,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,MAAO,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAE1G,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,MAAO,GAAI,GAAI,GAAI,GAAI,GAAI,EAEvF,GAAnBkD,GAAGpzB,SAAW,IAAS,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,MAAO,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAE9H4tB,GAAkB8C,UAAY,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAErI,GAAI,GAAI,GAAI,GAAI,EAAG,MAAO,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAE1G,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,MAAO,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAE1G,GAAI,GAAI,GAAI,EAAG,MAAO,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAE1G,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,MAAO,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAEtF,GAApB0C,GAAGrzB,UAAY,IAAS,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAE5H,EAAG,MAAO,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,MAAO,GAAI,GAAI,GAAI,GAAI,EAAG,MAAO,GAAI,EAAG,MAAO,GAAI,EAAG,MAAO,GAAI,GAAI,GAAI,GAAI,GAElH,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,MAAO,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAE1G,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,MAAO,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAE1G,GAAI,GAAI,GAAI,GAAI,EAAG,MAAO,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAExF,GAAlBqzB,GAAGhzB,QAAU,IAAS,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAE1H,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,MAAO,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAE1G,EAAG,MAAO,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAE1G,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,MAAO,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAE1G,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,MAAO,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAE1G,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,MAAO,EAEtF,GAApBgzB,GAAGl0B,UAAY,IAAS,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAE5H,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,MAAO,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAE1F,GAAhBk0B,GAAGj0B,MAAQ,IAAS,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAExH,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,MAAO,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAE1G,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,MAAO,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAE3GyuB,GAAkB+C,OAAS,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAElI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,MAAO,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAE1G,GAAI,GAAI,EAAG,MAAO,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAE1G,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,MAAO,GAAI,GAAI,GAAI,GAAI,GAAI,GAE1G,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,MAAO,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAE1G,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,MAAO,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI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I,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAE1G,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,MAAO,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAE3GutB,GAAkBiD,QAAU,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAEnI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,MAAO,GAAI,GAAI,GAAI,GAAI,GAAI,GAE1G,EAAG,MAAO,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAE1G,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,MAAO,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAE1G,GAAI,GAAI,EAAG,MAAO,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAE1G,GAAI,GAAI,GAAI,GAAI,EAAG,MAAO,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAE1G,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,MAAO,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAE1G,GAAI,GAAI,GAAI,GAAI,GAA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AAI,GAAI,GAE1G,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,MAAO,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAE1G,GAAI,GAAI,GAAI,GAAI,EAAG,MAAO,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAE3GrD,GAAkBsD,SAAW,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAEpI,EAAG,MAAO,GAAI,GAAI,EAAG,MAAO,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,MAAO,GAAI,GAAI,GAAI,GAAI,GAE9G,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,MAAO,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAE1G,GAAI,GAAI,GAAI,GAAI,EAAG,MAAO,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAE1G,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,MAAO,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAE1G,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,MAAO,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAE1G,EAAG,MAAO,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GA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AAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAE5G,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,MAAO,GAAI,GAAI,GAAI,GAE1G,EAAG,MAAO,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAE1G,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,MAAO,GAAI,GAAI,GAAI,GAAI,GAAI,GAE1G,GAAI,GAAI,GAAI,GAAI,EAAG,MAAO,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAE3GzD,GAAkBmC,UAAY,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAErI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,MAAO,GAAI,GAAI,GAAI,GAAI,GAAI,GAE1G,GAAI,GAAI,GAAI,GAAI,EAAG,MAAO,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,MAAO,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAE5G,GAAI,GAAI,EAAG,MAAO,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAE1G,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GA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","file":"static/js/0.5d986f47.chunk.worker.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/velcro/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 90);\n","type Buffer = {\n  from(\n    buf: BufferSource | string,\n    encoding?: 'base64'\n  ): {\n    toString(encoding: 'base64' | 'utf-8'): string;\n  };\n};\n\nexport namespace Base64 {\n  export const decode =\n    typeof global === 'object' && typeof global['Buffer'] === 'function'\n      ? (data: string) => (global['Buffer'] as Buffer).from(data, 'base64').toString('utf-8')\n      : typeof atob === 'function'\n      ? (data: string) => decodeURIComponent(escape(atob(data)))\n      : (_data: string) => {\n          throw new Error(\n            'The environment has neither the Buffer nor btoa functions. Please consider polyfilling one of these apis.'\n          );\n        };\n\n  export const encode =\n    typeof global === 'object' && typeof global['Buffer'] === 'function'\n      ? (data: string) => (global['Buffer'] as Buffer).from(data).toString('base64')\n      : typeof btoa === 'function'\n      ? (data: string) => btoa(unescape(encodeURIComponent(data)))\n      : (_data: string) => {\n          throw new Error(\n            'The environment has neither the Buffer nor btoa functions. Please consider polyfilling one of these apis.'\n          );\n        };\n}\n","import type { Uri } from './uri';\n\nabstract class BaseError extends Error {\n  readonly name = this.constructor.name;\n}\n\nexport class AmbiguousModuleError extends BaseError {}\n\nexport class CanceledError extends BaseError {}\n\nexport class EntryExcludedError extends BaseError {\n  constructor(uri: { toString(): string }) {\n    super(`Entry was excluded by current configuration '${uri.toString()}'`);\n  }\n}\n\nexport class EntryNotFoundError extends BaseError {\n  constructor(uri: { toString(): string }) {\n    super(`Unable to resolve '${uri.toString()}'`);\n  }\n}\n\nexport class DependencyNotFoundError extends EntryNotFoundError {\n  constructor(spec: string, parentUri: { toString(): string }) {\n    super(`The dependency '${spec}' of '${parentUri.toString()}' was not found`);\n  }\n}\n\nexport class NotResolvableError extends BaseError {}\n\nexport class ParseError extends BaseError {\n  constructor(readonly uri: Uri, message: string) {\n    super(`Parsing failed for '${uri.toString()}': ${message}`);\n  }\n}\n\nexport function isCanceledError(err: unknown): err is CanceledError {\n  return err instanceof CanceledError || (err && (err as any).name === 'CanceledError');\n}\n","import type { CancellationToken } from 'ts-primitives';\nimport { CanceledError } from './error';\n\nexport type Awaited<T> = T extends Thenable<infer U> ? U : T;\n\nexport interface Thenable<T> {\n  /**\n   * Attaches callbacks for the resolution and/or rejection of the Promise.\n   * @param onfulfilled The callback to execute when the Promise is resolved.\n   * @param onrejected The callback to execute when the Promise is rejected.\n   * @returns A Promise for the completion of which ever callback is executed.\n   */\n  then<TResult>(\n    onfulfilled?: (value: T) => TResult | Thenable<TResult>,\n    onrejected?: (reason: any) => TResult | Thenable<TResult>\n  ): Thenable<TResult>;\n  then<TResult>(\n    onfulfilled?: (value: T) => TResult | Thenable<TResult>,\n    onrejected?: (reason: any) => void\n  ): Thenable<TResult>;\n}\n\n// See: https://github.com/microsoft/TypeScript/pull/26063#issuecomment-461576933\nexport function all<T extends [unknown] | unknown[]>(values: T, token: CancellationToken) {\n  let shouldAwait = false;\n\n  const result = values.map((element) => {\n    if (isThenable(element)) {\n      shouldAwait = true;\n\n      return checkCancellation(element, token);\n    }\n\n    return element;\n  }) as T;\n\n  if (shouldAwait) {\n    return (Promise.all(result) as unknown) as Promise<{ [P in keyof T]: Awaited<T[P]> }>;\n  }\n\n  return values as { [P in keyof T]: Awaited<T[P]> };\n}\n\nexport async function checkCancellation<T>(promise: Thenable<T>, token: CancellationToken) {\n  try {\n    const result = await promise;\n    if (token.isCancellationRequested) {\n      return Promise.reject(new CanceledError());\n    }\n\n    return result;\n  } catch (err) {\n    if (token.isCancellationRequested) {\n      return Promise.reject(new CanceledError());\n    }\n\n    throw err;\n  }\n}\n\nexport function isThenable<T = unknown>(object: unknown): object is Thenable<T> {\n  return (\n    object &&\n    // Detection of 'normal' thenable\n    (typeof (object as any).then === 'function' ||\n      // Detection for regenerator runtime state\n      (typeof (object as any).done === 'boolean' &&\n        typeof (object as any).next === 'number' &&\n        typeof (object as any).pre === 'number'))\n  );\n}\n","export class Decoder {\n  private readonly decoder: TextDecoder | undefined;\n\n  constructor() {\n    if (typeof TextDecoder !== 'undefined') {\n      this.decoder = new TextDecoder();\n    } else if (typeof Buffer !== 'function' || typeof Buffer['from'] !== 'function') {\n      throw new Error(\n        'The environment supports neither the TextDecoder nor Buffer API. Please consider polyfilling one of these.'\n      );\n    }\n  }\n\n  decode(buf: BufferSource): string {\n    const str = this.decoder\n      ? this.decoder.decode(buf)\n      : (Buffer as any).from(buf).toString('utf-8');\n\n    return str.charCodeAt(0) === 0xfeff ? str.slice(1) : str;\n  }\n}\n","export class MapSet<K, V> {\n  private readonly _data = new Map<K, Set<V>>();\n\n  get size() {\n    return this._data.size;\n  }\n\n  add(key: K, value: V) {\n    let values = this._data.get(key);\n\n    if (!values) {\n      values = new Set();\n      this._data.set(key, values);\n    }\n\n    values.add(value);\n\n    return this;\n  }\n\n  clear() {\n    this._data.clear();\n  }\n\n  delete(key: K, value: V) {\n    const values = this._data.get(key);\n\n    if (values) {\n      const ret = values.delete(value);\n\n      if (!values.size) {\n        this._data.delete(key);\n      }\n\n      return ret;\n    }\n\n    return false;\n  }\n\n  deleteAll(key: K) {\n    return this._data.delete(key);\n  }\n\n  get(key: K) {\n    return this._data.get(key);\n  }\n\n  has(key: K) {\n    return this._data.has(key);\n  }\n\n  hasValue(key: K, value: V) {\n    const values = this._data.get(key);\n\n    return values ? values.has(value) : false;\n  }\n\n  *entries(): IterableIterator<[K, V]> {\n    for (const [key, values] of this._data.entries()) {\n      for (const value of values) {\n        yield [key, value];\n      }\n    }\n  }\n\n  *values(): IterableIterator<V> {\n    for (const values of this._data.values()) {\n      yield* values.values();\n    }\n  }\n}\n","import type { Decoder } from './decoder';\n\nexport type PackageMainField = 'browser' | 'module' | 'jsnext:main' | 'main' | 'unpkg';\n\nexport interface PartialPackageJson {\n  name?: string;\n  version?: string;\n  browser?: string | { [key: string]: false | string };\n  main?: string;\n  module?: string;\n  'jsnext:main'?: string;\n  dependencies?: { [key: string]: string };\n  devDependencies?: { [key: string]: string };\n  peerDependencies?: { [key: string]: string };\n  unpkg?: string;\n}\nexport interface PackageJson extends PartialPackageJson {\n  name: string;\n  version: string;\n}\n\nexport function isValidPartialPackageJson(json: unknown): json is PartialPackageJson {\n  return (\n    typeof json === 'object' &&\n    json !== null &&\n    !hasInvalidOptionalStringField(json as any, 'name') &&\n    !hasInvalidOptionalStringField(json as any, 'version') &&\n    !hasInvalidBrowserField(json as any) &&\n    !hasInvalidOptionalStringField(json as any, 'main') &&\n    !hasInvalidOptionalStringField(json as any, 'module') &&\n    !hasInvalidOptionalStringField(json as any, 'jsnext:main') &&\n    !hasInvalidOptionalStringField(json as any, 'unpkg') &&\n    !hasInvalidDependenciesField(json as any, 'dependencies') &&\n    !hasInvalidDependenciesField(json as any, 'devDependencies') &&\n    !hasInvalidDependenciesField(json as any, 'peerDependencies')\n  );\n}\n\nexport function isValidPackageJson(json: unknown): json is PackageJson {\n  return (\n    typeof json === 'object' &&\n    json !== null &&\n    !hasInvalidRequiredStringField(json as any, 'name') &&\n    !hasInvalidRequiredStringField(json as any, 'version') &&\n    !hasInvalidBrowserField(json as any) &&\n    !hasInvalidOptionalStringField(json as any, 'main') &&\n    !hasInvalidOptionalStringField(json as any, 'module') &&\n    !hasInvalidOptionalStringField(json as any, 'jsnext:main') &&\n    !hasInvalidOptionalStringField(json as any, 'unpkg') &&\n    !hasInvalidDependenciesField(json as any, 'dependencies') &&\n    !hasInvalidDependenciesField(json as any, 'devDependencies') &&\n    !hasInvalidDependenciesField(json as any, 'peerDependencies')\n  );\n}\n\nfunction hasInvalidBrowserField(json: any) {\n  let error = '';\n\n  const browser = json.browser;\n  if (browser) {\n    if (typeof browser === 'object') {\n      for (const key in browser) {\n        if (typeof key !== 'string') {\n          error = `The key ${key} of .browser must be a string`;\n          break;\n        }\n        if (typeof browser[key] !== 'string' && browser[key] !== false) {\n          error = `The value ${key} of .browser must be a string or false`;\n          break;\n        }\n      }\n    }\n  }\n\n  return error;\n}\n\nfunction hasInvalidRequiredStringField(json: any, field: string) {\n  return typeof json[field] !== 'string';\n}\n\nfunction hasInvalidOptionalStringField(json: any, field: string) {\n  return json[field] !== undefined && typeof json[field] !== 'string';\n}\n\nfunction hasInvalidDependenciesField(json: any, field: string) {\n  return (\n    json[field] !== undefined &&\n    typeof json[field] === 'object' &&\n    json[field] !== null &&\n    !Object.keys(json[field]).every(\n      (key) => typeof key === 'string' && typeof json[field][key] === 'string'\n    )\n  );\n}\n\nexport function parseBufferAsPartialPackageJson(\n  decoder: Decoder,\n  content: ArrayBuffer,\n  spec: string\n): PartialPackageJson {\n  try {\n    const text = decoder.decode(content);\n\n    return parseTextAsPartialPackageJson(text, spec);\n  } catch (err) {\n    throw new Error(`Error decoding manifest buffer for package ${spec}: ${err.message}`);\n  }\n}\n\nexport function parseBufferAsPackageJson(\n  decoder: Decoder,\n  content: ArrayBuffer,\n  spec: string\n): PackageJson {\n  try {\n    const text = decoder.decode(content);\n\n    return parseTextAsPackageJson(text, spec);\n  } catch (err) {\n    throw new Error(`Error decoding manifest buffer for package ${spec}: ${err.message}`);\n  }\n}\n\nfunction parseTextAsPartialPackageJson(text: string, spec: string): PartialPackageJson {\n  let json: unknown;\n\n  try {\n    json = JSON.parse(text);\n  } catch (err) {\n    throw new Error(`Error parsing manifest as json for package ${spec}: ${err.message}`);\n  }\n\n  if (!isValidPartialPackageJson(json)) {\n    throw new Error(`Invalid manifest for the package ${spec}`);\n  }\n\n  return json;\n}\n\nfunction parseTextAsPackageJson(text: string, spec: string): PackageJson {\n  const json = parseTextAsPartialPackageJson(text, spec);\n\n  if (!isValidPackageJson(json)) {\n    throw new Error(`Invalid manifest for the package ${spec}`);\n  }\n\n  return json;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n// NOTE: VSCode's copy of nodejs path library to be usable in common (non-node) namespace\n// Copied from: https://github.com/nodejs/node/blob/v12.8.1/lib/path.js\n\n/**\n * Copyright Joyent, Inc. and other Node contributors.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to permit\n * persons to whom the Software is furnished to do so, subject to the\n * following conditions:\n *\n * The above copyright notice and this permission notice shall be included\n * in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n * NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n * USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\nconst CHAR_DOT = 46; /* . */\nconst CHAR_FORWARD_SLASH = 47; /* / */\n\nclass ErrorInvalidArgType extends Error {\n  code: 'ERR_INVALID_ARG_TYPE';\n  constructor(name: string, expected: string, actual: any) {\n    // determiner: 'must be' or 'must not be'\n    let determiner;\n    if (typeof expected === 'string' && expected.indexOf('not ') === 0) {\n      determiner = 'must not be';\n      expected = expected.replace(/^not /, '');\n    } else {\n      determiner = 'must be';\n    }\n\n    const type = name.indexOf('.') !== -1 ? 'property' : 'argument';\n    let msg = `The \"${name}\" ${type} ${determiner} of type ${expected}`;\n\n    msg += `. Received type ${typeof actual}`;\n    super(msg);\n\n    this.code = 'ERR_INVALID_ARG_TYPE';\n  }\n}\n\nfunction validateString(value: string, name: string) {\n  if (typeof value !== 'string') {\n    throw new ErrorInvalidArgType(name, 'string', value);\n  }\n}\n\nfunction isPosixPathSeparator(code: number | undefined) {\n  return code === CHAR_FORWARD_SLASH;\n}\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeString(\n  path: string,\n  allowAboveRoot: boolean,\n  separator: string,\n  isPathSeparator: (code?: number) => boolean\n) {\n  let res = '';\n  let lastSegmentLength = 0;\n  let lastSlash = -1;\n  let dots = 0;\n  let code = 0;\n  for (let i = 0; i <= path.length; ++i) {\n    if (i < path.length) {\n      code = path.charCodeAt(i);\n    } else if (isPathSeparator(code)) {\n      break;\n    } else {\n      code = CHAR_FORWARD_SLASH;\n    }\n\n    if (isPathSeparator(code)) {\n      if (lastSlash === i - 1 || dots === 1) {\n        // NOOP\n      } else if (dots === 2) {\n        if (\n          res.length < 2 ||\n          lastSegmentLength !== 2 ||\n          res.charCodeAt(res.length - 1) !== CHAR_DOT ||\n          res.charCodeAt(res.length - 2) !== CHAR_DOT\n        ) {\n          if (res.length > 2) {\n            const lastSlashIndex = res.lastIndexOf(separator);\n            if (lastSlashIndex === -1) {\n              res = '';\n              lastSegmentLength = 0;\n            } else {\n              res = res.slice(0, lastSlashIndex);\n              lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);\n            }\n            lastSlash = i;\n            dots = 0;\n            continue;\n          } else if (res.length !== 0) {\n            res = '';\n            lastSegmentLength = 0;\n            lastSlash = i;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          res += res.length > 0 ? `${separator}..` : '..';\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (res.length > 0) {\n          res += `${separator}${path.slice(lastSlash + 1, i)}`;\n        } else {\n          res = path.slice(lastSlash + 1, i);\n        }\n        lastSegmentLength = i - lastSlash - 1;\n      }\n      lastSlash = i;\n      dots = 0;\n    } else if (code === CHAR_DOT && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\n\nfunction _format(sep: string, pathObject: ParsedPath) {\n  if (pathObject === null || typeof pathObject !== 'object') {\n    throw new ErrorInvalidArgType('pathObject', 'Object', pathObject);\n  }\n  const dir = pathObject.dir || pathObject.root;\n  const base = pathObject.base || `${pathObject.name || ''}${pathObject.ext || ''}`;\n  if (!dir) {\n    return base;\n  }\n  return dir === pathObject.root ? `${dir}${base}` : `${dir}${sep}${base}`;\n}\n\nexport interface ParsedPath {\n  root: string;\n  dir: string;\n  base: string;\n  ext: string;\n  name: string;\n}\n\nexport interface IPath {\n  normalize(path: string): string;\n  isAbsolute(path: string): boolean;\n  join(...paths: string[]): string;\n  resolve(...pathSegments: string[]): string;\n  relative(from: string, to: string): string;\n  dirname(path: string): string;\n  basename(path: string, ext?: string): string;\n  extname(path: string): string;\n  format(pathObject: ParsedPath): string;\n  parse(path: string): ParsedPath;\n  toNamespacedPath(path: string): string;\n  sep: '\\\\' | '/';\n  delimiter: string;\n  win32: IPath | null;\n  posix: IPath | null;\n}\n\n// export const win32: IPath = {\n// \t// path.resolve([from ...], to)\n// \tresolve(...pathSegments: string[]): string {\n// \t\tlet resolvedDevice = '';\n// \t\tlet resolvedTail = '';\n// \t\tlet resolvedAbsolute = false;\n\n// \t\tfor (let i = pathSegments.length - 1; i >= -1; i--) {\n// \t\t\tlet path;\n// \t\t\tif (i >= 0) {\n// \t\t\t\tpath = pathSegments[i];\n// \t\t\t\tvalidateString(path, 'path');\n\n// \t\t\t\t// Skip empty entries\n// \t\t\t\tif (path.length === 0) {\n// \t\t\t\t\tcontinue;\n// \t\t\t\t}\n// \t\t\t} else if (resolvedDevice.length === 0) {\n// \t\t\t\tpath = process.cwd();\n// \t\t\t} else {\n// \t\t\t\t// Windows has the concept of drive-specific current working\n// \t\t\t\t// directories. If we've resolved a drive letter but not yet an\n// \t\t\t\t// absolute path, get cwd for that drive, or the process cwd if\n// \t\t\t\t// the drive cwd is not available. We're sure the device is not\n// \t\t\t\t// a UNC path at this points, because UNC paths are always absolute.\n// \t\t\t\tpath = (process.env as any)[`=${resolvedDevice}`] || process.cwd();\n\n// \t\t\t\t// Verify that a cwd was found and that it actually points\n// \t\t\t\t// to our drive. If not, default to the drive's root.\n// \t\t\t\tif (path === undefined ||\n// \t\t\t\t\tpath.slice(0, 2).toLowerCase() !== resolvedDevice.toLowerCase() &&\n// \t\t\t\t\tpath.charCodeAt(2) === CHAR_BACKWARD_SLASH) {\n// \t\t\t\t\tpath = `${resolvedDevice}\\\\`;\n// \t\t\t\t}\n// \t\t\t}\n\n// \t\t\tconst len = path.length;\n// \t\t\tlet rootEnd = 0;\n// \t\t\tlet device = '';\n// \t\t\tlet isAbsolute = false;\n// \t\t\tconst code = path.charCodeAt(0);\n\n// \t\t\t// Try to match a root\n// \t\t\tif (len === 1) {\n// \t\t\t\tif (isPathSeparator(code)) {\n// \t\t\t\t\t// `path` contains just a path separator\n// \t\t\t\t\trootEnd = 1;\n// \t\t\t\t\tisAbsolute = true;\n// \t\t\t\t}\n// \t\t\t} else if (isPathSeparator(code)) {\n// \t\t\t\t// Possible UNC root\n\n// \t\t\t\t// If we started with a separator, we know we at least have an\n// \t\t\t\t// absolute path of some kind (UNC or otherwise)\n// \t\t\t\tisAbsolute = true;\n\n// \t\t\t\tif (isPathSeparator(path.charCodeAt(1))) {\n// \t\t\t\t\t// Matched double path separator at beginning\n// \t\t\t\t\tlet j = 2;\n// \t\t\t\t\tlet last = j;\n// \t\t\t\t\t// Match 1 or more non-path separators\n// \t\t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n// \t\t\t\t\t\tj++;\n// \t\t\t\t\t}\n// \t\t\t\t\tif (j < len && j !== last) {\n// \t\t\t\t\t\tconst firstPart = path.slice(last, j);\n// \t\t\t\t\t\t// Matched!\n// \t\t\t\t\t\tlast = j;\n// \t\t\t\t\t\t// Match 1 or more path separators\n// \t\t\t\t\t\twhile (j < len && isPathSeparator(path.charCodeAt(j))) {\n// \t\t\t\t\t\t\tj++;\n// \t\t\t\t\t\t}\n// \t\t\t\t\t\tif (j < len && j !== last) {\n// \t\t\t\t\t\t\t// Matched!\n// \t\t\t\t\t\t\tlast = j;\n// \t\t\t\t\t\t\t// Match 1 or more non-path separators\n// \t\t\t\t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n// \t\t\t\t\t\t\t\tj++;\n// \t\t\t\t\t\t\t}\n// \t\t\t\t\t\t\tif (j === len || j !== last) {\n// \t\t\t\t\t\t\t\t// We matched a UNC root\n// \t\t\t\t\t\t\t\tdevice = `\\\\\\\\${firstPart}\\\\${path.slice(last, j)}`;\n// \t\t\t\t\t\t\t\trootEnd = j;\n// \t\t\t\t\t\t\t}\n// \t\t\t\t\t\t}\n// \t\t\t\t\t}\n// \t\t\t\t} else {\n// \t\t\t\t\trootEnd = 1;\n// \t\t\t\t}\n// \t\t\t} else if (isWindowsDeviceRoot(code) &&\n// \t\t\t\tpath.charCodeAt(1) === CHAR_COLON) {\n// \t\t\t\t// Possible device root\n// \t\t\t\tdevice = path.slice(0, 2);\n// \t\t\t\trootEnd = 2;\n// \t\t\t\tif (len > 2 && isPathSeparator(path.charCodeAt(2))) {\n// \t\t\t\t\t// Treat separator following drive name as an absolute path\n// \t\t\t\t\t// indicator\n// \t\t\t\t\tisAbsolute = true;\n// \t\t\t\t\trootEnd = 3;\n// \t\t\t\t}\n// \t\t\t}\n\n// \t\t\tif (device.length > 0) {\n// \t\t\t\tif (resolvedDevice.length > 0) {\n// \t\t\t\t\tif (device.toLowerCase() !== resolvedDevice.toLowerCase()) {\n// \t\t\t\t\t\t// This path points to another device so it is not applicable\n// \t\t\t\t\t\tcontinue;\n// \t\t\t\t\t}\n// \t\t\t\t} else {\n// \t\t\t\t\tresolvedDevice = device;\n// \t\t\t\t}\n// \t\t\t}\n\n// \t\t\tif (resolvedAbsolute) {\n// \t\t\t\tif (resolvedDevice.length > 0) {\n// \t\t\t\t\tbreak;\n// \t\t\t\t}\n// \t\t\t} else {\n// \t\t\t\tresolvedTail = `${path.slice(rootEnd)}\\\\${resolvedTail}`;\n// \t\t\t\tresolvedAbsolute = isAbsolute;\n// \t\t\t\tif (isAbsolute && resolvedDevice.length > 0) {\n// \t\t\t\t\tbreak;\n// \t\t\t\t}\n// \t\t\t}\n// \t\t}\n\n// \t\t// At this point the path should be resolved to a full absolute path,\n// \t\t// but handle relative paths to be safe (might happen when process.cwd()\n// \t\t// fails)\n\n// \t\t// Normalize the tail path\n// \t\tresolvedTail = normalizeString(resolvedTail, !resolvedAbsolute, '\\\\',\n// \t\t\tisPathSeparator);\n\n// \t\treturn resolvedAbsolute ?\n// \t\t\t`${resolvedDevice}\\\\${resolvedTail}` :\n// \t\t\t`${resolvedDevice}${resolvedTail}` || '.';\n// \t},\n\n// \tnormalize(path: string): string {\n// \t\tvalidateString(path, 'path');\n// \t\tconst len = path.length;\n// \t\tif (len === 0) {\n// \t\t\treturn '.';\n// \t\t}\n// \t\tlet rootEnd = 0;\n// \t\tlet device;\n// \t\tlet isAbsolute = false;\n// \t\tconst code = path.charCodeAt(0);\n\n// \t\t// Try to match a root\n// \t\tif (len === 1) {\n// \t\t\t// `path` contains just a single char, exit early to avoid\n// \t\t\t// unnecessary work\n// \t\t\treturn isPosixPathSeparator(code) ? '\\\\' : path;\n// \t\t}\n// \t\tif (isPathSeparator(code)) {\n// \t\t\t// Possible UNC root\n\n// \t\t\t// If we started with a separator, we know we at least have an absolute\n// \t\t\t// path of some kind (UNC or otherwise)\n// \t\t\tisAbsolute = true;\n\n// \t\t\tif (isPathSeparator(path.charCodeAt(1))) {\n// \t\t\t\t// Matched double path separator at beginning\n// \t\t\t\tlet j = 2;\n// \t\t\t\tlet last = j;\n// \t\t\t\t// Match 1 or more non-path separators\n// \t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n// \t\t\t\t\tj++;\n// \t\t\t\t}\n// \t\t\t\tif (j < len && j !== last) {\n// \t\t\t\t\tconst firstPart = path.slice(last, j);\n// \t\t\t\t\t// Matched!\n// \t\t\t\t\tlast = j;\n// \t\t\t\t\t// Match 1 or more path separators\n// \t\t\t\t\twhile (j < len && isPathSeparator(path.charCodeAt(j))) {\n// \t\t\t\t\t\tj++;\n// \t\t\t\t\t}\n// \t\t\t\t\tif (j < len && j !== last) {\n// \t\t\t\t\t\t// Matched!\n// \t\t\t\t\t\tlast = j;\n// \t\t\t\t\t\t// Match 1 or more non-path separators\n// \t\t\t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n// \t\t\t\t\t\t\tj++;\n// \t\t\t\t\t\t}\n// \t\t\t\t\t\tif (j === len) {\n// \t\t\t\t\t\t\t// We matched a UNC root only\n// \t\t\t\t\t\t\t// Return the normalized version of the UNC root since there\n// \t\t\t\t\t\t\t// is nothing left to process\n// \t\t\t\t\t\t\treturn `\\\\\\\\${firstPart}\\\\${path.slice(last)}\\\\`;\n// \t\t\t\t\t\t}\n// \t\t\t\t\t\tif (j !== last) {\n// \t\t\t\t\t\t\t// We matched a UNC root with leftovers\n// \t\t\t\t\t\t\tdevice = `\\\\\\\\${firstPart}\\\\${path.slice(last, j)}`;\n// \t\t\t\t\t\t\trootEnd = j;\n// \t\t\t\t\t\t}\n// \t\t\t\t\t}\n// \t\t\t\t}\n// \t\t\t} else {\n// \t\t\t\trootEnd = 1;\n// \t\t\t}\n// \t\t} else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {\n// \t\t\t// Possible device root\n// \t\t\tdevice = path.slice(0, 2);\n// \t\t\trootEnd = 2;\n// \t\t\tif (len > 2 && isPathSeparator(path.charCodeAt(2))) {\n// \t\t\t\t// Treat separator following drive name as an absolute path\n// \t\t\t\t// indicator\n// \t\t\t\tisAbsolute = true;\n// \t\t\t\trootEnd = 3;\n// \t\t\t}\n// \t\t}\n\n// \t\tlet tail = rootEnd < len ?\n// \t\t\tnormalizeString(path.slice(rootEnd), !isAbsolute, '\\\\', isPathSeparator) :\n// \t\t\t'';\n// \t\tif (tail.length === 0 && !isAbsolute) {\n// \t\t\ttail = '.';\n// \t\t}\n// \t\tif (tail.length > 0 && isPathSeparator(path.charCodeAt(len - 1))) {\n// \t\t\ttail += '\\\\';\n// \t\t}\n// \t\tif (device === undefined) {\n// \t\t\treturn isAbsolute ? `\\\\${tail}` : tail;\n// \t\t}\n// \t\treturn isAbsolute ? `${device}\\\\${tail}` : `${device}${tail}`;\n// \t},\n\n// \tisAbsolute(path: string): boolean {\n// \t\tvalidateString(path, 'path');\n// \t\tconst len = path.length;\n// \t\tif (len === 0) {\n// \t\t\treturn false;\n// \t\t}\n\n// \t\tconst code = path.charCodeAt(0);\n// \t\treturn isPathSeparator(code) ||\n// \t\t\t// Possible device root\n// \t\t\tlen > 2 &&\n// \t\t\tisWindowsDeviceRoot(code) &&\n// \t\t\tpath.charCodeAt(1) === CHAR_COLON &&\n// \t\t\tisPathSeparator(path.charCodeAt(2));\n// \t},\n\n// \tjoin(...paths: string[]): string {\n// \t\tif (paths.length === 0) {\n// \t\t\treturn '.';\n// \t\t}\n\n// \t\tlet joined;\n// \t\tlet firstPart: string | undefined;\n// \t\tfor (let i = 0; i < paths.length; ++i) {\n// \t\t\tconst arg = paths[i];\n// \t\t\tvalidateString(arg, 'path');\n// \t\t\tif (arg.length > 0) {\n// \t\t\t\tif (joined === undefined) {\n// \t\t\t\t\tjoined = firstPart = arg;\n// \t\t\t\t}\n// \t\t\t\telse {\n// \t\t\t\t\tjoined += `\\\\${arg}`;\n// \t\t\t\t}\n// \t\t\t}\n// \t\t}\n\n// \t\tif (joined === undefined) {\n// \t\t\treturn '.';\n// \t\t}\n\n// \t\t// Make sure that the joined path doesn't start with two slashes, because\n// \t\t// normalize() will mistake it for an UNC path then.\n// \t\t//\n// \t\t// This step is skipped when it is very clear that the user actually\n// \t\t// intended to point at an UNC path. This is assumed when the first\n// \t\t// non-empty string arguments starts with exactly two slashes followed by\n// \t\t// at least one more non-slash character.\n// \t\t//\n// \t\t// Note that for normalize() to treat a path as an UNC path it needs to\n// \t\t// have at least 2 components, so we don't filter for that here.\n// \t\t// This means that the user can use join to construct UNC paths from\n// \t\t// a server name and a share name; for example:\n// \t\t//   path.join('//server', 'share') -> '\\\\\\\\server\\\\share\\\\')\n// \t\tlet needsReplace = true;\n// \t\tlet slashCount = 0;\n// \t\tif (typeof firstPart === 'string' && isPathSeparator(firstPart.charCodeAt(0))) {\n// \t\t\t++slashCount;\n// \t\t\tconst firstLen = firstPart.length;\n// \t\t\tif (firstLen > 1 && isPathSeparator(firstPart.charCodeAt(1))) {\n// \t\t\t\t++slashCount;\n// \t\t\t\tif (firstLen > 2) {\n// \t\t\t\t\tif (isPathSeparator(firstPart.charCodeAt(2))) {\n// \t\t\t\t\t\t++slashCount;\n// \t\t\t\t\t} else {\n// \t\t\t\t\t\t// We matched a UNC path in the first part\n// \t\t\t\t\t\tneedsReplace = false;\n// \t\t\t\t\t}\n// \t\t\t\t}\n// \t\t\t}\n// \t\t}\n// \t\tif (needsReplace) {\n// \t\t\t// Find any more consecutive slashes we need to replace\n// \t\t\twhile (slashCount < joined.length &&\n// \t\t\t\tisPathSeparator(joined.charCodeAt(slashCount))) {\n// \t\t\t\tslashCount++;\n// \t\t\t}\n\n// \t\t\t// Replace the slashes if needed\n// \t\t\tif (slashCount >= 2) {\n// \t\t\t\tjoined = `\\\\${joined.slice(slashCount)}`;\n// \t\t\t}\n// \t\t}\n\n// \t\treturn win32.normalize(joined);\n// \t},\n\n// \t// It will solve the relative path from `from` to `to`, for instance:\n// \t//  from = 'C:\\\\orandea\\\\test\\\\aaa'\n// \t//  to = 'C:\\\\orandea\\\\impl\\\\bbb'\n// \t// The output of the function should be: '..\\\\..\\\\impl\\\\bbb'\n// \trelative(from: string, to: string): string {\n// \t\tvalidateString(from, 'from');\n// \t\tvalidateString(to, 'to');\n\n// \t\tif (from === to) {\n// \t\t\treturn '';\n// \t\t}\n\n// \t\tconst fromOrig = win32.resolve(from);\n// \t\tconst toOrig = win32.resolve(to);\n\n// \t\tif (fromOrig === toOrig) {\n// \t\t\treturn '';\n// \t\t}\n\n// \t\tfrom = fromOrig.toLowerCase();\n// \t\tto = toOrig.toLowerCase();\n\n// \t\tif (from === to) {\n// \t\t\treturn '';\n// \t\t}\n\n// \t\t// Trim any leading backslashes\n// \t\tlet fromStart = 0;\n// \t\twhile (fromStart < from.length &&\n// \t\t\tfrom.charCodeAt(fromStart) === CHAR_BACKWARD_SLASH) {\n// \t\t\tfromStart++;\n// \t\t}\n// \t\t// Trim trailing backslashes (applicable to UNC paths only)\n// \t\tlet fromEnd = from.length;\n// \t\twhile (fromEnd - 1 > fromStart &&\n// \t\t\tfrom.charCodeAt(fromEnd - 1) === CHAR_BACKWARD_SLASH) {\n// \t\t\tfromEnd--;\n// \t\t}\n// \t\tconst fromLen = fromEnd - fromStart;\n\n// \t\t// Trim any leading backslashes\n// \t\tlet toStart = 0;\n// \t\twhile (toStart < to.length &&\n// \t\t\tto.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {\n// \t\t\ttoStart++;\n// \t\t}\n// \t\t// Trim trailing backslashes (applicable to UNC paths only)\n// \t\tlet toEnd = to.length;\n// \t\twhile (toEnd - 1 > toStart &&\n// \t\t\tto.charCodeAt(toEnd - 1) === CHAR_BACKWARD_SLASH) {\n// \t\t\ttoEnd--;\n// \t\t}\n// \t\tconst toLen = toEnd - toStart;\n\n// \t\t// Compare paths to find the longest common path from root\n// \t\tconst length = fromLen < toLen ? fromLen : toLen;\n// \t\tlet lastCommonSep = -1;\n// \t\tlet i = 0;\n// \t\tfor (; i < length; i++) {\n// \t\t\tconst fromCode = from.charCodeAt(fromStart + i);\n// \t\t\tif (fromCode !== to.charCodeAt(toStart + i)) {\n// \t\t\t\tbreak;\n// \t\t\t} else if (fromCode === CHAR_BACKWARD_SLASH) {\n// \t\t\t\tlastCommonSep = i;\n// \t\t\t}\n// \t\t}\n\n// \t\t// We found a mismatch before the first common path separator was seen, so\n// \t\t// return the original `to`.\n// \t\tif (i !== length) {\n// \t\t\tif (lastCommonSep === -1) {\n// \t\t\t\treturn toOrig;\n// \t\t\t}\n// \t\t} else {\n// \t\t\tif (toLen > length) {\n// \t\t\t\tif (to.charCodeAt(toStart + i) === CHAR_BACKWARD_SLASH) {\n// \t\t\t\t\t// We get here if `from` is the exact base path for `to`.\n// \t\t\t\t\t// For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo\\\\bar\\\\baz'\n// \t\t\t\t\treturn toOrig.slice(toStart + i + 1);\n// \t\t\t\t}\n// \t\t\t\tif (i === 2) {\n// \t\t\t\t\t// We get here if `from` is the device root.\n// \t\t\t\t\t// For example: from='C:\\\\'; to='C:\\\\foo'\n// \t\t\t\t\treturn toOrig.slice(toStart + i);\n// \t\t\t\t}\n// \t\t\t}\n// \t\t\tif (fromLen > length) {\n// \t\t\t\tif (from.charCodeAt(fromStart + i) === CHAR_BACKWARD_SLASH) {\n// \t\t\t\t\t// We get here if `to` is the exact base path for `from`.\n// \t\t\t\t\t// For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo'\n// \t\t\t\t\tlastCommonSep = i;\n// \t\t\t\t} else if (i === 2) {\n// \t\t\t\t\t// We get here if `to` is the device root.\n// \t\t\t\t\t// For example: from='C:\\\\foo\\\\bar'; to='C:\\\\'\n// \t\t\t\t\tlastCommonSep = 3;\n// \t\t\t\t}\n// \t\t\t}\n// \t\t\tif (lastCommonSep === -1) {\n// \t\t\t\tlastCommonSep = 0;\n// \t\t\t}\n// \t\t}\n\n// \t\tlet out = '';\n// \t\t// Generate the relative path based on the path difference between `to` and\n// \t\t// `from`\n// \t\tfor (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n// \t\t\tif (i === fromEnd || from.charCodeAt(i) === CHAR_BACKWARD_SLASH) {\n// \t\t\t\tout += out.length === 0 ? '..' : '\\\\..';\n// \t\t\t}\n// \t\t}\n\n// \t\ttoStart += lastCommonSep;\n\n// \t\t// Lastly, append the rest of the destination (`to`) path that comes after\n// \t\t// the common path parts\n// \t\tif (out.length > 0) {\n// \t\t\treturn `${out}${toOrig.slice(toStart, toEnd)}`;\n// \t\t}\n\n// \t\tif (toOrig.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {\n// \t\t\t++toStart;\n// \t\t}\n\n// \t\treturn toOrig.slice(toStart, toEnd);\n// \t},\n\n// \ttoNamespacedPath(path: string): string {\n// \t\t// Note: this will *probably* throw somewhere.\n// \t\tif (typeof path !== 'string') {\n// \t\t\treturn path;\n// \t\t}\n\n// \t\tif (path.length === 0) {\n// \t\t\treturn '';\n// \t\t}\n\n// \t\tconst resolvedPath = win32.resolve(path);\n\n// \t\tif (resolvedPath.length <= 2) {\n// \t\t\treturn path;\n// \t\t}\n\n// \t\tif (resolvedPath.charCodeAt(0) === CHAR_BACKWARD_SLASH) {\n// \t\t\t// Possible UNC root\n// \t\t\tif (resolvedPath.charCodeAt(1) === CHAR_BACKWARD_SLASH) {\n// \t\t\t\tconst code = resolvedPath.charCodeAt(2);\n// \t\t\t\tif (code !== CHAR_QUESTION_MARK && code !== CHAR_DOT) {\n// \t\t\t\t\t// Matched non-long UNC root, convert the path to a long UNC path\n// \t\t\t\t\treturn `\\\\\\\\?\\\\UNC\\\\${resolvedPath.slice(2)}`;\n// \t\t\t\t}\n// \t\t\t}\n// \t\t} else if (isWindowsDeviceRoot(resolvedPath.charCodeAt(0)) &&\n// \t\t\tresolvedPath.charCodeAt(1) === CHAR_COLON &&\n// \t\t\tresolvedPath.charCodeAt(2) === CHAR_BACKWARD_SLASH) {\n// \t\t\t// Matched device root, convert the path to a long UNC path\n// \t\t\treturn `\\\\\\\\?\\\\${resolvedPath}`;\n// \t\t}\n\n// \t\treturn path;\n// \t},\n\n// \tdirname(path: string): string {\n// \t\tvalidateString(path, 'path');\n// \t\tconst len = path.length;\n// \t\tif (len === 0) {\n// \t\t\treturn '.';\n// \t\t}\n// \t\tlet rootEnd = -1;\n// \t\tlet offset = 0;\n// \t\tconst code = path.charCodeAt(0);\n\n// \t\tif (len === 1) {\n// \t\t\t// `path` contains just a path separator, exit early to avoid\n// \t\t\t// unnecessary work or a dot.\n// \t\t\treturn isPathSeparator(code) ? path : '.';\n// \t\t}\n\n// \t\t// Try to match a root\n// \t\tif (isPathSeparator(code)) {\n// \t\t\t// Possible UNC root\n\n// \t\t\trootEnd = offset = 1;\n\n// \t\t\tif (isPathSeparator(path.charCodeAt(1))) {\n// \t\t\t\t// Matched double path separator at beginning\n// \t\t\t\tlet j = 2;\n// \t\t\t\tlet last = j;\n// \t\t\t\t// Match 1 or more non-path separators\n// \t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n// \t\t\t\t\tj++;\n// \t\t\t\t}\n// \t\t\t\tif (j < len && j !== last) {\n// \t\t\t\t\t// Matched!\n// \t\t\t\t\tlast = j;\n// \t\t\t\t\t// Match 1 or more path separators\n// \t\t\t\t\twhile (j < len && isPathSeparator(path.charCodeAt(j))) {\n// \t\t\t\t\t\tj++;\n// \t\t\t\t\t}\n// \t\t\t\t\tif (j < len && j !== last) {\n// \t\t\t\t\t\t// Matched!\n// \t\t\t\t\t\tlast = j;\n// \t\t\t\t\t\t// Match 1 or more non-path separators\n// \t\t\t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n// \t\t\t\t\t\t\tj++;\n// \t\t\t\t\t\t}\n// \t\t\t\t\t\tif (j === len) {\n// \t\t\t\t\t\t\t// We matched a UNC root only\n// \t\t\t\t\t\t\treturn path;\n// \t\t\t\t\t\t}\n// \t\t\t\t\t\tif (j !== last) {\n// \t\t\t\t\t\t\t// We matched a UNC root with leftovers\n\n// \t\t\t\t\t\t\t// Offset by 1 to include the separator after the UNC root to\n// \t\t\t\t\t\t\t// treat it as a \"normal root\" on top of a (UNC) root\n// \t\t\t\t\t\t\trootEnd = offset = j + 1;\n// \t\t\t\t\t\t}\n// \t\t\t\t\t}\n// \t\t\t\t}\n// \t\t\t}\n// \t\t\t// Possible device root\n// \t\t} else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {\n// \t\t\trootEnd = len > 2 && isPathSeparator(path.charCodeAt(2)) ? 3 : 2;\n// \t\t\toffset = rootEnd;\n// \t\t}\n\n// \t\tlet end = -1;\n// \t\tlet matchedSlash = true;\n// \t\tfor (let i = len - 1; i >= offset; --i) {\n// \t\t\tif (isPathSeparator(path.charCodeAt(i))) {\n// \t\t\t\tif (!matchedSlash) {\n// \t\t\t\t\tend = i;\n// \t\t\t\t\tbreak;\n// \t\t\t\t}\n// \t\t\t} else {\n// \t\t\t\t// We saw the first non-path separator\n// \t\t\t\tmatchedSlash = false;\n// \t\t\t}\n// \t\t}\n\n// \t\tif (end === -1) {\n// \t\t\tif (rootEnd === -1) {\n// \t\t\t\treturn '.';\n// \t\t\t}\n\n// \t\t\tend = rootEnd;\n// \t\t}\n// \t\treturn path.slice(0, end);\n// \t},\n\n// \tbasename(path: string, ext?: string): string {\n// \t\tif (ext !== undefined) {\n// \t\t\tvalidateString(ext, 'ext');\n// \t\t}\n// \t\tvalidateString(path, 'path');\n// \t\tlet start = 0;\n// \t\tlet end = -1;\n// \t\tlet matchedSlash = true;\n// \t\tlet i;\n\n// \t\t// Check for a drive letter prefix so as not to mistake the following\n// \t\t// path separator as an extra separator at the end of the path that can be\n// \t\t// disregarded\n// \t\tif (path.length >= 2 &&\n// \t\t\tisWindowsDeviceRoot(path.charCodeAt(0)) &&\n// \t\t\tpath.charCodeAt(1) === CHAR_COLON) {\n// \t\t\tstart = 2;\n// \t\t}\n\n// \t\tif (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n// \t\t\tif (ext === path) {\n// \t\t\t\treturn '';\n// \t\t\t}\n// \t\t\tlet extIdx = ext.length - 1;\n// \t\t\tlet firstNonSlashEnd = -1;\n// \t\t\tfor (i = path.length - 1; i >= start; --i) {\n// \t\t\t\tconst code = path.charCodeAt(i);\n// \t\t\t\tif (isPathSeparator(code)) {\n// \t\t\t\t\t// If we reached a path separator that was not part of a set of path\n// \t\t\t\t\t// separators at the end of the string, stop now\n// \t\t\t\t\tif (!matchedSlash) {\n// \t\t\t\t\t\tstart = i + 1;\n// \t\t\t\t\t\tbreak;\n// \t\t\t\t\t}\n// \t\t\t\t} else {\n// \t\t\t\t\tif (firstNonSlashEnd === -1) {\n// \t\t\t\t\t\t// We saw the first non-path separator, remember this index in case\n// \t\t\t\t\t\t// we need it if the extension ends up not matching\n// \t\t\t\t\t\tmatchedSlash = false;\n// \t\t\t\t\t\tfirstNonSlashEnd = i + 1;\n// \t\t\t\t\t}\n// \t\t\t\t\tif (extIdx >= 0) {\n// \t\t\t\t\t\t// Try to match the explicit extension\n// \t\t\t\t\t\tif (code === ext.charCodeAt(extIdx)) {\n// \t\t\t\t\t\t\tif (--extIdx === -1) {\n// \t\t\t\t\t\t\t\t// We matched the extension, so mark this as the end of our path\n// \t\t\t\t\t\t\t\t// component\n// \t\t\t\t\t\t\t\tend = i;\n// \t\t\t\t\t\t\t}\n// \t\t\t\t\t\t} else {\n// \t\t\t\t\t\t\t// Extension does not match, so our result is the entire path\n// \t\t\t\t\t\t\t// component\n// \t\t\t\t\t\t\textIdx = -1;\n// \t\t\t\t\t\t\tend = firstNonSlashEnd;\n// \t\t\t\t\t\t}\n// \t\t\t\t\t}\n// \t\t\t\t}\n// \t\t\t}\n\n// \t\t\tif (start === end) {\n// \t\t\t\tend = firstNonSlashEnd;\n// \t\t\t} else if (end === -1) {\n// \t\t\t\tend = path.length;\n// \t\t\t}\n// \t\t\treturn path.slice(start, end);\n// \t\t}\n// \t\tfor (i = path.length - 1; i >= start; --i) {\n// \t\t\tif (isPathSeparator(path.charCodeAt(i))) {\n// \t\t\t\t// If we reached a path separator that was not part of a set of path\n// \t\t\t\t// separators at the end of the string, stop now\n// \t\t\t\tif (!matchedSlash) {\n// \t\t\t\t\tstart = i + 1;\n// \t\t\t\t\tbreak;\n// \t\t\t\t}\n// \t\t\t} else if (end === -1) {\n// \t\t\t\t// We saw the first non-path separator, mark this as the end of our\n// \t\t\t\t// path component\n// \t\t\t\tmatchedSlash = false;\n// \t\t\t\tend = i + 1;\n// \t\t\t}\n// \t\t}\n\n// \t\tif (end === -1) {\n// \t\t\treturn '';\n// \t\t}\n// \t\treturn path.slice(start, end);\n// \t},\n\n// \textname(path: string): string {\n// \t\tvalidateString(path, 'path');\n// \t\tlet start = 0;\n// \t\tlet startDot = -1;\n// \t\tlet startPart = 0;\n// \t\tlet end = -1;\n// \t\tlet matchedSlash = true;\n// \t\t// Track the state of characters (if any) we see before our first dot and\n// \t\t// after any path separator we find\n// \t\tlet preDotState = 0;\n\n// \t\t// Check for a drive letter prefix so as not to mistake the following\n// \t\t// path separator as an extra separator at the end of the path that can be\n// \t\t// disregarded\n\n// \t\tif (path.length >= 2 &&\n// \t\t\tpath.charCodeAt(1) === CHAR_COLON &&\n// \t\t\tisWindowsDeviceRoot(path.charCodeAt(0))) {\n// \t\t\tstart = startPart = 2;\n// \t\t}\n\n// \t\tfor (let i = path.length - 1; i >= start; --i) {\n// \t\t\tconst code = path.charCodeAt(i);\n// \t\t\tif (isPathSeparator(code)) {\n// \t\t\t\t// If we reached a path separator that was not part of a set of path\n// \t\t\t\t// separators at the end of the string, stop now\n// \t\t\t\tif (!matchedSlash) {\n// \t\t\t\t\tstartPart = i + 1;\n// \t\t\t\t\tbreak;\n// \t\t\t\t}\n// \t\t\t\tcontinue;\n// \t\t\t}\n// \t\t\tif (end === -1) {\n// \t\t\t\t// We saw the first non-path separator, mark this as the end of our\n// \t\t\t\t// extension\n// \t\t\t\tmatchedSlash = false;\n// \t\t\t\tend = i + 1;\n// \t\t\t}\n// \t\t\tif (code === CHAR_DOT) {\n// \t\t\t\t// If this is our first dot, mark it as the start of our extension\n// \t\t\t\tif (startDot === -1) {\n// \t\t\t\t\tstartDot = i;\n// \t\t\t\t}\n// \t\t\t\telse if (preDotState !== 1) {\n// \t\t\t\t\tpreDotState = 1;\n// \t\t\t\t}\n// \t\t\t} else if (startDot !== -1) {\n// \t\t\t\t// We saw a non-dot and non-path separator before our dot, so we should\n// \t\t\t\t// have a good chance at having a non-empty extension\n// \t\t\t\tpreDotState = -1;\n// \t\t\t}\n// \t\t}\n\n// \t\tif (startDot === -1 ||\n// \t\t\tend === -1 ||\n// \t\t\t// We saw a non-dot character immediately before the dot\n// \t\t\tpreDotState === 0 ||\n// \t\t\t// The (right-most) trimmed path component is exactly '..'\n// \t\t\t(preDotState === 1 &&\n// \t\t\t\tstartDot === end - 1 &&\n// \t\t\t\tstartDot === startPart + 1)) {\n// \t\t\treturn '';\n// \t\t}\n// \t\treturn path.slice(startDot, end);\n// \t},\n\n// \tformat: _format.bind(null, '\\\\'),\n\n// \tparse(path) {\n// \t\tvalidateString(path, 'path');\n\n// \t\tconst ret = { root: '', dir: '', base: '', ext: '', name: '' };\n// \t\tif (path.length === 0) {\n// \t\t\treturn ret;\n// \t\t}\n\n// \t\tconst len = path.length;\n// \t\tlet rootEnd = 0;\n// \t\tlet code = path.charCodeAt(0);\n\n// \t\tif (len === 1) {\n// \t\t\tif (isPathSeparator(code)) {\n// \t\t\t\t// `path` contains just a path separator, exit early to avoid\n// \t\t\t\t// unnecessary work\n// \t\t\t\tret.root = ret.dir = path;\n// \t\t\t\treturn ret;\n// \t\t\t}\n// \t\t\tret.base = ret.name = path;\n// \t\t\treturn ret;\n// \t\t}\n// \t\t// Try to match a root\n// \t\tif (isPathSeparator(code)) {\n// \t\t\t// Possible UNC root\n\n// \t\t\trootEnd = 1;\n// \t\t\tif (isPathSeparator(path.charCodeAt(1))) {\n// \t\t\t\t// Matched double path separator at beginning\n// \t\t\t\tlet j = 2;\n// \t\t\t\tlet last = j;\n// \t\t\t\t// Match 1 or more non-path separators\n// \t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n// \t\t\t\t\tj++;\n// \t\t\t\t}\n// \t\t\t\tif (j < len && j !== last) {\n// \t\t\t\t\t// Matched!\n// \t\t\t\t\tlast = j;\n// \t\t\t\t\t// Match 1 or more path separators\n// \t\t\t\t\twhile (j < len && isPathSeparator(path.charCodeAt(j))) {\n// \t\t\t\t\t\tj++;\n// \t\t\t\t\t}\n// \t\t\t\t\tif (j < len && j !== last) {\n// \t\t\t\t\t\t// Matched!\n// \t\t\t\t\t\tlast = j;\n// \t\t\t\t\t\t// Match 1 or more non-path separators\n// \t\t\t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n// \t\t\t\t\t\t\tj++;\n// \t\t\t\t\t\t}\n// \t\t\t\t\t\tif (j === len) {\n// \t\t\t\t\t\t\t// We matched a UNC root only\n// \t\t\t\t\t\t\trootEnd = j;\n// \t\t\t\t\t\t} else if (j !== last) {\n// \t\t\t\t\t\t\t// We matched a UNC root with leftovers\n// \t\t\t\t\t\t\trootEnd = j + 1;\n// \t\t\t\t\t\t}\n// \t\t\t\t\t}\n// \t\t\t\t}\n// \t\t\t}\n// \t\t} else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {\n// \t\t\t// Possible device root\n// \t\t\tif (len <= 2) {\n// \t\t\t\t// `path` contains just a drive root, exit early to avoid\n// \t\t\t\t// unnecessary work\n// \t\t\t\tret.root = ret.dir = path;\n// \t\t\t\treturn ret;\n// \t\t\t}\n// \t\t\trootEnd = 2;\n// \t\t\tif (isPathSeparator(path.charCodeAt(2))) {\n// \t\t\t\tif (len === 3) {\n// \t\t\t\t\t// `path` contains just a drive root, exit early to avoid\n// \t\t\t\t\t// unnecessary work\n// \t\t\t\t\tret.root = ret.dir = path;\n// \t\t\t\t\treturn ret;\n// \t\t\t\t}\n// \t\t\t\trootEnd = 3;\n// \t\t\t}\n// \t\t}\n// \t\tif (rootEnd > 0) {\n// \t\t\tret.root = path.slice(0, rootEnd);\n// \t\t}\n\n// \t\tlet startDot = -1;\n// \t\tlet startPart = rootEnd;\n// \t\tlet end = -1;\n// \t\tlet matchedSlash = true;\n// \t\tlet i = path.length - 1;\n\n// \t\t// Track the state of characters (if any) we see before our first dot and\n// \t\t// after any path separator we find\n// \t\tlet preDotState = 0;\n\n// \t\t// Get non-dir info\n// \t\tfor (; i >= rootEnd; --i) {\n// \t\t\tcode = path.charCodeAt(i);\n// \t\t\tif (isPathSeparator(code)) {\n// \t\t\t\t// If we reached a path separator that was not part of a set of path\n// \t\t\t\t// separators at the end of the string, stop now\n// \t\t\t\tif (!matchedSlash) {\n// \t\t\t\t\tstartPart = i + 1;\n// \t\t\t\t\tbreak;\n// \t\t\t\t}\n// \t\t\t\tcontinue;\n// \t\t\t}\n// \t\t\tif (end === -1) {\n// \t\t\t\t// We saw the first non-path separator, mark this as the end of our\n// \t\t\t\t// extension\n// \t\t\t\tmatchedSlash = false;\n// \t\t\t\tend = i + 1;\n// \t\t\t}\n// \t\t\tif (code === CHAR_DOT) {\n// \t\t\t\t// If this is our first dot, mark it as the start of our extension\n// \t\t\t\tif (startDot === -1) {\n// \t\t\t\t\tstartDot = i;\n// \t\t\t\t} else if (preDotState !== 1) {\n// \t\t\t\t\tpreDotState = 1;\n// \t\t\t\t}\n// \t\t\t} else if (startDot !== -1) {\n// \t\t\t\t// We saw a non-dot and non-path separator before our dot, so we should\n// \t\t\t\t// have a good chance at having a non-empty extension\n// \t\t\t\tpreDotState = -1;\n// \t\t\t}\n// \t\t}\n\n// \t\tif (end !== -1) {\n// \t\t\tif (startDot === -1 ||\n// \t\t\t\t// We saw a non-dot character immediately before the dot\n// \t\t\t\tpreDotState === 0 ||\n// \t\t\t\t// The (right-most) trimmed path component is exactly '..'\n// \t\t\t\t(preDotState === 1 &&\n// \t\t\t\t\tstartDot === end - 1 &&\n// \t\t\t\t\tstartDot === startPart + 1)) {\n// \t\t\t\tret.base = ret.name = path.slice(startPart, end);\n// \t\t\t} else {\n// \t\t\t\tret.name = path.slice(startPart, startDot);\n// \t\t\t\tret.base = path.slice(startPart, end);\n// \t\t\t\tret.ext = path.slice(startDot, end);\n// \t\t\t}\n// \t\t}\n\n// \t\t// If the directory is the root, use the entire root as the `dir` including\n// \t\t// the trailing slash if any (`C:\\abc` -> `C:\\`). Otherwise, strip out the\n// \t\t// trailing slash (`C:\\abc\\def` -> `C:\\abc`).\n// \t\tif (startPart > 0 && startPart !== rootEnd) {\n// \t\t\tret.dir = path.slice(0, startPart - 1);\n// \t\t} else {\n// \t\t\tret.dir = ret.root;\n// \t\t}\n\n// \t\treturn ret;\n// \t},\n\n// \tsep: '\\\\',\n// \tdelimiter: ';',\n// \twin32: null,\n// \tposix: null\n// };\n\nexport const posix: IPath = {\n  // path.resolve([from ...], to)\n  resolve(...pathSegments: string[]): string {\n    let resolvedPath = '';\n    let resolvedAbsolute = false;\n\n    for (let i = pathSegments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n      const path = i >= 0 ? pathSegments[i] : process.cwd();\n\n      validateString(path, 'path');\n\n      // Skip empty entries\n      if (path.length === 0) {\n        continue;\n      }\n\n      resolvedPath = `${path}/${resolvedPath}`;\n      resolvedAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n    }\n\n    // At this point the path should be resolved to a full absolute path, but\n    // handle relative paths to be safe (might happen when process.cwd() fails)\n\n    // Normalize the path\n    resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute, '/', isPosixPathSeparator);\n\n    if (resolvedAbsolute) {\n      return `/${resolvedPath}`;\n    }\n    return resolvedPath.length > 0 ? resolvedPath : '.';\n  },\n\n  normalize(path: string): string {\n    validateString(path, 'path');\n\n    if (path.length === 0) {\n      return '.';\n    }\n\n    const isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n    const trailingSeparator = path.charCodeAt(path.length - 1) === CHAR_FORWARD_SLASH;\n\n    // Normalize the path\n    path = normalizeString(path, !isAbsolute, '/', isPosixPathSeparator);\n\n    if (path.length === 0) {\n      if (isAbsolute) {\n        return '/';\n      }\n      return trailingSeparator ? './' : '.';\n    }\n    if (trailingSeparator) {\n      path += '/';\n    }\n\n    return isAbsolute ? `/${path}` : path;\n  },\n\n  isAbsolute(path: string): boolean {\n    validateString(path, 'path');\n    return path.length > 0 && path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n  },\n\n  join(...paths: string[]): string {\n    if (paths.length === 0) {\n      return '.';\n    }\n    let joined;\n    for (let i = 0; i < paths.length; ++i) {\n      const arg = paths[i];\n      validateString(arg, 'path');\n      if (arg.length > 0) {\n        if (joined === undefined) {\n          joined = arg;\n        } else {\n          joined += `/${arg}`;\n        }\n      }\n    }\n    if (joined === undefined) {\n      return '.';\n    }\n    return posix.normalize(joined);\n  },\n\n  relative(from: string, to: string): string {\n    validateString(from, 'from');\n    validateString(to, 'to');\n\n    if (from === to) {\n      return '';\n    }\n\n    // Trim leading forward slashes.\n    from = posix.resolve(from);\n    to = posix.resolve(to);\n\n    if (from === to) {\n      return '';\n    }\n\n    const fromStart = 1;\n    const fromEnd = from.length;\n    const fromLen = fromEnd - fromStart;\n    const toStart = 1;\n    const toLen = to.length - toStart;\n\n    // Compare paths to find the longest common path from root\n    const length = fromLen < toLen ? fromLen : toLen;\n    let lastCommonSep = -1;\n    let i = 0;\n    for (; i < length; i++) {\n      const fromCode = from.charCodeAt(fromStart + i);\n      if (fromCode !== to.charCodeAt(toStart + i)) {\n        break;\n      } else if (fromCode === CHAR_FORWARD_SLASH) {\n        lastCommonSep = i;\n      }\n    }\n    if (i === length) {\n      if (toLen > length) {\n        if (to.charCodeAt(toStart + i) === CHAR_FORWARD_SLASH) {\n          // We get here if `from` is the exact base path for `to`.\n          // For example: from='/foo/bar'; to='/foo/bar/baz'\n          return to.slice(toStart + i + 1);\n        }\n        if (i === 0) {\n          // We get here if `from` is the root\n          // For example: from='/'; to='/foo'\n          return to.slice(toStart + i);\n        }\n      } else if (fromLen > length) {\n        if (from.charCodeAt(fromStart + i) === CHAR_FORWARD_SLASH) {\n          // We get here if `to` is the exact base path for `from`.\n          // For example: from='/foo/bar/baz'; to='/foo/bar'\n          lastCommonSep = i;\n        } else if (i === 0) {\n          // We get here if `to` is the root.\n          // For example: from='/foo/bar'; to='/'\n          lastCommonSep = 0;\n        }\n      }\n    }\n\n    let out = '';\n    // Generate the relative path based on the path difference between `to`\n    // and `from`.\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n      if (i === fromEnd || from.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n        out += out.length === 0 ? '..' : '/..';\n      }\n    }\n\n    // Lastly, append the rest of the destination (`to`) path that comes after\n    // the common path parts.\n    return `${out}${to.slice(toStart + lastCommonSep)}`;\n  },\n\n  toNamespacedPath(path: string): string {\n    // Non-op on posix systems\n    return path;\n  },\n\n  dirname(path: string): string {\n    validateString(path, 'path');\n    if (path.length === 0) {\n      return '.';\n    }\n    const hasRoot = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n    let end = -1;\n    let matchedSlash = true;\n    for (let i = path.length - 1; i >= 1; --i) {\n      if (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n        if (!matchedSlash) {\n          end = i;\n          break;\n        }\n      } else {\n        // We saw the first non-path separator\n        matchedSlash = false;\n      }\n    }\n\n    if (end === -1) {\n      return hasRoot ? '/' : '.';\n    }\n    if (hasRoot && end === 1) {\n      return '//';\n    }\n    return path.slice(0, end);\n  },\n\n  basename(path: string, ext?: string): string {\n    if (ext !== undefined) {\n      validateString(ext, 'ext');\n    }\n    validateString(path, 'path');\n\n    let start = 0;\n    let end = -1;\n    let matchedSlash = true;\n    let i;\n\n    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n      if (ext === path) {\n        return '';\n      }\n      let extIdx = ext.length - 1;\n      let firstNonSlashEnd = -1;\n      for (i = path.length - 1; i >= 0; --i) {\n        const code = path.charCodeAt(i);\n        if (code === CHAR_FORWARD_SLASH) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            start = i + 1;\n            break;\n          }\n        } else {\n          if (firstNonSlashEnd === -1) {\n            // We saw the first non-path separator, remember this index in case\n            // we need it if the extension ends up not matching\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            // Try to match the explicit extension\n            if (code === ext.charCodeAt(extIdx)) {\n              if (--extIdx === -1) {\n                // We matched the extension, so mark this as the end of our path\n                // component\n                end = i;\n              }\n            } else {\n              // Extension does not match, so our result is the entire path\n              // component\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n\n      if (start === end) {\n        end = firstNonSlashEnd;\n      } else if (end === -1) {\n        end = path.length;\n      }\n      return path.slice(start, end);\n    }\n    for (i = path.length - 1; i >= 0; --i) {\n      if (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          start = i + 1;\n          break;\n        }\n      } else if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // path component\n        matchedSlash = false;\n        end = i + 1;\n      }\n    }\n\n    if (end === -1) {\n      return '';\n    }\n    return path.slice(start, end);\n  },\n\n  extname(path: string): string {\n    validateString(path, 'path');\n    let startDot = -1;\n    let startPart = 0;\n    let end = -1;\n    let matchedSlash = true;\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    let preDotState = 0;\n    for (let i = path.length - 1; i >= 0; --i) {\n      const code = path.charCodeAt(i);\n      if (code === CHAR_FORWARD_SLASH) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === CHAR_DOT) {\n        // If this is our first dot, mark it as the start of our extension\n        if (startDot === -1) {\n          startDot = i;\n        } else if (preDotState !== 1) {\n          preDotState = 1;\n        }\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (\n      startDot === -1 ||\n      end === -1 ||\n      // We saw a non-dot character immediately before the dot\n      preDotState === 0 ||\n      // The (right-most) trimmed path component is exactly '..'\n      (preDotState === 1 && startDot === end - 1 && startDot === startPart + 1)\n    ) {\n      return '';\n    }\n    return path.slice(startDot, end);\n  },\n\n  format: _format.bind(null, '/'),\n\n  parse(path: string): ParsedPath {\n    validateString(path, 'path');\n\n    const ret = { root: '', dir: '', base: '', ext: '', name: '' };\n    if (path.length === 0) {\n      return ret;\n    }\n    const isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n    let start;\n    if (isAbsolute) {\n      ret.root = '/';\n      start = 1;\n    } else {\n      start = 0;\n    }\n    let startDot = -1;\n    let startPart = 0;\n    let end = -1;\n    let matchedSlash = true;\n    let i = path.length - 1;\n\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    let preDotState = 0;\n\n    // Get non-dir info\n    for (; i >= start; --i) {\n      const code = path.charCodeAt(i);\n      if (code === CHAR_FORWARD_SLASH) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === CHAR_DOT) {\n        // If this is our first dot, mark it as the start of our extension\n        if (startDot === -1) {\n          startDot = i;\n        } else if (preDotState !== 1) {\n          preDotState = 1;\n        }\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (end !== -1) {\n      const start = startPart === 0 && isAbsolute ? 1 : startPart;\n      if (\n        startDot === -1 ||\n        // We saw a non-dot character immediately before the dot\n        preDotState === 0 ||\n        // The (right-most) trimmed path component is exactly '..'\n        (preDotState === 1 && startDot === end - 1 && startDot === startPart + 1)\n      ) {\n        ret.base = ret.name = path.slice(start, end);\n      } else {\n        ret.name = path.slice(start, startDot);\n        ret.base = path.slice(start, end);\n        ret.ext = path.slice(startDot, end);\n      }\n    }\n\n    if (startPart > 0) {\n      ret.dir = path.slice(0, startPart - 1);\n    } else if (isAbsolute) {\n      ret.dir = '/';\n    }\n\n    return ret;\n  },\n\n  sep: '/',\n  delimiter: ':',\n  win32: null,\n  posix: null,\n};\n\nexport const normalize = posix.normalize;\nexport const isAbsolute = posix.isAbsolute;\nexport const join = posix.join;\nexport const resolve = posix.resolve;\nexport const relative = posix.relative;\nexport const dirname = posix.dirname;\nexport const basename = posix.basename;\nexport const extname = posix.extname;\nexport const format = posix.format;\nexport const parse = posix.parse;\nexport const toNamespacedPath = posix.toNamespacedPath;\nexport const sep = posix.sep;\nexport const delimiter = posix.delimiter;\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from './charCode';\nimport { join } from './path';\n\nconst _schemePattern = /^\\w[\\w\\d+.-]*$/;\nconst _singleSlashStart = /^\\//;\nconst _doubleSlashStart = /^\\/\\//;\n\nfunction _validateUri(ret: Uri, _strict?: boolean): void {\n  // scheme, must be set\n  if (!ret.scheme && _strict) {\n    throw new Error(\n      `[UriError]: Scheme is missing: {scheme: \"\", authority: \"${ret.authority}\", path: \"${ret.path}\", query: \"${ret.query}\", fragment: \"${ret.fragment}\"}`\n    );\n  }\n\n  // scheme, https://tools.ietf.org/html/rfc3986#section-3.1\n  // ALPHA *( ALPHA / DIGIT / \"+\" / \"-\" / \".\" )\n  if (ret.scheme && !_schemePattern.test(ret.scheme)) {\n    throw new Error('[UriError]: Scheme contains illegal characters.');\n  }\n\n  // path, http://tools.ietf.org/html/rfc3986#section-3.3\n  // If a URI contains an authority component, then the path component\n  // must either be empty or begin with a slash (\"/\") character.  If a URI\n  // does not contain an authority component, then the path cannot begin\n  // with two slash characters (\"//\").\n  if (ret.path) {\n    if (ret.authority) {\n      if (!_singleSlashStart.test(ret.path)) {\n        throw new Error(\n          '[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash (\"/\") character'\n        );\n      }\n    } else {\n      if (_doubleSlashStart.test(ret.path)) {\n        throw new Error(\n          '[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters (\"//\")'\n        );\n      }\n    }\n  }\n}\n\n// for a while we allowed uris *without* schemes and this is the migration\n// for them, e.g. an uri without scheme and without strict-mode warns and falls\n// back to the file-scheme. that should cause the least carnage and still be a\n// clear warning\nfunction _schemeFix(scheme: string, _strict: boolean): string {\n  if (!scheme && !_strict) {\n    return 'file';\n  }\n  return scheme;\n}\n\n// implements a bit of https://tools.ietf.org/html/rfc3986#section-5\nfunction _referenceResolution(scheme: string, path: string): string {\n  // the slash-character is our 'default base' as we don't\n  // support constructing URIs relative to other URIs. This\n  // see https://tools.ietf.org/html/rfc3986#section-5.1.4\n  switch (scheme) {\n    case 'https':\n    case 'http':\n    case 'file':\n      if (!path) {\n        path = _slash;\n      } else if (path[0] !== _slash) {\n        path = _slash + path;\n      }\n      break;\n  }\n  return path;\n}\n\nconst _empty = '';\nconst _slash = '/';\nconst _regexp = /^(([^:/?#]+?):)?(\\/\\/([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?/;\n\n/**\n * Uniform Resource Identifier (URI) http://tools.ietf.org/html/rfc3986.\n * This class is a simple parser which creates the basic component parts\n * (http://tools.ietf.org/html/rfc3986#section-3) with minimal validation\n * and encoding.\n *\n * ```txt\n *       foo://example.com:8042/over/there?name=ferret#nose\n *       \\_/   \\______________/\\_________/ \\_________/ \\__/\n *        |           |            |            |        |\n *     scheme     authority       path        query   fragment\n *        |   _____________________|__\n *       / \\ /                        \\\n *       urn:example:animal:ferret:nose\n * ```\n */\nexport class Uri implements UriComponents {\n  static ensureTrailingSlash(uri: Uri, trailingSlash = '/') {\n    return uri.with({\n      path: uri.path.replace(TRAILING_SLASH_RX, trailingSlash),\n    });\n  }\n\n  static equals(l: Uri, r: Uri) {\n    return (\n      l.authority === r.authority &&\n      l.fragment === r.fragment &&\n      l.path === r.path &&\n      l.query === r.query &&\n      l.scheme === r.scheme\n    );\n  }\n\n  static getFirstPathSegmentAfterPrefix(child: Uri, parent: Uri): string {\n    const childHref = child.path;\n    const parentHref = parent.path;\n    const parentOffset = parentHref.charAt(parentHref.length - 1) === '/' ? -1 : 0;\n\n    for (let i = 0; i <= childHref.length; i++) {\n      if (i < parentHref.length) {\n        if (childHref.charAt(i) !== parentHref.charAt(i)) {\n          throw new Error(\n            `The child entry ${child.toString()} does not have the pathname of ${parent.toString()} as a prefix`\n          );\n        }\n      } else if (i === parentHref.length + parentOffset) {\n        if (childHref.charAt(i) !== '/') {\n          throw new Error(\n            `The child entry ${child.toString()} does not have the pathname of ${parent.toString()} as a prefix`\n          );\n        }\n      } else if (childHref.charAt(i) === '/') {\n        return childHref.slice(parentHref.length + 1 + parentOffset, i);\n      }\n    }\n\n    return childHref.slice(parentHref.length + 1 + parentOffset);\n  }\n\n  static isPrefixOf(prefix: Uri, uri: Uri) {\n    return (\n      prefix.authority === uri.authority &&\n      prefix.fragment === uri.fragment &&\n      prefix.query === uri.query &&\n      prefix.scheme === uri.scheme &&\n      uri.path.startsWith(prefix.path)\n    );\n  }\n\n  static isUri(thing: any): thing is Uri {\n    if (thing instanceof Uri) {\n      return true;\n    }\n    if (!thing) {\n      return false;\n    }\n    return (\n      typeof (<Uri>thing).authority === 'string' &&\n      typeof (<Uri>thing).fragment === 'string' &&\n      typeof (<Uri>thing).path === 'string' &&\n      typeof (<Uri>thing).query === 'string' &&\n      typeof (<Uri>thing).scheme === 'string' &&\n      typeof (<Uri>thing).fsPath === 'function' &&\n      typeof (<Uri>thing).with === 'function' &&\n      typeof (<Uri>thing).toString === 'function'\n    );\n  }\n\n  /**\n   * scheme is the 'http' part of 'http://www.msft.com/some/path?query#fragment'.\n   * The part before the first colon.\n   */\n  readonly scheme: string;\n\n  /**\n   * authority is the 'www.msft.com' part of 'http://www.msft.com/some/path?query#fragment'.\n   * The part between the first double slashes and the next slash.\n   */\n  readonly authority: string;\n\n  /**\n   * path is the '/some/path' part of 'http://www.msft.com/some/path?query#fragment'.\n   */\n  readonly path: string;\n\n  /**\n   * query is the 'query' part of 'http://www.msft.com/some/path?query#fragment'.\n   */\n  readonly query: string;\n\n  /**\n   * fragment is the 'fragment' part of 'http://www.msft.com/some/path?query#fragment'.\n   */\n  readonly fragment: string;\n\n  /**\n   * @internal\n   */\n  protected constructor(\n    scheme: string,\n    authority?: string,\n    path?: string,\n    query?: string,\n    fragment?: string,\n    _strict?: boolean\n  );\n\n  /**\n   * @internal\n   */\n  protected constructor(components: UriComponents);\n\n  /**\n   * @internal\n   */\n  protected constructor(\n    schemeOrData: string | UriComponents,\n    authority?: string,\n    path?: string,\n    query?: string,\n    fragment?: string,\n    _strict: boolean = false\n  ) {\n    if (typeof schemeOrData === 'object') {\n      this.scheme = schemeOrData.scheme || _empty;\n      this.authority = schemeOrData.authority || _empty;\n      this.path = schemeOrData.path || _empty;\n      this.query = schemeOrData.query || _empty;\n      this.fragment = schemeOrData.fragment || _empty;\n      // no validation because it's this URI\n      // that creates uri components.\n      // _validateUri(this);\n    } else {\n      this.scheme = _schemeFix(schemeOrData, _strict);\n      this.authority = authority || _empty;\n      this.path = _referenceResolution(this.scheme, path || _empty);\n      this.query = query || _empty;\n      this.fragment = fragment || _empty;\n\n      _validateUri(this, _strict);\n    }\n  }\n\n  // ---- filesystem path -----------------------\n\n  /**\n\t * Returns a string representing the corresponding file system path of this URI.\n\t * platform specific path separator.\n\t *\n\t * * Will *not* validate the path for invalid characters and semantics.\n\t * * Will *not* look at the scheme of this URI.\n\t * * The result shall *not* be used for display purposes but for accessing a file on disk.\n\t *\n\t *\n\t * The *difference* to `URI#path` is the use of the platform specific separator and the handling\n\t *\n\t * ```ts\n\t\tconst u = URI.parse('file://server/c$/folder/file.txt')\n\t\tu.authority === 'server'\n\t\tu.path === '/shares/c$/file.txt'\n\t\tu.fsPath === '\\\\server\\c$\\folder\\file.txt'\n\t```\n\t *\n\t * Using `URI#path` to read a file (using fs-apis) would not be enough because parts of the path,\n\t * namely the server name, would be missing. Therefore `URI#fsPath` exists - it's sugar to ease working\n\t * with URIs that represent files on disk (`file` scheme).\n\t */\n  get fsPath(): string {\n    // if (this.scheme !== 'file') {\n    // \tconsole.warn(`[UriError] calling fsPath with scheme ${this.scheme}`);\n    // }\n    return uriToFsPath(this, false);\n  }\n\n  // ---- modify to new -------------------------\n\n  with(change: {\n    scheme?: string;\n    authority?: string | null;\n    path?: string | null;\n    query?: string | null;\n    fragment?: string | null;\n  }): Uri {\n    if (!change) {\n      return this;\n    }\n\n    let { scheme, authority, path, query, fragment } = change;\n    if (scheme === undefined) {\n      scheme = this.scheme;\n    } else if (scheme === null) {\n      scheme = _empty;\n    }\n    if (authority === undefined) {\n      authority = this.authority;\n    } else if (authority === null) {\n      authority = _empty;\n    }\n    if (path === undefined) {\n      path = this.path;\n    } else if (path === null) {\n      path = _empty;\n    }\n    if (query === undefined) {\n      query = this.query;\n    } else if (query === null) {\n      query = _empty;\n    }\n    if (fragment === undefined) {\n      fragment = this.fragment;\n    } else if (fragment === null) {\n      fragment = _empty;\n    }\n\n    if (\n      scheme === this.scheme &&\n      authority === this.authority &&\n      path === this.path &&\n      query === this.query &&\n      fragment === this.fragment\n    ) {\n      return this;\n    }\n\n    return new _URI(scheme, authority, path, query, fragment);\n  }\n\n  // ---- parse & validate ------------------------\n\n  /**\n   * Creates a new URI from a string, e.g. `http://www.msft.com/some/path`,\n   * `file:///usr/home`, or `scheme:with/path`.\n   *\n   * @param value A string which represents an URI (see `URI#toString`).\n   */\n  static parse(value: string, _strict: boolean = false): Uri {\n    const match = _regexp.exec(value);\n    if (!match) {\n      return new _URI(_empty, _empty, _empty, _empty, _empty);\n    }\n    return new _URI(\n      match[2] || _empty,\n      percentDecode(match[4] || _empty),\n      percentDecode(match[5] || _empty),\n      percentDecode(match[7] || _empty),\n      percentDecode(match[9] || _empty),\n      _strict\n    );\n  }\n\n  /**\n\t * Creates a new URI from a file system path, e.g. `c:\\my\\files`,\n\t * `/usr/home`, or `\\\\server\\share\\some\\path`.\n\t *\n\t * The *difference* between `URI#parse` and `URI#file` is that the latter treats the argument\n\t * as path, not as stringified-uri. E.g. `URI.file(path)` is **not the same as**\n\t * `URI.parse('file://' + path)` because the path might contain characters that are\n\t * interpreted (# and ?). See the following sample:\n\t * ```ts\n\tconst good = URI.file('/coding/c#/project1');\n\tgood.scheme === 'file';\n\tgood.path === '/coding/c#/project1';\n\tgood.fragment === '';\n\tconst bad = URI.parse('file://' + '/coding/c#/project1');\n\tbad.scheme === 'file';\n\tbad.path === '/coding/c'; // path is now broken\n\tbad.fragment === '/project1';\n\t```\n\t *\n\t * @param path A file system path (see `URI#fsPath`)\n\t */\n  static file(path: string): Uri {\n    let authority = _empty;\n\n    // check for authority as used in UNC shares\n    // or use the path as given\n    if (path[0] === _slash && path[1] === _slash) {\n      const idx = path.indexOf(_slash, 2);\n      if (idx === -1) {\n        authority = path.substring(2);\n        path = _slash;\n      } else {\n        authority = path.substring(2, idx);\n        path = path.substring(idx) || _slash;\n      }\n    }\n\n    return new _URI('file', authority, path, _empty, _empty);\n  }\n\n  static from(components: {\n    scheme: string;\n    authority?: string;\n    path?: string;\n    query?: string;\n    fragment?: string;\n  }): Uri {\n    return new _URI(\n      components.scheme,\n      components.authority,\n      components.path,\n      components.query,\n      components.fragment\n    );\n  }\n\n  /**\n   * Join a URI path with path fragments and normalizes the resulting path.\n   *\n   * @param uri The input URI.\n   * @param pathFragment The path fragment to add to the URI path.\n   * @returns The resulting URI.\n   */\n  static joinPath(uri: Uri, ...pathFragment: string[]): Uri {\n    if (!uri.path) {\n      throw new Error(`[UriError]: cannot call joinPaths on URI without path`);\n    }\n    const newPath = join(uri.path, ...pathFragment);\n    return uri.with({ path: newPath });\n  }\n\n  // ---- printing/externalize ---------------------------\n\n  /**\n   * Creates a string representation for this URI. It's guaranteed that calling\n   * `URI.parse` with the result of this function creates an URI which is equal\n   * to this URI.\n   *\n   * * The result shall *not* be used for display purposes but for externalization or transport.\n   * * The result will be encoded using the percentage encoding and encoding happens mostly\n   * ignore the scheme-specific encoding rules.\n   *\n   * @param skipEncoding Do not encode the result, default is `false`\n   */\n  toString(skipEncoding: boolean = true): string {\n    return _asFormatted(this, skipEncoding);\n  }\n\n  toJSON(): UriComponents {\n    return this;\n  }\n\n  static revive(data: UriComponents | Uri): Uri;\n  static revive(data: UriComponents | Uri | undefined): Uri | undefined;\n  static revive(data: UriComponents | Uri | null): Uri | null;\n  static revive(data: UriComponents | Uri | undefined | null): Uri | undefined | null;\n  static revive(data: UriComponents | Uri | undefined | null): Uri | undefined | null {\n    if (!data) {\n      return data;\n    } else if (data instanceof Uri) {\n      return data;\n    } else {\n      const result = new _URI(data);\n      result._formatted = (<UriState>data).external;\n      result._fsPath = (<UriState>data)._sep === _pathSepMarker ? (<UriState>data).fsPath : null;\n      return result;\n    }\n  }\n}\n\nexport interface UriComponents {\n  scheme: string;\n  authority: string;\n  path: string;\n  query: string;\n  fragment: string;\n}\n\ninterface UriState extends UriComponents {\n  $mid: number;\n  external: string;\n  fsPath: string;\n  _sep: 1 | undefined;\n}\n\nconst _pathSepMarker = undefined;\n\n// eslint-disable-next-line @typescript-eslint/naming-convention\nclass _URI extends Uri {\n  _formatted: string | null = null;\n  _fsPath: string | null = null;\n\n  get fsPath(): string {\n    if (!this._fsPath) {\n      this._fsPath = uriToFsPath(this, false);\n    }\n    return this._fsPath;\n  }\n\n  toString(skipEncoding: boolean = true): string {\n    if (!skipEncoding) {\n      // we don't cache that\n      return _asFormatted(this, false);\n    } else {\n      if (!this._formatted) {\n        this._formatted = _asFormatted(this, true);\n      }\n      return this._formatted;\n    }\n  }\n\n  toJSON(): UriComponents {\n    const res = <UriState>{\n      $mid: 1,\n    };\n    // cached state\n    if (this._fsPath) {\n      res.fsPath = this._fsPath;\n      res._sep = _pathSepMarker;\n    }\n    if (this._formatted) {\n      res.external = this._formatted;\n    }\n    // uri components\n    if (this.path) {\n      res.path = this.path;\n    }\n    if (this.scheme) {\n      res.scheme = this.scheme;\n    }\n    if (this.authority) {\n      res.authority = this.authority;\n    }\n    if (this.query) {\n      res.query = this.query;\n    }\n    if (this.fragment) {\n      res.fragment = this.fragment;\n    }\n    return res;\n  }\n}\n\n// reserved characters: https://tools.ietf.org/html/rfc3986#section-2.2\nconst encodeTable: { [ch: number]: string } = {\n  [CharCode.Colon]: '%3A', // gen-delims\n  [CharCode.Slash]: '%2F',\n  [CharCode.QuestionMark]: '%3F',\n  [CharCode.Hash]: '%23',\n  [CharCode.OpenSquareBracket]: '%5B',\n  [CharCode.CloseSquareBracket]: '%5D',\n  [CharCode.AtSign]: '%40',\n\n  [CharCode.ExclamationMark]: '%21', // sub-delims\n  [CharCode.DollarSign]: '%24',\n  [CharCode.Ampersand]: '%26',\n  [CharCode.SingleQuote]: '%27',\n  [CharCode.OpenParen]: '%28',\n  [CharCode.CloseParen]: '%29',\n  [CharCode.Asterisk]: '%2A',\n  [CharCode.Plus]: '%2B',\n  [CharCode.Comma]: '%2C',\n  [CharCode.Semicolon]: '%3B',\n  [CharCode.Equals]: '%3D',\n\n  [CharCode.Space]: '%20',\n};\n\nfunction encodeURIComponentFast(uriComponent: string, allowSlash: boolean): string {\n  let res: string | undefined = undefined;\n  let nativeEncodePos = -1;\n\n  for (let pos = 0; pos < uriComponent.length; pos++) {\n    const code = uriComponent.charCodeAt(pos);\n\n    // unreserved characters: https://tools.ietf.org/html/rfc3986#section-2.3\n    if (\n      (code >= CharCode.a && code <= CharCode.z) ||\n      (code >= CharCode.A && code <= CharCode.Z) ||\n      (code >= CharCode.Digit0 && code <= CharCode.Digit9) ||\n      code === CharCode.Dash ||\n      code === CharCode.Period ||\n      code === CharCode.Underline ||\n      code === CharCode.Tilde ||\n      (allowSlash && code === CharCode.Slash)\n    ) {\n      // check if we are delaying native encode\n      if (nativeEncodePos !== -1) {\n        res += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));\n        nativeEncodePos = -1;\n      }\n      // check if we write into a new string (by default we try to return the param)\n      if (res !== undefined) {\n        res += uriComponent.charAt(pos);\n      }\n    } else {\n      // encoding needed, we need to allocate a new string\n      if (res === undefined) {\n        res = uriComponent.substr(0, pos);\n      }\n\n      // check with default table first\n      const escaped = encodeTable[code];\n      if (escaped !== undefined) {\n        // check if we are delaying native encode\n        if (nativeEncodePos !== -1) {\n          res += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));\n          nativeEncodePos = -1;\n        }\n\n        // append escaped variant to result\n        res += escaped;\n      } else if (nativeEncodePos === -1) {\n        // use native encode only when needed\n        nativeEncodePos = pos;\n      }\n    }\n  }\n\n  if (nativeEncodePos !== -1) {\n    res += encodeURIComponent(uriComponent.substring(nativeEncodePos));\n  }\n\n  return res !== undefined ? res : uriComponent;\n}\n\nfunction encodeURIComponentMinimal(path: string): string {\n  let res: string | undefined = undefined;\n  for (let pos = 0; pos < path.length; pos++) {\n    const code = path.charCodeAt(pos);\n    if (code === CharCode.Hash || code === CharCode.QuestionMark) {\n      if (res === undefined) {\n        res = path.substr(0, pos);\n      }\n      res += encodeTable[code];\n    } else {\n      if (res !== undefined) {\n        res += path[pos];\n      }\n    }\n  }\n  return res !== undefined ? res : path;\n}\n\n/**\n * Compute `fsPath` for the given uri\n */\nexport function uriToFsPath(uri: Uri, keepDriveLetterCasing: boolean): string {\n  let value: string;\n  if (uri.authority && uri.path.length > 1 && uri.scheme === 'file') {\n    // unc path: file://shares/c$/far/boo\n    value = `//${uri.authority}${uri.path}`;\n  } else if (\n    uri.path.charCodeAt(0) === CharCode.Slash &&\n    ((uri.path.charCodeAt(1) >= CharCode.A && uri.path.charCodeAt(1) <= CharCode.Z) ||\n      (uri.path.charCodeAt(1) >= CharCode.a && uri.path.charCodeAt(1) <= CharCode.z)) &&\n    uri.path.charCodeAt(2) === CharCode.Colon\n  ) {\n    if (!keepDriveLetterCasing) {\n      // windows drive letter: file:///c:/far/boo\n      value = uri.path[1].toLowerCase() + uri.path.substr(2);\n    } else {\n      value = uri.path.substr(1);\n    }\n  } else {\n    // other path\n    value = uri.path;\n  }\n  return value;\n}\n\n/**\n * Create the external version of a uri\n */\nfunction _asFormatted(uri: Uri, skipEncoding: boolean): string {\n  const encoder = !skipEncoding ? encodeURIComponentFast : encodeURIComponentMinimal;\n\n  let res = '';\n  let { scheme, authority, path, query, fragment } = uri;\n  if (scheme) {\n    res += scheme;\n    res += ':';\n  }\n  if (authority || scheme === 'file') {\n    res += _slash;\n    res += _slash;\n  }\n  if (authority) {\n    let idx = authority.indexOf('@');\n    if (idx !== -1) {\n      // <user>@<auth>\n      const userinfo = authority.substr(0, idx);\n      authority = authority.substr(idx + 1);\n      idx = userinfo.indexOf(':');\n      if (idx === -1) {\n        res += encoder(userinfo, false);\n      } else {\n        // <user>:<pass>@<auth>\n        res += encoder(userinfo.substr(0, idx), false);\n        res += ':';\n        res += encoder(userinfo.substr(idx + 1), false);\n      }\n      res += '@';\n    }\n    authority = authority.toLowerCase();\n    idx = authority.indexOf(':');\n    if (idx === -1) {\n      res += encoder(authority, false);\n    } else {\n      // <auth>:<port>\n      res += encoder(authority.substr(0, idx), false);\n      res += authority.substr(idx);\n    }\n  }\n  if (path) {\n    // lower-case windows drive letters in /C:/fff or C:/fff\n    if (\n      path.length >= 3 &&\n      path.charCodeAt(0) === CharCode.Slash &&\n      path.charCodeAt(2) === CharCode.Colon\n    ) {\n      const code = path.charCodeAt(1);\n      if (code >= CharCode.A && code <= CharCode.Z) {\n        path = `/${String.fromCharCode(code + 32)}:${path.substr(3)}`; // \"/c:\".length === 3\n      }\n    } else if (path.length >= 2 && path.charCodeAt(1) === CharCode.Colon) {\n      const code = path.charCodeAt(0);\n      if (code >= CharCode.A && code <= CharCode.Z) {\n        path = `${String.fromCharCode(code + 32)}:${path.substr(2)}`; // \"/c:\".length === 3\n      }\n    }\n    // encode the rest of the path\n    res += encoder(path, true);\n  }\n  if (query) {\n    res += '?';\n    res += encoder(query, false);\n  }\n  if (fragment) {\n    res += '#';\n    res += !skipEncoding ? encodeURIComponentFast(fragment, false) : fragment;\n  }\n  return res;\n}\n\n// --- decode\n\nfunction decodeURIComponentGraceful(str: string): string {\n  try {\n    return decodeURIComponent(str);\n  } catch {\n    if (str.length > 3) {\n      return str.substr(0, 3) + decodeURIComponentGraceful(str.substr(3));\n    } else {\n      return str;\n    }\n  }\n}\n\nconst _rEncodedAsHex = /(%[0-9A-Za-z][0-9A-Za-z])+/g;\n\nfunction percentDecode(str: string): string {\n  if (!str.match(_rEncodedAsHex)) {\n    return str;\n  }\n  return str.replace(_rEncodedAsHex, (match) => decodeURIComponentGraceful(match));\n}\n\nconst TRAILING_SLASH_RX = /\\/?$/;\n","export default function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}","function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nexport default function _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}","module.exports = require(\"regenerator-runtime\");\n","import unsupportedIterableToArray from \"./unsupportedIterableToArray\";\nexport default function _createForOfIteratorHelper(o) {\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (o = unsupportedIterableToArray(o))) {\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var it,\n      normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}","import setPrototypeOf from \"./setPrototypeOf\";\nexport default function _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) setPrototypeOf(subClass, superClass);\n}","export default function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}","import _typeof from \"../../helpers/esm/typeof\";\nimport assertThisInitialized from \"./assertThisInitialized\";\nexport default function _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return assertThisInitialized(self);\n}","import getPrototypeOf from \"./getPrototypeOf\";\nimport isNativeReflectConstruct from \"./isNativeReflectConstruct\";\nimport possibleConstructorReturn from \"./possibleConstructorReturn\";\nexport default function _createSuper(Derived) {\n  return function () {\n    var Super = getPrototypeOf(Derived),\n        result;\n\n    if (isNativeReflectConstruct()) {\n      var NewTarget = getPrototypeOf(this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return possibleConstructorReturn(this, result);\n  };\n}","export default function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}","function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nexport default function _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n\n      _next(undefined);\n    });\n  };\n}","import arrayWithHoles from \"./arrayWithHoles\";\nimport iterableToArrayLimit from \"./iterableToArrayLimit\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray\";\nimport nonIterableRest from \"./nonIterableRest\";\nexport default function _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();\n}","export default function _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}","export default function _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}","export default function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","const SPEC_RX = /^((@[^/]+\\/[^/@]+|[^./@][^/@]*)(?:@([^/]+))?)(.*)?$/;\n\ntype _BareModuleSpec<T = ReturnType<typeof parseBareModuleSpec>> = T extends null | undefined\n  ? never\n  : T;\nexport type BareModuleSpec = _BareModuleSpec;\n\nexport function parseBareModuleSpec(bareModuleSpec: string) {\n  const matches = bareModuleSpec.match(SPEC_RX);\n\n  if (matches) {\n    const [, nameSpec, name, spec, path = ''] = matches;\n\n    return {\n      nameSpec,\n      name,\n      spec,\n      path,\n    };\n  }\n\n  return null;\n}\n","import { version as nodeLibsVersion } from '@velcro/node-libs/package.json';\nimport { BareModuleSpec, parseBareModuleSpec } from './bareModules';\n\nexport const NODE_CORE_SHIMS: Record<string, BareModuleSpec | undefined> = Object.assign(\n  Object.create(null),\n  {\n    string_decoder: parseBareModuleSpec('string_decoder@1.2.0'),\n    punycode: parseBareModuleSpec('punycode@2.1.1'),\n  }\n);\n\nfor (const name of [\n  'assert',\n  'buffer',\n  'constants',\n  'crypto',\n  'events',\n  'fs',\n  'http',\n  'https',\n  'net',\n  'os',\n  'path',\n  'process',\n  'querystring',\n  'stream',\n  'tls',\n  'url',\n  'util',\n  'vm',\n  'zlib',\n]) {\n  NODE_CORE_SHIMS[name] = parseBareModuleSpec(\n    `@velcro/node-libs@${nodeLibsVersion}/lib/${name}.js`\n  )!;\n}\n","import type { Thenable, Uri } from '@velcro/common';\nimport type { ResolverContext } from './context';\nimport type { Resolver } from './resolver';\n\ntype MaybeThenable<T> = T | Thenable<T>;\n\nexport interface ResolverStrategy {\n  /**\n   * Produce a url given the components of a bare module specifier.\n   *\n   * @param ctx A `ResolverContext` that should be used for making calls to other strategy methods\n   * @param name The name of a bare module\n   * @param spec The optional `@version` of a bare module specifier\n   * @param path The optional path at the end of the bare module specifier\n   */\n  getUrlForBareModule?(\n    ctx: ResolverContext,\n    name: string,\n    spec: string,\n    path: string\n  ): MaybeThenable<ResolverStrategy.BareModuleResult>;\n\n  /**\n   * Determine the canonical uri for a given uri.\n   *\n   * For example, you might consider symlink targets their canonicalized path or you might\n   * consider the canonicalized path of https://unpkg.com/react to be\n   * https://unpkg.com/react@16.13.1/index.js.\n   *\n   * Dealing only in canonical uris means that anything produced from those can be cached.\n   *\n   * @param ctx A `ResolverContext` that should be used for making calls to other strategy methods\n   * @param uri The uri to canonicalize\n   */\n  getCanonicalUrl(\n    ctx: ResolverContext,\n    uri: Uri\n  ): MaybeThenable<ResolverStrategy.CanonicalizeResult>;\n\n  /**\n   * Get the logical resolve root for a given uri.\n   *\n   * For example, a filesystem-based strategy might consider the root to be `file:///`. Or,\n   * if it was scoped to /home/filearts, the root might be `file:///home/filearts/`.\n   *\n   * Any uri that is not a 'child' of the resolve root should be considered out of scope for a given\n   * strategy.\n   *\n   * @param ctx A `ResolverContext` that should be used for making calls to other strategy methods\n   * @param uri The uri for which the logical resolve root uri should be found\n   */\n  getResolveRoot(ctx: ResolverContext, uri: Uri): MaybeThenable<ResolverStrategy.ResolveRootResult>;\n\n  /**\n   * Get the settings for a given uri\n   *\n   * This indirection allows resolver strategies to have per-strategy or even per-uri settings.\n   *\n   * @param ctx A `ResolverContext` that should be used for making calls to other strategy methods\n   * @param uri The uri for which to load settings\n   */\n  getSettings(ctx: ResolverContext, uri: Uri): MaybeThenable<ResolverStrategy.SettingsResult>;\n\n  /**\n   * Produce a list of resolved entries that are direct children of the given uri.\n   *\n   * This is the moral equivalent to something like non-recursive `fs.readdir()`. It is only\n   * designed to show files and folders (for now).\n   *\n   * @param ctx A `ResolverContext` that should be used for making calls to other strategy methods\n   * @param uri The uri at which to list entries\n   */\n  listEntries(ctx: ResolverContext, uri: Uri): MaybeThenable<ResolverStrategy.ListEntriesResult>;\n\n  /**\n   * Read the content at the uri as an `ArrayBuffer`\n   *\n   * ArrayBuffers are the lowest-common-denominator across the web and node and can easily be\n   * decoded with standard web apis like `StringDecoder`. In Node.js, `Buffer` objects are also\n   * `ArrayBuffer`s, allowing the tooling to be built on that primitive.\n   *\n   * This is helpful for the understanding that not all uris are expected to produce meaningful\n   * text representations.\n   *\n   * @param ctx A `ResolverContext` that should be used for making calls to other strategy methods\n   * @param uri The uri at which to read the content\n   */\n  readFileContent(\n    ctx: ResolverContext,\n    uri: Uri\n  ): MaybeThenable<ResolverStrategy.ReadFileContentResult>;\n}\n\nexport interface ResolverStrategyWithRoot extends ResolverStrategy {\n  /**\n   * The root uri of the strategy.\n   *\n   * A common parent to all uris that this strategy can handle.\n   *\n   * This may sometimes be the same value as would be returned by `getResolveRoot` but will\n   * sometimes be a parent of that. Take, for example Unpkg; there, we may want to express\n   * that a strategy should 'own' all uris under https://unpkg.com/ even though the resolve\n   * root for https://unpkg.com/react@16.13.1/index.js will actually be\n   * https://unpkg.com/react@16.13.1/.\n   *\n   * Notably, the `CompoundResolverStrategy` requires all child strategies implement the\n   * `ResolverStrategyWithRoot` interface because it dispatches operations on different\n   * uris according to each strategy's `rootUri`.\n   */\n  rootUri: Uri;\n}\n\nexport namespace ResolverStrategy {\n  export enum EntryKind {\n    File = 'file',\n    Directory = 'directory',\n  }\n\n  export interface Entry<TKind extends EntryKind = EntryKind> {\n    uri: Uri;\n    type: TKind;\n  }\n\n  export type BareModuleResult = {\n    found: boolean;\n    uri: Uri | null;\n  };\n\n  export interface CanonicalizeResult {\n    uri: Uri;\n  }\n\n  export interface ResolveRootResult {\n    uri: Uri;\n  }\n\n  export interface SettingsResult {\n    settings: Resolver.Settings;\n  }\n\n  export interface ListEntriesResult {\n    entries: Entry[];\n  }\n\n  export interface ReadFileContentResult {\n    content: ArrayBuffer;\n  }\n}\n\nexport abstract class AbstractResolverStrategy implements ResolverStrategy {\n  getCanonicalUrl(\n    _ctx: ResolverContext,\n    uri: Uri\n  ): ReturnType<ResolverStrategy['getCanonicalUrl']> {\n    return {\n      uri,\n    };\n  }\n\n  getSettings(ctx: ResolverContext, _uri: Uri): ReturnType<ResolverStrategy['getSettings']> {\n    return {\n      settings: ctx.settings,\n    };\n  }\n\n  /**\n   * Create a new ResolverStrategy having one or more methods overridden.\n   *\n   * You might use this if you want to override specific behaviour of another strategy without\n   * wanting to re-implement the whole strategy.\n   *\n   * If you need to invoke an overridden method, the overridden strategy will be available\n   * on `this.parent`.\n   *\n   * @param overrides A map of ResolverStrategy methods that you would like to override\n   */\n  withOverrides(\n    overrides: {\n      [TMethodName in keyof ResolverStrategy]?: ResolverStrategy[TMethodName];\n    }\n  ): ResolverStrategy {\n    const strategy = { ...overrides, parent: this };\n\n    return Object.setPrototypeOf(Object.assign(Object.create(null), strategy), this);\n  }\n\n  abstract getResolveRoot(\n    ctx: ResolverContext,\n    uri: Uri\n  ): ReturnType<ResolverStrategy['getResolveRoot']>;\n  abstract listEntries(ctx: ResolverContext, uri: Uri): ReturnType<ResolverStrategy['listEntries']>;\n  abstract readFileContent(\n    ctx: ResolverContext,\n    uri: Uri\n  ): ReturnType<ResolverStrategy['readFileContent']>;\n}\n\nexport abstract class AbstractResolverStrategyWithRoot extends AbstractResolverStrategy\n  implements ResolverStrategyWithRoot {\n  constructor(readonly rootUri: Uri) {\n    super();\n  }\n}\n","import {\n  all,\n  Awaited,\n  basename,\n  CanceledError,\n  CancellationToken,\n  CancellationTokenSource,\n  checkCancellation,\n  Decoder,\n  DependencyNotFoundError,\n  dirname,\n  EntryExcludedError,\n  EntryNotFoundError,\n  isThenable,\n  MapSet,\n  PackageJson,\n  parseBufferAsPackageJson,\n  parseBufferAsPartialPackageJson,\n  PartialPackageJson,\n  Thenable,\n  Uri,\n} from '@velcro/common';\nimport { BareModuleSpec, parseBareModuleSpec } from './bareModules';\nimport type { Resolver } from './resolver';\nimport { NODE_CORE_SHIMS } from './shims';\nimport { ResolverStrategy } from './strategy';\n\ntype ReturnTypeWithVisits<\n  T extends (...args: any[]) => any,\n  TReturn = ReturnType<T>\n> = TReturn extends Thenable<infer U>\n  ? Promise<U & { visited: ResolverContext.Visit[] }>\n  : TReturn & { visited: ResolverContext.Visit[] };\n\n// type UncachedReturnType<T> = { [K in keyof T] : K extends typeof CACHE ? never : T[K] };\n// type UncachedReturn<\n//   T extends (...any: any[]) => any,\n//   TReturn = ReturnType<T>\n// > = TReturn extends Thenable<infer U>\n//   ? Thenable<UncachedReturnType<U>>\n//   : UncachedReturnType<TReturn>;\n\nconst CACHE = Symbol('Context.cache');\n\ntype InvalidationRecord = {\n  cacheKey: string;\n  operationCache: Map<string, unknown>;\n};\n\ntype ResolveResult =\n  | {\n      found: false;\n      uri: null;\n      parentPackageJson?: { packageJson: PackageJson; uri: Uri };\n    }\n  | {\n      found: true;\n      uri: null;\n      parentPackageJson?: { packageJson: PackageJson; uri: Uri };\n      rootUri: Uri;\n    }\n  | {\n      found: true;\n      uri: Uri;\n      parentPackageJson?: { packageJson: PackageJson; uri: Uri };\n      rootUri: Uri;\n    };\n\ntype ReadParentPackageJsonResultInternal =\n  | {\n      found: true;\n      packageJson: PackageJson;\n      uri: Uri;\n      visitedDirs: Uri[];\n    }\n  | {\n      found: false;\n      packageJson: null;\n      uri: null;\n    };\n\ntype StrategyResult<T> =\n  | Promise<T & { visited: ResolverContext.Visit[] }>\n  | (T & { visited: ResolverContext.Visit[] });\n\nclass Visits {\n  private readonly parent?: Visits;\n  private readonly visits = [] as ResolverContext.Visit[];\n\n  constructor(readonly uri: { toString(): string }, parent?: Visits) {\n    this.parent = parent;\n  }\n\n  child(uri: { toString(): string }): Visits {\n    return new Visits(uri, this);\n  }\n\n  push(visit: ResolverContext.Visit) {\n    if (!this.visits.find((cmp) => cmp.type == visit.type && Uri.equals(cmp.uri, visit.uri))) {\n      this.visits.push(visit);\n      if (this.parent) {\n        this.parent.push(visit);\n      }\n    }\n  }\n\n  toArray(): ResolverContext.Visit[] {\n    return this.parent ? this.parent.toArray() : this.visits.slice();\n  }\n}\n\nexport class ResolverContext {\n  static create(\n    resolver: Resolver,\n    strategy: ResolverStrategy,\n    settings: Resolver.Settings,\n    token: CancellationToken,\n    options: { debug?: boolean } = {}\n  ) {\n    return new ResolverContext({\n      cache: new Map(),\n      cacheInvalidations: new MapSet(),\n      debug: !!options.debug,\n      decoder: new Decoder(),\n      path: [],\n      resolver,\n      settings,\n      strategy,\n      token,\n      visits: new Visits(Uri.parse('velcro:/root')),\n    });\n  }\n\n  private readonly cache: ResolverContext.Options['cache'];\n  private readonly cacheInvalidations: ResolverContext.Options['cacheInvalidations'];\n  private readonly debugMode: boolean;\n  readonly decoder: ResolverContext.Options['decoder'];\n  private readonly mapResultWithVisits = <T>(result: T) =>\n    Object.assign(result, { visited: this.visits.toArray() });\n  readonly path: ReadonlyArray<string>;\n  private readonly resolver: ResolverContext.Options['resolver'];\n  readonly settings: Readonly<ResolverContext.Options['settings']>;\n  private readonly strategy: ResolverContext.Options['strategy'];\n  private readonly tokenSource: CancellationTokenSource;\n  private readonly visits: Visits;\n\n  protected constructor(options: ResolverContext.Options) {\n    this.cache = options.cache;\n    this.cacheInvalidations = options.cacheInvalidations;\n    this.debugMode = options.debug;\n    this.decoder = options.decoder;\n    this.path = options.path;\n    this.resolver = options.resolver;\n    this.settings = options.settings;\n    this.strategy = options.strategy;\n    this.tokenSource = new CancellationTokenSource(options.token);\n    this.visits = options.visits;\n  }\n\n  get token() {\n    return this.tokenSource.token;\n  }\n\n  get visited() {\n    return this.visits.toArray();\n  }\n\n  dispose() {\n    this.tokenSource.dispose(true);\n  }\n\n  forOperation(\n    operationName: string,\n    uri: { toString(): string },\n    options: { resetPath?: boolean; resetVisits?: boolean } = {}\n  ) {\n    const encodedOperation = encodePathNode(operationName, uri);\n\n    if (this.path.includes(encodedOperation)) {\n      const formattedPath = this.path\n        .map((segment) => {\n          const { operationName, uri } = decodePathNode(segment);\n\n          return `${operationName}(${uri.toString()})`;\n        })\n        .join(' -> ');\n\n      throw this._wrapError(\n        new Error(\n          `Detected a recursive call to the operation '${operationName}' for '${uri.toString()}' at path '${formattedPath}'`\n        )\n      );\n    }\n\n    return new ResolverContext({\n      cache: this.cache,\n      cacheInvalidations: this.cacheInvalidations,\n      debug: this.debugMode,\n      decoder: this.decoder,\n      path: options.resetPath ? [] : this.path.concat(encodedOperation),\n      resolver: this.resolver,\n      settings: this.settings,\n      strategy: this.strategy,\n      token: this.tokenSource.token,\n      visits: options.resetVisits ? new Visits(uri) : this.visits.child(uri),\n    });\n  }\n\n  getCanonicalUrl(uri: Uri): StrategyResult<ResolverStrategy.CanonicalizeResult> {\n    const method = this.strategy.getCanonicalUrl;\n    const receiver = this.strategy;\n    const operationName = 'Strategy.getCanonicalUrl';\n    const href = uri.toString();\n\n    return this.runInChildContext(operationName, uri, (ctx) =>\n      ctx.runWithCache(operationName, href, method, receiver, ctx, uri)\n    );\n  }\n\n  getResolveRoot(uri: Uri): StrategyResult<ResolverStrategy.ResolveRootResult> {\n    const method = this.strategy.getResolveRoot;\n    const receiver = this.strategy;\n    const operationName = 'Strategy.getResolveRoot';\n    const href = uri.toString();\n\n    return this.runInChildContext(operationName, uri, (ctx) =>\n      ctx.runWithCache(operationName, href, method, receiver, ctx, uri)\n    );\n  }\n\n  getSettings(uri: Uri): StrategyResult<ResolverStrategy.SettingsResult> {\n    const method = this.strategy.getSettings;\n    const receiver = this.strategy;\n    const operationName = 'Strategy.getSettings';\n    const href = uri.toString();\n\n    return this.runInChildContext(operationName, uri, (ctx) =>\n      ctx.runWithCache(operationName, href, method, receiver, ctx, uri)\n    );\n  }\n\n  getUrlForBareModule(\n    name: string,\n    spec: string,\n    path: string\n  ): StrategyResult<ResolverStrategy.BareModuleResult> {\n    const method = this.strategy.getUrlForBareModule;\n\n    if (!method) {\n      return Promise.reject(\n        new Error(\n          `Unable to resolve bare module spec '${name}@${spec}${path}' because no strategy was found that supports resolving bare modules`\n        )\n      );\n    }\n\n    const receiver = this.strategy;\n    const operationName = 'Strategy.getUrlForBareModule';\n    const href = `${name}@${spec}${path}`;\n\n    return this.runInChildContext(operationName, href, (ctx) =>\n      ctx.runWithCache(operationName, href, method, receiver, ctx, name, spec, path)\n    );\n  }\n\n  invalidate(uri: Uri) {\n    const href = uri.toString();\n    const invalidations = this.cacheInvalidations.get(href);\n    let invalidated = false;\n\n    if (invalidations) {\n      for (const { cacheKey, operationCache } of invalidations) {\n        invalidated = operationCache.delete(cacheKey) || invalidated;\n      }\n    }\n\n    this.cacheInvalidations.deleteAll(href);\n\n    return invalidated;\n  }\n\n  listEntries(uri: Uri): StrategyResult<ResolverStrategy.ListEntriesResult> {\n    const method = this.strategy.listEntries;\n    const receiver = this.strategy;\n    const operationName = 'Strategy.listEntries';\n    const href = uri.toString();\n\n    return this.runInChildContext(operationName, uri, (ctx) =>\n      ctx.runWithCache(operationName, href, method, receiver, ctx, uri)\n    );\n  }\n\n  readFileContent(uri: Uri): StrategyResult<ResolverStrategy.ReadFileContentResult> {\n    const method = this.strategy.readFileContent;\n    const receiver = this.strategy;\n    const operationName = 'Strategy.readFileContent';\n    const href = uri.toString();\n\n    this.recordVisit(uri, ResolverContext.VisitKind.File);\n\n    return this.runInChildContext(operationName, uri, (ctx) =>\n      ctx.runWithCache(operationName, href, method, receiver, ctx, uri)\n    );\n  }\n\n  readParentPackageJson(uri: Uri): StrategyResult<ReadParentPackageJsonResultInternal> {\n    return this.runWithCache(\n      'readParentPackageJson',\n      uri.toString(),\n      readParentPackageJson,\n      null,\n      this,\n      uri\n    );\n  }\n\n  recordVisit(uri: Uri, type: ResolverContext.VisitKind = ResolverContext.VisitKind.File) {\n    this.visits.push({ type, uri });\n  }\n\n  resolve(spec: string, fromUri: Uri): StrategyResult<ResolveResult> {\n    const method = resolveDependency;\n    const receiver = null;\n    const operationName = 'resolve';\n    const href = `${fromUri}|${spec}`;\n\n    return this.runInChildContext(operationName, href, (ctx) =>\n      ctx.runWithCache(operationName, href, method, receiver, ctx, fromUri, spec)\n    );\n  }\n\n  resolveUri(uri: Uri): StrategyResult<ResolveResult> {\n    const method = resolve;\n    const receiver = null;\n    const operationName = 'resolveUri';\n    const href = uri.toString();\n\n    return this.runInChildContext(operationName, uri, (ctx) =>\n      ctx.runWithCache(operationName, href, method, receiver, ctx, uri)\n    );\n  }\n\n  runInChildContext<T>(\n    operationName: string,\n    uri: { toString(): string },\n    contextFn: (ctx: ResolverContext) => T\n  ): T {\n    return this.runInContext(\n      operationName,\n      uri,\n      { resetPath: false, resetVisits: false },\n      contextFn\n    );\n  }\n\n  runInIsolatedContext<T>(\n    operationName: string,\n    uri: { toString(): string },\n    contextFn: (ctx: ResolverContext) => T\n  ): T {\n    return this.runInContext(operationName, uri, { resetPath: true, resetVisits: true }, contextFn);\n  }\n\n  private runInContext<T>(\n    operationName: string,\n    uri: { toString(): string },\n    options: { resetPath: boolean; resetVisits: boolean },\n    contextFn: (ctx: ResolverContext) => T\n  ) {\n    const ctx = this.forOperation(operationName, uri, options);\n\n    ctx.debug('%s(%s)', operationName, uri.toString());\n\n    return contextFn(ctx);\n  }\n\n  private createStoreResultFn<TMethod extends (...args: any[]) => any>(\n    operationCache: Map<string, ReturnTypeWithVisits<TMethod>>,\n    cacheKey: string\n  ) {\n    return (result: ReturnTypeWithVisits<TMethod>) => {\n      const mappedResult = this.mapResultWithVisits(result);\n      const visited = mappedResult.visited as ResolverContext.Visit[];\n\n      if (mappedResult[CACHE]) {\n        const cacheEntries = mappedResult[CACHE] as [string, ReturnTypeWithVisits<TMethod>][];\n        delete mappedResult[CACHE];\n\n        for (const [cacheKey, value] of cacheEntries) {\n          operationCache.set(cacheKey, value);\n\n          for (const visit of visited) {\n            this.cacheInvalidations.add(visit.uri.toString(), { cacheKey, operationCache });\n          }\n        }\n      }\n\n      // Override the pending value with the resolved value\n      operationCache.set(cacheKey, mappedResult);\n\n      for (const visit of visited) {\n        this.cacheInvalidations.add(visit.uri.toString(), { cacheKey, operationCache });\n      }\n\n      return mappedResult;\n    };\n  }\n\n  private runWithCache<TMethod extends (...args: any[]) => any>(\n    cacheSegment: string,\n    cacheKey: string,\n    fn: TMethod,\n    target: unknown,\n    ...args: Parameters<TMethod>\n  ): ReturnTypeWithVisits<TMethod> {\n    let operationCache = this.cache.get(cacheSegment) as\n      | Map<string, ReturnTypeWithVisits<TMethod>>\n      | undefined;\n\n    if (!operationCache) {\n      operationCache = new Map();\n      this.cache.set(cacheSegment, operationCache);\n    }\n\n    const cached = operationCache.get(cacheKey);\n\n    if (cached) {\n      this.debug('%s(%s) [HIT]', cacheSegment, cacheKey);\n\n      // We either have a cached result or a cached promise for a result. Either way, the value\n      // is suitable as a return.\n      return cached;\n    }\n\n    const cacheResult = this.createStoreResultFn(operationCache, cacheKey);\n\n    this.debug('%s(%s) [MISS]', cacheSegment, cacheKey);\n\n    // Nothing is cached\n    const ret = fn.apply(target, args);\n\n    if (isThenable(ret)) {\n      const promiseRet = ret as Thenable<ReturnTypeWithVisits<TMethod>>;\n\n      // Produce a promise that will only be settled once the cache has been updated accordingly.\n      const wrappedRet = promiseRet.then(cacheResult, (err) => {\n        // Delete the entry from the cache in case it was a transient failure\n        operationCache!.delete(cacheKey);\n\n        return Promise.reject(err);\n      });\n\n      // Set the pending value in the cache for now\n      operationCache.set(cacheKey, wrappedRet as Awaited<Thenable<ReturnTypeWithVisits<TMethod>>>);\n\n      return wrappedRet as Awaited<Thenable<ReturnTypeWithVisits<TMethod>>>;\n    }\n\n    return cacheResult(ret);\n  }\n\n  private _wrapError<T extends Error>(\n    err: T\n  ): T & { path: { operationName: string; uri: Uri | string }[] } {\n    return Object.assign(err, {\n      path: this.path.map(decodePathNode),\n    });\n  }\n\n  debug(...args: Parameters<Console['warn']>) {\n    if (this.debugMode) {\n      if (typeof args[0] === 'string') {\n        args[0] = ' '.repeat(this.path.length) + args[0];\n      }\n      console.warn(...args);\n    }\n  }\n}\n\nfunction encodePathNode(operationName: string, uri: { toString(): string }) {\n  return `${operationName}:${uri.toString()}`;\n}\n\nfunction decodePathNode(node: string) {\n  const parts = node.split(':', 2);\n\n  if (parts.length !== 2) {\n    console.log('WTF', { node, parts });\n    throw new Error(`Invariant violation: Unexpected path node: '${node}'`);\n  }\n\n  return {\n    operationName: parts[0],\n    uri: parts[1].includes(':') ? Uri.parse(parts[1]) : parts[1],\n  };\n}\n\nasync function resolve(ctx: ResolverContext, uri: Uri): Promise<ResolveResult> {\n  const bothResolved = all(\n    [ctx.getCanonicalUrl(uri), ctx.getResolveRoot(uri), ctx.getSettings(uri)],\n    ctx.token\n  );\n\n  const [canonicalizationResult, resolveRootResult, settingsResult] = isThenable(bothResolved)\n    ? await checkCancellation(bothResolved, ctx.token)\n    : bothResolved;\n\n  const rootUri = resolveRootResult.uri;\n  const rootUriWithoutTrailingSlash = Uri.ensureTrailingSlash(rootUri, '');\n\n  if (!Uri.isPrefixOf(rootUriWithoutTrailingSlash, canonicalizationResult.uri)) {\n    throw new Error(\n      `Unable to resolve a module whose path ${canonicalizationResult.uri.toString(\n        true\n      )} is above the host's root ${rootUri.toString()}`\n    );\n  }\n\n  const resolveReturn =\n    Uri.equals(rootUriWithoutTrailingSlash, canonicalizationResult.uri) ||\n    Uri.equals(rootUri, canonicalizationResult.uri)\n      ? ctx.runInChildContext('resolveAsDirectory', canonicalizationResult.uri, (ctx) =>\n          resolveAsDirectory(\n            ctx,\n            Uri.ensureTrailingSlash(canonicalizationResult.uri),\n            resolveRootResult.uri,\n            settingsResult.settings\n          )\n        )\n      : ctx.runInChildContext('resolveAsFile', canonicalizationResult.uri, (ctx) =>\n          resolveAsFile(\n            ctx,\n            canonicalizationResult.uri,\n            resolveRootResult.uri,\n            settingsResult.settings,\n            null\n          )\n        );\n  const readParentPackageJsonReturn = ctx.readParentPackageJson(uri);\n  const resolveAndPackageJson = all([resolveReturn, readParentPackageJsonReturn], ctx.token);\n  const [resolveResult, readParentPackageJsonResult] = isThenable(resolveAndPackageJson)\n    ? await resolveAndPackageJson\n    : resolveAndPackageJson;\n\n  return {\n    ...resolveResult,\n    parentPackageJson: readParentPackageJsonResult.found\n      ? {\n          packageJson: readParentPackageJsonResult.packageJson,\n          uri: readParentPackageJsonResult.uri,\n        }\n      : undefined,\n  };\n}\n\nasync function resolveDependency(ctx: ResolverContext, fromUri: Uri, spec: string) {\n  const parsedSpec = parseBareModuleSpec(spec);\n\n  if (parsedSpec) {\n    return ctx.runInChildContext('resolveBareModule', fromUri, (ctx) =>\n      resolveBareModule(ctx, fromUri, parsedSpec)\n    );\n  }\n\n  const relativeUri = Uri.joinPath(\n    Uri.from({\n      ...fromUri,\n      path: dirname(fromUri.path),\n    }),\n    spec\n  );\n\n  return ctx.runInChildContext('resolveUri', relativeUri, (ctx) => resolve(ctx, relativeUri));\n}\n\nasync function resolveBareModule(ctx: ResolverContext, uri: Uri, parsedSpec: BareModuleSpec) {\n  let locatorName = parsedSpec.name;\n  let locatorSpec = parsedSpec.spec;\n  let locatorPath = parsedSpec.path;\n\n  if (!locatorSpec) {\n    const resolveRootReturn = ctx.getResolveRoot(uri);\n    const resolveRootResult = isThenable(resolveRootReturn)\n      ? await checkCancellation(resolveRootReturn, ctx.token)\n      : resolveRootReturn;\n\n    let nextUri = uri;\n    let maxIterations = 10;\n\n    while (Uri.isPrefixOf(resolveRootResult.uri, nextUri)) {\n      if (--maxIterations <= 0) {\n        throw new Error('Max iterations reached');\n      }\n\n      const parentPackageJsonReturn = ctx.readParentPackageJson(uri);\n      const parentPackageJsonResult = isThenable(parentPackageJsonReturn)\n        ? await checkCancellation(parentPackageJsonReturn, ctx.token)\n        : parentPackageJsonReturn;\n\n      if (!parentPackageJsonResult.found) {\n        throw new DependencyNotFoundError(parsedSpec.nameSpec, uri);\n      }\n      ctx.recordVisit(parentPackageJsonResult.uri, ResolverContext.VisitKind.File);\n\n      if (parentPackageJsonResult.packageJson.name === parsedSpec.name) {\n        // We found a parent directory that *IS* the module we're looking for\n        const directoryUri = Uri.ensureTrailingSlash(\n          Uri.joinPath(parentPackageJsonResult.uri, '../')\n        );\n        return ctx.runInChildContext('resolveAsDirectory', directoryUri, (ctx) =>\n          resolveAsDirectory(ctx, directoryUri, resolveRootResult.uri, ctx.settings)\n        );\n      }\n\n      const dependencies = {\n        ...(parentPackageJsonResult.packageJson.devDependencies || {}),\n        ...(parentPackageJsonResult.packageJson.peerDependencies || {}),\n        ...(parentPackageJsonResult.packageJson.dependencies || {}),\n      };\n\n      locatorSpec = dependencies[parsedSpec.name];\n\n      if (locatorSpec) {\n        break;\n      }\n\n      nextUri = Uri.joinPath(parentPackageJsonResult.uri, '..');\n\n      if (Uri.equals(nextUri, resolveRootResult.uri)) {\n        break;\n      }\n    }\n  }\n\n  if (!locatorSpec) {\n    const builtIn = NODE_CORE_SHIMS[parsedSpec.name];\n\n    if (builtIn) {\n      locatorName = builtIn.name;\n      locatorSpec = builtIn.spec;\n      locatorPath = builtIn.path;\n    }\n  }\n\n  if (!locatorSpec) {\n    throw new DependencyNotFoundError(parsedSpec.nameSpec, uri);\n  }\n\n  const bareModuleUriReturn = ctx.getUrlForBareModule(locatorName, locatorSpec, locatorPath);\n  const bareModuleUriResult = isThenable(bareModuleUriReturn)\n    ? await checkCancellation(bareModuleUriReturn, ctx.token)\n    : bareModuleUriReturn;\n\n  if (!bareModuleUriResult.found) {\n    throw new DependencyNotFoundError(parsedSpec.nameSpec, uri);\n  }\n\n  if (!bareModuleUriResult.uri) {\n    // TODO: Inject empty module\n    throw new EntryExcludedError(parsedSpec.nameSpec);\n  }\n\n  const resolveReturn = ctx.resolveUri(bareModuleUriResult.uri);\n  const resolveResult = isThenable(resolveReturn)\n    ? await checkCancellation(resolveReturn, ctx.token)\n    : resolveReturn;\n\n  return resolveResult;\n}\nexport namespace ResolverContext {\n  export interface Options {\n    cache: Map<string, Map<string, unknown>>;\n    cacheInvalidations: MapSet<string, InvalidationRecord>;\n    debug: boolean;\n    decoder: Decoder;\n    path: string[];\n    resolver: Resolver;\n    settings: Resolver.Settings;\n    strategy: ResolverStrategy;\n    token: CancellationToken;\n    visits: Visits;\n  }\n\n  export enum VisitKind {\n    Directory = 'Directory',\n    File = 'File',\n  }\n\n  export type Visit =\n    | {\n        type: VisitKind.Directory;\n        uri: Uri;\n      }\n    | {\n        type: VisitKind.File;\n        uri: Uri;\n      };\n}\n\nasync function resolveAsDirectory(\n  ctx: ResolverContext,\n  uri: Uri,\n  rootUri: Uri,\n  settings: Resolver.Settings\n): Promise<ResolveResult> {\n  ctx.recordVisit(uri, ResolverContext.VisitKind.Directory);\n\n  const listEntriesReturn = ctx.listEntries(uri);\n  const listEntriesResult = isThenable(listEntriesReturn)\n    ? await checkCancellation(listEntriesReturn, ctx.token)\n    : listEntriesReturn;\n\n  let mainPathname = 'index';\n\n  // Step 1: Look for a package.json with an main field\n  const packageJsonUri = Uri.joinPath(uri, './package.json');\n\n  ctx.recordVisit(packageJsonUri, ResolverContext.VisitKind.File);\n\n  const packageJsonEntry = listEntriesResult.entries.find(\n    (entry) =>\n      entry.type === ResolverStrategy.EntryKind.File && Uri.equals(packageJsonUri, entry.uri)\n  );\n\n  let packageJson: PartialPackageJson | null = null;\n\n  if (packageJsonEntry) {\n    const packageJsonContentReturn = ctx.readFileContent(packageJsonUri);\n    const packageJsonContentResult = isThenable(packageJsonContentReturn)\n      ? await checkCancellation(packageJsonContentReturn, ctx.token)\n      : packageJsonContentReturn;\n\n    packageJson = parseBufferAsPartialPackageJson(\n      ctx.decoder,\n      packageJsonContentResult.content,\n      uri.toString()\n    );\n\n    for (const packageMain of settings.packageMain) {\n      const pathname = packageJson[packageMain];\n      if (typeof pathname === 'string') {\n        mainPathname = pathname;\n        break;\n      }\n    }\n  }\n\n  const fileUri = Uri.joinPath(uri, mainPathname);\n\n  return ctx.runInChildContext('resolveAsFile', uri, (ctx) =>\n    resolveAsFile(ctx, fileUri, rootUri, settings, packageJson)\n  );\n}\n\nasync function resolveAsFile(\n  ctx: ResolverContext,\n  uri: Uri,\n  rootUri: Uri,\n  settings: Resolver.Settings,\n  packageJson: PartialPackageJson | null,\n  ignoreBrowserOverrides = false\n): Promise<ResolveResult> {\n  if (uri.path === '' || uri.path === '/') {\n    throw new TypeError(`Unable to resolve the root as a file: ${uri.toString()}`);\n  }\n\n  ctx.recordVisit(uri, ResolverContext.VisitKind.File);\n\n  const browserOverrides = new Map<string, Uri | false>();\n\n  if (packageJson === null) {\n    // The parent package.json is only interesting if we are going to look at the `browser`\n    // field and then consider browser mapping overrides in there.\n    const parentPackageJsonResult =\n      settings.packageMain.includes('browser') && !ignoreBrowserOverrides\n        ? await checkCancellation(\n            ctx.runInChildContext('readParentPackageJsonInternal', uri, (ctx) =>\n              readParentPackageJsonInternal(ctx, uri, rootUri, { uriIsCanonicalized: true })\n            ),\n            ctx.token\n          )\n        : undefined;\n    if (parentPackageJsonResult && parentPackageJsonResult.found) {\n      ctx.recordVisit(parentPackageJsonResult.uri, ResolverContext.VisitKind.File);\n\n      packageJson = parentPackageJsonResult.packageJson;\n\n      if (\n        parentPackageJsonResult.packageJson.browser &&\n        typeof parentPackageJsonResult.packageJson.browser === 'object'\n      ) {\n        const browserMap = parentPackageJsonResult.packageJson.browser;\n        const packageJsonDir = Uri.joinPath(parentPackageJsonResult.uri, '..');\n\n        for (const entry in browserMap) {\n          const impliedUri = Uri.joinPath(packageJsonDir, entry);\n          const targetSpec = browserMap[entry];\n          const target = targetSpec === false ? false : Uri.joinPath(packageJsonDir, targetSpec);\n\n          if (Uri.equals(impliedUri, uri)) {\n            if (target === false) {\n              return {\n                found: false,\n                uri: null,\n              };\n            }\n\n            // console.warn('REMAPPED %s to %s', url, target);\n\n            // We found an exact match so let's make sure we resolve the re-mapped file but\n            // also that we don't go through the browser overrides rodeo again.\n            return ctx.runInChildContext('resolveAsFile', target, (ctx) =>\n              resolveAsFile(ctx, target, rootUri, settings, packageJson, true)\n            );\n          }\n\n          browserOverrides.set(impliedUri.toString(), target);\n        }\n      }\n    }\n  }\n\n  const containingDirUri = Uri.ensureTrailingSlash(Uri.joinPath(uri, '..'));\n\n  const filename = basename(uri.path);\n  const entriesReturn = ctx.listEntries(containingDirUri);\n  const entriesResult = isThenable(entriesReturn)\n    ? await checkCancellation(entriesReturn, ctx.token)\n    : entriesReturn;\n  const entryDirectoryMap = new Map<string, ResolverStrategy.Entry>();\n  const entryFileMap = new Map<string, ResolverStrategy.Entry<ResolverStrategy.EntryKind.File>>();\n\n  for (const entry of entriesResult.entries) {\n    if (Uri.equals(entry.uri, uri) && entry.type == ResolverStrategy.EntryKind.File) {\n      // Found an exact match\n      return {\n        found: true,\n        rootUri,\n        uri,\n      };\n    }\n\n    if (entry.type === ResolverStrategy.EntryKind.Directory) {\n      const childFilename = Uri.getFirstPathSegmentAfterPrefix(entry.uri, containingDirUri);\n\n      entryDirectoryMap.set(childFilename, entry);\n    } else if (entry.type === ResolverStrategy.EntryKind.File) {\n      const childFilename = basename(entry.uri.path);\n\n      entryFileMap.set(\n        childFilename,\n        entry as ResolverStrategy.Entry<ResolverStrategy.EntryKind.File>\n      );\n    }\n  }\n\n  // Look for browser overrides\n  for (const ext of settings.extensions) {\n    const hrefWithExtensionUri = uri.with({ path: `${uri.path}${ext}` });\n    const hrefWithExtension = hrefWithExtensionUri.toString();\n    const mapping = browserOverrides.get(hrefWithExtension);\n\n    ctx.recordVisit(hrefWithExtensionUri, ResolverContext.VisitKind.File);\n\n    if (mapping === false) {\n      // console.warn('REMAPPED %s to undefined', url);\n      return {\n        found: true,\n        rootUri,\n        uri: null,\n      };\n    } else if (mapping) {\n      // console.warn('REMAPPED %s to %s', url, mapping);\n\n      return ctx.runInChildContext('resolveAsFile', mapping, (ctx) =>\n        resolveAsFile(ctx, mapping, rootUri, settings, packageJson, true)\n      );\n    }\n\n    const match = entryFileMap.get(`${filename}${ext}`);\n    if (match) {\n      if (match.type !== ResolverStrategy.EntryKind.File) {\n        continue;\n      }\n\n      return {\n        found: true,\n        rootUri,\n        uri: match.uri,\n      };\n    }\n  }\n\n  // First, attempt to find a matching file or directory\n  const match = entryDirectoryMap.get(filename);\n  if (match) {\n    if (match.type !== ResolverStrategy.EntryKind.Directory) {\n      throw new Error(`Invariant violation ${match.type} is unexpected`);\n    }\n\n    return ctx.runInChildContext('resolveAsDirectory', match.uri, (ctx) =>\n      resolveAsDirectory(ctx, Uri.ensureTrailingSlash(match.uri), rootUri, settings)\n    );\n  }\n\n  throw new EntryNotFoundError(uri);\n}\n\nasync function readParentPackageJson(ctx: ResolverContext, uri: Uri) {\n  const canonicalizationReturn = ctx.getCanonicalUrl(uri);\n  const resolveRootReturn = ctx.getResolveRoot(uri);\n  const bothResolved = all([canonicalizationReturn, resolveRootReturn], ctx.token);\n  const [canonicalizationResult, resolveRootResult] = isThenable(bothResolved)\n    ? await checkCancellation(bothResolved, ctx.token)\n    : bothResolved;\n  const readReturn = ctx.runInChildContext(\n    'readParentPackageJsonInternal',\n    canonicalizationResult.uri,\n    (ctx) =>\n      readParentPackageJsonInternal(ctx, canonicalizationResult.uri, resolveRootResult.uri, {\n        uriIsCanonicalized: true,\n      })\n  );\n  const readResult = isThenable(readReturn) ? await readReturn : readReturn;\n\n  if (readResult.found && readResult.visitedDirs) {\n    const visitedDirs = readResult.visitedDirs;\n    delete readResult.visitedDirs;\n\n    (readResult as any)[CACHE] = visitedDirs.map((uri) => [uri.toString(), { ...readResult, uri }]);\n  }\n\n  return readResult as ReadParentPackageJsonResultInternal;\n}\n\nasync function readParentPackageJsonInternal(\n  ctx: ResolverContext,\n  uri: Uri,\n  rootUri: Uri,\n  options: { uriIsCanonicalized: boolean }\n): Promise<ReadParentPackageJsonResultInternal> {\n  if (!options.uriIsCanonicalized) {\n    const canonicalizationReturn = ctx.getCanonicalUrl(uri);\n    const canonicalizationResult = isThenable(canonicalizationReturn)\n      ? await checkCancellation(canonicalizationReturn, ctx.token)\n      : canonicalizationReturn;\n\n    uri = canonicalizationResult.uri;\n  }\n\n  const hostRootHref = Uri.ensureTrailingSlash(rootUri);\n  const containingDirUrl = Uri.ensureTrailingSlash(Uri.joinPath(uri, '..'));\n  const visitedDirs = [] as Uri[];\n\n  const readPackageJsonOrRecurse = async (\n    ctx: ResolverContext,\n    dir: Uri\n  ): Promise<ReadParentPackageJsonResultInternal> => {\n    if (!Uri.isPrefixOf(hostRootHref, dir)) {\n      // Terminal condition for recursion\n      return {\n        found: false,\n        packageJson: null,\n        uri: null,\n      };\n    }\n\n    ctx.recordVisit(dir, ResolverContext.VisitKind.Directory);\n\n    const entriesReturn = ctx.listEntries(dir);\n    const entriesResult = isThenable(entriesReturn)\n      ? await checkCancellation(entriesReturn, ctx.token)\n      : entriesReturn;\n    const packageJsonUri = Uri.joinPath(dir, 'package.json');\n    const packageJsonEntry = entriesResult.entries.find(\n      (entry) =>\n        entry.type === ResolverStrategy.EntryKind.File && Uri.equals(entry.uri, packageJsonUri)\n    );\n\n    ctx.recordVisit(packageJsonUri, ResolverContext.VisitKind.File);\n\n    if (packageJsonEntry) {\n      // Found! Let's try to parse\n      try {\n        const parentPackageJsonContentReturn = ctx.readFileContent(packageJsonUri);\n        const parentPackageJsonContentResult = isThenable(parentPackageJsonContentReturn)\n          ? await checkCancellation(parentPackageJsonContentReturn, ctx.token)\n          : parentPackageJsonContentReturn;\n\n        const packageJson = parseBufferAsPackageJson(\n          ctx.decoder,\n          parentPackageJsonContentResult.content,\n          packageJsonUri.toString()\n        );\n\n        return { found: true, packageJson, uri: packageJsonUri, visitedDirs };\n      } catch (err) {\n        if (err instanceof CanceledError || (err && err.name === 'CanceledError')) {\n          throw err;\n        }\n\n        // TODO: Maybe issue some warning?\n      }\n    }\n\n    // Not found here, let's try one up\n    const parentDir = Uri.ensureTrailingSlash(Uri.joinPath(dir, '..'));\n\n    // Skip infinite recursion\n    if (Uri.equals(dir, parentDir) || Uri.isPrefixOf(dir, parentDir)) {\n      return {\n        found: false,\n        packageJson: null,\n        uri: null,\n      };\n    }\n\n    visitedDirs.push(dir);\n\n    return ctx.runInChildContext('readPackageJsonOrRecurse', parentDir, (ctx) =>\n      readPackageJsonOrRecurse(ctx, parentDir)\n    );\n  };\n\n  if (Uri.equals(uri, containingDirUrl) || Uri.isPrefixOf(uri, containingDirUrl)) {\n    return {\n      found: false,\n      packageJson: null,\n      uri: null,\n    };\n  }\n  return ctx.runInChildContext('readPackageJsonOrRecurse', containingDirUrl, (ctx) =>\n    readPackageJsonOrRecurse(ctx, containingDirUrl)\n  );\n}\n","import { CancellationTokenSource, PackageMainField, Uri } from '@velcro/common';\nimport { ResolverContext } from './context';\nimport type { ResolverStrategy } from './strategy';\n\nexport class Resolver {\n  private disposed = false;\n  readonly rootCtx: ResolverContext;\n  private readonly settings: Resolver.Settings;\n  private readonly strategy: ResolverStrategy;\n  private readonly tokenSource = new CancellationTokenSource();\n\n  constructor(strategy: ResolverStrategy, settings: Resolver.Settings) {\n    this.settings = settings;\n    this.strategy = strategy;\n    this.rootCtx = ResolverContext.create(\n      this,\n      this.strategy,\n      this.settings,\n      this.tokenSource.token,\n      { debug: settings.debug }\n    );\n  }\n\n  decode(buf: BufferSource | string): string {\n    if (typeof buf === 'string') {\n      return buf;\n    }\n\n    return this.rootCtx.decoder.decode(buf);\n  }\n\n  dispose() {\n    this.disposed = true;\n    return this.rootCtx.dispose();\n  }\n\n  getCanonicalUrl(uri: string | Uri) {\n    if (this.disposed) {\n      throw new Error('Resolver has been disposed');\n    }\n\n    return this.rootCtx.runInIsolatedContext('Resolver.getCanonicalUrl', uri, (ctx) =>\n      ctx.getCanonicalUrl(typeof uri === 'string' ? Uri.parse(uri) : uri)\n    );\n  }\n\n  getResolveRoot(uri: string | Uri) {\n    if (this.disposed) {\n      throw new Error('Resolver has been disposed');\n    }\n\n    return this.rootCtx.runInIsolatedContext('Resolver.getResolveRoot', uri, (ctx) =>\n      ctx.getResolveRoot(typeof uri === 'string' ? Uri.parse(uri) : uri)\n    );\n  }\n\n  getSettings(uri: string | Uri) {\n    if (this.disposed) {\n      throw new Error('Resolver has been disposed');\n    }\n\n    return this.rootCtx.runInIsolatedContext('Resolver.getSettings', uri, (ctx) =>\n      ctx.getSettings(typeof uri === 'string' ? Uri.parse(uri) : uri)\n    );\n  }\n\n  getUrlForBareModule(name: string, spec: string, path: string) {\n    if (this.disposed) {\n      throw new Error('Resolver has been disposed');\n    }\n\n    return this.rootCtx.runInIsolatedContext(\n      'Resolver.getUrlForBareModule',\n      `${name}|${spec}|${path}`,\n      (ctx) => ctx.getUrlForBareModule(name, spec, path)\n    );\n  }\n\n  invalidate(uri: string | Uri) {\n    if (this.disposed) {\n      throw new Error('Resolver has been disposed');\n    }\n\n    return this.rootCtx.runInIsolatedContext('Resolver.invalidate', uri, (ctx) =>\n      ctx.invalidate(typeof uri === 'string' ? Uri.parse(uri) : uri)\n    );\n  }\n\n  listEntries(uri: Uri) {\n    if (this.disposed) {\n      throw new Error('Resolver has been disposed');\n    }\n\n    return this.rootCtx.runInIsolatedContext('Resolver.listEntries', uri, (ctx) =>\n      ctx.listEntries(typeof uri === 'string' ? Uri.parse(uri) : uri)\n    );\n  }\n\n  readFileContent(uri: Uri) {\n    if (this.disposed) {\n      throw new Error('Resolver has been disposed');\n    }\n\n    return this.rootCtx.runInIsolatedContext('Resolver.readFileContent', uri, (ctx) =>\n      ctx.readFileContent(typeof uri === 'string' ? Uri.parse(uri) : uri)\n    );\n  }\n\n  readParentPackageJson(uri: Uri) {\n    if (this.disposed) {\n      throw new Error('Resolver has been disposed');\n    }\n\n    return this.rootCtx.runInIsolatedContext('Resolver.readParentPackageJson', uri, (ctx) =>\n      ctx.readParentPackageJson(typeof uri === 'string' ? Uri.parse(uri) : uri)\n    );\n  }\n\n  resolve(spec: Uri): ReturnType<ResolverContext['resolve']>;\n  resolve(spec: string, fromUri: Uri): ReturnType<ResolverContext['resolve']>;\n  resolve(spec: string | Uri, fromUri?: Uri): ReturnType<ResolverContext['resolve']> {\n    if (this.disposed) {\n      throw new Error('Resolver has been disposed');\n    }\n\n    if (Uri.isUri(spec)) {\n      return this.rootCtx.runInIsolatedContext('Resolver.resolveUri', spec, (ctx) =>\n        ctx.resolveUri(spec)\n      );\n    }\n\n    if (!fromUri) {\n      throw new Error(\n        'When calling Resolver.resolve with a string spec, a second \"fromUri\" argument is required'\n      );\n    }\n\n    return this.rootCtx.runInIsolatedContext(\n      'Resolver.resolve',\n      `${fromUri ? fromUri.toString() : ''}|${spec}`,\n      (ctx) => ctx.resolve(spec, fromUri)\n    );\n  }\n}\n\nexport namespace Resolver {\n  export interface Settings {\n    debug?: boolean;\n    extensions: string[];\n    packageMain: PackageMainField[];\n  }\n}\n","import defineProperty from \"./defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nexport default function _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}","import arrayWithoutHoles from \"./arrayWithoutHoles\";\nimport iterableToArray from \"./iterableToArray\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray\";\nimport nonIterableSpread from \"./nonIterableSpread\";\nexport default function _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();\n}","import arrayLikeToArray from \"./arrayLikeToArray\";\nexport default function _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return arrayLikeToArray(arr);\n}","export default function _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}","export default function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","\"use strict\";\nvar __spreadArrays = (this && this.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Checker = exports.createCheckers = void 0;\nvar types_1 = require(\"./types\");\nvar util_1 = require(\"./util\");\n/**\n * Export functions used to define interfaces.\n */\nvar types_2 = require(\"./types\");\nObject.defineProperty(exports, \"TArray\", { enumerable: true, get: function () { return types_2.TArray; } });\nObject.defineProperty(exports, \"TEnumType\", { enumerable: true, get: function () { return types_2.TEnumType; } });\nObject.defineProperty(exports, \"TEnumLiteral\", { enumerable: true, get: function () { return types_2.TEnumLiteral; } });\nObject.defineProperty(exports, \"TFunc\", { enumerable: true, get: function () { return types_2.TFunc; } });\nObject.defineProperty(exports, \"TIface\", { enumerable: true, get: function () { return types_2.TIface; } });\nObject.defineProperty(exports, \"TLiteral\", { enumerable: true, get: function () { return types_2.TLiteral; } });\nObject.defineProperty(exports, \"TName\", { enumerable: true, get: function () { return types_2.TName; } });\nObject.defineProperty(exports, \"TOptional\", { enumerable: true, get: function () { return types_2.TOptional; } });\nObject.defineProperty(exports, \"TParam\", { enumerable: true, get: function () { return types_2.TParam; } });\nObject.defineProperty(exports, \"TParamList\", { enumerable: true, get: function () { return types_2.TParamList; } });\nObject.defineProperty(exports, \"TProp\", { enumerable: true, get: function () { return types_2.TProp; } });\nObject.defineProperty(exports, \"TTuple\", { enumerable: true, get: function () { return types_2.TTuple; } });\nObject.defineProperty(exports, \"TType\", { enumerable: true, get: function () { return types_2.TType; } });\nObject.defineProperty(exports, \"TUnion\", { enumerable: true, get: function () { return types_2.TUnion; } });\nObject.defineProperty(exports, \"TIntersection\", { enumerable: true, get: function () { return types_2.TIntersection; } });\nObject.defineProperty(exports, \"array\", { enumerable: true, get: function () { return types_2.array; } });\nObject.defineProperty(exports, \"enumlit\", { enumerable: true, get: function () { return types_2.enumlit; } });\nObject.defineProperty(exports, \"enumtype\", { enumerable: true, get: function () { return types_2.enumtype; } });\nObject.defineProperty(exports, \"func\", { enumerable: true, get: function () { return types_2.func; } });\nObject.defineProperty(exports, \"iface\", { enumerable: true, get: function () { return types_2.iface; } });\nObject.defineProperty(exports, \"lit\", { enumerable: true, get: function () { return types_2.lit; } });\nObject.defineProperty(exports, \"name\", { enumerable: true, get: function () { return types_2.name; } });\nObject.defineProperty(exports, \"opt\", { enumerable: true, get: function () { return types_2.opt; } });\nObject.defineProperty(exports, \"param\", { enumerable: true, get: function () { return types_2.param; } });\nObject.defineProperty(exports, \"tuple\", { enumerable: true, get: function () { return types_2.tuple; } });\nObject.defineProperty(exports, \"union\", { enumerable: true, get: function () { return types_2.union; } });\nObject.defineProperty(exports, \"intersection\", { enumerable: true, get: function () { return types_2.intersection; } });\nObject.defineProperty(exports, \"BasicType\", { enumerable: true, get: function () { return types_2.BasicType; } });\nvar util_2 = require(\"./util\");\nObject.defineProperty(exports, \"VError\", { enumerable: true, get: function () { return util_2.VError; } });\n/**\n * Takes one of more type suites (e.g. a module generated by `ts-interface-builder`), and combines\n * them into a suite of interface checkers. If a type is used by name, that name should be present\n * among the passed-in type suites.\n *\n * The returned object maps type names to Checker objects.\n */\nfunction createCheckers() {\n    var typeSuite = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        typeSuite[_i] = arguments[_i];\n    }\n    var fullSuite = Object.assign.apply(Object, __spreadArrays([{}, types_1.basicTypes], typeSuite));\n    var checkers = {};\n    for (var _a = 0, typeSuite_1 = typeSuite; _a < typeSuite_1.length; _a++) {\n        var suite_1 = typeSuite_1[_a];\n        for (var _b = 0, _c = Object.keys(suite_1); _b < _c.length; _b++) {\n            var name = _c[_b];\n            checkers[name] = new Checker(fullSuite, suite_1[name]);\n        }\n    }\n    return checkers;\n}\nexports.createCheckers = createCheckers;\n/**\n * Checker implements validation of objects, and also includes accessors to validate method calls.\n * Checkers should be created using `createCheckers()`.\n */\nvar Checker = /** @class */ (function () {\n    // Create checkers by using `createCheckers()` function.\n    function Checker(suite, ttype, _path) {\n        if (_path === void 0) { _path = 'value'; }\n        this.suite = suite;\n        this.ttype = ttype;\n        this._path = _path;\n        this.props = new Map();\n        if (ttype instanceof types_1.TIface) {\n            for (var _i = 0, _a = ttype.props; _i < _a.length; _i++) {\n                var p = _a[_i];\n                this.props.set(p.name, p.ttype);\n            }\n        }\n        this.checkerPlain = this.ttype.getChecker(suite, false);\n        this.checkerStrict = this.ttype.getChecker(suite, true);\n    }\n    /**\n     * Set the path to report in errors, instead of the default \"value\". (E.g. if the Checker is for\n     * a \"person\" interface, set path to \"person\" to report e.g. \"person.name is not a string\".)\n     */\n    Checker.prototype.setReportedPath = function (path) {\n        this._path = path;\n    };\n    /**\n     * Check that the given value satisfies this checker's type, or throw Error.\n     */\n    Checker.prototype.check = function (value) { return this._doCheck(this.checkerPlain, value); };\n    /**\n     * A fast check for whether or not the given value satisfies this Checker's type. This returns\n     * true or false, does not produce an error message, and is fast both on success and on failure.\n     */\n    Checker.prototype.test = function (value) {\n        return this.checkerPlain(value, new util_1.NoopContext());\n    };\n    /**\n     * Returns an error object describing the errors if the given value does not satisfy this\n     * Checker's type, or null if it does.\n     */\n    Checker.prototype.validate = function (value) {\n        return this._doValidate(this.checkerPlain, value);\n    };\n    /**\n     * Check that the given value satisfies this checker's type strictly. This checks that objects\n     * and tuples have no extra members. Note that this prevents backward compatibility, so usually\n     * a plain check() is more appropriate.\n     */\n    Checker.prototype.strictCheck = function (value) { return this._doCheck(this.checkerStrict, value); };\n    /**\n     * A fast strict check for whether or not the given value satisfies this Checker's type. Returns\n     * true or false, does not produce an error message, and is fast both on success and on failure.\n     */\n    Checker.prototype.strictTest = function (value) {\n        return this.checkerStrict(value, new util_1.NoopContext());\n    };\n    /**\n     * Returns an error object describing the errors if the given value does not satisfy this\n     * Checker's type strictly, or null if it does.\n     */\n    Checker.prototype.strictValidate = function (value) {\n        return this._doValidate(this.checkerStrict, value);\n    };\n    /**\n     * If this checker is for an interface, returns a Checker for the type required for the given\n     * property of this interface.\n     */\n    Checker.prototype.getProp = function (prop) {\n        var ttype = this.props.get(prop);\n        if (!ttype) {\n            throw new Error(\"Type has no property \" + prop);\n        }\n        return new Checker(this.suite, ttype, this._path + \".\" + prop);\n    };\n    /**\n     * If this checker is for an interface, returns a Checker for the argument-list required to call\n     * the given method of this interface. E.g. if this Checker is for the interface:\n     *    interface Foo {\n     *      find(s: string, pos?: number): number;\n     *    }\n     * Then methodArgs(\"find\").check(...) will succeed for [\"foo\"] and [\"foo\", 3], but not for [17].\n     */\n    Checker.prototype.methodArgs = function (methodName) {\n        var tfunc = this._getMethod(methodName);\n        return new Checker(this.suite, tfunc.paramList);\n    };\n    /**\n     * If this checker is for an interface, returns a Checker for the return value of the given\n     * method of this interface.\n     */\n    Checker.prototype.methodResult = function (methodName) {\n        var tfunc = this._getMethod(methodName);\n        return new Checker(this.suite, tfunc.result);\n    };\n    /**\n     * If this checker is for a function, returns a Checker for its argument-list.\n     */\n    Checker.prototype.getArgs = function () {\n        if (!(this.ttype instanceof types_1.TFunc)) {\n            throw new Error(\"getArgs() applied to non-function\");\n        }\n        return new Checker(this.suite, this.ttype.paramList);\n    };\n    /**\n     * If this checker is for a function, returns a Checker for its result.\n     */\n    Checker.prototype.getResult = function () {\n        if (!(this.ttype instanceof types_1.TFunc)) {\n            throw new Error(\"getResult() applied to non-function\");\n        }\n        return new Checker(this.suite, this.ttype.result);\n    };\n    /**\n     * Return the type for which this is a checker.\n     */\n    Checker.prototype.getType = function () {\n        return this.ttype;\n    };\n    /**\n     * Actual implementation of check() and strictCheck().\n     */\n    Checker.prototype._doCheck = function (checkerFunc, value) {\n        var noopCtx = new util_1.NoopContext();\n        if (!checkerFunc(value, noopCtx)) {\n            var detailCtx = new util_1.DetailContext();\n            checkerFunc(value, detailCtx);\n            throw detailCtx.getError(this._path);\n        }\n    };\n    Checker.prototype._doValidate = function (checkerFunc, value) {\n        var noopCtx = new util_1.NoopContext();\n        if (checkerFunc(value, noopCtx)) {\n            return null;\n        }\n        var detailCtx = new util_1.DetailContext();\n        checkerFunc(value, detailCtx);\n        return detailCtx.getErrorDetail(this._path);\n    };\n    Checker.prototype._getMethod = function (methodName) {\n        var ttype = this.props.get(methodName);\n        if (!ttype) {\n            throw new Error(\"Type has no property \" + methodName);\n        }\n        if (!(ttype instanceof types_1.TFunc)) {\n            throw new Error(\"Property \" + methodName + \" is not a method\");\n        }\n        return ttype;\n    };\n    return Checker;\n}());\nexports.Checker = Checker;\n","const debug = require('../internal/debug')\nconst { MAX_LENGTH, MAX_SAFE_INTEGER } = require('../internal/constants')\nconst { re, t } = require('../internal/re')\n\nconst { compareIdentifiers } = require('../internal/identifiers')\nclass SemVer {\n  constructor (version, options) {\n    if (!options || typeof options !== 'object') {\n      options = {\n        loose: !!options,\n        includePrerelease: false\n      }\n    }\n    if (version instanceof SemVer) {\n      if (version.loose === !!options.loose &&\n          version.includePrerelease === !!options.includePrerelease) {\n        return version\n      } else {\n        version = version.version\n      }\n    } else if (typeof version !== 'string') {\n      throw new TypeError(`Invalid Version: ${version}`)\n    }\n\n    if (version.length > MAX_LENGTH) {\n      throw new TypeError(\n        `version is longer than ${MAX_LENGTH} characters`\n      )\n    }\n\n    debug('SemVer', version, options)\n    this.options = options\n    this.loose = !!options.loose\n    // this isn't actually relevant for versions, but keep it so that we\n    // don't run into trouble passing this.options around.\n    this.includePrerelease = !!options.includePrerelease\n\n    const m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL])\n\n    if (!m) {\n      throw new TypeError(`Invalid Version: ${version}`)\n    }\n\n    this.raw = version\n\n    // these are actually numbers\n    this.major = +m[1]\n    this.minor = +m[2]\n    this.patch = +m[3]\n\n    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {\n      throw new TypeError('Invalid major version')\n    }\n\n    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {\n      throw new TypeError('Invalid minor version')\n    }\n\n    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {\n      throw new TypeError('Invalid patch version')\n    }\n\n    // numberify any prerelease numeric ids\n    if (!m[4]) {\n      this.prerelease = []\n    } else {\n      this.prerelease = m[4].split('.').map((id) => {\n        if (/^[0-9]+$/.test(id)) {\n          const num = +id\n          if (num >= 0 && num < MAX_SAFE_INTEGER) {\n            return num\n          }\n        }\n        return id\n      })\n    }\n\n    this.build = m[5] ? m[5].split('.') : []\n    this.format()\n  }\n\n  format () {\n    this.version = `${this.major}.${this.minor}.${this.patch}`\n    if (this.prerelease.length) {\n      this.version += `-${this.prerelease.join('.')}`\n    }\n    return this.version\n  }\n\n  toString () {\n    return this.version\n  }\n\n  compare (other) {\n    debug('SemVer.compare', this.version, this.options, other)\n    if (!(other instanceof SemVer)) {\n      if (typeof other === 'string' && other === this.version) {\n        return 0\n      }\n      other = new SemVer(other, this.options)\n    }\n\n    if (other.version === this.version) {\n      return 0\n    }\n\n    return this.compareMain(other) || this.comparePre(other)\n  }\n\n  compareMain (other) {\n    if (!(other instanceof SemVer)) {\n      other = new SemVer(other, this.options)\n    }\n\n    return (\n      compareIdentifiers(this.major, other.major) ||\n      compareIdentifiers(this.minor, other.minor) ||\n      compareIdentifiers(this.patch, other.patch)\n    )\n  }\n\n  comparePre (other) {\n    if (!(other instanceof SemVer)) {\n      other = new SemVer(other, this.options)\n    }\n\n    // NOT having a prerelease is > having one\n    if (this.prerelease.length && !other.prerelease.length) {\n      return -1\n    } else if (!this.prerelease.length && other.prerelease.length) {\n      return 1\n    } else if (!this.prerelease.length && !other.prerelease.length) {\n      return 0\n    }\n\n    let i = 0\n    do {\n      const a = this.prerelease[i]\n      const b = other.prerelease[i]\n      debug('prerelease compare', i, a, b)\n      if (a === undefined && b === undefined) {\n        return 0\n      } else if (b === undefined) {\n        return 1\n      } else if (a === undefined) {\n        return -1\n      } else if (a === b) {\n        continue\n      } else {\n        return compareIdentifiers(a, b)\n      }\n    } while (++i)\n  }\n\n  compareBuild (other) {\n    if (!(other instanceof SemVer)) {\n      other = new SemVer(other, this.options)\n    }\n\n    let i = 0\n    do {\n      const a = this.build[i]\n      const b = other.build[i]\n      debug('prerelease compare', i, a, b)\n      if (a === undefined && b === undefined) {\n        return 0\n      } else if (b === undefined) {\n        return 1\n      } else if (a === undefined) {\n        return -1\n      } else if (a === b) {\n        continue\n      } else {\n        return compareIdentifiers(a, b)\n      }\n    } while (++i)\n  }\n\n  // preminor will bump the version up to the next minor release, and immediately\n  // down to pre-release. premajor and prepatch work the same way.\n  inc (release, identifier) {\n    switch (release) {\n      case 'premajor':\n        this.prerelease.length = 0\n        this.patch = 0\n        this.minor = 0\n        this.major++\n        this.inc('pre', identifier)\n        break\n      case 'preminor':\n        this.prerelease.length = 0\n        this.patch = 0\n        this.minor++\n        this.inc('pre', identifier)\n        break\n      case 'prepatch':\n        // If this is already a prerelease, it will bump to the next version\n        // drop any prereleases that might already exist, since they are not\n        // relevant at this point.\n        this.prerelease.length = 0\n        this.inc('patch', identifier)\n        this.inc('pre', identifier)\n        break\n      // If the input is a non-prerelease version, this acts the same as\n      // prepatch.\n      case 'prerelease':\n        if (this.prerelease.length === 0) {\n          this.inc('patch', identifier)\n        }\n        this.inc('pre', identifier)\n        break\n\n      case 'major':\n        // If this is a pre-major version, bump up to the same major version.\n        // Otherwise increment major.\n        // 1.0.0-5 bumps to 1.0.0\n        // 1.1.0 bumps to 2.0.0\n        if (\n          this.minor !== 0 ||\n          this.patch !== 0 ||\n          this.prerelease.length === 0\n        ) {\n          this.major++\n        }\n        this.minor = 0\n        this.patch = 0\n        this.prerelease = []\n        break\n      case 'minor':\n        // If this is a pre-minor version, bump up to the same minor version.\n        // Otherwise increment minor.\n        // 1.2.0-5 bumps to 1.2.0\n        // 1.2.1 bumps to 1.3.0\n        if (this.patch !== 0 || this.prerelease.length === 0) {\n          this.minor++\n        }\n        this.patch = 0\n        this.prerelease = []\n        break\n      case 'patch':\n        // If this is not a pre-release version, it will increment the patch.\n        // If it is a pre-release it will bump up to the same patch version.\n        // 1.2.0-5 patches to 1.2.0\n        // 1.2.0 patches to 1.2.1\n        if (this.prerelease.length === 0) {\n          this.patch++\n        }\n        this.prerelease = []\n        break\n      // This probably shouldn't be used publicly.\n      // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.\n      case 'pre':\n        if (this.prerelease.length === 0) {\n          this.prerelease = [0]\n        } else {\n          let i = this.prerelease.length\n          while (--i >= 0) {\n            if (typeof this.prerelease[i] === 'number') {\n              this.prerelease[i]++\n              i = -2\n            }\n          }\n          if (i === -1) {\n            // didn't increment anything\n            this.prerelease.push(0)\n          }\n        }\n        if (identifier) {\n          // 1.2.0-beta.1 bumps to 1.2.0-beta.2,\n          // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0\n          if (this.prerelease[0] === identifier) {\n            if (isNaN(this.prerelease[1])) {\n              this.prerelease = [identifier, 0]\n            }\n          } else {\n            this.prerelease = [identifier, 0]\n          }\n        }\n        break\n\n      default:\n        throw new Error(`invalid increment argument: ${release}`)\n    }\n    this.format()\n    this.raw = this.version\n    return this\n  }\n}\n\nmodule.exports = SemVer\n","export default function _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}","const SemVer = require('../classes/semver')\nconst compare = (a, b, loose) =>\n  new SemVer(a, loose).compare(new SemVer(b, loose))\n\nmodule.exports = compare\n","// hoisted class for cyclic dependency\nclass Range {\n  constructor (range, options) {\n    if (!options || typeof options !== 'object') {\n      options = {\n        loose: !!options,\n        includePrerelease: false\n      }\n    }\n\n    if (range instanceof Range) {\n      if (\n        range.loose === !!options.loose &&\n        range.includePrerelease === !!options.includePrerelease\n      ) {\n        return range\n      } else {\n        return new Range(range.raw, options)\n      }\n    }\n\n    if (range instanceof Comparator) {\n      // just put it in the set and return\n      this.raw = range.value\n      this.set = [[range]]\n      this.format()\n      return this\n    }\n\n    this.options = options\n    this.loose = !!options.loose\n    this.includePrerelease = !!options.includePrerelease\n\n    // First, split based on boolean or ||\n    this.raw = range\n    this.set = range\n      .split(/\\s*\\|\\|\\s*/)\n      // map the range to a 2d array of comparators\n      .map(range => this.parseRange(range.trim()))\n      // throw out any comparator lists that are empty\n      // this generally means that it was not a valid range, which is allowed\n      // in loose mode, but will still throw if the WHOLE range is invalid.\n      .filter(c => c.length)\n\n    if (!this.set.length) {\n      throw new TypeError(`Invalid SemVer Range: ${range}`)\n    }\n\n    this.format()\n  }\n\n  format () {\n    this.range = this.set\n      .map((comps) => {\n        return comps.join(' ').trim()\n      })\n      .join('||')\n      .trim()\n    return this.range\n  }\n\n  toString () {\n    return this.range\n  }\n\n  parseRange (range) {\n    const loose = this.options.loose\n    range = range.trim()\n    // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`\n    const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE]\n    range = range.replace(hr, hyphenReplace(this.options.includePrerelease))\n    debug('hyphen replace', range)\n    // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`\n    range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace)\n    debug('comparator trim', range, re[t.COMPARATORTRIM])\n\n    // `~ 1.2.3` => `~1.2.3`\n    range = range.replace(re[t.TILDETRIM], tildeTrimReplace)\n\n    // `^ 1.2.3` => `^1.2.3`\n    range = range.replace(re[t.CARETTRIM], caretTrimReplace)\n\n    // normalize spaces\n    range = range.split(/\\s+/).join(' ')\n\n    // At this point, the range is completely trimmed and\n    // ready to be split into comparators.\n\n    const compRe = loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR]\n    return range\n      .split(' ')\n      .map(comp => parseComparator(comp, this.options))\n      .join(' ')\n      .split(/\\s+/)\n      .map(comp => replaceGTE0(comp, this.options))\n      // in loose mode, throw out any that are not valid comparators\n      .filter(this.options.loose ? comp => !!comp.match(compRe) : () => true)\n      .map(comp => new Comparator(comp, this.options))\n  }\n\n  intersects (range, options) {\n    if (!(range instanceof Range)) {\n      throw new TypeError('a Range is required')\n    }\n\n    return this.set.some((thisComparators) => {\n      return (\n        isSatisfiable(thisComparators, options) &&\n        range.set.some((rangeComparators) => {\n          return (\n            isSatisfiable(rangeComparators, options) &&\n            thisComparators.every((thisComparator) => {\n              return rangeComparators.every((rangeComparator) => {\n                return thisComparator.intersects(rangeComparator, options)\n              })\n            })\n          )\n        })\n      )\n    })\n  }\n\n  // if ANY of the sets match ALL of its comparators, then pass\n  test (version) {\n    if (!version) {\n      return false\n    }\n\n    if (typeof version === 'string') {\n      try {\n        version = new SemVer(version, this.options)\n      } catch (er) {\n        return false\n      }\n    }\n\n    for (let i = 0; i < this.set.length; i++) {\n      if (testSet(this.set[i], version, this.options)) {\n        return true\n      }\n    }\n    return false\n  }\n}\nmodule.exports = Range\n\nconst Comparator = require('./comparator')\nconst debug = require('../internal/debug')\nconst SemVer = require('./semver')\nconst {\n  re,\n  t,\n  comparatorTrimReplace,\n  tildeTrimReplace,\n  caretTrimReplace\n} = require('../internal/re')\n\n// take a set of comparators and determine whether there\n// exists a version which can satisfy it\nconst isSatisfiable = (comparators, options) => {\n  let result = true\n  const remainingComparators = comparators.slice()\n  let testComparator = remainingComparators.pop()\n\n  while (result && remainingComparators.length) {\n    result = remainingComparators.every((otherComparator) => {\n      return testComparator.intersects(otherComparator, options)\n    })\n\n    testComparator = remainingComparators.pop()\n  }\n\n  return result\n}\n\n// comprised of xranges, tildes, stars, and gtlt's at this point.\n// already replaced the hyphen ranges\n// turn into a set of JUST comparators.\nconst parseComparator = (comp, options) => {\n  debug('comp', comp, options)\n  comp = replaceCarets(comp, options)\n  debug('caret', comp)\n  comp = replaceTildes(comp, options)\n  debug('tildes', comp)\n  comp = replaceXRanges(comp, options)\n  debug('xrange', comp)\n  comp = replaceStars(comp, options)\n  debug('stars', comp)\n  return comp\n}\n\nconst isX = id => !id || id.toLowerCase() === 'x' || id === '*'\n\n// ~, ~> --> * (any, kinda silly)\n// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0-0\n// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0-0\n// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0-0\n// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0-0\n// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0-0\nconst replaceTildes = (comp, options) =>\n  comp.trim().split(/\\s+/).map((comp) => {\n    return replaceTilde(comp, options)\n  }).join(' ')\n\nconst replaceTilde = (comp, options) => {\n  const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE]\n  return comp.replace(r, (_, M, m, p, pr) => {\n    debug('tilde', comp, _, M, m, p, pr)\n    let ret\n\n    if (isX(M)) {\n      ret = ''\n    } else if (isX(m)) {\n      ret = `>=${M}.0.0 <${+M + 1}.0.0-0`\n    } else if (isX(p)) {\n      // ~1.2 == >=1.2.0 <1.3.0-0\n      ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`\n    } else if (pr) {\n      debug('replaceTilde pr', pr)\n      ret = `>=${M}.${m}.${p}-${pr\n      } <${M}.${+m + 1}.0-0`\n    } else {\n      // ~1.2.3 == >=1.2.3 <1.3.0-0\n      ret = `>=${M}.${m}.${p\n      } <${M}.${+m + 1}.0-0`\n    }\n\n    debug('tilde return', ret)\n    return ret\n  })\n}\n\n// ^ --> * (any, kinda silly)\n// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0-0\n// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0-0\n// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0-0\n// ^1.2.3 --> >=1.2.3 <2.0.0-0\n// ^1.2.0 --> >=1.2.0 <2.0.0-0\nconst replaceCarets = (comp, options) =>\n  comp.trim().split(/\\s+/).map((comp) => {\n    return replaceCaret(comp, options)\n  }).join(' ')\n\nconst replaceCaret = (comp, options) => {\n  debug('caret', comp, options)\n  const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET]\n  const z = options.includePrerelease ? '-0' : ''\n  return comp.replace(r, (_, M, m, p, pr) => {\n    debug('caret', comp, _, M, m, p, pr)\n    let ret\n\n    if (isX(M)) {\n      ret = ''\n    } else if (isX(m)) {\n      ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`\n    } else if (isX(p)) {\n      if (M === '0') {\n        ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`\n      } else {\n        ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`\n      }\n    } else if (pr) {\n      debug('replaceCaret pr', pr)\n      if (M === '0') {\n        if (m === '0') {\n          ret = `>=${M}.${m}.${p}-${pr\n          } <${M}.${m}.${+p + 1}-0`\n        } else {\n          ret = `>=${M}.${m}.${p}-${pr\n          } <${M}.${+m + 1}.0-0`\n        }\n      } else {\n        ret = `>=${M}.${m}.${p}-${pr\n        } <${+M + 1}.0.0-0`\n      }\n    } else {\n      debug('no pr')\n      if (M === '0') {\n        if (m === '0') {\n          ret = `>=${M}.${m}.${p\n          }${z} <${M}.${m}.${+p + 1}-0`\n        } else {\n          ret = `>=${M}.${m}.${p\n          }${z} <${M}.${+m + 1}.0-0`\n        }\n      } else {\n        ret = `>=${M}.${m}.${p\n        } <${+M + 1}.0.0-0`\n      }\n    }\n\n    debug('caret return', ret)\n    return ret\n  })\n}\n\nconst replaceXRanges = (comp, options) => {\n  debug('replaceXRanges', comp, options)\n  return comp.split(/\\s+/).map((comp) => {\n    return replaceXRange(comp, options)\n  }).join(' ')\n}\n\nconst replaceXRange = (comp, options) => {\n  comp = comp.trim()\n  const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE]\n  return comp.replace(r, (ret, gtlt, M, m, p, pr) => {\n    debug('xRange', comp, ret, gtlt, M, m, p, pr)\n    const xM = isX(M)\n    const xm = xM || isX(m)\n    const xp = xm || isX(p)\n    const anyX = xp\n\n    if (gtlt === '=' && anyX) {\n      gtlt = ''\n    }\n\n    // if we're including prereleases in the match, then we need\n    // to fix this to -0, the lowest possible prerelease value\n    pr = options.includePrerelease ? '-0' : ''\n\n    if (xM) {\n      if (gtlt === '>' || gtlt === '<') {\n        // nothing is allowed\n        ret = '<0.0.0-0'\n      } else {\n        // nothing is forbidden\n        ret = '*'\n      }\n    } else if (gtlt && anyX) {\n      // we know patch is an x, because we have any x at all.\n      // replace X with 0\n      if (xm) {\n        m = 0\n      }\n      p = 0\n\n      if (gtlt === '>') {\n        // >1 => >=2.0.0\n        // >1.2 => >=1.3.0\n        gtlt = '>='\n        if (xm) {\n          M = +M + 1\n          m = 0\n          p = 0\n        } else {\n          m = +m + 1\n          p = 0\n        }\n      } else if (gtlt === '<=') {\n        // <=0.7.x is actually <0.8.0, since any 0.7.x should\n        // pass.  Similarly, <=7.x is actually <8.0.0, etc.\n        gtlt = '<'\n        if (xm) {\n          M = +M + 1\n        } else {\n          m = +m + 1\n        }\n      }\n\n      if (gtlt === '<')\n        pr = '-0'\n\n      ret = `${gtlt + M}.${m}.${p}${pr}`\n    } else if (xm) {\n      ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`\n    } else if (xp) {\n      ret = `>=${M}.${m}.0${pr\n      } <${M}.${+m + 1}.0-0`\n    }\n\n    debug('xRange return', ret)\n\n    return ret\n  })\n}\n\n// Because * is AND-ed with everything else in the comparator,\n// and '' means \"any version\", just remove the *s entirely.\nconst replaceStars = (comp, options) => {\n  debug('replaceStars', comp, options)\n  // Looseness is ignored here.  star is always as loose as it gets!\n  return comp.trim().replace(re[t.STAR], '')\n}\n\nconst replaceGTE0 = (comp, options) => {\n  debug('replaceGTE0', comp, options)\n  return comp.trim()\n    .replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], '')\n}\n\n// This function is passed to string.replace(re[t.HYPHENRANGE])\n// M, m, patch, prerelease, build\n// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5\n// 1.2.3 - 3.4 => >=1.2.0 <3.5.0-0 Any 3.4.x will do\n// 1.2 - 3.4 => >=1.2.0 <3.5.0-0\nconst hyphenReplace = incPr => ($0,\n  from, fM, fm, fp, fpr, fb,\n  to, tM, tm, tp, tpr, tb) => {\n  if (isX(fM)) {\n    from = ''\n  } else if (isX(fm)) {\n    from = `>=${fM}.0.0${incPr ? '-0' : ''}`\n  } else if (isX(fp)) {\n    from = `>=${fM}.${fm}.0${incPr ? '-0' : ''}`\n  } else if (fpr) {\n    from = `>=${from}`\n  } else {\n    from = `>=${from}${incPr ? '-0' : ''}`\n  }\n\n  if (isX(tM)) {\n    to = ''\n  } else if (isX(tm)) {\n    to = `<${+tM + 1}.0.0-0`\n  } else if (isX(tp)) {\n    to = `<${tM}.${+tm + 1}.0-0`\n  } else if (tpr) {\n    to = `<=${tM}.${tm}.${tp}-${tpr}`\n  } else if (incPr) {\n    to = `<${tM}.${tm}.${+tp + 1}-0`\n  } else {\n    to = `<=${to}`\n  }\n\n  return (`${from} ${to}`).trim()\n}\n\nconst testSet = (set, version, options) => {\n  for (let i = 0; i < set.length; i++) {\n    if (!set[i].test(version)) {\n      return false\n    }\n  }\n\n  if (version.prerelease.length && !options.includePrerelease) {\n    // Find the set of versions that are allowed to have prereleases\n    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0\n    // That should allow `1.2.3-pr.2` to pass.\n    // However, `1.2.4-alpha.notready` should NOT be allowed,\n    // even though it's within the range set by the comparators.\n    for (let i = 0; i < set.length; i++) {\n      debug(set[i].semver)\n      if (set[i].semver === Comparator.ANY) {\n        continue\n      }\n\n      if (set[i].semver.prerelease.length > 0) {\n        const allowed = set[i].semver\n        if (allowed.major === version.major &&\n            allowed.minor === version.minor &&\n            allowed.patch === version.patch) {\n          return true\n        }\n      }\n    }\n\n    // Version has a -pre, but it's not one of the ones we like.\n    return false\n  }\n\n  return true\n}\n","export default function _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}","import setPrototypeOf from \"./setPrototypeOf\";\nimport isNativeReflectConstruct from \"./isNativeReflectConstruct\";\nexport default function _construct(Parent, args, Class) {\n  if (isNativeReflectConstruct()) {\n    _construct = Reflect.construct;\n  } else {\n    _construct = function _construct(Parent, args, Class) {\n      var a = [null];\n      a.push.apply(a, args);\n      var Constructor = Function.bind.apply(Parent, a);\n      var instance = new Constructor();\n      if (Class) setPrototypeOf(instance, Class.prototype);\n      return instance;\n    };\n  }\n\n  return _construct.apply(null, arguments);\n}","import getPrototypeOf from \"./getPrototypeOf\";\nimport setPrototypeOf from \"./setPrototypeOf\";\nimport isNativeFunction from \"./isNativeFunction\";\nimport construct from \"./construct\";\nexport default function _wrapNativeSuper(Class) {\n  var _cache = typeof Map === \"function\" ? new Map() : undefined;\n\n  _wrapNativeSuper = function _wrapNativeSuper(Class) {\n    if (Class === null || !isNativeFunction(Class)) return Class;\n\n    if (typeof Class !== \"function\") {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n\n    if (typeof _cache !== \"undefined\") {\n      if (_cache.has(Class)) return _cache.get(Class);\n\n      _cache.set(Class, Wrapper);\n    }\n\n    function Wrapper() {\n      return construct(Class, arguments, getPrototypeOf(this).constructor);\n    }\n\n    Wrapper.prototype = Object.create(Class.prototype, {\n      constructor: {\n        value: Wrapper,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    return setPrototypeOf(Wrapper, Class);\n  };\n\n  return _wrapNativeSuper(Class);\n}","export default function _isNativeFunction(fn) {\n  return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n}","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nexport interface ErrorListenerCallback {\n\t(error: any): void;\n}\n\nexport interface ErrorListenerUnbind {\n\t(): void;\n}\n\n// Avoid circular dependency on EventEmitter by implementing a subset of the interface.\nexport class ErrorHandler {\n\tprivate unexpectedErrorHandler: (e: any) => void;\n\tprivate listeners: ErrorListenerCallback[];\n\n\tconstructor() {\n\n\t\tthis.listeners = [];\n\n\t\tthis.unexpectedErrorHandler = function (e: any) {\n\t\t\tsetTimeout(() => {\n\t\t\t\tif (e.stack) {\n\t\t\t\t\tthrow new Error(e.message + '\\n\\n' + e.stack);\n\t\t\t\t}\n\n\t\t\t\tthrow e;\n\t\t\t}, 0);\n\t\t};\n\t}\n\n\taddListener(listener: ErrorListenerCallback): ErrorListenerUnbind {\n\t\tthis.listeners.push(listener);\n\n\t\treturn () => {\n\t\t\tthis._removeListener(listener);\n\t\t};\n\t}\n\n\tprivate emit(e: any): void {\n\t\tthis.listeners.forEach((listener) => {\n\t\t\tlistener(e);\n\t\t});\n\t}\n\n\tprivate _removeListener(listener: ErrorListenerCallback): void {\n\t\tthis.listeners.splice(this.listeners.indexOf(listener), 1);\n\t}\n\n\tsetUnexpectedErrorHandler(newUnexpectedErrorHandler: (e: any) => void): void {\n\t\tthis.unexpectedErrorHandler = newUnexpectedErrorHandler;\n\t}\n\n\tgetUnexpectedErrorHandler(): (e: any) => void {\n\t\treturn this.unexpectedErrorHandler;\n\t}\n\n\tonUnexpectedError(e: any): void {\n\t\tthis.unexpectedErrorHandler(e);\n\t\tthis.emit(e);\n\t}\n\n\t// For external errors, we don't want the listeners to be called\n\tonUnexpectedExternalError(e: any): void {\n\t\tthis.unexpectedErrorHandler(e);\n\t}\n}\n\nexport const errorHandler = new ErrorHandler();\n\nexport function setUnexpectedErrorHandler(newUnexpectedErrorHandler: (e: any) => void): void {\n\terrorHandler.setUnexpectedErrorHandler(newUnexpectedErrorHandler);\n}\n\nexport function onUnexpectedError(e: any): undefined {\n\t// ignore errors from cancelled promises\n\tif (!isPromiseCanceledError(e)) {\n\t\terrorHandler.onUnexpectedError(e);\n\t}\n\treturn undefined;\n}\n\nexport function onUnexpectedExternalError(e: any): undefined {\n\t// ignore errors from cancelled promises\n\tif (!isPromiseCanceledError(e)) {\n\t\terrorHandler.onUnexpectedExternalError(e);\n\t}\n\treturn undefined;\n}\n\nexport interface SerializedError {\n\treadonly $isError: true;\n\treadonly name: string;\n\treadonly message: string;\n\treadonly stack: string;\n}\n\nexport function transformErrorForSerialization(error: Error): SerializedError;\nexport function transformErrorForSerialization(error: any): any;\nexport function transformErrorForSerialization(error: any): any {\n\tif (error instanceof Error) {\n\t\tlet { name, message } = error;\n\t\tconst stack: string = (<any>error).stacktrace || (<any>error).stack;\n\t\treturn {\n\t\t\t$isError: true,\n\t\t\tname,\n\t\t\tmessage,\n\t\t\tstack\n\t\t};\n\t}\n\n\t// return as is\n\treturn error;\n}\n\n// see https://github.com/v8/v8/wiki/Stack%20Trace%20API#basic-stack-traces\nexport interface V8CallSite {\n\tgetThis(): any;\n\tgetTypeName(): string;\n\tgetFunction(): string;\n\tgetFunctionName(): string;\n\tgetMethodName(): string;\n\tgetFileName(): string;\n\tgetLineNumber(): number;\n\tgetColumnNumber(): number;\n\tgetEvalOrigin(): string;\n\tisToplevel(): boolean;\n\tisEval(): boolean;\n\tisNative(): boolean;\n\tisConstructor(): boolean;\n\ttoString(): string;\n}\n\nconst canceledName = 'Canceled';\n\n/**\n * Checks if the given error is a promise in canceled state\n */\nexport function isPromiseCanceledError(error: any): boolean {\n\treturn error instanceof Error && error.name === canceledName && error.message === canceledName;\n}\n\n/**\n * Returns an error that signals cancellation.\n */\nexport function canceled(): Error {\n\tconst error = new Error(canceledName);\n\terror.name = error.message;\n\treturn error;\n}\n\nexport function illegalArgument(name?: string): Error {\n\tif (name) {\n\t\treturn new Error(`Illegal argument: ${name}`);\n\t} else {\n\t\treturn new Error('Illegal argument');\n\t}\n}\n\nexport function illegalState(name?: string): Error {\n\tif (name) {\n\t\treturn new Error(`Illegal state: ${name}`);\n\t} else {\n\t\treturn new Error('Illegal state');\n\t}\n}\n\nexport function readonly(name?: string): Error {\n\treturn name\n\t\t? new Error(`readonly property '${name} cannot be changed'`)\n\t\t: new Error('readonly property cannot be changed');\n}\n\nexport function disposed(what: string): Error {\n\tconst result = new Error(`${what} has been disposed`);\n\tresult.name = 'DISPOSED';\n\treturn result;\n}\n\nexport function getErrorMessage(err: any): string {\n\tif (!err) {\n\t\treturn 'Error';\n\t}\n\n\tif (err.message) {\n\t\treturn err.message;\n\t}\n\n\tif (err.stack) {\n\t\treturn err.stack.split('\\n')[0];\n\t}\n\n\treturn String(err);\n}\n\nexport class NotImplementedError extends Error {\n\tconstructor(message?: string) {\n\t\tsuper('NotImplemented');\n\t\tif (message) {\n\t\t\tthis.message = message;\n\t\t}\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nexport namespace Iterable {\n\n\texport function is<T = any>(thing: any): thing is IterableIterator<T> {\n\t\treturn thing && typeof thing === 'object' && typeof thing[Symbol.iterator] === 'function';\n\t}\n\n\tconst _empty: Iterable<any> = Object.freeze([]);\n\texport function empty<T = any>(): Iterable<T> {\n\t\treturn _empty;\n\t}\n\n\texport function* single<T>(element: T): Iterable<T> {\n\t\tyield element;\n\t}\n\n\texport function from<T>(iterable: Iterable<T> | undefined | null): Iterable<T> {\n\t\treturn iterable || _empty;\n\t}\n\n\texport function first<T>(iterable: Iterable<T>): T | undefined {\n\t\treturn iterable[Symbol.iterator]().next().value;\n\t}\n\n\texport function some<T>(iterable: Iterable<T>, predicate: (t: T) => boolean): boolean {\n\t\tfor (const element of iterable) {\n\t\t\tif (predicate(element)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\texport function* filter<T>(iterable: Iterable<T>, predicate: (t: T) => boolean): Iterable<T> {\n\t\tfor (const element of iterable) {\n\t\t\tif (predicate(element)) {\n\t\t\t\tyield element;\n\t\t\t}\n\t\t}\n\t}\n\n\texport function* map<T, R>(iterable: Iterable<T>, fn: (t: T) => R): Iterable<R> {\n\t\tfor (const element of iterable) {\n\t\t\tyield fn(element);\n\t\t}\n\t}\n\n\texport function* concat<T>(...iterables: Iterable<T>[]): Iterable<T> {\n\t\tfor (const iterable of iterables) {\n\t\t\tfor (const element of iterable) {\n\t\t\t\tyield element;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Consumes `atMost` elements from iterable and returns the consumed elements,\n\t * and an iterable for the rest of the elements.\n\t */\n\texport function consume<T>(iterable: Iterable<T>, atMost: number = Number.POSITIVE_INFINITY): [T[], Iterable<T>] {\n\t\tconst consumed: T[] = [];\n\n\t\tif (atMost === 0) {\n\t\t\treturn [consumed, iterable];\n\t\t}\n\n\t\tconst iterator = iterable[Symbol.iterator]();\n\n\t\tfor (let i = 0; i < atMost; i++) {\n\t\t\tconst next = iterator.next();\n\n\t\t\tif (next.done) {\n\t\t\t\treturn [consumed, Iterable.empty()];\n\t\t\t}\n\n\t\t\tconsumed.push(next.value);\n\t\t}\n\n\t\treturn [consumed, { [Symbol.iterator]() { return iterator; } }];\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { once } from 'vs/base/common/functional';\nimport { Iterable } from 'vs/base/common/iterator';\n\n/**\n * Enables logging of potentially leaked disposables.\n *\n * A disposable is considered leaked if it is not disposed or not registered as the child of\n * another disposable. This tracking is very simple an only works for classes that either\n * extend Disposable or use a DisposableStore. This means there are a lot of false positives.\n */\nconst TRACK_DISPOSABLES = false;\n\nconst __is_disposable_tracked__ = '__is_disposable_tracked__';\n\nfunction markTracked<T extends IDisposable>(x: T): void {\n\tif (!TRACK_DISPOSABLES) {\n\t\treturn;\n\t}\n\n\tif (x && x !== Disposable.None) {\n\t\ttry {\n\t\t\t(x as any)[__is_disposable_tracked__] = true;\n\t\t} catch {\n\t\t\t// noop\n\t\t}\n\t}\n}\n\nfunction trackDisposable<T extends IDisposable>(x: T): T {\n\tif (!TRACK_DISPOSABLES) {\n\t\treturn x;\n\t}\n\n\tconst stack = new Error('Potentially leaked disposable').stack!;\n\tsetTimeout(() => {\n\t\tif (!(x as any)[__is_disposable_tracked__]) {\n\t\t\tconsole.log(stack);\n\t\t}\n\t}, 3000);\n\treturn x;\n}\n\nexport interface IDisposable {\n\tdispose(): void;\n}\n\nexport function isDisposable<E extends object>(thing: E): thing is E & IDisposable {\n\treturn typeof (<IDisposable>thing).dispose === 'function' && (<IDisposable>thing).dispose.length === 0;\n}\n\nexport function dispose<T extends IDisposable>(disposable: T): T;\nexport function dispose<T extends IDisposable>(disposable: T | undefined): T | undefined;\nexport function dispose<T extends IDisposable, A extends IterableIterator<T> = IterableIterator<T>>(disposables: IterableIterator<T>): A;\nexport function dispose<T extends IDisposable>(disposables: Array<T>): Array<T>;\nexport function dispose<T extends IDisposable>(disposables: ReadonlyArray<T>): ReadonlyArray<T>;\nexport function dispose<T extends IDisposable>(arg: T | IterableIterator<T> | undefined): any {\n\tif (Iterable.is(arg)) {\n\t\tfor (let d of arg) {\n\t\t\tif (d) {\n\t\t\t\tmarkTracked(d);\n\t\t\t\td.dispose();\n\t\t\t}\n\t\t}\n\t\treturn Array.isArray(arg) ? [] : arg;\n\t} else if (arg) {\n\t\tmarkTracked(arg);\n\t\targ.dispose();\n\t\treturn arg;\n\t}\n}\n\n\nexport function combinedDisposable(...disposables: IDisposable[]): IDisposable {\n\tdisposables.forEach(markTracked);\n\treturn trackDisposable({ dispose: () => dispose(disposables) });\n}\n\nexport function toDisposable(fn: () => void): IDisposable {\n\tconst self = trackDisposable({\n\t\tdispose: () => {\n\t\t\tmarkTracked(self);\n\t\t\tfn();\n\t\t}\n\t});\n\treturn self;\n}\n\nexport class DisposableStore implements IDisposable {\n\n\tstatic DISABLE_DISPOSED_WARNING = false;\n\n\tprivate _toDispose = new Set<IDisposable>();\n\tprivate _isDisposed = false;\n\n\t/**\n\t * Dispose of all registered disposables and mark this object as disposed.\n\t *\n\t * Any future disposables added to this object will be disposed of on `add`.\n\t */\n\tpublic dispose(): void {\n\t\tif (this._isDisposed) {\n\t\t\treturn;\n\t\t}\n\n\t\tmarkTracked(this);\n\t\tthis._isDisposed = true;\n\t\tthis.clear();\n\t}\n\n\t/**\n\t * Dispose of all registered disposables but do not mark this object as disposed.\n\t */\n\tpublic clear(): void {\n\t\tthis._toDispose.forEach(item => item.dispose());\n\t\tthis._toDispose.clear();\n\t}\n\n\tpublic add<T extends IDisposable>(t: T): T {\n\t\tif (!t) {\n\t\t\treturn t;\n\t\t}\n\t\tif ((t as unknown as DisposableStore) === this) {\n\t\t\tthrow new Error('Cannot register a disposable on itself!');\n\t\t}\n\n\t\tmarkTracked(t);\n\t\tif (this._isDisposed) {\n\t\t\tif (!DisposableStore.DISABLE_DISPOSED_WARNING) {\n\t\t\t\tconsole.warn(new Error('Trying to add a disposable to a DisposableStore that has already been disposed of. The added object will be leaked!').stack);\n\t\t\t}\n\t\t} else {\n\t\t\tthis._toDispose.add(t);\n\t\t}\n\n\t\treturn t;\n\t}\n}\n\nexport abstract class Disposable implements IDisposable {\n\n\tstatic readonly None = Object.freeze<IDisposable>({ dispose() { } });\n\n\tprivate readonly _store = new DisposableStore();\n\n\tconstructor() {\n\t\ttrackDisposable(this);\n\t}\n\n\tpublic dispose(): void {\n\t\tmarkTracked(this);\n\n\t\tthis._store.dispose();\n\t}\n\n\tprotected _register<T extends IDisposable>(t: T): T {\n\t\tif ((t as unknown as Disposable) === this) {\n\t\t\tthrow new Error('Cannot register a disposable on itself!');\n\t\t}\n\t\treturn this._store.add(t);\n\t}\n}\n\n/**\n * Manages the lifecycle of a disposable value that may be changed.\n *\n * This ensures that when the disposable value is changed, the previously held disposable is disposed of. You can\n * also register a `MutableDisposable` on a `Disposable` to ensure it is automatically cleaned up.\n */\nexport class MutableDisposable<T extends IDisposable> implements IDisposable {\n\tprivate _value?: T;\n\tprivate _isDisposed = false;\n\n\tconstructor() {\n\t\ttrackDisposable(this);\n\t}\n\n\tget value(): T | undefined {\n\t\treturn this._isDisposed ? undefined : this._value;\n\t}\n\n\tset value(value: T | undefined) {\n\t\tif (this._isDisposed || value === this._value) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (this._value) {\n\t\t\tthis._value.dispose();\n\t\t}\n\t\tif (value) {\n\t\t\tmarkTracked(value);\n\t\t}\n\t\tthis._value = value;\n\t}\n\n\tclear() {\n\t\tthis.value = undefined;\n\t}\n\n\tdispose(): void {\n\t\tthis._isDisposed = true;\n\t\tmarkTracked(this);\n\t\tif (this._value) {\n\t\t\tthis._value.dispose();\n\t\t}\n\t\tthis._value = undefined;\n\t}\n}\n\nexport interface IReference<T> extends IDisposable {\n\treadonly object: T;\n}\n\nexport abstract class ReferenceCollection<T> {\n\n\tprivate readonly references: Map<string, { readonly object: T; counter: number; }> = new Map();\n\n\tacquire(key: string, ...args: any[]): IReference<T> {\n\t\tlet reference = this.references.get(key);\n\n\t\tif (!reference) {\n\t\t\treference = { counter: 0, object: this.createReferencedObject(key, ...args) };\n\t\t\tthis.references.set(key, reference);\n\t\t}\n\n\t\tconst { object } = reference;\n\t\tconst dispose = once(() => {\n\t\t\tif (--reference!.counter === 0) {\n\t\t\t\tthis.destroyReferencedObject(key, reference!.object);\n\t\t\t\tthis.references.delete(key);\n\t\t\t}\n\t\t});\n\n\t\treference.counter++;\n\n\t\treturn { object, dispose };\n\t}\n\n\tprotected abstract createReferencedObject(key: string, ...args: any[]): T;\n\tprotected abstract destroyReferencedObject(key: string, object: T): void;\n}\n\nexport class ImmortalReference<T> implements IReference<T> {\n\tconstructor(public object: T) { }\n\tdispose(): void { /* noop */ }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nclass Node<E> {\n\n\tstatic readonly Undefined = new Node<any>(undefined);\n\n\telement: E;\n\tnext: Node<E>;\n\tprev: Node<E>;\n\n\tconstructor(element: E) {\n\t\tthis.element = element;\n\t\tthis.next = Node.Undefined;\n\t\tthis.prev = Node.Undefined;\n\t}\n}\n\nexport class LinkedList<E> {\n\n\tprivate _first: Node<E> = Node.Undefined;\n\tprivate _last: Node<E> = Node.Undefined;\n\tprivate _size: number = 0;\n\n\tget size(): number {\n\t\treturn this._size;\n\t}\n\n\tisEmpty(): boolean {\n\t\treturn this._first === Node.Undefined;\n\t}\n\n\tclear(): void {\n\t\tthis._first = Node.Undefined;\n\t\tthis._last = Node.Undefined;\n\t\tthis._size = 0;\n\t}\n\n\tunshift(element: E): () => void {\n\t\treturn this._insert(element, false);\n\t}\n\n\tpush(element: E): () => void {\n\t\treturn this._insert(element, true);\n\t}\n\n\tprivate _insert(element: E, atTheEnd: boolean): () => void {\n\t\tconst newNode = new Node(element);\n\t\tif (this._first === Node.Undefined) {\n\t\t\tthis._first = newNode;\n\t\t\tthis._last = newNode;\n\n\t\t} else if (atTheEnd) {\n\t\t\t// push\n\t\t\tconst oldLast = this._last!;\n\t\t\tthis._last = newNode;\n\t\t\tnewNode.prev = oldLast;\n\t\t\toldLast.next = newNode;\n\n\t\t} else {\n\t\t\t// unshift\n\t\t\tconst oldFirst = this._first;\n\t\t\tthis._first = newNode;\n\t\t\tnewNode.next = oldFirst;\n\t\t\toldFirst.prev = newNode;\n\t\t}\n\t\tthis._size += 1;\n\n\t\tlet didRemove = false;\n\t\treturn () => {\n\t\t\tif (!didRemove) {\n\t\t\t\tdidRemove = true;\n\t\t\t\tthis._remove(newNode);\n\t\t\t}\n\t\t};\n\t}\n\n\tshift(): E | undefined {\n\t\tif (this._first === Node.Undefined) {\n\t\t\treturn undefined;\n\t\t} else {\n\t\t\tconst res = this._first.element;\n\t\t\tthis._remove(this._first);\n\t\t\treturn res;\n\t\t}\n\t}\n\n\tpop(): E | undefined {\n\t\tif (this._last === Node.Undefined) {\n\t\t\treturn undefined;\n\t\t} else {\n\t\t\tconst res = this._last.element;\n\t\t\tthis._remove(this._last);\n\t\t\treturn res;\n\t\t}\n\t}\n\n\tprivate _remove(node: Node<E>): void {\n\t\tif (node.prev !== Node.Undefined && node.next !== Node.Undefined) {\n\t\t\t// middle\n\t\t\tconst anchor = node.prev;\n\t\t\tanchor.next = node.next;\n\t\t\tnode.next.prev = anchor;\n\n\t\t} else if (node.prev === Node.Undefined && node.next === Node.Undefined) {\n\t\t\t// only node\n\t\t\tthis._first = Node.Undefined;\n\t\t\tthis._last = Node.Undefined;\n\n\t\t} else if (node.next === Node.Undefined) {\n\t\t\t// last\n\t\t\tthis._last = this._last!.prev!;\n\t\t\tthis._last.next = Node.Undefined;\n\n\t\t} else if (node.prev === Node.Undefined) {\n\t\t\t// first\n\t\t\tthis._first = this._first!.next!;\n\t\t\tthis._first.prev = Node.Undefined;\n\t\t}\n\n\t\t// done\n\t\tthis._size -= 1;\n\t}\n\n\t*[Symbol.iterator](): Iterator<E> {\n\t\tlet node = this._first;\n\t\twhile (node !== Node.Undefined) {\n\t\t\tyield node.element;\n\t\t\tnode = node.next;\n\t\t}\n\t}\n\n\ttoArray(): E[] {\n\t\tconst result: E[] = [];\n\t\tfor (let node = this._first; node !== Node.Undefined; node = node.next) {\n\t\t\tresult.push(node.element);\n\t\t}\n\t\treturn result;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { onUnexpectedError } from 'vs/base/common/errors';\nimport { once as onceFn } from 'vs/base/common/functional';\nimport { Disposable, IDisposable, toDisposable, combinedDisposable, DisposableStore } from 'vs/base/common/lifecycle';\nimport { LinkedList } from 'vs/base/common/linkedList';\nimport { CancellationToken } from 'vs/base/common/cancellation';\n\n/**\n * To an event a function with one or zero parameters\n * can be subscribed. The event is the subscriber function itself.\n */\nexport interface Event<T> {\n\t(listener: (e: T) => any, thisArgs?: any, disposables?: IDisposable[] | DisposableStore): IDisposable;\n}\n\nexport namespace Event {\n\texport const None: Event<any> = () => Disposable.None;\n\n\t/**\n\t * Given an event, returns another event which only fires once.\n\t */\n\texport function once<T>(event: Event<T>): Event<T> {\n\t\treturn (listener, thisArgs = null, disposables?) => {\n\t\t\t// we need this, in case the event fires during the listener call\n\t\t\tlet didFire = false;\n\t\t\tlet result: IDisposable;\n\t\t\tresult = event(e => {\n\t\t\t\tif (didFire) {\n\t\t\t\t\treturn;\n\t\t\t\t} else if (result) {\n\t\t\t\t\tresult.dispose();\n\t\t\t\t} else {\n\t\t\t\t\tdidFire = true;\n\t\t\t\t}\n\n\t\t\t\treturn listener.call(thisArgs, e);\n\t\t\t}, null, disposables);\n\n\t\t\tif (didFire) {\n\t\t\t\tresult.dispose();\n\t\t\t}\n\n\t\t\treturn result;\n\t\t};\n\t}\n\n\t/**\n\t * Given an event and a `map` function, returns another event which maps each element\n\t * through the mapping function.\n\t */\n\texport function map<I, O>(event: Event<I>, map: (i: I) => O): Event<O> {\n\t\treturn snapshot((listener, thisArgs = null, disposables?) => event(i => listener.call(thisArgs, map(i)), null, disposables));\n\t}\n\n\t/**\n\t * Given an event and an `each` function, returns another identical event and calls\n\t * the `each` function per each element.\n\t */\n\texport function forEach<I>(event: Event<I>, each: (i: I) => void): Event<I> {\n\t\treturn snapshot((listener, thisArgs = null, disposables?) => event(i => { each(i); listener.call(thisArgs, i); }, null, disposables));\n\t}\n\n\t/**\n\t * Given an event and a `filter` function, returns another event which emits those\n\t * elements for which the `filter` function returns `true`.\n\t */\n\texport function filter<T>(event: Event<T>, filter: (e: T) => boolean): Event<T>;\n\texport function filter<T, R>(event: Event<T | R>, filter: (e: T | R) => e is R): Event<R>;\n\texport function filter<T>(event: Event<T>, filter: (e: T) => boolean): Event<T> {\n\t\treturn snapshot((listener, thisArgs = null, disposables?) => event(e => filter(e) && listener.call(thisArgs, e), null, disposables));\n\t}\n\n\t/**\n\t * Given an event, returns the same event but typed as `Event<void>`.\n\t */\n\texport function signal<T>(event: Event<T>): Event<void> {\n\t\treturn event as Event<any> as Event<void>;\n\t}\n\n\t/**\n\t * Given a collection of events, returns a single event which emits\n\t * whenever any of the provided events emit.\n\t */\n\texport function any<T>(...events: Event<T>[]): Event<T>;\n\texport function any(...events: Event<any>[]): Event<void>;\n\texport function any<T>(...events: Event<T>[]): Event<T> {\n\t\treturn (listener, thisArgs = null, disposables?) => combinedDisposable(...events.map(event => event(e => listener.call(thisArgs, e), null, disposables)));\n\t}\n\n\t/**\n\t * Given an event and a `merge` function, returns another event which maps each element\n\t * and the cumulative result through the `merge` function. Similar to `map`, but with memory.\n\t */\n\texport function reduce<I, O>(event: Event<I>, merge: (last: O | undefined, event: I) => O, initial?: O): Event<O> {\n\t\tlet output: O | undefined = initial;\n\n\t\treturn map<I, O>(event, e => {\n\t\t\toutput = merge(output, e);\n\t\t\treturn output;\n\t\t});\n\t}\n\n\t/**\n\t * Given a chain of event processing functions (filter, map, etc), each\n\t * function will be invoked per event & per listener. Snapshotting an event\n\t * chain allows each function to be invoked just once per event.\n\t */\n\texport function snapshot<T>(event: Event<T>): Event<T> {\n\t\tlet listener: IDisposable;\n\t\tconst emitter = new Emitter<T>({\n\t\t\tonFirstListenerAdd() {\n\t\t\t\tlistener = event(emitter.fire, emitter);\n\t\t\t},\n\t\t\tonLastListenerRemove() {\n\t\t\t\tlistener.dispose();\n\t\t\t}\n\t\t});\n\n\t\treturn emitter.event;\n\t}\n\n\t/**\n\t * Debounces the provided event, given a `merge` function.\n\t *\n\t * @param event The input event.\n\t * @param merge The reducing function.\n\t * @param delay The debouncing delay in millis.\n\t * @param leading Whether the event should fire in the leading phase of the timeout.\n\t * @param leakWarningThreshold The leak warning threshold override.\n\t */\n\texport function debounce<T>(event: Event<T>, merge: (last: T | undefined, event: T) => T, delay?: number, leading?: boolean, leakWarningThreshold?: number): Event<T>;\n\texport function debounce<I, O>(event: Event<I>, merge: (last: O | undefined, event: I) => O, delay?: number, leading?: boolean, leakWarningThreshold?: number): Event<O>;\n\texport function debounce<I, O>(event: Event<I>, merge: (last: O | undefined, event: I) => O, delay: number = 100, leading = false, leakWarningThreshold?: number): Event<O> {\n\n\t\tlet subscription: IDisposable;\n\t\tlet output: O | undefined = undefined;\n\t\tlet handle: any = undefined;\n\t\tlet numDebouncedCalls = 0;\n\n\t\tconst emitter = new Emitter<O>({\n\t\t\tleakWarningThreshold,\n\t\t\tonFirstListenerAdd() {\n\t\t\t\tsubscription = event(cur => {\n\t\t\t\t\tnumDebouncedCalls++;\n\t\t\t\t\toutput = merge(output, cur);\n\n\t\t\t\t\tif (leading && !handle) {\n\t\t\t\t\t\temitter.fire(output);\n\t\t\t\t\t\toutput = undefined;\n\t\t\t\t\t}\n\n\t\t\t\t\tclearTimeout(handle);\n\t\t\t\t\thandle = setTimeout(() => {\n\t\t\t\t\t\tconst _output = output;\n\t\t\t\t\t\toutput = undefined;\n\t\t\t\t\t\thandle = undefined;\n\t\t\t\t\t\tif (!leading || numDebouncedCalls > 1) {\n\t\t\t\t\t\t\temitter.fire(_output!);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tnumDebouncedCalls = 0;\n\t\t\t\t\t}, delay);\n\t\t\t\t});\n\t\t\t},\n\t\t\tonLastListenerRemove() {\n\t\t\t\tsubscription.dispose();\n\t\t\t}\n\t\t});\n\n\t\treturn emitter.event;\n\t}\n\n\t/**\n\t * Given an event, it returns another event which fires only once and as soon as\n\t * the input event emits. The event data is the number of millis it took for the\n\t * event to fire.\n\t */\n\texport function stopwatch<T>(event: Event<T>): Event<number> {\n\t\tconst start = new Date().getTime();\n\t\treturn map(once(event), _ => new Date().getTime() - start);\n\t}\n\n\t/**\n\t * Given an event, it returns another event which fires only when the event\n\t * element changes.\n\t */\n\texport function latch<T>(event: Event<T>): Event<T> {\n\t\tlet firstCall = true;\n\t\tlet cache: T;\n\n\t\treturn filter(event, value => {\n\t\t\tconst shouldEmit = firstCall || value !== cache;\n\t\t\tfirstCall = false;\n\t\t\tcache = value;\n\t\t\treturn shouldEmit;\n\t\t});\n\t}\n\n\t/**\n\t * Buffers the provided event until a first listener comes\n\t * along, at which point fire all the events at once and\n\t * pipe the event from then on.\n\t *\n\t * ```typescript\n\t * const emitter = new Emitter<number>();\n\t * const event = emitter.event;\n\t * const bufferedEvent = buffer(event);\n\t *\n\t * emitter.fire(1);\n\t * emitter.fire(2);\n\t * emitter.fire(3);\n\t * // nothing...\n\t *\n\t * const listener = bufferedEvent(num => console.log(num));\n\t * // 1, 2, 3\n\t *\n\t * emitter.fire(4);\n\t * // 4\n\t * ```\n\t */\n\texport function buffer<T>(event: Event<T>, nextTick = false, _buffer: T[] = []): Event<T> {\n\t\tlet buffer: T[] | null = _buffer.slice();\n\n\t\tlet listener: IDisposable | null = event(e => {\n\t\t\tif (buffer) {\n\t\t\t\tbuffer.push(e);\n\t\t\t} else {\n\t\t\t\temitter.fire(e);\n\t\t\t}\n\t\t});\n\n\t\tconst flush = () => {\n\t\t\tif (buffer) {\n\t\t\t\tbuffer.forEach(e => emitter.fire(e));\n\t\t\t}\n\t\t\tbuffer = null;\n\t\t};\n\n\t\tconst emitter = new Emitter<T>({\n\t\t\tonFirstListenerAdd() {\n\t\t\t\tif (!listener) {\n\t\t\t\t\tlistener = event(e => emitter.fire(e));\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tonFirstListenerDidAdd() {\n\t\t\t\tif (buffer) {\n\t\t\t\t\tif (nextTick) {\n\t\t\t\t\t\tsetTimeout(flush);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tflush();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tonLastListenerRemove() {\n\t\t\t\tif (listener) {\n\t\t\t\t\tlistener.dispose();\n\t\t\t\t}\n\t\t\t\tlistener = null;\n\t\t\t}\n\t\t});\n\n\t\treturn emitter.event;\n\t}\n\n\texport interface IChainableEvent<T> {\n\t\tevent: Event<T>;\n\t\tmap<O>(fn: (i: T) => O): IChainableEvent<O>;\n\t\tforEach(fn: (i: T) => void): IChainableEvent<T>;\n\t\tfilter(fn: (e: T) => boolean): IChainableEvent<T>;\n\t\tfilter<R>(fn: (e: T | R) => e is R): IChainableEvent<R>;\n\t\treduce<R>(merge: (last: R | undefined, event: T) => R, initial?: R): IChainableEvent<R>;\n\t\tlatch(): IChainableEvent<T>;\n\t\tdebounce(merge: (last: T | undefined, event: T) => T, delay?: number, leading?: boolean, leakWarningThreshold?: number): IChainableEvent<T>;\n\t\tdebounce<R>(merge: (last: R | undefined, event: T) => R, delay?: number, leading?: boolean, leakWarningThreshold?: number): IChainableEvent<R>;\n\t\ton(listener: (e: T) => any, thisArgs?: any, disposables?: IDisposable[] | DisposableStore): IDisposable;\n\t\tonce(listener: (e: T) => any, thisArgs?: any, disposables?: IDisposable[]): IDisposable;\n\t}\n\n\tclass ChainableEvent<T> implements IChainableEvent<T> {\n\n\t\tconstructor(readonly event: Event<T>) { }\n\n\t\tmap<O>(fn: (i: T) => O): IChainableEvent<O> {\n\t\t\treturn new ChainableEvent(map(this.event, fn));\n\t\t}\n\n\t\tforEach(fn: (i: T) => void): IChainableEvent<T> {\n\t\t\treturn new ChainableEvent(forEach(this.event, fn));\n\t\t}\n\n\t\tfilter(fn: (e: T) => boolean): IChainableEvent<T>;\n\t\tfilter<R>(fn: (e: T | R) => e is R): IChainableEvent<R>;\n\t\tfilter(fn: (e: T) => boolean): IChainableEvent<T> {\n\t\t\treturn new ChainableEvent(filter(this.event, fn));\n\t\t}\n\n\t\treduce<R>(merge: (last: R | undefined, event: T) => R, initial?: R): IChainableEvent<R> {\n\t\t\treturn new ChainableEvent(reduce(this.event, merge, initial));\n\t\t}\n\n\t\tlatch(): IChainableEvent<T> {\n\t\t\treturn new ChainableEvent(latch(this.event));\n\t\t}\n\n\t\tdebounce(merge: (last: T | undefined, event: T) => T, delay?: number, leading?: boolean, leakWarningThreshold?: number): IChainableEvent<T>;\n\t\tdebounce<R>(merge: (last: R | undefined, event: T) => R, delay?: number, leading?: boolean, leakWarningThreshold?: number): IChainableEvent<R>;\n\t\tdebounce<R>(merge: (last: R | undefined, event: T) => R, delay: number = 100, leading = false, leakWarningThreshold?: number): IChainableEvent<R> {\n\t\t\treturn new ChainableEvent(debounce(this.event, merge, delay, leading, leakWarningThreshold));\n\t\t}\n\n\t\ton(listener: (e: T) => any, thisArgs: any, disposables: IDisposable[] | DisposableStore) {\n\t\t\treturn this.event(listener, thisArgs, disposables);\n\t\t}\n\n\t\tonce(listener: (e: T) => any, thisArgs: any, disposables: IDisposable[]) {\n\t\t\treturn once(this.event)(listener, thisArgs, disposables);\n\t\t}\n\t}\n\n\texport function chain<T>(event: Event<T>): IChainableEvent<T> {\n\t\treturn new ChainableEvent(event);\n\t}\n\n\texport interface NodeEventEmitter {\n\t\ton(event: string | symbol, listener: Function): unknown;\n\t\tremoveListener(event: string | symbol, listener: Function): unknown;\n\t}\n\n\texport function fromNodeEventEmitter<T>(emitter: NodeEventEmitter, eventName: string, map: (...args: any[]) => T = id => id): Event<T> {\n\t\tconst fn = (...args: any[]) => result.fire(map(...args));\n\t\tconst onFirstListenerAdd = () => emitter.on(eventName, fn);\n\t\tconst onLastListenerRemove = () => emitter.removeListener(eventName, fn);\n\t\tconst result = new Emitter<T>({ onFirstListenerAdd, onLastListenerRemove });\n\n\t\treturn result.event;\n\t}\n\n\texport interface DOMEventEmitter {\n\t\taddEventListener(event: string | symbol, listener: Function): void;\n\t\tremoveEventListener(event: string | symbol, listener: Function): void;\n\t}\n\n\texport function fromDOMEventEmitter<T>(emitter: DOMEventEmitter, eventName: string, map: (...args: any[]) => T = id => id): Event<T> {\n\t\tconst fn = (...args: any[]) => result.fire(map(...args));\n\t\tconst onFirstListenerAdd = () => emitter.addEventListener(eventName, fn);\n\t\tconst onLastListenerRemove = () => emitter.removeEventListener(eventName, fn);\n\t\tconst result = new Emitter<T>({ onFirstListenerAdd, onLastListenerRemove });\n\n\t\treturn result.event;\n\t}\n\n\texport function fromPromise<T = any>(promise: Promise<T>): Event<undefined> {\n\t\tconst emitter = new Emitter<undefined>();\n\t\tlet shouldEmit = false;\n\n\t\tpromise\n\t\t\t.then(undefined, () => null)\n\t\t\t.then(() => {\n\t\t\t\tif (!shouldEmit) {\n\t\t\t\t\tsetTimeout(() => emitter.fire(undefined), 0);\n\t\t\t\t} else {\n\t\t\t\t\temitter.fire(undefined);\n\t\t\t\t}\n\t\t\t});\n\n\t\tshouldEmit = true;\n\t\treturn emitter.event;\n\t}\n\n\texport function toPromise<T>(event: Event<T>): Promise<T> {\n\t\treturn new Promise(c => once(event)(c));\n\t}\n}\n\ntype Listener<T> = [(e: T) => void, any] | ((e: T) => void);\n\nexport interface EmitterOptions {\n\tonFirstListenerAdd?: Function;\n\tonFirstListenerDidAdd?: Function;\n\tonListenerDidAdd?: Function;\n\tonLastListenerRemove?: Function;\n\tleakWarningThreshold?: number;\n}\n\nlet _globalLeakWarningThreshold = -1;\nexport function setGlobalLeakWarningThreshold(n: number): IDisposable {\n\tconst oldValue = _globalLeakWarningThreshold;\n\t_globalLeakWarningThreshold = n;\n\treturn {\n\t\tdispose() {\n\t\t\t_globalLeakWarningThreshold = oldValue;\n\t\t}\n\t};\n}\n\nclass LeakageMonitor {\n\n\tprivate _stacks: Map<string, number> | undefined;\n\tprivate _warnCountdown: number = 0;\n\n\tconstructor(\n\t\treadonly customThreshold?: number,\n\t\treadonly name: string = Math.random().toString(18).slice(2, 5),\n\t) { }\n\n\tdispose(): void {\n\t\tif (this._stacks) {\n\t\t\tthis._stacks.clear();\n\t\t}\n\t}\n\n\tcheck(listenerCount: number): undefined | (() => void) {\n\n\t\tlet threshold = _globalLeakWarningThreshold;\n\t\tif (typeof this.customThreshold === 'number') {\n\t\t\tthreshold = this.customThreshold;\n\t\t}\n\n\t\tif (threshold <= 0 || listenerCount < threshold) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tif (!this._stacks) {\n\t\t\tthis._stacks = new Map();\n\t\t}\n\t\tconst stack = new Error().stack!.split('\\n').slice(3).join('\\n');\n\t\tconst count = (this._stacks.get(stack) || 0);\n\t\tthis._stacks.set(stack, count + 1);\n\t\tthis._warnCountdown -= 1;\n\n\t\tif (this._warnCountdown <= 0) {\n\t\t\t// only warn on first exceed and then every time the limit\n\t\t\t// is exceeded by 50% again\n\t\t\tthis._warnCountdown = threshold * 0.5;\n\n\t\t\t// find most frequent listener and print warning\n\t\t\tlet topStack: string | undefined;\n\t\t\tlet topCount: number = 0;\n\t\t\tfor (const [stack, count] of this._stacks) {\n\t\t\t\tif (!topStack || topCount < count) {\n\t\t\t\t\ttopStack = stack;\n\t\t\t\t\ttopCount = count;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconsole.warn(`[${this.name}] potential listener LEAK detected, having ${listenerCount} listeners already. MOST frequent listener (${topCount}):`);\n\t\t\tconsole.warn(topStack!);\n\t\t}\n\n\t\treturn () => {\n\t\t\tconst count = (this._stacks!.get(stack) || 0);\n\t\t\tthis._stacks!.set(stack, count - 1);\n\t\t};\n\t}\n}\n\n/**\n * The Emitter can be used to expose an Event to the public\n * to fire it from the insides.\n * Sample:\n\tclass Document {\n\n\t\tprivate readonly _onDidChange = new Emitter<(value:string)=>any>();\n\n\t\tpublic onDidChange = this._onDidChange.event;\n\n\t\t// getter-style\n\t\t// get onDidChange(): Event<(value:string)=>any> {\n\t\t// \treturn this._onDidChange.event;\n\t\t// }\n\n\t\tprivate _doIt() {\n\t\t\t//...\n\t\t\tthis._onDidChange.fire(value);\n\t\t}\n\t}\n */\nexport class Emitter<T> {\n\n\tprivate static readonly _noop = function () { };\n\n\tprivate readonly _options?: EmitterOptions;\n\tprivate readonly _leakageMon?: LeakageMonitor;\n\tprivate _disposed: boolean = false;\n\tprivate _event?: Event<T>;\n\tprivate _deliveryQueue?: LinkedList<[Listener<T>, T]>;\n\tprotected _listeners?: LinkedList<Listener<T>>;\n\n\tconstructor(options?: EmitterOptions) {\n\t\tthis._options = options;\n\t\tthis._leakageMon = _globalLeakWarningThreshold > 0\n\t\t\t? new LeakageMonitor(this._options && this._options.leakWarningThreshold)\n\t\t\t: undefined;\n\t}\n\n\t/**\n\t * For the public to allow to subscribe\n\t * to events from this Emitter\n\t */\n\tget event(): Event<T> {\n\t\tif (!this._event) {\n\t\t\tthis._event = (listener: (e: T) => any, thisArgs?: any, disposables?: IDisposable[] | DisposableStore) => {\n\t\t\t\tif (!this._listeners) {\n\t\t\t\t\tthis._listeners = new LinkedList();\n\t\t\t\t}\n\n\t\t\t\tconst firstListener = this._listeners.isEmpty();\n\n\t\t\t\tif (firstListener && this._options && this._options.onFirstListenerAdd) {\n\t\t\t\t\tthis._options.onFirstListenerAdd(this);\n\t\t\t\t}\n\n\t\t\t\tconst remove = this._listeners.push(!thisArgs ? listener : [listener, thisArgs]);\n\n\t\t\t\tif (firstListener && this._options && this._options.onFirstListenerDidAdd) {\n\t\t\t\t\tthis._options.onFirstListenerDidAdd(this);\n\t\t\t\t}\n\n\t\t\t\tif (this._options && this._options.onListenerDidAdd) {\n\t\t\t\t\tthis._options.onListenerDidAdd(this, listener, thisArgs);\n\t\t\t\t}\n\n\t\t\t\t// check and record this emitter for potential leakage\n\t\t\t\tlet removeMonitor: (() => void) | undefined;\n\t\t\t\tif (this._leakageMon) {\n\t\t\t\t\tremoveMonitor = this._leakageMon.check(this._listeners.size);\n\t\t\t\t}\n\n\t\t\t\tlet result: IDisposable;\n\t\t\t\tresult = {\n\t\t\t\t\tdispose: () => {\n\t\t\t\t\t\tif (removeMonitor) {\n\t\t\t\t\t\t\tremoveMonitor();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tresult.dispose = Emitter._noop;\n\t\t\t\t\t\tif (!this._disposed) {\n\t\t\t\t\t\t\tremove();\n\t\t\t\t\t\t\tif (this._options && this._options.onLastListenerRemove) {\n\t\t\t\t\t\t\t\tconst hasListeners = (this._listeners && !this._listeners.isEmpty());\n\t\t\t\t\t\t\t\tif (!hasListeners) {\n\t\t\t\t\t\t\t\t\tthis._options.onLastListenerRemove(this);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tif (disposables instanceof DisposableStore) {\n\t\t\t\t\tdisposables.add(result);\n\t\t\t\t} else if (Array.isArray(disposables)) {\n\t\t\t\t\tdisposables.push(result);\n\t\t\t\t}\n\n\t\t\t\treturn result;\n\t\t\t};\n\t\t}\n\t\treturn this._event;\n\t}\n\n\t/**\n\t * To be kept private to fire an event to\n\t * subscribers\n\t */\n\tfire(event: T): void {\n\t\tif (this._listeners) {\n\t\t\t// put all [listener,event]-pairs into delivery queue\n\t\t\t// then emit all event. an inner/nested event might be\n\t\t\t// the driver of this\n\n\t\t\tif (!this._deliveryQueue) {\n\t\t\t\tthis._deliveryQueue = new LinkedList();\n\t\t\t}\n\n\t\t\tfor (let listener of this._listeners) {\n\t\t\t\tthis._deliveryQueue.push([listener, event]);\n\t\t\t}\n\n\t\t\twhile (this._deliveryQueue.size > 0) {\n\t\t\t\tconst [listener, event] = this._deliveryQueue.shift()!;\n\t\t\t\ttry {\n\t\t\t\t\tif (typeof listener === 'function') {\n\t\t\t\t\t\tlistener.call(undefined, event);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlistener[0].call(listener[1], event);\n\t\t\t\t\t}\n\t\t\t\t} catch (e) {\n\t\t\t\t\tonUnexpectedError(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tdispose() {\n\t\tif (this._listeners) {\n\t\t\tthis._listeners.clear();\n\t\t}\n\t\tif (this._deliveryQueue) {\n\t\t\tthis._deliveryQueue.clear();\n\t\t}\n\t\tif (this._leakageMon) {\n\t\t\tthis._leakageMon.dispose();\n\t\t}\n\t\tthis._disposed = true;\n\t}\n}\n\nexport class PauseableEmitter<T> extends Emitter<T> {\n\n\tprivate _isPaused = 0;\n\tprivate _eventQueue = new LinkedList<T>();\n\tprivate _mergeFn?: (input: T[]) => T;\n\n\tconstructor(options?: EmitterOptions & { merge?: (input: T[]) => T }) {\n\t\tsuper(options);\n\t\tthis._mergeFn = options && options.merge;\n\t}\n\n\tpause(): void {\n\t\tthis._isPaused++;\n\t}\n\n\tresume(): void {\n\t\tif (this._isPaused !== 0 && --this._isPaused === 0) {\n\t\t\tif (this._mergeFn) {\n\t\t\t\t// use the merge function to create a single composite\n\t\t\t\t// event. make a copy in case firing pauses this emitter\n\t\t\t\tconst events = this._eventQueue.toArray();\n\t\t\t\tthis._eventQueue.clear();\n\t\t\t\tsuper.fire(this._mergeFn(events));\n\n\t\t\t} else {\n\t\t\t\t// no merging, fire each event individually and test\n\t\t\t\t// that this emitter isn't paused halfway through\n\t\t\t\twhile (!this._isPaused && this._eventQueue.size !== 0) {\n\t\t\t\t\tsuper.fire(this._eventQueue.shift()!);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfire(event: T): void {\n\t\tif (this._listeners) {\n\t\t\tif (this._isPaused !== 0) {\n\t\t\t\tthis._eventQueue.push(event);\n\t\t\t} else {\n\t\t\t\tsuper.fire(event);\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport interface IWaitUntil {\n\twaitUntil(thenable: Promise<any>): void;\n}\n\nexport class AsyncEmitter<T extends IWaitUntil> extends Emitter<T> {\n\n\tprivate _asyncDeliveryQueue?: LinkedList<[Listener<T>, Omit<T, 'waitUntil'>]>;\n\n\tasync fireAsync(data: Omit<T, 'waitUntil'>, token: CancellationToken, promiseJoin?: (p: Promise<any>, listener: Function) => Promise<any>): Promise<void> {\n\t\tif (!this._listeners) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!this._asyncDeliveryQueue) {\n\t\t\tthis._asyncDeliveryQueue = new LinkedList();\n\t\t}\n\n\t\tfor (const listener of this._listeners) {\n\t\t\tthis._asyncDeliveryQueue.push([listener, data]);\n\t\t}\n\n\t\twhile (this._asyncDeliveryQueue.size > 0 && !token.isCancellationRequested) {\n\n\t\t\tconst [listener, data] = this._asyncDeliveryQueue.shift()!;\n\t\t\tconst thenables: Promise<any>[] = [];\n\n\t\t\tconst event = <T>{\n\t\t\t\t...data,\n\t\t\t\twaitUntil: (p: Promise<any>): void => {\n\t\t\t\t\tif (Object.isFrozen(thenables)) {\n\t\t\t\t\t\tthrow new Error('waitUntil can NOT be called asynchronous');\n\t\t\t\t\t}\n\t\t\t\t\tif (promiseJoin) {\n\t\t\t\t\t\tp = promiseJoin(p, typeof listener === 'function' ? listener : listener[0]);\n\t\t\t\t\t}\n\t\t\t\t\tthenables.push(p);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\ttry {\n\t\t\t\tif (typeof listener === 'function') {\n\t\t\t\t\tlistener.call(undefined, event);\n\t\t\t\t} else {\n\t\t\t\t\tlistener[0].call(listener[1], event);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\tonUnexpectedError(e);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// freeze thenables-collection to enforce sync-calls to\n\t\t\t// wait until and then wait for all thenables to resolve\n\t\t\tObject.freeze(thenables);\n\t\t\tawait Promise.all(thenables).catch(e => onUnexpectedError(e));\n\t\t}\n\t}\n}\n\nexport class EventMultiplexer<T> implements IDisposable {\n\n\tprivate readonly emitter: Emitter<T>;\n\tprivate hasListeners = false;\n\tprivate events: { event: Event<T>; listener: IDisposable | null; }[] = [];\n\n\tconstructor() {\n\t\tthis.emitter = new Emitter<T>({\n\t\t\tonFirstListenerAdd: () => this.onFirstListenerAdd(),\n\t\t\tonLastListenerRemove: () => this.onLastListenerRemove()\n\t\t});\n\t}\n\n\tget event(): Event<T> {\n\t\treturn this.emitter.event;\n\t}\n\n\tadd(event: Event<T>): IDisposable {\n\t\tconst e = { event: event, listener: null };\n\t\tthis.events.push(e);\n\n\t\tif (this.hasListeners) {\n\t\t\tthis.hook(e);\n\t\t}\n\n\t\tconst dispose = () => {\n\t\t\tif (this.hasListeners) {\n\t\t\t\tthis.unhook(e);\n\t\t\t}\n\n\t\t\tconst idx = this.events.indexOf(e);\n\t\t\tthis.events.splice(idx, 1);\n\t\t};\n\n\t\treturn toDisposable(onceFn(dispose));\n\t}\n\n\tprivate onFirstListenerAdd(): void {\n\t\tthis.hasListeners = true;\n\t\tthis.events.forEach(e => this.hook(e));\n\t}\n\n\tprivate onLastListenerRemove(): void {\n\t\tthis.hasListeners = false;\n\t\tthis.events.forEach(e => this.unhook(e));\n\t}\n\n\tprivate hook(e: { event: Event<T>; listener: IDisposable | null; }): void {\n\t\te.listener = e.event(r => this.emitter.fire(r));\n\t}\n\n\tprivate unhook(e: { event: Event<T>; listener: IDisposable | null; }): void {\n\t\tif (e.listener) {\n\t\t\te.listener.dispose();\n\t\t}\n\t\te.listener = null;\n\t}\n\n\tdispose(): void {\n\t\tthis.emitter.dispose();\n\t}\n}\n\n/**\n * The EventBufferer is useful in situations in which you want\n * to delay firing your events during some code.\n * You can wrap that code and be sure that the event will not\n * be fired during that wrap.\n *\n * ```\n * const emitter: Emitter;\n * const delayer = new EventDelayer();\n * const delayedEvent = delayer.wrapEvent(emitter.event);\n *\n * delayedEvent(console.log);\n *\n * delayer.bufferEvents(() => {\n *   emitter.fire(); // event will not be fired yet\n * });\n *\n * // event will only be fired at this point\n * ```\n */\nexport class EventBufferer {\n\n\tprivate buffers: Function[][] = [];\n\n\twrapEvent<T>(event: Event<T>): Event<T> {\n\t\treturn (listener, thisArgs?, disposables?) => {\n\t\t\treturn event(i => {\n\t\t\t\tconst buffer = this.buffers[this.buffers.length - 1];\n\n\t\t\t\tif (buffer) {\n\t\t\t\t\tbuffer.push(() => listener.call(thisArgs, i));\n\t\t\t\t} else {\n\t\t\t\t\tlistener.call(thisArgs, i);\n\t\t\t\t}\n\t\t\t}, undefined, disposables);\n\t\t};\n\t}\n\n\tbufferEvents<R = void>(fn: () => R): R {\n\t\tconst buffer: Array<() => R> = [];\n\t\tthis.buffers.push(buffer);\n\t\tconst r = fn();\n\t\tthis.buffers.pop();\n\t\tbuffer.forEach(flush => flush());\n\t\treturn r;\n\t}\n}\n\n/**\n * A Relay is an event forwarder which functions as a replugabble event pipe.\n * Once created, you can connect an input event to it and it will simply forward\n * events from that input event through its own `event` property. The `input`\n * can be changed at any point in time.\n */\nexport class Relay<T> implements IDisposable {\n\n\tprivate listening = false;\n\tprivate inputEvent: Event<T> = Event.None;\n\tprivate inputEventListener: IDisposable = Disposable.None;\n\n\tprivate readonly emitter = new Emitter<T>({\n\t\tonFirstListenerDidAdd: () => {\n\t\t\tthis.listening = true;\n\t\t\tthis.inputEventListener = this.inputEvent(this.emitter.fire, this.emitter);\n\t\t},\n\t\tonLastListenerRemove: () => {\n\t\t\tthis.listening = false;\n\t\t\tthis.inputEventListener.dispose();\n\t\t}\n\t});\n\n\treadonly event: Event<T> = this.emitter.event;\n\n\tset input(event: Event<T>) {\n\t\tthis.inputEvent = event;\n\n\t\tif (this.listening) {\n\t\t\tthis.inputEventListener.dispose();\n\t\t\tthis.inputEventListener = event(this.emitter.fire, this.emitter);\n\t\t}\n\t}\n\n\tdispose() {\n\t\tthis.inputEventListener.dispose();\n\t\tthis.emitter.dispose();\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Emitter, Event } from 'vs/base/common/event';\nimport { IDisposable } from 'vs/base/common/lifecycle';\n\nexport interface CancellationToken {\n\n\t/**\n\t * A flag signalling is cancellation has been requested.\n\t */\n\treadonly isCancellationRequested: boolean;\n\n\t/**\n\t * An event which fires when cancellation is requested. This event\n\t * only ever fires `once` as cancellation can only happen once. Listeners\n\t * that are registered after cancellation will be called (next event loop run),\n\t * but also only once.\n\t *\n\t * @event\n\t */\n\treadonly onCancellationRequested: (listener: (e: any) => any, thisArgs?: any, disposables?: IDisposable[]) => IDisposable;\n}\n\nconst shortcutEvent: Event<any> = Object.freeze(function (callback, context?): IDisposable {\n\tconst handle = setTimeout(callback.bind(context), 0);\n\treturn { dispose() { clearTimeout(handle); } };\n});\n\nexport namespace CancellationToken {\n\n\texport function isCancellationToken(thing: unknown): thing is CancellationToken {\n\t\tif (thing === CancellationToken.None || thing === CancellationToken.Cancelled) {\n\t\t\treturn true;\n\t\t}\n\t\tif (thing instanceof MutableToken) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!thing || typeof thing !== 'object') {\n\t\t\treturn false;\n\t\t}\n\t\treturn typeof (thing as CancellationToken).isCancellationRequested === 'boolean'\n\t\t\t&& typeof (thing as CancellationToken).onCancellationRequested === 'function';\n\t}\n\n\n\texport const None: CancellationToken = Object.freeze({\n\t\tisCancellationRequested: false,\n\t\tonCancellationRequested: Event.None\n\t});\n\n\texport const Cancelled: CancellationToken = Object.freeze({\n\t\tisCancellationRequested: true,\n\t\tonCancellationRequested: shortcutEvent\n\t});\n}\n\nclass MutableToken implements CancellationToken {\n\n\tprivate _isCancelled: boolean = false;\n\tprivate _emitter: Emitter<any> | null = null;\n\n\tpublic cancel() {\n\t\tif (!this._isCancelled) {\n\t\t\tthis._isCancelled = true;\n\t\t\tif (this._emitter) {\n\t\t\t\tthis._emitter.fire(undefined);\n\t\t\t\tthis.dispose();\n\t\t\t}\n\t\t}\n\t}\n\n\tget isCancellationRequested(): boolean {\n\t\treturn this._isCancelled;\n\t}\n\n\tget onCancellationRequested(): Event<any> {\n\t\tif (this._isCancelled) {\n\t\t\treturn shortcutEvent;\n\t\t}\n\t\tif (!this._emitter) {\n\t\t\tthis._emitter = new Emitter<any>();\n\t\t}\n\t\treturn this._emitter.event;\n\t}\n\n\tpublic dispose(): void {\n\t\tif (this._emitter) {\n\t\t\tthis._emitter.dispose();\n\t\t\tthis._emitter = null;\n\t\t}\n\t}\n}\n\nexport class CancellationTokenSource {\n\n\tprivate _token?: CancellationToken = undefined;\n\tprivate _parentListener?: IDisposable = undefined;\n\n\tconstructor(parent?: CancellationToken) {\n\t\tthis._parentListener = parent && parent.onCancellationRequested(this.cancel, this);\n\t}\n\n\tget token(): CancellationToken {\n\t\tif (!this._token) {\n\t\t\t// be lazy and create the token only when\n\t\t\t// actually needed\n\t\t\tthis._token = new MutableToken();\n\t\t}\n\t\treturn this._token;\n\t}\n\n\tcancel(): void {\n\t\tif (!this._token) {\n\t\t\t// save an object by returning the default\n\t\t\t// cancelled token when cancellation happens\n\t\t\t// before someone asks for the token\n\t\t\tthis._token = CancellationToken.Cancelled;\n\n\t\t} else if (this._token instanceof MutableToken) {\n\t\t\t// actually cancel\n\t\t\tthis._token.cancel();\n\t\t}\n\t}\n\n\tdispose(cancel: boolean = false): void {\n\t\tif (cancel) {\n\t\t\tthis.cancel();\n\t\t}\n\t\tif (this._parentListener) {\n\t\t\tthis._parentListener.dispose();\n\t\t}\n\t\tif (!this._token) {\n\t\t\t// ensure to initialize with an empty token if we had none\n\t\t\tthis._token = CancellationToken.None;\n\n\t\t} else if (this._token instanceof MutableToken) {\n\t\t\t// actually dispose\n\t\t\tthis._token.dispose();\n\t\t}\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CancellationToken, CancellationTokenSource } from 'vs/base/common/cancellation';\nimport * as errors from 'vs/base/common/errors';\nimport { Emitter, Event } from 'vs/base/common/event';\nimport { IDisposable, toDisposable } from 'vs/base/common/lifecycle';\nimport { URI } from 'vs/base/common/uri';\n\nexport function isThenable<T>(obj: any): obj is Promise<T> {\n\treturn obj && typeof (<Promise<any>>obj).then === 'function';\n}\n\nexport interface CancelablePromise<T> extends Promise<T> {\n\tcancel(): void;\n}\n\nexport function createCancelablePromise<T>(callback: (token: CancellationToken) => Promise<T>): CancelablePromise<T> {\n\tconst source = new CancellationTokenSource();\n\n\tconst thenable = callback(source.token);\n\tconst promise = new Promise<T>((resolve, reject) => {\n\t\tsource.token.onCancellationRequested(() => {\n\t\t\treject(errors.canceled());\n\t\t});\n\t\tPromise.resolve(thenable).then(value => {\n\t\t\tsource.dispose();\n\t\t\tresolve(value);\n\t\t}, err => {\n\t\t\tsource.dispose();\n\t\t\treject(err);\n\t\t});\n\t});\n\n\treturn <CancelablePromise<T>>new class {\n\t\tcancel() {\n\t\t\tsource.cancel();\n\t\t}\n\t\tthen<TResult1 = T, TResult2 = never>(resolve?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, reject?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2> {\n\t\t\treturn promise.then(resolve, reject);\n\t\t}\n\t\tcatch<TResult = never>(reject?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult> {\n\t\t\treturn this.then(undefined, reject);\n\t\t}\n\t\tfinally(onfinally?: (() => void) | undefined | null): Promise<T> {\n\t\t\treturn promise.finally(onfinally);\n\t\t}\n\t};\n}\n\nexport function raceCancellation<T>(promise: Promise<T>, token: CancellationToken): Promise<T | undefined>;\nexport function raceCancellation<T>(promise: Promise<T>, token: CancellationToken, defaultValue: T): Promise<T>;\nexport function raceCancellation<T>(promise: Promise<T>, token: CancellationToken, defaultValue?: T): Promise<T> {\n\treturn Promise.race([promise, new Promise<T>(resolve => token.onCancellationRequested(() => resolve(defaultValue)))]);\n}\n\nexport function raceTimeout<T>(promise: Promise<T>, timeout: number, onTimeout?: () => void): Promise<T> {\n\tlet promiseResolve: (() => void) | undefined = undefined;\n\n\tconst timer = setTimeout(() => {\n\t\tpromiseResolve?.();\n\t\tonTimeout?.();\n\t}, timeout);\n\n\treturn Promise.race([\n\t\tpromise.finally(() => clearTimeout(timer)),\n\t\tnew Promise<T>(resolve => promiseResolve = resolve)\n\t]);\n}\n\nexport function asPromise<T>(callback: () => T | Thenable<T>): Promise<T> {\n\treturn new Promise<T>((resolve, reject) => {\n\t\tconst item = callback();\n\t\tif (isThenable<T>(item)) {\n\t\t\titem.then(resolve, reject);\n\t\t} else {\n\t\t\tresolve(item);\n\t\t}\n\t});\n}\n\nexport interface ITask<T> {\n\t(): T;\n}\n\n/**\n * A helper to prevent accumulation of sequential async tasks.\n *\n * Imagine a mail man with the sole task of delivering letters. As soon as\n * a letter submitted for delivery, he drives to the destination, delivers it\n * and returns to his base. Imagine that during the trip, N more letters were submitted.\n * When the mail man returns, he picks those N letters and delivers them all in a\n * single trip. Even though N+1 submissions occurred, only 2 deliveries were made.\n *\n * The throttler implements this via the queue() method, by providing it a task\n * factory. Following the example:\n *\n * \t\tconst throttler = new Throttler();\n * \t\tconst letters = [];\n *\n * \t\tfunction deliver() {\n * \t\t\tconst lettersToDeliver = letters;\n * \t\t\tletters = [];\n * \t\t\treturn makeTheTrip(lettersToDeliver);\n * \t\t}\n *\n * \t\tfunction onLetterReceived(l) {\n * \t\t\tletters.push(l);\n * \t\t\tthrottler.queue(deliver);\n * \t\t}\n */\nexport class Throttler {\n\n\tprivate activePromise: Promise<any> | null;\n\tprivate queuedPromise: Promise<any> | null;\n\tprivate queuedPromiseFactory: ITask<Promise<any>> | null;\n\n\tconstructor() {\n\t\tthis.activePromise = null;\n\t\tthis.queuedPromise = null;\n\t\tthis.queuedPromiseFactory = null;\n\t}\n\n\tqueue<T>(promiseFactory: ITask<Promise<T>>): Promise<T> {\n\t\tif (this.activePromise) {\n\t\t\tthis.queuedPromiseFactory = promiseFactory;\n\n\t\t\tif (!this.queuedPromise) {\n\t\t\t\tconst onComplete = () => {\n\t\t\t\t\tthis.queuedPromise = null;\n\n\t\t\t\t\tconst result = this.queue(this.queuedPromiseFactory!);\n\t\t\t\t\tthis.queuedPromiseFactory = null;\n\n\t\t\t\t\treturn result;\n\t\t\t\t};\n\n\t\t\t\tthis.queuedPromise = new Promise(c => {\n\t\t\t\t\tthis.activePromise!.then(onComplete, onComplete).then(c);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn new Promise((c, e) => {\n\t\t\t\tthis.queuedPromise!.then(c, e);\n\t\t\t});\n\t\t}\n\n\t\tthis.activePromise = promiseFactory();\n\n\t\treturn new Promise((c, e) => {\n\t\t\tthis.activePromise!.then((result: any) => {\n\t\t\t\tthis.activePromise = null;\n\t\t\t\tc(result);\n\t\t\t}, (err: any) => {\n\t\t\t\tthis.activePromise = null;\n\t\t\t\te(err);\n\t\t\t});\n\t\t});\n\t}\n}\n\nexport class Sequencer {\n\n\tprivate current: Promise<any> = Promise.resolve(null);\n\n\tqueue<T>(promiseTask: ITask<Promise<T>>): Promise<T> {\n\t\treturn this.current = this.current.then(() => promiseTask());\n\t}\n}\n\n/**\n * A helper to delay execution of a task that is being requested often.\n *\n * Following the throttler, now imagine the mail man wants to optimize the number of\n * trips proactively. The trip itself can be long, so he decides not to make the trip\n * as soon as a letter is submitted. Instead he waits a while, in case more\n * letters are submitted. After said waiting period, if no letters were submitted, he\n * decides to make the trip. Imagine that N more letters were submitted after the first\n * one, all within a short period of time between each other. Even though N+1\n * submissions occurred, only 1 delivery was made.\n *\n * The delayer offers this behavior via the trigger() method, into which both the task\n * to be executed and the waiting period (delay) must be passed in as arguments. Following\n * the example:\n *\n * \t\tconst delayer = new Delayer(WAITING_PERIOD);\n * \t\tconst letters = [];\n *\n * \t\tfunction letterReceived(l) {\n * \t\t\tletters.push(l);\n * \t\t\tdelayer.trigger(() => { return makeTheTrip(); });\n * \t\t}\n */\nexport class Delayer<T> implements IDisposable {\n\n\tprivate timeout: any;\n\tprivate completionPromise: Promise<any> | null;\n\tprivate doResolve: ((value?: any | Promise<any>) => void) | null;\n\tprivate doReject: ((err: any) => void) | null;\n\tprivate task: ITask<T | Promise<T>> | null;\n\n\tconstructor(public defaultDelay: number) {\n\t\tthis.timeout = null;\n\t\tthis.completionPromise = null;\n\t\tthis.doResolve = null;\n\t\tthis.doReject = null;\n\t\tthis.task = null;\n\t}\n\n\ttrigger(task: ITask<T | Promise<T>>, delay: number = this.defaultDelay): Promise<T> {\n\t\tthis.task = task;\n\t\tthis.cancelTimeout();\n\n\t\tif (!this.completionPromise) {\n\t\t\tthis.completionPromise = new Promise((c, e) => {\n\t\t\t\tthis.doResolve = c;\n\t\t\t\tthis.doReject = e;\n\t\t\t}).then(() => {\n\t\t\t\tthis.completionPromise = null;\n\t\t\t\tthis.doResolve = null;\n\t\t\t\tif (this.task) {\n\t\t\t\t\tconst task = this.task;\n\t\t\t\t\tthis.task = null;\n\t\t\t\t\treturn task();\n\t\t\t\t}\n\t\t\t\treturn undefined;\n\t\t\t});\n\t\t}\n\n\t\tthis.timeout = setTimeout(() => {\n\t\t\tthis.timeout = null;\n\t\t\tif (this.doResolve) {\n\t\t\t\tthis.doResolve(null);\n\t\t\t}\n\t\t}, delay);\n\n\t\treturn this.completionPromise;\n\t}\n\n\tisTriggered(): boolean {\n\t\treturn this.timeout !== null;\n\t}\n\n\tcancel(): void {\n\t\tthis.cancelTimeout();\n\n\t\tif (this.completionPromise) {\n\t\t\tif (this.doReject) {\n\t\t\t\tthis.doReject(errors.canceled());\n\t\t\t}\n\t\t\tthis.completionPromise = null;\n\t\t}\n\t}\n\n\tprivate cancelTimeout(): void {\n\t\tif (this.timeout !== null) {\n\t\t\tclearTimeout(this.timeout);\n\t\t\tthis.timeout = null;\n\t\t}\n\t}\n\n\tdispose(): void {\n\t\tthis.cancelTimeout();\n\t}\n}\n\n/**\n * A helper to delay execution of a task that is being requested often, while\n * preventing accumulation of consecutive executions, while the task runs.\n *\n * The mail man is clever and waits for a certain amount of time, before going\n * out to deliver letters. While the mail man is going out, more letters arrive\n * and can only be delivered once he is back. Once he is back the mail man will\n * do one more trip to deliver the letters that have accumulated while he was out.\n */\nexport class ThrottledDelayer<T> {\n\n\tprivate delayer: Delayer<Promise<T>>;\n\tprivate throttler: Throttler;\n\n\tconstructor(defaultDelay: number) {\n\t\tthis.delayer = new Delayer(defaultDelay);\n\t\tthis.throttler = new Throttler();\n\t}\n\n\ttrigger(promiseFactory: ITask<Promise<T>>, delay?: number): Promise<T> {\n\t\treturn this.delayer.trigger(() => this.throttler.queue(promiseFactory), delay) as any as Promise<T>;\n\t}\n\n\tisTriggered(): boolean {\n\t\treturn this.delayer.isTriggered();\n\t}\n\n\tcancel(): void {\n\t\tthis.delayer.cancel();\n\t}\n\n\tdispose(): void {\n\t\tthis.delayer.dispose();\n\t}\n}\n\n/**\n * A barrier that is initially closed and then becomes opened permanently.\n */\nexport class Barrier {\n\n\tprivate _isOpen: boolean;\n\tprivate _promise: Promise<boolean>;\n\tprivate _completePromise!: (v: boolean) => void;\n\n\tconstructor() {\n\t\tthis._isOpen = false;\n\t\tthis._promise = new Promise<boolean>((c, e) => {\n\t\t\tthis._completePromise = c;\n\t\t});\n\t}\n\n\tisOpen(): boolean {\n\t\treturn this._isOpen;\n\t}\n\n\topen(): void {\n\t\tthis._isOpen = true;\n\t\tthis._completePromise(true);\n\t}\n\n\twait(): Promise<boolean> {\n\t\treturn this._promise;\n\t}\n}\n\nexport function timeout(millis: number): CancelablePromise<void>;\nexport function timeout(millis: number, token: CancellationToken): Promise<void>;\nexport function timeout(millis: number, token?: CancellationToken): CancelablePromise<void> | Promise<void> {\n\tif (!token) {\n\t\treturn createCancelablePromise(token => timeout(millis, token));\n\t}\n\n\treturn new Promise((resolve, reject) => {\n\t\tconst handle = setTimeout(resolve, millis);\n\t\ttoken.onCancellationRequested(() => {\n\t\t\tclearTimeout(handle);\n\t\t\treject(errors.canceled());\n\t\t});\n\t});\n}\n\nexport function disposableTimeout(handler: () => void, timeout = 0): IDisposable {\n\tconst timer = setTimeout(handler, timeout);\n\treturn toDisposable(() => clearTimeout(timer));\n}\n\nexport function ignoreErrors<T>(promise: Promise<T>): Promise<T | undefined> {\n\treturn promise.then(undefined, _ => undefined);\n}\n\n/**\n * Runs the provided list of promise factories in sequential order. The returned\n * promise will complete to an array of results from each promise.\n */\n\nexport function sequence<T>(promiseFactories: ITask<Promise<T>>[]): Promise<T[]> {\n\tconst results: T[] = [];\n\tlet index = 0;\n\tconst len = promiseFactories.length;\n\n\tfunction next(): Promise<T> | null {\n\t\treturn index < len ? promiseFactories[index++]() : null;\n\t}\n\n\tfunction thenHandler(result: any): Promise<any> {\n\t\tif (result !== undefined && result !== null) {\n\t\t\tresults.push(result);\n\t\t}\n\n\t\tconst n = next();\n\t\tif (n) {\n\t\t\treturn n.then(thenHandler);\n\t\t}\n\n\t\treturn Promise.resolve(results);\n\t}\n\n\treturn Promise.resolve(null).then(thenHandler);\n}\n\nexport function first<T>(promiseFactories: ITask<Promise<T>>[], shouldStop: (t: T) => boolean = t => !!t, defaultValue: T | null = null): Promise<T | null> {\n\tlet index = 0;\n\tconst len = promiseFactories.length;\n\n\tconst loop: () => Promise<T | null> = () => {\n\t\tif (index >= len) {\n\t\t\treturn Promise.resolve(defaultValue);\n\t\t}\n\n\t\tconst factory = promiseFactories[index++];\n\t\tconst promise = Promise.resolve(factory());\n\n\t\treturn promise.then(result => {\n\t\t\tif (shouldStop(result)) {\n\t\t\t\treturn Promise.resolve(result);\n\t\t\t}\n\n\t\t\treturn loop();\n\t\t});\n\t};\n\n\treturn loop();\n}\n\ninterface ILimitedTaskFactory<T> {\n\tfactory: ITask<Promise<T>>;\n\tc: (value?: T | Promise<T>) => void;\n\te: (error?: any) => void;\n}\n\n/**\n * A helper to queue N promises and run them all with a max degree of parallelism. The helper\n * ensures that at any time no more than M promises are running at the same time.\n */\nexport class Limiter<T> {\n\n\tprivate _size = 0;\n\tprivate runningPromises: number;\n\tprivate maxDegreeOfParalellism: number;\n\tprivate outstandingPromises: ILimitedTaskFactory<T>[];\n\tprivate readonly _onFinished: Emitter<void>;\n\n\tconstructor(maxDegreeOfParalellism: number) {\n\t\tthis.maxDegreeOfParalellism = maxDegreeOfParalellism;\n\t\tthis.outstandingPromises = [];\n\t\tthis.runningPromises = 0;\n\t\tthis._onFinished = new Emitter<void>();\n\t}\n\n\tget onFinished(): Event<void> {\n\t\treturn this._onFinished.event;\n\t}\n\n\tget size(): number {\n\t\treturn this._size;\n\t\t// return this.runningPromises + this.outstandingPromises.length;\n\t}\n\n\tqueue(factory: ITask<Promise<T>>): Promise<T> {\n\t\tthis._size++;\n\n\t\treturn new Promise<T>((c, e) => {\n\t\t\tthis.outstandingPromises.push({ factory, c, e });\n\t\t\tthis.consume();\n\t\t});\n\t}\n\n\tprivate consume(): void {\n\t\twhile (this.outstandingPromises.length && this.runningPromises < this.maxDegreeOfParalellism) {\n\t\t\tconst iLimitedTask = this.outstandingPromises.shift()!;\n\t\t\tthis.runningPromises++;\n\n\t\t\tconst promise = iLimitedTask.factory();\n\t\t\tpromise.then(iLimitedTask.c, iLimitedTask.e);\n\t\t\tpromise.then(() => this.consumed(), () => this.consumed());\n\t\t}\n\t}\n\n\tprivate consumed(): void {\n\t\tthis._size--;\n\t\tthis.runningPromises--;\n\n\t\tif (this.outstandingPromises.length > 0) {\n\t\t\tthis.consume();\n\t\t} else {\n\t\t\tthis._onFinished.fire();\n\t\t}\n\t}\n\n\tdispose(): void {\n\t\tthis._onFinished.dispose();\n\t}\n}\n\n/**\n * A queue is handles one promise at a time and guarantees that at any time only one promise is executing.\n */\nexport class Queue<T> extends Limiter<T> {\n\n\tconstructor() {\n\t\tsuper(1);\n\t}\n}\n\n/**\n * A helper to organize queues per resource. The ResourceQueue makes sure to manage queues per resource\n * by disposing them once the queue is empty.\n */\nexport class ResourceQueue implements IDisposable {\n\n\tprivate readonly queues = new Map<string, Queue<void>>();\n\n\tqueueFor(resource: URI): Queue<void> {\n\t\tconst key = resource.toString();\n\t\tif (!this.queues.has(key)) {\n\t\t\tconst queue = new Queue<void>();\n\t\t\tqueue.onFinished(() => {\n\t\t\t\tqueue.dispose();\n\t\t\t\tthis.queues.delete(key);\n\t\t\t});\n\n\t\t\tthis.queues.set(key, queue);\n\t\t}\n\n\t\treturn this.queues.get(key)!;\n\t}\n\n\tdispose(): void {\n\t\tthis.queues.forEach(queue => queue.dispose());\n\t\tthis.queues.clear();\n\t}\n}\n\nexport class TimeoutTimer implements IDisposable {\n\tprivate _token: any;\n\n\tconstructor();\n\tconstructor(runner: () => void, timeout: number);\n\tconstructor(runner?: () => void, timeout?: number) {\n\t\tthis._token = -1;\n\n\t\tif (typeof runner === 'function' && typeof timeout === 'number') {\n\t\t\tthis.setIfNotSet(runner, timeout);\n\t\t}\n\t}\n\n\tdispose(): void {\n\t\tthis.cancel();\n\t}\n\n\tcancel(): void {\n\t\tif (this._token !== -1) {\n\t\t\tclearTimeout(this._token);\n\t\t\tthis._token = -1;\n\t\t}\n\t}\n\n\tcancelAndSet(runner: () => void, timeout: number): void {\n\t\tthis.cancel();\n\t\tthis._token = setTimeout(() => {\n\t\t\tthis._token = -1;\n\t\t\trunner();\n\t\t}, timeout);\n\t}\n\n\tsetIfNotSet(runner: () => void, timeout: number): void {\n\t\tif (this._token !== -1) {\n\t\t\t// timer is already set\n\t\t\treturn;\n\t\t}\n\t\tthis._token = setTimeout(() => {\n\t\t\tthis._token = -1;\n\t\t\trunner();\n\t\t}, timeout);\n\t}\n}\n\nexport class IntervalTimer implements IDisposable {\n\n\tprivate _token: any;\n\n\tconstructor() {\n\t\tthis._token = -1;\n\t}\n\n\tdispose(): void {\n\t\tthis.cancel();\n\t}\n\n\tcancel(): void {\n\t\tif (this._token !== -1) {\n\t\t\tclearInterval(this._token);\n\t\t\tthis._token = -1;\n\t\t}\n\t}\n\n\tcancelAndSet(runner: () => void, interval: number): void {\n\t\tthis.cancel();\n\t\tthis._token = setInterval(() => {\n\t\t\trunner();\n\t\t}, interval);\n\t}\n}\n\nexport class RunOnceScheduler {\n\n\tprotected runner: ((...args: any[]) => void) | null;\n\n\tprivate timeoutToken: any;\n\tprivate timeout: number;\n\tprivate timeoutHandler: () => void;\n\n\tconstructor(runner: (...args: any[]) => void, timeout: number) {\n\t\tthis.timeoutToken = -1;\n\t\tthis.runner = runner;\n\t\tthis.timeout = timeout;\n\t\tthis.timeoutHandler = this.onTimeout.bind(this);\n\t}\n\n\t/**\n\t * Dispose RunOnceScheduler\n\t */\n\tdispose(): void {\n\t\tthis.cancel();\n\t\tthis.runner = null;\n\t}\n\n\t/**\n\t * Cancel current scheduled runner (if any).\n\t */\n\tcancel(): void {\n\t\tif (this.isScheduled()) {\n\t\t\tclearTimeout(this.timeoutToken);\n\t\t\tthis.timeoutToken = -1;\n\t\t}\n\t}\n\n\t/**\n\t * Cancel previous runner (if any) & schedule a new runner.\n\t */\n\tschedule(delay = this.timeout): void {\n\t\tthis.cancel();\n\t\tthis.timeoutToken = setTimeout(this.timeoutHandler, delay);\n\t}\n\n\t/**\n\t * Returns true if scheduled.\n\t */\n\tisScheduled(): boolean {\n\t\treturn this.timeoutToken !== -1;\n\t}\n\n\tprivate onTimeout() {\n\t\tthis.timeoutToken = -1;\n\t\tif (this.runner) {\n\t\t\tthis.doRun();\n\t\t}\n\t}\n\n\tprotected doRun(): void {\n\t\tif (this.runner) {\n\t\t\tthis.runner();\n\t\t}\n\t}\n}\n\nexport class RunOnceWorker<T> extends RunOnceScheduler {\n\tprivate units: T[] = [];\n\n\tconstructor(runner: (units: T[]) => void, timeout: number) {\n\t\tsuper(runner, timeout);\n\t}\n\n\twork(unit: T): void {\n\t\tthis.units.push(unit);\n\n\t\tif (!this.isScheduled()) {\n\t\t\tthis.schedule();\n\t\t}\n\t}\n\n\tprotected doRun(): void {\n\t\tconst units = this.units;\n\t\tthis.units = [];\n\n\t\tif (this.runner) {\n\t\t\tthis.runner(units);\n\t\t}\n\t}\n\n\tdispose(): void {\n\t\tthis.units = [];\n\n\t\tsuper.dispose();\n\t}\n}\n\n//#region -- run on idle tricks ------------\n\nexport interface IdleDeadline {\n\treadonly didTimeout: boolean;\n\ttimeRemaining(): number;\n}\n/**\n * Execute the callback the next time the browser is idle\n */\nexport let runWhenIdle: (callback: (idle: IdleDeadline) => void, timeout?: number) => IDisposable;\n\ndeclare function requestIdleCallback(callback: (args: IdleDeadline) => void, options?: { timeout: number }): number;\ndeclare function cancelIdleCallback(handle: number): void;\n\n(function () {\n\tif (typeof requestIdleCallback !== 'function' || typeof cancelIdleCallback !== 'function') {\n\t\tconst dummyIdle: IdleDeadline = Object.freeze({\n\t\t\tdidTimeout: true,\n\t\t\ttimeRemaining() { return 15; }\n\t\t});\n\t\trunWhenIdle = (runner) => {\n\t\t\tconst handle = setTimeout(() => runner(dummyIdle));\n\t\t\tlet disposed = false;\n\t\t\treturn {\n\t\t\t\tdispose() {\n\t\t\t\t\tif (disposed) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tdisposed = true;\n\t\t\t\t\tclearTimeout(handle);\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\t} else {\n\t\trunWhenIdle = (runner, timeout?) => {\n\t\t\tconst handle: number = requestIdleCallback(runner, typeof timeout === 'number' ? { timeout } : undefined);\n\t\t\tlet disposed = false;\n\t\t\treturn {\n\t\t\t\tdispose() {\n\t\t\t\t\tif (disposed) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tdisposed = true;\n\t\t\t\t\tcancelIdleCallback(handle);\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\t}\n})();\n\n/**\n * An implementation of the \"idle-until-urgent\"-strategy as introduced\n * here: https://philipwalton.com/articles/idle-until-urgent/\n */\nexport class IdleValue<T> {\n\n\tprivate readonly _executor: () => void;\n\tprivate readonly _handle: IDisposable;\n\n\tprivate _didRun: boolean = false;\n\tprivate _value?: T;\n\tprivate _error: any;\n\n\tconstructor(executor: () => T) {\n\t\tthis._executor = () => {\n\t\t\ttry {\n\t\t\t\tthis._value = executor();\n\t\t\t} catch (err) {\n\t\t\t\tthis._error = err;\n\t\t\t} finally {\n\t\t\t\tthis._didRun = true;\n\t\t\t}\n\t\t};\n\t\tthis._handle = runWhenIdle(() => this._executor());\n\t}\n\n\tdispose(): void {\n\t\tthis._handle.dispose();\n\t}\n\n\tget value(): T {\n\t\tif (!this._didRun) {\n\t\t\tthis._handle.dispose();\n\t\t\tthis._executor();\n\t\t}\n\t\tif (this._error) {\n\t\t\tthrow this._error;\n\t\t}\n\t\treturn this._value!;\n\t}\n}\n\n//#endregion\n\nexport async function retry<T>(task: ITask<Promise<T>>, delay: number, retries: number): Promise<T> {\n\tlet lastError: Error | undefined;\n\n\tfor (let i = 0; i < retries; i++) {\n\t\ttry {\n\t\t\treturn await task();\n\t\t} catch (error) {\n\t\t\tlastError = error;\n\n\t\t\tawait timeout(delay);\n\t\t}\n\t}\n\n\tthrow lastError;\n}\n\n//#region Task Sequentializer\n\ninterface IPendingTask {\n\ttaskId: number;\n\tcancel: () => void;\n\tpromise: Promise<void>;\n}\n\ninterface ISequentialTask {\n\tpromise: Promise<void>;\n\tpromiseResolve: () => void;\n\tpromiseReject: (error: Error) => void;\n\trun: () => Promise<void>;\n}\n\nexport interface ITaskSequentializerWithPendingTask {\n\treadonly pending: Promise<void>;\n}\n\nexport class TaskSequentializer {\n\tprivate _pending?: IPendingTask;\n\tprivate _next?: ISequentialTask;\n\n\thasPending(taskId?: number): this is ITaskSequentializerWithPendingTask {\n\t\tif (!this._pending) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (typeof taskId === 'number') {\n\t\t\treturn this._pending.taskId === taskId;\n\t\t}\n\n\t\treturn !!this._pending;\n\t}\n\n\tget pending(): Promise<void> | undefined {\n\t\treturn this._pending ? this._pending.promise : undefined;\n\t}\n\n\tcancelPending(): void {\n\t\tthis._pending?.cancel();\n\t}\n\n\tsetPending(taskId: number, promise: Promise<void>, onCancel?: () => void,): Promise<void> {\n\t\tthis._pending = { taskId: taskId, cancel: () => onCancel?.(), promise };\n\n\t\tpromise.then(() => this.donePending(taskId), () => this.donePending(taskId));\n\n\t\treturn promise;\n\t}\n\n\tprivate donePending(taskId: number): void {\n\t\tif (this._pending && taskId === this._pending.taskId) {\n\n\t\t\t// only set pending to done if the promise finished that is associated with that taskId\n\t\t\tthis._pending = undefined;\n\n\t\t\t// schedule the next task now that we are free if we have any\n\t\t\tthis.triggerNext();\n\t\t}\n\t}\n\n\tprivate triggerNext(): void {\n\t\tif (this._next) {\n\t\t\tconst next = this._next;\n\t\t\tthis._next = undefined;\n\n\t\t\t// Run next task and complete on the associated promise\n\t\t\tnext.run().then(next.promiseResolve, next.promiseReject);\n\t\t}\n\t}\n\n\tsetNext(run: () => Promise<void>): Promise<void> {\n\n\t\t// this is our first next task, so we create associated promise with it\n\t\t// so that we can return a promise that completes when the task has\n\t\t// completed.\n\t\tif (!this._next) {\n\t\t\tlet promiseResolve: () => void;\n\t\t\tlet promiseReject: (error: Error) => void;\n\t\t\tconst promise = new Promise<void>((resolve, reject) => {\n\t\t\t\tpromiseResolve = resolve;\n\t\t\t\tpromiseReject = reject;\n\t\t\t});\n\n\t\t\tthis._next = {\n\t\t\t\trun,\n\t\t\t\tpromise,\n\t\t\t\tpromiseResolve: promiseResolve!,\n\t\t\t\tpromiseReject: promiseReject!\n\t\t\t};\n\t\t}\n\n\t\t// we have a previous next task, just overwrite it\n\t\telse {\n\t\t\tthis._next.run = run;\n\t\t}\n\n\t\treturn this._next.promise;\n\t}\n}\n\n//#endregion\n","interface ISetImmediate {\n      (callback: (...args: any[]) => void): void;\n    }\n    \n    const _globals = (typeof self === 'object' ? self : typeof global === 'object' ? global : {} as any);\n    export const globals: any = _globals;\n\n    export const isWindows = false;\n    export const isMacintosh = false;\n\n    export const setImmediate: ISetImmediate = (function defineSetImmediate() {\n      if (globals.setImmediate) {\n        return globals.setImmediate.bind(globals);\n      }\n      if (typeof globals.postMessage === 'function' && !globals.importScripts) {\n        interface IQueueElement {\n          id: number;\n          callback: () => void;\n        }\n        let pending: IQueueElement[] = [];\n        globals.addEventListener('message', (e: MessageEvent) => {\n          if (e.data && e.data.vscodeSetImmediateId) {\n            for (let i = 0, len = pending.length; i < len; i++) {\n              const candidate = pending[i];\n              if (candidate.id === e.data.vscodeSetImmediateId) {\n                pending.splice(i, 1);\n                candidate.callback();\n                return;\n              }\n            }\n          }\n        });\n        let lastId = 0;\n        return (callback: () => void) => {\n          const myId = ++lastId;\n          pending.push({\n            id: myId,\n            callback: callback\n          });\n          globals.postMessage({ vscodeSetImmediateId: myId }, '*');\n        };\n      }\n      if (typeof process !== 'undefined' && typeof process.nextTick === 'function') {\n        return process.nextTick.bind(process);\n      }\n      const _promise = Promise.resolve();\n      return (callback: (...args: any[]) => void) => _promise.then(callback);\n    })();\n  ","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { isWindows, isMacintosh, setImmediate, IProcessEnvironment } from 'vs/base/common/platform';\n\ninterface IProcess {\n\tplatform: string;\n\tenv: IProcessEnvironment;\n\n\tcwd(): string;\n\tnextTick(callback: (...args: any[]) => void): void;\n}\n\ndeclare const process: IProcess;\nconst safeProcess: IProcess = (typeof process === 'undefined') ? {\n\tcwd(): string { return '/'; },\n\tenv: Object.create(null),\n\tget platform(): string { return isWindows ? 'win32' : isMacintosh ? 'darwin' : 'linux'; },\n\tnextTick(callback: (...args: any[]) => void): void { return setImmediate(callback); }\n} : process;\n\nexport const cwd = safeProcess.cwd;\nexport const env = safeProcess.env;\nexport const platform = safeProcess.platform;\nexport const nextTick = safeProcess.nextTick;\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n// NOTE: VSCode's copy of nodejs path library to be usable in common (non-node) namespace\n// Copied from: https://github.com/nodejs/node/blob/v12.8.1/lib/path.js\n\n/**\n * Copyright Joyent, Inc. and other Node contributors.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to permit\n * persons to whom the Software is furnished to do so, subject to the\n * following conditions:\n *\n * The above copyright notice and this permission notice shall be included\n * in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n * NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n * USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\nimport * as process from 'vs/base/common/process';\n\nconst CHAR_UPPERCASE_A = 65;/* A */\nconst CHAR_LOWERCASE_A = 97; /* a */\nconst CHAR_UPPERCASE_Z = 90; /* Z */\nconst CHAR_LOWERCASE_Z = 122; /* z */\nconst CHAR_DOT = 46; /* . */\nconst CHAR_FORWARD_SLASH = 47; /* / */\nconst CHAR_BACKWARD_SLASH = 92; /* \\ */\nconst CHAR_COLON = 58; /* : */\nconst CHAR_QUESTION_MARK = 63; /* ? */\n\nclass ErrorInvalidArgType extends Error {\n\tcode: 'ERR_INVALID_ARG_TYPE';\n\tconstructor(name: string, expected: string, actual: any) {\n\t\t// determiner: 'must be' or 'must not be'\n\t\tlet determiner;\n\t\tif (typeof expected === 'string' && expected.indexOf('not ') === 0) {\n\t\t\tdeterminer = 'must not be';\n\t\t\texpected = expected.replace(/^not /, '');\n\t\t} else {\n\t\t\tdeterminer = 'must be';\n\t\t}\n\n\t\tconst type = name.indexOf('.') !== -1 ? 'property' : 'argument';\n\t\tlet msg = `The \"${name}\" ${type} ${determiner} of type ${expected}`;\n\n\t\tmsg += `. Received type ${typeof actual}`;\n\t\tsuper(msg);\n\n\t\tthis.code = 'ERR_INVALID_ARG_TYPE';\n\t}\n}\n\nfunction validateString(value: string, name: string) {\n\tif (typeof value !== 'string') {\n\t\tthrow new ErrorInvalidArgType(name, 'string', value);\n\t}\n}\n\nfunction isPathSeparator(code: number | undefined) {\n\treturn code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;\n}\n\nfunction isPosixPathSeparator(code: number | undefined) {\n\treturn code === CHAR_FORWARD_SLASH;\n}\n\nfunction isWindowsDeviceRoot(code: number) {\n\treturn code >= CHAR_UPPERCASE_A && code <= CHAR_UPPERCASE_Z ||\n\t\tcode >= CHAR_LOWERCASE_A && code <= CHAR_LOWERCASE_Z;\n}\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeString(path: string, allowAboveRoot: boolean, separator: string, isPathSeparator: (code?: number) => boolean) {\n\tlet res = '';\n\tlet lastSegmentLength = 0;\n\tlet lastSlash = -1;\n\tlet dots = 0;\n\tlet code = 0;\n\tfor (let i = 0; i <= path.length; ++i) {\n\t\tif (i < path.length) {\n\t\t\tcode = path.charCodeAt(i);\n\t\t}\n\t\telse if (isPathSeparator(code)) {\n\t\t\tbreak;\n\t\t}\n\t\telse {\n\t\t\tcode = CHAR_FORWARD_SLASH;\n\t\t}\n\n\t\tif (isPathSeparator(code)) {\n\t\t\tif (lastSlash === i - 1 || dots === 1) {\n\t\t\t\t// NOOP\n\t\t\t} else if (dots === 2) {\n\t\t\t\tif (res.length < 2 || lastSegmentLength !== 2 ||\n\t\t\t\t\tres.charCodeAt(res.length - 1) !== CHAR_DOT ||\n\t\t\t\t\tres.charCodeAt(res.length - 2) !== CHAR_DOT) {\n\t\t\t\t\tif (res.length > 2) {\n\t\t\t\t\t\tconst lastSlashIndex = res.lastIndexOf(separator);\n\t\t\t\t\t\tif (lastSlashIndex === -1) {\n\t\t\t\t\t\t\tres = '';\n\t\t\t\t\t\t\tlastSegmentLength = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tres = res.slice(0, lastSlashIndex);\n\t\t\t\t\t\t\tlastSegmentLength = res.length - 1 - res.lastIndexOf(separator);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlastSlash = i;\n\t\t\t\t\t\tdots = 0;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else if (res.length !== 0) {\n\t\t\t\t\t\tres = '';\n\t\t\t\t\t\tlastSegmentLength = 0;\n\t\t\t\t\t\tlastSlash = i;\n\t\t\t\t\t\tdots = 0;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (allowAboveRoot) {\n\t\t\t\t\tres += res.length > 0 ? `${separator}..` : '..';\n\t\t\t\t\tlastSegmentLength = 2;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (res.length > 0) {\n\t\t\t\t\tres += `${separator}${path.slice(lastSlash + 1, i)}`;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tres = path.slice(lastSlash + 1, i);\n\t\t\t\t}\n\t\t\t\tlastSegmentLength = i - lastSlash - 1;\n\t\t\t}\n\t\t\tlastSlash = i;\n\t\t\tdots = 0;\n\t\t} else if (code === CHAR_DOT && dots !== -1) {\n\t\t\t++dots;\n\t\t} else {\n\t\t\tdots = -1;\n\t\t}\n\t}\n\treturn res;\n}\n\nfunction _format(sep: string, pathObject: ParsedPath) {\n\tif (pathObject === null || typeof pathObject !== 'object') {\n\t\tthrow new ErrorInvalidArgType('pathObject', 'Object', pathObject);\n\t}\n\tconst dir = pathObject.dir || pathObject.root;\n\tconst base = pathObject.base ||\n\t\t`${pathObject.name || ''}${pathObject.ext || ''}`;\n\tif (!dir) {\n\t\treturn base;\n\t}\n\treturn dir === pathObject.root ? `${dir}${base}` : `${dir}${sep}${base}`;\n}\n\nexport interface ParsedPath {\n\troot: string;\n\tdir: string;\n\tbase: string;\n\text: string;\n\tname: string;\n}\n\nexport interface IPath {\n\tnormalize(path: string): string;\n\tisAbsolute(path: string): boolean;\n\tjoin(...paths: string[]): string;\n\tresolve(...pathSegments: string[]): string;\n\trelative(from: string, to: string): string;\n\tdirname(path: string): string;\n\tbasename(path: string, ext?: string): string;\n\textname(path: string): string;\n\tformat(pathObject: ParsedPath): string;\n\tparse(path: string): ParsedPath;\n\ttoNamespacedPath(path: string): string;\n\tsep: '\\\\' | '/';\n\tdelimiter: string;\n\twin32: IPath | null;\n\tposix: IPath | null;\n}\n\nexport const win32: IPath = {\n\t// path.resolve([from ...], to)\n\tresolve(...pathSegments: string[]): string {\n\t\tlet resolvedDevice = '';\n\t\tlet resolvedTail = '';\n\t\tlet resolvedAbsolute = false;\n\n\t\tfor (let i = pathSegments.length - 1; i >= -1; i--) {\n\t\t\tlet path;\n\t\t\tif (i >= 0) {\n\t\t\t\tpath = pathSegments[i];\n\t\t\t\tvalidateString(path, 'path');\n\n\t\t\t\t// Skip empty entries\n\t\t\t\tif (path.length === 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else if (resolvedDevice.length === 0) {\n\t\t\t\tpath = process.cwd();\n\t\t\t} else {\n\t\t\t\t// Windows has the concept of drive-specific current working\n\t\t\t\t// directories. If we've resolved a drive letter but not yet an\n\t\t\t\t// absolute path, get cwd for that drive, or the process cwd if\n\t\t\t\t// the drive cwd is not available. We're sure the device is not\n\t\t\t\t// a UNC path at this points, because UNC paths are always absolute.\n\t\t\t\tpath = (process.env as any)[`=${resolvedDevice}`] || process.cwd();\n\n\t\t\t\t// Verify that a cwd was found and that it actually points\n\t\t\t\t// to our drive. If not, default to the drive's root.\n\t\t\t\tif (path === undefined ||\n\t\t\t\t\tpath.slice(0, 2).toLowerCase() !== resolvedDevice.toLowerCase() &&\n\t\t\t\t\tpath.charCodeAt(2) === CHAR_BACKWARD_SLASH) {\n\t\t\t\t\tpath = `${resolvedDevice}\\\\`;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst len = path.length;\n\t\t\tlet rootEnd = 0;\n\t\t\tlet device = '';\n\t\t\tlet isAbsolute = false;\n\t\t\tconst code = path.charCodeAt(0);\n\n\t\t\t// Try to match a root\n\t\t\tif (len === 1) {\n\t\t\t\tif (isPathSeparator(code)) {\n\t\t\t\t\t// `path` contains just a path separator\n\t\t\t\t\trootEnd = 1;\n\t\t\t\t\tisAbsolute = true;\n\t\t\t\t}\n\t\t\t} else if (isPathSeparator(code)) {\n\t\t\t\t// Possible UNC root\n\n\t\t\t\t// If we started with a separator, we know we at least have an\n\t\t\t\t// absolute path of some kind (UNC or otherwise)\n\t\t\t\tisAbsolute = true;\n\n\t\t\t\tif (isPathSeparator(path.charCodeAt(1))) {\n\t\t\t\t\t// Matched double path separator at beginning\n\t\t\t\t\tlet j = 2;\n\t\t\t\t\tlet last = j;\n\t\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\tj++;\n\t\t\t\t\t}\n\t\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\t\tconst firstPart = path.slice(last, j);\n\t\t\t\t\t\t// Matched!\n\t\t\t\t\t\tlast = j;\n\t\t\t\t\t\t// Match 1 or more path separators\n\t\t\t\t\t\twhile (j < len && isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\t\t\t// Matched!\n\t\t\t\t\t\t\tlast = j;\n\t\t\t\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (j === len || j !== last) {\n\t\t\t\t\t\t\t\t// We matched a UNC root\n\t\t\t\t\t\t\t\tdevice = `\\\\\\\\${firstPart}\\\\${path.slice(last, j)}`;\n\t\t\t\t\t\t\t\trootEnd = j;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\trootEnd = 1;\n\t\t\t\t}\n\t\t\t} else if (isWindowsDeviceRoot(code) &&\n\t\t\t\tpath.charCodeAt(1) === CHAR_COLON) {\n\t\t\t\t// Possible device root\n\t\t\t\tdevice = path.slice(0, 2);\n\t\t\t\trootEnd = 2;\n\t\t\t\tif (len > 2 && isPathSeparator(path.charCodeAt(2))) {\n\t\t\t\t\t// Treat separator following drive name as an absolute path\n\t\t\t\t\t// indicator\n\t\t\t\t\tisAbsolute = true;\n\t\t\t\t\trootEnd = 3;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (device.length > 0) {\n\t\t\t\tif (resolvedDevice.length > 0) {\n\t\t\t\t\tif (device.toLowerCase() !== resolvedDevice.toLowerCase()) {\n\t\t\t\t\t\t// This path points to another device so it is not applicable\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tresolvedDevice = device;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (resolvedAbsolute) {\n\t\t\t\tif (resolvedDevice.length > 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tresolvedTail = `${path.slice(rootEnd)}\\\\${resolvedTail}`;\n\t\t\t\tresolvedAbsolute = isAbsolute;\n\t\t\t\tif (isAbsolute && resolvedDevice.length > 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// At this point the path should be resolved to a full absolute path,\n\t\t// but handle relative paths to be safe (might happen when process.cwd()\n\t\t// fails)\n\n\t\t// Normalize the tail path\n\t\tresolvedTail = normalizeString(resolvedTail, !resolvedAbsolute, '\\\\',\n\t\t\tisPathSeparator);\n\n\t\treturn resolvedAbsolute ?\n\t\t\t`${resolvedDevice}\\\\${resolvedTail}` :\n\t\t\t`${resolvedDevice}${resolvedTail}` || '.';\n\t},\n\n\tnormalize(path: string): string {\n\t\tvalidateString(path, 'path');\n\t\tconst len = path.length;\n\t\tif (len === 0) {\n\t\t\treturn '.';\n\t\t}\n\t\tlet rootEnd = 0;\n\t\tlet device;\n\t\tlet isAbsolute = false;\n\t\tconst code = path.charCodeAt(0);\n\n\t\t// Try to match a root\n\t\tif (len === 1) {\n\t\t\t// `path` contains just a single char, exit early to avoid\n\t\t\t// unnecessary work\n\t\t\treturn isPosixPathSeparator(code) ? '\\\\' : path;\n\t\t}\n\t\tif (isPathSeparator(code)) {\n\t\t\t// Possible UNC root\n\n\t\t\t// If we started with a separator, we know we at least have an absolute\n\t\t\t// path of some kind (UNC or otherwise)\n\t\t\tisAbsolute = true;\n\n\t\t\tif (isPathSeparator(path.charCodeAt(1))) {\n\t\t\t\t// Matched double path separator at beginning\n\t\t\t\tlet j = 2;\n\t\t\t\tlet last = j;\n\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\tconst firstPart = path.slice(last, j);\n\t\t\t\t\t// Matched!\n\t\t\t\t\tlast = j;\n\t\t\t\t\t// Match 1 or more path separators\n\t\t\t\t\twhile (j < len && isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\tj++;\n\t\t\t\t\t}\n\t\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\t\t// Matched!\n\t\t\t\t\t\tlast = j;\n\t\t\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j === len) {\n\t\t\t\t\t\t\t// We matched a UNC root only\n\t\t\t\t\t\t\t// Return the normalized version of the UNC root since there\n\t\t\t\t\t\t\t// is nothing left to process\n\t\t\t\t\t\t\treturn `\\\\\\\\${firstPart}\\\\${path.slice(last)}\\\\`;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j !== last) {\n\t\t\t\t\t\t\t// We matched a UNC root with leftovers\n\t\t\t\t\t\t\tdevice = `\\\\\\\\${firstPart}\\\\${path.slice(last, j)}`;\n\t\t\t\t\t\t\trootEnd = j;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\trootEnd = 1;\n\t\t\t}\n\t\t} else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {\n\t\t\t// Possible device root\n\t\t\tdevice = path.slice(0, 2);\n\t\t\trootEnd = 2;\n\t\t\tif (len > 2 && isPathSeparator(path.charCodeAt(2))) {\n\t\t\t\t// Treat separator following drive name as an absolute path\n\t\t\t\t// indicator\n\t\t\t\tisAbsolute = true;\n\t\t\t\trootEnd = 3;\n\t\t\t}\n\t\t}\n\n\t\tlet tail = rootEnd < len ?\n\t\t\tnormalizeString(path.slice(rootEnd), !isAbsolute, '\\\\', isPathSeparator) :\n\t\t\t'';\n\t\tif (tail.length === 0 && !isAbsolute) {\n\t\t\ttail = '.';\n\t\t}\n\t\tif (tail.length > 0 && isPathSeparator(path.charCodeAt(len - 1))) {\n\t\t\ttail += '\\\\';\n\t\t}\n\t\tif (device === undefined) {\n\t\t\treturn isAbsolute ? `\\\\${tail}` : tail;\n\t\t}\n\t\treturn isAbsolute ? `${device}\\\\${tail}` : `${device}${tail}`;\n\t},\n\n\tisAbsolute(path: string): boolean {\n\t\tvalidateString(path, 'path');\n\t\tconst len = path.length;\n\t\tif (len === 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst code = path.charCodeAt(0);\n\t\treturn isPathSeparator(code) ||\n\t\t\t// Possible device root\n\t\t\tlen > 2 &&\n\t\t\tisWindowsDeviceRoot(code) &&\n\t\t\tpath.charCodeAt(1) === CHAR_COLON &&\n\t\t\tisPathSeparator(path.charCodeAt(2));\n\t},\n\n\tjoin(...paths: string[]): string {\n\t\tif (paths.length === 0) {\n\t\t\treturn '.';\n\t\t}\n\n\t\tlet joined;\n\t\tlet firstPart: string | undefined;\n\t\tfor (let i = 0; i < paths.length; ++i) {\n\t\t\tconst arg = paths[i];\n\t\t\tvalidateString(arg, 'path');\n\t\t\tif (arg.length > 0) {\n\t\t\t\tif (joined === undefined) {\n\t\t\t\t\tjoined = firstPart = arg;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tjoined += `\\\\${arg}`;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (joined === undefined) {\n\t\t\treturn '.';\n\t\t}\n\n\t\t// Make sure that the joined path doesn't start with two slashes, because\n\t\t// normalize() will mistake it for an UNC path then.\n\t\t//\n\t\t// This step is skipped when it is very clear that the user actually\n\t\t// intended to point at an UNC path. This is assumed when the first\n\t\t// non-empty string arguments starts with exactly two slashes followed by\n\t\t// at least one more non-slash character.\n\t\t//\n\t\t// Note that for normalize() to treat a path as an UNC path it needs to\n\t\t// have at least 2 components, so we don't filter for that here.\n\t\t// This means that the user can use join to construct UNC paths from\n\t\t// a server name and a share name; for example:\n\t\t//   path.join('//server', 'share') -> '\\\\\\\\server\\\\share\\\\')\n\t\tlet needsReplace = true;\n\t\tlet slashCount = 0;\n\t\tif (typeof firstPart === 'string' && isPathSeparator(firstPart.charCodeAt(0))) {\n\t\t\t++slashCount;\n\t\t\tconst firstLen = firstPart.length;\n\t\t\tif (firstLen > 1 && isPathSeparator(firstPart.charCodeAt(1))) {\n\t\t\t\t++slashCount;\n\t\t\t\tif (firstLen > 2) {\n\t\t\t\t\tif (isPathSeparator(firstPart.charCodeAt(2))) {\n\t\t\t\t\t\t++slashCount;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// We matched a UNC path in the first part\n\t\t\t\t\t\tneedsReplace = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (needsReplace) {\n\t\t\t// Find any more consecutive slashes we need to replace\n\t\t\twhile (slashCount < joined.length &&\n\t\t\t\tisPathSeparator(joined.charCodeAt(slashCount))) {\n\t\t\t\tslashCount++;\n\t\t\t}\n\n\t\t\t// Replace the slashes if needed\n\t\t\tif (slashCount >= 2) {\n\t\t\t\tjoined = `\\\\${joined.slice(slashCount)}`;\n\t\t\t}\n\t\t}\n\n\t\treturn win32.normalize(joined);\n\t},\n\n\n\t// It will solve the relative path from `from` to `to`, for instance:\n\t//  from = 'C:\\\\orandea\\\\test\\\\aaa'\n\t//  to = 'C:\\\\orandea\\\\impl\\\\bbb'\n\t// The output of the function should be: '..\\\\..\\\\impl\\\\bbb'\n\trelative(from: string, to: string): string {\n\t\tvalidateString(from, 'from');\n\t\tvalidateString(to, 'to');\n\n\t\tif (from === to) {\n\t\t\treturn '';\n\t\t}\n\n\t\tconst fromOrig = win32.resolve(from);\n\t\tconst toOrig = win32.resolve(to);\n\n\t\tif (fromOrig === toOrig) {\n\t\t\treturn '';\n\t\t}\n\n\t\tfrom = fromOrig.toLowerCase();\n\t\tto = toOrig.toLowerCase();\n\n\t\tif (from === to) {\n\t\t\treturn '';\n\t\t}\n\n\t\t// Trim any leading backslashes\n\t\tlet fromStart = 0;\n\t\twhile (fromStart < from.length &&\n\t\t\tfrom.charCodeAt(fromStart) === CHAR_BACKWARD_SLASH) {\n\t\t\tfromStart++;\n\t\t}\n\t\t// Trim trailing backslashes (applicable to UNC paths only)\n\t\tlet fromEnd = from.length;\n\t\twhile (fromEnd - 1 > fromStart &&\n\t\t\tfrom.charCodeAt(fromEnd - 1) === CHAR_BACKWARD_SLASH) {\n\t\t\tfromEnd--;\n\t\t}\n\t\tconst fromLen = fromEnd - fromStart;\n\n\t\t// Trim any leading backslashes\n\t\tlet toStart = 0;\n\t\twhile (toStart < to.length &&\n\t\t\tto.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {\n\t\t\ttoStart++;\n\t\t}\n\t\t// Trim trailing backslashes (applicable to UNC paths only)\n\t\tlet toEnd = to.length;\n\t\twhile (toEnd - 1 > toStart &&\n\t\t\tto.charCodeAt(toEnd - 1) === CHAR_BACKWARD_SLASH) {\n\t\t\ttoEnd--;\n\t\t}\n\t\tconst toLen = toEnd - toStart;\n\n\t\t// Compare paths to find the longest common path from root\n\t\tconst length = fromLen < toLen ? fromLen : toLen;\n\t\tlet lastCommonSep = -1;\n\t\tlet i = 0;\n\t\tfor (; i < length; i++) {\n\t\t\tconst fromCode = from.charCodeAt(fromStart + i);\n\t\t\tif (fromCode !== to.charCodeAt(toStart + i)) {\n\t\t\t\tbreak;\n\t\t\t} else if (fromCode === CHAR_BACKWARD_SLASH) {\n\t\t\t\tlastCommonSep = i;\n\t\t\t}\n\t\t}\n\n\t\t// We found a mismatch before the first common path separator was seen, so\n\t\t// return the original `to`.\n\t\tif (i !== length) {\n\t\t\tif (lastCommonSep === -1) {\n\t\t\t\treturn toOrig;\n\t\t\t}\n\t\t} else {\n\t\t\tif (toLen > length) {\n\t\t\t\tif (to.charCodeAt(toStart + i) === CHAR_BACKWARD_SLASH) {\n\t\t\t\t\t// We get here if `from` is the exact base path for `to`.\n\t\t\t\t\t// For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo\\\\bar\\\\baz'\n\t\t\t\t\treturn toOrig.slice(toStart + i + 1);\n\t\t\t\t}\n\t\t\t\tif (i === 2) {\n\t\t\t\t\t// We get here if `from` is the device root.\n\t\t\t\t\t// For example: from='C:\\\\'; to='C:\\\\foo'\n\t\t\t\t\treturn toOrig.slice(toStart + i);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (fromLen > length) {\n\t\t\t\tif (from.charCodeAt(fromStart + i) === CHAR_BACKWARD_SLASH) {\n\t\t\t\t\t// We get here if `to` is the exact base path for `from`.\n\t\t\t\t\t// For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo'\n\t\t\t\t\tlastCommonSep = i;\n\t\t\t\t} else if (i === 2) {\n\t\t\t\t\t// We get here if `to` is the device root.\n\t\t\t\t\t// For example: from='C:\\\\foo\\\\bar'; to='C:\\\\'\n\t\t\t\t\tlastCommonSep = 3;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (lastCommonSep === -1) {\n\t\t\t\tlastCommonSep = 0;\n\t\t\t}\n\t\t}\n\n\t\tlet out = '';\n\t\t// Generate the relative path based on the path difference between `to` and\n\t\t// `from`\n\t\tfor (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n\t\t\tif (i === fromEnd || from.charCodeAt(i) === CHAR_BACKWARD_SLASH) {\n\t\t\t\tout += out.length === 0 ? '..' : '\\\\..';\n\t\t\t}\n\t\t}\n\n\t\ttoStart += lastCommonSep;\n\n\t\t// Lastly, append the rest of the destination (`to`) path that comes after\n\t\t// the common path parts\n\t\tif (out.length > 0) {\n\t\t\treturn `${out}${toOrig.slice(toStart, toEnd)}`;\n\t\t}\n\n\t\tif (toOrig.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {\n\t\t\t++toStart;\n\t\t}\n\n\t\treturn toOrig.slice(toStart, toEnd);\n\t},\n\n\ttoNamespacedPath(path: string): string {\n\t\t// Note: this will *probably* throw somewhere.\n\t\tif (typeof path !== 'string') {\n\t\t\treturn path;\n\t\t}\n\n\t\tif (path.length === 0) {\n\t\t\treturn '';\n\t\t}\n\n\t\tconst resolvedPath = win32.resolve(path);\n\n\t\tif (resolvedPath.length <= 2) {\n\t\t\treturn path;\n\t\t}\n\n\t\tif (resolvedPath.charCodeAt(0) === CHAR_BACKWARD_SLASH) {\n\t\t\t// Possible UNC root\n\t\t\tif (resolvedPath.charCodeAt(1) === CHAR_BACKWARD_SLASH) {\n\t\t\t\tconst code = resolvedPath.charCodeAt(2);\n\t\t\t\tif (code !== CHAR_QUESTION_MARK && code !== CHAR_DOT) {\n\t\t\t\t\t// Matched non-long UNC root, convert the path to a long UNC path\n\t\t\t\t\treturn `\\\\\\\\?\\\\UNC\\\\${resolvedPath.slice(2)}`;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (isWindowsDeviceRoot(resolvedPath.charCodeAt(0)) &&\n\t\t\tresolvedPath.charCodeAt(1) === CHAR_COLON &&\n\t\t\tresolvedPath.charCodeAt(2) === CHAR_BACKWARD_SLASH) {\n\t\t\t// Matched device root, convert the path to a long UNC path\n\t\t\treturn `\\\\\\\\?\\\\${resolvedPath}`;\n\t\t}\n\n\t\treturn path;\n\t},\n\n\tdirname(path: string): string {\n\t\tvalidateString(path, 'path');\n\t\tconst len = path.length;\n\t\tif (len === 0) {\n\t\t\treturn '.';\n\t\t}\n\t\tlet rootEnd = -1;\n\t\tlet offset = 0;\n\t\tconst code = path.charCodeAt(0);\n\n\t\tif (len === 1) {\n\t\t\t// `path` contains just a path separator, exit early to avoid\n\t\t\t// unnecessary work or a dot.\n\t\t\treturn isPathSeparator(code) ? path : '.';\n\t\t}\n\n\t\t// Try to match a root\n\t\tif (isPathSeparator(code)) {\n\t\t\t// Possible UNC root\n\n\t\t\trootEnd = offset = 1;\n\n\t\t\tif (isPathSeparator(path.charCodeAt(1))) {\n\t\t\t\t// Matched double path separator at beginning\n\t\t\t\tlet j = 2;\n\t\t\t\tlet last = j;\n\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\t// Matched!\n\t\t\t\t\tlast = j;\n\t\t\t\t\t// Match 1 or more path separators\n\t\t\t\t\twhile (j < len && isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\tj++;\n\t\t\t\t\t}\n\t\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\t\t// Matched!\n\t\t\t\t\t\tlast = j;\n\t\t\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j === len) {\n\t\t\t\t\t\t\t// We matched a UNC root only\n\t\t\t\t\t\t\treturn path;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j !== last) {\n\t\t\t\t\t\t\t// We matched a UNC root with leftovers\n\n\t\t\t\t\t\t\t// Offset by 1 to include the separator after the UNC root to\n\t\t\t\t\t\t\t// treat it as a \"normal root\" on top of a (UNC) root\n\t\t\t\t\t\t\trootEnd = offset = j + 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Possible device root\n\t\t} else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {\n\t\t\trootEnd = len > 2 && isPathSeparator(path.charCodeAt(2)) ? 3 : 2;\n\t\t\toffset = rootEnd;\n\t\t}\n\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\tfor (let i = len - 1; i >= offset; --i) {\n\t\t\tif (isPathSeparator(path.charCodeAt(i))) {\n\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\tend = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// We saw the first non-path separator\n\t\t\t\tmatchedSlash = false;\n\t\t\t}\n\t\t}\n\n\t\tif (end === -1) {\n\t\t\tif (rootEnd === -1) {\n\t\t\t\treturn '.';\n\t\t\t}\n\n\t\t\tend = rootEnd;\n\t\t}\n\t\treturn path.slice(0, end);\n\t},\n\n\tbasename(path: string, ext?: string): string {\n\t\tif (ext !== undefined) {\n\t\t\tvalidateString(ext, 'ext');\n\t\t}\n\t\tvalidateString(path, 'path');\n\t\tlet start = 0;\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\tlet i;\n\n\t\t// Check for a drive letter prefix so as not to mistake the following\n\t\t// path separator as an extra separator at the end of the path that can be\n\t\t// disregarded\n\t\tif (path.length >= 2 &&\n\t\t\tisWindowsDeviceRoot(path.charCodeAt(0)) &&\n\t\t\tpath.charCodeAt(1) === CHAR_COLON) {\n\t\t\tstart = 2;\n\t\t}\n\n\t\tif (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n\t\t\tif (ext === path) {\n\t\t\t\treturn '';\n\t\t\t}\n\t\t\tlet extIdx = ext.length - 1;\n\t\t\tlet firstNonSlashEnd = -1;\n\t\t\tfor (i = path.length - 1; i >= start; --i) {\n\t\t\t\tconst code = path.charCodeAt(i);\n\t\t\t\tif (isPathSeparator(code)) {\n\t\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\t\tstart = i + 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (firstNonSlashEnd === -1) {\n\t\t\t\t\t\t// We saw the first non-path separator, remember this index in case\n\t\t\t\t\t\t// we need it if the extension ends up not matching\n\t\t\t\t\t\tmatchedSlash = false;\n\t\t\t\t\t\tfirstNonSlashEnd = i + 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (extIdx >= 0) {\n\t\t\t\t\t\t// Try to match the explicit extension\n\t\t\t\t\t\tif (code === ext.charCodeAt(extIdx)) {\n\t\t\t\t\t\t\tif (--extIdx === -1) {\n\t\t\t\t\t\t\t\t// We matched the extension, so mark this as the end of our path\n\t\t\t\t\t\t\t\t// component\n\t\t\t\t\t\t\t\tend = i;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Extension does not match, so our result is the entire path\n\t\t\t\t\t\t\t// component\n\t\t\t\t\t\t\textIdx = -1;\n\t\t\t\t\t\t\tend = firstNonSlashEnd;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (start === end) {\n\t\t\t\tend = firstNonSlashEnd;\n\t\t\t} else if (end === -1) {\n\t\t\t\tend = path.length;\n\t\t\t}\n\t\t\treturn path.slice(start, end);\n\t\t}\n\t\tfor (i = path.length - 1; i >= start; --i) {\n\t\t\tif (isPathSeparator(path.charCodeAt(i))) {\n\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\tstart = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else if (end === -1) {\n\t\t\t\t// We saw the first non-path separator, mark this as the end of our\n\t\t\t\t// path component\n\t\t\t\tmatchedSlash = false;\n\t\t\t\tend = i + 1;\n\t\t\t}\n\t\t}\n\n\t\tif (end === -1) {\n\t\t\treturn '';\n\t\t}\n\t\treturn path.slice(start, end);\n\t},\n\n\textname(path: string): string {\n\t\tvalidateString(path, 'path');\n\t\tlet start = 0;\n\t\tlet startDot = -1;\n\t\tlet startPart = 0;\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\t// Track the state of characters (if any) we see before our first dot and\n\t\t// after any path separator we find\n\t\tlet preDotState = 0;\n\n\t\t// Check for a drive letter prefix so as not to mistake the following\n\t\t// path separator as an extra separator at the end of the path that can be\n\t\t// disregarded\n\n\t\tif (path.length >= 2 &&\n\t\t\tpath.charCodeAt(1) === CHAR_COLON &&\n\t\t\tisWindowsDeviceRoot(path.charCodeAt(0))) {\n\t\t\tstart = startPart = 2;\n\t\t}\n\n\t\tfor (let i = path.length - 1; i >= start; --i) {\n\t\t\tconst code = path.charCodeAt(i);\n\t\t\tif (isPathSeparator(code)) {\n\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\tstartPart = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (end === -1) {\n\t\t\t\t// We saw the first non-path separator, mark this as the end of our\n\t\t\t\t// extension\n\t\t\t\tmatchedSlash = false;\n\t\t\t\tend = i + 1;\n\t\t\t}\n\t\t\tif (code === CHAR_DOT) {\n\t\t\t\t// If this is our first dot, mark it as the start of our extension\n\t\t\t\tif (startDot === -1) {\n\t\t\t\t\tstartDot = i;\n\t\t\t\t}\n\t\t\t\telse if (preDotState !== 1) {\n\t\t\t\t\tpreDotState = 1;\n\t\t\t\t}\n\t\t\t} else if (startDot !== -1) {\n\t\t\t\t// We saw a non-dot and non-path separator before our dot, so we should\n\t\t\t\t// have a good chance at having a non-empty extension\n\t\t\t\tpreDotState = -1;\n\t\t\t}\n\t\t}\n\n\t\tif (startDot === -1 ||\n\t\t\tend === -1 ||\n\t\t\t// We saw a non-dot character immediately before the dot\n\t\t\tpreDotState === 0 ||\n\t\t\t// The (right-most) trimmed path component is exactly '..'\n\t\t\t(preDotState === 1 &&\n\t\t\t\tstartDot === end - 1 &&\n\t\t\t\tstartDot === startPart + 1)) {\n\t\t\treturn '';\n\t\t}\n\t\treturn path.slice(startDot, end);\n\t},\n\n\tformat: _format.bind(null, '\\\\'),\n\n\tparse(path) {\n\t\tvalidateString(path, 'path');\n\n\t\tconst ret = { root: '', dir: '', base: '', ext: '', name: '' };\n\t\tif (path.length === 0) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tconst len = path.length;\n\t\tlet rootEnd = 0;\n\t\tlet code = path.charCodeAt(0);\n\n\t\tif (len === 1) {\n\t\t\tif (isPathSeparator(code)) {\n\t\t\t\t// `path` contains just a path separator, exit early to avoid\n\t\t\t\t// unnecessary work\n\t\t\t\tret.root = ret.dir = path;\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tret.base = ret.name = path;\n\t\t\treturn ret;\n\t\t}\n\t\t// Try to match a root\n\t\tif (isPathSeparator(code)) {\n\t\t\t// Possible UNC root\n\n\t\t\trootEnd = 1;\n\t\t\tif (isPathSeparator(path.charCodeAt(1))) {\n\t\t\t\t// Matched double path separator at beginning\n\t\t\t\tlet j = 2;\n\t\t\t\tlet last = j;\n\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\t// Matched!\n\t\t\t\t\tlast = j;\n\t\t\t\t\t// Match 1 or more path separators\n\t\t\t\t\twhile (j < len && isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\tj++;\n\t\t\t\t\t}\n\t\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\t\t// Matched!\n\t\t\t\t\t\tlast = j;\n\t\t\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j === len) {\n\t\t\t\t\t\t\t// We matched a UNC root only\n\t\t\t\t\t\t\trootEnd = j;\n\t\t\t\t\t\t} else if (j !== last) {\n\t\t\t\t\t\t\t// We matched a UNC root with leftovers\n\t\t\t\t\t\t\trootEnd = j + 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {\n\t\t\t// Possible device root\n\t\t\tif (len <= 2) {\n\t\t\t\t// `path` contains just a drive root, exit early to avoid\n\t\t\t\t// unnecessary work\n\t\t\t\tret.root = ret.dir = path;\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\trootEnd = 2;\n\t\t\tif (isPathSeparator(path.charCodeAt(2))) {\n\t\t\t\tif (len === 3) {\n\t\t\t\t\t// `path` contains just a drive root, exit early to avoid\n\t\t\t\t\t// unnecessary work\n\t\t\t\t\tret.root = ret.dir = path;\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t\trootEnd = 3;\n\t\t\t}\n\t\t}\n\t\tif (rootEnd > 0) {\n\t\t\tret.root = path.slice(0, rootEnd);\n\t\t}\n\n\t\tlet startDot = -1;\n\t\tlet startPart = rootEnd;\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\tlet i = path.length - 1;\n\n\t\t// Track the state of characters (if any) we see before our first dot and\n\t\t// after any path separator we find\n\t\tlet preDotState = 0;\n\n\t\t// Get non-dir info\n\t\tfor (; i >= rootEnd; --i) {\n\t\t\tcode = path.charCodeAt(i);\n\t\t\tif (isPathSeparator(code)) {\n\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\tstartPart = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (end === -1) {\n\t\t\t\t// We saw the first non-path separator, mark this as the end of our\n\t\t\t\t// extension\n\t\t\t\tmatchedSlash = false;\n\t\t\t\tend = i + 1;\n\t\t\t}\n\t\t\tif (code === CHAR_DOT) {\n\t\t\t\t// If this is our first dot, mark it as the start of our extension\n\t\t\t\tif (startDot === -1) {\n\t\t\t\t\tstartDot = i;\n\t\t\t\t} else if (preDotState !== 1) {\n\t\t\t\t\tpreDotState = 1;\n\t\t\t\t}\n\t\t\t} else if (startDot !== -1) {\n\t\t\t\t// We saw a non-dot and non-path separator before our dot, so we should\n\t\t\t\t// have a good chance at having a non-empty extension\n\t\t\t\tpreDotState = -1;\n\t\t\t}\n\t\t}\n\n\t\tif (end !== -1) {\n\t\t\tif (startDot === -1 ||\n\t\t\t\t// We saw a non-dot character immediately before the dot\n\t\t\t\tpreDotState === 0 ||\n\t\t\t\t// The (right-most) trimmed path component is exactly '..'\n\t\t\t\t(preDotState === 1 &&\n\t\t\t\t\tstartDot === end - 1 &&\n\t\t\t\t\tstartDot === startPart + 1)) {\n\t\t\t\tret.base = ret.name = path.slice(startPart, end);\n\t\t\t} else {\n\t\t\t\tret.name = path.slice(startPart, startDot);\n\t\t\t\tret.base = path.slice(startPart, end);\n\t\t\t\tret.ext = path.slice(startDot, end);\n\t\t\t}\n\t\t}\n\n\t\t// If the directory is the root, use the entire root as the `dir` including\n\t\t// the trailing slash if any (`C:\\abc` -> `C:\\`). Otherwise, strip out the\n\t\t// trailing slash (`C:\\abc\\def` -> `C:\\abc`).\n\t\tif (startPart > 0 && startPart !== rootEnd) {\n\t\t\tret.dir = path.slice(0, startPart - 1);\n\t\t} else {\n\t\t\tret.dir = ret.root;\n\t\t}\n\n\t\treturn ret;\n\t},\n\n\tsep: '\\\\',\n\tdelimiter: ';',\n\twin32: null,\n\tposix: null\n};\n\nexport const posix: IPath = {\n\t// path.resolve([from ...], to)\n\tresolve(...pathSegments: string[]): string {\n\t\tlet resolvedPath = '';\n\t\tlet resolvedAbsolute = false;\n\n\t\tfor (let i = pathSegments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n\t\t\tconst path = i >= 0 ? pathSegments[i] : process.cwd();\n\n\t\t\tvalidateString(path, 'path');\n\n\t\t\t// Skip empty entries\n\t\t\tif (path.length === 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tresolvedPath = `${path}/${resolvedPath}`;\n\t\t\tresolvedAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n\t\t}\n\n\t\t// At this point the path should be resolved to a full absolute path, but\n\t\t// handle relative paths to be safe (might happen when process.cwd() fails)\n\n\t\t// Normalize the path\n\t\tresolvedPath = normalizeString(resolvedPath, !resolvedAbsolute, '/',\n\t\t\tisPosixPathSeparator);\n\n\t\tif (resolvedAbsolute) {\n\t\t\treturn `/${resolvedPath}`;\n\t\t}\n\t\treturn resolvedPath.length > 0 ? resolvedPath : '.';\n\t},\n\n\tnormalize(path: string): string {\n\t\tvalidateString(path, 'path');\n\n\t\tif (path.length === 0) {\n\t\t\treturn '.';\n\t\t}\n\n\t\tconst isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n\t\tconst trailingSeparator =\n\t\t\tpath.charCodeAt(path.length - 1) === CHAR_FORWARD_SLASH;\n\n\t\t// Normalize the path\n\t\tpath = normalizeString(path, !isAbsolute, '/', isPosixPathSeparator);\n\n\t\tif (path.length === 0) {\n\t\t\tif (isAbsolute) {\n\t\t\t\treturn '/';\n\t\t\t}\n\t\t\treturn trailingSeparator ? './' : '.';\n\t\t}\n\t\tif (trailingSeparator) {\n\t\t\tpath += '/';\n\t\t}\n\n\t\treturn isAbsolute ? `/${path}` : path;\n\t},\n\n\tisAbsolute(path: string): boolean {\n\t\tvalidateString(path, 'path');\n\t\treturn path.length > 0 && path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n\t},\n\n\tjoin(...paths: string[]): string {\n\t\tif (paths.length === 0) {\n\t\t\treturn '.';\n\t\t}\n\t\tlet joined;\n\t\tfor (let i = 0; i < paths.length; ++i) {\n\t\t\tconst arg = paths[i];\n\t\t\tvalidateString(arg, 'path');\n\t\t\tif (arg.length > 0) {\n\t\t\t\tif (joined === undefined) {\n\t\t\t\t\tjoined = arg;\n\t\t\t\t} else {\n\t\t\t\t\tjoined += `/${arg}`;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (joined === undefined) {\n\t\t\treturn '.';\n\t\t}\n\t\treturn posix.normalize(joined);\n\t},\n\n\trelative(from: string, to: string): string {\n\t\tvalidateString(from, 'from');\n\t\tvalidateString(to, 'to');\n\n\t\tif (from === to) {\n\t\t\treturn '';\n\t\t}\n\n\t\t// Trim leading forward slashes.\n\t\tfrom = posix.resolve(from);\n\t\tto = posix.resolve(to);\n\n\t\tif (from === to) {\n\t\t\treturn '';\n\t\t}\n\n\t\tconst fromStart = 1;\n\t\tconst fromEnd = from.length;\n\t\tconst fromLen = fromEnd - fromStart;\n\t\tconst toStart = 1;\n\t\tconst toLen = to.length - toStart;\n\n\t\t// Compare paths to find the longest common path from root\n\t\tconst length = (fromLen < toLen ? fromLen : toLen);\n\t\tlet lastCommonSep = -1;\n\t\tlet i = 0;\n\t\tfor (; i < length; i++) {\n\t\t\tconst fromCode = from.charCodeAt(fromStart + i);\n\t\t\tif (fromCode !== to.charCodeAt(toStart + i)) {\n\t\t\t\tbreak;\n\t\t\t} else if (fromCode === CHAR_FORWARD_SLASH) {\n\t\t\t\tlastCommonSep = i;\n\t\t\t}\n\t\t}\n\t\tif (i === length) {\n\t\t\tif (toLen > length) {\n\t\t\t\tif (to.charCodeAt(toStart + i) === CHAR_FORWARD_SLASH) {\n\t\t\t\t\t// We get here if `from` is the exact base path for `to`.\n\t\t\t\t\t// For example: from='/foo/bar'; to='/foo/bar/baz'\n\t\t\t\t\treturn to.slice(toStart + i + 1);\n\t\t\t\t}\n\t\t\t\tif (i === 0) {\n\t\t\t\t\t// We get here if `from` is the root\n\t\t\t\t\t// For example: from='/'; to='/foo'\n\t\t\t\t\treturn to.slice(toStart + i);\n\t\t\t\t}\n\t\t\t} else if (fromLen > length) {\n\t\t\t\tif (from.charCodeAt(fromStart + i) === CHAR_FORWARD_SLASH) {\n\t\t\t\t\t// We get here if `to` is the exact base path for `from`.\n\t\t\t\t\t// For example: from='/foo/bar/baz'; to='/foo/bar'\n\t\t\t\t\tlastCommonSep = i;\n\t\t\t\t} else if (i === 0) {\n\t\t\t\t\t// We get here if `to` is the root.\n\t\t\t\t\t// For example: from='/foo/bar'; to='/'\n\t\t\t\t\tlastCommonSep = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlet out = '';\n\t\t// Generate the relative path based on the path difference between `to`\n\t\t// and `from`.\n\t\tfor (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n\t\t\tif (i === fromEnd || from.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n\t\t\t\tout += out.length === 0 ? '..' : '/..';\n\t\t\t}\n\t\t}\n\n\t\t// Lastly, append the rest of the destination (`to`) path that comes after\n\t\t// the common path parts.\n\t\treturn `${out}${to.slice(toStart + lastCommonSep)}`;\n\t},\n\n\ttoNamespacedPath(path: string): string {\n\t\t// Non-op on posix systems\n\t\treturn path;\n\t},\n\n\tdirname(path: string): string {\n\t\tvalidateString(path, 'path');\n\t\tif (path.length === 0) {\n\t\t\treturn '.';\n\t\t}\n\t\tconst hasRoot = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\tfor (let i = path.length - 1; i >= 1; --i) {\n\t\t\tif (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\tend = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// We saw the first non-path separator\n\t\t\t\tmatchedSlash = false;\n\t\t\t}\n\t\t}\n\n\t\tif (end === -1) {\n\t\t\treturn hasRoot ? '/' : '.';\n\t\t}\n\t\tif (hasRoot && end === 1) {\n\t\t\treturn '//';\n\t\t}\n\t\treturn path.slice(0, end);\n\t},\n\n\tbasename(path: string, ext?: string): string {\n\t\tif (ext !== undefined) {\n\t\t\tvalidateString(ext, 'ext');\n\t\t}\n\t\tvalidateString(path, 'path');\n\n\t\tlet start = 0;\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\tlet i;\n\n\t\tif (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n\t\t\tif (ext === path) {\n\t\t\t\treturn '';\n\t\t\t}\n\t\t\tlet extIdx = ext.length - 1;\n\t\t\tlet firstNonSlashEnd = -1;\n\t\t\tfor (i = path.length - 1; i >= 0; --i) {\n\t\t\t\tconst code = path.charCodeAt(i);\n\t\t\t\tif (code === CHAR_FORWARD_SLASH) {\n\t\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\t\tstart = i + 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (firstNonSlashEnd === -1) {\n\t\t\t\t\t\t// We saw the first non-path separator, remember this index in case\n\t\t\t\t\t\t// we need it if the extension ends up not matching\n\t\t\t\t\t\tmatchedSlash = false;\n\t\t\t\t\t\tfirstNonSlashEnd = i + 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (extIdx >= 0) {\n\t\t\t\t\t\t// Try to match the explicit extension\n\t\t\t\t\t\tif (code === ext.charCodeAt(extIdx)) {\n\t\t\t\t\t\t\tif (--extIdx === -1) {\n\t\t\t\t\t\t\t\t// We matched the extension, so mark this as the end of our path\n\t\t\t\t\t\t\t\t// component\n\t\t\t\t\t\t\t\tend = i;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Extension does not match, so our result is the entire path\n\t\t\t\t\t\t\t// component\n\t\t\t\t\t\t\textIdx = -1;\n\t\t\t\t\t\t\tend = firstNonSlashEnd;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (start === end) {\n\t\t\t\tend = firstNonSlashEnd;\n\t\t\t} else if (end === -1) {\n\t\t\t\tend = path.length;\n\t\t\t}\n\t\t\treturn path.slice(start, end);\n\t\t}\n\t\tfor (i = path.length - 1; i >= 0; --i) {\n\t\t\tif (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\tstart = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else if (end === -1) {\n\t\t\t\t// We saw the first non-path separator, mark this as the end of our\n\t\t\t\t// path component\n\t\t\t\tmatchedSlash = false;\n\t\t\t\tend = i + 1;\n\t\t\t}\n\t\t}\n\n\t\tif (end === -1) {\n\t\t\treturn '';\n\t\t}\n\t\treturn path.slice(start, end);\n\t},\n\n\textname(path: string): string {\n\t\tvalidateString(path, 'path');\n\t\tlet startDot = -1;\n\t\tlet startPart = 0;\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\t// Track the state of characters (if any) we see before our first dot and\n\t\t// after any path separator we find\n\t\tlet preDotState = 0;\n\t\tfor (let i = path.length - 1; i >= 0; --i) {\n\t\t\tconst code = path.charCodeAt(i);\n\t\t\tif (code === CHAR_FORWARD_SLASH) {\n\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\tstartPart = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (end === -1) {\n\t\t\t\t// We saw the first non-path separator, mark this as the end of our\n\t\t\t\t// extension\n\t\t\t\tmatchedSlash = false;\n\t\t\t\tend = i + 1;\n\t\t\t}\n\t\t\tif (code === CHAR_DOT) {\n\t\t\t\t// If this is our first dot, mark it as the start of our extension\n\t\t\t\tif (startDot === -1) {\n\t\t\t\t\tstartDot = i;\n\t\t\t\t}\n\t\t\t\telse if (preDotState !== 1) {\n\t\t\t\t\tpreDotState = 1;\n\t\t\t\t}\n\t\t\t} else if (startDot !== -1) {\n\t\t\t\t// We saw a non-dot and non-path separator before our dot, so we should\n\t\t\t\t// have a good chance at having a non-empty extension\n\t\t\t\tpreDotState = -1;\n\t\t\t}\n\t\t}\n\n\t\tif (startDot === -1 ||\n\t\t\tend === -1 ||\n\t\t\t// We saw a non-dot character immediately before the dot\n\t\t\tpreDotState === 0 ||\n\t\t\t// The (right-most) trimmed path component is exactly '..'\n\t\t\t(preDotState === 1 &&\n\t\t\t\tstartDot === end - 1 &&\n\t\t\t\tstartDot === startPart + 1)) {\n\t\t\treturn '';\n\t\t}\n\t\treturn path.slice(startDot, end);\n\t},\n\n\tformat: _format.bind(null, '/'),\n\n\tparse(path: string): ParsedPath {\n\t\tvalidateString(path, 'path');\n\n\t\tconst ret = { root: '', dir: '', base: '', ext: '', name: '' };\n\t\tif (path.length === 0) {\n\t\t\treturn ret;\n\t\t}\n\t\tconst isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n\t\tlet start;\n\t\tif (isAbsolute) {\n\t\t\tret.root = '/';\n\t\t\tstart = 1;\n\t\t} else {\n\t\t\tstart = 0;\n\t\t}\n\t\tlet startDot = -1;\n\t\tlet startPart = 0;\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\tlet i = path.length - 1;\n\n\t\t// Track the state of characters (if any) we see before our first dot and\n\t\t// after any path separator we find\n\t\tlet preDotState = 0;\n\n\t\t// Get non-dir info\n\t\tfor (; i >= start; --i) {\n\t\t\tconst code = path.charCodeAt(i);\n\t\t\tif (code === CHAR_FORWARD_SLASH) {\n\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\tstartPart = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (end === -1) {\n\t\t\t\t// We saw the first non-path separator, mark this as the end of our\n\t\t\t\t// extension\n\t\t\t\tmatchedSlash = false;\n\t\t\t\tend = i + 1;\n\t\t\t}\n\t\t\tif (code === CHAR_DOT) {\n\t\t\t\t// If this is our first dot, mark it as the start of our extension\n\t\t\t\tif (startDot === -1) {\n\t\t\t\t\tstartDot = i;\n\t\t\t\t} else if (preDotState !== 1) {\n\t\t\t\t\tpreDotState = 1;\n\t\t\t\t}\n\t\t\t} else if (startDot !== -1) {\n\t\t\t\t// We saw a non-dot and non-path separator before our dot, so we should\n\t\t\t\t// have a good chance at having a non-empty extension\n\t\t\t\tpreDotState = -1;\n\t\t\t}\n\t\t}\n\n\t\tif (end !== -1) {\n\t\t\tconst start = startPart === 0 && isAbsolute ? 1 : startPart;\n\t\t\tif (startDot === -1 ||\n\t\t\t\t// We saw a non-dot character immediately before the dot\n\t\t\t\tpreDotState === 0 ||\n\t\t\t\t// The (right-most) trimmed path component is exactly '..'\n\t\t\t\t(preDotState === 1 &&\n\t\t\t\t\tstartDot === end - 1 &&\n\t\t\t\t\tstartDot === startPart + 1)) {\n\t\t\t\tret.base = ret.name = path.slice(start, end);\n\t\t\t} else {\n\t\t\t\tret.name = path.slice(start, startDot);\n\t\t\t\tret.base = path.slice(start, end);\n\t\t\t\tret.ext = path.slice(startDot, end);\n\t\t\t}\n\t\t}\n\n\t\tif (startPart > 0) {\n\t\t\tret.dir = path.slice(0, startPart - 1);\n\t\t} else if (isAbsolute) {\n\t\t\tret.dir = '/';\n\t\t}\n\n\t\treturn ret;\n\t},\n\n\tsep: '/',\n\tdelimiter: ':',\n\twin32: null,\n\tposix: null\n};\n\nposix.win32 = win32.win32 = win32;\nposix.posix = win32.posix = posix;\n\nexport const normalize = (process.platform === 'win32' ? win32.normalize : posix.normalize);\nexport const isAbsolute = (process.platform === 'win32' ? win32.isAbsolute : posix.isAbsolute);\nexport const join = (process.platform === 'win32' ? win32.join : posix.join);\nexport const resolve = (process.platform === 'win32' ? win32.resolve : posix.resolve);\nexport const relative = (process.platform === 'win32' ? win32.relative : posix.relative);\nexport const dirname = (process.platform === 'win32' ? win32.dirname : posix.dirname);\nexport const basename = (process.platform === 'win32' ? win32.basename : posix.basename);\nexport const extname = (process.platform === 'win32' ? win32.extname : posix.extname);\nexport const format = (process.platform === 'win32' ? win32.format : posix.format);\nexport const parse = (process.platform === 'win32' ? win32.parse : posix.parse);\nexport const toNamespacedPath = (process.platform === 'win32' ? win32.toNamespacedPath : posix.toNamespacedPath);\nexport const sep = (process.platform === 'win32' ? win32.sep : posix.sep);\nexport const delimiter = (process.platform === 'win32' ? win32.delimiter : posix.delimiter);\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { isWindows } from 'vs/base/common/platform';\nimport { CharCode } from 'vs/base/common/charCode';\nimport * as paths from 'vs/base/common/path';\n\nconst _schemePattern = /^\\w[\\w\\d+.-]*$/;\nconst _singleSlashStart = /^\\//;\nconst _doubleSlashStart = /^\\/\\//;\n\nfunction _validateUri(ret: URI, _strict?: boolean): void {\n\n\t// scheme, must be set\n\tif (!ret.scheme && _strict) {\n\t\tthrow new Error(`[UriError]: Scheme is missing: {scheme: \"\", authority: \"${ret.authority}\", path: \"${ret.path}\", query: \"${ret.query}\", fragment: \"${ret.fragment}\"}`);\n\t}\n\n\t// scheme, https://tools.ietf.org/html/rfc3986#section-3.1\n\t// ALPHA *( ALPHA / DIGIT / \"+\" / \"-\" / \".\" )\n\tif (ret.scheme && !_schemePattern.test(ret.scheme)) {\n\t\tthrow new Error('[UriError]: Scheme contains illegal characters.');\n\t}\n\n\t// path, http://tools.ietf.org/html/rfc3986#section-3.3\n\t// If a URI contains an authority component, then the path component\n\t// must either be empty or begin with a slash (\"/\") character.  If a URI\n\t// does not contain an authority component, then the path cannot begin\n\t// with two slash characters (\"//\").\n\tif (ret.path) {\n\t\tif (ret.authority) {\n\t\t\tif (!_singleSlashStart.test(ret.path)) {\n\t\t\t\tthrow new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash (\"/\") character');\n\t\t\t}\n\t\t} else {\n\t\t\tif (_doubleSlashStart.test(ret.path)) {\n\t\t\t\tthrow new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters (\"//\")');\n\t\t\t}\n\t\t}\n\t}\n}\n\n// for a while we allowed uris *without* schemes and this is the migration\n// for them, e.g. an uri without scheme and without strict-mode warns and falls\n// back to the file-scheme. that should cause the least carnage and still be a\n// clear warning\nfunction _schemeFix(scheme: string, _strict: boolean): string {\n\tif (!scheme && !_strict) {\n\t\treturn 'file';\n\t}\n\treturn scheme;\n}\n\n// implements a bit of https://tools.ietf.org/html/rfc3986#section-5\nfunction _referenceResolution(scheme: string, path: string): string {\n\n\t// the slash-character is our 'default base' as we don't\n\t// support constructing URIs relative to other URIs. This\n\t// also means that we alter and potentially break paths.\n\t// see https://tools.ietf.org/html/rfc3986#section-5.1.4\n\tswitch (scheme) {\n\t\tcase 'https':\n\t\tcase 'http':\n\t\tcase 'file':\n\t\t\tif (!path) {\n\t\t\t\tpath = _slash;\n\t\t\t} else if (path[0] !== _slash) {\n\t\t\t\tpath = _slash + path;\n\t\t\t}\n\t\t\tbreak;\n\t}\n\treturn path;\n}\n\nconst _empty = '';\nconst _slash = '/';\nconst _regexp = /^(([^:/?#]+?):)?(\\/\\/([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?/;\n\n/**\n * Uniform Resource Identifier (URI) http://tools.ietf.org/html/rfc3986.\n * This class is a simple parser which creates the basic component parts\n * (http://tools.ietf.org/html/rfc3986#section-3) with minimal validation\n * and encoding.\n *\n * ```txt\n *       foo://example.com:8042/over/there?name=ferret#nose\n *       \\_/   \\______________/\\_________/ \\_________/ \\__/\n *        |           |            |            |        |\n *     scheme     authority       path        query   fragment\n *        |   _____________________|__\n *       / \\ /                        \\\n *       urn:example:animal:ferret:nose\n * ```\n */\nexport class URI implements UriComponents {\n\n\tstatic isUri(thing: any): thing is URI {\n\t\tif (thing instanceof URI) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!thing) {\n\t\t\treturn false;\n\t\t}\n\t\treturn typeof (<URI>thing).authority === 'string'\n\t\t\t&& typeof (<URI>thing).fragment === 'string'\n\t\t\t&& typeof (<URI>thing).path === 'string'\n\t\t\t&& typeof (<URI>thing).query === 'string'\n\t\t\t&& typeof (<URI>thing).scheme === 'string'\n\t\t\t&& typeof (<URI>thing).fsPath === 'function'\n\t\t\t&& typeof (<URI>thing).with === 'function'\n\t\t\t&& typeof (<URI>thing).toString === 'function';\n\t}\n\n\t/**\n\t * scheme is the 'http' part of 'http://www.msft.com/some/path?query#fragment'.\n\t * The part before the first colon.\n\t */\n\treadonly scheme: string;\n\n\t/**\n\t * authority is the 'www.msft.com' part of 'http://www.msft.com/some/path?query#fragment'.\n\t * The part between the first double slashes and the next slash.\n\t */\n\treadonly authority: string;\n\n\t/**\n\t * path is the '/some/path' part of 'http://www.msft.com/some/path?query#fragment'.\n\t */\n\treadonly path: string;\n\n\t/**\n\t * query is the 'query' part of 'http://www.msft.com/some/path?query#fragment'.\n\t */\n\treadonly query: string;\n\n\t/**\n\t * fragment is the 'fragment' part of 'http://www.msft.com/some/path?query#fragment'.\n\t */\n\treadonly fragment: string;\n\n\t/**\n\t * @internal\n\t */\n\tprotected constructor(scheme: string, authority?: string, path?: string, query?: string, fragment?: string, _strict?: boolean);\n\n\t/**\n\t * @internal\n\t */\n\tprotected constructor(components: UriComponents);\n\n\t/**\n\t * @internal\n\t */\n\tprotected constructor(schemeOrData: string | UriComponents, authority?: string, path?: string, query?: string, fragment?: string, _strict: boolean = false) {\n\n\t\tif (typeof schemeOrData === 'object') {\n\t\t\tthis.scheme = schemeOrData.scheme || _empty;\n\t\t\tthis.authority = schemeOrData.authority || _empty;\n\t\t\tthis.path = schemeOrData.path || _empty;\n\t\t\tthis.query = schemeOrData.query || _empty;\n\t\t\tthis.fragment = schemeOrData.fragment || _empty;\n\t\t\t// no validation because it's this URI\n\t\t\t// that creates uri components.\n\t\t\t// _validateUri(this);\n\t\t} else {\n\t\t\tthis.scheme = _schemeFix(schemeOrData, _strict);\n\t\t\tthis.authority = authority || _empty;\n\t\t\tthis.path = _referenceResolution(this.scheme, path || _empty);\n\t\t\tthis.query = query || _empty;\n\t\t\tthis.fragment = fragment || _empty;\n\n\t\t\t_validateUri(this, _strict);\n\t\t}\n\t}\n\n\t// ---- filesystem path -----------------------\n\n\t/**\n\t * Returns a string representing the corresponding file system path of this URI.\n\t * Will handle UNC paths, normalizes windows drive letters to lower-case, and uses the\n\t * platform specific path separator.\n\t *\n\t * * Will *not* validate the path for invalid characters and semantics.\n\t * * Will *not* look at the scheme of this URI.\n\t * * The result shall *not* be used for display purposes but for accessing a file on disk.\n\t *\n\t *\n\t * The *difference* to `URI#path` is the use of the platform specific separator and the handling\n\t * of UNC paths. See the below sample of a file-uri with an authority (UNC path).\n\t *\n\t * ```ts\n\t\tconst u = URI.parse('file://server/c$/folder/file.txt')\n\t\tu.authority === 'server'\n\t\tu.path === '/shares/c$/file.txt'\n\t\tu.fsPath === '\\\\server\\c$\\folder\\file.txt'\n\t```\n\t *\n\t * Using `URI#path` to read a file (using fs-apis) would not be enough because parts of the path,\n\t * namely the server name, would be missing. Therefore `URI#fsPath` exists - it's sugar to ease working\n\t * with URIs that represent files on disk (`file` scheme).\n\t */\n\tget fsPath(): string {\n\t\t// if (this.scheme !== 'file') {\n\t\t// \tconsole.warn(`[UriError] calling fsPath with scheme ${this.scheme}`);\n\t\t// }\n\t\treturn uriToFsPath(this, false);\n\t}\n\n\t// ---- modify to new -------------------------\n\n\twith(change: { scheme?: string; authority?: string | null; path?: string | null; query?: string | null; fragment?: string | null }): URI {\n\n\t\tif (!change) {\n\t\t\treturn this;\n\t\t}\n\n\t\tlet { scheme, authority, path, query, fragment } = change;\n\t\tif (scheme === undefined) {\n\t\t\tscheme = this.scheme;\n\t\t} else if (scheme === null) {\n\t\t\tscheme = _empty;\n\t\t}\n\t\tif (authority === undefined) {\n\t\t\tauthority = this.authority;\n\t\t} else if (authority === null) {\n\t\t\tauthority = _empty;\n\t\t}\n\t\tif (path === undefined) {\n\t\t\tpath = this.path;\n\t\t} else if (path === null) {\n\t\t\tpath = _empty;\n\t\t}\n\t\tif (query === undefined) {\n\t\t\tquery = this.query;\n\t\t} else if (query === null) {\n\t\t\tquery = _empty;\n\t\t}\n\t\tif (fragment === undefined) {\n\t\t\tfragment = this.fragment;\n\t\t} else if (fragment === null) {\n\t\t\tfragment = _empty;\n\t\t}\n\n\t\tif (scheme === this.scheme\n\t\t\t&& authority === this.authority\n\t\t\t&& path === this.path\n\t\t\t&& query === this.query\n\t\t\t&& fragment === this.fragment) {\n\n\t\t\treturn this;\n\t\t}\n\n\t\treturn new _URI(scheme, authority, path, query, fragment);\n\t}\n\n\t// ---- parse & validate ------------------------\n\n\t/**\n\t * Creates a new URI from a string, e.g. `http://www.msft.com/some/path`,\n\t * `file:///usr/home`, or `scheme:with/path`.\n\t *\n\t * @param value A string which represents an URI (see `URI#toString`).\n\t */\n\tstatic parse(value: string, _strict: boolean = false): URI {\n\t\tconst match = _regexp.exec(value);\n\t\tif (!match) {\n\t\t\treturn new _URI(_empty, _empty, _empty, _empty, _empty);\n\t\t}\n\t\treturn new _URI(\n\t\t\tmatch[2] || _empty,\n\t\t\tpercentDecode(match[4] || _empty),\n\t\t\tpercentDecode(match[5] || _empty),\n\t\t\tpercentDecode(match[7] || _empty),\n\t\t\tpercentDecode(match[9] || _empty),\n\t\t\t_strict\n\t\t);\n\t}\n\n\t/**\n\t * Creates a new URI from a file system path, e.g. `c:\\my\\files`,\n\t * `/usr/home`, or `\\\\server\\share\\some\\path`.\n\t *\n\t * The *difference* between `URI#parse` and `URI#file` is that the latter treats the argument\n\t * as path, not as stringified-uri. E.g. `URI.file(path)` is **not the same as**\n\t * `URI.parse('file://' + path)` because the path might contain characters that are\n\t * interpreted (# and ?). See the following sample:\n\t * ```ts\n\tconst good = URI.file('/coding/c#/project1');\n\tgood.scheme === 'file';\n\tgood.path === '/coding/c#/project1';\n\tgood.fragment === '';\n\tconst bad = URI.parse('file://' + '/coding/c#/project1');\n\tbad.scheme === 'file';\n\tbad.path === '/coding/c'; // path is now broken\n\tbad.fragment === '/project1';\n\t```\n\t *\n\t * @param path A file system path (see `URI#fsPath`)\n\t */\n\tstatic file(path: string): URI {\n\n\t\tlet authority = _empty;\n\n\t\t// normalize to fwd-slashes on windows,\n\t\t// on other systems bwd-slashes are valid\n\t\t// filename character, eg /f\\oo/ba\\r.txt\n\t\tif (isWindows) {\n\t\t\tpath = path.replace(/\\\\/g, _slash);\n\t\t}\n\n\t\t// check for authority as used in UNC shares\n\t\t// or use the path as given\n\t\tif (path[0] === _slash && path[1] === _slash) {\n\t\t\tconst idx = path.indexOf(_slash, 2);\n\t\t\tif (idx === -1) {\n\t\t\t\tauthority = path.substring(2);\n\t\t\t\tpath = _slash;\n\t\t\t} else {\n\t\t\t\tauthority = path.substring(2, idx);\n\t\t\t\tpath = path.substring(idx) || _slash;\n\t\t\t}\n\t\t}\n\n\t\treturn new _URI('file', authority, path, _empty, _empty);\n\t}\n\n\tstatic from(components: { scheme: string; authority?: string; path?: string; query?: string; fragment?: string }): URI {\n\t\treturn new _URI(\n\t\t\tcomponents.scheme,\n\t\t\tcomponents.authority,\n\t\t\tcomponents.path,\n\t\t\tcomponents.query,\n\t\t\tcomponents.fragment,\n\t\t);\n\t}\n\n\t/**\n\t * Join a URI path with path fragments and normalizes the resulting path.\n\t *\n\t * @param uri The input URI.\n\t * @param pathFragment The path fragment to add to the URI path.\n\t * @returns The resulting URI.\n\t */\n\tstatic joinPath(uri: URI, ...pathFragment: string[]): URI {\n\t\tif (!uri.path) {\n\t\t\tthrow new Error(`[UriError]: cannot call joinPaths on URI without path`);\n\t\t}\n\t\tlet newPath: string;\n\t\tif (isWindows && uri.scheme === 'file') {\n\t\t\tnewPath = URI.file(paths.win32.join(uriToFsPath(uri, true), ...pathFragment)).path;\n\t\t} else {\n\t\t\tnewPath = paths.posix.join(uri.path, ...pathFragment);\n\t\t}\n\t\treturn uri.with({ path: newPath });\n\t}\n\n\t// ---- printing/externalize ---------------------------\n\n\t/**\n\t * Creates a string representation for this URI. It's guaranteed that calling\n\t * `URI.parse` with the result of this function creates an URI which is equal\n\t * to this URI.\n\t *\n\t * * The result shall *not* be used for display purposes but for externalization or transport.\n\t * * The result will be encoded using the percentage encoding and encoding happens mostly\n\t * ignore the scheme-specific encoding rules.\n\t *\n\t * @param skipEncoding Do not encode the result, default is `false`\n\t */\n\ttoString(skipEncoding: boolean = false): string {\n\t\treturn _asFormatted(this, skipEncoding);\n\t}\n\n\ttoJSON(): UriComponents {\n\t\treturn this;\n\t}\n\n\tstatic revive(data: UriComponents | URI): URI;\n\tstatic revive(data: UriComponents | URI | undefined): URI | undefined;\n\tstatic revive(data: UriComponents | URI | null): URI | null;\n\tstatic revive(data: UriComponents | URI | undefined | null): URI | undefined | null;\n\tstatic revive(data: UriComponents | URI | undefined | null): URI | undefined | null {\n\t\tif (!data) {\n\t\t\treturn data;\n\t\t} else if (data instanceof URI) {\n\t\t\treturn data;\n\t\t} else {\n\t\t\tconst result = new _URI(data);\n\t\t\tresult._formatted = (<UriState>data).external;\n\t\t\tresult._fsPath = (<UriState>data)._sep === _pathSepMarker ? (<UriState>data).fsPath : null;\n\t\t\treturn result;\n\t\t}\n\t}\n}\n\nexport interface UriComponents {\n\tscheme: string;\n\tauthority: string;\n\tpath: string;\n\tquery: string;\n\tfragment: string;\n}\n\ninterface UriState extends UriComponents {\n\t$mid: number;\n\texternal: string;\n\tfsPath: string;\n\t_sep: 1 | undefined;\n}\n\nconst _pathSepMarker = isWindows ? 1 : undefined;\n\n// eslint-disable-next-line @typescript-eslint/naming-convention\nclass _URI extends URI {\n\n\t_formatted: string | null = null;\n\t_fsPath: string | null = null;\n\n\tget fsPath(): string {\n\t\tif (!this._fsPath) {\n\t\t\tthis._fsPath = uriToFsPath(this, false);\n\t\t}\n\t\treturn this._fsPath;\n\t}\n\n\ttoString(skipEncoding: boolean = false): string {\n\t\tif (!skipEncoding) {\n\t\t\tif (!this._formatted) {\n\t\t\t\tthis._formatted = _asFormatted(this, false);\n\t\t\t}\n\t\t\treturn this._formatted;\n\t\t} else {\n\t\t\t// we don't cache that\n\t\t\treturn _asFormatted(this, true);\n\t\t}\n\t}\n\n\ttoJSON(): UriComponents {\n\t\tconst res = <UriState>{\n\t\t\t$mid: 1\n\t\t};\n\t\t// cached state\n\t\tif (this._fsPath) {\n\t\t\tres.fsPath = this._fsPath;\n\t\t\tres._sep = _pathSepMarker;\n\t\t}\n\t\tif (this._formatted) {\n\t\t\tres.external = this._formatted;\n\t\t}\n\t\t// uri components\n\t\tif (this.path) {\n\t\t\tres.path = this.path;\n\t\t}\n\t\tif (this.scheme) {\n\t\t\tres.scheme = this.scheme;\n\t\t}\n\t\tif (this.authority) {\n\t\t\tres.authority = this.authority;\n\t\t}\n\t\tif (this.query) {\n\t\t\tres.query = this.query;\n\t\t}\n\t\tif (this.fragment) {\n\t\t\tres.fragment = this.fragment;\n\t\t}\n\t\treturn res;\n\t}\n}\n\n// reserved characters: https://tools.ietf.org/html/rfc3986#section-2.2\nconst encodeTable: { [ch: number]: string } = {\n\t[CharCode.Colon]: '%3A', // gen-delims\n\t[CharCode.Slash]: '%2F',\n\t[CharCode.QuestionMark]: '%3F',\n\t[CharCode.Hash]: '%23',\n\t[CharCode.OpenSquareBracket]: '%5B',\n\t[CharCode.CloseSquareBracket]: '%5D',\n\t[CharCode.AtSign]: '%40',\n\n\t[CharCode.ExclamationMark]: '%21', // sub-delims\n\t[CharCode.DollarSign]: '%24',\n\t[CharCode.Ampersand]: '%26',\n\t[CharCode.SingleQuote]: '%27',\n\t[CharCode.OpenParen]: '%28',\n\t[CharCode.CloseParen]: '%29',\n\t[CharCode.Asterisk]: '%2A',\n\t[CharCode.Plus]: '%2B',\n\t[CharCode.Comma]: '%2C',\n\t[CharCode.Semicolon]: '%3B',\n\t[CharCode.Equals]: '%3D',\n\n\t[CharCode.Space]: '%20',\n};\n\nfunction encodeURIComponentFast(uriComponent: string, allowSlash: boolean): string {\n\tlet res: string | undefined = undefined;\n\tlet nativeEncodePos = -1;\n\n\tfor (let pos = 0; pos < uriComponent.length; pos++) {\n\t\tconst code = uriComponent.charCodeAt(pos);\n\n\t\t// unreserved characters: https://tools.ietf.org/html/rfc3986#section-2.3\n\t\tif (\n\t\t\t(code >= CharCode.a && code <= CharCode.z)\n\t\t\t|| (code >= CharCode.A && code <= CharCode.Z)\n\t\t\t|| (code >= CharCode.Digit0 && code <= CharCode.Digit9)\n\t\t\t|| code === CharCode.Dash\n\t\t\t|| code === CharCode.Period\n\t\t\t|| code === CharCode.Underline\n\t\t\t|| code === CharCode.Tilde\n\t\t\t|| (allowSlash && code === CharCode.Slash)\n\t\t) {\n\t\t\t// check if we are delaying native encode\n\t\t\tif (nativeEncodePos !== -1) {\n\t\t\t\tres += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));\n\t\t\t\tnativeEncodePos = -1;\n\t\t\t}\n\t\t\t// check if we write into a new string (by default we try to return the param)\n\t\t\tif (res !== undefined) {\n\t\t\t\tres += uriComponent.charAt(pos);\n\t\t\t}\n\n\t\t} else {\n\t\t\t// encoding needed, we need to allocate a new string\n\t\t\tif (res === undefined) {\n\t\t\t\tres = uriComponent.substr(0, pos);\n\t\t\t}\n\n\t\t\t// check with default table first\n\t\t\tconst escaped = encodeTable[code];\n\t\t\tif (escaped !== undefined) {\n\n\t\t\t\t// check if we are delaying native encode\n\t\t\t\tif (nativeEncodePos !== -1) {\n\t\t\t\t\tres += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));\n\t\t\t\t\tnativeEncodePos = -1;\n\t\t\t\t}\n\n\t\t\t\t// append escaped variant to result\n\t\t\t\tres += escaped;\n\n\t\t\t} else if (nativeEncodePos === -1) {\n\t\t\t\t// use native encode only when needed\n\t\t\t\tnativeEncodePos = pos;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (nativeEncodePos !== -1) {\n\t\tres += encodeURIComponent(uriComponent.substring(nativeEncodePos));\n\t}\n\n\treturn res !== undefined ? res : uriComponent;\n}\n\nfunction encodeURIComponentMinimal(path: string): string {\n\tlet res: string | undefined = undefined;\n\tfor (let pos = 0; pos < path.length; pos++) {\n\t\tconst code = path.charCodeAt(pos);\n\t\tif (code === CharCode.Hash || code === CharCode.QuestionMark) {\n\t\t\tif (res === undefined) {\n\t\t\t\tres = path.substr(0, pos);\n\t\t\t}\n\t\t\tres += encodeTable[code];\n\t\t} else {\n\t\t\tif (res !== undefined) {\n\t\t\t\tres += path[pos];\n\t\t\t}\n\t\t}\n\t}\n\treturn res !== undefined ? res : path;\n}\n\n/**\n * Compute `fsPath` for the given uri\n */\nexport function uriToFsPath(uri: URI, keepDriveLetterCasing: boolean): string {\n\n\tlet value: string;\n\tif (uri.authority && uri.path.length > 1 && uri.scheme === 'file') {\n\t\t// unc path: file://shares/c$/far/boo\n\t\tvalue = `//${uri.authority}${uri.path}`;\n\t} else if (\n\t\turi.path.charCodeAt(0) === CharCode.Slash\n\t\t&& (uri.path.charCodeAt(1) >= CharCode.A && uri.path.charCodeAt(1) <= CharCode.Z || uri.path.charCodeAt(1) >= CharCode.a && uri.path.charCodeAt(1) <= CharCode.z)\n\t\t&& uri.path.charCodeAt(2) === CharCode.Colon\n\t) {\n\t\tif (!keepDriveLetterCasing) {\n\t\t\t// windows drive letter: file:///c:/far/boo\n\t\t\tvalue = uri.path[1].toLowerCase() + uri.path.substr(2);\n\t\t} else {\n\t\t\tvalue = uri.path.substr(1);\n\t\t}\n\t} else {\n\t\t// other path\n\t\tvalue = uri.path;\n\t}\n\tif (isWindows) {\n\t\tvalue = value.replace(/\\//g, '\\\\');\n\t}\n\treturn value;\n}\n\n/**\n * Create the external version of a uri\n */\nfunction _asFormatted(uri: URI, skipEncoding: boolean): string {\n\n\tconst encoder = !skipEncoding\n\t\t? encodeURIComponentFast\n\t\t: encodeURIComponentMinimal;\n\n\tlet res = '';\n\tlet { scheme, authority, path, query, fragment } = uri;\n\tif (scheme) {\n\t\tres += scheme;\n\t\tres += ':';\n\t}\n\tif (authority || scheme === 'file') {\n\t\tres += _slash;\n\t\tres += _slash;\n\t}\n\tif (authority) {\n\t\tlet idx = authority.indexOf('@');\n\t\tif (idx !== -1) {\n\t\t\t// <user>@<auth>\n\t\t\tconst userinfo = authority.substr(0, idx);\n\t\t\tauthority = authority.substr(idx + 1);\n\t\t\tidx = userinfo.indexOf(':');\n\t\t\tif (idx === -1) {\n\t\t\t\tres += encoder(userinfo, false);\n\t\t\t} else {\n\t\t\t\t// <user>:<pass>@<auth>\n\t\t\t\tres += encoder(userinfo.substr(0, idx), false);\n\t\t\t\tres += ':';\n\t\t\t\tres += encoder(userinfo.substr(idx + 1), false);\n\t\t\t}\n\t\t\tres += '@';\n\t\t}\n\t\tauthority = authority.toLowerCase();\n\t\tidx = authority.indexOf(':');\n\t\tif (idx === -1) {\n\t\t\tres += encoder(authority, false);\n\t\t} else {\n\t\t\t// <auth>:<port>\n\t\t\tres += encoder(authority.substr(0, idx), false);\n\t\t\tres += authority.substr(idx);\n\t\t}\n\t}\n\tif (path) {\n\t\t// lower-case windows drive letters in /C:/fff or C:/fff\n\t\tif (path.length >= 3 && path.charCodeAt(0) === CharCode.Slash && path.charCodeAt(2) === CharCode.Colon) {\n\t\t\tconst code = path.charCodeAt(1);\n\t\t\tif (code >= CharCode.A && code <= CharCode.Z) {\n\t\t\t\tpath = `/${String.fromCharCode(code + 32)}:${path.substr(3)}`; // \"/c:\".length === 3\n\t\t\t}\n\t\t} else if (path.length >= 2 && path.charCodeAt(1) === CharCode.Colon) {\n\t\t\tconst code = path.charCodeAt(0);\n\t\t\tif (code >= CharCode.A && code <= CharCode.Z) {\n\t\t\t\tpath = `${String.fromCharCode(code + 32)}:${path.substr(2)}`; // \"/c:\".length === 3\n\t\t\t}\n\t\t}\n\t\t// encode the rest of the path\n\t\tres += encoder(path, true);\n\t}\n\tif (query) {\n\t\tres += '?';\n\t\tres += encoder(query, false);\n\t}\n\tif (fragment) {\n\t\tres += '#';\n\t\tres += !skipEncoding ? encodeURIComponentFast(fragment, false) : fragment;\n\t}\n\treturn res;\n}\n\n// --- decode\n\nfunction decodeURIComponentGraceful(str: string): string {\n\ttry {\n\t\treturn decodeURIComponent(str);\n\t} catch {\n\t\tif (str.length > 3) {\n\t\t\treturn str.substr(0, 3) + decodeURIComponentGraceful(str.substr(3));\n\t\t} else {\n\t\t\treturn str;\n\t\t}\n\t}\n}\n\nconst _rEncodedAsHex = /(%[0-9A-Za-z][0-9A-Za-z])+/g;\n\nfunction percentDecode(str: string): string {\n\tif (!str.match(_rEncodedAsHex)) {\n\t\treturn str;\n\t}\n\treturn str.replace(_rEncodedAsHex, (match) => decodeURIComponentGraceful(match));\n}\n","const { MAX_SAFE_COMPONENT_LENGTH } = require('./constants')\nconst debug = require('./debug')\nexports = module.exports = {}\n\n// The actual regexps go on exports.re\nconst re = exports.re = []\nconst src = exports.src = []\nconst t = exports.t = {}\nlet R = 0\n\nconst createToken = (name, value, isGlobal) => {\n  const index = R++\n  debug(index, value)\n  t[name] = index\n  src[index] = value\n  re[index] = new RegExp(value, isGlobal ? 'g' : undefined)\n}\n\n// The following Regular Expressions can be used for tokenizing,\n// validating, and parsing SemVer version strings.\n\n// ## Numeric Identifier\n// A single `0`, or a non-zero digit followed by zero or more digits.\n\ncreateToken('NUMERICIDENTIFIER', '0|[1-9]\\\\d*')\ncreateToken('NUMERICIDENTIFIERLOOSE', '[0-9]+')\n\n// ## Non-numeric Identifier\n// Zero or more digits, followed by a letter or hyphen, and then zero or\n// more letters, digits, or hyphens.\n\ncreateToken('NONNUMERICIDENTIFIER', '\\\\d*[a-zA-Z-][a-zA-Z0-9-]*')\n\n// ## Main Version\n// Three dot-separated numeric identifiers.\n\ncreateToken('MAINVERSION', `(${src[t.NUMERICIDENTIFIER]})\\\\.` +\n                   `(${src[t.NUMERICIDENTIFIER]})\\\\.` +\n                   `(${src[t.NUMERICIDENTIFIER]})`)\n\ncreateToken('MAINVERSIONLOOSE', `(${src[t.NUMERICIDENTIFIERLOOSE]})\\\\.` +\n                        `(${src[t.NUMERICIDENTIFIERLOOSE]})\\\\.` +\n                        `(${src[t.NUMERICIDENTIFIERLOOSE]})`)\n\n// ## Pre-release Version Identifier\n// A numeric identifier, or a non-numeric identifier.\n\ncreateToken('PRERELEASEIDENTIFIER', `(?:${src[t.NUMERICIDENTIFIER]\n}|${src[t.NONNUMERICIDENTIFIER]})`)\n\ncreateToken('PRERELEASEIDENTIFIERLOOSE', `(?:${src[t.NUMERICIDENTIFIERLOOSE]\n}|${src[t.NONNUMERICIDENTIFIER]})`)\n\n// ## Pre-release Version\n// Hyphen, followed by one or more dot-separated pre-release version\n// identifiers.\n\ncreateToken('PRERELEASE', `(?:-(${src[t.PRERELEASEIDENTIFIER]\n}(?:\\\\.${src[t.PRERELEASEIDENTIFIER]})*))`)\n\ncreateToken('PRERELEASELOOSE', `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]\n}(?:\\\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`)\n\n// ## Build Metadata Identifier\n// Any combination of digits, letters, or hyphens.\n\ncreateToken('BUILDIDENTIFIER', '[0-9A-Za-z-]+')\n\n// ## Build Metadata\n// Plus sign, followed by one or more period-separated build metadata\n// identifiers.\n\ncreateToken('BUILD', `(?:\\\\+(${src[t.BUILDIDENTIFIER]\n}(?:\\\\.${src[t.BUILDIDENTIFIER]})*))`)\n\n// ## Full Version String\n// A main version, followed optionally by a pre-release version and\n// build metadata.\n\n// Note that the only major, minor, patch, and pre-release sections of\n// the version string are capturing groups.  The build metadata is not a\n// capturing group, because it should not ever be used in version\n// comparison.\n\ncreateToken('FULLPLAIN', `v?${src[t.MAINVERSION]\n}${src[t.PRERELEASE]}?${\n  src[t.BUILD]}?`)\n\ncreateToken('FULL', `^${src[t.FULLPLAIN]}$`)\n\n// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.\n// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty\n// common in the npm registry.\ncreateToken('LOOSEPLAIN', `[v=\\\\s]*${src[t.MAINVERSIONLOOSE]\n}${src[t.PRERELEASELOOSE]}?${\n  src[t.BUILD]}?`)\n\ncreateToken('LOOSE', `^${src[t.LOOSEPLAIN]}$`)\n\ncreateToken('GTLT', '((?:<|>)?=?)')\n\n// Something like \"2.*\" or \"1.2.x\".\n// Note that \"x.x\" is a valid xRange identifer, meaning \"any version\"\n// Only the first item is strictly required.\ncreateToken('XRANGEIDENTIFIERLOOSE', `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\\\*`)\ncreateToken('XRANGEIDENTIFIER', `${src[t.NUMERICIDENTIFIER]}|x|X|\\\\*`)\n\ncreateToken('XRANGEPLAIN', `[v=\\\\s]*(${src[t.XRANGEIDENTIFIER]})` +\n                   `(?:\\\\.(${src[t.XRANGEIDENTIFIER]})` +\n                   `(?:\\\\.(${src[t.XRANGEIDENTIFIER]})` +\n                   `(?:${src[t.PRERELEASE]})?${\n                     src[t.BUILD]}?` +\n                   `)?)?`)\n\ncreateToken('XRANGEPLAINLOOSE', `[v=\\\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})` +\n                        `(?:\\\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +\n                        `(?:\\\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +\n                        `(?:${src[t.PRERELEASELOOSE]})?${\n                          src[t.BUILD]}?` +\n                        `)?)?`)\n\ncreateToken('XRANGE', `^${src[t.GTLT]}\\\\s*${src[t.XRANGEPLAIN]}$`)\ncreateToken('XRANGELOOSE', `^${src[t.GTLT]}\\\\s*${src[t.XRANGEPLAINLOOSE]}$`)\n\n// Coercion.\n// Extract anything that could conceivably be a part of a valid semver\ncreateToken('COERCE', `${'(^|[^\\\\d])' +\n              '(\\\\d{1,'}${MAX_SAFE_COMPONENT_LENGTH}})` +\n              `(?:\\\\.(\\\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` +\n              `(?:\\\\.(\\\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` +\n              `(?:$|[^\\\\d])`)\ncreateToken('COERCERTL', src[t.COERCE], true)\n\n// Tilde ranges.\n// Meaning is \"reasonably at or greater than\"\ncreateToken('LONETILDE', '(?:~>?)')\n\ncreateToken('TILDETRIM', `(\\\\s*)${src[t.LONETILDE]}\\\\s+`, true)\nexports.tildeTrimReplace = '$1~'\n\ncreateToken('TILDE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`)\ncreateToken('TILDELOOSE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`)\n\n// Caret ranges.\n// Meaning is \"at least and backwards compatible with\"\ncreateToken('LONECARET', '(?:\\\\^)')\n\ncreateToken('CARETTRIM', `(\\\\s*)${src[t.LONECARET]}\\\\s+`, true)\nexports.caretTrimReplace = '$1^'\n\ncreateToken('CARET', `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`)\ncreateToken('CARETLOOSE', `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`)\n\n// A simple gt/lt/eq thing, or just \"\" to indicate \"any version\"\ncreateToken('COMPARATORLOOSE', `^${src[t.GTLT]}\\\\s*(${src[t.LOOSEPLAIN]})$|^$`)\ncreateToken('COMPARATOR', `^${src[t.GTLT]}\\\\s*(${src[t.FULLPLAIN]})$|^$`)\n\n// An expression to strip any whitespace between the gtlt and the thing\n// it modifies, so that `> 1.2.3` ==> `>1.2.3`\ncreateToken('COMPARATORTRIM', `(\\\\s*)${src[t.GTLT]\n}\\\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true)\nexports.comparatorTrimReplace = '$1$2$3'\n\n// Something like `1.2.3 - 1.2.4`\n// Note that these all use the loose form, because they'll be\n// checked against either the strict or loose comparator form\n// later.\ncreateToken('HYPHENRANGE', `^\\\\s*(${src[t.XRANGEPLAIN]})` +\n                   `\\\\s+-\\\\s+` +\n                   `(${src[t.XRANGEPLAIN]})` +\n                   `\\\\s*$`)\n\ncreateToken('HYPHENRANGELOOSE', `^\\\\s*(${src[t.XRANGEPLAINLOOSE]})` +\n                        `\\\\s+-\\\\s+` +\n                        `(${src[t.XRANGEPLAINLOOSE]})` +\n                        `\\\\s*$`)\n\n// Star ranges basically just allow anything at all.\ncreateToken('STAR', '(<|>)?=?\\\\s*\\\\*')\n// >=0.0.0 is like a star\ncreateToken('GTE0', '^\\\\s*>=\\\\s*0\\.0\\.0\\\\s*$')\ncreateToken('GTE0PRE', '^\\\\s*>=\\\\s*0\\.0\\.0-0\\\\s*$')\n","const {MAX_LENGTH} = require('../internal/constants')\nconst { re, t } = require('../internal/re')\nconst SemVer = require('../classes/semver')\n\nconst parse = (version, options) => {\n  if (!options || typeof options !== 'object') {\n    options = {\n      loose: !!options,\n      includePrerelease: false\n    }\n  }\n\n  if (version instanceof SemVer) {\n    return version\n  }\n\n  if (typeof version !== 'string') {\n    return null\n  }\n\n  if (version.length > MAX_LENGTH) {\n    return null\n  }\n\n  const r = options.loose ? re[t.LOOSE] : re[t.FULL]\n  if (!r.test(version)) {\n    return null\n  }\n\n  try {\n    return new SemVer(version, options)\n  } catch (er) {\n    return null\n  }\n}\n\nmodule.exports = parse\n","import arrayLikeToArray from \"./arrayLikeToArray\";\nexport default function _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(n);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}","export default function _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}","export default function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}","// just pre-load all the stuff that index.js lazily exports\nconst internalRe = require('./internal/re')\nmodule.exports = {\n  re: internalRe.re,\n  src: internalRe.src,\n  tokens: internalRe.t,\n  SEMVER_SPEC_VERSION: require('./internal/constants').SEMVER_SPEC_VERSION,\n  SemVer: require('./classes/semver'),\n  compareIdentifiers: require('./internal/identifiers').compareIdentifiers,\n  rcompareIdentifiers: require('./internal/identifiers').rcompareIdentifiers,\n  parse: require('./functions/parse'),\n  valid: require('./functions/valid'),\n  clean: require('./functions/clean'),\n  inc: require('./functions/inc'),\n  diff: require('./functions/diff'),\n  major: require('./functions/major'),\n  minor: require('./functions/minor'),\n  patch: require('./functions/patch'),\n  prerelease: require('./functions/prerelease'),\n  compare: require('./functions/compare'),\n  rcompare: require('./functions/rcompare'),\n  compareLoose: require('./functions/compare-loose'),\n  compareBuild: require('./functions/compare-build'),\n  sort: require('./functions/sort'),\n  rsort: require('./functions/rsort'),\n  gt: require('./functions/gt'),\n  lt: require('./functions/lt'),\n  eq: require('./functions/eq'),\n  neq: require('./functions/neq'),\n  gte: require('./functions/gte'),\n  lte: require('./functions/lte'),\n  cmp: require('./functions/cmp'),\n  coerce: require('./functions/coerce'),\n  Comparator: require('./classes/comparator'),\n  Range: require('./classes/range'),\n  satisfies: require('./functions/satisfies'),\n  toComparators: require('./ranges/to-comparators'),\n  maxSatisfying: require('./ranges/max-satisfying'),\n  minSatisfying: require('./ranges/min-satisfying'),\n  minVersion: require('./ranges/min-version'),\n  validRange: require('./ranges/valid'),\n  outside: require('./ranges/outside'),\n  gtr: require('./ranges/gtr'),\n  ltr: require('./ranges/ltr'),\n  intersects: require('./ranges/intersects'),\n  simplifyRange: require('./ranges/simplify'),\n  subset: require('./ranges/subset'),\n}\n","/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\nvar isArray = require('isarray')\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength()\n\nfunction typedArraySupport () {\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length)\n    }\n    that.length = length\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    })\n  }\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n}\n\nfunction allocUnsafe (that, size) {\n  assertSize(size)\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  that = createBuffer(that, length)\n\n  var actual = that.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual)\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  that = createBuffer(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array)\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset)\n  } else {\n    array = new Uint8Array(array, byteOffset, length)\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array)\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    that = createBuffer(that, len)\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len)\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString())\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n","// Note: this is the semver.org version of the spec that it implements\n// Not necessarily the package version of this code.\nconst SEMVER_SPEC_VERSION = '2.0.0'\n\nconst MAX_LENGTH = 256\nconst MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER ||\n  /* istanbul ignore next */ 9007199254740991\n\n// Max safe segment length for coercion.\nconst MAX_SAFE_COMPONENT_LENGTH = 16\n\nmodule.exports = {\n  SEMVER_SPEC_VERSION,\n  MAX_LENGTH,\n  MAX_SAFE_INTEGER,\n  MAX_SAFE_COMPONENT_LENGTH\n}\n","const debug = (\n  typeof process === 'object' &&\n  process.env &&\n  process.env.NODE_DEBUG &&\n  /\\bsemver\\b/i.test(process.env.NODE_DEBUG)\n) ? (...args) => console.error('SEMVER', ...args)\n  : () => {}\n\nmodule.exports = debug\n","const compare = require('./compare')\nconst gt = (a, b, loose) => compare(a, b, loose) > 0\nmodule.exports = gt\n","const ANY = Symbol('SemVer ANY')\n// hoisted class for cyclic dependency\nclass Comparator {\n  static get ANY () {\n    return ANY\n  }\n  constructor (comp, options) {\n    if (!options || typeof options !== 'object') {\n      options = {\n        loose: !!options,\n        includePrerelease: false\n      }\n    }\n\n    if (comp instanceof Comparator) {\n      if (comp.loose === !!options.loose) {\n        return comp\n      } else {\n        comp = comp.value\n      }\n    }\n\n    debug('comparator', comp, options)\n    this.options = options\n    this.loose = !!options.loose\n    this.parse(comp)\n\n    if (this.semver === ANY) {\n      this.value = ''\n    } else {\n      this.value = this.operator + this.semver.version\n    }\n\n    debug('comp', this)\n  }\n\n  parse (comp) {\n    const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR]\n    const m = comp.match(r)\n\n    if (!m) {\n      throw new TypeError(`Invalid comparator: ${comp}`)\n    }\n\n    this.operator = m[1] !== undefined ? m[1] : ''\n    if (this.operator === '=') {\n      this.operator = ''\n    }\n\n    // if it literally is just '>' or '' then allow anything.\n    if (!m[2]) {\n      this.semver = ANY\n    } else {\n      this.semver = new SemVer(m[2], this.options.loose)\n    }\n  }\n\n  toString () {\n    return this.value\n  }\n\n  test (version) {\n    debug('Comparator.test', version, this.options.loose)\n\n    if (this.semver === ANY || version === ANY) {\n      return true\n    }\n\n    if (typeof version === 'string') {\n      try {\n        version = new SemVer(version, this.options)\n      } catch (er) {\n        return false\n      }\n    }\n\n    return cmp(version, this.operator, this.semver, this.options)\n  }\n\n  intersects (comp, options) {\n    if (!(comp instanceof Comparator)) {\n      throw new TypeError('a Comparator is required')\n    }\n\n    if (!options || typeof options !== 'object') {\n      options = {\n        loose: !!options,\n        includePrerelease: false\n      }\n    }\n\n    if (this.operator === '') {\n      if (this.value === '') {\n        return true\n      }\n      return new Range(comp.value, options).test(this.value)\n    } else if (comp.operator === '') {\n      if (comp.value === '') {\n        return true\n      }\n      return new Range(this.value, options).test(comp.semver)\n    }\n\n    const sameDirectionIncreasing =\n      (this.operator === '>=' || this.operator === '>') &&\n      (comp.operator === '>=' || comp.operator === '>')\n    const sameDirectionDecreasing =\n      (this.operator === '<=' || this.operator === '<') &&\n      (comp.operator === '<=' || comp.operator === '<')\n    const sameSemVer = this.semver.version === comp.semver.version\n    const differentDirectionsInclusive =\n      (this.operator === '>=' || this.operator === '<=') &&\n      (comp.operator === '>=' || comp.operator === '<=')\n    const oppositeDirectionsLessThan =\n      cmp(this.semver, '<', comp.semver, options) &&\n      (this.operator === '>=' || this.operator === '>') &&\n        (comp.operator === '<=' || comp.operator === '<')\n    const oppositeDirectionsGreaterThan =\n      cmp(this.semver, '>', comp.semver, options) &&\n      (this.operator === '<=' || this.operator === '<') &&\n        (comp.operator === '>=' || comp.operator === '>')\n\n    return (\n      sameDirectionIncreasing ||\n      sameDirectionDecreasing ||\n      (sameSemVer && differentDirectionsInclusive) ||\n      oppositeDirectionsLessThan ||\n      oppositeDirectionsGreaterThan\n    )\n  }\n}\n\nmodule.exports = Comparator\n\nconst {re, t} = require('../internal/re')\nconst cmp = require('../functions/cmp')\nconst debug = require('../internal/debug')\nconst SemVer = require('./semver')\nconst Range = require('./range')\n","const Range = require('../classes/range')\nconst satisfies = (version, range, options) => {\n  try {\n    range = new Range(range, options)\n  } catch (er) {\n    return false\n  }\n  return range.test(version)\n}\nmodule.exports = satisfies\n","export default function _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}","import { Uri } from '@velcro/common';\nimport {\n  AbstractResolverStrategyWithRoot,\n  ResolverContext,\n  ResolverStrategy,\n} from '@velcro/resolver';\n\ninterface DirectoryEntry {\n  type: ResolverStrategy.EntryKind.Directory;\n  children: Record<string, Entry>;\n}\n\nenum FileEncoding {\n  Base64 = 'base64',\n  UTF8 = 'utf-8',\n}\n\ninterface FileEntry {\n  type: ResolverStrategy.EntryKind.File;\n  content: string;\n  encoding: FileEncoding;\n}\n\ninterface FileInputWithEncoding {\n  encoding: FileEncoding;\n  content: string;\n}\n\ntype Entry = DirectoryEntry | FileEntry;\ntype FileInput = string | FileInputWithEncoding;\n\nconst encodeText =\n  typeof TextEncoder === 'function'\n    ? (function () {\n        const encoder = new TextEncoder();\n\n        return function encodeText(data: string): ArrayBuffer {\n          return encoder.encode(data).buffer;\n        };\n      })()\n    : typeof Buffer === 'function'\n    ? function encodeText(data: string): ArrayBuffer {\n        return Buffer.from(data);\n      }\n    : function encodeText(_data: string): ArrayBuffer {\n        throw new Error(\n          'The environment provides neither TextEncoder nor Buffer. Please consider polyfilling one of these APIs.'\n        );\n      };\n\nexport class MemoryStrategy extends AbstractResolverStrategyWithRoot {\n  private readonly root: DirectoryEntry = {\n    type: ResolverStrategy.EntryKind.Directory,\n    children: {},\n  };\n\n  constructor(files: Record<string, FileInput>, rootUri = Uri.parse('memory:/')) {\n    super(Uri.ensureTrailingSlash(rootUri));\n\n    for (const pathname in files) {\n      const file = files[pathname];\n\n      if (typeof file === 'string') {\n        this.addFile(pathname, file);\n      } else {\n        this.addFile(pathname, file.content, { encoding: file.encoding });\n      }\n    }\n  }\n\n  getEntryAtPath(pathname: string) {\n    const segments = Array.isArray(pathname)\n      ? pathname.slice()\n      : pathname.split('/').filter(Boolean);\n\n    let parent: Entry = this.root;\n\n    for (const segment of segments) {\n      if (!parent || parent.type !== ResolverStrategy.EntryKind.Directory) {\n        throw new Error(`Failed to add ${pathname}`);\n      }\n\n      parent = parent.children[segment];\n    }\n\n    return parent;\n  }\n\n  addFile(\n    pathname: string,\n    content: string,\n    {\n      encoding = FileEncoding.UTF8,\n      overwrite = false,\n    }: { encoding?: FileEncoding; overwrite?: boolean } = {}\n  ) {\n    const segments = pathname.split('/').filter(Boolean);\n    const filename = segments.pop();\n\n    if (!filename) {\n      throw new Error(`Unable to add a file without a filename '${pathname}'`);\n    }\n\n    let parent: Entry = this.root;\n\n    for (const segment of segments) {\n      if (!parent || parent.type !== ResolverStrategy.EntryKind.Directory) {\n        throw new Error(`Failed to add ${pathname}`);\n      }\n\n      let dir: Entry = parent.children[segment];\n\n      if (!dir) {\n        dir = {\n          type: ResolverStrategy.EntryKind.Directory,\n          children: {},\n        };\n\n        parent.children[segment] = dir;\n      }\n\n      parent = dir;\n    }\n\n    if (parent.type !== ResolverStrategy.EntryKind.Directory) {\n      throw new Error(`Cannot add file to a non directory entry ${pathname}`);\n    }\n\n    if (parent.children[filename] && !overwrite) {\n      throw new Error(`Entry already exists at ${pathname}`);\n    }\n\n    const entry: FileEntry = {\n      type: ResolverStrategy.EntryKind.File,\n      content,\n      encoding,\n    };\n\n    parent.children[filename] = entry;\n\n    return entry;\n  }\n\n  removeFile(pathname: string) {\n    const segments = pathname.split('/').filter(Boolean);\n    const filename = segments.pop();\n\n    if (!filename) {\n      return false;\n    }\n\n    let parent: Entry = this.root;\n\n    for (const segment of segments) {\n      if (!parent || parent.type !== ResolverStrategy.EntryKind.Directory) {\n        return false;\n      }\n\n      parent = parent.children[segment];\n    }\n\n    if (!parent || parent.type !== ResolverStrategy.EntryKind.Directory) {\n      return false;\n    }\n\n    return delete parent.children[filename];\n  }\n\n  getResolveRoot() {\n    return {\n      uri: this.rootUri,\n    };\n  }\n\n  listEntries(_ctx: ResolverContext, uri: Uri) {\n    const urlPathname = Uri.ensureTrailingSlash(uri).fsPath;\n    const basePathname = this.rootUri.fsPath;\n    const fsPathname = urlPathname.startsWith(basePathname)\n      ? urlPathname.slice(basePathname.length - 1)\n      : urlPathname;\n    const parent = this.getEntryAtPath(fsPathname);\n\n    if (!parent) {\n      throw new Error(`No such directory ${uri.toString()}`);\n    }\n\n    if (parent.type !== ResolverStrategy.EntryKind.Directory) {\n      throw new Error(`Cannot list entries under a file at ${uri.toString()}`);\n    }\n\n    const entries = Object.keys(parent.children).map((filename) => {\n      const entry = parent.children[filename];\n\n      return {\n        uri: Uri.joinPath(this.rootUri, fsPathname, filename),\n        type: entry.type,\n      };\n    });\n\n    return {\n      entries,\n    };\n  }\n\n  readFileContent(_ctx: ResolverContext, uri: Uri) {\n    const urlPathname = Uri.ensureTrailingSlash(uri).fsPath;\n    const basePathname = this.rootUri.fsPath;\n    const fsPathname = urlPathname.startsWith(basePathname)\n      ? urlPathname.slice(basePathname.length - 1)\n      : urlPathname;\n    const entry = this.getEntryAtPath(fsPathname);\n\n    if (!entry) {\n      throw new Error(`No such file ${uri.toString()}`);\n    }\n\n    if (entry.type !== 'file') {\n      throw new Error(`Cannot read content of a non-file at ${uri.toString()}`);\n    }\n\n    switch (entry.encoding) {\n      case FileEncoding.Base64: {\n        const binSting = atob(entry.content);\n        const binArray = new Uint8Array(binSting.length);\n\n        Array.prototype.forEach.call(binArray, function (_el: any, idx: number, arr: number[]) {\n          arr[idx] = binSting.charCodeAt(idx);\n        });\n\n        return {\n          content: binArray.buffer,\n        };\n      }\n      case FileEncoding.UTF8: {\n        return {\n          content: encodeText(entry.content),\n        };\n      }\n      default:\n        throw new Error(`Unsupported encoding for ${uri.toString()}: ${entry.encoding}`);\n    }\n  }\n\n  uriForPath(pathname: string) {\n    return Uri.joinPath(this.rootUri, pathname);\n  }\n}\n","export default class BitSet {\n\tconstructor(arg) {\n\t\tthis.bits = arg instanceof BitSet ? arg.bits.slice() : [];\n\t}\n\n\tadd(n) {\n\t\tthis.bits[n >> 5] |= 1 << (n & 31);\n\t}\n\n\thas(n) {\n\t\treturn !!(this.bits[n >> 5] & (1 << (n & 31)));\n\t}\n}","export default class Chunk {\n\tconstructor(start, end, content) {\n\t\tthis.start = start;\n\t\tthis.end = end;\n\t\tthis.original = content;\n\n\t\tthis.intro = '';\n\t\tthis.outro = '';\n\n\t\tthis.content = content;\n\t\tthis.storeName = false;\n\t\tthis.edited = false;\n\n\t\t// we make these non-enumerable, for sanity while debugging\n\t\tObject.defineProperties(this, {\n\t\t\tprevious: { writable: true, value: null },\n\t\t\tnext:     { writable: true, value: null }\n\t\t});\n\t}\n\n\tappendLeft(content) {\n\t\tthis.outro += content;\n\t}\n\n\tappendRight(content) {\n\t\tthis.intro = this.intro + content;\n\t}\n\n\tclone() {\n\t\tconst chunk = new Chunk(this.start, this.end, this.original);\n\n\t\tchunk.intro = this.intro;\n\t\tchunk.outro = this.outro;\n\t\tchunk.content = this.content;\n\t\tchunk.storeName = this.storeName;\n\t\tchunk.edited = this.edited;\n\n\t\treturn chunk;\n\t}\n\n\tcontains(index) {\n\t\treturn this.start < index && index < this.end;\n\t}\n\n\teachNext(fn) {\n\t\tlet chunk = this;\n\t\twhile (chunk) {\n\t\t\tfn(chunk);\n\t\t\tchunk = chunk.next;\n\t\t}\n\t}\n\n\teachPrevious(fn) {\n\t\tlet chunk = this;\n\t\twhile (chunk) {\n\t\t\tfn(chunk);\n\t\t\tchunk = chunk.previous;\n\t\t}\n\t}\n\n\tedit(content, storeName, contentOnly) {\n\t\tthis.content = content;\n\t\tif (!contentOnly) {\n\t\t\tthis.intro = '';\n\t\t\tthis.outro = '';\n\t\t}\n\t\tthis.storeName = storeName;\n\n\t\tthis.edited = true;\n\n\t\treturn this;\n\t}\n\n\tprependLeft(content) {\n\t\tthis.outro = content + this.outro;\n\t}\n\n\tprependRight(content) {\n\t\tthis.intro = content + this.intro;\n\t}\n\n\tsplit(index) {\n\t\tconst sliceIndex = index - this.start;\n\n\t\tconst originalBefore = this.original.slice(0, sliceIndex);\n\t\tconst originalAfter = this.original.slice(sliceIndex);\n\n\t\tthis.original = originalBefore;\n\n\t\tconst newChunk = new Chunk(index, this.end, originalAfter);\n\t\tnewChunk.outro = this.outro;\n\t\tthis.outro = '';\n\n\t\tthis.end = index;\n\n\t\tif (this.edited) {\n\t\t\t// TODO is this block necessary?...\n\t\t\tnewChunk.edit('', false);\n\t\t\tthis.content = '';\n\t\t} else {\n\t\t\tthis.content = originalBefore;\n\t\t}\n\n\t\tnewChunk.next = this.next;\n\t\tif (newChunk.next) newChunk.next.previous = newChunk;\n\t\tnewChunk.previous = this;\n\t\tthis.next = newChunk;\n\n\t\treturn newChunk;\n\t}\n\n\ttoString() {\n\t\treturn this.intro + this.content + this.outro;\n\t}\n\n\ttrimEnd(rx) {\n\t\tthis.outro = this.outro.replace(rx, '');\n\t\tif (this.outro.length) return true;\n\n\t\tconst trimmed = this.content.replace(rx, '');\n\n\t\tif (trimmed.length) {\n\t\t\tif (trimmed !== this.content) {\n\t\t\t\tthis.split(this.start + trimmed.length).edit('', undefined, true);\n\t\t\t}\n\t\t\treturn true;\n\n\t\t} else {\n\t\t\tthis.edit('', undefined, true);\n\n\t\t\tthis.intro = this.intro.replace(rx, '');\n\t\t\tif (this.intro.length) return true;\n\t\t}\n\t}\n\n\ttrimStart(rx) {\n\t\tthis.intro = this.intro.replace(rx, '');\n\t\tif (this.intro.length) return true;\n\n\t\tconst trimmed = this.content.replace(rx, '');\n\n\t\tif (trimmed.length) {\n\t\t\tif (trimmed !== this.content) {\n\t\t\t\tthis.split(this.end - trimmed.length);\n\t\t\t\tthis.edit('', undefined, true);\n\t\t\t}\n\t\t\treturn true;\n\n\t\t} else {\n\t\t\tthis.edit('', undefined, true);\n\n\t\t\tthis.outro = this.outro.replace(rx, '');\n\t\t\tif (this.outro.length) return true;\n\t\t}\n\t}\n}\n","import { encode } from 'sourcemap-codec';\n\nlet btoa = () => {\n\tthrow new Error('Unsupported environment: `window.btoa` or `Buffer` should be supported.');\n};\nif (typeof window !== 'undefined' && typeof window.btoa === 'function') {\n\tbtoa = str => window.btoa(unescape(encodeURIComponent(str)));\n} else if (typeof Buffer === 'function') {\n\tbtoa = str => Buffer.from(str, 'utf-8').toString('base64');\n}\n\nexport default class SourceMap {\n\tconstructor(properties) {\n\t\tthis.version = 3;\n\t\tthis.file = properties.file;\n\t\tthis.sources = properties.sources;\n\t\tthis.sourcesContent = properties.sourcesContent;\n\t\tthis.names = properties.names;\n\t\tthis.mappings = encode(properties.mappings);\n\t}\n\n\ttoString() {\n\t\treturn JSON.stringify(this);\n\t}\n\n\ttoUrl() {\n\t\treturn 'data:application/json;charset=utf-8;base64,' + btoa(this.toString());\n\t}\n}\n","export default function guessIndent(code) {\n\tconst lines = code.split('\\n');\n\n\tconst tabbed = lines.filter(line => /^\\t+/.test(line));\n\tconst spaced = lines.filter(line => /^ {2,}/.test(line));\n\n\tif (tabbed.length === 0 && spaced.length === 0) {\n\t\treturn null;\n\t}\n\n\t// More lines tabbed than spaced? Assume tabs, and\n\t// default to tabs in the case of a tie (or nothing\n\t// to go on)\n\tif (tabbed.length >= spaced.length) {\n\t\treturn '\\t';\n\t}\n\n\t// Otherwise, we need to guess the multiple\n\tconst min = spaced.reduce((previous, current) => {\n\t\tconst numSpaces = /^ +/.exec(current)[0].length;\n\t\treturn Math.min(numSpaces, previous);\n\t}, Infinity);\n\n\treturn new Array(min + 1).join(' ');\n}\n","export default function getRelativePath(from, to) {\n\tconst fromParts = from.split(/[/\\\\]/);\n\tconst toParts = to.split(/[/\\\\]/);\n\n\tfromParts.pop(); // get dirname\n\n\twhile (fromParts[0] === toParts[0]) {\n\t\tfromParts.shift();\n\t\ttoParts.shift();\n\t}\n\n\tif (fromParts.length) {\n\t\tlet i = fromParts.length;\n\t\twhile (i--) fromParts[i] = '..';\n\t}\n\n\treturn fromParts.concat(toParts).join('/');\n}\n","const toString = Object.prototype.toString;\n\nexport default function isObject(thing) {\n\treturn toString.call(thing) === '[object Object]';\n}\n","export default function getLocator(source) {\n\tconst originalLines = source.split('\\n');\n\tconst lineOffsets = [];\n\n\tfor (let i = 0, pos = 0; i < originalLines.length; i++) {\n\t\tlineOffsets.push(pos);\n\t\tpos += originalLines[i].length + 1;\n\t}\n\n\treturn function locate(index) {\n\t\tlet i = 0;\n\t\tlet j = lineOffsets.length;\n\t\twhile (i < j) {\n\t\t\tconst m = (i + j) >> 1;\n\t\t\tif (index < lineOffsets[m]) {\n\t\t\t\tj = m;\n\t\t\t} else {\n\t\t\t\ti = m + 1;\n\t\t\t}\n\t\t}\n\t\tconst line = i - 1;\n\t\tconst column = index - lineOffsets[line];\n\t\treturn { line, column };\n\t};\n}\n","export default class Mappings {\n\tconstructor(hires) {\n\t\tthis.hires = hires;\n\t\tthis.generatedCodeLine = 0;\n\t\tthis.generatedCodeColumn = 0;\n\t\tthis.raw = [];\n\t\tthis.rawSegments = this.raw[this.generatedCodeLine] = [];\n\t\tthis.pending = null;\n\t}\n\n\taddEdit(sourceIndex, content, loc, nameIndex) {\n\t\tif (content.length) {\n\t\t\tconst segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];\n\t\t\tif (nameIndex >= 0) {\n\t\t\t\tsegment.push(nameIndex);\n\t\t\t}\n\t\t\tthis.rawSegments.push(segment);\n\t\t} else if (this.pending) {\n\t\t\tthis.rawSegments.push(this.pending);\n\t\t}\n\n\t\tthis.advance(content);\n\t\tthis.pending = null;\n\t}\n\n\taddUneditedChunk(sourceIndex, chunk, original, loc, sourcemapLocations) {\n\t\tlet originalCharIndex = chunk.start;\n\t\tlet first = true;\n\n\t\twhile (originalCharIndex < chunk.end) {\n\t\t\tif (this.hires || first || sourcemapLocations.has(originalCharIndex)) {\n\t\t\t\tthis.rawSegments.push([this.generatedCodeColumn, sourceIndex, loc.line, loc.column]);\n\t\t\t}\n\n\t\t\tif (original[originalCharIndex] === '\\n') {\n\t\t\t\tloc.line += 1;\n\t\t\t\tloc.column = 0;\n\t\t\t\tthis.generatedCodeLine += 1;\n\t\t\t\tthis.raw[this.generatedCodeLine] = this.rawSegments = [];\n\t\t\t\tthis.generatedCodeColumn = 0;\n\t\t\t\tfirst = true;\n\t\t\t} else {\n\t\t\t\tloc.column += 1;\n\t\t\t\tthis.generatedCodeColumn += 1;\n\t\t\t\tfirst = false;\n\t\t\t}\n\n\t\t\toriginalCharIndex += 1;\n\t\t}\n\n\t\tthis.pending = null;\n\t}\n\n\tadvance(str) {\n\t\tif (!str) return;\n\n\t\tconst lines = str.split('\\n');\n\n\t\tif (lines.length > 1) {\n\t\t\tfor (let i = 0; i < lines.length - 1; i++) {\n\t\t\t\tthis.generatedCodeLine++;\n\t\t\t\tthis.raw[this.generatedCodeLine] = this.rawSegments = [];\n\t\t\t}\n\t\t\tthis.generatedCodeColumn = 0;\n\t\t}\n\n\t\tthis.generatedCodeColumn += lines[lines.length - 1].length;\n\t}\n}\n","import BitSet from './BitSet.js';\nimport Chunk from './Chunk.js';\nimport SourceMap from './SourceMap.js';\nimport guessIndent from './utils/guessIndent.js';\nimport getRelativePath from './utils/getRelativePath.js';\nimport isObject from './utils/isObject.js';\nimport getLocator from './utils/getLocator.js';\nimport Mappings from './utils/Mappings.js';\nimport Stats from './utils/Stats.js';\n\nconst n = '\\n';\n\nconst warned = {\n\tinsertLeft: false,\n\tinsertRight: false,\n\tstoreName: false\n};\n\nexport default class MagicString {\n\tconstructor(string, options = {}) {\n\t\tconst chunk = new Chunk(0, string.length, string);\n\n\t\tObject.defineProperties(this, {\n\t\t\toriginal:              { writable: true, value: string },\n\t\t\toutro:                 { writable: true, value: '' },\n\t\t\tintro:                 { writable: true, value: '' },\n\t\t\tfirstChunk:            { writable: true, value: chunk },\n\t\t\tlastChunk:             { writable: true, value: chunk },\n\t\t\tlastSearchedChunk:     { writable: true, value: chunk },\n\t\t\tbyStart:               { writable: true, value: {} },\n\t\t\tbyEnd:                 { writable: true, value: {} },\n\t\t\tfilename:              { writable: true, value: options.filename },\n\t\t\tindentExclusionRanges: { writable: true, value: options.indentExclusionRanges },\n\t\t\tsourcemapLocations:    { writable: true, value: new BitSet() },\n\t\t\tstoredNames:           { writable: true, value: {} },\n\t\t\tindentStr:             { writable: true, value: guessIndent(string) }\n\t\t});\n\n\t\tif (DEBUG) {\n\t\t\tObject.defineProperty(this, 'stats', { value: new Stats() });\n\t\t}\n\n\t\tthis.byStart[0] = chunk;\n\t\tthis.byEnd[string.length] = chunk;\n\t}\n\n\taddSourcemapLocation(char) {\n\t\tthis.sourcemapLocations.add(char);\n\t}\n\n\tappend(content) {\n\t\tif (typeof content !== 'string') throw new TypeError('outro content must be a string');\n\n\t\tthis.outro += content;\n\t\treturn this;\n\t}\n\n\tappendLeft(index, content) {\n\t\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n\t\tif (DEBUG) this.stats.time('appendLeft');\n\n\t\tthis._split(index);\n\n\t\tconst chunk = this.byEnd[index];\n\n\t\tif (chunk) {\n\t\t\tchunk.appendLeft(content);\n\t\t} else {\n\t\t\tthis.intro += content;\n\t\t}\n\n\t\tif (DEBUG) this.stats.timeEnd('appendLeft');\n\t\treturn this;\n\t}\n\n\tappendRight(index, content) {\n\t\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n\t\tif (DEBUG) this.stats.time('appendRight');\n\n\t\tthis._split(index);\n\n\t\tconst chunk = this.byStart[index];\n\n\t\tif (chunk) {\n\t\t\tchunk.appendRight(content);\n\t\t} else {\n\t\t\tthis.outro += content;\n\t\t}\n\n\t\tif (DEBUG) this.stats.timeEnd('appendRight');\n\t\treturn this;\n\t}\n\n\tclone() {\n\t\tconst cloned = new MagicString(this.original, { filename: this.filename });\n\n\t\tlet originalChunk = this.firstChunk;\n\t\tlet clonedChunk = (cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone());\n\n\t\twhile (originalChunk) {\n\t\t\tcloned.byStart[clonedChunk.start] = clonedChunk;\n\t\t\tcloned.byEnd[clonedChunk.end] = clonedChunk;\n\n\t\t\tconst nextOriginalChunk = originalChunk.next;\n\t\t\tconst nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();\n\n\t\t\tif (nextClonedChunk) {\n\t\t\t\tclonedChunk.next = nextClonedChunk;\n\t\t\t\tnextClonedChunk.previous = clonedChunk;\n\n\t\t\t\tclonedChunk = nextClonedChunk;\n\t\t\t}\n\n\t\t\toriginalChunk = nextOriginalChunk;\n\t\t}\n\n\t\tcloned.lastChunk = clonedChunk;\n\n\t\tif (this.indentExclusionRanges) {\n\t\t\tcloned.indentExclusionRanges = this.indentExclusionRanges.slice();\n\t\t}\n\n\t\tcloned.sourcemapLocations = new BitSet(this.sourcemapLocations);\n\n\t\tcloned.intro = this.intro;\n\t\tcloned.outro = this.outro;\n\n\t\treturn cloned;\n\t}\n\n\tgenerateDecodedMap(options) {\n\t\toptions = options || {};\n\n\t\tconst sourceIndex = 0;\n\t\tconst names = Object.keys(this.storedNames);\n\t\tconst mappings = new Mappings(options.hires);\n\n\t\tconst locate = getLocator(this.original);\n\n\t\tif (this.intro) {\n\t\t\tmappings.advance(this.intro);\n\t\t}\n\n\t\tthis.firstChunk.eachNext(chunk => {\n\t\t\tconst loc = locate(chunk.start);\n\n\t\t\tif (chunk.intro.length) mappings.advance(chunk.intro);\n\n\t\t\tif (chunk.edited) {\n\t\t\t\tmappings.addEdit(\n\t\t\t\t\tsourceIndex,\n\t\t\t\t\tchunk.content,\n\t\t\t\t\tloc,\n\t\t\t\t\tchunk.storeName ? names.indexOf(chunk.original) : -1\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tmappings.addUneditedChunk(sourceIndex, chunk, this.original, loc, this.sourcemapLocations);\n\t\t\t}\n\n\t\t\tif (chunk.outro.length) mappings.advance(chunk.outro);\n\t\t});\n\n\t\treturn {\n\t\t\tfile: options.file ? options.file.split(/[/\\\\]/).pop() : null,\n\t\t\tsources: [options.source ? getRelativePath(options.file || '', options.source) : null],\n\t\t\tsourcesContent: options.includeContent ? [this.original] : [null],\n\t\t\tnames,\n\t\t\tmappings: mappings.raw\n\t\t};\n\t}\n\n\tgenerateMap(options) {\n\t\treturn new SourceMap(this.generateDecodedMap(options));\n\t}\n\n\tgetIndentString() {\n\t\treturn this.indentStr === null ? '\\t' : this.indentStr;\n\t}\n\n\tindent(indentStr, options) {\n\t\tconst pattern = /^[^\\r\\n]/gm;\n\n\t\tif (isObject(indentStr)) {\n\t\t\toptions = indentStr;\n\t\t\tindentStr = undefined;\n\t\t}\n\n\t\tindentStr = indentStr !== undefined ? indentStr : this.indentStr || '\\t';\n\n\t\tif (indentStr === '') return this; // noop\n\n\t\toptions = options || {};\n\n\t\t// Process exclusion ranges\n\t\tconst isExcluded = {};\n\n\t\tif (options.exclude) {\n\t\t\tconst exclusions =\n\t\t\t\ttypeof options.exclude[0] === 'number' ? [options.exclude] : options.exclude;\n\t\t\texclusions.forEach(exclusion => {\n\t\t\t\tfor (let i = exclusion[0]; i < exclusion[1]; i += 1) {\n\t\t\t\t\tisExcluded[i] = true;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tlet shouldIndentNextCharacter = options.indentStart !== false;\n\t\tconst replacer = match => {\n\t\t\tif (shouldIndentNextCharacter) return `${indentStr}${match}`;\n\t\t\tshouldIndentNextCharacter = true;\n\t\t\treturn match;\n\t\t};\n\n\t\tthis.intro = this.intro.replace(pattern, replacer);\n\n\t\tlet charIndex = 0;\n\t\tlet chunk = this.firstChunk;\n\n\t\twhile (chunk) {\n\t\t\tconst end = chunk.end;\n\n\t\t\tif (chunk.edited) {\n\t\t\t\tif (!isExcluded[charIndex]) {\n\t\t\t\t\tchunk.content = chunk.content.replace(pattern, replacer);\n\n\t\t\t\t\tif (chunk.content.length) {\n\t\t\t\t\t\tshouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === '\\n';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcharIndex = chunk.start;\n\n\t\t\t\twhile (charIndex < end) {\n\t\t\t\t\tif (!isExcluded[charIndex]) {\n\t\t\t\t\t\tconst char = this.original[charIndex];\n\n\t\t\t\t\t\tif (char === '\\n') {\n\t\t\t\t\t\t\tshouldIndentNextCharacter = true;\n\t\t\t\t\t\t} else if (char !== '\\r' && shouldIndentNextCharacter) {\n\t\t\t\t\t\t\tshouldIndentNextCharacter = false;\n\n\t\t\t\t\t\t\tif (charIndex === chunk.start) {\n\t\t\t\t\t\t\t\tchunk.prependRight(indentStr);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis._splitChunk(chunk, charIndex);\n\t\t\t\t\t\t\t\tchunk = chunk.next;\n\t\t\t\t\t\t\t\tchunk.prependRight(indentStr);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tcharIndex += 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcharIndex = chunk.end;\n\t\t\tchunk = chunk.next;\n\t\t}\n\n\t\tthis.outro = this.outro.replace(pattern, replacer);\n\n\t\treturn this;\n\t}\n\n\tinsert() {\n\t\tthrow new Error('magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)');\n\t}\n\n\tinsertLeft(index, content) {\n\t\tif (!warned.insertLeft) {\n\t\t\tconsole.warn('magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead'); // eslint-disable-line no-console\n\t\t\twarned.insertLeft = true;\n\t\t}\n\n\t\treturn this.appendLeft(index, content);\n\t}\n\n\tinsertRight(index, content) {\n\t\tif (!warned.insertRight) {\n\t\t\tconsole.warn('magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead'); // eslint-disable-line no-console\n\t\t\twarned.insertRight = true;\n\t\t}\n\n\t\treturn this.prependRight(index, content);\n\t}\n\n\tmove(start, end, index) {\n\t\tif (index >= start && index <= end) throw new Error('Cannot move a selection inside itself');\n\n\t\tif (DEBUG) this.stats.time('move');\n\n\t\tthis._split(start);\n\t\tthis._split(end);\n\t\tthis._split(index);\n\n\t\tconst first = this.byStart[start];\n\t\tconst last = this.byEnd[end];\n\n\t\tconst oldLeft = first.previous;\n\t\tconst oldRight = last.next;\n\n\t\tconst newRight = this.byStart[index];\n\t\tif (!newRight && last === this.lastChunk) return this;\n\t\tconst newLeft = newRight ? newRight.previous : this.lastChunk;\n\n\t\tif (oldLeft) oldLeft.next = oldRight;\n\t\tif (oldRight) oldRight.previous = oldLeft;\n\n\t\tif (newLeft) newLeft.next = first;\n\t\tif (newRight) newRight.previous = last;\n\n\t\tif (!first.previous) this.firstChunk = last.next;\n\t\tif (!last.next) {\n\t\t\tthis.lastChunk = first.previous;\n\t\t\tthis.lastChunk.next = null;\n\t\t}\n\n\t\tfirst.previous = newLeft;\n\t\tlast.next = newRight || null;\n\n\t\tif (!newLeft) this.firstChunk = first;\n\t\tif (!newRight) this.lastChunk = last;\n\n\t\tif (DEBUG) this.stats.timeEnd('move');\n\t\treturn this;\n\t}\n\n\toverwrite(start, end, content, options) {\n\t\tif (typeof content !== 'string') throw new TypeError('replacement content must be a string');\n\n\t\twhile (start < 0) start += this.original.length;\n\t\twhile (end < 0) end += this.original.length;\n\n\t\tif (end > this.original.length) throw new Error('end is out of bounds');\n\t\tif (start === end)\n\t\t\tthrow new Error('Cannot overwrite a zero-length range – use appendLeft or prependRight instead');\n\n\t\tif (DEBUG) this.stats.time('overwrite');\n\n\t\tthis._split(start);\n\t\tthis._split(end);\n\n\t\tif (options === true) {\n\t\t\tif (!warned.storeName) {\n\t\t\t\tconsole.warn('The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string'); // eslint-disable-line no-console\n\t\t\t\twarned.storeName = true;\n\t\t\t}\n\n\t\t\toptions = { storeName: true };\n\t\t}\n\t\tconst storeName = options !== undefined ? options.storeName : false;\n\t\tconst contentOnly = options !== undefined ? options.contentOnly : false;\n\n\t\tif (storeName) {\n\t\t\tconst original = this.original.slice(start, end);\n\t\t\tthis.storedNames[original] = true;\n\t\t}\n\n\t\tconst first = this.byStart[start];\n\t\tconst last = this.byEnd[end];\n\n\t\tif (first) {\n\t\t\tif (end > first.end && first.next !== this.byStart[first.end]) {\n\t\t\t\tthrow new Error('Cannot overwrite across a split point');\n\t\t\t}\n\n\t\t\tfirst.edit(content, storeName, contentOnly);\n\n\t\t\tif (first !== last) {\n\t\t\t\tlet chunk = first.next;\n\t\t\t\twhile (chunk !== last) {\n\t\t\t\t\tchunk.edit('', false);\n\t\t\t\t\tchunk = chunk.next;\n\t\t\t\t}\n\n\t\t\t\tchunk.edit('', false);\n\t\t\t}\n\t\t} else {\n\t\t\t// must be inserting at the end\n\t\t\tconst newChunk = new Chunk(start, end, '').edit(content, storeName);\n\n\t\t\t// TODO last chunk in the array may not be the last chunk, if it's moved...\n\t\t\tlast.next = newChunk;\n\t\t\tnewChunk.previous = last;\n\t\t}\n\n\t\tif (DEBUG) this.stats.timeEnd('overwrite');\n\t\treturn this;\n\t}\n\n\tprepend(content) {\n\t\tif (typeof content !== 'string') throw new TypeError('outro content must be a string');\n\n\t\tthis.intro = content + this.intro;\n\t\treturn this;\n\t}\n\n\tprependLeft(index, content) {\n\t\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n\t\tif (DEBUG) this.stats.time('insertRight');\n\n\t\tthis._split(index);\n\n\t\tconst chunk = this.byEnd[index];\n\n\t\tif (chunk) {\n\t\t\tchunk.prependLeft(content);\n\t\t} else {\n\t\t\tthis.intro = content + this.intro;\n\t\t}\n\n\t\tif (DEBUG) this.stats.timeEnd('insertRight');\n\t\treturn this;\n\t}\n\n\tprependRight(index, content) {\n\t\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n\t\tif (DEBUG) this.stats.time('insertRight');\n\n\t\tthis._split(index);\n\n\t\tconst chunk = this.byStart[index];\n\n\t\tif (chunk) {\n\t\t\tchunk.prependRight(content);\n\t\t} else {\n\t\t\tthis.outro = content + this.outro;\n\t\t}\n\n\t\tif (DEBUG) this.stats.timeEnd('insertRight');\n\t\treturn this;\n\t}\n\n\tremove(start, end) {\n\t\twhile (start < 0) start += this.original.length;\n\t\twhile (end < 0) end += this.original.length;\n\n\t\tif (start === end) return this;\n\n\t\tif (start < 0 || end > this.original.length) throw new Error('Character is out of bounds');\n\t\tif (start > end) throw new Error('end must be greater than start');\n\n\t\tif (DEBUG) this.stats.time('remove');\n\n\t\tthis._split(start);\n\t\tthis._split(end);\n\n\t\tlet chunk = this.byStart[start];\n\n\t\twhile (chunk) {\n\t\t\tchunk.intro = '';\n\t\t\tchunk.outro = '';\n\t\t\tchunk.edit('');\n\n\t\t\tchunk = end > chunk.end ? this.byStart[chunk.end] : null;\n\t\t}\n\n\t\tif (DEBUG) this.stats.timeEnd('remove');\n\t\treturn this;\n\t}\n\n\tlastChar() {\n\t\tif (this.outro.length)\n\t\t\treturn this.outro[this.outro.length - 1];\n\t\tlet chunk = this.lastChunk;\n\t\tdo {\n\t\t\tif (chunk.outro.length)\n\t\t\t\treturn chunk.outro[chunk.outro.length - 1];\n\t\t\tif (chunk.content.length)\n\t\t\t\treturn chunk.content[chunk.content.length - 1];\n\t\t\tif (chunk.intro.length)\n\t\t\t\treturn chunk.intro[chunk.intro.length - 1];\n\t\t} while (chunk = chunk.previous);\n\t\tif (this.intro.length)\n\t\t\treturn this.intro[this.intro.length - 1];\n\t\treturn '';\n\t}\n\n\tlastLine() {\n\t\tlet lineIndex = this.outro.lastIndexOf(n);\n\t\tif (lineIndex !== -1)\n\t\t\treturn this.outro.substr(lineIndex + 1);\n\t\tlet lineStr = this.outro;\n\t\tlet chunk = this.lastChunk;\n\t\tdo {\n\t\t\tif (chunk.outro.length > 0) {\n\t\t\t\tlineIndex = chunk.outro.lastIndexOf(n);\n\t\t\t\tif (lineIndex !== -1)\n\t\t\t\t\treturn chunk.outro.substr(lineIndex + 1) + lineStr;\n\t\t\t\tlineStr = chunk.outro + lineStr;\n\t\t\t}\n\n\t\t\tif (chunk.content.length > 0) {\n\t\t\t\tlineIndex = chunk.content.lastIndexOf(n);\n\t\t\t\tif (lineIndex !== -1)\n\t\t\t\t\treturn chunk.content.substr(lineIndex + 1) + lineStr;\n\t\t\t\tlineStr = chunk.content + lineStr;\n\t\t\t}\n\n\t\t\tif (chunk.intro.length > 0) {\n\t\t\t\tlineIndex = chunk.intro.lastIndexOf(n);\n\t\t\t\tif (lineIndex !== -1)\n\t\t\t\t\treturn chunk.intro.substr(lineIndex + 1) + lineStr;\n\t\t\t\tlineStr = chunk.intro + lineStr;\n\t\t\t}\n\t\t} while (chunk = chunk.previous);\n\t\tlineIndex = this.intro.lastIndexOf(n);\n\t\tif (lineIndex !== -1)\n\t\t\treturn this.intro.substr(lineIndex + 1) + lineStr;\n\t\treturn this.intro + lineStr;\n\t}\n\n\tslice(start = 0, end = this.original.length) {\n\t\twhile (start < 0) start += this.original.length;\n\t\twhile (end < 0) end += this.original.length;\n\n\t\tlet result = '';\n\n\t\t// find start chunk\n\t\tlet chunk = this.firstChunk;\n\t\twhile (chunk && (chunk.start > start || chunk.end <= start)) {\n\t\t\t// found end chunk before start\n\t\t\tif (chunk.start < end && chunk.end >= end) {\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\tchunk = chunk.next;\n\t\t}\n\n\t\tif (chunk && chunk.edited && chunk.start !== start)\n\t\t\tthrow new Error(`Cannot use replaced character ${start} as slice start anchor.`);\n\n\t\tconst startChunk = chunk;\n\t\twhile (chunk) {\n\t\t\tif (chunk.intro && (startChunk !== chunk || chunk.start === start)) {\n\t\t\t\tresult += chunk.intro;\n\t\t\t}\n\n\t\t\tconst containsEnd = chunk.start < end && chunk.end >= end;\n\t\t\tif (containsEnd && chunk.edited && chunk.end !== end)\n\t\t\t\tthrow new Error(`Cannot use replaced character ${end} as slice end anchor.`);\n\n\t\t\tconst sliceStart = startChunk === chunk ? start - chunk.start : 0;\n\t\t\tconst sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;\n\n\t\t\tresult += chunk.content.slice(sliceStart, sliceEnd);\n\n\t\t\tif (chunk.outro && (!containsEnd || chunk.end === end)) {\n\t\t\t\tresult += chunk.outro;\n\t\t\t}\n\n\t\t\tif (containsEnd) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tchunk = chunk.next;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t// TODO deprecate this? not really very useful\n\tsnip(start, end) {\n\t\tconst clone = this.clone();\n\t\tclone.remove(0, start);\n\t\tclone.remove(end, clone.original.length);\n\n\t\treturn clone;\n\t}\n\n\t_split(index) {\n\t\tif (this.byStart[index] || this.byEnd[index]) return;\n\n\t\tif (DEBUG) this.stats.time('_split');\n\n\t\tlet chunk = this.lastSearchedChunk;\n\t\tconst searchForward = index > chunk.end;\n\n\t\twhile (chunk) {\n\t\t\tif (chunk.contains(index)) return this._splitChunk(chunk, index);\n\n\t\t\tchunk = searchForward ? this.byStart[chunk.end] : this.byEnd[chunk.start];\n\t\t}\n\t}\n\n\t_splitChunk(chunk, index) {\n\t\tif (chunk.edited && chunk.content.length) {\n\t\t\t// zero-length edited chunks are a special case (overlapping replacements)\n\t\t\tconst loc = getLocator(this.original)(index);\n\t\t\tthrow new Error(\n\t\t\t\t`Cannot split a chunk that has already been edited (${loc.line}:${loc.column} – \"${\n\t\t\t\t\tchunk.original\n\t\t\t\t}\")`\n\t\t\t);\n\t\t}\n\n\t\tconst newChunk = chunk.split(index);\n\n\t\tthis.byEnd[index] = chunk;\n\t\tthis.byStart[index] = newChunk;\n\t\tthis.byEnd[newChunk.end] = newChunk;\n\n\t\tif (chunk === this.lastChunk) this.lastChunk = newChunk;\n\n\t\tthis.lastSearchedChunk = chunk;\n\t\tif (DEBUG) this.stats.timeEnd('_split');\n\t\treturn true;\n\t}\n\n\ttoString() {\n\t\tlet str = this.intro;\n\n\t\tlet chunk = this.firstChunk;\n\t\twhile (chunk) {\n\t\t\tstr += chunk.toString();\n\t\t\tchunk = chunk.next;\n\t\t}\n\n\t\treturn str + this.outro;\n\t}\n\n\tisEmpty() {\n\t\tlet chunk = this.firstChunk;\n\t\tdo {\n\t\t\tif (chunk.intro.length && chunk.intro.trim() ||\n\t\t\t\t\tchunk.content.length && chunk.content.trim() ||\n\t\t\t\t\tchunk.outro.length && chunk.outro.trim())\n\t\t\t\treturn false;\n\t\t} while (chunk = chunk.next);\n\t\treturn true;\n\t}\n\n\tlength() {\n\t\tlet chunk = this.firstChunk;\n\t\tlet length = 0;\n\t\tdo {\n\t\t\tlength += chunk.intro.length + chunk.content.length + chunk.outro.length;\n\t\t} while (chunk = chunk.next);\n\t\treturn length;\n\t}\n\n\ttrimLines() {\n\t\treturn this.trim('[\\\\r\\\\n]');\n\t}\n\n\ttrim(charType) {\n\t\treturn this.trimStart(charType).trimEnd(charType);\n\t}\n\n\ttrimEndAborted(charType) {\n\t\tconst rx = new RegExp((charType || '\\\\s') + '+$');\n\n\t\tthis.outro = this.outro.replace(rx, '');\n\t\tif (this.outro.length) return true;\n\n\t\tlet chunk = this.lastChunk;\n\n\t\tdo {\n\t\t\tconst end = chunk.end;\n\t\t\tconst aborted = chunk.trimEnd(rx);\n\n\t\t\t// if chunk was trimmed, we have a new lastChunk\n\t\t\tif (chunk.end !== end) {\n\t\t\t\tif (this.lastChunk === chunk) {\n\t\t\t\t\tthis.lastChunk = chunk.next;\n\t\t\t\t}\n\n\t\t\t\tthis.byEnd[chunk.end] = chunk;\n\t\t\t\tthis.byStart[chunk.next.start] = chunk.next;\n\t\t\t\tthis.byEnd[chunk.next.end] = chunk.next;\n\t\t\t}\n\n\t\t\tif (aborted) return true;\n\t\t\tchunk = chunk.previous;\n\t\t} while (chunk);\n\n\t\treturn false;\n\t}\n\n\ttrimEnd(charType) {\n\t\tthis.trimEndAborted(charType);\n\t\treturn this;\n\t}\n\ttrimStartAborted(charType) {\n\t\tconst rx = new RegExp('^' + (charType || '\\\\s') + '+');\n\n\t\tthis.intro = this.intro.replace(rx, '');\n\t\tif (this.intro.length) return true;\n\n\t\tlet chunk = this.firstChunk;\n\n\t\tdo {\n\t\t\tconst end = chunk.end;\n\t\t\tconst aborted = chunk.trimStart(rx);\n\n\t\t\tif (chunk.end !== end) {\n\t\t\t\t// special case...\n\t\t\t\tif (chunk === this.lastChunk) this.lastChunk = chunk.next;\n\n\t\t\t\tthis.byEnd[chunk.end] = chunk;\n\t\t\t\tthis.byStart[chunk.next.start] = chunk.next;\n\t\t\t\tthis.byEnd[chunk.next.end] = chunk.next;\n\t\t\t}\n\n\t\t\tif (aborted) return true;\n\t\t\tchunk = chunk.next;\n\t\t} while (chunk);\n\n\t\treturn false;\n\t}\n\n\ttrimStart(charType) {\n\t\tthis.trimStartAborted(charType);\n\t\treturn this;\n\t}\n}\n","import MagicString from './MagicString.js';\nimport SourceMap from './SourceMap.js';\nimport getRelativePath from './utils/getRelativePath.js';\nimport isObject from './utils/isObject.js';\nimport getLocator from './utils/getLocator.js';\nimport Mappings from './utils/Mappings.js';\n\nconst hasOwnProp = Object.prototype.hasOwnProperty;\n\nexport default class Bundle {\n\tconstructor(options = {}) {\n\t\tthis.intro = options.intro || '';\n\t\tthis.separator = options.separator !== undefined ? options.separator : '\\n';\n\t\tthis.sources = [];\n\t\tthis.uniqueSources = [];\n\t\tthis.uniqueSourceIndexByFilename = {};\n\t}\n\n\taddSource(source) {\n\t\tif (source instanceof MagicString) {\n\t\t\treturn this.addSource({\n\t\t\t\tcontent: source,\n\t\t\t\tfilename: source.filename,\n\t\t\t\tseparator: this.separator\n\t\t\t});\n\t\t}\n\n\t\tif (!isObject(source) || !source.content) {\n\t\t\tthrow new Error('bundle.addSource() takes an object with a `content` property, which should be an instance of MagicString, and an optional `filename`');\n\t\t}\n\n\t\t['filename', 'indentExclusionRanges', 'separator'].forEach(option => {\n\t\t\tif (!hasOwnProp.call(source, option)) source[option] = source.content[option];\n\t\t});\n\n\t\tif (source.separator === undefined) {\n\t\t\t// TODO there's a bunch of this sort of thing, needs cleaning up\n\t\t\tsource.separator = this.separator;\n\t\t}\n\n\t\tif (source.filename) {\n\t\t\tif (!hasOwnProp.call(this.uniqueSourceIndexByFilename, source.filename)) {\n\t\t\t\tthis.uniqueSourceIndexByFilename[source.filename] = this.uniqueSources.length;\n\t\t\t\tthis.uniqueSources.push({ filename: source.filename, content: source.content.original });\n\t\t\t} else {\n\t\t\t\tconst uniqueSource = this.uniqueSources[this.uniqueSourceIndexByFilename[source.filename]];\n\t\t\t\tif (source.content.original !== uniqueSource.content) {\n\t\t\t\t\tthrow new Error(`Illegal source: same filename (${source.filename}), different contents`);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.sources.push(source);\n\t\treturn this;\n\t}\n\n\tappend(str, options) {\n\t\tthis.addSource({\n\t\t\tcontent: new MagicString(str),\n\t\t\tseparator: (options && options.separator) || ''\n\t\t});\n\n\t\treturn this;\n\t}\n\n\tclone() {\n\t\tconst bundle = new Bundle({\n\t\t\tintro: this.intro,\n\t\t\tseparator: this.separator\n\t\t});\n\n\t\tthis.sources.forEach(source => {\n\t\t\tbundle.addSource({\n\t\t\t\tfilename: source.filename,\n\t\t\t\tcontent: source.content.clone(),\n\t\t\t\tseparator: source.separator\n\t\t\t});\n\t\t});\n\n\t\treturn bundle;\n\t}\n\n\tgenerateDecodedMap(options = {}) {\n\t\tconst names = [];\n\t\tthis.sources.forEach(source => {\n\t\t\tObject.keys(source.content.storedNames).forEach(name => {\n\t\t\t\tif (!~names.indexOf(name)) names.push(name);\n\t\t\t});\n\t\t});\n\n\t\tconst mappings = new Mappings(options.hires);\n\n\t\tif (this.intro) {\n\t\t\tmappings.advance(this.intro);\n\t\t}\n\n\t\tthis.sources.forEach((source, i) => {\n\t\t\tif (i > 0) {\n\t\t\t\tmappings.advance(this.separator);\n\t\t\t}\n\n\t\t\tconst sourceIndex = source.filename ? this.uniqueSourceIndexByFilename[source.filename] : -1;\n\t\t\tconst magicString = source.content;\n\t\t\tconst locate = getLocator(magicString.original);\n\n\t\t\tif (magicString.intro) {\n\t\t\t\tmappings.advance(magicString.intro);\n\t\t\t}\n\n\t\t\tmagicString.firstChunk.eachNext(chunk => {\n\t\t\t\tconst loc = locate(chunk.start);\n\n\t\t\t\tif (chunk.intro.length) mappings.advance(chunk.intro);\n\n\t\t\t\tif (source.filename) {\n\t\t\t\t\tif (chunk.edited) {\n\t\t\t\t\t\tmappings.addEdit(\n\t\t\t\t\t\t\tsourceIndex,\n\t\t\t\t\t\t\tchunk.content,\n\t\t\t\t\t\t\tloc,\n\t\t\t\t\t\t\tchunk.storeName ? names.indexOf(chunk.original) : -1\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmappings.addUneditedChunk(\n\t\t\t\t\t\t\tsourceIndex,\n\t\t\t\t\t\t\tchunk,\n\t\t\t\t\t\t\tmagicString.original,\n\t\t\t\t\t\t\tloc,\n\t\t\t\t\t\t\tmagicString.sourcemapLocations\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tmappings.advance(chunk.content);\n\t\t\t\t}\n\n\t\t\t\tif (chunk.outro.length) mappings.advance(chunk.outro);\n\t\t\t});\n\n\t\t\tif (magicString.outro) {\n\t\t\t\tmappings.advance(magicString.outro);\n\t\t\t}\n\t\t});\n\n\t\treturn {\n\t\t\tfile: options.file ? options.file.split(/[/\\\\]/).pop() : null,\n\t\t\tsources: this.uniqueSources.map(source => {\n\t\t\t\treturn options.file ? getRelativePath(options.file, source.filename) : source.filename;\n\t\t\t}),\n\t\t\tsourcesContent: this.uniqueSources.map(source => {\n\t\t\t\treturn options.includeContent ? source.content : null;\n\t\t\t}),\n\t\t\tnames,\n\t\t\tmappings: mappings.raw\n\t\t};\n\t}\n\n\tgenerateMap(options) {\n\t\treturn new SourceMap(this.generateDecodedMap(options));\n\t}\n\n\tgetIndentString() {\n\t\tconst indentStringCounts = {};\n\n\t\tthis.sources.forEach(source => {\n\t\t\tconst indentStr = source.content.indentStr;\n\n\t\t\tif (indentStr === null) return;\n\n\t\t\tif (!indentStringCounts[indentStr]) indentStringCounts[indentStr] = 0;\n\t\t\tindentStringCounts[indentStr] += 1;\n\t\t});\n\n\t\treturn (\n\t\t\tObject.keys(indentStringCounts).sort((a, b) => {\n\t\t\t\treturn indentStringCounts[a] - indentStringCounts[b];\n\t\t\t})[0] || '\\t'\n\t\t);\n\t}\n\n\tindent(indentStr) {\n\t\tif (!arguments.length) {\n\t\t\tindentStr = this.getIndentString();\n\t\t}\n\n\t\tif (indentStr === '') return this; // noop\n\n\t\tlet trailingNewline = !this.intro || this.intro.slice(-1) === '\\n';\n\n\t\tthis.sources.forEach((source, i) => {\n\t\t\tconst separator = source.separator !== undefined ? source.separator : this.separator;\n\t\t\tconst indentStart = trailingNewline || (i > 0 && /\\r?\\n$/.test(separator));\n\n\t\t\tsource.content.indent(indentStr, {\n\t\t\t\texclude: source.indentExclusionRanges,\n\t\t\t\tindentStart //: trailingNewline || /\\r?\\n$/.test( separator )  //true///\\r?\\n/.test( separator )\n\t\t\t});\n\n\t\t\ttrailingNewline = source.content.lastChar() === '\\n';\n\t\t});\n\n\t\tif (this.intro) {\n\t\t\tthis.intro =\n\t\t\t\tindentStr +\n\t\t\t\tthis.intro.replace(/^[^\\n]/gm, (match, index) => {\n\t\t\t\t\treturn index > 0 ? indentStr + match : match;\n\t\t\t\t});\n\t\t}\n\n\t\treturn this;\n\t}\n\n\tprepend(str) {\n\t\tthis.intro = str + this.intro;\n\t\treturn this;\n\t}\n\n\ttoString() {\n\t\tconst body = this.sources\n\t\t\t.map((source, i) => {\n\t\t\t\tconst separator = source.separator !== undefined ? source.separator : this.separator;\n\t\t\t\tconst str = (i > 0 ? separator : '') + source.content.toString();\n\n\t\t\t\treturn str;\n\t\t\t})\n\t\t\t.join('');\n\n\t\treturn this.intro + body;\n\t}\n\n\tisEmpty () {\n\t\tif (this.intro.length && this.intro.trim())\n\t\t\treturn false;\n\t\tif (this.sources.some(source => !source.content.isEmpty()))\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\tlength() {\n\t\treturn this.sources.reduce((length, source) => length + source.content.length(), this.intro.length);\n\t}\n\n\ttrimLines() {\n\t\treturn this.trim('[\\\\r\\\\n]');\n\t}\n\n\ttrim(charType) {\n\t\treturn this.trimStart(charType).trimEnd(charType);\n\t}\n\n\ttrimStart(charType) {\n\t\tconst rx = new RegExp('^' + (charType || '\\\\s') + '+');\n\t\tthis.intro = this.intro.replace(rx, '');\n\n\t\tif (!this.intro) {\n\t\t\tlet source;\n\t\t\tlet i = 0;\n\n\t\t\tdo {\n\t\t\t\tsource = this.sources[i++];\n\t\t\t\tif (!source) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} while (!source.content.trimStartAborted(charType));\n\t\t}\n\n\t\treturn this;\n\t}\n\n\ttrimEnd(charType) {\n\t\tconst rx = new RegExp((charType || '\\\\s') + '+$');\n\n\t\tlet source;\n\t\tlet i = this.sources.length - 1;\n\n\t\tdo {\n\t\t\tsource = this.sources[i--];\n\t\t\tif (!source) {\n\t\t\t\tthis.intro = this.intro.replace(rx, '');\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (!source.content.trimEndAborted(charType));\n\n\t\treturn this;\n\t}\n}\n","import superPropBase from \"./superPropBase\";\nexport default function _get(target, property, receiver) {\n  if (typeof Reflect !== \"undefined\" && Reflect.get) {\n    _get = Reflect.get;\n  } else {\n    _get = function _get(target, property, receiver) {\n      var base = superPropBase(target, property);\n      if (!base) return;\n      var desc = Object.getOwnPropertyDescriptor(base, property);\n\n      if (desc.get) {\n        return desc.get.call(receiver);\n      }\n\n      return desc.value;\n    };\n  }\n\n  return _get(target, property, receiver || target);\n}","import getPrototypeOf from \"./getPrototypeOf\";\nexport default function _superPropBase(object, property) {\n  while (!Object.prototype.hasOwnProperty.call(object, property)) {\n    object = getPrototypeOf(object);\n    if (object === null) break;\n  }\n\n  return object;\n}","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DetailContext = exports.NoopContext = exports.VError = void 0;\n/**\n * Error thrown by validation. Besides an informative message, it includes the path to the\n * property which triggered the failure.\n */\nvar VError = /** @class */ (function (_super) {\n    __extends(VError, _super);\n    function VError(path, message) {\n        var _this = _super.call(this, message) || this;\n        _this.path = path;\n        // See https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work for info about this workaround.\n        Object.setPrototypeOf(_this, VError.prototype);\n        return _this;\n    }\n    return VError;\n}(Error));\nexports.VError = VError;\n/**\n * Fast implementation of IContext used for first-pass validation. If that fails, we can validate\n * using DetailContext to collect error messages. That's faster for the common case when messages\n * normally pass validation.\n */\nvar NoopContext = /** @class */ (function () {\n    function NoopContext() {\n    }\n    NoopContext.prototype.fail = function (relPath, message, score) {\n        return false;\n    };\n    NoopContext.prototype.unionResolver = function () { return this; };\n    NoopContext.prototype.createContext = function () { return this; };\n    NoopContext.prototype.resolveUnion = function (ur) { };\n    return NoopContext;\n}());\nexports.NoopContext = NoopContext;\n/**\n * Complete implementation of IContext that collects meaningfull errors.\n */\nvar DetailContext = /** @class */ (function () {\n    function DetailContext() {\n        // Stack of property names and associated messages for reporting helpful error messages.\n        this._propNames = [\"\"];\n        this._messages = [null];\n        // Score is used to choose the best union member whose DetailContext to use for reporting.\n        // Higher score means better match (or rather less severe mismatch).\n        this._score = 0;\n    }\n    DetailContext.prototype.fail = function (relPath, message, score) {\n        this._propNames.push(relPath);\n        this._messages.push(message);\n        this._score += score;\n        return false;\n    };\n    DetailContext.prototype.unionResolver = function () {\n        return new DetailUnionResolver();\n    };\n    DetailContext.prototype.resolveUnion = function (unionResolver) {\n        var _a, _b;\n        var u = unionResolver;\n        var best = null;\n        for (var _i = 0, _c = u.contexts; _i < _c.length; _i++) {\n            var ctx = _c[_i];\n            if (!best || ctx._score >= best._score) {\n                best = ctx;\n            }\n        }\n        if (best && best._score > 0) {\n            (_a = this._propNames).push.apply(_a, best._propNames);\n            (_b = this._messages).push.apply(_b, best._messages);\n        }\n    };\n    DetailContext.prototype.getError = function (path) {\n        var msgParts = [];\n        for (var i = this._propNames.length - 1; i >= 0; i--) {\n            var p = this._propNames[i];\n            path += (typeof p === \"number\") ? \"[\" + p + \"]\" : (p ? \".\" + p : \"\");\n            var m = this._messages[i];\n            if (m) {\n                msgParts.push(path + \" \" + m);\n            }\n        }\n        return new VError(path, msgParts.join(\"; \"));\n    };\n    DetailContext.prototype.getErrorDetail = function (path) {\n        var details = [];\n        for (var i = this._propNames.length - 1; i >= 0; i--) {\n            var p = this._propNames[i];\n            path += (typeof p === \"number\") ? \"[\" + p + \"]\" : (p ? \".\" + p : \"\");\n            var message = this._messages[i];\n            if (message) {\n                details.push({ path: path, message: message });\n            }\n        }\n        var detail = null;\n        for (var i = details.length - 1; i >= 0; i--) {\n            if (detail) {\n                details[i].nested = [detail];\n            }\n            detail = details[i];\n        }\n        return detail;\n    };\n    return DetailContext;\n}());\nexports.DetailContext = DetailContext;\nvar DetailUnionResolver = /** @class */ (function () {\n    function DetailUnionResolver() {\n        this.contexts = [];\n    }\n    DetailUnionResolver.prototype.createContext = function () {\n        var ctx = new DetailContext();\n        this.contexts.push(ctx);\n        return ctx;\n    };\n    return DetailUnionResolver;\n}());\n","function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nmodule.exports = _classCallCheck;","function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nmodule.exports = _createClass;","const numeric = /^[0-9]+$/\nconst compareIdentifiers = (a, b) => {\n  const anum = numeric.test(a)\n  const bnum = numeric.test(b)\n\n  if (anum && bnum) {\n    a = +a\n    b = +b\n  }\n\n  return a === b ? 0\n    : (anum && !bnum) ? -1\n    : (bnum && !anum) ? 1\n    : a < b ? -1\n    : 1\n}\n\nconst rcompareIdentifiers = (a, b) => compareIdentifiers(b, a)\n\nmodule.exports = {\n  compareIdentifiers,\n  rcompareIdentifiers\n}\n","const compare = require('./compare')\nconst eq = (a, b, loose) => compare(a, b, loose) === 0\nmodule.exports = eq\n","const SemVer = require('../classes/semver')\nconst compareBuild = (a, b, loose) => {\n  const versionA = new SemVer(a, loose)\n  const versionB = new SemVer(b, loose)\n  return versionA.compare(versionB) || versionA.compareBuild(versionB)\n}\nmodule.exports = compareBuild\n","const compare = require('./compare')\nconst lt = (a, b, loose) => compare(a, b, loose) < 0\nmodule.exports = lt\n","const compare = require('./compare')\nconst gte = (a, b, loose) => compare(a, b, loose) >= 0\nmodule.exports = gte\n","const compare = require('./compare')\nconst lte = (a, b, loose) => compare(a, b, loose) <= 0\nmodule.exports = lte\n","const SemVer = require('../classes/semver')\nconst Comparator = require('../classes/comparator')\nconst {ANY} = Comparator\nconst Range = require('../classes/range')\nconst satisfies = require('../functions/satisfies')\nconst gt = require('../functions/gt')\nconst lt = require('../functions/lt')\nconst lte = require('../functions/lte')\nconst gte = require('../functions/gte')\n\nconst outside = (version, range, hilo, options) => {\n  version = new SemVer(version, options)\n  range = new Range(range, options)\n\n  let gtfn, ltefn, ltfn, comp, ecomp\n  switch (hilo) {\n    case '>':\n      gtfn = gt\n      ltefn = lte\n      ltfn = lt\n      comp = '>'\n      ecomp = '>='\n      break\n    case '<':\n      gtfn = lt\n      ltefn = gte\n      ltfn = gt\n      comp = '<'\n      ecomp = '<='\n      break\n    default:\n      throw new TypeError('Must provide a hilo val of \"<\" or \">\"')\n  }\n\n  // If it satisifes the range it is not outside\n  if (satisfies(version, range, options)) {\n    return false\n  }\n\n  // From now on, variable terms are as if we're in \"gtr\" mode.\n  // but note that everything is flipped for the \"ltr\" function.\n\n  for (let i = 0; i < range.set.length; ++i) {\n    const comparators = range.set[i]\n\n    let high = null\n    let low = null\n\n    comparators.forEach((comparator) => {\n      if (comparator.semver === ANY) {\n        comparator = new Comparator('>=0.0.0')\n      }\n      high = high || comparator\n      low = low || comparator\n      if (gtfn(comparator.semver, high.semver, options)) {\n        high = comparator\n      } else if (ltfn(comparator.semver, low.semver, options)) {\n        low = comparator\n      }\n    })\n\n    // If the edge version comparator has a operator then our version\n    // isn't outside it\n    if (high.operator === comp || high.operator === ecomp) {\n      return false\n    }\n\n    // If the lowest version comparator has an operator and our version\n    // is less than it then it isn't higher than the range\n    if ((!low.operator || low.operator === comp) &&\n        ltefn(version, low.semver)) {\n      return false\n    } else if (low.operator === ecomp && ltfn(version, low.semver)) {\n      return false\n    }\n  }\n  return true\n}\n\nmodule.exports = outside\n","\"use strict\";\n/**\n * This module defines nodes used to define types and validations for objects and interfaces.\n */\n// tslint:disable:no-shadowed-variable prefer-for-of\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.basicTypes = exports.BasicType = exports.TParamList = exports.TParam = exports.param = exports.TFunc = exports.func = exports.TProp = exports.TOptional = exports.opt = exports.TIface = exports.iface = exports.TEnumLiteral = exports.enumlit = exports.TEnumType = exports.enumtype = exports.TIntersection = exports.intersection = exports.TUnion = exports.union = exports.TTuple = exports.tuple = exports.TArray = exports.array = exports.TLiteral = exports.lit = exports.TName = exports.name = exports.TType = void 0;\nvar util_1 = require(\"./util\");\n/** Node that represents a type. */\nvar TType = /** @class */ (function () {\n    function TType() {\n    }\n    return TType;\n}());\nexports.TType = TType;\n/** Parses a type spec into a TType node. */\nfunction parseSpec(typeSpec) {\n    return typeof typeSpec === \"string\" ? name(typeSpec) : typeSpec;\n}\nfunction getNamedType(suite, name) {\n    var ttype = suite[name];\n    if (!ttype) {\n        throw new Error(\"Unknown type \" + name);\n    }\n    return ttype;\n}\n/**\n * Defines a type name, either built-in, or defined in this suite. It can typically be included in\n * the specs as just a plain string.\n */\nfunction name(value) { return new TName(value); }\nexports.name = name;\nvar TName = /** @class */ (function (_super) {\n    __extends(TName, _super);\n    function TName(name) {\n        var _this = _super.call(this) || this;\n        _this.name = name;\n        _this._failMsg = \"is not a \" + name;\n        return _this;\n    }\n    TName.prototype.getChecker = function (suite, strict, allowedProps) {\n        var _this = this;\n        var ttype = getNamedType(suite, this.name);\n        var checker = ttype.getChecker(suite, strict, allowedProps);\n        if (ttype instanceof BasicType || ttype instanceof TName) {\n            return checker;\n        }\n        // For complex types, add an additional \"is not a <Type>\" message on failure.\n        return function (value, ctx) { return checker(value, ctx) ? true : ctx.fail(null, _this._failMsg, 0); };\n    };\n    return TName;\n}(TType));\nexports.TName = TName;\n/**\n * Defines a literal value, e.g. lit('hello') or lit(123).\n */\nfunction lit(value) { return new TLiteral(value); }\nexports.lit = lit;\nvar TLiteral = /** @class */ (function (_super) {\n    __extends(TLiteral, _super);\n    function TLiteral(value) {\n        var _this = _super.call(this) || this;\n        _this.value = value;\n        _this.name = JSON.stringify(value);\n        _this._failMsg = \"is not \" + _this.name;\n        return _this;\n    }\n    TLiteral.prototype.getChecker = function (suite, strict) {\n        var _this = this;\n        return function (value, ctx) { return (value === _this.value) ? true : ctx.fail(null, _this._failMsg, -1); };\n    };\n    return TLiteral;\n}(TType));\nexports.TLiteral = TLiteral;\n/**\n * Defines an array type, e.g. array('number').\n */\nfunction array(typeSpec) { return new TArray(parseSpec(typeSpec)); }\nexports.array = array;\nvar TArray = /** @class */ (function (_super) {\n    __extends(TArray, _super);\n    function TArray(ttype) {\n        var _this = _super.call(this) || this;\n        _this.ttype = ttype;\n        return _this;\n    }\n    TArray.prototype.getChecker = function (suite, strict) {\n        var itemChecker = this.ttype.getChecker(suite, strict);\n        return function (value, ctx) {\n            if (!Array.isArray(value)) {\n                return ctx.fail(null, \"is not an array\", 0);\n            }\n            for (var i = 0; i < value.length; i++) {\n                var ok = itemChecker(value[i], ctx);\n                if (!ok) {\n                    return ctx.fail(i, null, 1);\n                }\n            }\n            return true;\n        };\n    };\n    return TArray;\n}(TType));\nexports.TArray = TArray;\n/**\n * Defines a tuple type, e.g. tuple('string', 'number').\n */\nfunction tuple() {\n    var typeSpec = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        typeSpec[_i] = arguments[_i];\n    }\n    return new TTuple(typeSpec.map(function (t) { return parseSpec(t); }));\n}\nexports.tuple = tuple;\nvar TTuple = /** @class */ (function (_super) {\n    __extends(TTuple, _super);\n    function TTuple(ttypes) {\n        var _this = _super.call(this) || this;\n        _this.ttypes = ttypes;\n        return _this;\n    }\n    TTuple.prototype.getChecker = function (suite, strict) {\n        var itemCheckers = this.ttypes.map(function (t) { return t.getChecker(suite, strict); });\n        var checker = function (value, ctx) {\n            if (!Array.isArray(value)) {\n                return ctx.fail(null, \"is not an array\", 0);\n            }\n            for (var i = 0; i < itemCheckers.length; i++) {\n                var ok = itemCheckers[i](value[i], ctx);\n                if (!ok) {\n                    return ctx.fail(i, null, 1);\n                }\n            }\n            return true;\n        };\n        if (!strict) {\n            return checker;\n        }\n        return function (value, ctx) {\n            if (!checker(value, ctx)) {\n                return false;\n            }\n            return value.length <= itemCheckers.length ? true :\n                ctx.fail(itemCheckers.length, \"is extraneous\", 2);\n        };\n    };\n    return TTuple;\n}(TType));\nexports.TTuple = TTuple;\n/**\n * Defines a union type, e.g. union('number', 'null').\n */\nfunction union() {\n    var typeSpec = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        typeSpec[_i] = arguments[_i];\n    }\n    return new TUnion(typeSpec.map(function (t) { return parseSpec(t); }));\n}\nexports.union = union;\nvar TUnion = /** @class */ (function (_super) {\n    __extends(TUnion, _super);\n    function TUnion(ttypes) {\n        var _this = _super.call(this) || this;\n        _this.ttypes = ttypes;\n        var names = ttypes.map(function (t) { return t instanceof TName || t instanceof TLiteral ? t.name : null; })\n            .filter(function (n) { return n; });\n        var otherTypes = ttypes.length - names.length;\n        if (names.length) {\n            if (otherTypes > 0) {\n                names.push(otherTypes + \" more\");\n            }\n            _this._failMsg = \"is none of \" + names.join(\", \");\n        }\n        else {\n            _this._failMsg = \"is none of \" + otherTypes + \" types\";\n        }\n        return _this;\n    }\n    TUnion.prototype.getChecker = function (suite, strict) {\n        var _this = this;\n        var itemCheckers = this.ttypes.map(function (t) { return t.getChecker(suite, strict); });\n        return function (value, ctx) {\n            var ur = ctx.unionResolver();\n            for (var i = 0; i < itemCheckers.length; i++) {\n                var ok = itemCheckers[i](value, ur.createContext());\n                if (ok) {\n                    return true;\n                }\n            }\n            ctx.resolveUnion(ur);\n            return ctx.fail(null, _this._failMsg, 0);\n        };\n    };\n    return TUnion;\n}(TType));\nexports.TUnion = TUnion;\n/**\n * Defines an intersection type, e.g. intersection('number', 'null').\n */\nfunction intersection() {\n    var typeSpec = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        typeSpec[_i] = arguments[_i];\n    }\n    return new TIntersection(typeSpec.map(function (t) { return parseSpec(t); }));\n}\nexports.intersection = intersection;\nvar TIntersection = /** @class */ (function (_super) {\n    __extends(TIntersection, _super);\n    function TIntersection(ttypes) {\n        var _this = _super.call(this) || this;\n        _this.ttypes = ttypes;\n        return _this;\n    }\n    TIntersection.prototype.getChecker = function (suite, strict) {\n        var allowedProps = new Set();\n        var itemCheckers = this.ttypes.map(function (t) { return t.getChecker(suite, strict, allowedProps); });\n        return function (value, ctx) {\n            var ok = itemCheckers.every(function (checker) { return checker(value, ctx); });\n            if (ok) {\n                return true;\n            }\n            return ctx.fail(null, null, 0);\n        };\n    };\n    return TIntersection;\n}(TType));\nexports.TIntersection = TIntersection;\n/**\n * Defines an enum type, e.g. enum({'A': 1, 'B': 2}).\n */\nfunction enumtype(values) {\n    return new TEnumType(values);\n}\nexports.enumtype = enumtype;\nvar TEnumType = /** @class */ (function (_super) {\n    __extends(TEnumType, _super);\n    function TEnumType(members) {\n        var _this = _super.call(this) || this;\n        _this.members = members;\n        _this.validValues = new Set();\n        _this._failMsg = \"is not a valid enum value\";\n        _this.validValues = new Set(Object.keys(members).map(function (name) { return members[name]; }));\n        return _this;\n    }\n    TEnumType.prototype.getChecker = function (suite, strict) {\n        var _this = this;\n        return function (value, ctx) {\n            return (_this.validValues.has(value) ? true : ctx.fail(null, _this._failMsg, 0));\n        };\n    };\n    return TEnumType;\n}(TType));\nexports.TEnumType = TEnumType;\n/**\n * Defines a literal enum value, such as Direction.Up, specified as enumlit(\"Direction\", \"Up\").\n */\nfunction enumlit(name, prop) {\n    return new TEnumLiteral(name, prop);\n}\nexports.enumlit = enumlit;\nvar TEnumLiteral = /** @class */ (function (_super) {\n    __extends(TEnumLiteral, _super);\n    function TEnumLiteral(enumName, prop) {\n        var _this = _super.call(this) || this;\n        _this.enumName = enumName;\n        _this.prop = prop;\n        _this._failMsg = \"is not \" + enumName + \".\" + prop;\n        return _this;\n    }\n    TEnumLiteral.prototype.getChecker = function (suite, strict) {\n        var _this = this;\n        var ttype = getNamedType(suite, this.enumName);\n        if (!(ttype instanceof TEnumType)) {\n            throw new Error(\"Type \" + this.enumName + \" used in enumlit is not an enum type\");\n        }\n        var val = ttype.members[this.prop];\n        if (!ttype.members.hasOwnProperty(this.prop)) {\n            throw new Error(\"Unknown value \" + this.enumName + \".\" + this.prop + \" used in enumlit\");\n        }\n        return function (value, ctx) { return (value === val) ? true : ctx.fail(null, _this._failMsg, -1); };\n    };\n    return TEnumLiteral;\n}(TType));\nexports.TEnumLiteral = TEnumLiteral;\nfunction makeIfaceProps(props) {\n    return Object.keys(props).map(function (name) { return makeIfaceProp(name, props[name]); });\n}\nfunction makeIfaceProp(name, prop) {\n    return prop instanceof TOptional ?\n        new TProp(name, prop.ttype, true) :\n        new TProp(name, parseSpec(prop), false);\n}\n/**\n * Defines an interface. The first argument is an array of interfaces that it extends, and the\n * second is an array of properties.\n */\nfunction iface(bases, props) {\n    return new TIface(bases, makeIfaceProps(props));\n}\nexports.iface = iface;\nvar TIface = /** @class */ (function (_super) {\n    __extends(TIface, _super);\n    function TIface(bases, props) {\n        var _this = _super.call(this) || this;\n        _this.bases = bases;\n        _this.props = props;\n        _this.propSet = new Set(props.map(function (p) { return p.name; }));\n        return _this;\n    }\n    TIface.prototype.getChecker = function (suite, strict, allowedProps) {\n        var _this = this;\n        var baseCheckers = this.bases.map(function (b) { return getNamedType(suite, b).getChecker(suite, strict); });\n        var propCheckers = this.props.map(function (prop) { return prop.ttype.getChecker(suite, strict); });\n        var testCtx = new util_1.NoopContext();\n        // Consider a prop required if it's not optional AND does not allow for undefined as a value.\n        var isPropRequired = this.props.map(function (prop, i) {\n            return !prop.isOpt && !propCheckers[i](undefined, testCtx);\n        });\n        var checker = function (value, ctx) {\n            if (typeof value !== \"object\" || value === null) {\n                return ctx.fail(null, \"is not an object\", 0);\n            }\n            for (var i = 0; i < baseCheckers.length; i++) {\n                if (!baseCheckers[i](value, ctx)) {\n                    return false;\n                }\n            }\n            for (var i = 0; i < propCheckers.length; i++) {\n                var name_1 = _this.props[i].name;\n                var v = value[name_1];\n                if (v === undefined) {\n                    if (isPropRequired[i]) {\n                        return ctx.fail(name_1, \"is missing\", 1);\n                    }\n                }\n                else {\n                    var ok = propCheckers[i](v, ctx);\n                    if (!ok) {\n                        return ctx.fail(name_1, null, 1);\n                    }\n                }\n            }\n            return true;\n        };\n        if (!strict) {\n            return checker;\n        }\n        var propSet = this.propSet;\n        if (allowedProps) {\n            this.propSet.forEach(function (prop) { return allowedProps.add(prop); });\n            propSet = allowedProps;\n        }\n        // In strict mode, check also for unknown enumerable properties.\n        return function (value, ctx) {\n            if (!checker(value, ctx)) {\n                return false;\n            }\n            for (var prop in value) {\n                if (!propSet.has(prop)) {\n                    return ctx.fail(prop, \"is extraneous\", 2);\n                }\n            }\n            return true;\n        };\n    };\n    return TIface;\n}(TType));\nexports.TIface = TIface;\n/**\n * Defines an optional property on an interface.\n */\nfunction opt(typeSpec) { return new TOptional(parseSpec(typeSpec)); }\nexports.opt = opt;\nvar TOptional = /** @class */ (function (_super) {\n    __extends(TOptional, _super);\n    function TOptional(ttype) {\n        var _this = _super.call(this) || this;\n        _this.ttype = ttype;\n        return _this;\n    }\n    TOptional.prototype.getChecker = function (suite, strict) {\n        var itemChecker = this.ttype.getChecker(suite, strict);\n        return function (value, ctx) {\n            return value === undefined || itemChecker(value, ctx);\n        };\n    };\n    return TOptional;\n}(TType));\nexports.TOptional = TOptional;\n/**\n * Defines a property in an interface.\n */\nvar TProp = /** @class */ (function () {\n    function TProp(name, ttype, isOpt) {\n        this.name = name;\n        this.ttype = ttype;\n        this.isOpt = isOpt;\n    }\n    return TProp;\n}());\nexports.TProp = TProp;\n/**\n * Defines a function. The first argument declares the function's return type, the rest declare\n * its parameters.\n */\nfunction func(resultSpec) {\n    var params = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        params[_i - 1] = arguments[_i];\n    }\n    return new TFunc(new TParamList(params), parseSpec(resultSpec));\n}\nexports.func = func;\nvar TFunc = /** @class */ (function (_super) {\n    __extends(TFunc, _super);\n    function TFunc(paramList, result) {\n        var _this = _super.call(this) || this;\n        _this.paramList = paramList;\n        _this.result = result;\n        return _this;\n    }\n    TFunc.prototype.getChecker = function (suite, strict) {\n        return function (value, ctx) {\n            return typeof value === \"function\" ? true : ctx.fail(null, \"is not a function\", 0);\n        };\n    };\n    return TFunc;\n}(TType));\nexports.TFunc = TFunc;\n/**\n * Defines a function parameter.\n */\nfunction param(name, typeSpec, isOpt) {\n    return new TParam(name, parseSpec(typeSpec), Boolean(isOpt));\n}\nexports.param = param;\nvar TParam = /** @class */ (function () {\n    function TParam(name, ttype, isOpt) {\n        this.name = name;\n        this.ttype = ttype;\n        this.isOpt = isOpt;\n    }\n    return TParam;\n}());\nexports.TParam = TParam;\n/**\n * Defines a function parameter list.\n */\nvar TParamList = /** @class */ (function (_super) {\n    __extends(TParamList, _super);\n    function TParamList(params) {\n        var _this = _super.call(this) || this;\n        _this.params = params;\n        return _this;\n    }\n    TParamList.prototype.getChecker = function (suite, strict) {\n        var _this = this;\n        var itemCheckers = this.params.map(function (t) { return t.ttype.getChecker(suite, strict); });\n        var testCtx = new util_1.NoopContext();\n        var isParamRequired = this.params.map(function (param, i) {\n            return !param.isOpt && !itemCheckers[i](undefined, testCtx);\n        });\n        var checker = function (value, ctx) {\n            if (!Array.isArray(value)) {\n                return ctx.fail(null, \"is not an array\", 0);\n            }\n            for (var i = 0; i < itemCheckers.length; i++) {\n                var p = _this.params[i];\n                if (value[i] === undefined) {\n                    if (isParamRequired[i]) {\n                        return ctx.fail(p.name, \"is missing\", 1);\n                    }\n                }\n                else {\n                    var ok = itemCheckers[i](value[i], ctx);\n                    if (!ok) {\n                        return ctx.fail(p.name, null, 1);\n                    }\n                }\n            }\n            return true;\n        };\n        if (!strict) {\n            return checker;\n        }\n        return function (value, ctx) {\n            if (!checker(value, ctx)) {\n                return false;\n            }\n            return value.length <= itemCheckers.length ? true :\n                ctx.fail(itemCheckers.length, \"is extraneous\", 2);\n        };\n    };\n    return TParamList;\n}(TType));\nexports.TParamList = TParamList;\n/**\n * Single TType implementation for all basic built-in types.\n */\nvar BasicType = /** @class */ (function (_super) {\n    __extends(BasicType, _super);\n    function BasicType(validator, message) {\n        var _this = _super.call(this) || this;\n        _this.validator = validator;\n        _this.message = message;\n        return _this;\n    }\n    BasicType.prototype.getChecker = function (suite, strict) {\n        var _this = this;\n        return function (value, ctx) { return _this.validator(value) ? true : ctx.fail(null, _this.message, 0); };\n    };\n    return BasicType;\n}(TType));\nexports.BasicType = BasicType;\n/**\n * Defines the suite of basic types.\n */\nexports.basicTypes = {\n    any: new BasicType(function (v) { return true; }, \"is invalid\"),\n    number: new BasicType(function (v) { return (typeof v === \"number\"); }, \"is not a number\"),\n    object: new BasicType(function (v) { return (typeof v === \"object\" && v); }, \"is not an object\"),\n    boolean: new BasicType(function (v) { return (typeof v === \"boolean\"); }, \"is not a boolean\"),\n    string: new BasicType(function (v) { return (typeof v === \"string\"); }, \"is not a string\"),\n    symbol: new BasicType(function (v) { return (typeof v === \"symbol\"); }, \"is not a symbol\"),\n    void: new BasicType(function (v) { return (v == null); }, \"is not void\"),\n    undefined: new BasicType(function (v) { return (v === undefined); }, \"is not undefined\"),\n    null: new BasicType(function (v) { return (v === null); }, \"is not null\"),\n    never: new BasicType(function (v) { return false; }, \"is unexpected\"),\n    Date: new BasicType(getIsNativeChecker(\"[object Date]\"), \"is not a Date\"),\n    RegExp: new BasicType(getIsNativeChecker(\"[object RegExp]\"), \"is not a RegExp\"),\n};\n// This approach for checking native object types mirrors that of lodash. Its advantage over\n// `isinstance` is that it can still return true for native objects created in different JS\n// execution environments.\nvar nativeToString = Object.prototype.toString;\nfunction getIsNativeChecker(tag) {\n    return function (v) { return typeof v === \"object\" && v && nativeToString.call(v) === tag; };\n}\nif (typeof Buffer !== \"undefined\") {\n    exports.basicTypes.Buffer = new BasicType(function (v) { return Buffer.isBuffer(v); }, \"is not a Buffer\");\n}\nvar _loop_1 = function (array_1) {\n    exports.basicTypes[array_1.name] = new BasicType(function (v) { return (v instanceof array_1); }, \"is not a \" + array_1.name);\n};\n// Support typed arrays of various flavors\nfor (var _i = 0, _a = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array,\n    Int32Array, Uint32Array, Float32Array, Float64Array, ArrayBuffer]; _i < _a.length; _i++) {\n    var array_1 = _a[_i];\n    _loop_1(array_1);\n}\n","const compare = require('./compare')\nconst neq = (a, b, loose) => compare(a, b, loose) !== 0\nmodule.exports = neq\n","const eq = require('./eq')\nconst neq = require('./neq')\nconst gt = require('./gt')\nconst gte = require('./gte')\nconst lt = require('./lt')\nconst lte = require('./lte')\n\nconst cmp = (a, op, b, loose) => {\n  switch (op) {\n    case '===':\n      if (typeof a === 'object')\n        a = a.version\n      if (typeof b === 'object')\n        b = b.version\n      return a === b\n\n    case '!==':\n      if (typeof a === 'object')\n        a = a.version\n      if (typeof b === 'object')\n        b = b.version\n      return a !== b\n\n    case '':\n    case '=':\n    case '==':\n      return eq(a, b, loose)\n\n    case '!=':\n      return neq(a, b, loose)\n\n    case '>':\n      return gt(a, b, loose)\n\n    case '>=':\n      return gte(a, b, loose)\n\n    case '<':\n      return lt(a, b, loose)\n\n    case '<=':\n      return lte(a, b, loose)\n\n    default:\n      throw new TypeError(`Invalid operator: ${op}`)\n  }\n}\nmodule.exports = cmp\n","var arrayLikeToArray = require(\"./arrayLikeToArray\");\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(n);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}\n\nmodule.exports = _unsupportedIterableToArray;","var unsupportedIterableToArray = require(\"./unsupportedIterableToArray\");\n\nfunction _createForOfIteratorHelper(o) {\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (o = unsupportedIterableToArray(o))) {\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var it,\n      normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nmodule.exports = _createForOfIteratorHelper;","export type SourceMapSegment =\n\t| [number]\n\t| [number, number, number, number]\n\t| [number, number, number, number, number];\nexport type SourceMapLine = SourceMapSegment[];\nexport type SourceMapMappings = SourceMapLine[];\n\nconst charToInteger: { [charCode: number]: number } = {};\nconst chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n\nfor (let i = 0; i < chars.length; i++) {\n\tcharToInteger[chars.charCodeAt(i)] = i;\n}\n\nexport function decode(mappings: string): SourceMapMappings {\n\tconst decoded: SourceMapMappings = [];\n\tlet line: SourceMapLine = [];\n\tconst segment: SourceMapSegment = [\n\t\t0, // generated code column\n\t\t0, // source file index\n\t\t0, // source code line\n\t\t0, // source code column\n\t\t0, // name index\n\t];\n\n\tlet j = 0;\n\tfor (let i = 0, shift = 0, value = 0; i < mappings.length; i++) {\n\t\tconst c = mappings.charCodeAt(i);\n\n\t\tif (c === 44) { // \",\"\n\t\t\tsegmentify(line, segment, j);\n\t\t\tj = 0;\n\n\t\t} else if (c === 59) { // \";\"\n\t\t\tsegmentify(line, segment, j);\n\t\t\tj = 0;\n\t\t\tdecoded.push(line);\n\t\t\tline = [];\n\t\t\tsegment[0] = 0;\n\n\t\t} else {\n\t\t\tlet integer = charToInteger[c];\n\t\t\tif (integer === undefined) {\n\t\t\t\tthrow new Error('Invalid character (' + String.fromCharCode(c) + ')');\n\t\t\t}\n\n\t\t\tconst hasContinuationBit = integer & 32;\n\n\t\t\tinteger &= 31;\n\t\t\tvalue += integer << shift;\n\n\t\t\tif (hasContinuationBit) {\n\t\t\t\tshift += 5;\n\t\t\t} else {\n\t\t\t\tconst shouldNegate = value & 1;\n\t\t\t\tvalue >>>= 1;\n\n\t\t\t\tif (shouldNegate) {\n\t\t\t\t\tvalue = value === 0 ? -0x80000000 : -value;\n\t\t\t\t}\n\n\t\t\t\tsegment[j] += value;\n\t\t\t\tj++;\n\t\t\t\tvalue = shift = 0; // reset\n\t\t\t}\n\t\t}\n\t}\n\n\tsegmentify(line, segment, j);\n\tdecoded.push(line);\n\n\treturn decoded;\n}\n\nfunction segmentify(line: SourceMapSegment[], segment: SourceMapSegment, j: number) {\n\t// This looks ugly, but we're creating specialized arrays with a specific\n\t// length. This is much faster than creating a new array (which v8 expands to\n\t// a capacity of 17 after pushing the first item), or slicing out a subarray\n\t// (which is slow). Length 4 is assumed to be the most frequent, followed by\n\t// length 5 (since not everything will have an associated name), followed by\n\t// length 1 (it's probably rare for a source substring to not have an\n\t// associated segment data).\n\tif (j === 4) line.push([segment[0], segment[1], segment[2], segment[3]]);\n\telse if (j === 5) line.push([segment[0], segment[1], segment[2], segment[3], segment[4]]);\n\telse if (j === 1) line.push([segment[0]]);\n}\n\nexport function encode(decoded: SourceMapMappings): string {\n\tlet sourceFileIndex = 0;  // second field\n\tlet sourceCodeLine = 0;   // third field\n\tlet sourceCodeColumn = 0; // fourth field\n\tlet nameIndex = 0;        // fifth field\n\tlet mappings = '';\n\n\tfor (let i = 0; i < decoded.length; i++) {\n\t\tconst line = decoded[i];\n\t\tif (i > 0) mappings += ';';\n\t\tif (line.length === 0) continue;\n\n\t\tlet generatedCodeColumn = 0; // first field\n\n\t\tconst lineMappings: string[] = [];\n\n\t\tfor (const segment of line) {\n\t\t\tlet segmentMappings = encodeInteger(segment[0] - generatedCodeColumn);\n\t\t\tgeneratedCodeColumn = segment[0];\n\n\t\t\tif (segment.length > 1) {\n\t\t\t\tsegmentMappings +=\n\t\t\t\t\tencodeInteger(segment[1] - sourceFileIndex) +\n\t\t\t\t\tencodeInteger(segment[2] - sourceCodeLine) +\n\t\t\t\t\tencodeInteger(segment[3] - sourceCodeColumn);\n\n\t\t\t\tsourceFileIndex = segment[1];\n\t\t\t\tsourceCodeLine = segment[2];\n\t\t\t\tsourceCodeColumn = segment[3];\n\t\t\t}\n\n\t\t\tif (segment.length === 5) {\n\t\t\t\tsegmentMappings += encodeInteger(segment[4] - nameIndex);\n\t\t\t\tnameIndex = segment[4];\n\t\t\t}\n\n\t\t\tlineMappings.push(segmentMappings);\n\t\t}\n\n\t\tmappings += lineMappings.join(',');\n\t}\n\n\treturn mappings;\n}\n\nfunction encodeInteger(num: number): string {\n\tvar result = '';\n\tnum = num < 0 ? (-num << 1) | 1 : num << 1;\n\tdo {\n\t\tvar clamped = num & 31;\n\t\tnum >>>= 5;\n\t\tif (num > 0) {\n\t\t\tclamped |= 32;\n\t\t}\n\t\tresult += chars[clamped];\n\t} while (num > 0);\n\n\treturn result;\n}\n","\"use strict\";\nvar LF = '\\n';\nvar CR = '\\r';\nvar LinesAndColumns = (function () {\n    function LinesAndColumns(string) {\n        this.string = string;\n        var offsets = [0];\n        for (var offset = 0; offset < string.length;) {\n            switch (string[offset]) {\n                case LF:\n                    offset += LF.length;\n                    offsets.push(offset);\n                    break;\n                case CR:\n                    offset += CR.length;\n                    if (string[offset] === LF) {\n                        offset += LF.length;\n                    }\n                    offsets.push(offset);\n                    break;\n                default:\n                    offset++;\n                    break;\n            }\n        }\n        this.offsets = offsets;\n    }\n    LinesAndColumns.prototype.locationForIndex = function (index) {\n        if (index < 0 || index > this.string.length) {\n            return null;\n        }\n        var line = 0;\n        var offsets = this.offsets;\n        while (offsets[line + 1] <= index) {\n            line++;\n        }\n        var column = index - offsets[line];\n        return { line: line, column: column };\n    };\n    LinesAndColumns.prototype.indexForLocation = function (location) {\n        var line = location.line, column = location.column;\n        if (line < 0 || line >= this.offsets.length) {\n            return null;\n        }\n        if (column < 0 || column > this.lengthOfLine(line)) {\n            return null;\n        }\n        return this.offsets[line] + column;\n    };\n    LinesAndColumns.prototype.lengthOfLine = function (line) {\n        var offset = this.offsets[line];\n        var nextOffset = line === this.offsets.length - 1 ? this.string.length : this.offsets[line + 1];\n        return nextOffset - offset;\n    };\n    return LinesAndColumns;\n}());\nexports.__esModule = true;\nexports[\"default\"] = LinesAndColumns;\n","/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime = (function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function define(obj, key, value) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n    return obj[key];\n  }\n  try {\n    // IE 8 has a broken Object.defineProperty that only works on DOM objects.\n    define({}, \"\");\n  } catch (err) {\n    define = function(obj, key, value) {\n      return obj[key] = value;\n    };\n  }\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunction.displayName = define(\n    GeneratorFunctionPrototype,\n    toStringTagSymbol,\n    \"GeneratorFunction\"\n  );\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      define(prototype, method, function(arg) {\n        return this._invoke(method, arg);\n      });\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      define(genFun, toStringTagSymbol, \"GeneratorFunction\");\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return PromiseImpl.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return PromiseImpl.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new PromiseImpl(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    if (PromiseImpl === void 0) PromiseImpl = Promise;\n\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList),\n      PromiseImpl\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator[\"return\"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  define(Gp, toStringTagSymbol, \"Generator\");\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n  typeof module === \"object\" ? module.exports : {}\n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n}\n","'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(\n      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)\n    ))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n","exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n","var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n","const parse = require('./parse')\nconst valid = (version, options) => {\n  const v = parse(version, options)\n  return v ? v.version : null\n}\nmodule.exports = valid\n","const parse = require('./parse')\nconst clean = (version, options) => {\n  const s = parse(version.trim().replace(/^[=v]+/, ''), options)\n  return s ? s.version : null\n}\nmodule.exports = clean\n","const SemVer = require('../classes/semver')\n\nconst inc = (version, release, options, identifier) => {\n  if (typeof (options) === 'string') {\n    identifier = options\n    options = undefined\n  }\n\n  try {\n    return new SemVer(version, options).inc(release, identifier).version\n  } catch (er) {\n    return null\n  }\n}\nmodule.exports = inc\n","const parse = require('./parse')\nconst eq = require('./eq')\n\nconst diff = (version1, version2) => {\n  if (eq(version1, version2)) {\n    return null\n  } else {\n    const v1 = parse(version1)\n    const v2 = parse(version2)\n    const hasPre = v1.prerelease.length || v2.prerelease.length\n    const prefix = hasPre ? 'pre' : ''\n    const defaultResult = hasPre ? 'prerelease' : ''\n    for (const key in v1) {\n      if (key === 'major' || key === 'minor' || key === 'patch') {\n        if (v1[key] !== v2[key]) {\n          return prefix + key\n        }\n      }\n    }\n    return defaultResult // may be undefined\n  }\n}\nmodule.exports = diff\n","const SemVer = require('../classes/semver')\nconst major = (a, loose) => new SemVer(a, loose).major\nmodule.exports = major\n","const SemVer = require('../classes/semver')\nconst minor = (a, loose) => new SemVer(a, loose).minor\nmodule.exports = minor\n","const SemVer = require('../classes/semver')\nconst patch = (a, loose) => new SemVer(a, loose).patch\nmodule.exports = patch\n","const parse = require('./parse')\nconst prerelease = (version, options) => {\n  const parsed = parse(version, options)\n  return (parsed && parsed.prerelease.length) ? parsed.prerelease : null\n}\nmodule.exports = prerelease\n","const compare = require('./compare')\nconst rcompare = (a, b, loose) => compare(b, a, loose)\nmodule.exports = rcompare\n","const compare = require('./compare')\nconst compareLoose = (a, b) => compare(a, b, true)\nmodule.exports = compareLoose\n","const compareBuild = require('./compare-build')\nconst sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose))\nmodule.exports = sort\n","const compareBuild = require('./compare-build')\nconst rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose))\nmodule.exports = rsort\n","const SemVer = require('../classes/semver')\nconst parse = require('./parse')\nconst {re, t} = require('../internal/re')\n\nconst coerce = (version, options) => {\n  if (version instanceof SemVer) {\n    return version\n  }\n\n  if (typeof version === 'number') {\n    version = String(version)\n  }\n\n  if (typeof version !== 'string') {\n    return null\n  }\n\n  options = options || {}\n\n  let match = null\n  if (!options.rtl) {\n    match = version.match(re[t.COERCE])\n  } else {\n    // Find the right-most coercible string that does not share\n    // a terminus with a more left-ward coercible string.\n    // Eg, '1.2.3.4' wants to coerce '2.3.4', not '3.4' or '4'\n    //\n    // Walk through the string checking with a /g regexp\n    // Manually set the index so as to pick up overlapping matches.\n    // Stop when we get a match that ends at the string end, since no\n    // coercible string can be more right-ward without the same terminus.\n    let next\n    while ((next = re[t.COERCERTL].exec(version)) &&\n        (!match || match.index + match[0].length !== version.length)\n    ) {\n      if (!match ||\n            next.index + next[0].length !== match.index + match[0].length) {\n        match = next\n      }\n      re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length\n    }\n    // leave it in a clean state\n    re[t.COERCERTL].lastIndex = -1\n  }\n\n  if (match === null)\n    return null\n\n  return parse(`${match[2]}.${match[3] || '0'}.${match[4] || '0'}`, options)\n}\nmodule.exports = coerce\n","const Range = require('../classes/range')\n\n// Mostly just for testing and legacy API reasons\nconst toComparators = (range, options) =>\n  new Range(range, options).set\n    .map(comp => comp.map(c => c.value).join(' ').trim().split(' '))\n\nmodule.exports = toComparators\n","const SemVer = require('../classes/semver')\nconst Range = require('../classes/range')\n\nconst maxSatisfying = (versions, range, options) => {\n  let max = null\n  let maxSV = null\n  let rangeObj = null\n  try {\n    rangeObj = new Range(range, options)\n  } catch (er) {\n    return null\n  }\n  versions.forEach((v) => {\n    if (rangeObj.test(v)) {\n      // satisfies(v, range, options)\n      if (!max || maxSV.compare(v) === -1) {\n        // compare(max, v, true)\n        max = v\n        maxSV = new SemVer(max, options)\n      }\n    }\n  })\n  return max\n}\nmodule.exports = maxSatisfying\n","const SemVer = require('../classes/semver')\nconst Range = require('../classes/range')\nconst minSatisfying = (versions, range, options) => {\n  let min = null\n  let minSV = null\n  let rangeObj = null\n  try {\n    rangeObj = new Range(range, options)\n  } catch (er) {\n    return null\n  }\n  versions.forEach((v) => {\n    if (rangeObj.test(v)) {\n      // satisfies(v, range, options)\n      if (!min || minSV.compare(v) === 1) {\n        // compare(min, v, true)\n        min = v\n        minSV = new SemVer(min, options)\n      }\n    }\n  })\n  return min\n}\nmodule.exports = minSatisfying\n","const SemVer = require('../classes/semver')\nconst Range = require('../classes/range')\nconst gt = require('../functions/gt')\n\nconst minVersion = (range, loose) => {\n  range = new Range(range, loose)\n\n  let minver = new SemVer('0.0.0')\n  if (range.test(minver)) {\n    return minver\n  }\n\n  minver = new SemVer('0.0.0-0')\n  if (range.test(minver)) {\n    return minver\n  }\n\n  minver = null\n  for (let i = 0; i < range.set.length; ++i) {\n    const comparators = range.set[i]\n\n    comparators.forEach((comparator) => {\n      // Clone to avoid manipulating the comparator's semver object.\n      const compver = new SemVer(comparator.semver.version)\n      switch (comparator.operator) {\n        case '>':\n          if (compver.prerelease.length === 0) {\n            compver.patch++\n          } else {\n            compver.prerelease.push(0)\n          }\n          compver.raw = compver.format()\n          /* fallthrough */\n        case '':\n        case '>=':\n          if (!minver || gt(minver, compver)) {\n            minver = compver\n          }\n          break\n        case '<':\n        case '<=':\n          /* Ignore maximum versions */\n          break\n        /* istanbul ignore next */\n        default:\n          throw new Error(`Unexpected operation: ${comparator.operator}`)\n      }\n    })\n  }\n\n  if (minver && range.test(minver)) {\n    return minver\n  }\n\n  return null\n}\nmodule.exports = minVersion\n","const Range = require('../classes/range')\nconst validRange = (range, options) => {\n  try {\n    // Return '*' instead of '' so that truthiness works.\n    // This will throw if it's invalid anyway\n    return new Range(range, options).range || '*'\n  } catch (er) {\n    return null\n  }\n}\nmodule.exports = validRange\n","// Determine if version is greater than all the versions possible in the range.\nconst outside = require('./outside')\nconst gtr = (version, range, options) => outside(version, range, '>', options)\nmodule.exports = gtr\n","const outside = require('./outside')\n// Determine if version is less than all the versions possible in the range\nconst ltr = (version, range, options) => outside(version, range, '<', options)\nmodule.exports = ltr\n","const Range = require('../classes/range')\nconst intersects = (r1, r2, options) => {\n  r1 = new Range(r1, options)\n  r2 = new Range(r2, options)\n  return r1.intersects(r2)\n}\nmodule.exports = intersects\n","// given a set of versions and a range, create a \"simplified\" range\n// that includes the same versions that the original range does\n// If the original range is shorter than the simplified one, return that.\nconst satisfies = require('../functions/satisfies.js')\nconst compare = require('../functions/compare.js')\nmodule.exports = (versions, range, options) => {\n  const set = []\n  let min = null\n  let prev = null\n  const v = versions.sort((a, b) => compare(a, b, options))\n  for (const version of v) {\n    const included = satisfies(version, range, options)\n    if (included) {\n      prev = version\n      if (!min)\n        min = version\n    } else {\n      if (prev) {\n        set.push([min, prev])\n      }\n      prev = null\n      min = null\n    }\n  }\n  if (min)\n    set.push([min, null])\n\n  const ranges = []\n  for (const [min, max] of set) {\n    if (min === max)\n      ranges.push(min)\n    else if (!max && min === v[0])\n      ranges.push('*')\n    else if (!max)\n      ranges.push(`>=${min}`)\n    else if (min === v[0])\n      ranges.push(`<=${max}`)\n    else\n      ranges.push(`${min} - ${max}`)\n  }\n  const simplified = ranges.join(' || ')\n  const original = typeof range.raw === 'string' ? range.raw : String(range)\n  return simplified.length < original.length ? simplified : range\n}\n","var arrayWithHoles = require(\"./arrayWithHoles\");\n\nvar iterableToArrayLimit = require(\"./iterableToArrayLimit\");\n\nvar unsupportedIterableToArray = require(\"./unsupportedIterableToArray\");\n\nvar nonIterableRest = require(\"./nonIterableRest\");\n\nfunction _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();\n}\n\nmodule.exports = _slicedToArray;","function _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nmodule.exports = _arrayWithHoles;","function _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nmodule.exports = _iterableToArrayLimit;","function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nmodule.exports = _arrayLikeToArray;","function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nmodule.exports = _nonIterableRest;","const Range = require('../classes/range.js')\nconst { ANY } = require('../classes/comparator.js')\nconst satisfies = require('../functions/satisfies.js')\nconst compare = require('../functions/compare.js')\n\n// Complex range `r1 || r2 || ...` is a subset of `R1 || R2 || ...` iff:\n// - Every simple range `r1, r2, ...` is a subset of some `R1, R2, ...`\n//\n// Simple range `c1 c2 ...` is a subset of simple range `C1 C2 ...` iff:\n// - If c is only the ANY comparator\n//   - If C is only the ANY comparator, return true\n//   - Else return false\n// - Let EQ be the set of = comparators in c\n// - If EQ is more than one, return true (null set)\n// - Let GT be the highest > or >= comparator in c\n// - Let LT be the lowest < or <= comparator in c\n// - If GT and LT, and GT.semver > LT.semver, return true (null set)\n// - If EQ\n//   - If GT, and EQ does not satisfy GT, return true (null set)\n//   - If LT, and EQ does not satisfy LT, return true (null set)\n//   - If EQ satisfies every C, return true\n//   - Else return false\n// - If GT\n//   - If GT is lower than any > or >= comp in C, return false\n//   - If GT is >=, and GT.semver does not satisfy every C, return false\n// - If LT\n//   - If LT.semver is greater than that of any > comp in C, return false\n//   - If LT is <=, and LT.semver does not satisfy every C, return false\n// - If any C is a = range, and GT or LT are set, return false\n// - Else return true\n\nconst subset = (sub, dom, options) => {\n  sub = new Range(sub, options)\n  dom = new Range(dom, options)\n  let sawNonNull = false\n\n  OUTER: for (const simpleSub of sub.set) {\n    for (const simpleDom of dom.set) {\n      const isSub = simpleSubset(simpleSub, simpleDom, options)\n      sawNonNull = sawNonNull || isSub !== null\n      if (isSub)\n        continue OUTER\n    }\n    // the null set is a subset of everything, but null simple ranges in\n    // a complex range should be ignored.  so if we saw a non-null range,\n    // then we know this isn't a subset, but if EVERY simple range was null,\n    // then it is a subset.\n    if (sawNonNull)\n      return false\n  }\n  return true\n}\n\nconst simpleSubset = (sub, dom, options) => {\n  if (sub.length === 1 && sub[0].semver === ANY)\n    return dom.length === 1 && dom[0].semver === ANY\n\n  const eqSet = new Set()\n  let gt, lt\n  for (const c of sub) {\n    if (c.operator === '>' || c.operator === '>=')\n      gt = higherGT(gt, c, options)\n    else if (c.operator === '<' || c.operator === '<=')\n      lt = lowerLT(lt, c, options)\n    else\n      eqSet.add(c.semver)\n  }\n\n  if (eqSet.size > 1)\n    return null\n\n  let gtltComp\n  if (gt && lt) {\n    gtltComp = compare(gt.semver, lt.semver, options)\n    if (gtltComp > 0)\n      return null\n    else if (gtltComp === 0 && (gt.operator !== '>=' || lt.operator !== '<='))\n      return null\n  }\n\n  // will iterate one or zero times\n  for (const eq of eqSet) {\n    if (gt && !satisfies(eq, String(gt), options))\n      return null\n\n    if (lt && !satisfies(eq, String(lt), options))\n      return null\n\n    for (const c of dom) {\n      if (!satisfies(eq, String(c), options))\n        return false\n    }\n    return true\n  }\n\n  let higher, lower\n  let hasDomLT, hasDomGT\n  for (const c of dom) {\n    hasDomGT = hasDomGT || c.operator === '>' || c.operator === '>='\n    hasDomLT = hasDomLT || c.operator === '<' || c.operator === '<='\n    if (gt) {\n      if (c.operator === '>' || c.operator === '>=') {\n        higher = higherGT(gt, c, options)\n        if (higher === c)\n          return false\n      } else if (gt.operator === '>=' && !satisfies(gt.semver, String(c), options))\n        return false\n    }\n    if (lt) {\n      if (c.operator === '<' || c.operator === '<=') {\n        lower = lowerLT(lt, c, options)\n        if (lower === c)\n          return false\n      } else if (lt.operator === '<=' && !satisfies(lt.semver, String(c), options))\n        return false\n    }\n    if (!c.operator && (lt || gt) && gtltComp !== 0)\n      return false\n  }\n\n  // if there was a < or >, and nothing in the dom, then must be false\n  // UNLESS it was limited by another range in the other direction.\n  // Eg, >1.0.0 <1.0.1 is still a subset of <2.0.0\n  if (gt && hasDomLT && !lt && gtltComp !== 0)\n    return false\n\n  if (lt && hasDomGT && !gt && gtltComp !== 0)\n    return false\n\n  return true\n}\n\n// >=1.2.3 is lower than >1.2.3\nconst higherGT = (a, b, options) => {\n  if (!a)\n    return b\n  const comp = compare(a.semver, b.semver, options)\n  return comp > 0 ? a\n    : comp < 0 ? b\n    : b.operator === '>' && a.operator === '>=' ? b\n    : a\n}\n\n// <=1.2.3 is higher than <1.2.3\nconst lowerLT = (a, b, options) => {\n  if (!a)\n    return b\n  const comp = compare(a.semver, b.semver, options)\n  return comp < 0 ? a\n    : comp > 0 ? b\n    : b.operator === '<' && a.operator === '<=' ? b\n    : a\n}\n\nmodule.exports = subset\n","// Reserved word lists for various dialects of the language\n\nvar reservedWords = {\n  3: \"abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile\",\n  5: \"class enum extends super const export import\",\n  6: \"enum\",\n  strict: \"implements interface let package private protected public static yield\",\n  strictBind: \"eval arguments\"\n};\n\n// And the keywords\n\nvar ecma5AndLessKeywords = \"break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this\";\n\nvar keywords = {\n  5: ecma5AndLessKeywords,\n  \"5module\": ecma5AndLessKeywords + \" export import\",\n  6: ecma5AndLessKeywords + \" const class extends export import super\"\n};\n\nvar keywordRelationalOperator = /^in(stanceof)?$/;\n\n// ## Character categories\n\n// Big ugly regular expressions that match characters in the\n// whitespace, identifier, and identifier-start categories. These\n// are only applied when a character is found to actually have a\n// code point above 128.\n// Generated by `bin/generate-identifier-regex.js`.\nvar nonASCIIidentifierStartChars = \"\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u037f\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u052f\\u0531-\\u0556\\u0559\\u0560-\\u0588\\u05d0-\\u05ea\\u05ef-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u0860-\\u086a\\u08a0-\\u08b4\\u08b6-\\u08c7\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u09fc\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0af9\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c39\\u0c3d\\u0c58-\\u0c5a\\u0c60\\u0c61\\u0c80\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d04-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d54-\\u0d56\\u0d5f-\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e86-\\u0e8a\\u0e8c-\\u0ea3\\u0ea5\\u0ea7-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f5\\u13f8-\\u13fd\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f8\\u1700-\\u170c\\u170e-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1878\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191e\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19b0-\\u19c9\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4b\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1c80-\\u1c88\\u1c90-\\u1cba\\u1cbd-\\u1cbf\\u1ce9-\\u1cec\\u1cee-\\u1cf3\\u1cf5\\u1cf6\\u1cfa\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2118-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309b-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312f\\u3131-\\u318e\\u31a0-\\u31bf\\u31f0-\\u31ff\\u3400-\\u4dbf\\u4e00-\\u9ffc\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua69d\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua7bf\\ua7c2-\\ua7ca\\ua7f5-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua8fd\\ua8fe\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\ua9e0-\\ua9e4\\ua9e6-\\ua9ef\\ua9fa-\\ua9fe\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa7e-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uab30-\\uab5a\\uab5c-\\uab69\\uab70-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc\";\nvar nonASCIIidentifierChars = \"\\u200c\\u200d\\xb7\\u0300-\\u036f\\u0387\\u0483-\\u0487\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u0669\\u0670\\u06d6-\\u06dc\\u06df-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u06f0-\\u06f9\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07c0-\\u07c9\\u07eb-\\u07f3\\u07fd\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0859-\\u085b\\u08d3-\\u08e1\\u08e3-\\u0903\\u093a-\\u093c\\u093e-\\u094f\\u0951-\\u0957\\u0962\\u0963\\u0966-\\u096f\\u0981-\\u0983\\u09bc\\u09be-\\u09c4\\u09c7\\u09c8\\u09cb-\\u09cd\\u09d7\\u09e2\\u09e3\\u09e6-\\u09ef\\u09fe\\u0a01-\\u0a03\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a66-\\u0a71\\u0a75\\u0a81-\\u0a83\\u0abc\\u0abe-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ae2\\u0ae3\\u0ae6-\\u0aef\\u0afa-\\u0aff\\u0b01-\\u0b03\\u0b3c\\u0b3e-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b55-\\u0b57\\u0b62\\u0b63\\u0b66-\\u0b6f\\u0b82\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd7\\u0be6-\\u0bef\\u0c00-\\u0c04\\u0c3e-\\u0c44\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0c66-\\u0c6f\\u0c81-\\u0c83\\u0cbc\\u0cbe-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0ce6-\\u0cef\\u0d00-\\u0d03\\u0d3b\\u0d3c\\u0d3e-\\u0d44\\u0d46-\\u0d48\\u0d4a-\\u0d4d\\u0d57\\u0d62\\u0d63\\u0d66-\\u0d6f\\u0d81-\\u0d83\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0de6-\\u0def\\u0df2\\u0df3\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0e50-\\u0e59\\u0eb1\\u0eb4-\\u0ebc\\u0ec8-\\u0ecd\\u0ed0-\\u0ed9\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f3e\\u0f3f\\u0f71-\\u0f84\\u0f86\\u0f87\\u0f8d-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102b-\\u103e\\u1040-\\u1049\\u1056-\\u1059\\u105e-\\u1060\\u1062-\\u1064\\u1067-\\u106d\\u1071-\\u1074\\u1082-\\u108d\\u108f-\\u109d\\u135d-\\u135f\\u1369-\\u1371\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b4-\\u17d3\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u1810-\\u1819\\u18a9\\u1920-\\u192b\\u1930-\\u193b\\u1946-\\u194f\\u19d0-\\u19da\\u1a17-\\u1a1b\\u1a55-\\u1a5e\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1ab0-\\u1abd\\u1abf\\u1ac0\\u1b00-\\u1b04\\u1b34-\\u1b44\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1b80-\\u1b82\\u1ba1-\\u1bad\\u1bb0-\\u1bb9\\u1be6-\\u1bf3\\u1c24-\\u1c37\\u1c40-\\u1c49\\u1c50-\\u1c59\\u1cd0-\\u1cd2\\u1cd4-\\u1ce8\\u1ced\\u1cf4\\u1cf7-\\u1cf9\\u1dc0-\\u1df9\\u1dfb-\\u1dff\\u203f\\u2040\\u2054\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2cef-\\u2cf1\\u2d7f\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua620-\\ua629\\ua66f\\ua674-\\ua67d\\ua69e\\ua69f\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua823-\\ua827\\ua82c\\ua880\\ua881\\ua8b4-\\ua8c5\\ua8d0-\\ua8d9\\ua8e0-\\ua8f1\\ua8ff-\\ua909\\ua926-\\ua92d\\ua947-\\ua953\\ua980-\\ua983\\ua9b3-\\ua9c0\\ua9d0-\\ua9d9\\ua9e5\\ua9f0-\\ua9f9\\uaa29-\\uaa36\\uaa43\\uaa4c\\uaa4d\\uaa50-\\uaa59\\uaa7b-\\uaa7d\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uaaeb-\\uaaef\\uaaf5\\uaaf6\\uabe3-\\uabea\\uabec\\uabed\\uabf0-\\uabf9\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe2f\\ufe33\\ufe34\\ufe4d-\\ufe4f\\uff10-\\uff19\\uff3f\";\n\nvar nonASCIIidentifierStart = new RegExp(\"[\" + nonASCIIidentifierStartChars + \"]\");\nvar nonASCIIidentifier = new RegExp(\"[\" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \"]\");\n\nnonASCIIidentifierStartChars = nonASCIIidentifierChars = null;\n\n// These are a run-length and offset encoded representation of the\n// >0xffff code points that are a valid part of identifiers. The\n// offset starts at 0x10000, and each pair of numbers represents an\n// offset to the next range, and then a size of the range. They were\n// generated by bin/generate-identifier-regex.js\n\n// eslint-disable-next-line comma-spacing\nvar astralIdentifierStartCodes = [0,11,2,25,2,18,2,1,2,14,3,13,35,122,70,52,268,28,4,48,48,31,14,29,6,37,11,29,3,35,5,7,2,4,43,157,19,35,5,35,5,39,9,51,157,310,10,21,11,7,153,5,3,0,2,43,2,1,4,0,3,22,11,22,10,30,66,18,2,1,11,21,11,25,71,55,7,1,65,0,16,3,2,2,2,28,43,28,4,28,36,7,2,27,28,53,11,21,11,18,14,17,111,72,56,50,14,50,14,35,349,41,7,1,79,28,11,0,9,21,107,20,28,22,13,52,76,44,33,24,27,35,30,0,3,0,9,34,4,0,13,47,15,3,22,0,2,0,36,17,2,24,85,6,2,0,2,3,2,14,2,9,8,46,39,7,3,1,3,21,2,6,2,1,2,4,4,0,19,0,13,4,159,52,19,3,21,2,31,47,21,1,2,0,185,46,42,3,37,47,21,0,60,42,14,0,72,26,230,43,117,63,32,7,3,0,3,7,2,1,2,23,16,0,2,0,95,7,3,38,17,0,2,0,29,0,11,39,8,0,22,0,12,45,20,0,35,56,264,8,2,36,18,0,50,29,113,6,2,1,2,37,22,0,26,5,2,1,2,31,15,0,328,18,190,0,80,921,103,110,18,195,2749,1070,4050,582,8634,568,8,30,114,29,19,47,17,3,32,20,6,18,689,63,129,74,6,0,67,12,65,1,2,0,29,6135,9,1237,43,8,8952,286,50,2,18,3,9,395,2309,106,6,12,4,8,8,9,5991,84,2,70,2,1,3,0,3,1,3,3,2,11,2,0,2,6,2,64,2,3,3,7,2,6,2,27,2,3,2,4,2,0,4,6,2,339,3,24,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,7,2357,44,11,6,17,0,370,43,1301,196,60,67,8,0,1205,3,2,26,2,1,2,0,3,0,2,9,2,3,2,0,2,0,7,0,5,0,2,0,2,0,2,2,2,1,2,0,3,0,2,0,2,0,2,0,2,0,2,1,2,0,3,3,2,6,2,3,2,3,2,0,2,9,2,16,6,2,2,4,2,16,4421,42717,35,4148,12,221,3,5761,15,7472,3104,541,1507,4938];\n\n// eslint-disable-next-line comma-spacing\nvar astralIdentifierCodes = [509,0,227,0,150,4,294,9,1368,2,2,1,6,3,41,2,5,0,166,1,574,3,9,9,370,1,154,10,176,2,54,14,32,9,16,3,46,10,54,9,7,2,37,13,2,9,6,1,45,0,13,2,49,13,9,3,2,11,83,11,7,0,161,11,6,9,7,3,56,1,2,6,3,1,3,2,10,0,11,1,3,6,4,4,193,17,10,9,5,0,82,19,13,9,214,6,3,8,28,1,83,16,16,9,82,12,9,9,84,14,5,9,243,14,166,9,71,5,2,1,3,3,2,0,2,1,13,9,120,6,3,6,4,0,29,9,41,6,2,3,9,0,10,10,47,15,406,7,2,7,17,9,57,21,2,13,123,5,4,0,2,1,2,6,2,0,9,9,49,4,2,1,2,4,9,9,330,3,19306,9,135,4,60,6,26,9,1014,0,2,54,8,3,82,0,12,1,19628,1,5319,4,4,5,9,7,3,6,31,3,149,2,1418,49,513,54,5,49,9,0,15,0,23,4,2,14,1361,6,2,16,3,6,2,1,2,4,262,6,10,9,419,13,1495,6,110,6,6,9,4759,9,787719,239];\n\n// This has a complexity linear to the value of the code. The\n// assumption is that looking up astral identifier characters is\n// rare.\nfunction isInAstralSet(code, set) {\n  var pos = 0x10000;\n  for (var i = 0; i < set.length; i += 2) {\n    pos += set[i];\n    if (pos > code) { return false }\n    pos += set[i + 1];\n    if (pos >= code) { return true }\n  }\n}\n\n// Test whether a given character code starts an identifier.\n\nfunction isIdentifierStart(code, astral) {\n  if (code < 65) { return code === 36 }\n  if (code < 91) { return true }\n  if (code < 97) { return code === 95 }\n  if (code < 123) { return true }\n  if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code)) }\n  if (astral === false) { return false }\n  return isInAstralSet(code, astralIdentifierStartCodes)\n}\n\n// Test whether a given character is part of an identifier.\n\nfunction isIdentifierChar(code, astral) {\n  if (code < 48) { return code === 36 }\n  if (code < 58) { return true }\n  if (code < 65) { return false }\n  if (code < 91) { return true }\n  if (code < 97) { return code === 95 }\n  if (code < 123) { return true }\n  if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code)) }\n  if (astral === false) { return false }\n  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes)\n}\n\n// ## Token types\n\n// The assignment of fine-grained, information-carrying type objects\n// allows the tokenizer to store the information it has about a\n// token in a way that is very cheap for the parser to look up.\n\n// All token type variables start with an underscore, to make them\n// easy to recognize.\n\n// The `beforeExpr` property is used to disambiguate between regular\n// expressions and divisions. It is set on all token types that can\n// be followed by an expression (thus, a slash after them would be a\n// regular expression).\n//\n// The `startsExpr` property is used to check if the token ends a\n// `yield` expression. It is set on all token types that either can\n// directly start an expression (like a quotation mark) or can\n// continue an expression (like the body of a string).\n//\n// `isLoop` marks a keyword as starting a loop, which is important\n// to know when parsing a label, in order to allow or disallow\n// continue jumps to that label.\n\nvar TokenType = function TokenType(label, conf) {\n  if ( conf === void 0 ) conf = {};\n\n  this.label = label;\n  this.keyword = conf.keyword;\n  this.beforeExpr = !!conf.beforeExpr;\n  this.startsExpr = !!conf.startsExpr;\n  this.isLoop = !!conf.isLoop;\n  this.isAssign = !!conf.isAssign;\n  this.prefix = !!conf.prefix;\n  this.postfix = !!conf.postfix;\n  this.binop = conf.binop || null;\n  this.updateContext = null;\n};\n\nfunction binop(name, prec) {\n  return new TokenType(name, {beforeExpr: true, binop: prec})\n}\nvar beforeExpr = {beforeExpr: true}, startsExpr = {startsExpr: true};\n\n// Map keyword names to token types.\n\nvar keywords$1 = {};\n\n// Succinct definitions of keyword token types\nfunction kw(name, options) {\n  if ( options === void 0 ) options = {};\n\n  options.keyword = name;\n  return keywords$1[name] = new TokenType(name, options)\n}\n\nvar types = {\n  num: new TokenType(\"num\", startsExpr),\n  regexp: new TokenType(\"regexp\", startsExpr),\n  string: new TokenType(\"string\", startsExpr),\n  name: new TokenType(\"name\", startsExpr),\n  eof: new TokenType(\"eof\"),\n\n  // Punctuation token types.\n  bracketL: new TokenType(\"[\", {beforeExpr: true, startsExpr: true}),\n  bracketR: new TokenType(\"]\"),\n  braceL: new TokenType(\"{\", {beforeExpr: true, startsExpr: true}),\n  braceR: new TokenType(\"}\"),\n  parenL: new TokenType(\"(\", {beforeExpr: true, startsExpr: true}),\n  parenR: new TokenType(\")\"),\n  comma: new TokenType(\",\", beforeExpr),\n  semi: new TokenType(\";\", beforeExpr),\n  colon: new TokenType(\":\", beforeExpr),\n  dot: new TokenType(\".\"),\n  question: new TokenType(\"?\", beforeExpr),\n  questionDot: new TokenType(\"?.\"),\n  arrow: new TokenType(\"=>\", beforeExpr),\n  template: new TokenType(\"template\"),\n  invalidTemplate: new TokenType(\"invalidTemplate\"),\n  ellipsis: new TokenType(\"...\", beforeExpr),\n  backQuote: new TokenType(\"`\", startsExpr),\n  dollarBraceL: new TokenType(\"${\", {beforeExpr: true, startsExpr: true}),\n\n  // Operators. These carry several kinds of properties to help the\n  // parser use them properly (the presence of these properties is\n  // what categorizes them as operators).\n  //\n  // `binop`, when present, specifies that this operator is a binary\n  // operator, and will refer to its precedence.\n  //\n  // `prefix` and `postfix` mark the operator as a prefix or postfix\n  // unary operator.\n  //\n  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as\n  // binary operators with a very low precedence, that should result\n  // in AssignmentExpression nodes.\n\n  eq: new TokenType(\"=\", {beforeExpr: true, isAssign: true}),\n  assign: new TokenType(\"_=\", {beforeExpr: true, isAssign: true}),\n  incDec: new TokenType(\"++/--\", {prefix: true, postfix: true, startsExpr: true}),\n  prefix: new TokenType(\"!/~\", {beforeExpr: true, prefix: true, startsExpr: true}),\n  logicalOR: binop(\"||\", 1),\n  logicalAND: binop(\"&&\", 2),\n  bitwiseOR: binop(\"|\", 3),\n  bitwiseXOR: binop(\"^\", 4),\n  bitwiseAND: binop(\"&\", 5),\n  equality: binop(\"==/!=/===/!==\", 6),\n  relational: binop(\"</>/<=/>=\", 7),\n  bitShift: binop(\"<</>>/>>>\", 8),\n  plusMin: new TokenType(\"+/-\", {beforeExpr: true, binop: 9, prefix: true, startsExpr: true}),\n  modulo: binop(\"%\", 10),\n  star: binop(\"*\", 10),\n  slash: binop(\"/\", 10),\n  starstar: new TokenType(\"**\", {beforeExpr: true}),\n  coalesce: binop(\"??\", 1),\n\n  // Keyword token types.\n  _break: kw(\"break\"),\n  _case: kw(\"case\", beforeExpr),\n  _catch: kw(\"catch\"),\n  _continue: kw(\"continue\"),\n  _debugger: kw(\"debugger\"),\n  _default: kw(\"default\", beforeExpr),\n  _do: kw(\"do\", {isLoop: true, beforeExpr: true}),\n  _else: kw(\"else\", beforeExpr),\n  _finally: kw(\"finally\"),\n  _for: kw(\"for\", {isLoop: true}),\n  _function: kw(\"function\", startsExpr),\n  _if: kw(\"if\"),\n  _return: kw(\"return\", beforeExpr),\n  _switch: kw(\"switch\"),\n  _throw: kw(\"throw\", beforeExpr),\n  _try: kw(\"try\"),\n  _var: kw(\"var\"),\n  _const: kw(\"const\"),\n  _while: kw(\"while\", {isLoop: true}),\n  _with: kw(\"with\"),\n  _new: kw(\"new\", {beforeExpr: true, startsExpr: true}),\n  _this: kw(\"this\", startsExpr),\n  _super: kw(\"super\", startsExpr),\n  _class: kw(\"class\", startsExpr),\n  _extends: kw(\"extends\", beforeExpr),\n  _export: kw(\"export\"),\n  _import: kw(\"import\", startsExpr),\n  _null: kw(\"null\", startsExpr),\n  _true: kw(\"true\", startsExpr),\n  _false: kw(\"false\", startsExpr),\n  _in: kw(\"in\", {beforeExpr: true, binop: 7}),\n  _instanceof: kw(\"instanceof\", {beforeExpr: true, binop: 7}),\n  _typeof: kw(\"typeof\", {beforeExpr: true, prefix: true, startsExpr: true}),\n  _void: kw(\"void\", {beforeExpr: true, prefix: true, startsExpr: true}),\n  _delete: kw(\"delete\", {beforeExpr: true, prefix: true, startsExpr: true})\n};\n\n// Matches a whole line break (where CRLF is considered a single\n// line break). Used to count lines.\n\nvar lineBreak = /\\r\\n?|\\n|\\u2028|\\u2029/;\nvar lineBreakG = new RegExp(lineBreak.source, \"g\");\n\nfunction isNewLine(code, ecma2019String) {\n  return code === 10 || code === 13 || (!ecma2019String && (code === 0x2028 || code === 0x2029))\n}\n\nvar nonASCIIwhitespace = /[\\u1680\\u2000-\\u200a\\u202f\\u205f\\u3000\\ufeff]/;\n\nvar skipWhiteSpace = /(?:\\s|\\/\\/.*|\\/\\*[^]*?\\*\\/)*/g;\n\nvar ref = Object.prototype;\nvar hasOwnProperty = ref.hasOwnProperty;\nvar toString = ref.toString;\n\n// Checks if an object has a property.\n\nfunction has(obj, propName) {\n  return hasOwnProperty.call(obj, propName)\n}\n\nvar isArray = Array.isArray || (function (obj) { return (\n  toString.call(obj) === \"[object Array]\"\n); });\n\nfunction wordsRegexp(words) {\n  return new RegExp(\"^(?:\" + words.replace(/ /g, \"|\") + \")$\")\n}\n\n// These are used when `options.locations` is on, for the\n// `startLoc` and `endLoc` properties.\n\nvar Position = function Position(line, col) {\n  this.line = line;\n  this.column = col;\n};\n\nPosition.prototype.offset = function offset (n) {\n  return new Position(this.line, this.column + n)\n};\n\nvar SourceLocation = function SourceLocation(p, start, end) {\n  this.start = start;\n  this.end = end;\n  if (p.sourceFile !== null) { this.source = p.sourceFile; }\n};\n\n// The `getLineInfo` function is mostly useful when the\n// `locations` option is off (for performance reasons) and you\n// want to find the line/column position for a given character\n// offset. `input` should be the code string that the offset refers\n// into.\n\nfunction getLineInfo(input, offset) {\n  for (var line = 1, cur = 0;;) {\n    lineBreakG.lastIndex = cur;\n    var match = lineBreakG.exec(input);\n    if (match && match.index < offset) {\n      ++line;\n      cur = match.index + match[0].length;\n    } else {\n      return new Position(line, offset - cur)\n    }\n  }\n}\n\n// A second optional argument can be given to further configure\n// the parser process. These options are recognized:\n\nvar defaultOptions = {\n  // `ecmaVersion` indicates the ECMAScript version to parse. Must be\n  // either 3, 5, 6 (2015), 7 (2016), 8 (2017), 9 (2018), or 10\n  // (2019). This influences support for strict mode, the set of\n  // reserved words, and support for new syntax features. The default\n  // is 10.\n  ecmaVersion: 10,\n  // `sourceType` indicates the mode the code should be parsed in.\n  // Can be either `\"script\"` or `\"module\"`. This influences global\n  // strict mode and parsing of `import` and `export` declarations.\n  sourceType: \"script\",\n  // `onInsertedSemicolon` can be a callback that will be called\n  // when a semicolon is automatically inserted. It will be passed\n  // the position of the comma as an offset, and if `locations` is\n  // enabled, it is given the location as a `{line, column}` object\n  // as second argument.\n  onInsertedSemicolon: null,\n  // `onTrailingComma` is similar to `onInsertedSemicolon`, but for\n  // trailing commas.\n  onTrailingComma: null,\n  // By default, reserved words are only enforced if ecmaVersion >= 5.\n  // Set `allowReserved` to a boolean value to explicitly turn this on\n  // an off. When this option has the value \"never\", reserved words\n  // and keywords can also not be used as property names.\n  allowReserved: null,\n  // When enabled, a return at the top level is not considered an\n  // error.\n  allowReturnOutsideFunction: false,\n  // When enabled, import/export statements are not constrained to\n  // appearing at the top of the program.\n  allowImportExportEverywhere: false,\n  // When enabled, await identifiers are allowed to appear at the top-level scope,\n  // but they are still not allowed in non-async functions.\n  allowAwaitOutsideFunction: false,\n  // When enabled, hashbang directive in the beginning of file\n  // is allowed and treated as a line comment.\n  allowHashBang: false,\n  // When `locations` is on, `loc` properties holding objects with\n  // `start` and `end` properties in `{line, column}` form (with\n  // line being 1-based and column 0-based) will be attached to the\n  // nodes.\n  locations: false,\n  // A function can be passed as `onToken` option, which will\n  // cause Acorn to call that function with object in the same\n  // format as tokens returned from `tokenizer().getToken()`. Note\n  // that you are not allowed to call the parser from the\n  // callback—that will corrupt its internal state.\n  onToken: null,\n  // A function can be passed as `onComment` option, which will\n  // cause Acorn to call that function with `(block, text, start,\n  // end)` parameters whenever a comment is skipped. `block` is a\n  // boolean indicating whether this is a block (`/* */`) comment,\n  // `text` is the content of the comment, and `start` and `end` are\n  // character offsets that denote the start and end of the comment.\n  // When the `locations` option is on, two more parameters are\n  // passed, the full `{line, column}` locations of the start and\n  // end of the comments. Note that you are not allowed to call the\n  // parser from the callback—that will corrupt its internal state.\n  onComment: null,\n  // Nodes have their start and end characters offsets recorded in\n  // `start` and `end` properties (directly on the node, rather than\n  // the `loc` object, which holds line/column data. To also add a\n  // [semi-standardized][range] `range` property holding a `[start,\n  // end]` array with the same numbers, set the `ranges` option to\n  // `true`.\n  //\n  // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678\n  ranges: false,\n  // It is possible to parse multiple files into a single AST by\n  // passing the tree produced by parsing the first file as\n  // `program` option in subsequent parses. This will add the\n  // toplevel forms of the parsed file to the `Program` (top) node\n  // of an existing parse tree.\n  program: null,\n  // When `locations` is on, you can pass this to record the source\n  // file in every node's `loc` object.\n  sourceFile: null,\n  // This value, if given, is stored in every node, whether\n  // `locations` is on or off.\n  directSourceFile: null,\n  // When enabled, parenthesized expressions are represented by\n  // (non-standard) ParenthesizedExpression nodes\n  preserveParens: false\n};\n\n// Interpret and default an options object\n\nfunction getOptions(opts) {\n  var options = {};\n\n  for (var opt in defaultOptions)\n    { options[opt] = opts && has(opts, opt) ? opts[opt] : defaultOptions[opt]; }\n\n  if (options.ecmaVersion >= 2015)\n    { options.ecmaVersion -= 2009; }\n\n  if (options.allowReserved == null)\n    { options.allowReserved = options.ecmaVersion < 5; }\n\n  if (isArray(options.onToken)) {\n    var tokens = options.onToken;\n    options.onToken = function (token) { return tokens.push(token); };\n  }\n  if (isArray(options.onComment))\n    { options.onComment = pushComment(options, options.onComment); }\n\n  return options\n}\n\nfunction pushComment(options, array) {\n  return function(block, text, start, end, startLoc, endLoc) {\n    var comment = {\n      type: block ? \"Block\" : \"Line\",\n      value: text,\n      start: start,\n      end: end\n    };\n    if (options.locations)\n      { comment.loc = new SourceLocation(this, startLoc, endLoc); }\n    if (options.ranges)\n      { comment.range = [start, end]; }\n    array.push(comment);\n  }\n}\n\n// Each scope gets a bitset that may contain these flags\nvar\n    SCOPE_TOP = 1,\n    SCOPE_FUNCTION = 2,\n    SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION,\n    SCOPE_ASYNC = 4,\n    SCOPE_GENERATOR = 8,\n    SCOPE_ARROW = 16,\n    SCOPE_SIMPLE_CATCH = 32,\n    SCOPE_SUPER = 64,\n    SCOPE_DIRECT_SUPER = 128;\n\nfunction functionFlags(async, generator) {\n  return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0)\n}\n\n// Used in checkLVal and declareName to determine the type of a binding\nvar\n    BIND_NONE = 0, // Not a binding\n    BIND_VAR = 1, // Var-style binding\n    BIND_LEXICAL = 2, // Let- or const-style binding\n    BIND_FUNCTION = 3, // Function declaration\n    BIND_SIMPLE_CATCH = 4, // Simple (identifier pattern) catch binding\n    BIND_OUTSIDE = 5; // Special case for function names as bound inside the function\n\nvar Parser = function Parser(options, input, startPos) {\n  this.options = options = getOptions(options);\n  this.sourceFile = options.sourceFile;\n  this.keywords = wordsRegexp(keywords[options.ecmaVersion >= 6 ? 6 : options.sourceType === \"module\" ? \"5module\" : 5]);\n  var reserved = \"\";\n  if (options.allowReserved !== true) {\n    for (var v = options.ecmaVersion;; v--)\n      { if (reserved = reservedWords[v]) { break } }\n    if (options.sourceType === \"module\") { reserved += \" await\"; }\n  }\n  this.reservedWords = wordsRegexp(reserved);\n  var reservedStrict = (reserved ? reserved + \" \" : \"\") + reservedWords.strict;\n  this.reservedWordsStrict = wordsRegexp(reservedStrict);\n  this.reservedWordsStrictBind = wordsRegexp(reservedStrict + \" \" + reservedWords.strictBind);\n  this.input = String(input);\n\n  // Used to signal to callers of `readWord1` whether the word\n  // contained any escape sequences. This is needed because words with\n  // escape sequences must not be interpreted as keywords.\n  this.containsEsc = false;\n\n  // Set up token state\n\n  // The current position of the tokenizer in the input.\n  if (startPos) {\n    this.pos = startPos;\n    this.lineStart = this.input.lastIndexOf(\"\\n\", startPos - 1) + 1;\n    this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;\n  } else {\n    this.pos = this.lineStart = 0;\n    this.curLine = 1;\n  }\n\n  // Properties of the current token:\n  // Its type\n  this.type = types.eof;\n  // For tokens that include more information than their type, the value\n  this.value = null;\n  // Its start and end offset\n  this.start = this.end = this.pos;\n  // And, if locations are used, the {line, column} object\n  // corresponding to those offsets\n  this.startLoc = this.endLoc = this.curPosition();\n\n  // Position information for the previous token\n  this.lastTokEndLoc = this.lastTokStartLoc = null;\n  this.lastTokStart = this.lastTokEnd = this.pos;\n\n  // The context stack is used to superficially track syntactic\n  // context to predict whether a regular expression is allowed in a\n  // given position.\n  this.context = this.initialContext();\n  this.exprAllowed = true;\n\n  // Figure out if it's a module code.\n  this.inModule = options.sourceType === \"module\";\n  this.strict = this.inModule || this.strictDirective(this.pos);\n\n  // Used to signify the start of a potential arrow function\n  this.potentialArrowAt = -1;\n\n  // Positions to delayed-check that yield/await does not exist in default parameters.\n  this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;\n  // Labels in scope.\n  this.labels = [];\n  // Thus-far undefined exports.\n  this.undefinedExports = {};\n\n  // If enabled, skip leading hashbang line.\n  if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === \"#!\")\n    { this.skipLineComment(2); }\n\n  // Scope tracking for duplicate variable names (see scope.js)\n  this.scopeStack = [];\n  this.enterScope(SCOPE_TOP);\n\n  // For RegExp validation\n  this.regexpState = null;\n};\n\nvar prototypeAccessors = { inFunction: { configurable: true },inGenerator: { configurable: true },inAsync: { configurable: true },allowSuper: { configurable: true },allowDirectSuper: { configurable: true },treatFunctionsAsVar: { configurable: true } };\n\nParser.prototype.parse = function parse () {\n  var node = this.options.program || this.startNode();\n  this.nextToken();\n  return this.parseTopLevel(node)\n};\n\nprototypeAccessors.inFunction.get = function () { return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0 };\nprototypeAccessors.inGenerator.get = function () { return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0 };\nprototypeAccessors.inAsync.get = function () { return (this.currentVarScope().flags & SCOPE_ASYNC) > 0 };\nprototypeAccessors.allowSuper.get = function () { return (this.currentThisScope().flags & SCOPE_SUPER) > 0 };\nprototypeAccessors.allowDirectSuper.get = function () { return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0 };\nprototypeAccessors.treatFunctionsAsVar.get = function () { return this.treatFunctionsAsVarInScope(this.currentScope()) };\n\n// Switch to a getter for 7.0.0.\nParser.prototype.inNonArrowFunction = function inNonArrowFunction () { return (this.currentThisScope().flags & SCOPE_FUNCTION) > 0 };\n\nParser.extend = function extend () {\n    var plugins = [], len = arguments.length;\n    while ( len-- ) plugins[ len ] = arguments[ len ];\n\n  var cls = this;\n  for (var i = 0; i < plugins.length; i++) { cls = plugins[i](cls); }\n  return cls\n};\n\nParser.parse = function parse (input, options) {\n  return new this(options, input).parse()\n};\n\nParser.parseExpressionAt = function parseExpressionAt (input, pos, options) {\n  var parser = new this(options, input, pos);\n  parser.nextToken();\n  return parser.parseExpression()\n};\n\nParser.tokenizer = function tokenizer (input, options) {\n  return new this(options, input)\n};\n\nObject.defineProperties( Parser.prototype, prototypeAccessors );\n\nvar pp = Parser.prototype;\n\n// ## Parser utilities\n\nvar literal = /^(?:'((?:\\\\.|[^'])*?)'|\"((?:\\\\.|[^\"])*?)\")/;\npp.strictDirective = function(start) {\n  for (;;) {\n    // Try to find string literal.\n    skipWhiteSpace.lastIndex = start;\n    start += skipWhiteSpace.exec(this.input)[0].length;\n    var match = literal.exec(this.input.slice(start));\n    if (!match) { return false }\n    if ((match[1] || match[2]) === \"use strict\") {\n      skipWhiteSpace.lastIndex = start + match[0].length;\n      var spaceAfter = skipWhiteSpace.exec(this.input), end = spaceAfter.index + spaceAfter[0].length;\n      var next = this.input.charAt(end);\n      return next === \";\" || next === \"}\" ||\n        (lineBreak.test(spaceAfter[0]) &&\n         !(/[(`.[+\\-/*%<>=,?^&]/.test(next) || next === \"!\" && this.input.charAt(end + 1) === \"=\"))\n    }\n    start += match[0].length;\n\n    // Skip semicolon, if any.\n    skipWhiteSpace.lastIndex = start;\n    start += skipWhiteSpace.exec(this.input)[0].length;\n    if (this.input[start] === \";\")\n      { start++; }\n  }\n};\n\n// Predicate that tests whether the next token is of the given\n// type, and if yes, consumes it as a side effect.\n\npp.eat = function(type) {\n  if (this.type === type) {\n    this.next();\n    return true\n  } else {\n    return false\n  }\n};\n\n// Tests whether parsed token is a contextual keyword.\n\npp.isContextual = function(name) {\n  return this.type === types.name && this.value === name && !this.containsEsc\n};\n\n// Consumes contextual keyword if possible.\n\npp.eatContextual = function(name) {\n  if (!this.isContextual(name)) { return false }\n  this.next();\n  return true\n};\n\n// Asserts that following token is given contextual keyword.\n\npp.expectContextual = function(name) {\n  if (!this.eatContextual(name)) { this.unexpected(); }\n};\n\n// Test whether a semicolon can be inserted at the current position.\n\npp.canInsertSemicolon = function() {\n  return this.type === types.eof ||\n    this.type === types.braceR ||\n    lineBreak.test(this.input.slice(this.lastTokEnd, this.start))\n};\n\npp.insertSemicolon = function() {\n  if (this.canInsertSemicolon()) {\n    if (this.options.onInsertedSemicolon)\n      { this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc); }\n    return true\n  }\n};\n\n// Consume a semicolon, or, failing that, see if we are allowed to\n// pretend that there is a semicolon at this position.\n\npp.semicolon = function() {\n  if (!this.eat(types.semi) && !this.insertSemicolon()) { this.unexpected(); }\n};\n\npp.afterTrailingComma = function(tokType, notNext) {\n  if (this.type === tokType) {\n    if (this.options.onTrailingComma)\n      { this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc); }\n    if (!notNext)\n      { this.next(); }\n    return true\n  }\n};\n\n// Expect a token of a given type. If found, consume it, otherwise,\n// raise an unexpected token error.\n\npp.expect = function(type) {\n  this.eat(type) || this.unexpected();\n};\n\n// Raise an unexpected token error.\n\npp.unexpected = function(pos) {\n  this.raise(pos != null ? pos : this.start, \"Unexpected token\");\n};\n\nfunction DestructuringErrors() {\n  this.shorthandAssign =\n  this.trailingComma =\n  this.parenthesizedAssign =\n  this.parenthesizedBind =\n  this.doubleProto =\n    -1;\n}\n\npp.checkPatternErrors = function(refDestructuringErrors, isAssign) {\n  if (!refDestructuringErrors) { return }\n  if (refDestructuringErrors.trailingComma > -1)\n    { this.raiseRecoverable(refDestructuringErrors.trailingComma, \"Comma is not permitted after the rest element\"); }\n  var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;\n  if (parens > -1) { this.raiseRecoverable(parens, \"Parenthesized pattern\"); }\n};\n\npp.checkExpressionErrors = function(refDestructuringErrors, andThrow) {\n  if (!refDestructuringErrors) { return false }\n  var shorthandAssign = refDestructuringErrors.shorthandAssign;\n  var doubleProto = refDestructuringErrors.doubleProto;\n  if (!andThrow) { return shorthandAssign >= 0 || doubleProto >= 0 }\n  if (shorthandAssign >= 0)\n    { this.raise(shorthandAssign, \"Shorthand property assignments are valid only in destructuring patterns\"); }\n  if (doubleProto >= 0)\n    { this.raiseRecoverable(doubleProto, \"Redefinition of __proto__ property\"); }\n};\n\npp.checkYieldAwaitInDefaultParams = function() {\n  if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos))\n    { this.raise(this.yieldPos, \"Yield expression cannot be a default value\"); }\n  if (this.awaitPos)\n    { this.raise(this.awaitPos, \"Await expression cannot be a default value\"); }\n};\n\npp.isSimpleAssignTarget = function(expr) {\n  if (expr.type === \"ParenthesizedExpression\")\n    { return this.isSimpleAssignTarget(expr.expression) }\n  return expr.type === \"Identifier\" || expr.type === \"MemberExpression\"\n};\n\nvar pp$1 = Parser.prototype;\n\n// ### Statement parsing\n\n// Parse a program. Initializes the parser, reads any number of\n// statements, and wraps them in a Program node.  Optionally takes a\n// `program` argument.  If present, the statements will be appended\n// to its body instead of creating a new node.\n\npp$1.parseTopLevel = function(node) {\n  var exports = {};\n  if (!node.body) { node.body = []; }\n  while (this.type !== types.eof) {\n    var stmt = this.parseStatement(null, true, exports);\n    node.body.push(stmt);\n  }\n  if (this.inModule)\n    { for (var i = 0, list = Object.keys(this.undefinedExports); i < list.length; i += 1)\n      {\n        var name = list[i];\n\n        this.raiseRecoverable(this.undefinedExports[name].start, (\"Export '\" + name + \"' is not defined\"));\n      } }\n  this.adaptDirectivePrologue(node.body);\n  this.next();\n  node.sourceType = this.options.sourceType;\n  return this.finishNode(node, \"Program\")\n};\n\nvar loopLabel = {kind: \"loop\"}, switchLabel = {kind: \"switch\"};\n\npp$1.isLet = function(context) {\n  if (this.options.ecmaVersion < 6 || !this.isContextual(\"let\")) { return false }\n  skipWhiteSpace.lastIndex = this.pos;\n  var skip = skipWhiteSpace.exec(this.input);\n  var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);\n  // For ambiguous cases, determine if a LexicalDeclaration (or only a\n  // Statement) is allowed here. If context is not empty then only a Statement\n  // is allowed. However, `let [` is an explicit negative lookahead for\n  // ExpressionStatement, so special-case it first.\n  if (nextCh === 91) { return true } // '['\n  if (context) { return false }\n\n  if (nextCh === 123) { return true } // '{'\n  if (isIdentifierStart(nextCh, true)) {\n    var pos = next + 1;\n    while (isIdentifierChar(this.input.charCodeAt(pos), true)) { ++pos; }\n    var ident = this.input.slice(next, pos);\n    if (!keywordRelationalOperator.test(ident)) { return true }\n  }\n  return false\n};\n\n// check 'async [no LineTerminator here] function'\n// - 'async /*foo*/ function' is OK.\n// - 'async /*\\n*/ function' is invalid.\npp$1.isAsyncFunction = function() {\n  if (this.options.ecmaVersion < 8 || !this.isContextual(\"async\"))\n    { return false }\n\n  skipWhiteSpace.lastIndex = this.pos;\n  var skip = skipWhiteSpace.exec(this.input);\n  var next = this.pos + skip[0].length;\n  return !lineBreak.test(this.input.slice(this.pos, next)) &&\n    this.input.slice(next, next + 8) === \"function\" &&\n    (next + 8 === this.input.length || !isIdentifierChar(this.input.charAt(next + 8)))\n};\n\n// Parse a single statement.\n//\n// If expecting a statement and finding a slash operator, parse a\n// regular expression literal. This is to handle cases like\n// `if (foo) /blah/.exec(foo)`, where looking at the previous token\n// does not help.\n\npp$1.parseStatement = function(context, topLevel, exports) {\n  var starttype = this.type, node = this.startNode(), kind;\n\n  if (this.isLet(context)) {\n    starttype = types._var;\n    kind = \"let\";\n  }\n\n  // Most types of statements are recognized by the keyword they\n  // start with. Many are trivial to parse, some require a bit of\n  // complexity.\n\n  switch (starttype) {\n  case types._break: case types._continue: return this.parseBreakContinueStatement(node, starttype.keyword)\n  case types._debugger: return this.parseDebuggerStatement(node)\n  case types._do: return this.parseDoStatement(node)\n  case types._for: return this.parseForStatement(node)\n  case types._function:\n    // Function as sole body of either an if statement or a labeled statement\n    // works, but not when it is part of a labeled statement that is the sole\n    // body of an if statement.\n    if ((context && (this.strict || context !== \"if\" && context !== \"label\")) && this.options.ecmaVersion >= 6) { this.unexpected(); }\n    return this.parseFunctionStatement(node, false, !context)\n  case types._class:\n    if (context) { this.unexpected(); }\n    return this.parseClass(node, true)\n  case types._if: return this.parseIfStatement(node)\n  case types._return: return this.parseReturnStatement(node)\n  case types._switch: return this.parseSwitchStatement(node)\n  case types._throw: return this.parseThrowStatement(node)\n  case types._try: return this.parseTryStatement(node)\n  case types._const: case types._var:\n    kind = kind || this.value;\n    if (context && kind !== \"var\") { this.unexpected(); }\n    return this.parseVarStatement(node, kind)\n  case types._while: return this.parseWhileStatement(node)\n  case types._with: return this.parseWithStatement(node)\n  case types.braceL: return this.parseBlock(true, node)\n  case types.semi: return this.parseEmptyStatement(node)\n  case types._export:\n  case types._import:\n    if (this.options.ecmaVersion > 10 && starttype === types._import) {\n      skipWhiteSpace.lastIndex = this.pos;\n      var skip = skipWhiteSpace.exec(this.input);\n      var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);\n      if (nextCh === 40 || nextCh === 46) // '(' or '.'\n        { return this.parseExpressionStatement(node, this.parseExpression()) }\n    }\n\n    if (!this.options.allowImportExportEverywhere) {\n      if (!topLevel)\n        { this.raise(this.start, \"'import' and 'export' may only appear at the top level\"); }\n      if (!this.inModule)\n        { this.raise(this.start, \"'import' and 'export' may appear only with 'sourceType: module'\"); }\n    }\n    return starttype === types._import ? this.parseImport(node) : this.parseExport(node, exports)\n\n    // If the statement does not start with a statement keyword or a\n    // brace, it's an ExpressionStatement or LabeledStatement. We\n    // simply start parsing an expression, and afterwards, if the\n    // next token is a colon and the expression was a simple\n    // Identifier node, we switch to interpreting it as a label.\n  default:\n    if (this.isAsyncFunction()) {\n      if (context) { this.unexpected(); }\n      this.next();\n      return this.parseFunctionStatement(node, true, !context)\n    }\n\n    var maybeName = this.value, expr = this.parseExpression();\n    if (starttype === types.name && expr.type === \"Identifier\" && this.eat(types.colon))\n      { return this.parseLabeledStatement(node, maybeName, expr, context) }\n    else { return this.parseExpressionStatement(node, expr) }\n  }\n};\n\npp$1.parseBreakContinueStatement = function(node, keyword) {\n  var isBreak = keyword === \"break\";\n  this.next();\n  if (this.eat(types.semi) || this.insertSemicolon()) { node.label = null; }\n  else if (this.type !== types.name) { this.unexpected(); }\n  else {\n    node.label = this.parseIdent();\n    this.semicolon();\n  }\n\n  // Verify that there is an actual destination to break or\n  // continue to.\n  var i = 0;\n  for (; i < this.labels.length; ++i) {\n    var lab = this.labels[i];\n    if (node.label == null || lab.name === node.label.name) {\n      if (lab.kind != null && (isBreak || lab.kind === \"loop\")) { break }\n      if (node.label && isBreak) { break }\n    }\n  }\n  if (i === this.labels.length) { this.raise(node.start, \"Unsyntactic \" + keyword); }\n  return this.finishNode(node, isBreak ? \"BreakStatement\" : \"ContinueStatement\")\n};\n\npp$1.parseDebuggerStatement = function(node) {\n  this.next();\n  this.semicolon();\n  return this.finishNode(node, \"DebuggerStatement\")\n};\n\npp$1.parseDoStatement = function(node) {\n  this.next();\n  this.labels.push(loopLabel);\n  node.body = this.parseStatement(\"do\");\n  this.labels.pop();\n  this.expect(types._while);\n  node.test = this.parseParenExpression();\n  if (this.options.ecmaVersion >= 6)\n    { this.eat(types.semi); }\n  else\n    { this.semicolon(); }\n  return this.finishNode(node, \"DoWhileStatement\")\n};\n\n// Disambiguating between a `for` and a `for`/`in` or `for`/`of`\n// loop is non-trivial. Basically, we have to parse the init `var`\n// statement or expression, disallowing the `in` operator (see\n// the second parameter to `parseExpression`), and then check\n// whether the next token is `in` or `of`. When there is no init\n// part (semicolon immediately after the opening parenthesis), it\n// is a regular `for` loop.\n\npp$1.parseForStatement = function(node) {\n  this.next();\n  var awaitAt = (this.options.ecmaVersion >= 9 && (this.inAsync || (!this.inFunction && this.options.allowAwaitOutsideFunction)) && this.eatContextual(\"await\")) ? this.lastTokStart : -1;\n  this.labels.push(loopLabel);\n  this.enterScope(0);\n  this.expect(types.parenL);\n  if (this.type === types.semi) {\n    if (awaitAt > -1) { this.unexpected(awaitAt); }\n    return this.parseFor(node, null)\n  }\n  var isLet = this.isLet();\n  if (this.type === types._var || this.type === types._const || isLet) {\n    var init$1 = this.startNode(), kind = isLet ? \"let\" : this.value;\n    this.next();\n    this.parseVar(init$1, true, kind);\n    this.finishNode(init$1, \"VariableDeclaration\");\n    if ((this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual(\"of\"))) && init$1.declarations.length === 1) {\n      if (this.options.ecmaVersion >= 9) {\n        if (this.type === types._in) {\n          if (awaitAt > -1) { this.unexpected(awaitAt); }\n        } else { node.await = awaitAt > -1; }\n      }\n      return this.parseForIn(node, init$1)\n    }\n    if (awaitAt > -1) { this.unexpected(awaitAt); }\n    return this.parseFor(node, init$1)\n  }\n  var refDestructuringErrors = new DestructuringErrors;\n  var init = this.parseExpression(true, refDestructuringErrors);\n  if (this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual(\"of\"))) {\n    if (this.options.ecmaVersion >= 9) {\n      if (this.type === types._in) {\n        if (awaitAt > -1) { this.unexpected(awaitAt); }\n      } else { node.await = awaitAt > -1; }\n    }\n    this.toAssignable(init, false, refDestructuringErrors);\n    this.checkLVal(init);\n    return this.parseForIn(node, init)\n  } else {\n    this.checkExpressionErrors(refDestructuringErrors, true);\n  }\n  if (awaitAt > -1) { this.unexpected(awaitAt); }\n  return this.parseFor(node, init)\n};\n\npp$1.parseFunctionStatement = function(node, isAsync, declarationPosition) {\n  this.next();\n  return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync)\n};\n\npp$1.parseIfStatement = function(node) {\n  this.next();\n  node.test = this.parseParenExpression();\n  // allow function declarations in branches, but only in non-strict mode\n  node.consequent = this.parseStatement(\"if\");\n  node.alternate = this.eat(types._else) ? this.parseStatement(\"if\") : null;\n  return this.finishNode(node, \"IfStatement\")\n};\n\npp$1.parseReturnStatement = function(node) {\n  if (!this.inFunction && !this.options.allowReturnOutsideFunction)\n    { this.raise(this.start, \"'return' outside of function\"); }\n  this.next();\n\n  // In `return` (and `break`/`continue`), the keywords with\n  // optional arguments, we eagerly look for a semicolon or the\n  // possibility to insert one.\n\n  if (this.eat(types.semi) || this.insertSemicolon()) { node.argument = null; }\n  else { node.argument = this.parseExpression(); this.semicolon(); }\n  return this.finishNode(node, \"ReturnStatement\")\n};\n\npp$1.parseSwitchStatement = function(node) {\n  this.next();\n  node.discriminant = this.parseParenExpression();\n  node.cases = [];\n  this.expect(types.braceL);\n  this.labels.push(switchLabel);\n  this.enterScope(0);\n\n  // Statements under must be grouped (by label) in SwitchCase\n  // nodes. `cur` is used to keep the node that we are currently\n  // adding statements to.\n\n  var cur;\n  for (var sawDefault = false; this.type !== types.braceR;) {\n    if (this.type === types._case || this.type === types._default) {\n      var isCase = this.type === types._case;\n      if (cur) { this.finishNode(cur, \"SwitchCase\"); }\n      node.cases.push(cur = this.startNode());\n      cur.consequent = [];\n      this.next();\n      if (isCase) {\n        cur.test = this.parseExpression();\n      } else {\n        if (sawDefault) { this.raiseRecoverable(this.lastTokStart, \"Multiple default clauses\"); }\n        sawDefault = true;\n        cur.test = null;\n      }\n      this.expect(types.colon);\n    } else {\n      if (!cur) { this.unexpected(); }\n      cur.consequent.push(this.parseStatement(null));\n    }\n  }\n  this.exitScope();\n  if (cur) { this.finishNode(cur, \"SwitchCase\"); }\n  this.next(); // Closing brace\n  this.labels.pop();\n  return this.finishNode(node, \"SwitchStatement\")\n};\n\npp$1.parseThrowStatement = function(node) {\n  this.next();\n  if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start)))\n    { this.raise(this.lastTokEnd, \"Illegal newline after throw\"); }\n  node.argument = this.parseExpression();\n  this.semicolon();\n  return this.finishNode(node, \"ThrowStatement\")\n};\n\n// Reused empty array added for node fields that are always empty.\n\nvar empty = [];\n\npp$1.parseTryStatement = function(node) {\n  this.next();\n  node.block = this.parseBlock();\n  node.handler = null;\n  if (this.type === types._catch) {\n    var clause = this.startNode();\n    this.next();\n    if (this.eat(types.parenL)) {\n      clause.param = this.parseBindingAtom();\n      var simple = clause.param.type === \"Identifier\";\n      this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);\n      this.checkLVal(clause.param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);\n      this.expect(types.parenR);\n    } else {\n      if (this.options.ecmaVersion < 10) { this.unexpected(); }\n      clause.param = null;\n      this.enterScope(0);\n    }\n    clause.body = this.parseBlock(false);\n    this.exitScope();\n    node.handler = this.finishNode(clause, \"CatchClause\");\n  }\n  node.finalizer = this.eat(types._finally) ? this.parseBlock() : null;\n  if (!node.handler && !node.finalizer)\n    { this.raise(node.start, \"Missing catch or finally clause\"); }\n  return this.finishNode(node, \"TryStatement\")\n};\n\npp$1.parseVarStatement = function(node, kind) {\n  this.next();\n  this.parseVar(node, false, kind);\n  this.semicolon();\n  return this.finishNode(node, \"VariableDeclaration\")\n};\n\npp$1.parseWhileStatement = function(node) {\n  this.next();\n  node.test = this.parseParenExpression();\n  this.labels.push(loopLabel);\n  node.body = this.parseStatement(\"while\");\n  this.labels.pop();\n  return this.finishNode(node, \"WhileStatement\")\n};\n\npp$1.parseWithStatement = function(node) {\n  if (this.strict) { this.raise(this.start, \"'with' in strict mode\"); }\n  this.next();\n  node.object = this.parseParenExpression();\n  node.body = this.parseStatement(\"with\");\n  return this.finishNode(node, \"WithStatement\")\n};\n\npp$1.parseEmptyStatement = function(node) {\n  this.next();\n  return this.finishNode(node, \"EmptyStatement\")\n};\n\npp$1.parseLabeledStatement = function(node, maybeName, expr, context) {\n  for (var i$1 = 0, list = this.labels; i$1 < list.length; i$1 += 1)\n    {\n    var label = list[i$1];\n\n    if (label.name === maybeName)\n      { this.raise(expr.start, \"Label '\" + maybeName + \"' is already declared\");\n  } }\n  var kind = this.type.isLoop ? \"loop\" : this.type === types._switch ? \"switch\" : null;\n  for (var i = this.labels.length - 1; i >= 0; i--) {\n    var label$1 = this.labels[i];\n    if (label$1.statementStart === node.start) {\n      // Update information about previous labels on this node\n      label$1.statementStart = this.start;\n      label$1.kind = kind;\n    } else { break }\n  }\n  this.labels.push({name: maybeName, kind: kind, statementStart: this.start});\n  node.body = this.parseStatement(context ? context.indexOf(\"label\") === -1 ? context + \"label\" : context : \"label\");\n  this.labels.pop();\n  node.label = expr;\n  return this.finishNode(node, \"LabeledStatement\")\n};\n\npp$1.parseExpressionStatement = function(node, expr) {\n  node.expression = expr;\n  this.semicolon();\n  return this.finishNode(node, \"ExpressionStatement\")\n};\n\n// Parse a semicolon-enclosed block of statements, handling `\"use\n// strict\"` declarations when `allowStrict` is true (used for\n// function bodies).\n\npp$1.parseBlock = function(createNewLexicalScope, node, exitStrict) {\n  if ( createNewLexicalScope === void 0 ) createNewLexicalScope = true;\n  if ( node === void 0 ) node = this.startNode();\n\n  node.body = [];\n  this.expect(types.braceL);\n  if (createNewLexicalScope) { this.enterScope(0); }\n  while (this.type !== types.braceR) {\n    var stmt = this.parseStatement(null);\n    node.body.push(stmt);\n  }\n  if (exitStrict) { this.strict = false; }\n  this.next();\n  if (createNewLexicalScope) { this.exitScope(); }\n  return this.finishNode(node, \"BlockStatement\")\n};\n\n// Parse a regular `for` loop. The disambiguation code in\n// `parseStatement` will already have parsed the init statement or\n// expression.\n\npp$1.parseFor = function(node, init) {\n  node.init = init;\n  this.expect(types.semi);\n  node.test = this.type === types.semi ? null : this.parseExpression();\n  this.expect(types.semi);\n  node.update = this.type === types.parenR ? null : this.parseExpression();\n  this.expect(types.parenR);\n  node.body = this.parseStatement(\"for\");\n  this.exitScope();\n  this.labels.pop();\n  return this.finishNode(node, \"ForStatement\")\n};\n\n// Parse a `for`/`in` and `for`/`of` loop, which are almost\n// same from parser's perspective.\n\npp$1.parseForIn = function(node, init) {\n  var isForIn = this.type === types._in;\n  this.next();\n\n  if (\n    init.type === \"VariableDeclaration\" &&\n    init.declarations[0].init != null &&\n    (\n      !isForIn ||\n      this.options.ecmaVersion < 8 ||\n      this.strict ||\n      init.kind !== \"var\" ||\n      init.declarations[0].id.type !== \"Identifier\"\n    )\n  ) {\n    this.raise(\n      init.start,\n      ((isForIn ? \"for-in\" : \"for-of\") + \" loop variable declaration may not have an initializer\")\n    );\n  } else if (init.type === \"AssignmentPattern\") {\n    this.raise(init.start, \"Invalid left-hand side in for-loop\");\n  }\n  node.left = init;\n  node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();\n  this.expect(types.parenR);\n  node.body = this.parseStatement(\"for\");\n  this.exitScope();\n  this.labels.pop();\n  return this.finishNode(node, isForIn ? \"ForInStatement\" : \"ForOfStatement\")\n};\n\n// Parse a list of variable declarations.\n\npp$1.parseVar = function(node, isFor, kind) {\n  node.declarations = [];\n  node.kind = kind;\n  for (;;) {\n    var decl = this.startNode();\n    this.parseVarId(decl, kind);\n    if (this.eat(types.eq)) {\n      decl.init = this.parseMaybeAssign(isFor);\n    } else if (kind === \"const\" && !(this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual(\"of\")))) {\n      this.unexpected();\n    } else if (decl.id.type !== \"Identifier\" && !(isFor && (this.type === types._in || this.isContextual(\"of\")))) {\n      this.raise(this.lastTokEnd, \"Complex binding patterns require an initialization value\");\n    } else {\n      decl.init = null;\n    }\n    node.declarations.push(this.finishNode(decl, \"VariableDeclarator\"));\n    if (!this.eat(types.comma)) { break }\n  }\n  return node\n};\n\npp$1.parseVarId = function(decl, kind) {\n  decl.id = this.parseBindingAtom();\n  this.checkLVal(decl.id, kind === \"var\" ? BIND_VAR : BIND_LEXICAL, false);\n};\n\nvar FUNC_STATEMENT = 1, FUNC_HANGING_STATEMENT = 2, FUNC_NULLABLE_ID = 4;\n\n// Parse a function declaration or literal (depending on the\n// `statement & FUNC_STATEMENT`).\n\n// Remove `allowExpressionBody` for 7.0.0, as it is only called with false\npp$1.parseFunction = function(node, statement, allowExpressionBody, isAsync) {\n  this.initFunction(node);\n  if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {\n    if (this.type === types.star && (statement & FUNC_HANGING_STATEMENT))\n      { this.unexpected(); }\n    node.generator = this.eat(types.star);\n  }\n  if (this.options.ecmaVersion >= 8)\n    { node.async = !!isAsync; }\n\n  if (statement & FUNC_STATEMENT) {\n    node.id = (statement & FUNC_NULLABLE_ID) && this.type !== types.name ? null : this.parseIdent();\n    if (node.id && !(statement & FUNC_HANGING_STATEMENT))\n      // If it is a regular function declaration in sloppy mode, then it is\n      // subject to Annex B semantics (BIND_FUNCTION). Otherwise, the binding\n      // mode depends on properties of the current scope (see\n      // treatFunctionsAsVar).\n      { this.checkLVal(node.id, (this.strict || node.generator || node.async) ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION); }\n  }\n\n  var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\n  this.yieldPos = 0;\n  this.awaitPos = 0;\n  this.awaitIdentPos = 0;\n  this.enterScope(functionFlags(node.async, node.generator));\n\n  if (!(statement & FUNC_STATEMENT))\n    { node.id = this.type === types.name ? this.parseIdent() : null; }\n\n  this.parseFunctionParams(node);\n  this.parseFunctionBody(node, allowExpressionBody, false);\n\n  this.yieldPos = oldYieldPos;\n  this.awaitPos = oldAwaitPos;\n  this.awaitIdentPos = oldAwaitIdentPos;\n  return this.finishNode(node, (statement & FUNC_STATEMENT) ? \"FunctionDeclaration\" : \"FunctionExpression\")\n};\n\npp$1.parseFunctionParams = function(node) {\n  this.expect(types.parenL);\n  node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);\n  this.checkYieldAwaitInDefaultParams();\n};\n\n// Parse a class declaration or literal (depending on the\n// `isStatement` parameter).\n\npp$1.parseClass = function(node, isStatement) {\n  this.next();\n\n  // ecma-262 14.6 Class Definitions\n  // A class definition is always strict mode code.\n  var oldStrict = this.strict;\n  this.strict = true;\n\n  this.parseClassId(node, isStatement);\n  this.parseClassSuper(node);\n  var classBody = this.startNode();\n  var hadConstructor = false;\n  classBody.body = [];\n  this.expect(types.braceL);\n  while (this.type !== types.braceR) {\n    var element = this.parseClassElement(node.superClass !== null);\n    if (element) {\n      classBody.body.push(element);\n      if (element.type === \"MethodDefinition\" && element.kind === \"constructor\") {\n        if (hadConstructor) { this.raise(element.start, \"Duplicate constructor in the same class\"); }\n        hadConstructor = true;\n      }\n    }\n  }\n  this.strict = oldStrict;\n  this.next();\n  node.body = this.finishNode(classBody, \"ClassBody\");\n  return this.finishNode(node, isStatement ? \"ClassDeclaration\" : \"ClassExpression\")\n};\n\npp$1.parseClassElement = function(constructorAllowsSuper) {\n  var this$1 = this;\n\n  if (this.eat(types.semi)) { return null }\n\n  var method = this.startNode();\n  var tryContextual = function (k, noLineBreak) {\n    if ( noLineBreak === void 0 ) noLineBreak = false;\n\n    var start = this$1.start, startLoc = this$1.startLoc;\n    if (!this$1.eatContextual(k)) { return false }\n    if (this$1.type !== types.parenL && (!noLineBreak || !this$1.canInsertSemicolon())) { return true }\n    if (method.key) { this$1.unexpected(); }\n    method.computed = false;\n    method.key = this$1.startNodeAt(start, startLoc);\n    method.key.name = k;\n    this$1.finishNode(method.key, \"Identifier\");\n    return false\n  };\n\n  method.kind = \"method\";\n  method.static = tryContextual(\"static\");\n  var isGenerator = this.eat(types.star);\n  var isAsync = false;\n  if (!isGenerator) {\n    if (this.options.ecmaVersion >= 8 && tryContextual(\"async\", true)) {\n      isAsync = true;\n      isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);\n    } else if (tryContextual(\"get\")) {\n      method.kind = \"get\";\n    } else if (tryContextual(\"set\")) {\n      method.kind = \"set\";\n    }\n  }\n  if (!method.key) { this.parsePropertyName(method); }\n  var key = method.key;\n  var allowsDirectSuper = false;\n  if (!method.computed && !method.static && (key.type === \"Identifier\" && key.name === \"constructor\" ||\n      key.type === \"Literal\" && key.value === \"constructor\")) {\n    if (method.kind !== \"method\") { this.raise(key.start, \"Constructor can't have get/set modifier\"); }\n    if (isGenerator) { this.raise(key.start, \"Constructor can't be a generator\"); }\n    if (isAsync) { this.raise(key.start, \"Constructor can't be an async method\"); }\n    method.kind = \"constructor\";\n    allowsDirectSuper = constructorAllowsSuper;\n  } else if (method.static && key.type === \"Identifier\" && key.name === \"prototype\") {\n    this.raise(key.start, \"Classes may not have a static property named prototype\");\n  }\n  this.parseClassMethod(method, isGenerator, isAsync, allowsDirectSuper);\n  if (method.kind === \"get\" && method.value.params.length !== 0)\n    { this.raiseRecoverable(method.value.start, \"getter should have no params\"); }\n  if (method.kind === \"set\" && method.value.params.length !== 1)\n    { this.raiseRecoverable(method.value.start, \"setter should have exactly one param\"); }\n  if (method.kind === \"set\" && method.value.params[0].type === \"RestElement\")\n    { this.raiseRecoverable(method.value.params[0].start, \"Setter cannot use rest params\"); }\n  return method\n};\n\npp$1.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {\n  method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);\n  return this.finishNode(method, \"MethodDefinition\")\n};\n\npp$1.parseClassId = function(node, isStatement) {\n  if (this.type === types.name) {\n    node.id = this.parseIdent();\n    if (isStatement)\n      { this.checkLVal(node.id, BIND_LEXICAL, false); }\n  } else {\n    if (isStatement === true)\n      { this.unexpected(); }\n    node.id = null;\n  }\n};\n\npp$1.parseClassSuper = function(node) {\n  node.superClass = this.eat(types._extends) ? this.parseExprSubscripts() : null;\n};\n\n// Parses module export declaration.\n\npp$1.parseExport = function(node, exports) {\n  this.next();\n  // export * from '...'\n  if (this.eat(types.star)) {\n    if (this.options.ecmaVersion >= 11) {\n      if (this.eatContextual(\"as\")) {\n        node.exported = this.parseIdent(true);\n        this.checkExport(exports, node.exported.name, this.lastTokStart);\n      } else {\n        node.exported = null;\n      }\n    }\n    this.expectContextual(\"from\");\n    if (this.type !== types.string) { this.unexpected(); }\n    node.source = this.parseExprAtom();\n    this.semicolon();\n    return this.finishNode(node, \"ExportAllDeclaration\")\n  }\n  if (this.eat(types._default)) { // export default ...\n    this.checkExport(exports, \"default\", this.lastTokStart);\n    var isAsync;\n    if (this.type === types._function || (isAsync = this.isAsyncFunction())) {\n      var fNode = this.startNode();\n      this.next();\n      if (isAsync) { this.next(); }\n      node.declaration = this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);\n    } else if (this.type === types._class) {\n      var cNode = this.startNode();\n      node.declaration = this.parseClass(cNode, \"nullableID\");\n    } else {\n      node.declaration = this.parseMaybeAssign();\n      this.semicolon();\n    }\n    return this.finishNode(node, \"ExportDefaultDeclaration\")\n  }\n  // export var|const|let|function|class ...\n  if (this.shouldParseExportStatement()) {\n    node.declaration = this.parseStatement(null);\n    if (node.declaration.type === \"VariableDeclaration\")\n      { this.checkVariableExport(exports, node.declaration.declarations); }\n    else\n      { this.checkExport(exports, node.declaration.id.name, node.declaration.id.start); }\n    node.specifiers = [];\n    node.source = null;\n  } else { // export { x, y as z } [from '...']\n    node.declaration = null;\n    node.specifiers = this.parseExportSpecifiers(exports);\n    if (this.eatContextual(\"from\")) {\n      if (this.type !== types.string) { this.unexpected(); }\n      node.source = this.parseExprAtom();\n    } else {\n      for (var i = 0, list = node.specifiers; i < list.length; i += 1) {\n        // check for keywords used as local names\n        var spec = list[i];\n\n        this.checkUnreserved(spec.local);\n        // check if export is defined\n        this.checkLocalExport(spec.local);\n      }\n\n      node.source = null;\n    }\n    this.semicolon();\n  }\n  return this.finishNode(node, \"ExportNamedDeclaration\")\n};\n\npp$1.checkExport = function(exports, name, pos) {\n  if (!exports) { return }\n  if (has(exports, name))\n    { this.raiseRecoverable(pos, \"Duplicate export '\" + name + \"'\"); }\n  exports[name] = true;\n};\n\npp$1.checkPatternExport = function(exports, pat) {\n  var type = pat.type;\n  if (type === \"Identifier\")\n    { this.checkExport(exports, pat.name, pat.start); }\n  else if (type === \"ObjectPattern\")\n    { for (var i = 0, list = pat.properties; i < list.length; i += 1)\n      {\n        var prop = list[i];\n\n        this.checkPatternExport(exports, prop);\n      } }\n  else if (type === \"ArrayPattern\")\n    { for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {\n      var elt = list$1[i$1];\n\n        if (elt) { this.checkPatternExport(exports, elt); }\n    } }\n  else if (type === \"Property\")\n    { this.checkPatternExport(exports, pat.value); }\n  else if (type === \"AssignmentPattern\")\n    { this.checkPatternExport(exports, pat.left); }\n  else if (type === \"RestElement\")\n    { this.checkPatternExport(exports, pat.argument); }\n  else if (type === \"ParenthesizedExpression\")\n    { this.checkPatternExport(exports, pat.expression); }\n};\n\npp$1.checkVariableExport = function(exports, decls) {\n  if (!exports) { return }\n  for (var i = 0, list = decls; i < list.length; i += 1)\n    {\n    var decl = list[i];\n\n    this.checkPatternExport(exports, decl.id);\n  }\n};\n\npp$1.shouldParseExportStatement = function() {\n  return this.type.keyword === \"var\" ||\n    this.type.keyword === \"const\" ||\n    this.type.keyword === \"class\" ||\n    this.type.keyword === \"function\" ||\n    this.isLet() ||\n    this.isAsyncFunction()\n};\n\n// Parses a comma-separated list of module exports.\n\npp$1.parseExportSpecifiers = function(exports) {\n  var nodes = [], first = true;\n  // export { x, y as z } [from '...']\n  this.expect(types.braceL);\n  while (!this.eat(types.braceR)) {\n    if (!first) {\n      this.expect(types.comma);\n      if (this.afterTrailingComma(types.braceR)) { break }\n    } else { first = false; }\n\n    var node = this.startNode();\n    node.local = this.parseIdent(true);\n    node.exported = this.eatContextual(\"as\") ? this.parseIdent(true) : node.local;\n    this.checkExport(exports, node.exported.name, node.exported.start);\n    nodes.push(this.finishNode(node, \"ExportSpecifier\"));\n  }\n  return nodes\n};\n\n// Parses import declaration.\n\npp$1.parseImport = function(node) {\n  this.next();\n  // import '...'\n  if (this.type === types.string) {\n    node.specifiers = empty;\n    node.source = this.parseExprAtom();\n  } else {\n    node.specifiers = this.parseImportSpecifiers();\n    this.expectContextual(\"from\");\n    node.source = this.type === types.string ? this.parseExprAtom() : this.unexpected();\n  }\n  this.semicolon();\n  return this.finishNode(node, \"ImportDeclaration\")\n};\n\n// Parses a comma-separated list of module imports.\n\npp$1.parseImportSpecifiers = function() {\n  var nodes = [], first = true;\n  if (this.type === types.name) {\n    // import defaultObj, { x, y as z } from '...'\n    var node = this.startNode();\n    node.local = this.parseIdent();\n    this.checkLVal(node.local, BIND_LEXICAL);\n    nodes.push(this.finishNode(node, \"ImportDefaultSpecifier\"));\n    if (!this.eat(types.comma)) { return nodes }\n  }\n  if (this.type === types.star) {\n    var node$1 = this.startNode();\n    this.next();\n    this.expectContextual(\"as\");\n    node$1.local = this.parseIdent();\n    this.checkLVal(node$1.local, BIND_LEXICAL);\n    nodes.push(this.finishNode(node$1, \"ImportNamespaceSpecifier\"));\n    return nodes\n  }\n  this.expect(types.braceL);\n  while (!this.eat(types.braceR)) {\n    if (!first) {\n      this.expect(types.comma);\n      if (this.afterTrailingComma(types.braceR)) { break }\n    } else { first = false; }\n\n    var node$2 = this.startNode();\n    node$2.imported = this.parseIdent(true);\n    if (this.eatContextual(\"as\")) {\n      node$2.local = this.parseIdent();\n    } else {\n      this.checkUnreserved(node$2.imported);\n      node$2.local = node$2.imported;\n    }\n    this.checkLVal(node$2.local, BIND_LEXICAL);\n    nodes.push(this.finishNode(node$2, \"ImportSpecifier\"));\n  }\n  return nodes\n};\n\n// Set `ExpressionStatement#directive` property for directive prologues.\npp$1.adaptDirectivePrologue = function(statements) {\n  for (var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i) {\n    statements[i].directive = statements[i].expression.raw.slice(1, -1);\n  }\n};\npp$1.isDirectiveCandidate = function(statement) {\n  return (\n    statement.type === \"ExpressionStatement\" &&\n    statement.expression.type === \"Literal\" &&\n    typeof statement.expression.value === \"string\" &&\n    // Reject parenthesized strings.\n    (this.input[statement.start] === \"\\\"\" || this.input[statement.start] === \"'\")\n  )\n};\n\nvar pp$2 = Parser.prototype;\n\n// Convert existing expression atom to assignable pattern\n// if possible.\n\npp$2.toAssignable = function(node, isBinding, refDestructuringErrors) {\n  if (this.options.ecmaVersion >= 6 && node) {\n    switch (node.type) {\n    case \"Identifier\":\n      if (this.inAsync && node.name === \"await\")\n        { this.raise(node.start, \"Cannot use 'await' as identifier inside an async function\"); }\n      break\n\n    case \"ObjectPattern\":\n    case \"ArrayPattern\":\n    case \"RestElement\":\n      break\n\n    case \"ObjectExpression\":\n      node.type = \"ObjectPattern\";\n      if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }\n      for (var i = 0, list = node.properties; i < list.length; i += 1) {\n        var prop = list[i];\n\n      this.toAssignable(prop, isBinding);\n        // Early error:\n        //   AssignmentRestProperty[Yield, Await] :\n        //     `...` DestructuringAssignmentTarget[Yield, Await]\n        //\n        //   It is a Syntax Error if |DestructuringAssignmentTarget| is an |ArrayLiteral| or an |ObjectLiteral|.\n        if (\n          prop.type === \"RestElement\" &&\n          (prop.argument.type === \"ArrayPattern\" || prop.argument.type === \"ObjectPattern\")\n        ) {\n          this.raise(prop.argument.start, \"Unexpected token\");\n        }\n      }\n      break\n\n    case \"Property\":\n      // AssignmentProperty has type === \"Property\"\n      if (node.kind !== \"init\") { this.raise(node.key.start, \"Object pattern can't contain getter or setter\"); }\n      this.toAssignable(node.value, isBinding);\n      break\n\n    case \"ArrayExpression\":\n      node.type = \"ArrayPattern\";\n      if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }\n      this.toAssignableList(node.elements, isBinding);\n      break\n\n    case \"SpreadElement\":\n      node.type = \"RestElement\";\n      this.toAssignable(node.argument, isBinding);\n      if (node.argument.type === \"AssignmentPattern\")\n        { this.raise(node.argument.start, \"Rest elements cannot have a default value\"); }\n      break\n\n    case \"AssignmentExpression\":\n      if (node.operator !== \"=\") { this.raise(node.left.end, \"Only '=' operator can be used for specifying default value.\"); }\n      node.type = \"AssignmentPattern\";\n      delete node.operator;\n      this.toAssignable(node.left, isBinding);\n      // falls through to AssignmentPattern\n\n    case \"AssignmentPattern\":\n      break\n\n    case \"ParenthesizedExpression\":\n      this.toAssignable(node.expression, isBinding, refDestructuringErrors);\n      break\n\n    case \"ChainExpression\":\n      this.raiseRecoverable(node.start, \"Optional chaining cannot appear in left-hand side\");\n      break\n\n    case \"MemberExpression\":\n      if (!isBinding) { break }\n\n    default:\n      this.raise(node.start, \"Assigning to rvalue\");\n    }\n  } else if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }\n  return node\n};\n\n// Convert list of expression atoms to binding list.\n\npp$2.toAssignableList = function(exprList, isBinding) {\n  var end = exprList.length;\n  for (var i = 0; i < end; i++) {\n    var elt = exprList[i];\n    if (elt) { this.toAssignable(elt, isBinding); }\n  }\n  if (end) {\n    var last = exprList[end - 1];\n    if (this.options.ecmaVersion === 6 && isBinding && last && last.type === \"RestElement\" && last.argument.type !== \"Identifier\")\n      { this.unexpected(last.argument.start); }\n  }\n  return exprList\n};\n\n// Parses spread element.\n\npp$2.parseSpread = function(refDestructuringErrors) {\n  var node = this.startNode();\n  this.next();\n  node.argument = this.parseMaybeAssign(false, refDestructuringErrors);\n  return this.finishNode(node, \"SpreadElement\")\n};\n\npp$2.parseRestBinding = function() {\n  var node = this.startNode();\n  this.next();\n\n  // RestElement inside of a function parameter must be an identifier\n  if (this.options.ecmaVersion === 6 && this.type !== types.name)\n    { this.unexpected(); }\n\n  node.argument = this.parseBindingAtom();\n\n  return this.finishNode(node, \"RestElement\")\n};\n\n// Parses lvalue (assignable) atom.\n\npp$2.parseBindingAtom = function() {\n  if (this.options.ecmaVersion >= 6) {\n    switch (this.type) {\n    case types.bracketL:\n      var node = this.startNode();\n      this.next();\n      node.elements = this.parseBindingList(types.bracketR, true, true);\n      return this.finishNode(node, \"ArrayPattern\")\n\n    case types.braceL:\n      return this.parseObj(true)\n    }\n  }\n  return this.parseIdent()\n};\n\npp$2.parseBindingList = function(close, allowEmpty, allowTrailingComma) {\n  var elts = [], first = true;\n  while (!this.eat(close)) {\n    if (first) { first = false; }\n    else { this.expect(types.comma); }\n    if (allowEmpty && this.type === types.comma) {\n      elts.push(null);\n    } else if (allowTrailingComma && this.afterTrailingComma(close)) {\n      break\n    } else if (this.type === types.ellipsis) {\n      var rest = this.parseRestBinding();\n      this.parseBindingListItem(rest);\n      elts.push(rest);\n      if (this.type === types.comma) { this.raise(this.start, \"Comma is not permitted after the rest element\"); }\n      this.expect(close);\n      break\n    } else {\n      var elem = this.parseMaybeDefault(this.start, this.startLoc);\n      this.parseBindingListItem(elem);\n      elts.push(elem);\n    }\n  }\n  return elts\n};\n\npp$2.parseBindingListItem = function(param) {\n  return param\n};\n\n// Parses assignment pattern around given atom if possible.\n\npp$2.parseMaybeDefault = function(startPos, startLoc, left) {\n  left = left || this.parseBindingAtom();\n  if (this.options.ecmaVersion < 6 || !this.eat(types.eq)) { return left }\n  var node = this.startNodeAt(startPos, startLoc);\n  node.left = left;\n  node.right = this.parseMaybeAssign();\n  return this.finishNode(node, \"AssignmentPattern\")\n};\n\n// Verify that a node is an lval — something that can be assigned\n// to.\n// bindingType can be either:\n// 'var' indicating that the lval creates a 'var' binding\n// 'let' indicating that the lval creates a lexical ('let' or 'const') binding\n// 'none' indicating that the binding should be checked for illegal identifiers, but not for duplicate references\n\npp$2.checkLVal = function(expr, bindingType, checkClashes) {\n  if ( bindingType === void 0 ) bindingType = BIND_NONE;\n\n  switch (expr.type) {\n  case \"Identifier\":\n    if (bindingType === BIND_LEXICAL && expr.name === \"let\")\n      { this.raiseRecoverable(expr.start, \"let is disallowed as a lexically bound name\"); }\n    if (this.strict && this.reservedWordsStrictBind.test(expr.name))\n      { this.raiseRecoverable(expr.start, (bindingType ? \"Binding \" : \"Assigning to \") + expr.name + \" in strict mode\"); }\n    if (checkClashes) {\n      if (has(checkClashes, expr.name))\n        { this.raiseRecoverable(expr.start, \"Argument name clash\"); }\n      checkClashes[expr.name] = true;\n    }\n    if (bindingType !== BIND_NONE && bindingType !== BIND_OUTSIDE) { this.declareName(expr.name, bindingType, expr.start); }\n    break\n\n  case \"ChainExpression\":\n    this.raiseRecoverable(expr.start, \"Optional chaining cannot appear in left-hand side\");\n    break\n\n  case \"MemberExpression\":\n    if (bindingType) { this.raiseRecoverable(expr.start, \"Binding member expression\"); }\n    break\n\n  case \"ObjectPattern\":\n    for (var i = 0, list = expr.properties; i < list.length; i += 1)\n      {\n    var prop = list[i];\n\n    this.checkLVal(prop, bindingType, checkClashes);\n  }\n    break\n\n  case \"Property\":\n    // AssignmentProperty has type === \"Property\"\n    this.checkLVal(expr.value, bindingType, checkClashes);\n    break\n\n  case \"ArrayPattern\":\n    for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {\n      var elem = list$1[i$1];\n\n    if (elem) { this.checkLVal(elem, bindingType, checkClashes); }\n    }\n    break\n\n  case \"AssignmentPattern\":\n    this.checkLVal(expr.left, bindingType, checkClashes);\n    break\n\n  case \"RestElement\":\n    this.checkLVal(expr.argument, bindingType, checkClashes);\n    break\n\n  case \"ParenthesizedExpression\":\n    this.checkLVal(expr.expression, bindingType, checkClashes);\n    break\n\n  default:\n    this.raise(expr.start, (bindingType ? \"Binding\" : \"Assigning to\") + \" rvalue\");\n  }\n};\n\n// A recursive descent parser operates by defining functions for all\n\nvar pp$3 = Parser.prototype;\n\n// Check if property name clashes with already added.\n// Object/class getters and setters are not allowed to clash —\n// either with each other or with an init property — and in\n// strict mode, init properties are also not allowed to be repeated.\n\npp$3.checkPropClash = function(prop, propHash, refDestructuringErrors) {\n  if (this.options.ecmaVersion >= 9 && prop.type === \"SpreadElement\")\n    { return }\n  if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand))\n    { return }\n  var key = prop.key;\n  var name;\n  switch (key.type) {\n  case \"Identifier\": name = key.name; break\n  case \"Literal\": name = String(key.value); break\n  default: return\n  }\n  var kind = prop.kind;\n  if (this.options.ecmaVersion >= 6) {\n    if (name === \"__proto__\" && kind === \"init\") {\n      if (propHash.proto) {\n        if (refDestructuringErrors) {\n          if (refDestructuringErrors.doubleProto < 0)\n            { refDestructuringErrors.doubleProto = key.start; }\n          // Backwards-compat kludge. Can be removed in version 6.0\n        } else { this.raiseRecoverable(key.start, \"Redefinition of __proto__ property\"); }\n      }\n      propHash.proto = true;\n    }\n    return\n  }\n  name = \"$\" + name;\n  var other = propHash[name];\n  if (other) {\n    var redefinition;\n    if (kind === \"init\") {\n      redefinition = this.strict && other.init || other.get || other.set;\n    } else {\n      redefinition = other.init || other[kind];\n    }\n    if (redefinition)\n      { this.raiseRecoverable(key.start, \"Redefinition of property\"); }\n  } else {\n    other = propHash[name] = {\n      init: false,\n      get: false,\n      set: false\n    };\n  }\n  other[kind] = true;\n};\n\n// ### Expression parsing\n\n// These nest, from the most general expression type at the top to\n// 'atomic', nondivisible expression types at the bottom. Most of\n// the functions will simply let the function(s) below them parse,\n// and, *if* the syntactic construct they handle is present, wrap\n// the AST node that the inner parser gave them in another node.\n\n// Parse a full expression. The optional arguments are used to\n// forbid the `in` operator (in for loops initalization expressions)\n// and provide reference for storing '=' operator inside shorthand\n// property assignment in contexts where both object expression\n// and object pattern might appear (so it's possible to raise\n// delayed syntax error at correct position).\n\npp$3.parseExpression = function(noIn, refDestructuringErrors) {\n  var startPos = this.start, startLoc = this.startLoc;\n  var expr = this.parseMaybeAssign(noIn, refDestructuringErrors);\n  if (this.type === types.comma) {\n    var node = this.startNodeAt(startPos, startLoc);\n    node.expressions = [expr];\n    while (this.eat(types.comma)) { node.expressions.push(this.parseMaybeAssign(noIn, refDestructuringErrors)); }\n    return this.finishNode(node, \"SequenceExpression\")\n  }\n  return expr\n};\n\n// Parse an assignment expression. This includes applications of\n// operators like `+=`.\n\npp$3.parseMaybeAssign = function(noIn, refDestructuringErrors, afterLeftParse) {\n  if (this.isContextual(\"yield\")) {\n    if (this.inGenerator) { return this.parseYield(noIn) }\n    // The tokenizer will assume an expression is allowed after\n    // `yield`, but this isn't that kind of yield\n    else { this.exprAllowed = false; }\n  }\n\n  var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1;\n  if (refDestructuringErrors) {\n    oldParenAssign = refDestructuringErrors.parenthesizedAssign;\n    oldTrailingComma = refDestructuringErrors.trailingComma;\n    refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;\n  } else {\n    refDestructuringErrors = new DestructuringErrors;\n    ownDestructuringErrors = true;\n  }\n\n  var startPos = this.start, startLoc = this.startLoc;\n  if (this.type === types.parenL || this.type === types.name)\n    { this.potentialArrowAt = this.start; }\n  var left = this.parseMaybeConditional(noIn, refDestructuringErrors);\n  if (afterLeftParse) { left = afterLeftParse.call(this, left, startPos, startLoc); }\n  if (this.type.isAssign) {\n    var node = this.startNodeAt(startPos, startLoc);\n    node.operator = this.value;\n    node.left = this.type === types.eq ? this.toAssignable(left, false, refDestructuringErrors) : left;\n    if (!ownDestructuringErrors) {\n      refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;\n    }\n    if (refDestructuringErrors.shorthandAssign >= node.left.start)\n      { refDestructuringErrors.shorthandAssign = -1; } // reset because shorthand default was used correctly\n    this.checkLVal(left);\n    this.next();\n    node.right = this.parseMaybeAssign(noIn);\n    return this.finishNode(node, \"AssignmentExpression\")\n  } else {\n    if (ownDestructuringErrors) { this.checkExpressionErrors(refDestructuringErrors, true); }\n  }\n  if (oldParenAssign > -1) { refDestructuringErrors.parenthesizedAssign = oldParenAssign; }\n  if (oldTrailingComma > -1) { refDestructuringErrors.trailingComma = oldTrailingComma; }\n  return left\n};\n\n// Parse a ternary conditional (`?:`) operator.\n\npp$3.parseMaybeConditional = function(noIn, refDestructuringErrors) {\n  var startPos = this.start, startLoc = this.startLoc;\n  var expr = this.parseExprOps(noIn, refDestructuringErrors);\n  if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }\n  if (this.eat(types.question)) {\n    var node = this.startNodeAt(startPos, startLoc);\n    node.test = expr;\n    node.consequent = this.parseMaybeAssign();\n    this.expect(types.colon);\n    node.alternate = this.parseMaybeAssign(noIn);\n    return this.finishNode(node, \"ConditionalExpression\")\n  }\n  return expr\n};\n\n// Start the precedence parser.\n\npp$3.parseExprOps = function(noIn, refDestructuringErrors) {\n  var startPos = this.start, startLoc = this.startLoc;\n  var expr = this.parseMaybeUnary(refDestructuringErrors, false);\n  if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }\n  return expr.start === startPos && expr.type === \"ArrowFunctionExpression\" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, noIn)\n};\n\n// Parse binary operators with the operator precedence parsing\n// algorithm. `left` is the left-hand side of the operator.\n// `minPrec` provides context that allows the function to stop and\n// defer further parser to one of its callers when it encounters an\n// operator that has a lower precedence than the set it is parsing.\n\npp$3.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, noIn) {\n  var prec = this.type.binop;\n  if (prec != null && (!noIn || this.type !== types._in)) {\n    if (prec > minPrec) {\n      var logical = this.type === types.logicalOR || this.type === types.logicalAND;\n      var coalesce = this.type === types.coalesce;\n      if (coalesce) {\n        // Handle the precedence of `tt.coalesce` as equal to the range of logical expressions.\n        // In other words, `node.right` shouldn't contain logical expressions in order to check the mixed error.\n        prec = types.logicalAND.binop;\n      }\n      var op = this.value;\n      this.next();\n      var startPos = this.start, startLoc = this.startLoc;\n      var right = this.parseExprOp(this.parseMaybeUnary(null, false), startPos, startLoc, prec, noIn);\n      var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical || coalesce);\n      if ((logical && this.type === types.coalesce) || (coalesce && (this.type === types.logicalOR || this.type === types.logicalAND))) {\n        this.raiseRecoverable(this.start, \"Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses\");\n      }\n      return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn)\n    }\n  }\n  return left\n};\n\npp$3.buildBinary = function(startPos, startLoc, left, right, op, logical) {\n  var node = this.startNodeAt(startPos, startLoc);\n  node.left = left;\n  node.operator = op;\n  node.right = right;\n  return this.finishNode(node, logical ? \"LogicalExpression\" : \"BinaryExpression\")\n};\n\n// Parse unary operators, both prefix and postfix.\n\npp$3.parseMaybeUnary = function(refDestructuringErrors, sawUnary) {\n  var startPos = this.start, startLoc = this.startLoc, expr;\n  if (this.isContextual(\"await\") && (this.inAsync || (!this.inFunction && this.options.allowAwaitOutsideFunction))) {\n    expr = this.parseAwait();\n    sawUnary = true;\n  } else if (this.type.prefix) {\n    var node = this.startNode(), update = this.type === types.incDec;\n    node.operator = this.value;\n    node.prefix = true;\n    this.next();\n    node.argument = this.parseMaybeUnary(null, true);\n    this.checkExpressionErrors(refDestructuringErrors, true);\n    if (update) { this.checkLVal(node.argument); }\n    else if (this.strict && node.operator === \"delete\" &&\n             node.argument.type === \"Identifier\")\n      { this.raiseRecoverable(node.start, \"Deleting local variable in strict mode\"); }\n    else { sawUnary = true; }\n    expr = this.finishNode(node, update ? \"UpdateExpression\" : \"UnaryExpression\");\n  } else {\n    expr = this.parseExprSubscripts(refDestructuringErrors);\n    if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }\n    while (this.type.postfix && !this.canInsertSemicolon()) {\n      var node$1 = this.startNodeAt(startPos, startLoc);\n      node$1.operator = this.value;\n      node$1.prefix = false;\n      node$1.argument = expr;\n      this.checkLVal(expr);\n      this.next();\n      expr = this.finishNode(node$1, \"UpdateExpression\");\n    }\n  }\n\n  if (!sawUnary && this.eat(types.starstar))\n    { return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false), \"**\", false) }\n  else\n    { return expr }\n};\n\n// Parse call, dot, and `[]`-subscript expressions.\n\npp$3.parseExprSubscripts = function(refDestructuringErrors) {\n  var startPos = this.start, startLoc = this.startLoc;\n  var expr = this.parseExprAtom(refDestructuringErrors);\n  if (expr.type === \"ArrowFunctionExpression\" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== \")\")\n    { return expr }\n  var result = this.parseSubscripts(expr, startPos, startLoc);\n  if (refDestructuringErrors && result.type === \"MemberExpression\") {\n    if (refDestructuringErrors.parenthesizedAssign >= result.start) { refDestructuringErrors.parenthesizedAssign = -1; }\n    if (refDestructuringErrors.parenthesizedBind >= result.start) { refDestructuringErrors.parenthesizedBind = -1; }\n  }\n  return result\n};\n\npp$3.parseSubscripts = function(base, startPos, startLoc, noCalls) {\n  var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === \"Identifier\" && base.name === \"async\" &&\n      this.lastTokEnd === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 &&\n      this.potentialArrowAt === base.start;\n  var optionalChained = false;\n\n  while (true) {\n    var element = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained);\n\n    if (element.optional) { optionalChained = true; }\n    if (element === base || element.type === \"ArrowFunctionExpression\") {\n      if (optionalChained) {\n        var chainNode = this.startNodeAt(startPos, startLoc);\n        chainNode.expression = element;\n        element = this.finishNode(chainNode, \"ChainExpression\");\n      }\n      return element\n    }\n\n    base = element;\n  }\n};\n\npp$3.parseSubscript = function(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained) {\n  var optionalSupported = this.options.ecmaVersion >= 11;\n  var optional = optionalSupported && this.eat(types.questionDot);\n  if (noCalls && optional) { this.raise(this.lastTokStart, \"Optional chaining cannot appear in the callee of new expressions\"); }\n\n  var computed = this.eat(types.bracketL);\n  if (computed || (optional && this.type !== types.parenL && this.type !== types.backQuote) || this.eat(types.dot)) {\n    var node = this.startNodeAt(startPos, startLoc);\n    node.object = base;\n    node.property = computed ? this.parseExpression() : this.parseIdent(this.options.allowReserved !== \"never\");\n    node.computed = !!computed;\n    if (computed) { this.expect(types.bracketR); }\n    if (optionalSupported) {\n      node.optional = optional;\n    }\n    base = this.finishNode(node, \"MemberExpression\");\n  } else if (!noCalls && this.eat(types.parenL)) {\n    var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\n    this.yieldPos = 0;\n    this.awaitPos = 0;\n    this.awaitIdentPos = 0;\n    var exprList = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);\n    if (maybeAsyncArrow && !optional && !this.canInsertSemicolon() && this.eat(types.arrow)) {\n      this.checkPatternErrors(refDestructuringErrors, false);\n      this.checkYieldAwaitInDefaultParams();\n      if (this.awaitIdentPos > 0)\n        { this.raise(this.awaitIdentPos, \"Cannot use 'await' as identifier inside an async function\"); }\n      this.yieldPos = oldYieldPos;\n      this.awaitPos = oldAwaitPos;\n      this.awaitIdentPos = oldAwaitIdentPos;\n      return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true)\n    }\n    this.checkExpressionErrors(refDestructuringErrors, true);\n    this.yieldPos = oldYieldPos || this.yieldPos;\n    this.awaitPos = oldAwaitPos || this.awaitPos;\n    this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;\n    var node$1 = this.startNodeAt(startPos, startLoc);\n    node$1.callee = base;\n    node$1.arguments = exprList;\n    if (optionalSupported) {\n      node$1.optional = optional;\n    }\n    base = this.finishNode(node$1, \"CallExpression\");\n  } else if (this.type === types.backQuote) {\n    if (optional || optionalChained) {\n      this.raise(this.start, \"Optional chaining cannot appear in the tag of tagged template expressions\");\n    }\n    var node$2 = this.startNodeAt(startPos, startLoc);\n    node$2.tag = base;\n    node$2.quasi = this.parseTemplate({isTagged: true});\n    base = this.finishNode(node$2, \"TaggedTemplateExpression\");\n  }\n  return base\n};\n\n// Parse an atomic expression — either a single token that is an\n// expression, an expression started by a keyword like `function` or\n// `new`, or an expression wrapped in punctuation like `()`, `[]`,\n// or `{}`.\n\npp$3.parseExprAtom = function(refDestructuringErrors) {\n  // If a division operator appears in an expression position, the\n  // tokenizer got confused, and we force it to read a regexp instead.\n  if (this.type === types.slash) { this.readRegexp(); }\n\n  var node, canBeArrow = this.potentialArrowAt === this.start;\n  switch (this.type) {\n  case types._super:\n    if (!this.allowSuper)\n      { this.raise(this.start, \"'super' keyword outside a method\"); }\n    node = this.startNode();\n    this.next();\n    if (this.type === types.parenL && !this.allowDirectSuper)\n      { this.raise(node.start, \"super() call outside constructor of a subclass\"); }\n    // The `super` keyword can appear at below:\n    // SuperProperty:\n    //     super [ Expression ]\n    //     super . IdentifierName\n    // SuperCall:\n    //     super ( Arguments )\n    if (this.type !== types.dot && this.type !== types.bracketL && this.type !== types.parenL)\n      { this.unexpected(); }\n    return this.finishNode(node, \"Super\")\n\n  case types._this:\n    node = this.startNode();\n    this.next();\n    return this.finishNode(node, \"ThisExpression\")\n\n  case types.name:\n    var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;\n    var id = this.parseIdent(false);\n    if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === \"async\" && !this.canInsertSemicolon() && this.eat(types._function))\n      { return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true) }\n    if (canBeArrow && !this.canInsertSemicolon()) {\n      if (this.eat(types.arrow))\n        { return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false) }\n      if (this.options.ecmaVersion >= 8 && id.name === \"async\" && this.type === types.name && !containsEsc) {\n        id = this.parseIdent(false);\n        if (this.canInsertSemicolon() || !this.eat(types.arrow))\n          { this.unexpected(); }\n        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true)\n      }\n    }\n    return id\n\n  case types.regexp:\n    var value = this.value;\n    node = this.parseLiteral(value.value);\n    node.regex = {pattern: value.pattern, flags: value.flags};\n    return node\n\n  case types.num: case types.string:\n    return this.parseLiteral(this.value)\n\n  case types._null: case types._true: case types._false:\n    node = this.startNode();\n    node.value = this.type === types._null ? null : this.type === types._true;\n    node.raw = this.type.keyword;\n    this.next();\n    return this.finishNode(node, \"Literal\")\n\n  case types.parenL:\n    var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow);\n    if (refDestructuringErrors) {\n      if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr))\n        { refDestructuringErrors.parenthesizedAssign = start; }\n      if (refDestructuringErrors.parenthesizedBind < 0)\n        { refDestructuringErrors.parenthesizedBind = start; }\n    }\n    return expr\n\n  case types.bracketL:\n    node = this.startNode();\n    this.next();\n    node.elements = this.parseExprList(types.bracketR, true, true, refDestructuringErrors);\n    return this.finishNode(node, \"ArrayExpression\")\n\n  case types.braceL:\n    return this.parseObj(false, refDestructuringErrors)\n\n  case types._function:\n    node = this.startNode();\n    this.next();\n    return this.parseFunction(node, 0)\n\n  case types._class:\n    return this.parseClass(this.startNode(), false)\n\n  case types._new:\n    return this.parseNew()\n\n  case types.backQuote:\n    return this.parseTemplate()\n\n  case types._import:\n    if (this.options.ecmaVersion >= 11) {\n      return this.parseExprImport()\n    } else {\n      return this.unexpected()\n    }\n\n  default:\n    this.unexpected();\n  }\n};\n\npp$3.parseExprImport = function() {\n  var node = this.startNode();\n\n  // Consume `import` as an identifier for `import.meta`.\n  // Because `this.parseIdent(true)` doesn't check escape sequences, it needs the check of `this.containsEsc`.\n  if (this.containsEsc) { this.raiseRecoverable(this.start, \"Escape sequence in keyword import\"); }\n  var meta = this.parseIdent(true);\n\n  switch (this.type) {\n  case types.parenL:\n    return this.parseDynamicImport(node)\n  case types.dot:\n    node.meta = meta;\n    return this.parseImportMeta(node)\n  default:\n    this.unexpected();\n  }\n};\n\npp$3.parseDynamicImport = function(node) {\n  this.next(); // skip `(`\n\n  // Parse node.source.\n  node.source = this.parseMaybeAssign();\n\n  // Verify ending.\n  if (!this.eat(types.parenR)) {\n    var errorPos = this.start;\n    if (this.eat(types.comma) && this.eat(types.parenR)) {\n      this.raiseRecoverable(errorPos, \"Trailing comma is not allowed in import()\");\n    } else {\n      this.unexpected(errorPos);\n    }\n  }\n\n  return this.finishNode(node, \"ImportExpression\")\n};\n\npp$3.parseImportMeta = function(node) {\n  this.next(); // skip `.`\n\n  var containsEsc = this.containsEsc;\n  node.property = this.parseIdent(true);\n\n  if (node.property.name !== \"meta\")\n    { this.raiseRecoverable(node.property.start, \"The only valid meta property for import is 'import.meta'\"); }\n  if (containsEsc)\n    { this.raiseRecoverable(node.start, \"'import.meta' must not contain escaped characters\"); }\n  if (this.options.sourceType !== \"module\")\n    { this.raiseRecoverable(node.start, \"Cannot use 'import.meta' outside a module\"); }\n\n  return this.finishNode(node, \"MetaProperty\")\n};\n\npp$3.parseLiteral = function(value) {\n  var node = this.startNode();\n  node.value = value;\n  node.raw = this.input.slice(this.start, this.end);\n  if (node.raw.charCodeAt(node.raw.length - 1) === 110) { node.bigint = node.raw.slice(0, -1).replace(/_/g, \"\"); }\n  this.next();\n  return this.finishNode(node, \"Literal\")\n};\n\npp$3.parseParenExpression = function() {\n  this.expect(types.parenL);\n  var val = this.parseExpression();\n  this.expect(types.parenR);\n  return val\n};\n\npp$3.parseParenAndDistinguishExpression = function(canBeArrow) {\n  var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;\n  if (this.options.ecmaVersion >= 6) {\n    this.next();\n\n    var innerStartPos = this.start, innerStartLoc = this.startLoc;\n    var exprList = [], first = true, lastIsComma = false;\n    var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;\n    this.yieldPos = 0;\n    this.awaitPos = 0;\n    // Do not save awaitIdentPos to allow checking awaits nested in parameters\n    while (this.type !== types.parenR) {\n      first ? first = false : this.expect(types.comma);\n      if (allowTrailingComma && this.afterTrailingComma(types.parenR, true)) {\n        lastIsComma = true;\n        break\n      } else if (this.type === types.ellipsis) {\n        spreadStart = this.start;\n        exprList.push(this.parseParenItem(this.parseRestBinding()));\n        if (this.type === types.comma) { this.raise(this.start, \"Comma is not permitted after the rest element\"); }\n        break\n      } else {\n        exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));\n      }\n    }\n    var innerEndPos = this.start, innerEndLoc = this.startLoc;\n    this.expect(types.parenR);\n\n    if (canBeArrow && !this.canInsertSemicolon() && this.eat(types.arrow)) {\n      this.checkPatternErrors(refDestructuringErrors, false);\n      this.checkYieldAwaitInDefaultParams();\n      this.yieldPos = oldYieldPos;\n      this.awaitPos = oldAwaitPos;\n      return this.parseParenArrowList(startPos, startLoc, exprList)\n    }\n\n    if (!exprList.length || lastIsComma) { this.unexpected(this.lastTokStart); }\n    if (spreadStart) { this.unexpected(spreadStart); }\n    this.checkExpressionErrors(refDestructuringErrors, true);\n    this.yieldPos = oldYieldPos || this.yieldPos;\n    this.awaitPos = oldAwaitPos || this.awaitPos;\n\n    if (exprList.length > 1) {\n      val = this.startNodeAt(innerStartPos, innerStartLoc);\n      val.expressions = exprList;\n      this.finishNodeAt(val, \"SequenceExpression\", innerEndPos, innerEndLoc);\n    } else {\n      val = exprList[0];\n    }\n  } else {\n    val = this.parseParenExpression();\n  }\n\n  if (this.options.preserveParens) {\n    var par = this.startNodeAt(startPos, startLoc);\n    par.expression = val;\n    return this.finishNode(par, \"ParenthesizedExpression\")\n  } else {\n    return val\n  }\n};\n\npp$3.parseParenItem = function(item) {\n  return item\n};\n\npp$3.parseParenArrowList = function(startPos, startLoc, exprList) {\n  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList)\n};\n\n// New's precedence is slightly tricky. It must allow its argument to\n// be a `[]` or dot subscript expression, but not a call — at least,\n// not without wrapping it in parentheses. Thus, it uses the noCalls\n// argument to parseSubscripts to prevent it from consuming the\n// argument list.\n\nvar empty$1 = [];\n\npp$3.parseNew = function() {\n  if (this.containsEsc) { this.raiseRecoverable(this.start, \"Escape sequence in keyword new\"); }\n  var node = this.startNode();\n  var meta = this.parseIdent(true);\n  if (this.options.ecmaVersion >= 6 && this.eat(types.dot)) {\n    node.meta = meta;\n    var containsEsc = this.containsEsc;\n    node.property = this.parseIdent(true);\n    if (node.property.name !== \"target\")\n      { this.raiseRecoverable(node.property.start, \"The only valid meta property for new is 'new.target'\"); }\n    if (containsEsc)\n      { this.raiseRecoverable(node.start, \"'new.target' must not contain escaped characters\"); }\n    if (!this.inNonArrowFunction())\n      { this.raiseRecoverable(node.start, \"'new.target' can only be used in functions\"); }\n    return this.finishNode(node, \"MetaProperty\")\n  }\n  var startPos = this.start, startLoc = this.startLoc, isImport = this.type === types._import;\n  node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);\n  if (isImport && node.callee.type === \"ImportExpression\") {\n    this.raise(startPos, \"Cannot use new with import()\");\n  }\n  if (this.eat(types.parenL)) { node.arguments = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8, false); }\n  else { node.arguments = empty$1; }\n  return this.finishNode(node, \"NewExpression\")\n};\n\n// Parse template expression.\n\npp$3.parseTemplateElement = function(ref) {\n  var isTagged = ref.isTagged;\n\n  var elem = this.startNode();\n  if (this.type === types.invalidTemplate) {\n    if (!isTagged) {\n      this.raiseRecoverable(this.start, \"Bad escape sequence in untagged template literal\");\n    }\n    elem.value = {\n      raw: this.value,\n      cooked: null\n    };\n  } else {\n    elem.value = {\n      raw: this.input.slice(this.start, this.end).replace(/\\r\\n?/g, \"\\n\"),\n      cooked: this.value\n    };\n  }\n  this.next();\n  elem.tail = this.type === types.backQuote;\n  return this.finishNode(elem, \"TemplateElement\")\n};\n\npp$3.parseTemplate = function(ref) {\n  if ( ref === void 0 ) ref = {};\n  var isTagged = ref.isTagged; if ( isTagged === void 0 ) isTagged = false;\n\n  var node = this.startNode();\n  this.next();\n  node.expressions = [];\n  var curElt = this.parseTemplateElement({isTagged: isTagged});\n  node.quasis = [curElt];\n  while (!curElt.tail) {\n    if (this.type === types.eof) { this.raise(this.pos, \"Unterminated template literal\"); }\n    this.expect(types.dollarBraceL);\n    node.expressions.push(this.parseExpression());\n    this.expect(types.braceR);\n    node.quasis.push(curElt = this.parseTemplateElement({isTagged: isTagged}));\n  }\n  this.next();\n  return this.finishNode(node, \"TemplateLiteral\")\n};\n\npp$3.isAsyncProp = function(prop) {\n  return !prop.computed && prop.key.type === \"Identifier\" && prop.key.name === \"async\" &&\n    (this.type === types.name || this.type === types.num || this.type === types.string || this.type === types.bracketL || this.type.keyword || (this.options.ecmaVersion >= 9 && this.type === types.star)) &&\n    !lineBreak.test(this.input.slice(this.lastTokEnd, this.start))\n};\n\n// Parse an object literal or binding pattern.\n\npp$3.parseObj = function(isPattern, refDestructuringErrors) {\n  var node = this.startNode(), first = true, propHash = {};\n  node.properties = [];\n  this.next();\n  while (!this.eat(types.braceR)) {\n    if (!first) {\n      this.expect(types.comma);\n      if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types.braceR)) { break }\n    } else { first = false; }\n\n    var prop = this.parseProperty(isPattern, refDestructuringErrors);\n    if (!isPattern) { this.checkPropClash(prop, propHash, refDestructuringErrors); }\n    node.properties.push(prop);\n  }\n  return this.finishNode(node, isPattern ? \"ObjectPattern\" : \"ObjectExpression\")\n};\n\npp$3.parseProperty = function(isPattern, refDestructuringErrors) {\n  var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;\n  if (this.options.ecmaVersion >= 9 && this.eat(types.ellipsis)) {\n    if (isPattern) {\n      prop.argument = this.parseIdent(false);\n      if (this.type === types.comma) {\n        this.raise(this.start, \"Comma is not permitted after the rest element\");\n      }\n      return this.finishNode(prop, \"RestElement\")\n    }\n    // To disallow parenthesized identifier via `this.toAssignable()`.\n    if (this.type === types.parenL && refDestructuringErrors) {\n      if (refDestructuringErrors.parenthesizedAssign < 0) {\n        refDestructuringErrors.parenthesizedAssign = this.start;\n      }\n      if (refDestructuringErrors.parenthesizedBind < 0) {\n        refDestructuringErrors.parenthesizedBind = this.start;\n      }\n    }\n    // Parse argument.\n    prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);\n    // To disallow trailing comma via `this.toAssignable()`.\n    if (this.type === types.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {\n      refDestructuringErrors.trailingComma = this.start;\n    }\n    // Finish\n    return this.finishNode(prop, \"SpreadElement\")\n  }\n  if (this.options.ecmaVersion >= 6) {\n    prop.method = false;\n    prop.shorthand = false;\n    if (isPattern || refDestructuringErrors) {\n      startPos = this.start;\n      startLoc = this.startLoc;\n    }\n    if (!isPattern)\n      { isGenerator = this.eat(types.star); }\n  }\n  var containsEsc = this.containsEsc;\n  this.parsePropertyName(prop);\n  if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {\n    isAsync = true;\n    isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);\n    this.parsePropertyName(prop, refDestructuringErrors);\n  } else {\n    isAsync = false;\n  }\n  this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);\n  return this.finishNode(prop, \"Property\")\n};\n\npp$3.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {\n  if ((isGenerator || isAsync) && this.type === types.colon)\n    { this.unexpected(); }\n\n  if (this.eat(types.colon)) {\n    prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);\n    prop.kind = \"init\";\n  } else if (this.options.ecmaVersion >= 6 && this.type === types.parenL) {\n    if (isPattern) { this.unexpected(); }\n    prop.kind = \"init\";\n    prop.method = true;\n    prop.value = this.parseMethod(isGenerator, isAsync);\n  } else if (!isPattern && !containsEsc &&\n             this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === \"Identifier\" &&\n             (prop.key.name === \"get\" || prop.key.name === \"set\") &&\n             (this.type !== types.comma && this.type !== types.braceR && this.type !== types.eq)) {\n    if (isGenerator || isAsync) { this.unexpected(); }\n    prop.kind = prop.key.name;\n    this.parsePropertyName(prop);\n    prop.value = this.parseMethod(false);\n    var paramCount = prop.kind === \"get\" ? 0 : 1;\n    if (prop.value.params.length !== paramCount) {\n      var start = prop.value.start;\n      if (prop.kind === \"get\")\n        { this.raiseRecoverable(start, \"getter should have no params\"); }\n      else\n        { this.raiseRecoverable(start, \"setter should have exactly one param\"); }\n    } else {\n      if (prop.kind === \"set\" && prop.value.params[0].type === \"RestElement\")\n        { this.raiseRecoverable(prop.value.params[0].start, \"Setter cannot use rest params\"); }\n    }\n  } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === \"Identifier\") {\n    if (isGenerator || isAsync) { this.unexpected(); }\n    this.checkUnreserved(prop.key);\n    if (prop.key.name === \"await\" && !this.awaitIdentPos)\n      { this.awaitIdentPos = startPos; }\n    prop.kind = \"init\";\n    if (isPattern) {\n      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);\n    } else if (this.type === types.eq && refDestructuringErrors) {\n      if (refDestructuringErrors.shorthandAssign < 0)\n        { refDestructuringErrors.shorthandAssign = this.start; }\n      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);\n    } else {\n      prop.value = prop.key;\n    }\n    prop.shorthand = true;\n  } else { this.unexpected(); }\n};\n\npp$3.parsePropertyName = function(prop) {\n  if (this.options.ecmaVersion >= 6) {\n    if (this.eat(types.bracketL)) {\n      prop.computed = true;\n      prop.key = this.parseMaybeAssign();\n      this.expect(types.bracketR);\n      return prop.key\n    } else {\n      prop.computed = false;\n    }\n  }\n  return prop.key = this.type === types.num || this.type === types.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== \"never\")\n};\n\n// Initialize empty function node.\n\npp$3.initFunction = function(node) {\n  node.id = null;\n  if (this.options.ecmaVersion >= 6) { node.generator = node.expression = false; }\n  if (this.options.ecmaVersion >= 8) { node.async = false; }\n};\n\n// Parse object or class method.\n\npp$3.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {\n  var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\n\n  this.initFunction(node);\n  if (this.options.ecmaVersion >= 6)\n    { node.generator = isGenerator; }\n  if (this.options.ecmaVersion >= 8)\n    { node.async = !!isAsync; }\n\n  this.yieldPos = 0;\n  this.awaitPos = 0;\n  this.awaitIdentPos = 0;\n  this.enterScope(functionFlags(isAsync, node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));\n\n  this.expect(types.parenL);\n  node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);\n  this.checkYieldAwaitInDefaultParams();\n  this.parseFunctionBody(node, false, true);\n\n  this.yieldPos = oldYieldPos;\n  this.awaitPos = oldAwaitPos;\n  this.awaitIdentPos = oldAwaitIdentPos;\n  return this.finishNode(node, \"FunctionExpression\")\n};\n\n// Parse arrow function expression with given parameters.\n\npp$3.parseArrowExpression = function(node, params, isAsync) {\n  var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\n\n  this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);\n  this.initFunction(node);\n  if (this.options.ecmaVersion >= 8) { node.async = !!isAsync; }\n\n  this.yieldPos = 0;\n  this.awaitPos = 0;\n  this.awaitIdentPos = 0;\n\n  node.params = this.toAssignableList(params, true);\n  this.parseFunctionBody(node, true, false);\n\n  this.yieldPos = oldYieldPos;\n  this.awaitPos = oldAwaitPos;\n  this.awaitIdentPos = oldAwaitIdentPos;\n  return this.finishNode(node, \"ArrowFunctionExpression\")\n};\n\n// Parse function body and check parameters.\n\npp$3.parseFunctionBody = function(node, isArrowFunction, isMethod) {\n  var isExpression = isArrowFunction && this.type !== types.braceL;\n  var oldStrict = this.strict, useStrict = false;\n\n  if (isExpression) {\n    node.body = this.parseMaybeAssign();\n    node.expression = true;\n    this.checkParams(node, false);\n  } else {\n    var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);\n    if (!oldStrict || nonSimple) {\n      useStrict = this.strictDirective(this.end);\n      // If this is a strict mode function, verify that argument names\n      // are not repeated, and it does not try to bind the words `eval`\n      // or `arguments`.\n      if (useStrict && nonSimple)\n        { this.raiseRecoverable(node.start, \"Illegal 'use strict' directive in function with non-simple parameter list\"); }\n    }\n    // Start a new scope with regard to labels and the `inFunction`\n    // flag (restore them to their old value afterwards).\n    var oldLabels = this.labels;\n    this.labels = [];\n    if (useStrict) { this.strict = true; }\n\n    // Add the params to varDeclaredNames to ensure that an error is thrown\n    // if a let/const declaration in the function clashes with one of the params.\n    this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node.params));\n    // Ensure the function name isn't a forbidden identifier in strict mode, e.g. 'eval'\n    if (this.strict && node.id) { this.checkLVal(node.id, BIND_OUTSIDE); }\n    node.body = this.parseBlock(false, undefined, useStrict && !oldStrict);\n    node.expression = false;\n    this.adaptDirectivePrologue(node.body.body);\n    this.labels = oldLabels;\n  }\n  this.exitScope();\n};\n\npp$3.isSimpleParamList = function(params) {\n  for (var i = 0, list = params; i < list.length; i += 1)\n    {\n    var param = list[i];\n\n    if (param.type !== \"Identifier\") { return false\n  } }\n  return true\n};\n\n// Checks function params for various disallowed patterns such as using \"eval\"\n// or \"arguments\" and duplicate parameters.\n\npp$3.checkParams = function(node, allowDuplicates) {\n  var nameHash = {};\n  for (var i = 0, list = node.params; i < list.length; i += 1)\n    {\n    var param = list[i];\n\n    this.checkLVal(param, BIND_VAR, allowDuplicates ? null : nameHash);\n  }\n};\n\n// Parses a comma-separated list of expressions, and returns them as\n// an array. `close` is the token type that ends the list, and\n// `allowEmpty` can be turned on to allow subsequent commas with\n// nothing in between them to be parsed as `null` (which is needed\n// for array literals).\n\npp$3.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {\n  var elts = [], first = true;\n  while (!this.eat(close)) {\n    if (!first) {\n      this.expect(types.comma);\n      if (allowTrailingComma && this.afterTrailingComma(close)) { break }\n    } else { first = false; }\n\n    var elt = (void 0);\n    if (allowEmpty && this.type === types.comma)\n      { elt = null; }\n    else if (this.type === types.ellipsis) {\n      elt = this.parseSpread(refDestructuringErrors);\n      if (refDestructuringErrors && this.type === types.comma && refDestructuringErrors.trailingComma < 0)\n        { refDestructuringErrors.trailingComma = this.start; }\n    } else {\n      elt = this.parseMaybeAssign(false, refDestructuringErrors);\n    }\n    elts.push(elt);\n  }\n  return elts\n};\n\npp$3.checkUnreserved = function(ref) {\n  var start = ref.start;\n  var end = ref.end;\n  var name = ref.name;\n\n  if (this.inGenerator && name === \"yield\")\n    { this.raiseRecoverable(start, \"Cannot use 'yield' as identifier inside a generator\"); }\n  if (this.inAsync && name === \"await\")\n    { this.raiseRecoverable(start, \"Cannot use 'await' as identifier inside an async function\"); }\n  if (this.keywords.test(name))\n    { this.raise(start, (\"Unexpected keyword '\" + name + \"'\")); }\n  if (this.options.ecmaVersion < 6 &&\n    this.input.slice(start, end).indexOf(\"\\\\\") !== -1) { return }\n  var re = this.strict ? this.reservedWordsStrict : this.reservedWords;\n  if (re.test(name)) {\n    if (!this.inAsync && name === \"await\")\n      { this.raiseRecoverable(start, \"Cannot use keyword 'await' outside an async function\"); }\n    this.raiseRecoverable(start, (\"The keyword '\" + name + \"' is reserved\"));\n  }\n};\n\n// Parse the next token as an identifier. If `liberal` is true (used\n// when parsing properties), it will also convert keywords into\n// identifiers.\n\npp$3.parseIdent = function(liberal, isBinding) {\n  var node = this.startNode();\n  if (this.type === types.name) {\n    node.name = this.value;\n  } else if (this.type.keyword) {\n    node.name = this.type.keyword;\n\n    // To fix https://github.com/acornjs/acorn/issues/575\n    // `class` and `function` keywords push new context into this.context.\n    // But there is no chance to pop the context if the keyword is consumed as an identifier such as a property name.\n    // If the previous token is a dot, this does not apply because the context-managing code already ignored the keyword\n    if ((node.name === \"class\" || node.name === \"function\") &&\n        (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {\n      this.context.pop();\n    }\n  } else {\n    this.unexpected();\n  }\n  this.next(!!liberal);\n  this.finishNode(node, \"Identifier\");\n  if (!liberal) {\n    this.checkUnreserved(node);\n    if (node.name === \"await\" && !this.awaitIdentPos)\n      { this.awaitIdentPos = node.start; }\n  }\n  return node\n};\n\n// Parses yield expression inside generator.\n\npp$3.parseYield = function(noIn) {\n  if (!this.yieldPos) { this.yieldPos = this.start; }\n\n  var node = this.startNode();\n  this.next();\n  if (this.type === types.semi || this.canInsertSemicolon() || (this.type !== types.star && !this.type.startsExpr)) {\n    node.delegate = false;\n    node.argument = null;\n  } else {\n    node.delegate = this.eat(types.star);\n    node.argument = this.parseMaybeAssign(noIn);\n  }\n  return this.finishNode(node, \"YieldExpression\")\n};\n\npp$3.parseAwait = function() {\n  if (!this.awaitPos) { this.awaitPos = this.start; }\n\n  var node = this.startNode();\n  this.next();\n  node.argument = this.parseMaybeUnary(null, false);\n  return this.finishNode(node, \"AwaitExpression\")\n};\n\nvar pp$4 = Parser.prototype;\n\n// This function is used to raise exceptions on parse errors. It\n// takes an offset integer (into the current `input`) to indicate\n// the location of the error, attaches the position to the end\n// of the error message, and then raises a `SyntaxError` with that\n// message.\n\npp$4.raise = function(pos, message) {\n  var loc = getLineInfo(this.input, pos);\n  message += \" (\" + loc.line + \":\" + loc.column + \")\";\n  var err = new SyntaxError(message);\n  err.pos = pos; err.loc = loc; err.raisedAt = this.pos;\n  throw err\n};\n\npp$4.raiseRecoverable = pp$4.raise;\n\npp$4.curPosition = function() {\n  if (this.options.locations) {\n    return new Position(this.curLine, this.pos - this.lineStart)\n  }\n};\n\nvar pp$5 = Parser.prototype;\n\nvar Scope = function Scope(flags) {\n  this.flags = flags;\n  // A list of var-declared names in the current lexical scope\n  this.var = [];\n  // A list of lexically-declared names in the current lexical scope\n  this.lexical = [];\n  // A list of lexically-declared FunctionDeclaration names in the current lexical scope\n  this.functions = [];\n};\n\n// The functions in this module keep track of declared variables in the current scope in order to detect duplicate variable names.\n\npp$5.enterScope = function(flags) {\n  this.scopeStack.push(new Scope(flags));\n};\n\npp$5.exitScope = function() {\n  this.scopeStack.pop();\n};\n\n// The spec says:\n// > At the top level of a function, or script, function declarations are\n// > treated like var declarations rather than like lexical declarations.\npp$5.treatFunctionsAsVarInScope = function(scope) {\n  return (scope.flags & SCOPE_FUNCTION) || !this.inModule && (scope.flags & SCOPE_TOP)\n};\n\npp$5.declareName = function(name, bindingType, pos) {\n  var redeclared = false;\n  if (bindingType === BIND_LEXICAL) {\n    var scope = this.currentScope();\n    redeclared = scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;\n    scope.lexical.push(name);\n    if (this.inModule && (scope.flags & SCOPE_TOP))\n      { delete this.undefinedExports[name]; }\n  } else if (bindingType === BIND_SIMPLE_CATCH) {\n    var scope$1 = this.currentScope();\n    scope$1.lexical.push(name);\n  } else if (bindingType === BIND_FUNCTION) {\n    var scope$2 = this.currentScope();\n    if (this.treatFunctionsAsVar)\n      { redeclared = scope$2.lexical.indexOf(name) > -1; }\n    else\n      { redeclared = scope$2.lexical.indexOf(name) > -1 || scope$2.var.indexOf(name) > -1; }\n    scope$2.functions.push(name);\n  } else {\n    for (var i = this.scopeStack.length - 1; i >= 0; --i) {\n      var scope$3 = this.scopeStack[i];\n      if (scope$3.lexical.indexOf(name) > -1 && !((scope$3.flags & SCOPE_SIMPLE_CATCH) && scope$3.lexical[0] === name) ||\n          !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {\n        redeclared = true;\n        break\n      }\n      scope$3.var.push(name);\n      if (this.inModule && (scope$3.flags & SCOPE_TOP))\n        { delete this.undefinedExports[name]; }\n      if (scope$3.flags & SCOPE_VAR) { break }\n    }\n  }\n  if (redeclared) { this.raiseRecoverable(pos, (\"Identifier '\" + name + \"' has already been declared\")); }\n};\n\npp$5.checkLocalExport = function(id) {\n  // scope.functions must be empty as Module code is always strict.\n  if (this.scopeStack[0].lexical.indexOf(id.name) === -1 &&\n      this.scopeStack[0].var.indexOf(id.name) === -1) {\n    this.undefinedExports[id.name] = id;\n  }\n};\n\npp$5.currentScope = function() {\n  return this.scopeStack[this.scopeStack.length - 1]\n};\n\npp$5.currentVarScope = function() {\n  for (var i = this.scopeStack.length - 1;; i--) {\n    var scope = this.scopeStack[i];\n    if (scope.flags & SCOPE_VAR) { return scope }\n  }\n};\n\n// Could be useful for `this`, `new.target`, `super()`, `super.property`, and `super[property]`.\npp$5.currentThisScope = function() {\n  for (var i = this.scopeStack.length - 1;; i--) {\n    var scope = this.scopeStack[i];\n    if (scope.flags & SCOPE_VAR && !(scope.flags & SCOPE_ARROW)) { return scope }\n  }\n};\n\nvar Node = function Node(parser, pos, loc) {\n  this.type = \"\";\n  this.start = pos;\n  this.end = 0;\n  if (parser.options.locations)\n    { this.loc = new SourceLocation(parser, loc); }\n  if (parser.options.directSourceFile)\n    { this.sourceFile = parser.options.directSourceFile; }\n  if (parser.options.ranges)\n    { this.range = [pos, 0]; }\n};\n\n// Start an AST node, attaching a start offset.\n\nvar pp$6 = Parser.prototype;\n\npp$6.startNode = function() {\n  return new Node(this, this.start, this.startLoc)\n};\n\npp$6.startNodeAt = function(pos, loc) {\n  return new Node(this, pos, loc)\n};\n\n// Finish an AST node, adding `type` and `end` properties.\n\nfunction finishNodeAt(node, type, pos, loc) {\n  node.type = type;\n  node.end = pos;\n  if (this.options.locations)\n    { node.loc.end = loc; }\n  if (this.options.ranges)\n    { node.range[1] = pos; }\n  return node\n}\n\npp$6.finishNode = function(node, type) {\n  return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc)\n};\n\n// Finish node at given position\n\npp$6.finishNodeAt = function(node, type, pos, loc) {\n  return finishNodeAt.call(this, node, type, pos, loc)\n};\n\n// The algorithm used to determine whether a regexp can appear at a\n\nvar TokContext = function TokContext(token, isExpr, preserveSpace, override, generator) {\n  this.token = token;\n  this.isExpr = !!isExpr;\n  this.preserveSpace = !!preserveSpace;\n  this.override = override;\n  this.generator = !!generator;\n};\n\nvar types$1 = {\n  b_stat: new TokContext(\"{\", false),\n  b_expr: new TokContext(\"{\", true),\n  b_tmpl: new TokContext(\"${\", false),\n  p_stat: new TokContext(\"(\", false),\n  p_expr: new TokContext(\"(\", true),\n  q_tmpl: new TokContext(\"`\", true, true, function (p) { return p.tryReadTemplateToken(); }),\n  f_stat: new TokContext(\"function\", false),\n  f_expr: new TokContext(\"function\", true),\n  f_expr_gen: new TokContext(\"function\", true, false, null, true),\n  f_gen: new TokContext(\"function\", false, false, null, true)\n};\n\nvar pp$7 = Parser.prototype;\n\npp$7.initialContext = function() {\n  return [types$1.b_stat]\n};\n\npp$7.braceIsBlock = function(prevType) {\n  var parent = this.curContext();\n  if (parent === types$1.f_expr || parent === types$1.f_stat)\n    { return true }\n  if (prevType === types.colon && (parent === types$1.b_stat || parent === types$1.b_expr))\n    { return !parent.isExpr }\n\n  // The check for `tt.name && exprAllowed` detects whether we are\n  // after a `yield` or `of` construct. See the `updateContext` for\n  // `tt.name`.\n  if (prevType === types._return || prevType === types.name && this.exprAllowed)\n    { return lineBreak.test(this.input.slice(this.lastTokEnd, this.start)) }\n  if (prevType === types._else || prevType === types.semi || prevType === types.eof || prevType === types.parenR || prevType === types.arrow)\n    { return true }\n  if (prevType === types.braceL)\n    { return parent === types$1.b_stat }\n  if (prevType === types._var || prevType === types._const || prevType === types.name)\n    { return false }\n  return !this.exprAllowed\n};\n\npp$7.inGeneratorContext = function() {\n  for (var i = this.context.length - 1; i >= 1; i--) {\n    var context = this.context[i];\n    if (context.token === \"function\")\n      { return context.generator }\n  }\n  return false\n};\n\npp$7.updateContext = function(prevType) {\n  var update, type = this.type;\n  if (type.keyword && prevType === types.dot)\n    { this.exprAllowed = false; }\n  else if (update = type.updateContext)\n    { update.call(this, prevType); }\n  else\n    { this.exprAllowed = type.beforeExpr; }\n};\n\n// Token-specific context update code\n\ntypes.parenR.updateContext = types.braceR.updateContext = function() {\n  if (this.context.length === 1) {\n    this.exprAllowed = true;\n    return\n  }\n  var out = this.context.pop();\n  if (out === types$1.b_stat && this.curContext().token === \"function\") {\n    out = this.context.pop();\n  }\n  this.exprAllowed = !out.isExpr;\n};\n\ntypes.braceL.updateContext = function(prevType) {\n  this.context.push(this.braceIsBlock(prevType) ? types$1.b_stat : types$1.b_expr);\n  this.exprAllowed = true;\n};\n\ntypes.dollarBraceL.updateContext = function() {\n  this.context.push(types$1.b_tmpl);\n  this.exprAllowed = true;\n};\n\ntypes.parenL.updateContext = function(prevType) {\n  var statementParens = prevType === types._if || prevType === types._for || prevType === types._with || prevType === types._while;\n  this.context.push(statementParens ? types$1.p_stat : types$1.p_expr);\n  this.exprAllowed = true;\n};\n\ntypes.incDec.updateContext = function() {\n  // tokExprAllowed stays unchanged\n};\n\ntypes._function.updateContext = types._class.updateContext = function(prevType) {\n  if (prevType.beforeExpr && prevType !== types.semi && prevType !== types._else &&\n      !(prevType === types._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) &&\n      !((prevType === types.colon || prevType === types.braceL) && this.curContext() === types$1.b_stat))\n    { this.context.push(types$1.f_expr); }\n  else\n    { this.context.push(types$1.f_stat); }\n  this.exprAllowed = false;\n};\n\ntypes.backQuote.updateContext = function() {\n  if (this.curContext() === types$1.q_tmpl)\n    { this.context.pop(); }\n  else\n    { this.context.push(types$1.q_tmpl); }\n  this.exprAllowed = false;\n};\n\ntypes.star.updateContext = function(prevType) {\n  if (prevType === types._function) {\n    var index = this.context.length - 1;\n    if (this.context[index] === types$1.f_expr)\n      { this.context[index] = types$1.f_expr_gen; }\n    else\n      { this.context[index] = types$1.f_gen; }\n  }\n  this.exprAllowed = true;\n};\n\ntypes.name.updateContext = function(prevType) {\n  var allowed = false;\n  if (this.options.ecmaVersion >= 6 && prevType !== types.dot) {\n    if (this.value === \"of\" && !this.exprAllowed ||\n        this.value === \"yield\" && this.inGeneratorContext())\n      { allowed = true; }\n  }\n  this.exprAllowed = allowed;\n};\n\n// This file contains Unicode properties extracted from the ECMAScript\n// specification. The lists are extracted like so:\n// $$('#table-binary-unicode-properties > figure > table > tbody > tr > td:nth-child(1) code').map(el => el.innerText)\n\n// #table-binary-unicode-properties\nvar ecma9BinaryProperties = \"ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS\";\nvar ecma10BinaryProperties = ecma9BinaryProperties + \" Extended_Pictographic\";\nvar ecma11BinaryProperties = ecma10BinaryProperties;\nvar unicodeBinaryProperties = {\n  9: ecma9BinaryProperties,\n  10: ecma10BinaryProperties,\n  11: ecma11BinaryProperties\n};\n\n// #table-unicode-general-category-values\nvar unicodeGeneralCategoryValues = \"Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu\";\n\n// #table-unicode-script-values\nvar ecma9ScriptValues = \"Adlam Adlm Ahom Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb\";\nvar ecma10ScriptValues = ecma9ScriptValues + \" Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd\";\nvar ecma11ScriptValues = ecma10ScriptValues + \" Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho\";\nvar unicodeScriptValues = {\n  9: ecma9ScriptValues,\n  10: ecma10ScriptValues,\n  11: ecma11ScriptValues\n};\n\nvar data = {};\nfunction buildUnicodeData(ecmaVersion) {\n  var d = data[ecmaVersion] = {\n    binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion] + \" \" + unicodeGeneralCategoryValues),\n    nonBinary: {\n      General_Category: wordsRegexp(unicodeGeneralCategoryValues),\n      Script: wordsRegexp(unicodeScriptValues[ecmaVersion])\n    }\n  };\n  d.nonBinary.Script_Extensions = d.nonBinary.Script;\n\n  d.nonBinary.gc = d.nonBinary.General_Category;\n  d.nonBinary.sc = d.nonBinary.Script;\n  d.nonBinary.scx = d.nonBinary.Script_Extensions;\n}\nbuildUnicodeData(9);\nbuildUnicodeData(10);\nbuildUnicodeData(11);\n\nvar pp$8 = Parser.prototype;\n\nvar RegExpValidationState = function RegExpValidationState(parser) {\n  this.parser = parser;\n  this.validFlags = \"gim\" + (parser.options.ecmaVersion >= 6 ? \"uy\" : \"\") + (parser.options.ecmaVersion >= 9 ? \"s\" : \"\");\n  this.unicodeProperties = data[parser.options.ecmaVersion >= 11 ? 11 : parser.options.ecmaVersion];\n  this.source = \"\";\n  this.flags = \"\";\n  this.start = 0;\n  this.switchU = false;\n  this.switchN = false;\n  this.pos = 0;\n  this.lastIntValue = 0;\n  this.lastStringValue = \"\";\n  this.lastAssertionIsQuantifiable = false;\n  this.numCapturingParens = 0;\n  this.maxBackReference = 0;\n  this.groupNames = [];\n  this.backReferenceNames = [];\n};\n\nRegExpValidationState.prototype.reset = function reset (start, pattern, flags) {\n  var unicode = flags.indexOf(\"u\") !== -1;\n  this.start = start | 0;\n  this.source = pattern + \"\";\n  this.flags = flags;\n  this.switchU = unicode && this.parser.options.ecmaVersion >= 6;\n  this.switchN = unicode && this.parser.options.ecmaVersion >= 9;\n};\n\nRegExpValidationState.prototype.raise = function raise (message) {\n  this.parser.raiseRecoverable(this.start, (\"Invalid regular expression: /\" + (this.source) + \"/: \" + message));\n};\n\n// If u flag is given, this returns the code point at the index (it combines a surrogate pair).\n// Otherwise, this returns the code unit of the index (can be a part of a surrogate pair).\nRegExpValidationState.prototype.at = function at (i, forceU) {\n    if ( forceU === void 0 ) forceU = false;\n\n  var s = this.source;\n  var l = s.length;\n  if (i >= l) {\n    return -1\n  }\n  var c = s.charCodeAt(i);\n  if (!(forceU || this.switchU) || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l) {\n    return c\n  }\n  var next = s.charCodeAt(i + 1);\n  return next >= 0xDC00 && next <= 0xDFFF ? (c << 10) + next - 0x35FDC00 : c\n};\n\nRegExpValidationState.prototype.nextIndex = function nextIndex (i, forceU) {\n    if ( forceU === void 0 ) forceU = false;\n\n  var s = this.source;\n  var l = s.length;\n  if (i >= l) {\n    return l\n  }\n  var c = s.charCodeAt(i), next;\n  if (!(forceU || this.switchU) || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l ||\n      (next = s.charCodeAt(i + 1)) < 0xDC00 || next > 0xDFFF) {\n    return i + 1\n  }\n  return i + 2\n};\n\nRegExpValidationState.prototype.current = function current (forceU) {\n    if ( forceU === void 0 ) forceU = false;\n\n  return this.at(this.pos, forceU)\n};\n\nRegExpValidationState.prototype.lookahead = function lookahead (forceU) {\n    if ( forceU === void 0 ) forceU = false;\n\n  return this.at(this.nextIndex(this.pos, forceU), forceU)\n};\n\nRegExpValidationState.prototype.advance = function advance (forceU) {\n    if ( forceU === void 0 ) forceU = false;\n\n  this.pos = this.nextIndex(this.pos, forceU);\n};\n\nRegExpValidationState.prototype.eat = function eat (ch, forceU) {\n    if ( forceU === void 0 ) forceU = false;\n\n  if (this.current(forceU) === ch) {\n    this.advance(forceU);\n    return true\n  }\n  return false\n};\n\nfunction codePointToString(ch) {\n  if (ch <= 0xFFFF) { return String.fromCharCode(ch) }\n  ch -= 0x10000;\n  return String.fromCharCode((ch >> 10) + 0xD800, (ch & 0x03FF) + 0xDC00)\n}\n\n/**\n * Validate the flags part of a given RegExpLiteral.\n *\n * @param {RegExpValidationState} state The state to validate RegExp.\n * @returns {void}\n */\npp$8.validateRegExpFlags = function(state) {\n  var validFlags = state.validFlags;\n  var flags = state.flags;\n\n  for (var i = 0; i < flags.length; i++) {\n    var flag = flags.charAt(i);\n    if (validFlags.indexOf(flag) === -1) {\n      this.raise(state.start, \"Invalid regular expression flag\");\n    }\n    if (flags.indexOf(flag, i + 1) > -1) {\n      this.raise(state.start, \"Duplicate regular expression flag\");\n    }\n  }\n};\n\n/**\n * Validate the pattern part of a given RegExpLiteral.\n *\n * @param {RegExpValidationState} state The state to validate RegExp.\n * @returns {void}\n */\npp$8.validateRegExpPattern = function(state) {\n  this.regexp_pattern(state);\n\n  // The goal symbol for the parse is |Pattern[~U, ~N]|. If the result of\n  // parsing contains a |GroupName|, reparse with the goal symbol\n  // |Pattern[~U, +N]| and use this result instead. Throw a *SyntaxError*\n  // exception if _P_ did not conform to the grammar, if any elements of _P_\n  // were not matched by the parse, or if any Early Error conditions exist.\n  if (!state.switchN && this.options.ecmaVersion >= 9 && state.groupNames.length > 0) {\n    state.switchN = true;\n    this.regexp_pattern(state);\n  }\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-Pattern\npp$8.regexp_pattern = function(state) {\n  state.pos = 0;\n  state.lastIntValue = 0;\n  state.lastStringValue = \"\";\n  state.lastAssertionIsQuantifiable = false;\n  state.numCapturingParens = 0;\n  state.maxBackReference = 0;\n  state.groupNames.length = 0;\n  state.backReferenceNames.length = 0;\n\n  this.regexp_disjunction(state);\n\n  if (state.pos !== state.source.length) {\n    // Make the same messages as V8.\n    if (state.eat(0x29 /* ) */)) {\n      state.raise(\"Unmatched ')'\");\n    }\n    if (state.eat(0x5D /* ] */) || state.eat(0x7D /* } */)) {\n      state.raise(\"Lone quantifier brackets\");\n    }\n  }\n  if (state.maxBackReference > state.numCapturingParens) {\n    state.raise(\"Invalid escape\");\n  }\n  for (var i = 0, list = state.backReferenceNames; i < list.length; i += 1) {\n    var name = list[i];\n\n    if (state.groupNames.indexOf(name) === -1) {\n      state.raise(\"Invalid named capture referenced\");\n    }\n  }\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-Disjunction\npp$8.regexp_disjunction = function(state) {\n  this.regexp_alternative(state);\n  while (state.eat(0x7C /* | */)) {\n    this.regexp_alternative(state);\n  }\n\n  // Make the same message as V8.\n  if (this.regexp_eatQuantifier(state, true)) {\n    state.raise(\"Nothing to repeat\");\n  }\n  if (state.eat(0x7B /* { */)) {\n    state.raise(\"Lone quantifier brackets\");\n  }\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-Alternative\npp$8.regexp_alternative = function(state) {\n  while (state.pos < state.source.length && this.regexp_eatTerm(state))\n    { }\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Term\npp$8.regexp_eatTerm = function(state) {\n  if (this.regexp_eatAssertion(state)) {\n    // Handle `QuantifiableAssertion Quantifier` alternative.\n    // `state.lastAssertionIsQuantifiable` is true if the last eaten Assertion\n    // is a QuantifiableAssertion.\n    if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {\n      // Make the same message as V8.\n      if (state.switchU) {\n        state.raise(\"Invalid quantifier\");\n      }\n    }\n    return true\n  }\n\n  if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {\n    this.regexp_eatQuantifier(state);\n    return true\n  }\n\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Assertion\npp$8.regexp_eatAssertion = function(state) {\n  var start = state.pos;\n  state.lastAssertionIsQuantifiable = false;\n\n  // ^, $\n  if (state.eat(0x5E /* ^ */) || state.eat(0x24 /* $ */)) {\n    return true\n  }\n\n  // \\b \\B\n  if (state.eat(0x5C /* \\ */)) {\n    if (state.eat(0x42 /* B */) || state.eat(0x62 /* b */)) {\n      return true\n    }\n    state.pos = start;\n  }\n\n  // Lookahead / Lookbehind\n  if (state.eat(0x28 /* ( */) && state.eat(0x3F /* ? */)) {\n    var lookbehind = false;\n    if (this.options.ecmaVersion >= 9) {\n      lookbehind = state.eat(0x3C /* < */);\n    }\n    if (state.eat(0x3D /* = */) || state.eat(0x21 /* ! */)) {\n      this.regexp_disjunction(state);\n      if (!state.eat(0x29 /* ) */)) {\n        state.raise(\"Unterminated group\");\n      }\n      state.lastAssertionIsQuantifiable = !lookbehind;\n      return true\n    }\n  }\n\n  state.pos = start;\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-Quantifier\npp$8.regexp_eatQuantifier = function(state, noError) {\n  if ( noError === void 0 ) noError = false;\n\n  if (this.regexp_eatQuantifierPrefix(state, noError)) {\n    state.eat(0x3F /* ? */);\n    return true\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-QuantifierPrefix\npp$8.regexp_eatQuantifierPrefix = function(state, noError) {\n  return (\n    state.eat(0x2A /* * */) ||\n    state.eat(0x2B /* + */) ||\n    state.eat(0x3F /* ? */) ||\n    this.regexp_eatBracedQuantifier(state, noError)\n  )\n};\npp$8.regexp_eatBracedQuantifier = function(state, noError) {\n  var start = state.pos;\n  if (state.eat(0x7B /* { */)) {\n    var min = 0, max = -1;\n    if (this.regexp_eatDecimalDigits(state)) {\n      min = state.lastIntValue;\n      if (state.eat(0x2C /* , */) && this.regexp_eatDecimalDigits(state)) {\n        max = state.lastIntValue;\n      }\n      if (state.eat(0x7D /* } */)) {\n        // SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-term\n        if (max !== -1 && max < min && !noError) {\n          state.raise(\"numbers out of order in {} quantifier\");\n        }\n        return true\n      }\n    }\n    if (state.switchU && !noError) {\n      state.raise(\"Incomplete quantifier\");\n    }\n    state.pos = start;\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-Atom\npp$8.regexp_eatAtom = function(state) {\n  return (\n    this.regexp_eatPatternCharacters(state) ||\n    state.eat(0x2E /* . */) ||\n    this.regexp_eatReverseSolidusAtomEscape(state) ||\n    this.regexp_eatCharacterClass(state) ||\n    this.regexp_eatUncapturingGroup(state) ||\n    this.regexp_eatCapturingGroup(state)\n  )\n};\npp$8.regexp_eatReverseSolidusAtomEscape = function(state) {\n  var start = state.pos;\n  if (state.eat(0x5C /* \\ */)) {\n    if (this.regexp_eatAtomEscape(state)) {\n      return true\n    }\n    state.pos = start;\n  }\n  return false\n};\npp$8.regexp_eatUncapturingGroup = function(state) {\n  var start = state.pos;\n  if (state.eat(0x28 /* ( */)) {\n    if (state.eat(0x3F /* ? */) && state.eat(0x3A /* : */)) {\n      this.regexp_disjunction(state);\n      if (state.eat(0x29 /* ) */)) {\n        return true\n      }\n      state.raise(\"Unterminated group\");\n    }\n    state.pos = start;\n  }\n  return false\n};\npp$8.regexp_eatCapturingGroup = function(state) {\n  if (state.eat(0x28 /* ( */)) {\n    if (this.options.ecmaVersion >= 9) {\n      this.regexp_groupSpecifier(state);\n    } else if (state.current() === 0x3F /* ? */) {\n      state.raise(\"Invalid group\");\n    }\n    this.regexp_disjunction(state);\n    if (state.eat(0x29 /* ) */)) {\n      state.numCapturingParens += 1;\n      return true\n    }\n    state.raise(\"Unterminated group\");\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedAtom\npp$8.regexp_eatExtendedAtom = function(state) {\n  return (\n    state.eat(0x2E /* . */) ||\n    this.regexp_eatReverseSolidusAtomEscape(state) ||\n    this.regexp_eatCharacterClass(state) ||\n    this.regexp_eatUncapturingGroup(state) ||\n    this.regexp_eatCapturingGroup(state) ||\n    this.regexp_eatInvalidBracedQuantifier(state) ||\n    this.regexp_eatExtendedPatternCharacter(state)\n  )\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-InvalidBracedQuantifier\npp$8.regexp_eatInvalidBracedQuantifier = function(state) {\n  if (this.regexp_eatBracedQuantifier(state, true)) {\n    state.raise(\"Nothing to repeat\");\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-SyntaxCharacter\npp$8.regexp_eatSyntaxCharacter = function(state) {\n  var ch = state.current();\n  if (isSyntaxCharacter(ch)) {\n    state.lastIntValue = ch;\n    state.advance();\n    return true\n  }\n  return false\n};\nfunction isSyntaxCharacter(ch) {\n  return (\n    ch === 0x24 /* $ */ ||\n    ch >= 0x28 /* ( */ && ch <= 0x2B /* + */ ||\n    ch === 0x2E /* . */ ||\n    ch === 0x3F /* ? */ ||\n    ch >= 0x5B /* [ */ && ch <= 0x5E /* ^ */ ||\n    ch >= 0x7B /* { */ && ch <= 0x7D /* } */\n  )\n}\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-PatternCharacter\n// But eat eager.\npp$8.regexp_eatPatternCharacters = function(state) {\n  var start = state.pos;\n  var ch = 0;\n  while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) {\n    state.advance();\n  }\n  return state.pos !== start\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedPatternCharacter\npp$8.regexp_eatExtendedPatternCharacter = function(state) {\n  var ch = state.current();\n  if (\n    ch !== -1 &&\n    ch !== 0x24 /* $ */ &&\n    !(ch >= 0x28 /* ( */ && ch <= 0x2B /* + */) &&\n    ch !== 0x2E /* . */ &&\n    ch !== 0x3F /* ? */ &&\n    ch !== 0x5B /* [ */ &&\n    ch !== 0x5E /* ^ */ &&\n    ch !== 0x7C /* | */\n  ) {\n    state.advance();\n    return true\n  }\n  return false\n};\n\n// GroupSpecifier ::\n//   [empty]\n//   `?` GroupName\npp$8.regexp_groupSpecifier = function(state) {\n  if (state.eat(0x3F /* ? */)) {\n    if (this.regexp_eatGroupName(state)) {\n      if (state.groupNames.indexOf(state.lastStringValue) !== -1) {\n        state.raise(\"Duplicate capture group name\");\n      }\n      state.groupNames.push(state.lastStringValue);\n      return\n    }\n    state.raise(\"Invalid group\");\n  }\n};\n\n// GroupName ::\n//   `<` RegExpIdentifierName `>`\n// Note: this updates `state.lastStringValue` property with the eaten name.\npp$8.regexp_eatGroupName = function(state) {\n  state.lastStringValue = \"\";\n  if (state.eat(0x3C /* < */)) {\n    if (this.regexp_eatRegExpIdentifierName(state) && state.eat(0x3E /* > */)) {\n      return true\n    }\n    state.raise(\"Invalid capture group name\");\n  }\n  return false\n};\n\n// RegExpIdentifierName ::\n//   RegExpIdentifierStart\n//   RegExpIdentifierName RegExpIdentifierPart\n// Note: this updates `state.lastStringValue` property with the eaten name.\npp$8.regexp_eatRegExpIdentifierName = function(state) {\n  state.lastStringValue = \"\";\n  if (this.regexp_eatRegExpIdentifierStart(state)) {\n    state.lastStringValue += codePointToString(state.lastIntValue);\n    while (this.regexp_eatRegExpIdentifierPart(state)) {\n      state.lastStringValue += codePointToString(state.lastIntValue);\n    }\n    return true\n  }\n  return false\n};\n\n// RegExpIdentifierStart ::\n//   UnicodeIDStart\n//   `$`\n//   `_`\n//   `\\` RegExpUnicodeEscapeSequence[+U]\npp$8.regexp_eatRegExpIdentifierStart = function(state) {\n  var start = state.pos;\n  var forceU = this.options.ecmaVersion >= 11;\n  var ch = state.current(forceU);\n  state.advance(forceU);\n\n  if (ch === 0x5C /* \\ */ && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {\n    ch = state.lastIntValue;\n  }\n  if (isRegExpIdentifierStart(ch)) {\n    state.lastIntValue = ch;\n    return true\n  }\n\n  state.pos = start;\n  return false\n};\nfunction isRegExpIdentifierStart(ch) {\n  return isIdentifierStart(ch, true) || ch === 0x24 /* $ */ || ch === 0x5F /* _ */\n}\n\n// RegExpIdentifierPart ::\n//   UnicodeIDContinue\n//   `$`\n//   `_`\n//   `\\` RegExpUnicodeEscapeSequence[+U]\n//   <ZWNJ>\n//   <ZWJ>\npp$8.regexp_eatRegExpIdentifierPart = function(state) {\n  var start = state.pos;\n  var forceU = this.options.ecmaVersion >= 11;\n  var ch = state.current(forceU);\n  state.advance(forceU);\n\n  if (ch === 0x5C /* \\ */ && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {\n    ch = state.lastIntValue;\n  }\n  if (isRegExpIdentifierPart(ch)) {\n    state.lastIntValue = ch;\n    return true\n  }\n\n  state.pos = start;\n  return false\n};\nfunction isRegExpIdentifierPart(ch) {\n  return isIdentifierChar(ch, true) || ch === 0x24 /* $ */ || ch === 0x5F /* _ */ || ch === 0x200C /* <ZWNJ> */ || ch === 0x200D /* <ZWJ> */\n}\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-AtomEscape\npp$8.regexp_eatAtomEscape = function(state) {\n  if (\n    this.regexp_eatBackReference(state) ||\n    this.regexp_eatCharacterClassEscape(state) ||\n    this.regexp_eatCharacterEscape(state) ||\n    (state.switchN && this.regexp_eatKGroupName(state))\n  ) {\n    return true\n  }\n  if (state.switchU) {\n    // Make the same message as V8.\n    if (state.current() === 0x63 /* c */) {\n      state.raise(\"Invalid unicode escape\");\n    }\n    state.raise(\"Invalid escape\");\n  }\n  return false\n};\npp$8.regexp_eatBackReference = function(state) {\n  var start = state.pos;\n  if (this.regexp_eatDecimalEscape(state)) {\n    var n = state.lastIntValue;\n    if (state.switchU) {\n      // For SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-atomescape\n      if (n > state.maxBackReference) {\n        state.maxBackReference = n;\n      }\n      return true\n    }\n    if (n <= state.numCapturingParens) {\n      return true\n    }\n    state.pos = start;\n  }\n  return false\n};\npp$8.regexp_eatKGroupName = function(state) {\n  if (state.eat(0x6B /* k */)) {\n    if (this.regexp_eatGroupName(state)) {\n      state.backReferenceNames.push(state.lastStringValue);\n      return true\n    }\n    state.raise(\"Invalid named reference\");\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-CharacterEscape\npp$8.regexp_eatCharacterEscape = function(state) {\n  return (\n    this.regexp_eatControlEscape(state) ||\n    this.regexp_eatCControlLetter(state) ||\n    this.regexp_eatZero(state) ||\n    this.regexp_eatHexEscapeSequence(state) ||\n    this.regexp_eatRegExpUnicodeEscapeSequence(state, false) ||\n    (!state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state)) ||\n    this.regexp_eatIdentityEscape(state)\n  )\n};\npp$8.regexp_eatCControlLetter = function(state) {\n  var start = state.pos;\n  if (state.eat(0x63 /* c */)) {\n    if (this.regexp_eatControlLetter(state)) {\n      return true\n    }\n    state.pos = start;\n  }\n  return false\n};\npp$8.regexp_eatZero = function(state) {\n  if (state.current() === 0x30 /* 0 */ && !isDecimalDigit(state.lookahead())) {\n    state.lastIntValue = 0;\n    state.advance();\n    return true\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-ControlEscape\npp$8.regexp_eatControlEscape = function(state) {\n  var ch = state.current();\n  if (ch === 0x74 /* t */) {\n    state.lastIntValue = 0x09; /* \\t */\n    state.advance();\n    return true\n  }\n  if (ch === 0x6E /* n */) {\n    state.lastIntValue = 0x0A; /* \\n */\n    state.advance();\n    return true\n  }\n  if (ch === 0x76 /* v */) {\n    state.lastIntValue = 0x0B; /* \\v */\n    state.advance();\n    return true\n  }\n  if (ch === 0x66 /* f */) {\n    state.lastIntValue = 0x0C; /* \\f */\n    state.advance();\n    return true\n  }\n  if (ch === 0x72 /* r */) {\n    state.lastIntValue = 0x0D; /* \\r */\n    state.advance();\n    return true\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-ControlLetter\npp$8.regexp_eatControlLetter = function(state) {\n  var ch = state.current();\n  if (isControlLetter(ch)) {\n    state.lastIntValue = ch % 0x20;\n    state.advance();\n    return true\n  }\n  return false\n};\nfunction isControlLetter(ch) {\n  return (\n    (ch >= 0x41 /* A */ && ch <= 0x5A /* Z */) ||\n    (ch >= 0x61 /* a */ && ch <= 0x7A /* z */)\n  )\n}\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-RegExpUnicodeEscapeSequence\npp$8.regexp_eatRegExpUnicodeEscapeSequence = function(state, forceU) {\n  if ( forceU === void 0 ) forceU = false;\n\n  var start = state.pos;\n  var switchU = forceU || state.switchU;\n\n  if (state.eat(0x75 /* u */)) {\n    if (this.regexp_eatFixedHexDigits(state, 4)) {\n      var lead = state.lastIntValue;\n      if (switchU && lead >= 0xD800 && lead <= 0xDBFF) {\n        var leadSurrogateEnd = state.pos;\n        if (state.eat(0x5C /* \\ */) && state.eat(0x75 /* u */) && this.regexp_eatFixedHexDigits(state, 4)) {\n          var trail = state.lastIntValue;\n          if (trail >= 0xDC00 && trail <= 0xDFFF) {\n            state.lastIntValue = (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;\n            return true\n          }\n        }\n        state.pos = leadSurrogateEnd;\n        state.lastIntValue = lead;\n      }\n      return true\n    }\n    if (\n      switchU &&\n      state.eat(0x7B /* { */) &&\n      this.regexp_eatHexDigits(state) &&\n      state.eat(0x7D /* } */) &&\n      isValidUnicode(state.lastIntValue)\n    ) {\n      return true\n    }\n    if (switchU) {\n      state.raise(\"Invalid unicode escape\");\n    }\n    state.pos = start;\n  }\n\n  return false\n};\nfunction isValidUnicode(ch) {\n  return ch >= 0 && ch <= 0x10FFFF\n}\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-IdentityEscape\npp$8.regexp_eatIdentityEscape = function(state) {\n  if (state.switchU) {\n    if (this.regexp_eatSyntaxCharacter(state)) {\n      return true\n    }\n    if (state.eat(0x2F /* / */)) {\n      state.lastIntValue = 0x2F; /* / */\n      return true\n    }\n    return false\n  }\n\n  var ch = state.current();\n  if (ch !== 0x63 /* c */ && (!state.switchN || ch !== 0x6B /* k */)) {\n    state.lastIntValue = ch;\n    state.advance();\n    return true\n  }\n\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalEscape\npp$8.regexp_eatDecimalEscape = function(state) {\n  state.lastIntValue = 0;\n  var ch = state.current();\n  if (ch >= 0x31 /* 1 */ && ch <= 0x39 /* 9 */) {\n    do {\n      state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */);\n      state.advance();\n    } while ((ch = state.current()) >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */)\n    return true\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClassEscape\npp$8.regexp_eatCharacterClassEscape = function(state) {\n  var ch = state.current();\n\n  if (isCharacterClassEscape(ch)) {\n    state.lastIntValue = -1;\n    state.advance();\n    return true\n  }\n\n  if (\n    state.switchU &&\n    this.options.ecmaVersion >= 9 &&\n    (ch === 0x50 /* P */ || ch === 0x70 /* p */)\n  ) {\n    state.lastIntValue = -1;\n    state.advance();\n    if (\n      state.eat(0x7B /* { */) &&\n      this.regexp_eatUnicodePropertyValueExpression(state) &&\n      state.eat(0x7D /* } */)\n    ) {\n      return true\n    }\n    state.raise(\"Invalid property name\");\n  }\n\n  return false\n};\nfunction isCharacterClassEscape(ch) {\n  return (\n    ch === 0x64 /* d */ ||\n    ch === 0x44 /* D */ ||\n    ch === 0x73 /* s */ ||\n    ch === 0x53 /* S */ ||\n    ch === 0x77 /* w */ ||\n    ch === 0x57 /* W */\n  )\n}\n\n// UnicodePropertyValueExpression ::\n//   UnicodePropertyName `=` UnicodePropertyValue\n//   LoneUnicodePropertyNameOrValue\npp$8.regexp_eatUnicodePropertyValueExpression = function(state) {\n  var start = state.pos;\n\n  // UnicodePropertyName `=` UnicodePropertyValue\n  if (this.regexp_eatUnicodePropertyName(state) && state.eat(0x3D /* = */)) {\n    var name = state.lastStringValue;\n    if (this.regexp_eatUnicodePropertyValue(state)) {\n      var value = state.lastStringValue;\n      this.regexp_validateUnicodePropertyNameAndValue(state, name, value);\n      return true\n    }\n  }\n  state.pos = start;\n\n  // LoneUnicodePropertyNameOrValue\n  if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {\n    var nameOrValue = state.lastStringValue;\n    this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);\n    return true\n  }\n  return false\n};\npp$8.regexp_validateUnicodePropertyNameAndValue = function(state, name, value) {\n  if (!has(state.unicodeProperties.nonBinary, name))\n    { state.raise(\"Invalid property name\"); }\n  if (!state.unicodeProperties.nonBinary[name].test(value))\n    { state.raise(\"Invalid property value\"); }\n};\npp$8.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {\n  if (!state.unicodeProperties.binary.test(nameOrValue))\n    { state.raise(\"Invalid property name\"); }\n};\n\n// UnicodePropertyName ::\n//   UnicodePropertyNameCharacters\npp$8.regexp_eatUnicodePropertyName = function(state) {\n  var ch = 0;\n  state.lastStringValue = \"\";\n  while (isUnicodePropertyNameCharacter(ch = state.current())) {\n    state.lastStringValue += codePointToString(ch);\n    state.advance();\n  }\n  return state.lastStringValue !== \"\"\n};\nfunction isUnicodePropertyNameCharacter(ch) {\n  return isControlLetter(ch) || ch === 0x5F /* _ */\n}\n\n// UnicodePropertyValue ::\n//   UnicodePropertyValueCharacters\npp$8.regexp_eatUnicodePropertyValue = function(state) {\n  var ch = 0;\n  state.lastStringValue = \"\";\n  while (isUnicodePropertyValueCharacter(ch = state.current())) {\n    state.lastStringValue += codePointToString(ch);\n    state.advance();\n  }\n  return state.lastStringValue !== \"\"\n};\nfunction isUnicodePropertyValueCharacter(ch) {\n  return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch)\n}\n\n// LoneUnicodePropertyNameOrValue ::\n//   UnicodePropertyValueCharacters\npp$8.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {\n  return this.regexp_eatUnicodePropertyValue(state)\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClass\npp$8.regexp_eatCharacterClass = function(state) {\n  if (state.eat(0x5B /* [ */)) {\n    state.eat(0x5E /* ^ */);\n    this.regexp_classRanges(state);\n    if (state.eat(0x5D /* ] */)) {\n      return true\n    }\n    // Unreachable since it threw \"unterminated regular expression\" error before.\n    state.raise(\"Unterminated character class\");\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassRanges\n// https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRanges\n// https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRangesNoDash\npp$8.regexp_classRanges = function(state) {\n  while (this.regexp_eatClassAtom(state)) {\n    var left = state.lastIntValue;\n    if (state.eat(0x2D /* - */) && this.regexp_eatClassAtom(state)) {\n      var right = state.lastIntValue;\n      if (state.switchU && (left === -1 || right === -1)) {\n        state.raise(\"Invalid character class\");\n      }\n      if (left !== -1 && right !== -1 && left > right) {\n        state.raise(\"Range out of order in character class\");\n      }\n    }\n  }\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtom\n// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtomNoDash\npp$8.regexp_eatClassAtom = function(state) {\n  var start = state.pos;\n\n  if (state.eat(0x5C /* \\ */)) {\n    if (this.regexp_eatClassEscape(state)) {\n      return true\n    }\n    if (state.switchU) {\n      // Make the same message as V8.\n      var ch$1 = state.current();\n      if (ch$1 === 0x63 /* c */ || isOctalDigit(ch$1)) {\n        state.raise(\"Invalid class escape\");\n      }\n      state.raise(\"Invalid escape\");\n    }\n    state.pos = start;\n  }\n\n  var ch = state.current();\n  if (ch !== 0x5D /* ] */) {\n    state.lastIntValue = ch;\n    state.advance();\n    return true\n  }\n\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassEscape\npp$8.regexp_eatClassEscape = function(state) {\n  var start = state.pos;\n\n  if (state.eat(0x62 /* b */)) {\n    state.lastIntValue = 0x08; /* <BS> */\n    return true\n  }\n\n  if (state.switchU && state.eat(0x2D /* - */)) {\n    state.lastIntValue = 0x2D; /* - */\n    return true\n  }\n\n  if (!state.switchU && state.eat(0x63 /* c */)) {\n    if (this.regexp_eatClassControlLetter(state)) {\n      return true\n    }\n    state.pos = start;\n  }\n\n  return (\n    this.regexp_eatCharacterClassEscape(state) ||\n    this.regexp_eatCharacterEscape(state)\n  )\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassControlLetter\npp$8.regexp_eatClassControlLetter = function(state) {\n  var ch = state.current();\n  if (isDecimalDigit(ch) || ch === 0x5F /* _ */) {\n    state.lastIntValue = ch % 0x20;\n    state.advance();\n    return true\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence\npp$8.regexp_eatHexEscapeSequence = function(state) {\n  var start = state.pos;\n  if (state.eat(0x78 /* x */)) {\n    if (this.regexp_eatFixedHexDigits(state, 2)) {\n      return true\n    }\n    if (state.switchU) {\n      state.raise(\"Invalid escape\");\n    }\n    state.pos = start;\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalDigits\npp$8.regexp_eatDecimalDigits = function(state) {\n  var start = state.pos;\n  var ch = 0;\n  state.lastIntValue = 0;\n  while (isDecimalDigit(ch = state.current())) {\n    state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */);\n    state.advance();\n  }\n  return state.pos !== start\n};\nfunction isDecimalDigit(ch) {\n  return ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */\n}\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigits\npp$8.regexp_eatHexDigits = function(state) {\n  var start = state.pos;\n  var ch = 0;\n  state.lastIntValue = 0;\n  while (isHexDigit(ch = state.current())) {\n    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);\n    state.advance();\n  }\n  return state.pos !== start\n};\nfunction isHexDigit(ch) {\n  return (\n    (ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */) ||\n    (ch >= 0x41 /* A */ && ch <= 0x46 /* F */) ||\n    (ch >= 0x61 /* a */ && ch <= 0x66 /* f */)\n  )\n}\nfunction hexToInt(ch) {\n  if (ch >= 0x41 /* A */ && ch <= 0x46 /* F */) {\n    return 10 + (ch - 0x41 /* A */)\n  }\n  if (ch >= 0x61 /* a */ && ch <= 0x66 /* f */) {\n    return 10 + (ch - 0x61 /* a */)\n  }\n  return ch - 0x30 /* 0 */\n}\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-LegacyOctalEscapeSequence\n// Allows only 0-377(octal) i.e. 0-255(decimal).\npp$8.regexp_eatLegacyOctalEscapeSequence = function(state) {\n  if (this.regexp_eatOctalDigit(state)) {\n    var n1 = state.lastIntValue;\n    if (this.regexp_eatOctalDigit(state)) {\n      var n2 = state.lastIntValue;\n      if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {\n        state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;\n      } else {\n        state.lastIntValue = n1 * 8 + n2;\n      }\n    } else {\n      state.lastIntValue = n1;\n    }\n    return true\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-OctalDigit\npp$8.regexp_eatOctalDigit = function(state) {\n  var ch = state.current();\n  if (isOctalDigit(ch)) {\n    state.lastIntValue = ch - 0x30; /* 0 */\n    state.advance();\n    return true\n  }\n  state.lastIntValue = 0;\n  return false\n};\nfunction isOctalDigit(ch) {\n  return ch >= 0x30 /* 0 */ && ch <= 0x37 /* 7 */\n}\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-Hex4Digits\n// https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigit\n// And HexDigit HexDigit in https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence\npp$8.regexp_eatFixedHexDigits = function(state, length) {\n  var start = state.pos;\n  state.lastIntValue = 0;\n  for (var i = 0; i < length; ++i) {\n    var ch = state.current();\n    if (!isHexDigit(ch)) {\n      state.pos = start;\n      return false\n    }\n    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);\n    state.advance();\n  }\n  return true\n};\n\n// Object type used to represent tokens. Note that normally, tokens\n// simply exist as properties on the parser object. This is only\n// used for the onToken callback and the external tokenizer.\n\nvar Token = function Token(p) {\n  this.type = p.type;\n  this.value = p.value;\n  this.start = p.start;\n  this.end = p.end;\n  if (p.options.locations)\n    { this.loc = new SourceLocation(p, p.startLoc, p.endLoc); }\n  if (p.options.ranges)\n    { this.range = [p.start, p.end]; }\n};\n\n// ## Tokenizer\n\nvar pp$9 = Parser.prototype;\n\n// Move to the next token\n\npp$9.next = function(ignoreEscapeSequenceInKeyword) {\n  if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc)\n    { this.raiseRecoverable(this.start, \"Escape sequence in keyword \" + this.type.keyword); }\n  if (this.options.onToken)\n    { this.options.onToken(new Token(this)); }\n\n  this.lastTokEnd = this.end;\n  this.lastTokStart = this.start;\n  this.lastTokEndLoc = this.endLoc;\n  this.lastTokStartLoc = this.startLoc;\n  this.nextToken();\n};\n\npp$9.getToken = function() {\n  this.next();\n  return new Token(this)\n};\n\n// If we're in an ES6 environment, make parsers iterable\nif (typeof Symbol !== \"undefined\")\n  { pp$9[Symbol.iterator] = function() {\n    var this$1 = this;\n\n    return {\n      next: function () {\n        var token = this$1.getToken();\n        return {\n          done: token.type === types.eof,\n          value: token\n        }\n      }\n    }\n  }; }\n\n// Toggle strict mode. Re-reads the next number or string to please\n// pedantic tests (`\"use strict\"; 010;` should fail).\n\npp$9.curContext = function() {\n  return this.context[this.context.length - 1]\n};\n\n// Read a single token, updating the parser object's token-related\n// properties.\n\npp$9.nextToken = function() {\n  var curContext = this.curContext();\n  if (!curContext || !curContext.preserveSpace) { this.skipSpace(); }\n\n  this.start = this.pos;\n  if (this.options.locations) { this.startLoc = this.curPosition(); }\n  if (this.pos >= this.input.length) { return this.finishToken(types.eof) }\n\n  if (curContext.override) { return curContext.override(this) }\n  else { this.readToken(this.fullCharCodeAtPos()); }\n};\n\npp$9.readToken = function(code) {\n  // Identifier or keyword. '\\uXXXX' sequences are allowed in\n  // identifiers, so '\\' also dispatches to that.\n  if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92 /* '\\' */)\n    { return this.readWord() }\n\n  return this.getTokenFromCode(code)\n};\n\npp$9.fullCharCodeAtPos = function() {\n  var code = this.input.charCodeAt(this.pos);\n  if (code <= 0xd7ff || code >= 0xe000) { return code }\n  var next = this.input.charCodeAt(this.pos + 1);\n  return (code << 10) + next - 0x35fdc00\n};\n\npp$9.skipBlockComment = function() {\n  var startLoc = this.options.onComment && this.curPosition();\n  var start = this.pos, end = this.input.indexOf(\"*/\", this.pos += 2);\n  if (end === -1) { this.raise(this.pos - 2, \"Unterminated comment\"); }\n  this.pos = end + 2;\n  if (this.options.locations) {\n    lineBreakG.lastIndex = start;\n    var match;\n    while ((match = lineBreakG.exec(this.input)) && match.index < this.pos) {\n      ++this.curLine;\n      this.lineStart = match.index + match[0].length;\n    }\n  }\n  if (this.options.onComment)\n    { this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos,\n                           startLoc, this.curPosition()); }\n};\n\npp$9.skipLineComment = function(startSkip) {\n  var start = this.pos;\n  var startLoc = this.options.onComment && this.curPosition();\n  var ch = this.input.charCodeAt(this.pos += startSkip);\n  while (this.pos < this.input.length && !isNewLine(ch)) {\n    ch = this.input.charCodeAt(++this.pos);\n  }\n  if (this.options.onComment)\n    { this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos,\n                           startLoc, this.curPosition()); }\n};\n\n// Called at the start of the parse and after every token. Skips\n// whitespace and comments, and.\n\npp$9.skipSpace = function() {\n  loop: while (this.pos < this.input.length) {\n    var ch = this.input.charCodeAt(this.pos);\n    switch (ch) {\n    case 32: case 160: // ' '\n      ++this.pos;\n      break\n    case 13:\n      if (this.input.charCodeAt(this.pos + 1) === 10) {\n        ++this.pos;\n      }\n    case 10: case 8232: case 8233:\n      ++this.pos;\n      if (this.options.locations) {\n        ++this.curLine;\n        this.lineStart = this.pos;\n      }\n      break\n    case 47: // '/'\n      switch (this.input.charCodeAt(this.pos + 1)) {\n      case 42: // '*'\n        this.skipBlockComment();\n        break\n      case 47:\n        this.skipLineComment(2);\n        break\n      default:\n        break loop\n      }\n      break\n    default:\n      if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {\n        ++this.pos;\n      } else {\n        break loop\n      }\n    }\n  }\n};\n\n// Called at the end of every token. Sets `end`, `val`, and\n// maintains `context` and `exprAllowed`, and skips the space after\n// the token, so that the next one's `start` will point at the\n// right position.\n\npp$9.finishToken = function(type, val) {\n  this.end = this.pos;\n  if (this.options.locations) { this.endLoc = this.curPosition(); }\n  var prevType = this.type;\n  this.type = type;\n  this.value = val;\n\n  this.updateContext(prevType);\n};\n\n// ### Token reading\n\n// This is the function that is called to fetch the next token. It\n// is somewhat obscure, because it works in character codes rather\n// than characters, and because operator parsing has been inlined\n// into it.\n//\n// All in the name of speed.\n//\npp$9.readToken_dot = function() {\n  var next = this.input.charCodeAt(this.pos + 1);\n  if (next >= 48 && next <= 57) { return this.readNumber(true) }\n  var next2 = this.input.charCodeAt(this.pos + 2);\n  if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) { // 46 = dot '.'\n    this.pos += 3;\n    return this.finishToken(types.ellipsis)\n  } else {\n    ++this.pos;\n    return this.finishToken(types.dot)\n  }\n};\n\npp$9.readToken_slash = function() { // '/'\n  var next = this.input.charCodeAt(this.pos + 1);\n  if (this.exprAllowed) { ++this.pos; return this.readRegexp() }\n  if (next === 61) { return this.finishOp(types.assign, 2) }\n  return this.finishOp(types.slash, 1)\n};\n\npp$9.readToken_mult_modulo_exp = function(code) { // '%*'\n  var next = this.input.charCodeAt(this.pos + 1);\n  var size = 1;\n  var tokentype = code === 42 ? types.star : types.modulo;\n\n  // exponentiation operator ** and **=\n  if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {\n    ++size;\n    tokentype = types.starstar;\n    next = this.input.charCodeAt(this.pos + 2);\n  }\n\n  if (next === 61) { return this.finishOp(types.assign, size + 1) }\n  return this.finishOp(tokentype, size)\n};\n\npp$9.readToken_pipe_amp = function(code) { // '|&'\n  var next = this.input.charCodeAt(this.pos + 1);\n  if (next === code) {\n    if (this.options.ecmaVersion >= 12) {\n      var next2 = this.input.charCodeAt(this.pos + 2);\n      if (next2 === 61) { return this.finishOp(types.assign, 3) }\n    }\n    return this.finishOp(code === 124 ? types.logicalOR : types.logicalAND, 2)\n  }\n  if (next === 61) { return this.finishOp(types.assign, 2) }\n  return this.finishOp(code === 124 ? types.bitwiseOR : types.bitwiseAND, 1)\n};\n\npp$9.readToken_caret = function() { // '^'\n  var next = this.input.charCodeAt(this.pos + 1);\n  if (next === 61) { return this.finishOp(types.assign, 2) }\n  return this.finishOp(types.bitwiseXOR, 1)\n};\n\npp$9.readToken_plus_min = function(code) { // '+-'\n  var next = this.input.charCodeAt(this.pos + 1);\n  if (next === code) {\n    if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 &&\n        (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {\n      // A `-->` line comment\n      this.skipLineComment(3);\n      this.skipSpace();\n      return this.nextToken()\n    }\n    return this.finishOp(types.incDec, 2)\n  }\n  if (next === 61) { return this.finishOp(types.assign, 2) }\n  return this.finishOp(types.plusMin, 1)\n};\n\npp$9.readToken_lt_gt = function(code) { // '<>'\n  var next = this.input.charCodeAt(this.pos + 1);\n  var size = 1;\n  if (next === code) {\n    size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;\n    if (this.input.charCodeAt(this.pos + size) === 61) { return this.finishOp(types.assign, size + 1) }\n    return this.finishOp(types.bitShift, size)\n  }\n  if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 &&\n      this.input.charCodeAt(this.pos + 3) === 45) {\n    // `<!--`, an XML-style comment that should be interpreted as a line comment\n    this.skipLineComment(4);\n    this.skipSpace();\n    return this.nextToken()\n  }\n  if (next === 61) { size = 2; }\n  return this.finishOp(types.relational, size)\n};\n\npp$9.readToken_eq_excl = function(code) { // '=!'\n  var next = this.input.charCodeAt(this.pos + 1);\n  if (next === 61) { return this.finishOp(types.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2) }\n  if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) { // '=>'\n    this.pos += 2;\n    return this.finishToken(types.arrow)\n  }\n  return this.finishOp(code === 61 ? types.eq : types.prefix, 1)\n};\n\npp$9.readToken_question = function() { // '?'\n  var ecmaVersion = this.options.ecmaVersion;\n  if (ecmaVersion >= 11) {\n    var next = this.input.charCodeAt(this.pos + 1);\n    if (next === 46) {\n      var next2 = this.input.charCodeAt(this.pos + 2);\n      if (next2 < 48 || next2 > 57) { return this.finishOp(types.questionDot, 2) }\n    }\n    if (next === 63) {\n      if (ecmaVersion >= 12) {\n        var next2$1 = this.input.charCodeAt(this.pos + 2);\n        if (next2$1 === 61) { return this.finishOp(types.assign, 3) }\n      }\n      return this.finishOp(types.coalesce, 2)\n    }\n  }\n  return this.finishOp(types.question, 1)\n};\n\npp$9.getTokenFromCode = function(code) {\n  switch (code) {\n  // The interpretation of a dot depends on whether it is followed\n  // by a digit or another two dots.\n  case 46: // '.'\n    return this.readToken_dot()\n\n  // Punctuation tokens.\n  case 40: ++this.pos; return this.finishToken(types.parenL)\n  case 41: ++this.pos; return this.finishToken(types.parenR)\n  case 59: ++this.pos; return this.finishToken(types.semi)\n  case 44: ++this.pos; return this.finishToken(types.comma)\n  case 91: ++this.pos; return this.finishToken(types.bracketL)\n  case 93: ++this.pos; return this.finishToken(types.bracketR)\n  case 123: ++this.pos; return this.finishToken(types.braceL)\n  case 125: ++this.pos; return this.finishToken(types.braceR)\n  case 58: ++this.pos; return this.finishToken(types.colon)\n\n  case 96: // '`'\n    if (this.options.ecmaVersion < 6) { break }\n    ++this.pos;\n    return this.finishToken(types.backQuote)\n\n  case 48: // '0'\n    var next = this.input.charCodeAt(this.pos + 1);\n    if (next === 120 || next === 88) { return this.readRadixNumber(16) } // '0x', '0X' - hex number\n    if (this.options.ecmaVersion >= 6) {\n      if (next === 111 || next === 79) { return this.readRadixNumber(8) } // '0o', '0O' - octal number\n      if (next === 98 || next === 66) { return this.readRadixNumber(2) } // '0b', '0B' - binary number\n    }\n\n  // Anything else beginning with a digit is an integer, octal\n  // number, or float.\n  case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: // 1-9\n    return this.readNumber(false)\n\n  // Quotes produce strings.\n  case 34: case 39: // '\"', \"'\"\n    return this.readString(code)\n\n  // Operators are parsed inline in tiny state machines. '=' (61) is\n  // often referred to. `finishOp` simply skips the amount of\n  // characters it is given as second argument, and returns a token\n  // of the type given by its first argument.\n\n  case 47: // '/'\n    return this.readToken_slash()\n\n  case 37: case 42: // '%*'\n    return this.readToken_mult_modulo_exp(code)\n\n  case 124: case 38: // '|&'\n    return this.readToken_pipe_amp(code)\n\n  case 94: // '^'\n    return this.readToken_caret()\n\n  case 43: case 45: // '+-'\n    return this.readToken_plus_min(code)\n\n  case 60: case 62: // '<>'\n    return this.readToken_lt_gt(code)\n\n  case 61: case 33: // '=!'\n    return this.readToken_eq_excl(code)\n\n  case 63: // '?'\n    return this.readToken_question()\n\n  case 126: // '~'\n    return this.finishOp(types.prefix, 1)\n  }\n\n  this.raise(this.pos, \"Unexpected character '\" + codePointToString$1(code) + \"'\");\n};\n\npp$9.finishOp = function(type, size) {\n  var str = this.input.slice(this.pos, this.pos + size);\n  this.pos += size;\n  return this.finishToken(type, str)\n};\n\npp$9.readRegexp = function() {\n  var escaped, inClass, start = this.pos;\n  for (;;) {\n    if (this.pos >= this.input.length) { this.raise(start, \"Unterminated regular expression\"); }\n    var ch = this.input.charAt(this.pos);\n    if (lineBreak.test(ch)) { this.raise(start, \"Unterminated regular expression\"); }\n    if (!escaped) {\n      if (ch === \"[\") { inClass = true; }\n      else if (ch === \"]\" && inClass) { inClass = false; }\n      else if (ch === \"/\" && !inClass) { break }\n      escaped = ch === \"\\\\\";\n    } else { escaped = false; }\n    ++this.pos;\n  }\n  var pattern = this.input.slice(start, this.pos);\n  ++this.pos;\n  var flagsStart = this.pos;\n  var flags = this.readWord1();\n  if (this.containsEsc) { this.unexpected(flagsStart); }\n\n  // Validate pattern\n  var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));\n  state.reset(start, pattern, flags);\n  this.validateRegExpFlags(state);\n  this.validateRegExpPattern(state);\n\n  // Create Literal#value property value.\n  var value = null;\n  try {\n    value = new RegExp(pattern, flags);\n  } catch (e) {\n    // ESTree requires null if it failed to instantiate RegExp object.\n    // https://github.com/estree/estree/blob/a27003adf4fd7bfad44de9cef372a2eacd527b1c/es5.md#regexpliteral\n  }\n\n  return this.finishToken(types.regexp, {pattern: pattern, flags: flags, value: value})\n};\n\n// Read an integer in the given radix. Return null if zero digits\n// were read, the integer value otherwise. When `len` is given, this\n// will return `null` unless the integer has exactly `len` digits.\n\npp$9.readInt = function(radix, len, maybeLegacyOctalNumericLiteral) {\n  // `len` is used for character escape sequences. In that case, disallow separators.\n  var allowSeparators = this.options.ecmaVersion >= 12 && len === undefined;\n\n  // `maybeLegacyOctalNumericLiteral` is true if it doesn't have prefix (0x,0o,0b)\n  // and isn't fraction part nor exponent part. In that case, if the first digit\n  // is zero then disallow separators.\n  var isLegacyOctalNumericLiteral = maybeLegacyOctalNumericLiteral && this.input.charCodeAt(this.pos) === 48;\n\n  var start = this.pos, total = 0, lastCode = 0;\n  for (var i = 0, e = len == null ? Infinity : len; i < e; ++i, ++this.pos) {\n    var code = this.input.charCodeAt(this.pos), val = (void 0);\n\n    if (allowSeparators && code === 95) {\n      if (isLegacyOctalNumericLiteral) { this.raiseRecoverable(this.pos, \"Numeric separator is not allowed in legacy octal numeric literals\"); }\n      if (lastCode === 95) { this.raiseRecoverable(this.pos, \"Numeric separator must be exactly one underscore\"); }\n      if (i === 0) { this.raiseRecoverable(this.pos, \"Numeric separator is not allowed at the first of digits\"); }\n      lastCode = code;\n      continue\n    }\n\n    if (code >= 97) { val = code - 97 + 10; } // a\n    else if (code >= 65) { val = code - 65 + 10; } // A\n    else if (code >= 48 && code <= 57) { val = code - 48; } // 0-9\n    else { val = Infinity; }\n    if (val >= radix) { break }\n    lastCode = code;\n    total = total * radix + val;\n  }\n\n  if (allowSeparators && lastCode === 95) { this.raiseRecoverable(this.pos - 1, \"Numeric separator is not allowed at the last of digits\"); }\n  if (this.pos === start || len != null && this.pos - start !== len) { return null }\n\n  return total\n};\n\nfunction stringToNumber(str, isLegacyOctalNumericLiteral) {\n  if (isLegacyOctalNumericLiteral) {\n    return parseInt(str, 8)\n  }\n\n  // `parseFloat(value)` stops parsing at the first numeric separator then returns a wrong value.\n  return parseFloat(str.replace(/_/g, \"\"))\n}\n\nfunction stringToBigInt(str) {\n  if (typeof BigInt !== \"function\") {\n    return null\n  }\n\n  // `BigInt(value)` throws syntax error if the string contains numeric separators.\n  return BigInt(str.replace(/_/g, \"\"))\n}\n\npp$9.readRadixNumber = function(radix) {\n  var start = this.pos;\n  this.pos += 2; // 0x\n  var val = this.readInt(radix);\n  if (val == null) { this.raise(this.start + 2, \"Expected number in radix \" + radix); }\n  if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {\n    val = stringToBigInt(this.input.slice(start, this.pos));\n    ++this.pos;\n  } else if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, \"Identifier directly after number\"); }\n  return this.finishToken(types.num, val)\n};\n\n// Read an integer, octal integer, or floating-point number.\n\npp$9.readNumber = function(startsWithDot) {\n  var start = this.pos;\n  if (!startsWithDot && this.readInt(10, undefined, true) === null) { this.raise(start, \"Invalid number\"); }\n  var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;\n  if (octal && this.strict) { this.raise(start, \"Invalid number\"); }\n  var next = this.input.charCodeAt(this.pos);\n  if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {\n    var val$1 = stringToBigInt(this.input.slice(start, this.pos));\n    ++this.pos;\n    if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, \"Identifier directly after number\"); }\n    return this.finishToken(types.num, val$1)\n  }\n  if (octal && /[89]/.test(this.input.slice(start, this.pos))) { octal = false; }\n  if (next === 46 && !octal) { // '.'\n    ++this.pos;\n    this.readInt(10);\n    next = this.input.charCodeAt(this.pos);\n  }\n  if ((next === 69 || next === 101) && !octal) { // 'eE'\n    next = this.input.charCodeAt(++this.pos);\n    if (next === 43 || next === 45) { ++this.pos; } // '+-'\n    if (this.readInt(10) === null) { this.raise(start, \"Invalid number\"); }\n  }\n  if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, \"Identifier directly after number\"); }\n\n  var val = stringToNumber(this.input.slice(start, this.pos), octal);\n  return this.finishToken(types.num, val)\n};\n\n// Read a string value, interpreting backslash-escapes.\n\npp$9.readCodePoint = function() {\n  var ch = this.input.charCodeAt(this.pos), code;\n\n  if (ch === 123) { // '{'\n    if (this.options.ecmaVersion < 6) { this.unexpected(); }\n    var codePos = ++this.pos;\n    code = this.readHexChar(this.input.indexOf(\"}\", this.pos) - this.pos);\n    ++this.pos;\n    if (code > 0x10FFFF) { this.invalidStringToken(codePos, \"Code point out of bounds\"); }\n  } else {\n    code = this.readHexChar(4);\n  }\n  return code\n};\n\nfunction codePointToString$1(code) {\n  // UTF-16 Decoding\n  if (code <= 0xFFFF) { return String.fromCharCode(code) }\n  code -= 0x10000;\n  return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00)\n}\n\npp$9.readString = function(quote) {\n  var out = \"\", chunkStart = ++this.pos;\n  for (;;) {\n    if (this.pos >= this.input.length) { this.raise(this.start, \"Unterminated string constant\"); }\n    var ch = this.input.charCodeAt(this.pos);\n    if (ch === quote) { break }\n    if (ch === 92) { // '\\'\n      out += this.input.slice(chunkStart, this.pos);\n      out += this.readEscapedChar(false);\n      chunkStart = this.pos;\n    } else {\n      if (isNewLine(ch, this.options.ecmaVersion >= 10)) { this.raise(this.start, \"Unterminated string constant\"); }\n      ++this.pos;\n    }\n  }\n  out += this.input.slice(chunkStart, this.pos++);\n  return this.finishToken(types.string, out)\n};\n\n// Reads template string tokens.\n\nvar INVALID_TEMPLATE_ESCAPE_ERROR = {};\n\npp$9.tryReadTemplateToken = function() {\n  this.inTemplateElement = true;\n  try {\n    this.readTmplToken();\n  } catch (err) {\n    if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {\n      this.readInvalidTemplateToken();\n    } else {\n      throw err\n    }\n  }\n\n  this.inTemplateElement = false;\n};\n\npp$9.invalidStringToken = function(position, message) {\n  if (this.inTemplateElement && this.options.ecmaVersion >= 9) {\n    throw INVALID_TEMPLATE_ESCAPE_ERROR\n  } else {\n    this.raise(position, message);\n  }\n};\n\npp$9.readTmplToken = function() {\n  var out = \"\", chunkStart = this.pos;\n  for (;;) {\n    if (this.pos >= this.input.length) { this.raise(this.start, \"Unterminated template\"); }\n    var ch = this.input.charCodeAt(this.pos);\n    if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) { // '`', '${'\n      if (this.pos === this.start && (this.type === types.template || this.type === types.invalidTemplate)) {\n        if (ch === 36) {\n          this.pos += 2;\n          return this.finishToken(types.dollarBraceL)\n        } else {\n          ++this.pos;\n          return this.finishToken(types.backQuote)\n        }\n      }\n      out += this.input.slice(chunkStart, this.pos);\n      return this.finishToken(types.template, out)\n    }\n    if (ch === 92) { // '\\'\n      out += this.input.slice(chunkStart, this.pos);\n      out += this.readEscapedChar(true);\n      chunkStart = this.pos;\n    } else if (isNewLine(ch)) {\n      out += this.input.slice(chunkStart, this.pos);\n      ++this.pos;\n      switch (ch) {\n      case 13:\n        if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; }\n      case 10:\n        out += \"\\n\";\n        break\n      default:\n        out += String.fromCharCode(ch);\n        break\n      }\n      if (this.options.locations) {\n        ++this.curLine;\n        this.lineStart = this.pos;\n      }\n      chunkStart = this.pos;\n    } else {\n      ++this.pos;\n    }\n  }\n};\n\n// Reads a template token to search for the end, without validating any escape sequences\npp$9.readInvalidTemplateToken = function() {\n  for (; this.pos < this.input.length; this.pos++) {\n    switch (this.input[this.pos]) {\n    case \"\\\\\":\n      ++this.pos;\n      break\n\n    case \"$\":\n      if (this.input[this.pos + 1] !== \"{\") {\n        break\n      }\n    // falls through\n\n    case \"`\":\n      return this.finishToken(types.invalidTemplate, this.input.slice(this.start, this.pos))\n\n    // no default\n    }\n  }\n  this.raise(this.start, \"Unterminated template\");\n};\n\n// Used to read escaped characters\n\npp$9.readEscapedChar = function(inTemplate) {\n  var ch = this.input.charCodeAt(++this.pos);\n  ++this.pos;\n  switch (ch) {\n  case 110: return \"\\n\" // 'n' -> '\\n'\n  case 114: return \"\\r\" // 'r' -> '\\r'\n  case 120: return String.fromCharCode(this.readHexChar(2)) // 'x'\n  case 117: return codePointToString$1(this.readCodePoint()) // 'u'\n  case 116: return \"\\t\" // 't' -> '\\t'\n  case 98: return \"\\b\" // 'b' -> '\\b'\n  case 118: return \"\\u000b\" // 'v' -> '\\u000b'\n  case 102: return \"\\f\" // 'f' -> '\\f'\n  case 13: if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; } // '\\r\\n'\n  case 10: // ' \\n'\n    if (this.options.locations) { this.lineStart = this.pos; ++this.curLine; }\n    return \"\"\n  case 56:\n  case 57:\n    if (inTemplate) {\n      var codePos = this.pos - 1;\n\n      this.invalidStringToken(\n        codePos,\n        \"Invalid escape sequence in template string\"\n      );\n\n      return null\n    }\n  default:\n    if (ch >= 48 && ch <= 55) {\n      var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];\n      var octal = parseInt(octalStr, 8);\n      if (octal > 255) {\n        octalStr = octalStr.slice(0, -1);\n        octal = parseInt(octalStr, 8);\n      }\n      this.pos += octalStr.length - 1;\n      ch = this.input.charCodeAt(this.pos);\n      if ((octalStr !== \"0\" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {\n        this.invalidStringToken(\n          this.pos - 1 - octalStr.length,\n          inTemplate\n            ? \"Octal literal in template string\"\n            : \"Octal literal in strict mode\"\n        );\n      }\n      return String.fromCharCode(octal)\n    }\n    if (isNewLine(ch)) {\n      // Unicode new line characters after \\ get removed from output in both\n      // template literals and strings\n      return \"\"\n    }\n    return String.fromCharCode(ch)\n  }\n};\n\n// Used to read character escape sequences ('\\x', '\\u', '\\U').\n\npp$9.readHexChar = function(len) {\n  var codePos = this.pos;\n  var n = this.readInt(16, len);\n  if (n === null) { this.invalidStringToken(codePos, \"Bad character escape sequence\"); }\n  return n\n};\n\n// Read an identifier, and return it as a string. Sets `this.containsEsc`\n// to whether the word contained a '\\u' escape.\n//\n// Incrementally adds only escaped chars, adding other chunks as-is\n// as a micro-optimization.\n\npp$9.readWord1 = function() {\n  this.containsEsc = false;\n  var word = \"\", first = true, chunkStart = this.pos;\n  var astral = this.options.ecmaVersion >= 6;\n  while (this.pos < this.input.length) {\n    var ch = this.fullCharCodeAtPos();\n    if (isIdentifierChar(ch, astral)) {\n      this.pos += ch <= 0xffff ? 1 : 2;\n    } else if (ch === 92) { // \"\\\"\n      this.containsEsc = true;\n      word += this.input.slice(chunkStart, this.pos);\n      var escStart = this.pos;\n      if (this.input.charCodeAt(++this.pos) !== 117) // \"u\"\n        { this.invalidStringToken(this.pos, \"Expecting Unicode escape sequence \\\\uXXXX\"); }\n      ++this.pos;\n      var esc = this.readCodePoint();\n      if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral))\n        { this.invalidStringToken(escStart, \"Invalid Unicode escape\"); }\n      word += codePointToString$1(esc);\n      chunkStart = this.pos;\n    } else {\n      break\n    }\n    first = false;\n  }\n  return word + this.input.slice(chunkStart, this.pos)\n};\n\n// Read an identifier or keyword token. Will check for reserved\n// words when necessary.\n\npp$9.readWord = function() {\n  var word = this.readWord1();\n  var type = types.name;\n  if (this.keywords.test(word)) {\n    type = keywords$1[word];\n  }\n  return this.finishToken(type, word)\n};\n\n// Acorn is a tiny, fast JavaScript parser written in JavaScript.\n\nvar version = \"7.4.0\";\n\nParser.acorn = {\n  Parser: Parser,\n  version: version,\n  defaultOptions: defaultOptions,\n  Position: Position,\n  SourceLocation: SourceLocation,\n  getLineInfo: getLineInfo,\n  Node: Node,\n  TokenType: TokenType,\n  tokTypes: types,\n  keywordTypes: keywords$1,\n  TokContext: TokContext,\n  tokContexts: types$1,\n  isIdentifierChar: isIdentifierChar,\n  isIdentifierStart: isIdentifierStart,\n  Token: Token,\n  isNewLine: isNewLine,\n  lineBreak: lineBreak,\n  lineBreakG: lineBreakG,\n  nonASCIIwhitespace: nonASCIIwhitespace\n};\n\n// The main exported interface (under `self.acorn` when in the\n// browser) is a `parse` function that takes a code string and\n// returns an abstract syntax tree as specified by [Mozilla parser\n// API][api].\n//\n// [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API\n\nfunction parse(input, options) {\n  return Parser.parse(input, options)\n}\n\n// This function tries to parse a single expression at a given\n// offset in a string. Useful for parsing mixed-language formats\n// that embed JavaScript expressions.\n\nfunction parseExpressionAt(input, pos, options) {\n  return Parser.parseExpressionAt(input, pos, options)\n}\n\n// Acorn is organized as a tokenizer and a recursive-descent parser.\n// The `tokenizer` export provides an interface to the tokenizer.\n\nfunction tokenizer(input, options) {\n  return Parser.tokenizer(input, options)\n}\n\nexport { Node, Parser, Position, SourceLocation, TokContext, Token, TokenType, defaultOptions, getLineInfo, isIdentifierChar, isIdentifierStart, isNewLine, keywords$1 as keywordTypes, lineBreak, lineBreakG, nonASCIIwhitespace, parse, parseExpressionAt, types$1 as tokContexts, types as tokTypes, tokenizer, version };\n","abstract class BaseError extends Error {\n  readonly name = this.constructor.name;\n}\n\nexport class GraphBuildError extends BaseError {\n  constructor(readonly errors: Error[]) {\n    super(\n      `Graph building failed with errors:\\n${errors.map((err) => `  ${err.message}`).join('\\n')}`\n    );\n  }\n}\n","var charToInteger = {};\nvar chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\nfor (var i = 0; i < chars.length; i++) {\n    charToInteger[chars.charCodeAt(i)] = i;\n}\nfunction decode(mappings) {\n    var decoded = [];\n    var line = [];\n    var segment = [\n        0,\n        0,\n        0,\n        0,\n        0,\n    ];\n    var j = 0;\n    for (var i = 0, shift = 0, value = 0; i < mappings.length; i++) {\n        var c = mappings.charCodeAt(i);\n        if (c === 44) { // \",\"\n            segmentify(line, segment, j);\n            j = 0;\n        }\n        else if (c === 59) { // \";\"\n            segmentify(line, segment, j);\n            j = 0;\n            decoded.push(line);\n            line = [];\n            segment[0] = 0;\n        }\n        else {\n            var integer = charToInteger[c];\n            if (integer === undefined) {\n                throw new Error('Invalid character (' + String.fromCharCode(c) + ')');\n            }\n            var hasContinuationBit = integer & 32;\n            integer &= 31;\n            value += integer << shift;\n            if (hasContinuationBit) {\n                shift += 5;\n            }\n            else {\n                var shouldNegate = value & 1;\n                value >>>= 1;\n                if (shouldNegate) {\n                    value = value === 0 ? -0x80000000 : -value;\n                }\n                segment[j] += value;\n                j++;\n                value = shift = 0; // reset\n            }\n        }\n    }\n    segmentify(line, segment, j);\n    decoded.push(line);\n    return decoded;\n}\nfunction segmentify(line, segment, j) {\n    // This looks ugly, but we're creating specialized arrays with a specific\n    // length. This is much faster than creating a new array (which v8 expands to\n    // a capacity of 17 after pushing the first item), or slicing out a subarray\n    // (which is slow). Length 4 is assumed to be the most frequent, followed by\n    // length 5 (since not everything will have an associated name), followed by\n    // length 1 (it's probably rare for a source substring to not have an\n    // associated segment data).\n    if (j === 4)\n        line.push([segment[0], segment[1], segment[2], segment[3]]);\n    else if (j === 5)\n        line.push([segment[0], segment[1], segment[2], segment[3], segment[4]]);\n    else if (j === 1)\n        line.push([segment[0]]);\n}\nfunction encode(decoded) {\n    var sourceFileIndex = 0; // second field\n    var sourceCodeLine = 0; // third field\n    var sourceCodeColumn = 0; // fourth field\n    var nameIndex = 0; // fifth field\n    var mappings = '';\n    for (var i = 0; i < decoded.length; i++) {\n        var line = decoded[i];\n        if (i > 0)\n            mappings += ';';\n        if (line.length === 0)\n            continue;\n        var generatedCodeColumn = 0; // first field\n        var lineMappings = [];\n        for (var _i = 0, line_1 = line; _i < line_1.length; _i++) {\n            var segment = line_1[_i];\n            var segmentMappings = encodeInteger(segment[0] - generatedCodeColumn);\n            generatedCodeColumn = segment[0];\n            if (segment.length > 1) {\n                segmentMappings +=\n                    encodeInteger(segment[1] - sourceFileIndex) +\n                        encodeInteger(segment[2] - sourceCodeLine) +\n                        encodeInteger(segment[3] - sourceCodeColumn);\n                sourceFileIndex = segment[1];\n                sourceCodeLine = segment[2];\n                sourceCodeColumn = segment[3];\n            }\n            if (segment.length === 5) {\n                segmentMappings += encodeInteger(segment[4] - nameIndex);\n                nameIndex = segment[4];\n            }\n            lineMappings.push(segmentMappings);\n        }\n        mappings += lineMappings.join(',');\n    }\n    return mappings;\n}\nfunction encodeInteger(num) {\n    var result = '';\n    num = num < 0 ? (-num << 1) | 1 : num << 1;\n    do {\n        var clamped = num & 31;\n        num >>>= 5;\n        if (num > 0) {\n            clamped |= 32;\n        }\n        result += chars[clamped];\n    } while (num > 0);\n    return result;\n}\n\nexport { decode, encode };\n//# sourceMappingURL=sourcemap-codec.es.js.map\n","import { Base64 } from '@velcro/common';\nimport type { DecodedSourceMap } from 'magic-string';\nimport { decode } from 'sourcemap-codec';\n\nexport class SourceMap {\n  readonly file?: string;\n  readonly mappings: string;\n  readonly sourceRoot?: string;\n  readonly names: string[];\n  readonly sources: (string | null)[];\n  readonly sourcesContent?: (string | null)[];\n  readonly version: number;\n\n  constructor(input: {\n    file?: string;\n    mappings: string;\n    sourceRoot?: string;\n    names: string[];\n    sources: (string | null)[];\n    sourcesContent?: (string | null)[];\n    version: string | number;\n  }) {\n    this.file = input.file;\n    this.mappings = input.mappings;\n    this.sourceRoot = input.sourceRoot;\n    this.names = input.names;\n    this.sources = input.sources;\n    this.sourcesContent = input.sourcesContent;\n    this.version = input.version as number | 0;\n  }\n\n  toString() {\n    return JSON.stringify(this);\n  }\n\n  toDataUri() {\n    return `data:application/json;charset=utf-8;base64,${Base64.encode(this.toString())}`;\n  }\n}\n\nfunction getSourceMappingUrlMatch(str: string) {\n  const re = /(?:(?:\\/\\/|\\/\\*)[@#][\\s]*(?:source)MappingURL=([^\\s'\"]+)[\\s]*$)|(?:\\/\\*[@#][\\s]*(?:source)MappingURL=([^\\s*'\"]+)[\\s]*(?:\\*\\/)[\\s]*$)/gm;\n  // Keep executing the search to find the *last* sourceMappingURL to avoid\n  // picking up sourceMappingURLs from comments, strings, etc.\n  let lastMatch: RegExpExecArray | null = null;\n  let match: RegExpExecArray | null;\n\n  while ((match = re.exec(str))) lastMatch = match;\n\n  return lastMatch;\n}\n\nexport function getSourceMappingUrl(str: string) {\n  const lastMatch = getSourceMappingUrlMatch(str);\n\n  if (!lastMatch) return '';\n\n  return lastMatch[1];\n}\n\nexport function updateSourceMappingUrl(str: string, url: string) {\n  const lastMatch = getSourceMappingUrlMatch(str);\n\n  if (!lastMatch) return str;\n\n  return str.slice(0, lastMatch.index) + str.slice(lastMatch.index).replace(lastMatch[1], url);\n}\n\nexport function decodeDataUriAsSourceMap(href: string): DecodedSourceMap | null {\n  const match = href.match(/^data:application\\/json;(?:charset=([^;]+);)?base64,(.*)$/);\n\n  if (match) {\n    if (match[1] && match[1] !== 'utf-8') {\n      return null;\n    }\n\n    try {\n      const decoded = JSON.parse(Base64.decode(match[2]));\n\n      if (decoded.mappings === '') {\n        return {\n          file: '',\n          mappings: [],\n          names: [],\n          sources: [],\n          sourcesContent: [],\n        };\n      }\n\n      if (typeof decoded.mappings === 'string') {\n        decoded.mappings = decode(decoded.mappings);\n      }\n\n      return decoded;\n    } catch (err) {\n      return null;\n    }\n  }\n\n  return null;\n}\n","import type { SourceMapSegment } from 'magic-string';\nimport { decode } from 'sourcemap-codec';\n\nexport interface ISourceMapper {\n  traceMappings(): ReturnType<typeof traceMappings>;\n}\n\n/**\n * Copyright (c) Rollup 2020 authors: https://github.com/rollup/rollup/graphs/contributors)\n *\n * Copied with light modifications from:\n * https://github.com/rollup/rollup/blob/36a4527473ea1fe678ed866c9f8dfd3c2542cd22/src/utils/collapseSourcemaps.ts\n */\n\nexport class Source {\n  content: string | null;\n  filename: string;\n\n  constructor(filename: string, content: string | null) {\n    this.filename = filename;\n    this.content = content;\n  }\n\n  traceSegment(line: number, column: number, name?: string): SourceMapSegmentObject {\n    return { line, column, name, source: this };\n  }\n}\n\ninterface SourceMapSegmentObject {\n  column: number;\n  line: number;\n  name?: string;\n  source: Source;\n}\n\nexport class Link {\n  mappings: SourceMapSegment[][];\n  names: string[];\n  sources: (Source | Link)[];\n\n  constructor(\n    map: { mappings: SourceMapSegment[][] | string; names: string[] },\n    sources: (Source | Link)[]\n  ) {\n    this.sources = sources;\n    this.names = map.names;\n    this.mappings = typeof map.mappings === 'string' ? decode(map.mappings) : map.mappings;\n  }\n\n  traceMappings() {\n    return traceMappings(this);\n  }\n\n  traceSegment(line: number, column: number, name: string): SourceMapSegmentObject | null {\n    return traceSegment(this, line, column, name);\n  }\n}\n\nexport class LazyLink {\n  private link?: Link = undefined;\n\n  constructor(private readonly loadLink: () => Link) {}\n\n  private getLink() {\n    let link = this.link;\n\n    if (!link) {\n      link = this.loadLink();\n      this.link = link;\n    }\n\n    return link;\n  }\n\n  traceMappings() {\n    return traceMappings(this.getLink());\n  }\n\n  traceSegment(line: number, column: number, name: string): SourceMapSegmentObject | null {\n    return traceSegment(this.getLink(), line, column, name);\n  }\n}\n\nfunction traceMappings(\n  this: void,\n  map: { mappings: SourceMapSegment[][]; names: string[]; sources: (Link | Source)[] }\n) {\n  const sources: string[] = [];\n  const sourcesContent: (string | null)[] = [];\n  const names: string[] = [];\n  const mappings = [];\n\n  for (const line of map.mappings) {\n    const tracedLine: SourceMapSegment[] = [];\n\n    for (const segment of line) {\n      if (segment.length == 1) continue;\n      const source = map.sources[segment[1]];\n      if (!source) continue;\n\n      const traced = source.traceSegment(\n        segment[2],\n        segment[3],\n        segment.length === 5 ? map.names[segment[4]] : ''\n      );\n\n      if (traced) {\n        // newer sources are more likely to be used, so search backwards.\n        let sourceIndex = sources.lastIndexOf(traced.source.filename);\n        if (sourceIndex === -1) {\n          sourceIndex = sources.length;\n          sources.push(traced.source.filename);\n          sourcesContent[sourceIndex] = traced.source.content;\n        } else if (sourcesContent[sourceIndex] == null) {\n          sourcesContent[sourceIndex] = traced.source.content;\n        } else if (\n          traced.source.content != null &&\n          sourcesContent[sourceIndex] !== traced.source.content\n        ) {\n          return new Error(\n            `Multiple conflicting contents for sourcemap source ${traced.source.filename}`\n          );\n        }\n\n        const tracedSegment: SourceMapSegment = [\n          segment[0],\n          sourceIndex,\n          traced.line,\n          traced.column,\n        ];\n\n        if (traced.name) {\n          let nameIndex = names.indexOf(traced.name);\n          if (nameIndex === -1) {\n            nameIndex = names.length;\n            names.push(traced.name);\n          }\n\n          (tracedSegment as SourceMapSegment)[4] = nameIndex;\n        }\n\n        tracedLine.push(tracedSegment);\n      }\n    }\n\n    mappings.push(tracedLine);\n  }\n\n  return { sources, sourcesContent, names, mappings };\n}\n\nfunction traceSegment(\n  this: void,\n  map: { mappings: SourceMapSegment[][]; names: string[]; sources: (Link | Source)[] },\n  line: number,\n  column: number,\n  name: string\n): SourceMapSegmentObject | null {\n  const segments = map.mappings[line];\n  if (!segments) return null;\n\n  // binary search through segments for the given column\n  let i = 0;\n  let j = segments.length - 1;\n\n  const checks = [];\n\n  while (i <= j) {\n    const m = (i + j) >> 1;\n    const segment = segments[m];\n    checks.push(segment);\n    if (segment[0] === column) {\n      if (segment.length == 1) return null;\n      const source = map.sources[segment[1]];\n      if (!source) return null;\n\n      return source.traceSegment(\n        segment[2],\n        segment[3],\n        segment.length === 5 ? map.names[segment[4]] : name\n      );\n    }\n    if (segment[0] > column) {\n      j = m - 1;\n    } else {\n      i = m + 1;\n    }\n  }\n\n  return null;\n}\n/**\n * This function attempts to compensate for the loss of precision when lower\n * layers of source maps have higher precision than upper layers, leading to\n * a loss of fidelity.\n *\n * The code was lifted from [Alec Larson](https://github.com/aleclarson)'s\n * [fork of sorcery](https://github.com/aleclarson/sorcery/blob/3934a3f38a6d8604fc9dbaa576cbb6e4d733040f/src/blend.js).\n *\n * NOTE: This function mutates the given node.\n *\n * @copyright [Alec Larson](https://github.com/aleclarson) 2018\n */\n// function blend(node: Link) {\n//   let mappings: SourceMapSegment[][] = []; // traced lines\n//   let sources: (Link | Source)[] = []; // traced sources\n//   let names: string[] = []; // traced symbols\n\n//   // Precompute which source/line/column triples are mapped by the given node.\n//   // These references are useful when interweaving old segments.\n//   const refs: number[][][] = Object.keys(node.sources).map(() => []);\n\n//   for (const segments of node.mappings) {\n//     let segment: SourceMapSegment;\n//     let lines: number[][];\n//     let columns: number[];\n//     for (let i = 0; i < segments.length; i++) {\n//       segment = segments[i];\n\n//       if (segment.length === 4 || segment.length === 5) {\n//         lines = refs[segment[1]];\n//         if (!lines) refs[segment[1]] = lines = [];\n\n//         columns = lines[segment[2]];\n//         if (columns) {\n//           uniqueAscendingInsert(columns, segment[3]);\n//         } else {\n//           lines[segment[2]] = [segment[3]];\n//         }\n//       }\n//     }\n//   }\n\n//   let traced: SourceMapSegment[] | undefined = undefined; // the traced line mapping\n//   let untraced: SourceMapSegment[] | undefined = undefined; // the untraced line mapping\n\n//   function addSegment(\n//     segment: SourceMapSegment,\n//     source?: { names: string[]; sources: (Link | Source)[] }\n//   ) {\n//     if (source) {\n//       segment[1] = uniq<Link | Source>(sources, source.sources[segment[1]!]);\n//       if (segment.length === 5) {\n//         segment[4] = uniq(names, source.names[segment[4]]);\n//       }\n//     } else if (segment.length === 5) {\n//       segment[4] = uniq(names, node.names[segment[4]]);\n//     }\n//     traced!.push(segment);\n//   }\n\n//   let tracedLine: number; // the last traced line\n//   let generatedLine = -1; // the current line\n//   let sourceIndex: number | undefined = -1; // source of last traced segment\n//   let sourceLine: number | undefined = undefined; // source line of last traced segment\n\n//   // Find the next line with segments.\n//   function nextLine() {\n//     tracedLine = generatedLine;\n//     while (++generatedLine < node.mappings.length) {\n//       untraced = node.mappings[generatedLine];\n//       if (untraced.length) return true;\n//     }\n//   }\n\n//   // Provide mappings for lines between the\n//   // last traced line and the current line.\n//   function fillSkippedLines() {\n//     const skipped = generatedLine - (tracedLine + 1);\n//     if (skipped !== 0) {\n//       let line = tracedLine;\n\n//       // Take line mappings from the current source.\n//       if (sourceIndex !== -1) {\n//         const source = node.sources[sourceIndex!];\n//         if (source instanceof Link) {\n//           while (line < generatedLine - 1) {\n//             if (++sourceLine! !== source.mappings.length) {\n//               mappings[++line] = traced = [];\n\n//               // Check referenced columns to avoid duplicate segments.\n//               const columns = refs[sourceIndex!][sourceLine!] || [];\n//               let prevColumn = -1;\n\n//               // Interweave old segments from the current source.\n//               const segments = source.mappings[sourceLine!];\n//               for (let i = 0; i < segments.length; i++) {\n//                 const segment = segments[i];\n//                 if (!hasValueBetween(columns, prevColumn, segment[0] + 1)) {\n//                   addSegment([...segment] as SourceMapSegment, source);\n//                   prevColumn = segment[0];\n//                 } else break;\n//               }\n//             } else {\n//               // End of source file.\n//               sourceIndex = -1;\n//               break;\n//             }\n//           }\n//         }\n//       }\n\n//       // Default to empty arrays for unmapped lines.\n//       while (++line < generatedLine) {\n//         mappings[line] = [];\n//       }\n//     }\n//   }\n\n//   while (nextLine()) {\n//     fillSkippedLines();\n\n//     // Trace the segments of this generated line.\n//     mappings[generatedLine] = traced = [];\n\n//     // Interweave old segments before the first mapped column of each line.\n//     const sourceColumn = untraced![0][3];\n//     if (sourceIndex !== -1 && sourceColumn !== 0) {\n//       const source = node.sources[sourceIndex];\n//       if (source instanceof Link) {\n//         const segments =\n//           sourceLine! < source.mappings.length - 1 ? source.mappings[++sourceLine!] : [];\n\n//         for (let i = 0; i < segments.length; i++) {\n//           const segment = segments[i];\n//           if (segment[0] < sourceColumn!) {\n//             addSegment(segment.slice(0) as SourceMapSegment, source);\n//           } else break;\n//         }\n//       }\n//     }\n\n//     const last = untraced!.length - 1;\n//     untraced!.forEach((curr: SourceMapSegment | null, i) => {\n//       [, sourceIndex, sourceLine] = curr!;\n\n//       const source = node.sources[sourceIndex!];\n//       if (source === null) {\n//         curr![1] = uniq(sources, null);\n//         return addSegment(curr!);\n//       }\n//       if (!(source instanceof Link)) {\n//         curr![1] = uniq(sources, source);\n//         return addSegment(curr!);\n//       }\n\n//       const next = i !== last ? untraced![i + 1] : null;\n//       const sourceColumn = curr![3];\n//       const generatedColumn = curr![0];\n\n//       // Find the first segment with a greater column.\n//       const segments = source.mappings[sourceLine!] || [];\n//       let j = findGreaterColumn(segments, sourceColumn!);\n\n//       // A \"base segment\" is required for tracing to a grand-parent.\n//       let base;\n//       if (--j !== -1) {\n//         base = segments[j];\n//         curr![1] = uniq(sources, source.sources[base[1]!]);\n//         curr![2] = base[2];\n//         curr![3] = base[3]! + sourceColumn! - base[0];\n//         if (base.length === 5) {\n//           // Inherit the names of aligned base segments.\n//           if (base[0] === sourceColumn) {\n//             curr![4] = uniq(names, source.names[base[4]!]);\n//           }\n//         } else if (curr!.length === 5) {\n//           // When our segment is named and the base segment is not,\n//           // assume this segment cannot be traced to its original source.\n//           if (base[0] !== sourceColumn) curr = null;\n//         }\n//       } else {\n//         curr![1] = uniq(sources, null);\n//       }\n\n//       curr && addSegment(curr);\n\n//       // Check referenced columns to avoid duplicate segments.\n//       const columns = refs[sourceIndex!][sourceLine!] || [];\n//       let baseColumn = base ? base[0] : -1;\n\n//       // Interweave old segments between our current and next segments.\n//       const nextColumn = next ? next[0] : 1 / 0;\n//       while (++j < segments.length) {\n//         let segment = segments[j];\n\n//         // The generated column is shifted to fit into the root source map.\n//         const column = segment[0] + generatedColumn - sourceColumn!;\n//         if (column >= nextColumn) break;\n\n//         // Avoid duplicates by checking if this segment goes elsewhere.\n//         if (!hasValueBetween(columns, baseColumn, segment[0] + 1)) {\n//           baseColumn = segment[0];\n//           segment = segment.slice(0) as SourceMapSegment;\n//           segment[0] = column;\n//           addSegment(segment, source);\n//         } else break;\n//       }\n//     });\n//   }\n//   fillSkippedLines();\n\n//   node.mappings = mappings;\n//   node.sources = sources;\n//   node.names = names;\n//   return node;\n// }\n\n// // Check if a value exists before pushing it to an array.\n// // Return the new or existing index of the value.\n// function uniq<T>(arr: T[], val: T): number {\n//   const i = arr.indexOf(val);\n//   return ~i ? i : arr.push(val) - 1;\n// }\n\n// // Get the first segment with a greater column.\n// function findGreaterColumn(segments: SourceMapSegment[], column: number) {\n//   let low = 0,\n//     high = segments.length;\n//   while (low < high) {\n//     const mid = (low + high) >>> 1;\n//     segments[mid][0] <= column ? (low = mid + 1) : (high = mid);\n//   }\n//   return low;\n// }\n\n// // The range is exclusive.\n// function hasValueBetween(arr: number[], start: number, end: number) {\n//   let low = 0,\n//     high = arr.length;\n//   while (low < high) {\n//     const mid = (low + high) >>> 1;\n//     const val = arr[mid];\n//     if (val <= start) {\n//       low = mid + 1;\n//     } else if (val >= end) {\n//       high = mid;\n//     } else {\n//       return true;\n//     }\n//   }\n//   return false;\n// }\n\n// // Insert unique values in ascending order.\n// function uniqueAscendingInsert(arr: number[], val: number) {\n//   let low = 0,\n//     high = arr.length;\n//   while (low < high) {\n//     const mid = (low + high) >>> 1;\n//     const x = arr[mid];\n//     if (x === val) return;\n//     if (x < val) {\n//       low = mid + 1;\n//     } else {\n//       high = mid;\n//     }\n//   }\n//   arr.splice(low, 0, val);\n// }\n","import type { Uri } from '@velcro/common';\n\nexport enum SourceModuleDependencyKind {\n  Entrypoint = 'Entrypoint',\n  Require = 'Require',\n  RequireResolve = 'RequireResolve',\n  GlobalObject = 'GlobalObject',\n}\n\ninterface SourceModuleOptions {\n  exportName?: string;\n}\n\ntype SourceLocation = { start: number; end: number };\n\nexport class SourceModuleDependency {\n  locator?: { name: string; spec: string; path: string; version?: string };\n\n  constructor(\n    readonly kind: SourceModuleDependencyKind,\n    readonly spec: string,\n    readonly locations: ReadonlyArray<SourceLocation>,\n    readonly options: SourceModuleOptions = {}\n  ) {}\n\n  static areIdentical(l: SourceModuleDependency, r: SourceModuleDependency) {\n    return l.kind === r.kind && l.spec === r.spec;\n  }\n\n  static fromEntrypoint(uri: Uri) {\n    return new SourceModuleDependency(SourceModuleDependencyKind.Entrypoint, uri.toString(), []);\n  }\n\n  static fromGlobalObject(spec: string, locations: SourceLocation[], exportName?: string) {\n    return new SourceModuleDependency(SourceModuleDependencyKind.GlobalObject, spec, locations, {\n      exportName,\n    });\n  }\n\n  static fromRequire(spec: string, locations: SourceLocation[]) {\n    return new SourceModuleDependency(SourceModuleDependencyKind.Require, spec, locations);\n  }\n\n  static fromRequireResolve(spec: string, locations: SourceLocation[]) {\n    return new SourceModuleDependency(SourceModuleDependencyKind.RequireResolve, spec, locations);\n  }\n}\n","import {\n  checkCancellation,\n  DependencyNotFoundError,\n  EntryExcludedError,\n  EntryNotFoundError,\n  isThenable,\n  Uri,\n} from '@velcro/common';\nimport type { ResolverContext } from '@velcro/resolver';\nimport MagicString from 'magic-string';\nimport type { DecodedSourceMap, SourceMap } from 'magic-string';\nimport {\n  decodeDataUriAsSourceMap,\n  getSourceMappingUrl,\n  updateSourceMappingUrl,\n} from '../build/sourceMap';\nimport { Link, Source } from '../build/sourceMapTree';\nimport type { SourceModule, SourceModuleDependency } from '../graph';\nimport type {\n  Plugin,\n  PluginLoadContext,\n  PluginResolveDependencyContext,\n  PluginResolveEntrypointContext,\n  PluginTransformContext,\n} from './plugin';\n\nexport class PluginManager {\n  constructor(private readonly plugins: Plugin[]) {\n    this.plugins.push({\n      name: 'builtIn',\n      load: async (ctx, id) => {\n        const uri = Uri.parse(id);\n        const readReturn = ctx.resolver.readFileContent(uri);\n        const readResult = isThenable(readReturn)\n          ? await checkCancellation(readReturn, ctx.token)\n          : readReturn;\n\n        return {\n          code: ctx.resolver.decode(readResult.content),\n          visited: readResult.visited,\n        };\n      },\n      resolveDependency: async (ctx, dependency, fromSourceModule) => {\n        const resolveReturn = ctx.resolver.resolve(dependency.spec, fromSourceModule.uri);\n        const resolveResult = isThenable(resolveReturn)\n          ? await checkCancellation(resolveReturn, ctx.token)\n          : resolveReturn;\n\n        if (!resolveResult.found) {\n          throw new DependencyNotFoundError(dependency.spec, fromSourceModule);\n        }\n\n        if (!resolveResult.uri) {\n          // TODO: Inject empty module\n          throw new EntryExcludedError(dependency.spec);\n        }\n\n        return {\n          uri: resolveResult.uri,\n          rootUri: resolveResult.rootUri,\n          visited: resolveResult.visited,\n        };\n      },\n      resolveEntrypoint: async (ctx, uri) => {\n        const resolveResult = await ctx.resolver.resolve(uri);\n\n        if (!resolveResult.found) {\n          throw new EntryNotFoundError(`Entry point not found: ${uri}`);\n        }\n\n        if (!resolveResult.uri) {\n          throw new EntryExcludedError(uri);\n        }\n\n        return resolveResult;\n      },\n      transform: async ({ createMagicString }, id) => {\n        if (id.path.endsWith('.json')) {\n          const magicString = createMagicString();\n          magicString.prepend('module.exports = ');\n\n          return {\n            code: magicString.toString(),\n            sourceMap: magicString.generateDecodedMap(),\n          };\n        }\n      },\n    });\n  }\n\n  async executeLoad(ctx: PluginLoadContext, uri: Uri) {\n    for (const plugin of this.plugins) {\n      if (typeof plugin.load === 'function') {\n        const loadReturn = plugin.load(ctx, uri.toString());\n        const loadResult = isThenable(loadReturn)\n          ? await checkCancellation(loadReturn, ctx.token)\n          : loadReturn;\n\n        if (!loadResult) {\n          continue;\n        }\n\n        return {\n          code: loadResult.code,\n          visited: loadResult.visited || [],\n        };\n      }\n    }\n\n    throw new Error(`No plugin was found that was able to load the uri ${uri.toString()}`);\n  }\n\n  async executeResolveDependency(\n    ctx: PluginResolveDependencyContext,\n    dependency: SourceModuleDependency,\n    fromModule: SourceModule\n  ) {\n    for (const plugin of this.plugins) {\n      if (typeof plugin.resolveDependency === 'function') {\n        const loadReturn = plugin.resolveDependency(ctx, dependency, fromModule);\n        const loadResult = isThenable(loadReturn)\n          ? await checkCancellation(loadReturn, ctx.token)\n          : loadReturn;\n\n        if (!loadResult) {\n          continue;\n        }\n\n        return {\n          uri: loadResult.uri,\n          rootUri: loadResult.rootUri,\n          visited: loadResult.visited || [],\n        };\n      }\n    }\n\n    throw new Error(\n      `No plugin was able to resolve the '${dependency.kind}' dependency, '${dependency.spec}' from '${fromModule.href}'`\n    );\n  }\n\n  async executeResolveEntrypoint(ctx: PluginResolveEntrypointContext, uri: Uri) {\n    for (const plugin of this.plugins) {\n      if (typeof plugin.resolveEntrypoint === 'function') {\n        const loadReturn = plugin.resolveEntrypoint(ctx, uri);\n        const loadResult = isThenable(loadReturn)\n          ? await checkCancellation(loadReturn, ctx.token)\n          : loadReturn;\n\n        if (!loadResult) {\n          continue;\n        }\n\n        return {\n          uri: loadResult.uri,\n          rootUri: loadResult.rootUri,\n          visited: loadResult.visited || [],\n        };\n      }\n    }\n\n    throw new Error(`No plugin was able to resolve the entrypoint '${uri.toString()}'`);\n  }\n\n  async executeTransform(\n    ctx: Omit<PluginTransformContext, 'createMagicString'>,\n    uri: Uri,\n    code: string | ArrayBuffer\n  ) {\n    if (typeof code !== 'string') {\n      code = ctx.resolver.decode(code);\n    }\n\n    const pluginCtx: PluginTransformContext = Object.assign(ctx, {\n      createMagicString() {\n        return new MagicString(code as string);\n      },\n    });\n\n    let sourceMapTree: Source | Link = new Source(uri.toString(), code);\n\n    // Figure out if our original code, itself has a sourcemap.\n    // For now, we will not recurse beyond that depth.\n    const sourceMapRef = getSourceMappingUrl(code);\n    if (sourceMapRef) {\n      let sourceMap: DecodedSourceMap | SourceMap | null = decodeDataUriAsSourceMap(sourceMapRef);\n\n      if (!sourceMap) {\n        const sourceMapUri = Uri.joinPath(uri, `../${sourceMapRef}`);\n\n        code = updateSourceMappingUrl(code, sourceMapUri.toString());\n      }\n\n      if (sourceMap) {\n        const sources = sourceMap.sources;\n        const sourcesContent = sourceMap.sourcesContent || [];\n        const baseSources = [] as Source[];\n\n        for (const idx in sources) {\n          if (sources[idx] && sourcesContent[idx]) {\n            baseSources.push(new Source(sources[idx]!, sourcesContent[idx]!));\n          }\n        }\n\n        sourceMapTree = new Link(sourceMap, baseSources);\n      }\n    }\n\n    const visited = [] as ResolverContext.Visit[];\n\n    for (const plugin of this.plugins) {\n      if (typeof plugin.transform === 'function') {\n        const transformReturn = plugin.transform(pluginCtx, uri, code);\n        const transformResult = isThenable(transformReturn)\n          ? await checkCancellation(transformReturn, ctx.token)\n          : transformReturn;\n\n        if (transformResult === null || transformResult === undefined) {\n          continue;\n        }\n\n        if (transformResult.sourceMap) {\n          sourceMapTree = new Link(transformResult.sourceMap, [sourceMapTree]);\n        }\n\n        code = transformResult.code;\n\n        if (transformResult.visited) {\n          visited.push(...transformResult.visited);\n        }\n      }\n    }\n\n    return {\n      code,\n      sourceMapTree,\n      visited,\n    };\n  }\n}\n","import * as Acorn from 'acorn';\nimport type {\n  ArrayPattern,\n  ArrowFunctionExpression,\n  AssignmentPattern,\n  BinaryExpression,\n  BlockStatement,\n  CallExpression,\n  ClassDeclaration,\n  Function,\n  FunctionDeclaration,\n  FunctionExpression,\n  Identifier,\n  IfStatement,\n  Literal,\n  MemberExpression,\n  Node,\n  ObjectPattern,\n  Program,\n  Property,\n  RestElement,\n  SimpleLiteral,\n  TemplateLiteral,\n  ThisExpression,\n  TryStatement,\n  UnaryExpression,\n  VariableDeclaration,\n} from 'estree';\n\nexport type NodeWithParent<TNode = Node> = TNode & {\n  parent: NodeWithParent | null;\n};\n\nexport interface StringLiteral extends SimpleLiteral {\n  value: string;\n}\n\nexport function isArrowFunctionExpression(node: Node): node is ArrowFunctionExpression {\n  return node.type === 'ArrowFunctionExpression';\n}\n\nexport function isArrayPattern(node: Node): node is ArrayPattern {\n  return node.type === 'ArrayPattern';\n}\n\nexport function isAssignmentPattern(node: Node): node is AssignmentPattern {\n  return node.type === 'AssignmentPattern';\n}\n\nexport function isBinaryExpression(node: Node): node is BinaryExpression {\n  return node.type === 'BinaryExpression';\n}\n\nexport function isBlockStatement(node: Node): node is BlockStatement {\n  return node.type === 'BlockStatement';\n}\n\nexport function isCallExpression(node: Node): node is CallExpression {\n  return node.type === 'CallExpression';\n}\n\nexport function isClassDeclaration(node: Node): node is ClassDeclaration {\n  return node.type === 'ClassDeclaration';\n}\n\nexport function isFunctionDeclaration(node: Node): node is FunctionDeclaration {\n  return node.type === 'FunctionDeclaration';\n}\n\nexport function isFunctionExpression(node: Node): node is FunctionExpression {\n  return node.type === 'FunctionExpression';\n}\n\nexport function isIdentifier(node: Node): node is Identifier {\n  return node.type === 'Identifier';\n}\n\nexport function isIfStatement(node: Node): node is IfStatement {\n  return node.type === 'IfStatement';\n}\n\nexport function isLiteral(node: Node): node is Literal {\n  return node.type === 'Literal';\n}\n\nexport function isMemberExpression(node: Node): node is MemberExpression {\n  return node.type === 'MemberExpression';\n}\n\nexport function isMethodDefinition(node: Node): node is MemberExpression {\n  return node.type === 'MethodDefinition';\n}\n\nexport function isObjectPattern(node: Node): node is ObjectPattern {\n  return node.type === 'ObjectPattern';\n}\n\nexport function isProperty(node: Node): node is Property {\n  return node.type === 'Property';\n}\n\nexport function isRestElement(node: Node): node is RestElement {\n  return node.type === 'RestElement';\n}\n\nexport function isProgram(node: Node): node is Program {\n  return node.type === 'Program';\n}\n\nexport function isTemplateLiteral(node: Node): node is TemplateLiteral {\n  return node.type === 'TemplateLiteral';\n}\n\nexport function isThisExpression(node: Node): node is ThisExpression {\n  return node.type === 'ThisExpression';\n}\n\nexport function isTryStatement(node: Node): node is TryStatement {\n  return node.type === 'TryStatement';\n}\n\nexport function isUnaryExpression(node: Node): node is UnaryExpression {\n  return node.type === 'UnaryExpression';\n}\n\nexport function isVariableDeclaration(node: Node): node is VariableDeclaration {\n  return node.type === 'VariableDeclaration';\n}\n\n// Refinements or groups\nexport function isFunction(node: Node): node is Function {\n  return (\n    isFunctionDeclaration(node) || isFunctionExpression(node) || isArrowFunctionExpression(node)\n  );\n}\n\nexport function isStringLiteral(node: Node): node is StringLiteral {\n  return isLiteral(node) && typeof node.value === 'string';\n}\n\nexport function parse(code: string, options?: acorn.Options) {\n  return (Acorn.parse(code, {\n    ...options,\n    allowReturnOutsideFunction: true,\n    sourceType: 'script',\n  }) as any) as Program;\n}\n","import type { Node } from 'estree';\nimport type { NodeWithParent } from './ast';\n\ntype VisitorContext = {\n  skip(): void;\n};\n\ntype EnterFunction<TContext> = (\n  this: VisitorContext,\n  node: NodeWithParent,\n  parent: NodeWithParent | null,\n  ctx: TContext,\n  prop?: string,\n  index?: number\n) => void;\ntype LeaveFunction<TContext> = (\n  node: NodeWithParent,\n  parent: NodeWithParent | null,\n  ctx: TContext,\n  prop?: string,\n  index?: number\n) => void;\n\nexport type Visitor<TContext> = {\n  enter?: EnterFunction<TContext>;\n  leave?: LeaveFunction<TContext>;\n};\n\nexport function traverse<TContext>(ast: Node, ctx: TContext, { enter, leave }: Visitor<TContext>) {\n  visit(ast as NodeWithParent, null, ctx, enter, leave);\n}\n\nlet shouldSkip = false;\nconst context = { skip: () => (shouldSkip = true) };\n\nexport const childKeys: {\n  [key: string]: string[];\n} = {};\n\nfunction visit<TContext>(\n  node: NodeWithParent,\n  parent: NodeWithParent | null,\n  ctx: TContext,\n  enter?: EnterFunction<TContext>,\n  leave?: LeaveFunction<TContext>\n  // prop?: string,\n  // index?: number\n) {\n  if (!node) return;\n\n  node.parent = parent;\n\n  if (enter) {\n    const _shouldSkip = shouldSkip;\n    shouldSkip = false;\n    enter.call(context, node, parent, ctx);\n    const skipped = shouldSkip;\n    shouldSkip = _shouldSkip;\n\n    if (skipped) return;\n  }\n\n  const keys =\n    childKeys[node.type] ||\n    (childKeys[node.type] = Object.keys(node).filter(\n      (key) => key !== 'parent' && typeof (node as any)[key] === 'object'\n    ));\n\n  const children = [] as NodeWithParent[];\n\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    const value = (node as any)[key] as NodeWithParent | NodeWithParent[];\n\n    if (Array.isArray(value)) {\n      for (let j = 0; j < value.length; j++) {\n        if (value[j]) children.push(value[j]);\n      }\n    } else if (value && value.type) {\n      children.push(value);\n    }\n  }\n\n  children.sort((a, b) => a.start - b.start);\n\n  for (const child of children) {\n    visit(child, node, ctx, enter, leave);\n  }\n\n  if (leave) {\n    leave(node, parent, ctx);\n  }\n}\n","import type { Uri } from '@velcro/common';\nimport type { BinaryOperator, Function, Identifier, MemberExpression, Node, Pattern } from 'estree';\nimport MagicString from 'magic-string';\nimport type { ParserFunction } from '../parsing';\nimport type { DEFAULT_SHIM_GLOBALS } from '../shims';\nimport { SourceModuleDependency } from '../sourceModuleDependency';\nimport {\n  isArrayPattern,\n  isArrowFunctionExpression,\n  isAssignmentPattern,\n  isBinaryExpression,\n  isBlockStatement,\n  isCallExpression,\n  isClassDeclaration,\n  isFunction,\n  isFunctionDeclaration,\n  isFunctionExpression,\n  isIdentifier,\n  isIfStatement,\n  isMemberExpression,\n  isMethodDefinition,\n  isObjectPattern,\n  isProgram,\n  isProperty,\n  isRestElement,\n  isStringLiteral,\n  isTemplateLiteral,\n  isThisExpression,\n  isTryStatement,\n  isUnaryExpression,\n  isVariableDeclaration,\n  NodeWithParent,\n  parse as parseAst,\n} from './ast';\nimport { traverse } from './traverse';\nimport type { Visitor } from './traverse';\n\ndeclare module 'estree' {\n  export interface BaseNodeWithoutComments {\n    start: number;\n    end: number;\n  }\n}\n\nexport const parse = function parseJavaScript(\n  uri: Uri,\n  code: string,\n  options: {\n    globalModules: typeof DEFAULT_SHIM_GLOBALS;\n    nodeEnv: string;\n  }\n): ReturnType<ParserFunction> {\n  const visitorCtx: DependencyVisitorContext = {\n    unboundSymbols: new Map(),\n    locals: new Map(),\n    magicString: new MagicString(code, { filename: uri.toString(), indentExclusionRanges: [] }),\n    nodeEnv: options.nodeEnv,\n    replacedSymbols: new Set<Identifier>(),\n    requires: [],\n    requireResolves: [],\n    skip: new Set(),\n    skipTransform: new Set(),\n  };\n  const dependencies = [] as SourceModuleDependency[];\n\n  try {\n    // let lastToken: Token | undefined;\n    const ast = parseAst(code, {\n      // onComment: (_isBlock, _test, start, end) => {\n      //   result.changes.push({ type: 'remove', start, end });\n      // },\n      // onInsertedSemicolon(lastTokEnd) {\n      //   result.changes.push({ type: 'appendRight', position: lastTokEnd, value: ';' });\n      // },\n      // onToken: (token) => {\n      //   const start = lastToken ? lastToken.end + 1 : 0;\n      //   const end = token.start;\n      //   if (end > start) {\n      //     result.changes.push({ type: 'remove', start, end });\n      //   }\n      //   lastToken = token;\n      // },\n    });\n\n    traverse(ast, visitorCtx, scopingAndRequiresVisitor);\n    traverse(ast, visitorCtx, collectGlobalsVisitor);\n  } catch (err) {\n    // console.debug(code);\n    // console.trace(err);\n    throw new Error(`Error parsing ${uri}: ${err.message}`);\n  }\n\n  // Handle explicit requires\n  const requiresBySpec = new Map<string, Array<{ start: number; end: number }>>();\n  for (const requireDependency of visitorCtx.requires) {\n    let locations = requiresBySpec.get(requireDependency.spec.value);\n    if (!locations) {\n      locations = [];\n      requiresBySpec.set(requireDependency.spec.value, locations);\n    }\n\n    locations.push({ start: requireDependency.spec.start, end: requireDependency.spec.end });\n  }\n  for (const [spec, locations] of requiresBySpec) {\n    dependencies.push(SourceModuleDependency.fromRequire(spec, locations));\n  }\n\n  // Handle require.resolve\n  const requireResolvesBySpec = new Map<string, Array<{ start: number; end: number }>>();\n  for (const requireDependency of visitorCtx.requireResolves) {\n    let locations = requiresBySpec.get(requireDependency.spec.value);\n    if (!locations) {\n      locations = [];\n      requiresBySpec.set(requireDependency.spec.value, locations);\n    }\n\n    locations.push({ start: requireDependency.spec.start, end: requireDependency.spec.end });\n  }\n  for (const [spec, locations] of requireResolvesBySpec) {\n    dependencies.push(SourceModuleDependency.fromRequireResolve(spec, locations));\n  }\n\n  for (const [symbolName, locations] of visitorCtx.unboundSymbols) {\n    const shim = options.globalModules[symbolName];\n\n    if (shim) {\n      dependencies.push(SourceModuleDependency.fromGlobalObject(shim.spec, locations, shim.export));\n\n      for (const location of locations) {\n        visitorCtx.magicString.overwrite(\n          location.start,\n          location.end,\n          `require(${JSON.stringify(`${shim.spec}`)})${shim.export ? `.${shim.export}` : ''}`\n        );\n      }\n    }\n  }\n\n  return {\n    code: visitorCtx.magicString,\n    dependencies,\n  };\n};\n\nexport type CommonJsRequire = {\n  callee: { start: number; end: number };\n  spec: { start: number; end: number; value: string };\n};\n\nexport type CommonJsRequireResolve = {\n  callee: { start: number; end: number };\n  spec: { start: number; end: number; value: string };\n};\n\nexport type DependencyVisitorContext = {\n  readonly unboundSymbols: Map<string, Node[]>;\n  readonly locals: Map<Node, { [identifier: string]: boolean }>;\n  readonly magicString: MagicString;\n  readonly nodeEnv: string;\n  readonly requires: CommonJsRequire[];\n  readonly replacedSymbols: Set<Identifier>;\n  readonly requireResolves: CommonJsRequireResolve[];\n  readonly skip: Set<Node>;\n  readonly skipTransform: Set<Node>;\n};\n\nexport const scopingAndRequiresVisitor: Visitor<DependencyVisitorContext> = {\n  enter(node, parent, ctx) {\n    // Get AST-node level locations in the source map\n    ctx.magicString.addSourcemapLocation(node.start);\n    ctx.magicString.addSourcemapLocation(node.end);\n\n    if (ctx.skip.has(node)) {\n      return this.skip();\n    }\n\n    visitAndCaptureScoping(node, parent, ctx);\n    visitAndSkipBranches(node, parent, ctx);\n    visitRequires(node, parent, ctx);\n  },\n  leave(node, _parent, ctx) {\n    let skipped = false;\n    let nextCheck: NodeWithParent<Node> | undefined = node;\n\n    while (nextCheck) {\n      if (ctx.skipTransform.has(nextCheck)) {\n        skipped = true;\n        break;\n      }\n\n      nextCheck = nextCheck.parent as NodeWithParent<Node> | undefined;\n    }\n\n    if (\n      !skipped &&\n      isMemberExpression(node) &&\n      memberExpressionMatches(node, 'process.env.NODE_ENV')\n    ) {\n      ctx.magicString.overwrite(node.start, node.end, JSON.stringify(ctx.nodeEnv), {\n        contentOnly: true,\n        storeName: true,\n      });\n      ctx.skip.add(node);\n      ctx.skipTransform.add(node);\n    }\n  },\n};\n\nexport const collectGlobalsVisitor: Visitor<DependencyVisitorContext> = {\n  enter(node, _parent, ctx) {\n    if (ctx.skip.has(node)) {\n      return this.skip();\n    }\n\n    if (isBindingIdentifier(node) && isIdentifier(node) && !isArgumentOfTypeOf(node)) {\n      var name = node.name;\n      if (name === 'undefined') return;\n      if (ctx.replacedSymbols.has(node)) {\n        return;\n      }\n\n      let foundBinding = false;\n      let nextParent = node.parent;\n\n      while (nextParent) {\n        if (name === 'arguments' && declaresArguments(nextParent)) {\n          foundBinding = true;\n          break;\n        }\n\n        const locals = ctx.locals.get(nextParent);\n\n        if (locals && locals[name]) {\n          foundBinding = true;\n          break;\n        }\n\n        nextParent = nextParent.parent;\n      }\n\n      if (!foundBinding) {\n        let unboundSymbols = ctx.unboundSymbols.get(name);\n        if (!unboundSymbols) {\n          unboundSymbols = [];\n          ctx.unboundSymbols.set(name, unboundSymbols);\n        }\n        unboundSymbols.push(node);\n      }\n    } else if (isThisExpression(node)) {\n      let foundBinding = false;\n      let nextParent = node.parent;\n\n      while (nextParent) {\n        if (declaresThis(nextParent)) {\n          foundBinding = true;\n          break;\n        }\n\n        nextParent = nextParent.parent;\n      }\n\n      if (!foundBinding) {\n        let unboundSymbols = ctx.unboundSymbols.get('this');\n        if (!unboundSymbols) {\n          unboundSymbols = [];\n          ctx.unboundSymbols.set('this', unboundSymbols);\n        }\n        unboundSymbols.push(node);\n      }\n    }\n  },\n};\n\nfunction visitAndCaptureScoping(\n  node: NodeWithParent,\n  _parent: NodeWithParent | null,\n  ctx: DependencyVisitorContext\n) {\n  if (isVariableDeclaration(node)) {\n    let parent: NodeWithParent | undefined;\n    let nextParent = node.parent;\n\n    while (nextParent) {\n      if (node.kind === 'var' ? isScope(nextParent) : isBlockScope(nextParent)) {\n        parent = nextParent;\n        break;\n      }\n\n      nextParent = nextParent.parent;\n    }\n\n    if (!parent) {\n      throw new Error(`Invariant violation: Failed to find a parent`);\n    }\n\n    let locals = ctx.locals.get(parent);\n\n    if (!locals) {\n      locals = {};\n      ctx.locals.set(parent, locals);\n    }\n\n    for (const declaration of node.declarations) {\n      declarePattern(declaration.id, locals);\n    }\n  } else if (isFunctionDeclaration(node)) {\n    let parent: NodeWithParent | undefined;\n    let nextParent = node.parent;\n\n    if (nextParent && nextParent.parent) {\n      nextParent = nextParent.parent;\n    }\n\n    while (nextParent) {\n      if (isScope(nextParent)) {\n        parent = nextParent;\n        break;\n      }\n\n      nextParent = nextParent.parent;\n    }\n\n    if (!parent) {\n      throw new Error(`Invariant violation: Failed to find a parent`);\n    }\n\n    let locals = ctx.locals.get(parent);\n\n    if (!locals) {\n      locals = {};\n      ctx.locals.set(parent, locals);\n    }\n\n    declareFunction(node, locals);\n  } else if (isFunction(node)) {\n    let locals = ctx.locals.get(node);\n\n    if (!locals) {\n      locals = {};\n      ctx.locals.set(node, locals);\n    }\n\n    declareFunction(node, locals);\n  } else if (isClassDeclaration(node) && node.id) {\n    let parent: NodeWithParent | undefined;\n    let nextParent = node.parent;\n\n    if (nextParent && nextParent.parent) {\n      nextParent = nextParent.parent;\n    }\n\n    while (nextParent) {\n      if (isScope(nextParent)) {\n        parent = nextParent;\n        break;\n      }\n\n      nextParent = nextParent.parent;\n    }\n\n    if (!parent) {\n      throw new Error(`Invariant violation: Failed to find a parent`);\n    }\n\n    let locals = ctx.locals.get(parent);\n\n    if (!locals) {\n      locals = {};\n      ctx.locals.set(parent, locals);\n    }\n\n    locals[node.id.name] = true;\n  } else if (isTryStatement(node)) {\n    if (node.handler) {\n      let locals = ctx.locals.get(node.handler);\n\n      if (!locals) {\n        locals = {};\n        ctx.locals.set(node.handler, locals);\n      }\n\n      if (node.handler.param) {\n        declarePattern(node.handler.param, locals);\n      }\n    }\n  }\n}\n\nfunction visitAndSkipBranches(\n  node: NodeWithParent,\n  _parent: NodeWithParent | null,\n  ctx: DependencyVisitorContext\n) {\n  if (isIfStatement(node) && isBinaryExpression(node.test)) {\n    const tests = {\n      '!=': (l: string, r: string) => l != r,\n      '!==': (l: string, r: string) => l !== r,\n      '==': (l: string, r: string) => l == r,\n      '===': (l: string, r: string) => l === r,\n    } as { [key in BinaryOperator]: (l: string, r: string) => boolean };\n    const test = tests[node.test.operator];\n\n    if (test) {\n      if (\n        isStringLiteral(node.test.left) &&\n        isMemberExpression(node.test.right) &&\n        memberExpressionMatches(node.test.right, 'process.env.NODE_ENV')\n      ) {\n        let rootObject = node.test.right;\n        while (isMemberExpression(rootObject.object)) {\n          rootObject = rootObject.object;\n        }\n        if (isIdentifier(rootObject.object)) {\n          ctx.replacedSymbols.add(rootObject.object);\n        }\n\n        ctx.skipTransform.add(node.test.right);\n\n        // if ('development' === process.env.NODE_ENV) {}\n\n        if (!test(node.test.left.value, ctx.nodeEnv)) {\n          ctx.skip.add(node.consequent);\n          // We can blow away the consequent\n          ctx.magicString.remove(\n            node.start,\n            node.alternate ? node.alternate.start : node.consequent.end\n          );\n        } else {\n          // We can blow away the test\n          ctx.magicString.remove(node.start, node.consequent.start - 1);\n\n          if (node.alternate) {\n            ctx.skip.add(node.alternate);\n            // We can blow away the alternate but we need to start and the end of the consequent + 1 char\n            ctx.magicString.remove(node.consequent.end + 1, node.alternate.end);\n          }\n        }\n      } else if (\n        isStringLiteral(node.test.right) &&\n        isMemberExpression(node.test.left) &&\n        memberExpressionMatches(node.test.left, 'process.env.NODE_ENV')\n      ) {\n        let rootObject = node.test.left;\n        while (isMemberExpression(rootObject.object)) {\n          rootObject = rootObject.object;\n        }\n        if (isIdentifier(rootObject.object)) {\n          ctx.replacedSymbols.add(rootObject.object);\n        }\n\n        ctx.skipTransform.add(node.test.left);\n\n        // if (process.env.NODE_ENV === 'development') {}\n\n        if (!test(node.test.right.value, ctx.nodeEnv)) {\n          ctx.skip.add(node.consequent);\n          // We can blow away the consequent\n          ctx.magicString.remove(\n            node.start,\n            node.alternate ? node.alternate.start : node.consequent.end\n          );\n        } else {\n          // We can blow away the test and the alternate\n          ctx.magicString.remove(node.start, node.consequent.start - 1);\n\n          if (node.alternate) {\n            ctx.skip.add(node.alternate);\n            // We can blow away the alternate but we need to start and the end of the consequent + 1 char\n            ctx.magicString.remove(node.consequent.end + 1, node.alternate.end);\n          }\n        }\n      }\n    }\n  }\n}\n\nfunction visitRequires(\n  node: NodeWithParent,\n  _parent: NodeWithParent | null,\n  ctx: DependencyVisitorContext\n) {\n  if (isCallExpression(node)) {\n    const callee = node.callee;\n    if (isIdentifier(callee) && callee.name === 'require') {\n      const firstArg = node.arguments[0];\n\n      if (isStringLiteral(firstArg)) {\n        ctx.requires.push({\n          spec: { start: firstArg.start, end: firstArg.end, value: firstArg.value },\n          callee: { start: callee.start, end: callee.end },\n        });\n      } else if (\n        isTemplateLiteral(firstArg) &&\n        firstArg.expressions.length === 0 &&\n        firstArg.quasis.length === 1\n      ) {\n        ctx.requires.push({\n          spec: {\n            start: firstArg.quasis[0].start,\n            end: firstArg.quasis[0].end,\n            value: firstArg.quasis[0].value.raw,\n          },\n          callee: { start: callee.start, end: callee.end },\n        });\n      } else {\n        console.warn('Non string-literal first arg to require', firstArg);\n      }\n    } else if (\n      isMemberExpression(callee) &&\n      isIdentifier(callee.object) &&\n      callee.object.name === 'require' &&\n      isIdentifier(callee.property) &&\n      callee.property.name === 'resolve'\n    ) {\n      const firstArg = node.arguments[0];\n\n      if (isStringLiteral(firstArg)) {\n        ctx.requireResolves.push({\n          spec: { start: firstArg.start, end: firstArg.end, value: firstArg.value },\n          callee: { start: callee.start, end: callee.end },\n        });\n      } else {\n        console.warn('Non string-literal first arg to require.resolve', firstArg);\n      }\n    }\n  }\n}\n\nfunction declareFunction(node: Function, locals: { [name: string]: boolean }) {\n  node.params.forEach(function (node) {\n    declarePattern(node, locals);\n  });\n  if ((node as any).id) {\n    locals[(node as any).id.name] = true;\n  }\n}\n\nfunction declarePattern(node: Pattern, locals: { [name: string]: boolean }) {\n  if (isIdentifier(node)) {\n    locals[node.name] = true;\n  } else if (isObjectPattern(node)) {\n    node.properties.forEach((node) =>\n      isRestElement(node)\n        ? declarePattern(node.argument, locals)\n        : declarePattern(node.value, locals)\n    );\n  } else if (isArrayPattern(node)) {\n    node.elements.forEach((node) => node && declarePattern(node, locals));\n  } else if (isRestElement(node)) {\n    declarePattern(node.argument, locals);\n  } else if (isAssignmentPattern(node)) {\n    declarePattern(node.left, locals);\n  } else {\n    throw new Error(`Invariant violation: Unexpected pattern type: ${node.type}`);\n  }\n}\n\nfunction isArgumentOfTypeOf(node: NodeWithParent) {\n  const parent = node.parent as Node;\n\n  return isUnaryExpression(parent) && parent.operator === 'typeof';\n}\n\nfunction isBindingIdentifier(node: NodeWithParent) {\n  return (\n    isIdentifier(node) &&\n    !isPropertyOfMemberExpression(node) &&\n    !isKeyOfProperty(node) &&\n    !isKeyOfMethodDefinition(node)\n  );\n}\n\nfunction isKeyOfProperty(node: NodeWithParent) {\n  return node.parent && isProperty(node.parent) && node.parent.key === node;\n}\n\nfunction isPropertyOfMemberExpression(node: NodeWithParent) {\n  return node.parent && isMemberExpression(node.parent) && node.parent.object !== node;\n}\n\nfunction isKeyOfMethodDefinition(node: NodeWithParent) {\n  return node.parent && isMethodDefinition(node.parent);\n}\n\nfunction isScope(node: NodeWithParent) {\n  return (\n    isFunctionDeclaration(node) ||\n    isFunctionExpression(node) ||\n    isArrowFunctionExpression(node) ||\n    isProgram(node)\n  );\n}\n\nfunction isBlockScope(node: NodeWithParent) {\n  return isBlockStatement(node) || isScope(node);\n}\n\nfunction declaresArguments(node: NodeWithParent) {\n  return isFunctionDeclaration(node) || isFunctionExpression(node);\n}\n\nfunction declaresThis(node: NodeWithParent) {\n  return isFunctionDeclaration(node) || isFunctionExpression(node);\n}\n\nfunction memberExpressionMatches(node: MemberExpression, pattern: string) {\n  const memberParts = pattern.split('.');\n\n  if (memberParts.length < 2) {\n    return false;\n  }\n\n  const object = memberParts.shift();\n  const property = memberParts.shift();\n\n  for (let i = memberParts.length - 1; i >= 0; i--) {\n    if (!isIdentifier(node.property) || node.property.name !== memberParts[i]) {\n      return false;\n    }\n\n    if (!isMemberExpression(node.object)) {\n      return false;\n    }\n\n    node = node.object;\n  }\n\n  if (!isIdentifier(node.object) || !isIdentifier(node.property)) {\n    return false;\n  }\n\n  return node.object.name === object && node.property.name === property;\n}\n","import type { Uri } from '@velcro/common';\nimport type { Bundle } from 'magic-string';\nimport { encode } from 'sourcemap-codec';\nimport { SourceMap } from './sourceMap';\nimport type { ISourceMapper } from './sourceMapTree';\n\nexport class ChunkOutput {\n  private cachedCode?: string;\n  private cachedSourceMap?: SourceMap;\n  private cachedSourceMapDataUri?: string;\n  private cachedSourceMapString?: string;\n\n  constructor(\n    private readonly bundle: Bundle,\n    private readonly sourceMapTree: ISourceMapper,\n    readonly uri: Uri\n  ) {}\n\n  get code() {\n    if (typeof this.cachedCode === 'undefined') {\n      this.cachedCode = this.bundle.toString();\n    }\n\n    return this.cachedCode!;\n  }\n\n  get href() {\n    return this.uri.toString();\n  }\n\n  get sourceMap() {\n    if (typeof this.cachedSourceMap === 'undefined') {\n      this.cachedSourceMap = this.generateSourceMap();\n    }\n\n    return this.cachedSourceMap!;\n  }\n\n  get sourceMapString() {\n    if (typeof this.cachedSourceMapString === 'undefined') {\n      this.cachedSourceMapString = this.sourceMap.toString();\n    }\n\n    return this.cachedSourceMapString!;\n  }\n\n  get sourceMapDataUri() {\n    if (typeof this.cachedSourceMapDataUri === 'undefined') {\n      this.cachedSourceMapDataUri = this.sourceMap.toDataUri();\n    }\n\n    return this.cachedSourceMapDataUri!;\n  }\n\n  private generateSourceMap() {\n    const sourceMapTreeMappings = this.sourceMapTree.traceMappings();\n\n    if (sourceMapTreeMappings instanceof Error) {\n      return new SourceMap({\n        file: this.href,\n        mappings: '',\n        names: [],\n        sources: [],\n        version: 3,\n        sourcesContent: [],\n      });\n    }\n\n    // Loop through generated mappings, removing mappings that are character-by-character increments\n    // from the previous mapping. Since we generated a hires bundle, this will shrink the resolution\n    // back down to something not unnecessarily large.\n    // for (const line of sourceMapTreeMappings.mappings) {\n    //   let lastSegment: SourceMapSegment | null = null;\n    //   const shrinkedLine: SourceMapSegment[] = [];\n\n    //   for (const segment of line) {\n    //     if (lastSegment && lastSegment.length >= 4 && lastSegment.length === segment.length) {\n    //       // We will only push the segment if it is not, effectively a direct cursor move of the\n    //       // last one.\n    //       // For example:\n    //       //   lastSegment = [1, 0, 0, 1] // Generated column 1, original column 1 of the 0th file, 0th line\n    //       //   segment = [2, 0, 0, 2] // Generated column 2, original column 2 of the 0th file, 0th line\n    //       // Given that, we can see that this segment is not adding any _new_ information so we can skip it.\n    //       if (\n    //         lastSegment.length >= 4 &&\n    //         (lastSegment[0] + 1 !== segment[0] ||\n    //           lastSegment[1] !== segment[1] ||\n    //           lastSegment[2] !== segment[2] ||\n    //           lastSegment[3]! + 1 !== segment[3] ||\n    //           lastSegment[4] !== segment[4])\n    //       ) {\n    //         shrinkedLine.push(segment);\n    //       }\n    //     } else {\n    //       shrinkedLine.push(segment);\n    //     }\n\n    //     lastSegment = segment;\n    //   }\n\n    //   // line.splice(0, line.length, ...shrinkedLine);\n    // }\n\n    const sourceMap = new SourceMap({\n      file: this.href,\n      mappings: encode(sourceMapTreeMappings.mappings),\n      names: sourceMapTreeMappings.names,\n      sources: sourceMapTreeMappings.sources,\n      version: 3,\n      sourcesContent: sourceMapTreeMappings.sourcesContent,\n    });\n\n    return sourceMap;\n  }\n}\n","import { MapSet, Uri } from '@velcro/common';\nimport { runtime } from '@velcro/runtime';\nimport { Bundle } from 'magic-string';\nimport type { DependencyEdge } from '../graph/dependencyEdge';\nimport type { SourceModule } from '../graph/sourceModule';\nimport type { VelcroImportMap, VelcroStaticRuntime } from '../runtime/types';\nimport { ChunkOutput } from './chunkOutput';\nimport { LazyLink, Link, Source } from './sourceMapTree';\n\ntype NotUndefined<T> = T extends undefined ? never : T;\n\nexport class Chunk {\n  private readonly edgesFrom = new MapSet<string, DependencyEdge>();\n  private readonly edgesTo = new MapSet<string, DependencyEdge>();\n  //@ts-ignore\n  private readonly rootUri: Uri;\n  private readonly sourceModules = new Map<string, SourceModule>();\n\n  constructor(options: Chunk.Options) {\n    this.rootUri = options.rootUri;\n\n    for (const sourceModule of options.sourceModules) {\n      this.sourceModules.set(sourceModule.href, sourceModule);\n    }\n\n    for (const edge of options.edges) {\n      const fromHref = edge.fromUri.toString();\n      const toHref = edge.toUri.toString();\n\n      this.edgesFrom.add(fromHref, edge);\n      this.edgesTo.add(toHref, edge);\n    }\n  }\n\n  buildForStaticRuntime(options?: Chunk.ToStringOptions) {\n    // const velcroModuleFactoryParts = velcroModuleFactory\n    //   .toString()\n    //   .split(velcroModuleFactory.splitString);\n    // const velcroChunkWrapperParts = velcroChunkWrapper\n    //   .toString()\n    //   .split(velcroChunkWrapper.splitString);\n\n    const bundle = new Bundle({\n      separator: '\\n',\n    });\n\n    for (const sourceModule of this.sourceModules.values()) {\n      const moduleScopes: NotUndefined<NotUndefined<VelcroImportMap['scopes']>[string]> = {};\n      const scopes: NotUndefined<VelcroImportMap['scopes']> = {\n        [sourceModule.href]: moduleScopes,\n      };\n      const importMap: VelcroImportMap = { scopes };\n      const edgesFrom = this.edgesFrom.get(sourceModule.href);\n\n      if (edgesFrom) {\n        for (const edge of edgesFrom) {\n          moduleScopes[edge.dependency.spec] = edge.toUri.toString();\n        }\n      }\n      const sourceModuleCode = sourceModule.source.clone();\n\n      sourceModuleCode.prepend(\n        `velcro.defs[${JSON.stringify(\n          sourceModule.uri.toString()\n        )}] = [function(module,exports,require,__dirname,__filename){\\n`\n      );\n      sourceModuleCode.append(`\\n},${JSON.stringify(importMap)}];`);\n      bundle.addSource(sourceModuleCode);\n    }\n\n    const velcroStaticRuntime: VelcroStaticRuntime = { defs: {} };\n\n    bundle.prepend(`(function(velcro){\\n`);\n    bundle.prepend(\n      `if (typeof Velcro === 'undefined') Velcro = Object.create(null);\\nif (typeof Velcro.registry === 'undefined') Velcro.registry = ${JSON.stringify(\n        velcroStaticRuntime\n      )};\\n`\n    );\n    bundle.append(`\\n})(Velcro.registry);\\n`);\n\n    if (options && options.injectRuntime) {\n      bundle.append(`\\n${runtime}(Velcro);\\n`);\n    }\n\n    if (options && options.invalidations) {\n      if (!options.injectRuntime) {\n        throw new Error(\n          'Setting injectRuntime to true is required when calling buildForStaticRuntime and specifying invalidations'\n        );\n      }\n\n      bundle.append(`\\nVelcro.runtime.invalidate(${JSON.stringify(options.invalidations)});\\n`);\n    }\n\n    const sourceMapTree = new LazyLink(() => {\n      const inputMap = bundle.generateDecodedMap({\n        includeContent: false,\n        hires: true,\n        source: this.rootUri.toString(),\n      });\n      return new Link(\n        inputMap,\n        inputMap.sources.map((sourceHref) => {\n          const sourceModule = this.sourceModules.get(sourceHref);\n\n          if (!sourceModule) {\n            return new Source(sourceHref, 'SOURCEMAP ERROR');\n          }\n\n          // All of the transformations included in the source module's magicString\n          // were baked into the bundle already. We just need to map these into any\n          // earlier sources.\n          return sourceModule.sourceMapsTree;\n        })\n      );\n    });\n\n    return new ChunkOutput(bundle, sourceMapTree, this.rootUri);\n  }\n}\n\nexport namespace Chunk {\n  export interface Options {\n    edges: Iterable<DependencyEdge>;\n    rootUri: Uri;\n    sourceModules: Iterable<SourceModule>;\n  }\n\n  export interface ToStringOptions {\n    /**\n     * Toggle whether to inject the runtime in the generated code.\n     *\n     * An instance of the runtime is important as it is what will actually schedule\n     * and execute code built for Velcro.\n     *\n     * When `injectRuntime` is `true`, the runtime code will be injected and the\n     * instance of it will be exposed as `Velcro.runtime`.\n     */\n    injectRuntime?: boolean;\n    invalidations?: string[];\n  }\n}\n","// This file is auto-generated. Do not edit.\n\nexport const runtime = \"(function(Velcro){var e=function(e,t,r){this.runtime=e,this.id=t,this.importMap=r,this.module={exports:{}},this.require=this.runtime.createRequire(this)},t=function(){function t(t){this.moduleDependents={},this.moduleInstances={},this.defs=t.defs,this.root=new e(this,\\\"velcro:/root\\\",{}),Object.defineProperty(this,\\\"require\\\",{enumerable:!0,value:this.root.require.bind(this.root)})}return t.prototype.createRequire=function(t){var r=this;function n(e){return r.resolveSpecAgainstImportMap(e,t)}return Object.assign((function(o){var i=n(o),s=r.moduleInstances[i];if(!s){var u=r.defs[i];if(!u)throw new Error(\\\"Unable to locate module '\\\"+i+\\\"' from '\\\"+t.id);var a=u[0],l=u[1];s=new e(r,i,l),r.moduleInstances[i]=s;var p=i.split(\\\"/\\\"),c=p.pop()||o,d=p.join(\\\"/\\\");a.call(s.module.exports,s.module,s.module.exports,s.require.bind(s),d,c)}return(r.moduleDependents[i]=r.moduleDependents[i]||[]).push(t),s.module.exports}),{resolve:n})},t.prototype.inject=function(t,r){var n=new e(this,t,Object.create(null));return n.module.exports=r,this.moduleInstances[t]=n,n},t.prototype.invalidate=function(e){for(var t=e.slice(),r=!1;t.length;){var n=t.shift();r=delete this.moduleInstances[n]||r;var o=this.moduleDependents[n];if(Array.isArray(o))for(var i=0;i<o.length;i++)t.push(o[i].id)}return r},t.prototype.resolveSpecAgainstImportMap=function(e,t){var r=t.importMap;if(!r.scopes)return e;var n=r.scopes[t.id];if(!n)return e;var o=n[e];return o||e},t.create=function(r){return r.runtime||(r.runtime=new t(r.registry)),r.Module=e,r.Runtime=t,r.runtime},t}();Velcro.runtime=t.create(Velcro);})\";\n","import { MapSet, Uri } from '@velcro/common';\nimport { Chunk } from '../build/chunk';\nimport type { DependencyEdge } from './dependencyEdge';\nimport type { SourceModule } from './sourceModule';\n\nexport class Graph {\n  private readonly edgesFrom = new MapSet<string, DependencyEdge>();\n  private readonly edgesTo = new MapSet<string, DependencyEdge>();\n  //@ts-ignore\n  private readonly rootUri: Uri;\n  private readonly sourceModules = new Map<string, SourceModule>();\n\n  constructor(options: Graph.Options) {\n    this.rootUri = options.rootUri;\n\n    for (const sourceModule of options.sourceModules) {\n      this.sourceModules.set(sourceModule.href, sourceModule);\n    }\n\n    for (const edge of options.edges) {\n      const fromHref = edge.fromUri.toString();\n      const toHref = edge.toUri.toString();\n\n      this.edgesFrom.add(fromHref, edge);\n      this.edgesTo.add(toHref, edge);\n    }\n  }\n\n  splitChunks(): Iterable<Chunk> {\n    return [\n      new Chunk({\n        edges: this.edgesFrom.values(),\n        rootUri: Uri.joinPath(this.rootUri, './chunk/0.js'),\n        sourceModules: this.sourceModules.values(),\n      }),\n    ];\n  }\n}\n\nexport namespace Graph {\n  export interface Options {\n    edges: Iterable<DependencyEdge>;\n    rootUri: Uri;\n    sourceModules: Iterable<SourceModule>;\n  }\n}\n","import { version as nodeLibsVersion } from '@velcro/node-libs/package.json';\n\nexport const DEFAULT_SHIM_GLOBALS: Record<\n  string,\n  { spec: string; export?: string } | undefined\n> = Object.assign(Object.create(null), {\n  Buffer: {\n    spec: `@velcro/node-libs@${nodeLibsVersion}/lib/buffer.js`,\n    export: 'Buffer',\n  },\n  global: {\n    spec: `@velcro/node-libs@${nodeLibsVersion}/lib/global.js`,\n  },\n  globalThis: {\n    spec: `@velcro/node-libs@${nodeLibsVersion}/lib/global.js`,\n  },\n  process: {\n    spec: `@velcro/node-libs@${nodeLibsVersion}/lib/process.js`,\n  },\n});\n","import type { Uri } from '@velcro/common';\nimport type { ResolverContext } from '@velcro/resolver';\nimport type MagicString from 'magic-string';\nimport type { Link, Source } from '../build/sourceMapTree';\nimport type { SourceModuleDependency } from './sourceModuleDependency';\n\nexport class SourceModule {\n  constructor(\n    readonly uri: Uri,\n    readonly rootUri: Uri,\n    readonly source: MagicString,\n    readonly dependencies: Set<SourceModuleDependency>,\n    readonly sourceMapsTree: Source | Link,\n    readonly visits: ResolverContext.Visit[]\n  ) {}\n\n  get href() {\n    return this.uri.toString();\n  }\n\n  get rootHref() {\n    return this.rootUri.toString();\n  }\n}\n","import {\n  CancellationToken,\n  CancellationTokenSource,\n  DisposableStore,\n  Emitter,\n  Event,\n  isCanceledError,\n  MapSet,\n  Uri,\n} from '@velcro/common';\nimport type { Resolver, ResolverContext } from '@velcro/resolver';\nimport { Plugin, PluginManager } from '../plugins';\nimport { parse } from './commonjs';\nimport type { DependencyEdge } from './dependencyEdge';\nimport { Graph } from './graph';\nimport { DEFAULT_SHIM_GLOBALS } from './shims';\nimport { SourceModule } from './sourceModule';\nimport { SourceModuleDependency } from './sourceModuleDependency';\n\ntype ExternalTestFunction = (\n  dependency: SourceModuleDependency,\n  fromSourceModule: SourceModule\n) => boolean;\n\nexport class Build {\n  private readonly disposer = new DisposableStore();\n  private readonly edges = new Set<DependencyEdge>();\n  readonly errors: Error[] = [];\n  readonly seen = new Set<unknown>();\n  private readonly sourceModules = new Map<string, SourceModule>();\n\n  private readonly pendingModuleOperations = new MapSet<string, Promise<unknown>>();\n  private readonly tokenSource: CancellationTokenSource;\n\n  private readonly onCompletedEmitter = new Emitter<{ graph: Graph }>();\n  private readonly onErrorEmitter = new Emitter<{ error: Error }>();\n  private readonly onProgressEmitter = new Emitter<{\n    progress: {\n      completed: number;\n      pending: number;\n    };\n  }>();\n\n  readonly done = new Promise<Graph>((resolve, reject) => {\n    this.disposer.add(this.onCompleted(({ graph }) => resolve(graph)));\n    this.disposer.add(this.onError(({ error }) => reject(error)));\n  });\n\n  constructor(readonly rootUri: Uri, options: { token?: CancellationToken } = {}) {\n    this.tokenSource = new CancellationTokenSource(options.token);\n\n    this.disposer.add(this.tokenSource);\n    this.done.catch(() => {\n      // Prevent uncaught rejection\n    });\n  }\n\n  get onCompleted(): Event<{ graph: Graph }> {\n    return this.onCompletedEmitter.event;\n  }\n\n  get onError(): Event<{ error: Error }> {\n    return this.onErrorEmitter.event;\n  }\n\n  get onProgress(): Event<{\n    progress: {\n      completed: number;\n      pending: number;\n    };\n  }> {\n    return this.onProgressEmitter.event;\n  }\n\n  get token() {\n    return this.tokenSource.token;\n  }\n\n  addEdge(edge: DependencyEdge) {\n    this.edges.add(edge);\n  }\n\n  addSourceModule(sourceModule: SourceModule) {\n    this.sourceModules.set(sourceModule.href, sourceModule);\n  }\n\n  cancel() {\n    this.tokenSource.cancel();\n  }\n\n  dispose() {\n    this.cancel();\n    this.disposer.dispose();\n  }\n\n  hasSourceModule(href: string) {\n    return this.sourceModules.has(href);\n  }\n\n  runAsync(key: string, fn: () => Promise<unknown>): void {\n    if (this.token.isCancellationRequested) {\n      return;\n    }\n\n    const onError = (err: Error) => {\n      if (ret) {\n        this.pendingModuleOperations.delete(key, ret);\n      }\n      this.cancel();\n\n      if (!isCanceledError(err)) {\n        this.errors.push(err);\n\n        this.onErrorEmitter.fire({ error: err });\n      }\n    };\n    const onSuccess = () => {\n      this.pendingModuleOperations.delete(key, ret);\n\n      if (!this.pendingModuleOperations.size) {\n        this.onCompletedEmitter.fire({\n          graph: new Graph({\n            edges: this.edges,\n            rootUri: this.rootUri,\n            sourceModules: this.sourceModules.values(),\n          }),\n        });\n      } else {\n        this.onProgressEmitter.fire({\n          progress: {\n            completed: this.sourceModules.size,\n            pending: this.pendingModuleOperations.size,\n          },\n        });\n      }\n    };\n\n    let ret: ReturnType<typeof fn>;\n\n    try {\n      ret = fn().then(onSuccess, onError);\n      this.pendingModuleOperations.add(key, ret);\n    } catch (err) {\n      onError(err);\n    }\n  }\n}\n\nexport class GraphBuilder {\n  private readonly edgesByDependency = new WeakMap<SourceModuleDependency, DependencyEdge>();\n  private readonly edgesByInvalidation = new MapSet<string, DependencyEdge>();\n  private readonly external?: ExternalTestFunction;\n  private readonly nodeEnv: string;\n  private readonly resolver: Resolver;\n  private readonly pluginManager: PluginManager;\n  private readonly sourceModules = new Map<string, SourceModule>();\n  private readonly sourceModulesByInvalidation = new MapSet<string, SourceModule>();\n\n  constructor(options: GraphBuilder.Options) {\n    this.resolver = options.resolver;\n    this.external = options.external;\n    this.nodeEnv = options.nodeEnv || 'development';\n    this.pluginManager = new PluginManager(options.plugins || []);\n  }\n\n  private loadDependency(build: Build, sourceModule: SourceModule, dep: SourceModuleDependency) {\n    if (build.seen.has(dep)) return;\n    build.seen.add(dep);\n\n    if (this.external && this.external(dep, sourceModule)) {\n      return;\n    }\n\n    // console.debug('loadDependency(%s, %s)', sourceModule.href, dep.spec);\n\n    build.runAsync(`${sourceModule.href}|${dep.spec}`, async () => {\n      const result = await this.pluginManager.executeResolveDependency(\n        {\n          nodeEnv: this.nodeEnv,\n          resolver: this.resolver,\n          token: build.token,\n        },\n        dep,\n        sourceModule\n      );\n      const edge = this.createEdge(\n        sourceModule.uri,\n        sourceModule.rootUri,\n        result.uri,\n        result.rootUri,\n        result.visited,\n        dep\n      );\n\n      build.addEdge(edge);\n\n      this.loadEdge(build, edge);\n    });\n  }\n\n  private loadEdge(build: Build, edge: DependencyEdge) {\n    const href = edge.toUri.toString();\n\n    if (build.hasSourceModule(href)) return;\n\n    const existingSourceModule = this.sourceModules.get(href);\n\n    if (existingSourceModule) {\n      build.addSourceModule(existingSourceModule);\n\n      return this.visitSourceModule(build, existingSourceModule);\n    }\n\n    // console.debug(\n    //   'loadEdge(%s, %s, %s)',\n    //   edge.fromUri.toString(),\n    //   edge.dependency.spec,\n    //   edge.toUri.toString()\n    // );\n\n    build.runAsync(href, async () => {\n      // We need to check again in case another 'thread' already produced this\n      // sourceModule\n      if (build.hasSourceModule(href)) return;\n\n      const loadResult = await this.pluginManager.executeLoad(\n        {\n          nodeEnv: this.nodeEnv,\n          resolver: this.resolver,\n          token: build.token,\n        },\n        edge.toUri\n      );\n\n      // We need to check again in case another 'thread' already produced this\n      // sourceModule\n      if (build.hasSourceModule(href)) return;\n\n      const transformResult = await this.pluginManager.executeTransform(\n        {\n          nodeEnv: this.nodeEnv,\n          resolver: this.resolver,\n          token: build.token,\n        },\n        edge.toUri,\n        loadResult.code\n      );\n\n      // We need to check again in case another 'thread' already produced this\n      // sourceModule\n      if (build.hasSourceModule(href)) return;\n\n      const parseResult = parse(edge.toUri, transformResult.code, {\n        globalModules: DEFAULT_SHIM_GLOBALS,\n        nodeEnv: this.nodeEnv,\n      });\n      const sourceModule = new SourceModule(\n        edge.toUri,\n        edge.toRootUri,\n        parseResult.code,\n        new Set(parseResult.dependencies),\n        transformResult.sourceMapTree,\n        [...transformResult.visited, ...loadResult.visited]\n      );\n\n      build.addSourceModule(sourceModule);\n      this.sourceModules.set(sourceModule.href, sourceModule);\n\n      for (const visit of sourceModule.visits) {\n        this.sourceModulesByInvalidation.add(visit.uri.toString(), sourceModule);\n      }\n\n      this.sourceModulesByInvalidation.add(sourceModule.href, sourceModule);\n\n      this.visitSourceModule(build, sourceModule);\n    });\n  }\n\n  private loadEntrypoint(build: Build, uri: Uri) {\n    const href = uri.toString();\n\n    // console.debug('loadEntrypoint(%s)', href);\n    build.runAsync(href, async () => {\n      const result = await this.pluginManager.executeResolveEntrypoint(\n        {\n          nodeEnv: this.nodeEnv,\n          resolver: this.resolver,\n          token: build.token,\n        },\n        uri\n      );\n      const edge = this.createEdge(\n        build.rootUri,\n        build.rootUri,\n        result.uri,\n        result.rootUri,\n        result.visited,\n        SourceModuleDependency.fromEntrypoint(uri)\n      );\n\n      this.loadEdge(build, edge);\n    });\n  }\n\n  private visitSourceModule(build: Build, sourceModule: SourceModule) {\n    if (build.seen.has(sourceModule)) return;\n    build.seen.add(sourceModule);\n\n    // console.debug('visitSourceModule(%s)', sourceModule.href);\n    for (const dep of sourceModule.dependencies) {\n      const existingEdge = this.edgesByDependency.get(dep);\n\n      if (existingEdge) {\n        build.addEdge(existingEdge);\n\n        this.loadEdge(build, existingEdge);\n      } else {\n        this.loadDependency(build, sourceModule, dep);\n      }\n    }\n  }\n\n  build(\n    entrypoints: (string | Uri)[],\n    options: { incremental?: boolean; token?: CancellationToken } = {}\n  ) {\n    const rootUri = Uri.parse('velcro:/');\n    const build = new Build(rootUri, { token: options.token });\n\n    for (const uri of entrypoints) {\n      this.loadEntrypoint(build, Uri.isUri(uri) ? uri : Uri.parse(uri));\n    }\n\n    return build;\n  }\n\n  invalidate(uri: Uri | string) {\n    const href = Uri.isUri(uri) ? uri.toString() : uri;\n    const sourceModules = this.sourceModulesByInvalidation.get(href);\n\n    if (sourceModules) {\n      for (const sourceModule of sourceModules) {\n        this.sourceModules.delete(sourceModule.href);\n      }\n      this.sourceModulesByInvalidation.deleteAll(href);\n    }\n\n    this.sourceModules.delete(href);\n\n    const edges = this.edgesByInvalidation.get(href);\n\n    if (edges) {\n      for (const edge of edges) {\n        this.edgesByDependency.delete(edge.dependency);\n      }\n      this.edgesByInvalidation.deleteAll(href);\n    }\n\n    this.resolver.invalidate(uri);\n  }\n\n  private createEdge(\n    fromUri: Uri,\n    fromRootUri: Uri,\n    toUri: Uri,\n    toRootUri: Uri,\n    visited: ResolverContext.Visit[],\n    dependency: SourceModuleDependency\n  ) {\n    const edge = { dependency, fromUri, fromRootUri, toUri, toRootUri, visited };\n\n    this.edgesByDependency.set(dependency, edge);\n\n    this.edgesByInvalidation.add(toUri.toString(), edge);\n    for (const visit of visited) {\n      this.edgesByInvalidation.add(visit.uri.toString(), edge);\n    }\n\n    return edge;\n  }\n}\n\nexport namespace GraphBuilder {\n  export interface Options {\n    external?: ExternalTestFunction;\n    nodeEnv?: string;\n    plugins?: Plugin[];\n    resolver: Resolver;\n  }\n}\n","export var ContextualKeyword; (function (ContextualKeyword) {\n  const NONE = 0; ContextualKeyword[ContextualKeyword[\"NONE\"] = NONE] = \"NONE\";\n  const _abstract = NONE + 1; ContextualKeyword[ContextualKeyword[\"_abstract\"] = _abstract] = \"_abstract\";\n  const _as = _abstract + 1; ContextualKeyword[ContextualKeyword[\"_as\"] = _as] = \"_as\";\n  const _asserts = _as + 1; ContextualKeyword[ContextualKeyword[\"_asserts\"] = _asserts] = \"_asserts\";\n  const _async = _asserts + 1; ContextualKeyword[ContextualKeyword[\"_async\"] = _async] = \"_async\";\n  const _await = _async + 1; ContextualKeyword[ContextualKeyword[\"_await\"] = _await] = \"_await\";\n  const _checks = _await + 1; ContextualKeyword[ContextualKeyword[\"_checks\"] = _checks] = \"_checks\";\n  const _constructor = _checks + 1; ContextualKeyword[ContextualKeyword[\"_constructor\"] = _constructor] = \"_constructor\";\n  const _declare = _constructor + 1; ContextualKeyword[ContextualKeyword[\"_declare\"] = _declare] = \"_declare\";\n  const _enum = _declare + 1; ContextualKeyword[ContextualKeyword[\"_enum\"] = _enum] = \"_enum\";\n  const _exports = _enum + 1; ContextualKeyword[ContextualKeyword[\"_exports\"] = _exports] = \"_exports\";\n  const _from = _exports + 1; ContextualKeyword[ContextualKeyword[\"_from\"] = _from] = \"_from\";\n  const _get = _from + 1; ContextualKeyword[ContextualKeyword[\"_get\"] = _get] = \"_get\";\n  const _global = _get + 1; ContextualKeyword[ContextualKeyword[\"_global\"] = _global] = \"_global\";\n  const _implements = _global + 1; ContextualKeyword[ContextualKeyword[\"_implements\"] = _implements] = \"_implements\";\n  const _infer = _implements + 1; ContextualKeyword[ContextualKeyword[\"_infer\"] = _infer] = \"_infer\";\n  const _interface = _infer + 1; ContextualKeyword[ContextualKeyword[\"_interface\"] = _interface] = \"_interface\";\n  const _is = _interface + 1; ContextualKeyword[ContextualKeyword[\"_is\"] = _is] = \"_is\";\n  const _keyof = _is + 1; ContextualKeyword[ContextualKeyword[\"_keyof\"] = _keyof] = \"_keyof\";\n  const _mixins = _keyof + 1; ContextualKeyword[ContextualKeyword[\"_mixins\"] = _mixins] = \"_mixins\";\n  const _module = _mixins + 1; ContextualKeyword[ContextualKeyword[\"_module\"] = _module] = \"_module\";\n  const _namespace = _module + 1; ContextualKeyword[ContextualKeyword[\"_namespace\"] = _namespace] = \"_namespace\";\n  const _of = _namespace + 1; ContextualKeyword[ContextualKeyword[\"_of\"] = _of] = \"_of\";\n  const _opaque = _of + 1; ContextualKeyword[ContextualKeyword[\"_opaque\"] = _opaque] = \"_opaque\";\n  const _private = _opaque + 1; ContextualKeyword[ContextualKeyword[\"_private\"] = _private] = \"_private\";\n  const _protected = _private + 1; ContextualKeyword[ContextualKeyword[\"_protected\"] = _protected] = \"_protected\";\n  const _proto = _protected + 1; ContextualKeyword[ContextualKeyword[\"_proto\"] = _proto] = \"_proto\";\n  const _public = _proto + 1; ContextualKeyword[ContextualKeyword[\"_public\"] = _public] = \"_public\";\n  const _readonly = _public + 1; ContextualKeyword[ContextualKeyword[\"_readonly\"] = _readonly] = \"_readonly\";\n  const _require = _readonly + 1; ContextualKeyword[ContextualKeyword[\"_require\"] = _require] = \"_require\";\n  const _set = _require + 1; ContextualKeyword[ContextualKeyword[\"_set\"] = _set] = \"_set\";\n  const _static = _set + 1; ContextualKeyword[ContextualKeyword[\"_static\"] = _static] = \"_static\";\n  const _type = _static + 1; ContextualKeyword[ContextualKeyword[\"_type\"] = _type] = \"_type\";\n  const _unique = _type + 1; ContextualKeyword[ContextualKeyword[\"_unique\"] = _unique] = \"_unique\";\n})(ContextualKeyword || (ContextualKeyword = {}));\n","// Generated file, do not edit! Run \"yarn generate\" to re-generate this file.\n/**\n * Enum of all token types, with bit fields to signify meaningful properties.\n */\nexport var TokenType; (function (TokenType) {\n  // Precedence 0 means not an operator; otherwise it is a positive number up to 12.\n  const PRECEDENCE_MASK = 0xf; TokenType[TokenType[\"PRECEDENCE_MASK\"] = PRECEDENCE_MASK] = \"PRECEDENCE_MASK\";\n  const IS_KEYWORD = 1 << 4; TokenType[TokenType[\"IS_KEYWORD\"] = IS_KEYWORD] = \"IS_KEYWORD\";\n  const IS_ASSIGN = 1 << 5; TokenType[TokenType[\"IS_ASSIGN\"] = IS_ASSIGN] = \"IS_ASSIGN\";\n  const IS_RIGHT_ASSOCIATIVE = 1 << 6; TokenType[TokenType[\"IS_RIGHT_ASSOCIATIVE\"] = IS_RIGHT_ASSOCIATIVE] = \"IS_RIGHT_ASSOCIATIVE\";\n  const IS_PREFIX = 1 << 7; TokenType[TokenType[\"IS_PREFIX\"] = IS_PREFIX] = \"IS_PREFIX\";\n  const IS_POSTFIX = 1 << 8; TokenType[TokenType[\"IS_POSTFIX\"] = IS_POSTFIX] = \"IS_POSTFIX\";\n\n  const num = 0; TokenType[TokenType[\"num\"] = num] = \"num\"; // num\n  const bigint = 512; TokenType[TokenType[\"bigint\"] = bigint] = \"bigint\"; // bigint\n  const regexp = 1024; TokenType[TokenType[\"regexp\"] = regexp] = \"regexp\"; // regexp\n  const string = 1536; TokenType[TokenType[\"string\"] = string] = \"string\"; // string\n  const name = 2048; TokenType[TokenType[\"name\"] = name] = \"name\"; // name\n  const eof = 2560; TokenType[TokenType[\"eof\"] = eof] = \"eof\"; // eof\n  const bracketL = 3072; TokenType[TokenType[\"bracketL\"] = bracketL] = \"bracketL\"; // [\n  const bracketR = 3584; TokenType[TokenType[\"bracketR\"] = bracketR] = \"bracketR\"; // ]\n  const braceL = 4096; TokenType[TokenType[\"braceL\"] = braceL] = \"braceL\"; // {\n  const braceBarL = 4608; TokenType[TokenType[\"braceBarL\"] = braceBarL] = \"braceBarL\"; // {|\n  const braceR = 5120; TokenType[TokenType[\"braceR\"] = braceR] = \"braceR\"; // }\n  const braceBarR = 5632; TokenType[TokenType[\"braceBarR\"] = braceBarR] = \"braceBarR\"; // |}\n  const parenL = 6144; TokenType[TokenType[\"parenL\"] = parenL] = \"parenL\"; // (\n  const parenR = 6656; TokenType[TokenType[\"parenR\"] = parenR] = \"parenR\"; // )\n  const comma = 7168; TokenType[TokenType[\"comma\"] = comma] = \"comma\"; // ,\n  const semi = 7680; TokenType[TokenType[\"semi\"] = semi] = \"semi\"; // ;\n  const colon = 8192; TokenType[TokenType[\"colon\"] = colon] = \"colon\"; // :\n  const doubleColon = 8704; TokenType[TokenType[\"doubleColon\"] = doubleColon] = \"doubleColon\"; // ::\n  const dot = 9216; TokenType[TokenType[\"dot\"] = dot] = \"dot\"; // .\n  const question = 9728; TokenType[TokenType[\"question\"] = question] = \"question\"; // ?\n  const questionDot = 10240; TokenType[TokenType[\"questionDot\"] = questionDot] = \"questionDot\"; // ?.\n  const arrow = 10752; TokenType[TokenType[\"arrow\"] = arrow] = \"arrow\"; // =>\n  const template = 11264; TokenType[TokenType[\"template\"] = template] = \"template\"; // template\n  const ellipsis = 11776; TokenType[TokenType[\"ellipsis\"] = ellipsis] = \"ellipsis\"; // ...\n  const backQuote = 12288; TokenType[TokenType[\"backQuote\"] = backQuote] = \"backQuote\"; // `\n  const dollarBraceL = 12800; TokenType[TokenType[\"dollarBraceL\"] = dollarBraceL] = \"dollarBraceL\"; // ${\n  const at = 13312; TokenType[TokenType[\"at\"] = at] = \"at\"; // @\n  const hash = 13824; TokenType[TokenType[\"hash\"] = hash] = \"hash\"; // #\n  const eq = 14368; TokenType[TokenType[\"eq\"] = eq] = \"eq\"; // = isAssign\n  const assign = 14880; TokenType[TokenType[\"assign\"] = assign] = \"assign\"; // _= isAssign\n  const preIncDec = 15744; TokenType[TokenType[\"preIncDec\"] = preIncDec] = \"preIncDec\"; // ++/-- prefix postfix\n  const postIncDec = 16256; TokenType[TokenType[\"postIncDec\"] = postIncDec] = \"postIncDec\"; // ++/-- prefix postfix\n  const bang = 16512; TokenType[TokenType[\"bang\"] = bang] = \"bang\"; // ! prefix\n  const tilde = 17024; TokenType[TokenType[\"tilde\"] = tilde] = \"tilde\"; // ~ prefix\n  const pipeline = 17409; TokenType[TokenType[\"pipeline\"] = pipeline] = \"pipeline\"; // |> prec:1\n  const nullishCoalescing = 17922; TokenType[TokenType[\"nullishCoalescing\"] = nullishCoalescing] = \"nullishCoalescing\"; // ?? prec:2\n  const logicalOR = 18434; TokenType[TokenType[\"logicalOR\"] = logicalOR] = \"logicalOR\"; // || prec:2\n  const logicalAND = 18947; TokenType[TokenType[\"logicalAND\"] = logicalAND] = \"logicalAND\"; // && prec:3\n  const bitwiseOR = 19460; TokenType[TokenType[\"bitwiseOR\"] = bitwiseOR] = \"bitwiseOR\"; // | prec:4\n  const bitwiseXOR = 19973; TokenType[TokenType[\"bitwiseXOR\"] = bitwiseXOR] = \"bitwiseXOR\"; // ^ prec:5\n  const bitwiseAND = 20486; TokenType[TokenType[\"bitwiseAND\"] = bitwiseAND] = \"bitwiseAND\"; // & prec:6\n  const equality = 20999; TokenType[TokenType[\"equality\"] = equality] = \"equality\"; // ==/!= prec:7\n  const lessThan = 21512; TokenType[TokenType[\"lessThan\"] = lessThan] = \"lessThan\"; // < prec:8\n  const greaterThan = 22024; TokenType[TokenType[\"greaterThan\"] = greaterThan] = \"greaterThan\"; // > prec:8\n  const relationalOrEqual = 22536; TokenType[TokenType[\"relationalOrEqual\"] = relationalOrEqual] = \"relationalOrEqual\"; // <=/>= prec:8\n  const bitShift = 23049; TokenType[TokenType[\"bitShift\"] = bitShift] = \"bitShift\"; // <</>> prec:9\n  const plus = 23690; TokenType[TokenType[\"plus\"] = plus] = \"plus\"; // + prec:10 prefix\n  const minus = 24202; TokenType[TokenType[\"minus\"] = minus] = \"minus\"; // - prec:10 prefix\n  const modulo = 24587; TokenType[TokenType[\"modulo\"] = modulo] = \"modulo\"; // % prec:11\n  const star = 25099; TokenType[TokenType[\"star\"] = star] = \"star\"; // * prec:11\n  const slash = 25611; TokenType[TokenType[\"slash\"] = slash] = \"slash\"; // / prec:11\n  const exponent = 26188; TokenType[TokenType[\"exponent\"] = exponent] = \"exponent\"; // ** prec:12 rightAssociative\n  const jsxName = 26624; TokenType[TokenType[\"jsxName\"] = jsxName] = \"jsxName\"; // jsxName\n  const jsxText = 27136; TokenType[TokenType[\"jsxText\"] = jsxText] = \"jsxText\"; // jsxText\n  const jsxTagStart = 27648; TokenType[TokenType[\"jsxTagStart\"] = jsxTagStart] = \"jsxTagStart\"; // jsxTagStart\n  const jsxTagEnd = 28160; TokenType[TokenType[\"jsxTagEnd\"] = jsxTagEnd] = \"jsxTagEnd\"; // jsxTagEnd\n  const typeParameterStart = 28672; TokenType[TokenType[\"typeParameterStart\"] = typeParameterStart] = \"typeParameterStart\"; // typeParameterStart\n  const nonNullAssertion = 29184; TokenType[TokenType[\"nonNullAssertion\"] = nonNullAssertion] = \"nonNullAssertion\"; // nonNullAssertion\n  const _break = 29712; TokenType[TokenType[\"_break\"] = _break] = \"_break\"; // break keyword\n  const _case = 30224; TokenType[TokenType[\"_case\"] = _case] = \"_case\"; // case keyword\n  const _catch = 30736; TokenType[TokenType[\"_catch\"] = _catch] = \"_catch\"; // catch keyword\n  const _continue = 31248; TokenType[TokenType[\"_continue\"] = _continue] = \"_continue\"; // continue keyword\n  const _debugger = 31760; TokenType[TokenType[\"_debugger\"] = _debugger] = \"_debugger\"; // debugger keyword\n  const _default = 32272; TokenType[TokenType[\"_default\"] = _default] = \"_default\"; // default keyword\n  const _do = 32784; TokenType[TokenType[\"_do\"] = _do] = \"_do\"; // do keyword\n  const _else = 33296; TokenType[TokenType[\"_else\"] = _else] = \"_else\"; // else keyword\n  const _finally = 33808; TokenType[TokenType[\"_finally\"] = _finally] = \"_finally\"; // finally keyword\n  const _for = 34320; TokenType[TokenType[\"_for\"] = _for] = \"_for\"; // for keyword\n  const _function = 34832; TokenType[TokenType[\"_function\"] = _function] = \"_function\"; // function keyword\n  const _if = 35344; TokenType[TokenType[\"_if\"] = _if] = \"_if\"; // if keyword\n  const _return = 35856; TokenType[TokenType[\"_return\"] = _return] = \"_return\"; // return keyword\n  const _switch = 36368; TokenType[TokenType[\"_switch\"] = _switch] = \"_switch\"; // switch keyword\n  const _throw = 37008; TokenType[TokenType[\"_throw\"] = _throw] = \"_throw\"; // throw keyword prefix\n  const _try = 37392; TokenType[TokenType[\"_try\"] = _try] = \"_try\"; // try keyword\n  const _var = 37904; TokenType[TokenType[\"_var\"] = _var] = \"_var\"; // var keyword\n  const _let = 38416; TokenType[TokenType[\"_let\"] = _let] = \"_let\"; // let keyword\n  const _const = 38928; TokenType[TokenType[\"_const\"] = _const] = \"_const\"; // const keyword\n  const _while = 39440; TokenType[TokenType[\"_while\"] = _while] = \"_while\"; // while keyword\n  const _with = 39952; TokenType[TokenType[\"_with\"] = _with] = \"_with\"; // with keyword\n  const _new = 40464; TokenType[TokenType[\"_new\"] = _new] = \"_new\"; // new keyword\n  const _this = 40976; TokenType[TokenType[\"_this\"] = _this] = \"_this\"; // this keyword\n  const _super = 41488; TokenType[TokenType[\"_super\"] = _super] = \"_super\"; // super keyword\n  const _class = 42000; TokenType[TokenType[\"_class\"] = _class] = \"_class\"; // class keyword\n  const _extends = 42512; TokenType[TokenType[\"_extends\"] = _extends] = \"_extends\"; // extends keyword\n  const _export = 43024; TokenType[TokenType[\"_export\"] = _export] = \"_export\"; // export keyword\n  const _import = 43536; TokenType[TokenType[\"_import\"] = _import] = \"_import\"; // import keyword\n  const _yield = 44048; TokenType[TokenType[\"_yield\"] = _yield] = \"_yield\"; // yield keyword\n  const _null = 44560; TokenType[TokenType[\"_null\"] = _null] = \"_null\"; // null keyword\n  const _true = 45072; TokenType[TokenType[\"_true\"] = _true] = \"_true\"; // true keyword\n  const _false = 45584; TokenType[TokenType[\"_false\"] = _false] = \"_false\"; // false keyword\n  const _in = 46104; TokenType[TokenType[\"_in\"] = _in] = \"_in\"; // in prec:8 keyword\n  const _instanceof = 46616; TokenType[TokenType[\"_instanceof\"] = _instanceof] = \"_instanceof\"; // instanceof prec:8 keyword\n  const _typeof = 47248; TokenType[TokenType[\"_typeof\"] = _typeof] = \"_typeof\"; // typeof keyword prefix\n  const _void = 47760; TokenType[TokenType[\"_void\"] = _void] = \"_void\"; // void keyword prefix\n  const _delete = 48272; TokenType[TokenType[\"_delete\"] = _delete] = \"_delete\"; // delete keyword prefix\n  const _async = 48656; TokenType[TokenType[\"_async\"] = _async] = \"_async\"; // async keyword\n  const _get = 49168; TokenType[TokenType[\"_get\"] = _get] = \"_get\"; // get keyword\n  const _set = 49680; TokenType[TokenType[\"_set\"] = _set] = \"_set\"; // set keyword\n  const _declare = 50192; TokenType[TokenType[\"_declare\"] = _declare] = \"_declare\"; // declare keyword\n  const _readonly = 50704; TokenType[TokenType[\"_readonly\"] = _readonly] = \"_readonly\"; // readonly keyword\n  const _abstract = 51216; TokenType[TokenType[\"_abstract\"] = _abstract] = \"_abstract\"; // abstract keyword\n  const _static = 51728; TokenType[TokenType[\"_static\"] = _static] = \"_static\"; // static keyword\n  const _public = 52240; TokenType[TokenType[\"_public\"] = _public] = \"_public\"; // public keyword\n  const _private = 52752; TokenType[TokenType[\"_private\"] = _private] = \"_private\"; // private keyword\n  const _protected = 53264; TokenType[TokenType[\"_protected\"] = _protected] = \"_protected\"; // protected keyword\n  const _as = 53776; TokenType[TokenType[\"_as\"] = _as] = \"_as\"; // as keyword\n  const _enum = 54288; TokenType[TokenType[\"_enum\"] = _enum] = \"_enum\"; // enum keyword\n  const _type = 54800; TokenType[TokenType[\"_type\"] = _type] = \"_type\"; // type keyword\n  const _implements = 55312; TokenType[TokenType[\"_implements\"] = _implements] = \"_implements\"; // implements keyword\n})(TokenType || (TokenType = {}));\nexport function formatTokenType(tokenType) {\n  switch (tokenType) {\n    case TokenType.num:\n      return \"num\";\n    case TokenType.bigint:\n      return \"bigint\";\n    case TokenType.regexp:\n      return \"regexp\";\n    case TokenType.string:\n      return \"string\";\n    case TokenType.name:\n      return \"name\";\n    case TokenType.eof:\n      return \"eof\";\n    case TokenType.bracketL:\n      return \"[\";\n    case TokenType.bracketR:\n      return \"]\";\n    case TokenType.braceL:\n      return \"{\";\n    case TokenType.braceBarL:\n      return \"{|\";\n    case TokenType.braceR:\n      return \"}\";\n    case TokenType.braceBarR:\n      return \"|}\";\n    case TokenType.parenL:\n      return \"(\";\n    case TokenType.parenR:\n      return \")\";\n    case TokenType.comma:\n      return \",\";\n    case TokenType.semi:\n      return \";\";\n    case TokenType.colon:\n      return \":\";\n    case TokenType.doubleColon:\n      return \"::\";\n    case TokenType.dot:\n      return \".\";\n    case TokenType.question:\n      return \"?\";\n    case TokenType.questionDot:\n      return \"?.\";\n    case TokenType.arrow:\n      return \"=>\";\n    case TokenType.template:\n      return \"template\";\n    case TokenType.ellipsis:\n      return \"...\";\n    case TokenType.backQuote:\n      return \"`\";\n    case TokenType.dollarBraceL:\n      return \"${\";\n    case TokenType.at:\n      return \"@\";\n    case TokenType.hash:\n      return \"#\";\n    case TokenType.eq:\n      return \"=\";\n    case TokenType.assign:\n      return \"_=\";\n    case TokenType.preIncDec:\n      return \"++/--\";\n    case TokenType.postIncDec:\n      return \"++/--\";\n    case TokenType.bang:\n      return \"!\";\n    case TokenType.tilde:\n      return \"~\";\n    case TokenType.pipeline:\n      return \"|>\";\n    case TokenType.nullishCoalescing:\n      return \"??\";\n    case TokenType.logicalOR:\n      return \"||\";\n    case TokenType.logicalAND:\n      return \"&&\";\n    case TokenType.bitwiseOR:\n      return \"|\";\n    case TokenType.bitwiseXOR:\n      return \"^\";\n    case TokenType.bitwiseAND:\n      return \"&\";\n    case TokenType.equality:\n      return \"==/!=\";\n    case TokenType.lessThan:\n      return \"<\";\n    case TokenType.greaterThan:\n      return \">\";\n    case TokenType.relationalOrEqual:\n      return \"<=/>=\";\n    case TokenType.bitShift:\n      return \"<</>>\";\n    case TokenType.plus:\n      return \"+\";\n    case TokenType.minus:\n      return \"-\";\n    case TokenType.modulo:\n      return \"%\";\n    case TokenType.star:\n      return \"*\";\n    case TokenType.slash:\n      return \"/\";\n    case TokenType.exponent:\n      return \"**\";\n    case TokenType.jsxName:\n      return \"jsxName\";\n    case TokenType.jsxText:\n      return \"jsxText\";\n    case TokenType.jsxTagStart:\n      return \"jsxTagStart\";\n    case TokenType.jsxTagEnd:\n      return \"jsxTagEnd\";\n    case TokenType.typeParameterStart:\n      return \"typeParameterStart\";\n    case TokenType.nonNullAssertion:\n      return \"nonNullAssertion\";\n    case TokenType._break:\n      return \"break\";\n    case TokenType._case:\n      return \"case\";\n    case TokenType._catch:\n      return \"catch\";\n    case TokenType._continue:\n      return \"continue\";\n    case TokenType._debugger:\n      return \"debugger\";\n    case TokenType._default:\n      return \"default\";\n    case TokenType._do:\n      return \"do\";\n    case TokenType._else:\n      return \"else\";\n    case TokenType._finally:\n      return \"finally\";\n    case TokenType._for:\n      return \"for\";\n    case TokenType._function:\n      return \"function\";\n    case TokenType._if:\n      return \"if\";\n    case TokenType._return:\n      return \"return\";\n    case TokenType._switch:\n      return \"switch\";\n    case TokenType._throw:\n      return \"throw\";\n    case TokenType._try:\n      return \"try\";\n    case TokenType._var:\n      return \"var\";\n    case TokenType._let:\n      return \"let\";\n    case TokenType._const:\n      return \"const\";\n    case TokenType._while:\n      return \"while\";\n    case TokenType._with:\n      return \"with\";\n    case TokenType._new:\n      return \"new\";\n    case TokenType._this:\n      return \"this\";\n    case TokenType._super:\n      return \"super\";\n    case TokenType._class:\n      return \"class\";\n    case TokenType._extends:\n      return \"extends\";\n    case TokenType._export:\n      return \"export\";\n    case TokenType._import:\n      return \"import\";\n    case TokenType._yield:\n      return \"yield\";\n    case TokenType._null:\n      return \"null\";\n    case TokenType._true:\n      return \"true\";\n    case TokenType._false:\n      return \"false\";\n    case TokenType._in:\n      return \"in\";\n    case TokenType._instanceof:\n      return \"instanceof\";\n    case TokenType._typeof:\n      return \"typeof\";\n    case TokenType._void:\n      return \"void\";\n    case TokenType._delete:\n      return \"delete\";\n    case TokenType._async:\n      return \"async\";\n    case TokenType._get:\n      return \"get\";\n    case TokenType._set:\n      return \"set\";\n    case TokenType._declare:\n      return \"declare\";\n    case TokenType._readonly:\n      return \"readonly\";\n    case TokenType._abstract:\n      return \"abstract\";\n    case TokenType._static:\n      return \"static\";\n    case TokenType._public:\n      return \"public\";\n    case TokenType._private:\n      return \"private\";\n    case TokenType._protected:\n      return \"protected\";\n    case TokenType._as:\n      return \"as\";\n    case TokenType._enum:\n      return \"enum\";\n    case TokenType._type:\n      return \"type\";\n    case TokenType._implements:\n      return \"implements\";\n    default:\n      return \"\";\n  }\n}\n","\nimport {ContextualKeyword} from \"./keywords\";\nimport { TokenType as tt} from \"./types\";\n\nexport class Scope {\n  \n  \n  \n\n  constructor(startTokenIndex, endTokenIndex, isFunctionScope) {\n    this.startTokenIndex = startTokenIndex;\n    this.endTokenIndex = endTokenIndex;\n    this.isFunctionScope = isFunctionScope;\n  }\n}\n\nexport class StateSnapshot {\n  constructor(\n     potentialArrowAt,\n     noAnonFunctionType,\n     tokensLength,\n     scopesLength,\n     pos,\n     type,\n     contextualKeyword,\n     start,\n     end,\n     isType,\n     scopeDepth,\n     error,\n  ) {;this.potentialArrowAt = potentialArrowAt;this.noAnonFunctionType = noAnonFunctionType;this.tokensLength = tokensLength;this.scopesLength = scopesLength;this.pos = pos;this.type = type;this.contextualKeyword = contextualKeyword;this.start = start;this.end = end;this.isType = isType;this.scopeDepth = scopeDepth;this.error = error;}\n}\n\nexport default class State {constructor() { State.prototype.__init.call(this);State.prototype.__init2.call(this);State.prototype.__init3.call(this);State.prototype.__init4.call(this);State.prototype.__init5.call(this);State.prototype.__init6.call(this);State.prototype.__init7.call(this);State.prototype.__init8.call(this);State.prototype.__init9.call(this);State.prototype.__init10.call(this);State.prototype.__init11.call(this);State.prototype.__init12.call(this); }\n  // Used to signify the start of a potential arrow function\n  __init() {this.potentialArrowAt = -1}\n\n  // Used by Flow to handle an edge case involving function type parsing.\n  __init2() {this.noAnonFunctionType = false}\n\n  // Token store.\n  __init3() {this.tokens = []}\n\n  // Array of all observed scopes, ordered by their ending position.\n  __init4() {this.scopes = []}\n\n  // The current position of the tokenizer in the input.\n  __init5() {this.pos = 0}\n\n  // Information about the current token.\n  __init6() {this.type = tt.eof}\n  __init7() {this.contextualKeyword = ContextualKeyword.NONE}\n  __init8() {this.start = 0}\n  __init9() {this.end = 0}\n\n  __init10() {this.isType = false}\n  __init11() {this.scopeDepth = 0}\n\n  /**\n   * If the parser is in an error state, then the token is always tt.eof and all functions can\n   * keep executing but should be written so they don't get into an infinite loop in this situation.\n   *\n   * This approach, combined with the ability to snapshot and restore state, allows us to implement\n   * backtracking without exceptions and without needing to explicitly propagate error states\n   * everywhere.\n   */\n  __init12() {this.error = null}\n\n  snapshot() {\n    return new StateSnapshot(\n      this.potentialArrowAt,\n      this.noAnonFunctionType,\n      this.tokens.length,\n      this.scopes.length,\n      this.pos,\n      this.type,\n      this.contextualKeyword,\n      this.start,\n      this.end,\n      this.isType,\n      this.scopeDepth,\n      this.error,\n    );\n  }\n\n  restoreFromSnapshot(snapshot) {\n    this.potentialArrowAt = snapshot.potentialArrowAt;\n    this.noAnonFunctionType = snapshot.noAnonFunctionType;\n    this.tokens.length = snapshot.tokensLength;\n    this.scopes.length = snapshot.scopesLength;\n    this.pos = snapshot.pos;\n    this.type = snapshot.type;\n    this.contextualKeyword = snapshot.contextualKeyword;\n    this.start = snapshot.start;\n    this.end = snapshot.end;\n    this.isType = snapshot.isType;\n    this.scopeDepth = snapshot.scopeDepth;\n    this.error = snapshot.error;\n  }\n}\n","export var charCodes; (function (charCodes) {\n  const backSpace = 8; charCodes[charCodes[\"backSpace\"] = backSpace] = \"backSpace\";\n  const lineFeed = 10; charCodes[charCodes[\"lineFeed\"] = lineFeed] = \"lineFeed\"; //  '\\n'\n  const carriageReturn = 13; charCodes[charCodes[\"carriageReturn\"] = carriageReturn] = \"carriageReturn\"; //  '\\r'\n  const shiftOut = 14; charCodes[charCodes[\"shiftOut\"] = shiftOut] = \"shiftOut\";\n  const space = 32; charCodes[charCodes[\"space\"] = space] = \"space\";\n  const exclamationMark = 33; charCodes[charCodes[\"exclamationMark\"] = exclamationMark] = \"exclamationMark\"; //  '!'\n  const quotationMark = 34; charCodes[charCodes[\"quotationMark\"] = quotationMark] = \"quotationMark\"; //  '\"'\n  const numberSign = 35; charCodes[charCodes[\"numberSign\"] = numberSign] = \"numberSign\"; //  '#'\n  const dollarSign = 36; charCodes[charCodes[\"dollarSign\"] = dollarSign] = \"dollarSign\"; //  '$'\n  const percentSign = 37; charCodes[charCodes[\"percentSign\"] = percentSign] = \"percentSign\"; //  '%'\n  const ampersand = 38; charCodes[charCodes[\"ampersand\"] = ampersand] = \"ampersand\"; //  '&'\n  const apostrophe = 39; charCodes[charCodes[\"apostrophe\"] = apostrophe] = \"apostrophe\"; //  '''\n  const leftParenthesis = 40; charCodes[charCodes[\"leftParenthesis\"] = leftParenthesis] = \"leftParenthesis\"; //  '('\n  const rightParenthesis = 41; charCodes[charCodes[\"rightParenthesis\"] = rightParenthesis] = \"rightParenthesis\"; //  ')'\n  const asterisk = 42; charCodes[charCodes[\"asterisk\"] = asterisk] = \"asterisk\"; //  '*'\n  const plusSign = 43; charCodes[charCodes[\"plusSign\"] = plusSign] = \"plusSign\"; //  '+'\n  const comma = 44; charCodes[charCodes[\"comma\"] = comma] = \"comma\"; //  ','\n  const dash = 45; charCodes[charCodes[\"dash\"] = dash] = \"dash\"; //  '-'\n  const dot = 46; charCodes[charCodes[\"dot\"] = dot] = \"dot\"; //  '.'\n  const slash = 47; charCodes[charCodes[\"slash\"] = slash] = \"slash\"; //  '/'\n  const digit0 = 48; charCodes[charCodes[\"digit0\"] = digit0] = \"digit0\"; //  '0'\n  const digit1 = 49; charCodes[charCodes[\"digit1\"] = digit1] = \"digit1\"; //  '1'\n  const digit2 = 50; charCodes[charCodes[\"digit2\"] = digit2] = \"digit2\"; //  '2'\n  const digit3 = 51; charCodes[charCodes[\"digit3\"] = digit3] = \"digit3\"; //  '3'\n  const digit4 = 52; charCodes[charCodes[\"digit4\"] = digit4] = \"digit4\"; //  '4'\n  const digit5 = 53; charCodes[charCodes[\"digit5\"] = digit5] = \"digit5\"; //  '5'\n  const digit6 = 54; charCodes[charCodes[\"digit6\"] = digit6] = \"digit6\"; //  '6'\n  const digit7 = 55; charCodes[charCodes[\"digit7\"] = digit7] = \"digit7\"; //  '7'\n  const digit8 = 56; charCodes[charCodes[\"digit8\"] = digit8] = \"digit8\"; //  '8'\n  const digit9 = 57; charCodes[charCodes[\"digit9\"] = digit9] = \"digit9\"; //  '9'\n  const colon = 58; charCodes[charCodes[\"colon\"] = colon] = \"colon\"; //  ':'\n  const semicolon = 59; charCodes[charCodes[\"semicolon\"] = semicolon] = \"semicolon\"; //  ';'\n  const lessThan = 60; charCodes[charCodes[\"lessThan\"] = lessThan] = \"lessThan\"; //  '<'\n  const equalsTo = 61; charCodes[charCodes[\"equalsTo\"] = equalsTo] = \"equalsTo\"; //  '='\n  const greaterThan = 62; charCodes[charCodes[\"greaterThan\"] = greaterThan] = \"greaterThan\"; //  '>'\n  const questionMark = 63; charCodes[charCodes[\"questionMark\"] = questionMark] = \"questionMark\"; //  '?'\n  const atSign = 64; charCodes[charCodes[\"atSign\"] = atSign] = \"atSign\"; //  '@'\n  const uppercaseA = 65; charCodes[charCodes[\"uppercaseA\"] = uppercaseA] = \"uppercaseA\"; //  'A'\n  const uppercaseB = 66; charCodes[charCodes[\"uppercaseB\"] = uppercaseB] = \"uppercaseB\"; //  'B'\n  const uppercaseC = 67; charCodes[charCodes[\"uppercaseC\"] = uppercaseC] = \"uppercaseC\"; //  'C'\n  const uppercaseD = 68; charCodes[charCodes[\"uppercaseD\"] = uppercaseD] = \"uppercaseD\"; //  'D'\n  const uppercaseE = 69; charCodes[charCodes[\"uppercaseE\"] = uppercaseE] = \"uppercaseE\"; //  'E'\n  const uppercaseF = 70; charCodes[charCodes[\"uppercaseF\"] = uppercaseF] = \"uppercaseF\"; //  'F'\n  const uppercaseG = 71; charCodes[charCodes[\"uppercaseG\"] = uppercaseG] = \"uppercaseG\"; //  'G'\n  const uppercaseH = 72; charCodes[charCodes[\"uppercaseH\"] = uppercaseH] = \"uppercaseH\"; //  'H'\n  const uppercaseI = 73; charCodes[charCodes[\"uppercaseI\"] = uppercaseI] = \"uppercaseI\"; //  'I'\n  const uppercaseJ = 74; charCodes[charCodes[\"uppercaseJ\"] = uppercaseJ] = \"uppercaseJ\"; //  'J'\n  const uppercaseK = 75; charCodes[charCodes[\"uppercaseK\"] = uppercaseK] = \"uppercaseK\"; //  'K'\n  const uppercaseL = 76; charCodes[charCodes[\"uppercaseL\"] = uppercaseL] = \"uppercaseL\"; //  'L'\n  const uppercaseM = 77; charCodes[charCodes[\"uppercaseM\"] = uppercaseM] = \"uppercaseM\"; //  'M'\n  const uppercaseN = 78; charCodes[charCodes[\"uppercaseN\"] = uppercaseN] = \"uppercaseN\"; //  'N'\n  const uppercaseO = 79; charCodes[charCodes[\"uppercaseO\"] = uppercaseO] = \"uppercaseO\"; //  'O'\n  const uppercaseP = 80; charCodes[charCodes[\"uppercaseP\"] = uppercaseP] = \"uppercaseP\"; //  'P'\n  const uppercaseQ = 81; charCodes[charCodes[\"uppercaseQ\"] = uppercaseQ] = \"uppercaseQ\"; //  'Q'\n  const uppercaseR = 82; charCodes[charCodes[\"uppercaseR\"] = uppercaseR] = \"uppercaseR\"; //  'R'\n  const uppercaseS = 83; charCodes[charCodes[\"uppercaseS\"] = uppercaseS] = \"uppercaseS\"; //  'S'\n  const uppercaseT = 84; charCodes[charCodes[\"uppercaseT\"] = uppercaseT] = \"uppercaseT\"; //  'T'\n  const uppercaseU = 85; charCodes[charCodes[\"uppercaseU\"] = uppercaseU] = \"uppercaseU\"; //  'U'\n  const uppercaseV = 86; charCodes[charCodes[\"uppercaseV\"] = uppercaseV] = \"uppercaseV\"; //  'V'\n  const uppercaseW = 87; charCodes[charCodes[\"uppercaseW\"] = uppercaseW] = \"uppercaseW\"; //  'W'\n  const uppercaseX = 88; charCodes[charCodes[\"uppercaseX\"] = uppercaseX] = \"uppercaseX\"; //  'X'\n  const uppercaseY = 89; charCodes[charCodes[\"uppercaseY\"] = uppercaseY] = \"uppercaseY\"; //  'Y'\n  const uppercaseZ = 90; charCodes[charCodes[\"uppercaseZ\"] = uppercaseZ] = \"uppercaseZ\"; //  'Z'\n  const leftSquareBracket = 91; charCodes[charCodes[\"leftSquareBracket\"] = leftSquareBracket] = \"leftSquareBracket\"; //  '['\n  const backslash = 92; charCodes[charCodes[\"backslash\"] = backslash] = \"backslash\"; //  '\\    '\n  const rightSquareBracket = 93; charCodes[charCodes[\"rightSquareBracket\"] = rightSquareBracket] = \"rightSquareBracket\"; //  ']'\n  const caret = 94; charCodes[charCodes[\"caret\"] = caret] = \"caret\"; //  '^'\n  const underscore = 95; charCodes[charCodes[\"underscore\"] = underscore] = \"underscore\"; //  '_'\n  const graveAccent = 96; charCodes[charCodes[\"graveAccent\"] = graveAccent] = \"graveAccent\"; //  '`'\n  const lowercaseA = 97; charCodes[charCodes[\"lowercaseA\"] = lowercaseA] = \"lowercaseA\"; //  'a'\n  const lowercaseB = 98; charCodes[charCodes[\"lowercaseB\"] = lowercaseB] = \"lowercaseB\"; //  'b'\n  const lowercaseC = 99; charCodes[charCodes[\"lowercaseC\"] = lowercaseC] = \"lowercaseC\"; //  'c'\n  const lowercaseD = 100; charCodes[charCodes[\"lowercaseD\"] = lowercaseD] = \"lowercaseD\"; //  'd'\n  const lowercaseE = 101; charCodes[charCodes[\"lowercaseE\"] = lowercaseE] = \"lowercaseE\"; //  'e'\n  const lowercaseF = 102; charCodes[charCodes[\"lowercaseF\"] = lowercaseF] = \"lowercaseF\"; //  'f'\n  const lowercaseG = 103; charCodes[charCodes[\"lowercaseG\"] = lowercaseG] = \"lowercaseG\"; //  'g'\n  const lowercaseH = 104; charCodes[charCodes[\"lowercaseH\"] = lowercaseH] = \"lowercaseH\"; //  'h'\n  const lowercaseI = 105; charCodes[charCodes[\"lowercaseI\"] = lowercaseI] = \"lowercaseI\"; //  'i'\n  const lowercaseJ = 106; charCodes[charCodes[\"lowercaseJ\"] = lowercaseJ] = \"lowercaseJ\"; //  'j'\n  const lowercaseK = 107; charCodes[charCodes[\"lowercaseK\"] = lowercaseK] = \"lowercaseK\"; //  'k'\n  const lowercaseL = 108; charCodes[charCodes[\"lowercaseL\"] = lowercaseL] = \"lowercaseL\"; //  'l'\n  const lowercaseM = 109; charCodes[charCodes[\"lowercaseM\"] = lowercaseM] = \"lowercaseM\"; //  'm'\n  const lowercaseN = 110; charCodes[charCodes[\"lowercaseN\"] = lowercaseN] = \"lowercaseN\"; //  'n'\n  const lowercaseO = 111; charCodes[charCodes[\"lowercaseO\"] = lowercaseO] = \"lowercaseO\"; //  'o'\n  const lowercaseP = 112; charCodes[charCodes[\"lowercaseP\"] = lowercaseP] = \"lowercaseP\"; //  'p'\n  const lowercaseQ = 113; charCodes[charCodes[\"lowercaseQ\"] = lowercaseQ] = \"lowercaseQ\"; //  'q'\n  const lowercaseR = 114; charCodes[charCodes[\"lowercaseR\"] = lowercaseR] = \"lowercaseR\"; //  'r'\n  const lowercaseS = 115; charCodes[charCodes[\"lowercaseS\"] = lowercaseS] = \"lowercaseS\"; //  's'\n  const lowercaseT = 116; charCodes[charCodes[\"lowercaseT\"] = lowercaseT] = \"lowercaseT\"; //  't'\n  const lowercaseU = 117; charCodes[charCodes[\"lowercaseU\"] = lowercaseU] = \"lowercaseU\"; //  'u'\n  const lowercaseV = 118; charCodes[charCodes[\"lowercaseV\"] = lowercaseV] = \"lowercaseV\"; //  'v'\n  const lowercaseW = 119; charCodes[charCodes[\"lowercaseW\"] = lowercaseW] = \"lowercaseW\"; //  'w'\n  const lowercaseX = 120; charCodes[charCodes[\"lowercaseX\"] = lowercaseX] = \"lowercaseX\"; //  'x'\n  const lowercaseY = 121; charCodes[charCodes[\"lowercaseY\"] = lowercaseY] = \"lowercaseY\"; //  'y'\n  const lowercaseZ = 122; charCodes[charCodes[\"lowercaseZ\"] = lowercaseZ] = \"lowercaseZ\"; //  'z'\n  const leftCurlyBrace = 123; charCodes[charCodes[\"leftCurlyBrace\"] = leftCurlyBrace] = \"leftCurlyBrace\"; //  '{'\n  const verticalBar = 124; charCodes[charCodes[\"verticalBar\"] = verticalBar] = \"verticalBar\"; //  '|'\n  const rightCurlyBrace = 125; charCodes[charCodes[\"rightCurlyBrace\"] = rightCurlyBrace] = \"rightCurlyBrace\"; //  '}'\n  const tilde = 126; charCodes[charCodes[\"tilde\"] = tilde] = \"tilde\"; //  '~'\n  const nonBreakingSpace = 160; charCodes[charCodes[\"nonBreakingSpace\"] = nonBreakingSpace] = \"nonBreakingSpace\";\n  // eslint-disable-next-line no-irregular-whitespace\n  const oghamSpaceMark = 5760; charCodes[charCodes[\"oghamSpaceMark\"] = oghamSpaceMark] = \"oghamSpaceMark\"; // ' '\n  const lineSeparator = 8232; charCodes[charCodes[\"lineSeparator\"] = lineSeparator] = \"lineSeparator\";\n  const paragraphSeparator = 8233; charCodes[charCodes[\"paragraphSeparator\"] = paragraphSeparator] = \"paragraphSeparator\";\n})(charCodes || (charCodes = {}));\n\nexport function isDigit(code) {\n  return (\n    (code >= charCodes.digit0 && code <= charCodes.digit9) ||\n    (code >= charCodes.lowercaseA && code <= charCodes.lowercaseF) ||\n    (code >= charCodes.uppercaseA && code <= charCodes.uppercaseF)\n  );\n}\n","import State from \"../tokenizer/state\";\nimport {charCodes} from \"../util/charcodes\";\n\nexport let isJSXEnabled;\nexport let isTypeScriptEnabled;\nexport let isFlowEnabled;\nexport let state;\nexport let input;\nexport let nextContextId;\n\nexport function getNextContextId() {\n  return nextContextId++;\n}\n\n// tslint:disable-next-line no-any\nexport function augmentError(error) {\n  if (\"pos\" in error) {\n    const loc = locationForIndex(error.pos);\n    error.message += ` (${loc.line}:${loc.column})`;\n    error.loc = loc;\n  }\n  return error;\n}\n\nexport class Loc {\n  \n  \n  constructor(line, column) {\n    this.line = line;\n    this.column = column;\n  }\n}\n\nexport function locationForIndex(pos) {\n  let line = 1;\n  let column = 1;\n  for (let i = 0; i < pos; i++) {\n    if (input.charCodeAt(i) === charCodes.lineFeed) {\n      line++;\n      column = 1;\n    } else {\n      column++;\n    }\n  }\n  return new Loc(line, column);\n}\n\nexport function initParser(\n  inputCode,\n  isJSXEnabledArg,\n  isTypeScriptEnabledArg,\n  isFlowEnabledArg,\n) {\n  input = inputCode;\n  state = new State();\n  nextContextId = 1;\n  isJSXEnabled = isJSXEnabledArg;\n  isTypeScriptEnabled = isTypeScriptEnabledArg;\n  isFlowEnabled = isFlowEnabledArg;\n}\n","import {eat, finishToken, lookaheadTypeAndKeyword, match} from \"../tokenizer/index\";\n\nimport {formatTokenType, TokenType as tt} from \"../tokenizer/types\";\nimport {charCodes} from \"../util/charcodes\";\nimport {input, state} from \"./base\";\n\n// ## Parser utilities\n\n// Tests whether parsed token is a contextual keyword.\nexport function isContextual(contextualKeyword) {\n  return state.contextualKeyword === contextualKeyword;\n}\n\nexport function isLookaheadContextual(contextualKeyword) {\n  const l = lookaheadTypeAndKeyword();\n  return l.type === tt.name && l.contextualKeyword === contextualKeyword;\n}\n\n// Consumes contextual keyword if possible.\nexport function eatContextual(contextualKeyword) {\n  return state.contextualKeyword === contextualKeyword && eat(tt.name);\n}\n\n// Asserts that following token is given contextual keyword.\nexport function expectContextual(contextualKeyword) {\n  if (!eatContextual(contextualKeyword)) {\n    unexpected();\n  }\n}\n\n// Test whether a semicolon can be inserted at the current position.\nexport function canInsertSemicolon() {\n  return match(tt.eof) || match(tt.braceR) || hasPrecedingLineBreak();\n}\n\nexport function hasPrecedingLineBreak() {\n  const prevToken = state.tokens[state.tokens.length - 1];\n  const lastTokEnd = prevToken ? prevToken.end : 0;\n  for (let i = lastTokEnd; i < state.start; i++) {\n    const code = input.charCodeAt(i);\n    if (\n      code === charCodes.lineFeed ||\n      code === charCodes.carriageReturn ||\n      code === 0x2028 ||\n      code === 0x2029\n    ) {\n      return true;\n    }\n  }\n  return false;\n}\n\nexport function isLineTerminator() {\n  return eat(tt.semi) || canInsertSemicolon();\n}\n\n// Consume a semicolon, or, failing that, see if we are allowed to\n// pretend that there is a semicolon at this position.\nexport function semicolon() {\n  if (!isLineTerminator()) {\n    unexpected('Unexpected token, expected \";\"');\n  }\n}\n\n// Expect a token of a given type. If found, consume it, otherwise,\n// raise an unexpected token error at given pos.\nexport function expect(type) {\n  const matched = eat(type);\n  if (!matched) {\n    unexpected(`Unexpected token, expected \"${formatTokenType(type)}\"`);\n  }\n}\n\n/**\n * Transition the parser to an error state. All code needs to be written to naturally unwind in this\n * state, which allows us to backtrack without exceptions and without error plumbing everywhere.\n */\nexport function unexpected(message = \"Unexpected token\", pos = state.start) {\n  if (state.error) {\n    return;\n  }\n  // tslint:disable-next-line no-any\n  const err = new SyntaxError(message);\n  err.pos = pos;\n  state.error = err;\n  state.pos = input.length;\n  finishToken(tt.eof);\n}\n","import {charCodes} from \"./charcodes\";\n\n// https://tc39.github.io/ecma262/#sec-white-space\nexport const WHITESPACE_CHARS = [\n  0x0009,\n  0x000b,\n  0x000c,\n  charCodes.space,\n  charCodes.nonBreakingSpace,\n  charCodes.oghamSpaceMark,\n  0x2000, // EN QUAD\n  0x2001, // EM QUAD\n  0x2002, // EN SPACE\n  0x2003, // EM SPACE\n  0x2004, // THREE-PER-EM SPACE\n  0x2005, // FOUR-PER-EM SPACE\n  0x2006, // SIX-PER-EM SPACE\n  0x2007, // FIGURE SPACE\n  0x2008, // PUNCTUATION SPACE\n  0x2009, // THIN SPACE\n  0x200a, // HAIR SPACE\n  0x202f, // NARROW NO-BREAK SPACE\n  0x205f, // MEDIUM MATHEMATICAL SPACE\n  0x3000, // IDEOGRAPHIC SPACE\n  0xfeff, // ZERO WIDTH NO-BREAK SPACE\n];\n\nexport const IS_WHITESPACE = new Uint8Array(65536);\nfor (const char of WHITESPACE_CHARS) {\n  IS_WHITESPACE[char] = 1;\n}\n","import {charCodes} from \"./charcodes\";\nimport {WHITESPACE_CHARS} from \"./whitespace\";\n\nfunction computeIsIdentifierChar(code) {\n  if (code < 48) return code === 36;\n  if (code < 58) return true;\n  if (code < 65) return false;\n  if (code < 91) return true;\n  if (code < 97) return code === 95;\n  if (code < 123) return true;\n  if (code < 128) return false;\n  throw new Error(\"Should not be called with non-ASCII char code.\");\n}\n\nexport const IS_IDENTIFIER_CHAR = new Uint8Array(65536);\nfor (let i = 0; i < 128; i++) {\n  IS_IDENTIFIER_CHAR[i] = computeIsIdentifierChar(i) ? 1 : 0;\n}\nfor (let i = 128; i < 65536; i++) {\n  IS_IDENTIFIER_CHAR[i] = 1;\n}\n// Aside from whitespace and newlines, all characters outside the ASCII space are either\n// identifier characters or invalid. Since we're not performing code validation, we can just\n// treat all invalid characters as identifier characters.\nfor (const whitespaceChar of WHITESPACE_CHARS) {\n  IS_IDENTIFIER_CHAR[whitespaceChar] = 0;\n}\nIS_IDENTIFIER_CHAR[0x2028] = 0;\nIS_IDENTIFIER_CHAR[0x2029] = 0;\n\nexport const IS_IDENTIFIER_START = IS_IDENTIFIER_CHAR.slice();\nfor (let numChar = charCodes.digit0; numChar <= charCodes.digit9; numChar++) {\n  IS_IDENTIFIER_START[numChar] = 0;\n}\n","// Generated file, do not edit! Run \"yarn generate\" to re-generate this file.\nimport {ContextualKeyword} from \"./keywords\";\nimport {TokenType as tt} from \"./types\";\n\n// prettier-ignore\nexport const READ_WORD_TREE = new Int32Array([\n  // \"\"\n  -1, 27, 594, 729, 1566, 2187, 2673, 3294, -1, 3510, -1, 4428, 4563, 4644, 4941, 5319, 5508, -1, 6048, 6507, 6966, 7398, 7560, 7722, -1, 7938, -1,\n  // \"a\"\n  -1, -1, 54, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 243, -1, -1, -1, 486, -1, -1, -1,\n  // \"ab\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 81, -1, -1, -1, -1, -1, -1, -1,\n  // \"abs\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 108, -1, -1, -1, -1, -1, -1,\n  // \"abst\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 135, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"abstr\"\n  -1, 162, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"abstra\"\n  -1, -1, -1, 189, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"abstrac\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 216, -1, -1, -1, -1, -1, -1,\n  // \"abstract\"\n  ContextualKeyword._abstract << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"as\"\n  ContextualKeyword._as << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 270, -1, -1, -1, -1, -1, 405, -1,\n  // \"ass\"\n  -1, -1, -1, -1, -1, 297, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"asse\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 324, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"asser\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 351, -1, -1, -1, -1, -1, -1,\n  // \"assert\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 378, -1, -1, -1, -1, -1, -1, -1,\n  // \"asserts\"\n  ContextualKeyword._asserts << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"asy\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 432, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"asyn\"\n  -1, -1, -1, 459, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"async\"\n  ContextualKeyword._async << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"aw\"\n  -1, 513, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"awa\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, 540, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"awai\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 567, -1, -1, -1, -1, -1, -1,\n  // \"await\"\n  ContextualKeyword._await << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"b\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 621, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"br\"\n  -1, -1, -1, -1, -1, 648, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"bre\"\n  -1, 675, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"brea\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 702, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"break\"\n  (tt._break << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"c\"\n  -1, 756, -1, -1, -1, -1, -1, -1, 918, -1, -1, -1, 1053, -1, -1, 1161, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"ca\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 783, 837, -1, -1, -1, -1, -1, -1,\n  // \"cas\"\n  -1, -1, -1, -1, -1, 810, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"case\"\n  (tt._case << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"cat\"\n  -1, -1, -1, 864, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"catc\"\n  -1, -1, -1, -1, -1, -1, -1, -1, 891, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"catch\"\n  (tt._catch << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"ch\"\n  -1, -1, -1, -1, -1, 945, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"che\"\n  -1, -1, -1, 972, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"chec\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 999, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"check\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1026, -1, -1, -1, -1, -1, -1, -1,\n  // \"checks\"\n  ContextualKeyword._checks << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"cl\"\n  -1, 1080, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"cla\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1107, -1, -1, -1, -1, -1, -1, -1,\n  // \"clas\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1134, -1, -1, -1, -1, -1, -1, -1,\n  // \"class\"\n  (tt._class << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"co\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1188, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"con\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1215, 1431, -1, -1, -1, -1, -1, -1,\n  // \"cons\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1242, -1, -1, -1, -1, -1, -1,\n  // \"const\"\n  (tt._const << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1269, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"constr\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1296, -1, -1, -1, -1, -1,\n  // \"constru\"\n  -1, -1, -1, 1323, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"construc\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1350, -1, -1, -1, -1, -1, -1,\n  // \"construct\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1377, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"constructo\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1404, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"constructor\"\n  ContextualKeyword._constructor << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"cont\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, 1458, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"conti\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1485, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"contin\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1512, -1, -1, -1, -1, -1,\n  // \"continu\"\n  -1, -1, -1, -1, -1, 1539, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"continue\"\n  (tt._continue << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"d\"\n  -1, -1, -1, -1, -1, 1593, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2160, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"de\"\n  -1, -1, 1620, 1782, -1, -1, 1917, -1, -1, -1, -1, -1, 2052, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"deb\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1647, -1, -1, -1, -1, -1,\n  // \"debu\"\n  -1, -1, -1, -1, -1, -1, -1, 1674, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"debug\"\n  -1, -1, -1, -1, -1, -1, -1, 1701, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"debugg\"\n  -1, -1, -1, -1, -1, 1728, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"debugge\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1755, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"debugger\"\n  (tt._debugger << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"dec\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1809, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"decl\"\n  -1, 1836, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"decla\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1863, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"declar\"\n  -1, -1, -1, -1, -1, 1890, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"declare\"\n  ContextualKeyword._declare << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"def\"\n  -1, 1944, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"defa\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1971, -1, -1, -1, -1, -1,\n  // \"defau\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1998, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"defaul\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2025, -1, -1, -1, -1, -1, -1,\n  // \"default\"\n  (tt._default << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"del\"\n  -1, -1, -1, -1, -1, 2079, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"dele\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2106, -1, -1, -1, -1, -1, -1,\n  // \"delet\"\n  -1, -1, -1, -1, -1, 2133, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"delete\"\n  (tt._delete << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"do\"\n  (tt._do << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"e\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2214, -1, 2295, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2376, -1, -1,\n  // \"el\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2241, -1, -1, -1, -1, -1, -1, -1,\n  // \"els\"\n  -1, -1, -1, -1, -1, 2268, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"else\"\n  (tt._else << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"en\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2322, -1, -1, -1, -1, -1,\n  // \"enu\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2349, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"enum\"\n  ContextualKeyword._enum << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"ex\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2403, -1, -1, -1, 2538, -1, -1, -1, -1, -1, -1,\n  // \"exp\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2430, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"expo\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2457, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"expor\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2484, -1, -1, -1, -1, -1, -1,\n  // \"export\"\n  (tt._export << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2511, -1, -1, -1, -1, -1, -1, -1,\n  // \"exports\"\n  ContextualKeyword._exports << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"ext\"\n  -1, -1, -1, -1, -1, 2565, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"exte\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2592, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"exten\"\n  -1, -1, -1, -1, 2619, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"extend\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2646, -1, -1, -1, -1, -1, -1, -1,\n  // \"extends\"\n  (tt._extends << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"f\"\n  -1, 2700, -1, -1, -1, -1, -1, -1, -1, 2808, -1, -1, -1, -1, -1, 2970, -1, -1, 3024, -1, -1, 3105, -1, -1, -1, -1, -1,\n  // \"fa\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2727, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"fal\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2754, -1, -1, -1, -1, -1, -1, -1,\n  // \"fals\"\n  -1, -1, -1, -1, -1, 2781, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"false\"\n  (tt._false << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"fi\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2835, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"fin\"\n  -1, 2862, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"fina\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2889, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"final\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2916, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"finall\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2943, -1,\n  // \"finally\"\n  (tt._finally << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"fo\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2997, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"for\"\n  (tt._for << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"fr\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3051, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"fro\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3078, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"from\"\n  ContextualKeyword._from << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"fu\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3132, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"fun\"\n  -1, -1, -1, 3159, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"func\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3186, -1, -1, -1, -1, -1, -1,\n  // \"funct\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, 3213, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"functi\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3240, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"functio\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3267, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"function\"\n  (tt._function << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"g\"\n  -1, -1, -1, -1, -1, 3321, -1, -1, -1, -1, -1, -1, 3375, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"ge\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3348, -1, -1, -1, -1, -1, -1,\n  // \"get\"\n  ContextualKeyword._get << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"gl\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3402, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"glo\"\n  -1, -1, 3429, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"glob\"\n  -1, 3456, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"globa\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3483, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"global\"\n  ContextualKeyword._global << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"i\"\n  -1, -1, -1, -1, -1, -1, 3537, -1, -1, -1, -1, -1, -1, 3564, 3888, -1, -1, -1, -1, 4401, -1, -1, -1, -1, -1, -1, -1,\n  // \"if\"\n  (tt._if << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"im\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3591, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"imp\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3618, -1, -1, 3807, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"impl\"\n  -1, -1, -1, -1, -1, 3645, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"imple\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3672, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"implem\"\n  -1, -1, -1, -1, -1, 3699, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"impleme\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3726, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"implemen\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3753, -1, -1, -1, -1, -1, -1,\n  // \"implement\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3780, -1, -1, -1, -1, -1, -1, -1,\n  // \"implements\"\n  ContextualKeyword._implements << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"impo\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3834, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"impor\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3861, -1, -1, -1, -1, -1, -1,\n  // \"import\"\n  (tt._import << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"in\"\n  (tt._in << 1) + 1, -1, -1, -1, -1, -1, 3915, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3996, 4212, -1, -1, -1, -1, -1, -1,\n  // \"inf\"\n  -1, -1, -1, -1, -1, 3942, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"infe\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3969, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"infer\"\n  ContextualKeyword._infer << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"ins\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4023, -1, -1, -1, -1, -1, -1,\n  // \"inst\"\n  -1, 4050, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"insta\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4077, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"instan\"\n  -1, -1, -1, 4104, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"instanc\"\n  -1, -1, -1, -1, -1, 4131, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"instance\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4158, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"instanceo\"\n  -1, -1, -1, -1, -1, -1, 4185, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"instanceof\"\n  (tt._instanceof << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"int\"\n  -1, -1, -1, -1, -1, 4239, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"inte\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4266, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"inter\"\n  -1, -1, -1, -1, -1, -1, 4293, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"interf\"\n  -1, 4320, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"interfa\"\n  -1, -1, -1, 4347, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"interfac\"\n  -1, -1, -1, -1, -1, 4374, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"interface\"\n  ContextualKeyword._interface << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"is\"\n  ContextualKeyword._is << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"k\"\n  -1, -1, -1, -1, -1, 4455, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"ke\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4482, -1,\n  // \"key\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4509, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"keyo\"\n  -1, -1, -1, -1, -1, -1, 4536, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"keyof\"\n  ContextualKeyword._keyof << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"l\"\n  -1, -1, -1, -1, -1, 4590, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"le\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4617, -1, -1, -1, -1, -1, -1,\n  // \"let\"\n  (tt._let << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"m\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, 4671, -1, -1, -1, -1, -1, 4806, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"mi\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4698, -1, -1,\n  // \"mix\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, 4725, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"mixi\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4752, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"mixin\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4779, -1, -1, -1, -1, -1, -1, -1,\n  // \"mixins\"\n  ContextualKeyword._mixins << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"mo\"\n  -1, -1, -1, -1, 4833, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"mod\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4860, -1, -1, -1, -1, -1,\n  // \"modu\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4887, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"modul\"\n  -1, -1, -1, -1, -1, 4914, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"module\"\n  ContextualKeyword._module << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"n\"\n  -1, 4968, -1, -1, -1, 5184, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5238, -1, -1, -1, -1, -1,\n  // \"na\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4995, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"nam\"\n  -1, -1, -1, -1, -1, 5022, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"name\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5049, -1, -1, -1, -1, -1, -1, -1,\n  // \"names\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5076, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"namesp\"\n  -1, 5103, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"namespa\"\n  -1, -1, -1, 5130, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"namespac\"\n  -1, -1, -1, -1, -1, 5157, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"namespace\"\n  ContextualKeyword._namespace << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"ne\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5211, -1, -1, -1,\n  // \"new\"\n  (tt._new << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"nu\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5265, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"nul\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5292, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"null\"\n  (tt._null << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"o\"\n  -1, -1, -1, -1, -1, -1, 5346, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5373, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"of\"\n  ContextualKeyword._of << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"op\"\n  -1, 5400, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"opa\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5427, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"opaq\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5454, -1, -1, -1, -1, -1,\n  // \"opaqu\"\n  -1, -1, -1, -1, -1, 5481, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"opaque\"\n  ContextualKeyword._opaque << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"p\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5535, -1, -1, 5913, -1, -1, -1, -1, -1,\n  // \"pr\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, 5562, -1, -1, -1, -1, -1, 5697, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"pri\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5589, -1, -1, -1, -1,\n  // \"priv\"\n  -1, 5616, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"priva\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5643, -1, -1, -1, -1, -1, -1,\n  // \"privat\"\n  -1, -1, -1, -1, -1, 5670, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"private\"\n  ContextualKeyword._private << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"pro\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5724, -1, -1, -1, -1, -1, -1,\n  // \"prot\"\n  -1, -1, -1, -1, -1, 5751, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5886, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"prote\"\n  -1, -1, -1, 5778, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"protec\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5805, -1, -1, -1, -1, -1, -1,\n  // \"protect\"\n  -1, -1, -1, -1, -1, 5832, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"protecte\"\n  -1, -1, -1, -1, 5859, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"protected\"\n  ContextualKeyword._protected << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"proto\"\n  ContextualKeyword._proto << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"pu\"\n  -1, -1, 5940, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"pub\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5967, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"publ\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, 5994, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"publi\"\n  -1, -1, -1, 6021, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"public\"\n  ContextualKeyword._public << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"r\"\n  -1, -1, -1, -1, -1, 6075, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"re\"\n  -1, 6102, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6264, -1, -1, 6399, -1, -1, -1, -1, -1, -1,\n  // \"rea\"\n  -1, -1, -1, -1, 6129, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"read\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6156, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"reado\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6183, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"readon\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6210, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"readonl\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6237, -1,\n  // \"readonly\"\n  ContextualKeyword._readonly << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"req\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6291, -1, -1, -1, -1, -1,\n  // \"requ\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, 6318, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"requi\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6345, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"requir\"\n  -1, -1, -1, -1, -1, 6372, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"require\"\n  ContextualKeyword._require << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"ret\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6426, -1, -1, -1, -1, -1,\n  // \"retu\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6453, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"retur\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6480, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"return\"\n  (tt._return << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"s\"\n  -1, -1, -1, -1, -1, 6534, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6588, 6723, -1, 6831, -1, -1, -1,\n  // \"se\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6561, -1, -1, -1, -1, -1, -1,\n  // \"set\"\n  ContextualKeyword._set << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"st\"\n  -1, 6615, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"sta\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6642, -1, -1, -1, -1, -1, -1,\n  // \"stat\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, 6669, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"stati\"\n  -1, -1, -1, 6696, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"static\"\n  ContextualKeyword._static << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"su\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6750, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"sup\"\n  -1, -1, -1, -1, -1, 6777, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"supe\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6804, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"super\"\n  (tt._super << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"sw\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, 6858, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"swi\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6885, -1, -1, -1, -1, -1, -1,\n  // \"swit\"\n  -1, -1, -1, 6912, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"switc\"\n  -1, -1, -1, -1, -1, -1, -1, -1, 6939, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"switch\"\n  (tt._switch << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"t\"\n  -1, -1, -1, -1, -1, -1, -1, -1, 6993, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7155, -1, -1, -1, -1, -1, -1, 7263, -1,\n  // \"th\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, 7020, -1, -1, -1, -1, -1, -1, -1, -1, 7074, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"thi\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7047, -1, -1, -1, -1, -1, -1, -1,\n  // \"this\"\n  (tt._this << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"thr\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7101, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"thro\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7128, -1, -1, -1,\n  // \"throw\"\n  (tt._throw << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"tr\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7182, -1, -1, -1, 7236, -1,\n  // \"tru\"\n  -1, -1, -1, -1, -1, 7209, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"true\"\n  (tt._true << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"try\"\n  (tt._try << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"ty\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7290, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"typ\"\n  -1, -1, -1, -1, -1, 7317, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"type\"\n  ContextualKeyword._type << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7344, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"typeo\"\n  -1, -1, -1, -1, -1, -1, 7371, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"typeof\"\n  (tt._typeof << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"u\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7425, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"un\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, 7452, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"uni\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7479, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"uniq\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7506, -1, -1, -1, -1, -1,\n  // \"uniqu\"\n  -1, -1, -1, -1, -1, 7533, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"unique\"\n  ContextualKeyword._unique << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"v\"\n  -1, 7587, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7641, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"va\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7614, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"var\"\n  (tt._var << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"vo\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, 7668, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"voi\"\n  -1, -1, -1, -1, 7695, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"void\"\n  (tt._void << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"w\"\n  -1, -1, -1, -1, -1, -1, -1, -1, 7749, 7857, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"wh\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, 7776, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"whi\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7803, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"whil\"\n  -1, -1, -1, -1, -1, 7830, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"while\"\n  (tt._while << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"wi\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7884, -1, -1, -1, -1, -1, -1,\n  // \"wit\"\n  -1, -1, -1, -1, -1, -1, -1, -1, 7911, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"with\"\n  (tt._with << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"y\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, 7965, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"yi\"\n  -1, -1, -1, -1, -1, 7992, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"yie\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8019, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"yiel\"\n  -1, -1, -1, -1, 8046, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"yield\"\n  (tt._yield << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n]);\n","/* eslint max-len: 0 */\n\nimport {input, isFlowEnabled, state} from \"../traverser/base\";\nimport {unexpected} from \"../traverser/util\";\nimport {charCodes} from \"../util/charcodes\";\nimport {IS_IDENTIFIER_CHAR, IS_IDENTIFIER_START} from \"../util/identifier\";\nimport {IS_WHITESPACE} from \"../util/whitespace\";\nimport {ContextualKeyword} from \"./keywords\";\nimport readWord from \"./readWord\";\nimport { TokenType as tt} from \"./types\";\n\nexport var IdentifierRole; (function (IdentifierRole) {\n  const Access = 0; IdentifierRole[IdentifierRole[\"Access\"] = Access] = \"Access\";\n  const ExportAccess = Access + 1; IdentifierRole[IdentifierRole[\"ExportAccess\"] = ExportAccess] = \"ExportAccess\";\n  const TopLevelDeclaration = ExportAccess + 1; IdentifierRole[IdentifierRole[\"TopLevelDeclaration\"] = TopLevelDeclaration] = \"TopLevelDeclaration\";\n  const FunctionScopedDeclaration = TopLevelDeclaration + 1; IdentifierRole[IdentifierRole[\"FunctionScopedDeclaration\"] = FunctionScopedDeclaration] = \"FunctionScopedDeclaration\";\n  const BlockScopedDeclaration = FunctionScopedDeclaration + 1; IdentifierRole[IdentifierRole[\"BlockScopedDeclaration\"] = BlockScopedDeclaration] = \"BlockScopedDeclaration\";\n  const ObjectShorthandTopLevelDeclaration = BlockScopedDeclaration + 1; IdentifierRole[IdentifierRole[\"ObjectShorthandTopLevelDeclaration\"] = ObjectShorthandTopLevelDeclaration] = \"ObjectShorthandTopLevelDeclaration\";\n  const ObjectShorthandFunctionScopedDeclaration = ObjectShorthandTopLevelDeclaration + 1; IdentifierRole[IdentifierRole[\"ObjectShorthandFunctionScopedDeclaration\"] = ObjectShorthandFunctionScopedDeclaration] = \"ObjectShorthandFunctionScopedDeclaration\";\n  const ObjectShorthandBlockScopedDeclaration = ObjectShorthandFunctionScopedDeclaration + 1; IdentifierRole[IdentifierRole[\"ObjectShorthandBlockScopedDeclaration\"] = ObjectShorthandBlockScopedDeclaration] = \"ObjectShorthandBlockScopedDeclaration\";\n  const ObjectShorthand = ObjectShorthandBlockScopedDeclaration + 1; IdentifierRole[IdentifierRole[\"ObjectShorthand\"] = ObjectShorthand] = \"ObjectShorthand\";\n  // Any identifier bound in an import statement, e.g. both A and b from\n  // `import A, * as b from 'A';`\n  const ImportDeclaration = ObjectShorthand + 1; IdentifierRole[IdentifierRole[\"ImportDeclaration\"] = ImportDeclaration] = \"ImportDeclaration\";\n  const ObjectKey = ImportDeclaration + 1; IdentifierRole[IdentifierRole[\"ObjectKey\"] = ObjectKey] = \"ObjectKey\";\n  // The `foo` in `import {foo as bar} from \"./abc\";`.\n  const ImportAccess = ObjectKey + 1; IdentifierRole[IdentifierRole[\"ImportAccess\"] = ImportAccess] = \"ImportAccess\";\n})(IdentifierRole || (IdentifierRole = {}));\n\nexport function isDeclaration(token) {\n  const role = token.identifierRole;\n  return (\n    role === IdentifierRole.TopLevelDeclaration ||\n    role === IdentifierRole.FunctionScopedDeclaration ||\n    role === IdentifierRole.BlockScopedDeclaration ||\n    role === IdentifierRole.ObjectShorthandTopLevelDeclaration ||\n    role === IdentifierRole.ObjectShorthandFunctionScopedDeclaration ||\n    role === IdentifierRole.ObjectShorthandBlockScopedDeclaration\n  );\n}\n\nexport function isNonTopLevelDeclaration(token) {\n  const role = token.identifierRole;\n  return (\n    role === IdentifierRole.FunctionScopedDeclaration ||\n    role === IdentifierRole.BlockScopedDeclaration ||\n    role === IdentifierRole.ObjectShorthandFunctionScopedDeclaration ||\n    role === IdentifierRole.ObjectShorthandBlockScopedDeclaration\n  );\n}\n\nexport function isTopLevelDeclaration(token) {\n  const role = token.identifierRole;\n  return (\n    role === IdentifierRole.TopLevelDeclaration ||\n    role === IdentifierRole.ObjectShorthandTopLevelDeclaration ||\n    role === IdentifierRole.ImportDeclaration\n  );\n}\n\nexport function isBlockScopedDeclaration(token) {\n  const role = token.identifierRole;\n  // Treat top-level declarations as block scope since the distinction doesn't matter here.\n  return (\n    role === IdentifierRole.TopLevelDeclaration ||\n    role === IdentifierRole.BlockScopedDeclaration ||\n    role === IdentifierRole.ObjectShorthandTopLevelDeclaration ||\n    role === IdentifierRole.ObjectShorthandBlockScopedDeclaration\n  );\n}\n\nexport function isFunctionScopedDeclaration(token) {\n  const role = token.identifierRole;\n  return (\n    role === IdentifierRole.FunctionScopedDeclaration ||\n    role === IdentifierRole.ObjectShorthandFunctionScopedDeclaration\n  );\n}\n\nexport function isObjectShorthandDeclaration(token) {\n  return (\n    token.identifierRole === IdentifierRole.ObjectShorthandTopLevelDeclaration ||\n    token.identifierRole === IdentifierRole.ObjectShorthandBlockScopedDeclaration ||\n    token.identifierRole === IdentifierRole.ObjectShorthandFunctionScopedDeclaration\n  );\n}\n\n// Object type used to represent tokens. Note that normally, tokens\n// simply exist as properties on the parser object. This is only\n// used for the onToken callback and the external tokenizer.\nexport class Token {\n  constructor() {\n    this.type = state.type;\n    this.contextualKeyword = state.contextualKeyword;\n    this.start = state.start;\n    this.end = state.end;\n    this.scopeDepth = state.scopeDepth;\n    this.isType = state.isType;\n    this.identifierRole = null;\n    this.shadowsGlobal = false;\n    this.contextId = null;\n    this.rhsEndIndex = null;\n    this.isExpression = false;\n    this.numNullishCoalesceStarts = 0;\n    this.numNullishCoalesceEnds = 0;\n    this.isOptionalChainStart = false;\n    this.isOptionalChainEnd = false;\n    this.subscriptStartIndex = null;\n    this.nullishStartIndex = null;\n  }\n\n  \n  \n  \n  \n  \n  \n  \n  // Initially false for all tokens, then may be computed in a follow-up step that does scope\n  // analysis.\n  \n  // Initially false for all tokens, but may be set during transform to mark it as containing an\n  // await operation.\n  \n  \n  // For assignments, the index of the RHS. For export tokens, the end of the export.\n  \n  // For class tokens, records if the class is a class expression or a class statement.\n  \n  // Number of times to insert a `nullishCoalesce(` snippet before this token.\n  \n  // Number of times to insert a `)` snippet after this token.\n  \n  // If true, insert an `optionalChain([` snippet before this token.\n  \n  // If true, insert a `])` snippet after this token.\n  \n  // Tag for `.`, `?.`, `[`, `?.[`, `(`, and `?.(` to denote the \"root\" token for this\n  // subscript chain. This can be used to determine if this chain is an optional chain.\n  \n  // Tag for `??` operators to denote the root token for this nullish coalescing call.\n  \n}\n\n// ## Tokenizer\n\n// Move to the next token\nexport function next() {\n  state.tokens.push(new Token());\n  nextToken();\n}\n\n// Call instead of next when inside a template, since that needs to be handled differently.\nexport function nextTemplateToken() {\n  state.tokens.push(new Token());\n  state.start = state.pos;\n  readTmplToken();\n}\n\n// The tokenizer never parses regexes by default. Instead, the parser is responsible for\n// instructing it to parse a regex when we see a slash at the start of an expression.\nexport function retokenizeSlashAsRegex() {\n  if (state.type === tt.assign) {\n    --state.pos;\n  }\n  readRegexp();\n}\n\nexport function pushTypeContext(existingTokensInType) {\n  for (let i = state.tokens.length - existingTokensInType; i < state.tokens.length; i++) {\n    state.tokens[i].isType = true;\n  }\n  const oldIsType = state.isType;\n  state.isType = true;\n  return oldIsType;\n}\n\nexport function popTypeContext(oldIsType) {\n  state.isType = oldIsType;\n}\n\nexport function eat(type) {\n  if (match(type)) {\n    next();\n    return true;\n  } else {\n    return false;\n  }\n}\n\nexport function match(type) {\n  return state.type === type;\n}\n\nexport function lookaheadType() {\n  const snapshot = state.snapshot();\n  next();\n  const type = state.type;\n  state.restoreFromSnapshot(snapshot);\n  return type;\n}\n\nexport class TypeAndKeyword {\n  \n  \n  constructor(type, contextualKeyword) {\n    this.type = type;\n    this.contextualKeyword = contextualKeyword;\n  }\n}\n\nexport function lookaheadTypeAndKeyword() {\n  const snapshot = state.snapshot();\n  next();\n  const type = state.type;\n  const contextualKeyword = state.contextualKeyword;\n  state.restoreFromSnapshot(snapshot);\n  return new TypeAndKeyword(type, contextualKeyword);\n}\n\n// Read a single token, updating the parser object's token-related\n// properties.\nexport function nextToken() {\n  skipSpace();\n  state.start = state.pos;\n  if (state.pos >= input.length) {\n    const tokens = state.tokens;\n    // We normally run past the end a bit, but if we're way past the end, avoid an infinite loop.\n    // Also check the token positions rather than the types since sometimes we rewrite the token\n    // type to something else.\n    if (\n      tokens.length >= 2 &&\n      tokens[tokens.length - 1].start >= input.length &&\n      tokens[tokens.length - 2].start >= input.length\n    ) {\n      unexpected(\"Unexpectedly reached the end of input.\");\n    }\n    finishToken(tt.eof);\n    return;\n  }\n  readToken(input.charCodeAt(state.pos));\n}\n\nfunction readToken(code) {\n  // Identifier or keyword. '\\uXXXX' sequences are allowed in\n  // identifiers, so '\\' also dispatches to that.\n  if (\n    IS_IDENTIFIER_START[code] ||\n    code === charCodes.backslash ||\n    (code === charCodes.atSign && input.charCodeAt(state.pos + 1) === charCodes.atSign)\n  ) {\n    readWord();\n  } else {\n    getTokenFromCode(code);\n  }\n}\n\nfunction skipBlockComment() {\n  while (\n    input.charCodeAt(state.pos) !== charCodes.asterisk ||\n    input.charCodeAt(state.pos + 1) !== charCodes.slash\n  ) {\n    state.pos++;\n    if (state.pos > input.length) {\n      unexpected(\"Unterminated comment\", state.pos - 2);\n      return;\n    }\n  }\n  state.pos += 2;\n}\n\nexport function skipLineComment(startSkip) {\n  let ch = input.charCodeAt((state.pos += startSkip));\n  if (state.pos < input.length) {\n    while (\n      ch !== charCodes.lineFeed &&\n      ch !== charCodes.carriageReturn &&\n      ch !== charCodes.lineSeparator &&\n      ch !== charCodes.paragraphSeparator &&\n      ++state.pos < input.length\n    ) {\n      ch = input.charCodeAt(state.pos);\n    }\n  }\n}\n\n// Called at the start of the parse and after every token. Skips\n// whitespace and comments.\nexport function skipSpace() {\n  while (state.pos < input.length) {\n    const ch = input.charCodeAt(state.pos);\n    switch (ch) {\n      case charCodes.carriageReturn:\n        if (input.charCodeAt(state.pos + 1) === charCodes.lineFeed) {\n          ++state.pos;\n        }\n\n      case charCodes.lineFeed:\n      case charCodes.lineSeparator:\n      case charCodes.paragraphSeparator:\n        ++state.pos;\n        break;\n\n      case charCodes.slash:\n        switch (input.charCodeAt(state.pos + 1)) {\n          case charCodes.asterisk:\n            state.pos += 2;\n            skipBlockComment();\n            break;\n\n          case charCodes.slash:\n            skipLineComment(2);\n            break;\n\n          default:\n            return;\n        }\n        break;\n\n      default:\n        if (IS_WHITESPACE[ch]) {\n          ++state.pos;\n        } else {\n          return;\n        }\n    }\n  }\n}\n\n// Called at the end of every token. Sets various fields, and skips the space after the token, so\n// that the next one's `start` will point at the right position.\nexport function finishToken(\n  type,\n  contextualKeyword = ContextualKeyword.NONE,\n) {\n  state.end = state.pos;\n  state.type = type;\n  state.contextualKeyword = contextualKeyword;\n}\n\n// ### Token reading\n\n// This is the function that is called to fetch the next token. It\n// is somewhat obscure, because it works in character codes rather\n// than characters, and because operator parsing has been inlined\n// into it.\n//\n// All in the name of speed.\nfunction readToken_dot() {\n  const nextChar = input.charCodeAt(state.pos + 1);\n  if (nextChar >= charCodes.digit0 && nextChar <= charCodes.digit9) {\n    readNumber(true);\n    return;\n  }\n\n  if (nextChar === charCodes.dot && input.charCodeAt(state.pos + 2) === charCodes.dot) {\n    state.pos += 3;\n    finishToken(tt.ellipsis);\n  } else {\n    ++state.pos;\n    finishToken(tt.dot);\n  }\n}\n\nfunction readToken_slash() {\n  const nextChar = input.charCodeAt(state.pos + 1);\n  if (nextChar === charCodes.equalsTo) {\n    finishOp(tt.assign, 2);\n  } else {\n    finishOp(tt.slash, 1);\n  }\n}\n\nfunction readToken_mult_modulo(code) {\n  // '%*'\n  let tokenType = code === charCodes.asterisk ? tt.star : tt.modulo;\n  let width = 1;\n  let nextChar = input.charCodeAt(state.pos + 1);\n\n  // Exponentiation operator **\n  if (code === charCodes.asterisk && nextChar === charCodes.asterisk) {\n    width++;\n    nextChar = input.charCodeAt(state.pos + 2);\n    tokenType = tt.exponent;\n  }\n\n  // Match *= or %=, disallowing *=> which can be valid in flow.\n  if (\n    nextChar === charCodes.equalsTo &&\n    input.charCodeAt(state.pos + 2) !== charCodes.greaterThan\n  ) {\n    width++;\n    tokenType = tt.assign;\n  }\n\n  finishOp(tokenType, width);\n}\n\nfunction readToken_pipe_amp(code) {\n  // '|&'\n  const nextChar = input.charCodeAt(state.pos + 1);\n\n  if (nextChar === code) {\n    if (input.charCodeAt(state.pos + 2) === charCodes.equalsTo) {\n      // ||= or &&=\n      finishOp(tt.assign, 3);\n    } else {\n      // || or &&\n      finishOp(code === charCodes.verticalBar ? tt.logicalOR : tt.logicalAND, 2);\n    }\n    return;\n  }\n\n  if (code === charCodes.verticalBar) {\n    // '|>'\n    if (nextChar === charCodes.greaterThan) {\n      finishOp(tt.pipeline, 2);\n      return;\n    } else if (nextChar === charCodes.rightCurlyBrace && isFlowEnabled) {\n      // '|}'\n      finishOp(tt.braceBarR, 2);\n      return;\n    }\n  }\n\n  if (nextChar === charCodes.equalsTo) {\n    finishOp(tt.assign, 2);\n    return;\n  }\n\n  finishOp(code === charCodes.verticalBar ? tt.bitwiseOR : tt.bitwiseAND, 1);\n}\n\nfunction readToken_caret() {\n  // '^'\n  const nextChar = input.charCodeAt(state.pos + 1);\n  if (nextChar === charCodes.equalsTo) {\n    finishOp(tt.assign, 2);\n  } else {\n    finishOp(tt.bitwiseXOR, 1);\n  }\n}\n\nfunction readToken_plus_min(code) {\n  // '+-'\n  const nextChar = input.charCodeAt(state.pos + 1);\n\n  if (nextChar === code) {\n    // Tentatively call this a prefix operator, but it might be changed to postfix later.\n    finishOp(tt.preIncDec, 2);\n    return;\n  }\n\n  if (nextChar === charCodes.equalsTo) {\n    finishOp(tt.assign, 2);\n  } else if (code === charCodes.plusSign) {\n    finishOp(tt.plus, 1);\n  } else {\n    finishOp(tt.minus, 1);\n  }\n}\n\n// '<>'\nfunction readToken_lt_gt(code) {\n  // Avoid right-shift for things like Array<Array<string>>.\n  if (code === charCodes.greaterThan && state.isType) {\n    finishOp(tt.greaterThan, 1);\n    return;\n  }\n  const nextChar = input.charCodeAt(state.pos + 1);\n\n  if (nextChar === code) {\n    const size =\n      code === charCodes.greaterThan && input.charCodeAt(state.pos + 2) === charCodes.greaterThan\n        ? 3\n        : 2;\n    if (input.charCodeAt(state.pos + size) === charCodes.equalsTo) {\n      finishOp(tt.assign, size + 1);\n      return;\n    }\n    finishOp(tt.bitShift, size);\n    return;\n  }\n\n  if (nextChar === charCodes.equalsTo) {\n    // <= | >=\n    finishOp(tt.relationalOrEqual, 2);\n  } else if (code === charCodes.lessThan) {\n    finishOp(tt.lessThan, 1);\n  } else {\n    finishOp(tt.greaterThan, 1);\n  }\n}\n\nfunction readToken_eq_excl(code) {\n  // '=!'\n  const nextChar = input.charCodeAt(state.pos + 1);\n  if (nextChar === charCodes.equalsTo) {\n    finishOp(tt.equality, input.charCodeAt(state.pos + 2) === charCodes.equalsTo ? 3 : 2);\n    return;\n  }\n  if (code === charCodes.equalsTo && nextChar === charCodes.greaterThan) {\n    // '=>'\n    state.pos += 2;\n    finishToken(tt.arrow);\n    return;\n  }\n  finishOp(code === charCodes.equalsTo ? tt.eq : tt.bang, 1);\n}\n\nfunction readToken_question() {\n  // '?'\n  const nextChar = input.charCodeAt(state.pos + 1);\n  const nextChar2 = input.charCodeAt(state.pos + 2);\n  if (nextChar === charCodes.questionMark && !state.isType) {\n    if (nextChar2 === charCodes.equalsTo) {\n      // '??='\n      finishOp(tt.assign, 3);\n    } else {\n      // '??'\n      finishOp(tt.nullishCoalescing, 2);\n    }\n  } else if (\n    nextChar === charCodes.dot &&\n    !(nextChar2 >= charCodes.digit0 && nextChar2 <= charCodes.digit9)\n  ) {\n    // '.' not followed by a number\n    state.pos += 2;\n    finishToken(tt.questionDot);\n  } else {\n    ++state.pos;\n    finishToken(tt.question);\n  }\n}\n\nexport function getTokenFromCode(code) {\n  switch (code) {\n    case charCodes.numberSign:\n      ++state.pos;\n      finishToken(tt.hash);\n      return;\n\n    // The interpretation of a dot depends on whether it is followed\n    // by a digit or another two dots.\n\n    case charCodes.dot:\n      readToken_dot();\n      return;\n\n    // Punctuation tokens.\n    case charCodes.leftParenthesis:\n      ++state.pos;\n      finishToken(tt.parenL);\n      return;\n    case charCodes.rightParenthesis:\n      ++state.pos;\n      finishToken(tt.parenR);\n      return;\n    case charCodes.semicolon:\n      ++state.pos;\n      finishToken(tt.semi);\n      return;\n    case charCodes.comma:\n      ++state.pos;\n      finishToken(tt.comma);\n      return;\n    case charCodes.leftSquareBracket:\n      ++state.pos;\n      finishToken(tt.bracketL);\n      return;\n    case charCodes.rightSquareBracket:\n      ++state.pos;\n      finishToken(tt.bracketR);\n      return;\n\n    case charCodes.leftCurlyBrace:\n      if (isFlowEnabled && input.charCodeAt(state.pos + 1) === charCodes.verticalBar) {\n        finishOp(tt.braceBarL, 2);\n      } else {\n        ++state.pos;\n        finishToken(tt.braceL);\n      }\n      return;\n\n    case charCodes.rightCurlyBrace:\n      ++state.pos;\n      finishToken(tt.braceR);\n      return;\n\n    case charCodes.colon:\n      if (input.charCodeAt(state.pos + 1) === charCodes.colon) {\n        finishOp(tt.doubleColon, 2);\n      } else {\n        ++state.pos;\n        finishToken(tt.colon);\n      }\n      return;\n\n    case charCodes.questionMark:\n      readToken_question();\n      return;\n    case charCodes.atSign:\n      ++state.pos;\n      finishToken(tt.at);\n      return;\n\n    case charCodes.graveAccent:\n      ++state.pos;\n      finishToken(tt.backQuote);\n      return;\n\n    case charCodes.digit0: {\n      const nextChar = input.charCodeAt(state.pos + 1);\n      // '0x', '0X', '0o', '0O', '0b', '0B'\n      if (\n        nextChar === charCodes.lowercaseX ||\n        nextChar === charCodes.uppercaseX ||\n        nextChar === charCodes.lowercaseO ||\n        nextChar === charCodes.uppercaseO ||\n        nextChar === charCodes.lowercaseB ||\n        nextChar === charCodes.uppercaseB\n      ) {\n        readRadixNumber();\n        return;\n      }\n    }\n    // Anything else beginning with a digit is an integer, octal\n    // number, or float.\n    case charCodes.digit1:\n    case charCodes.digit2:\n    case charCodes.digit3:\n    case charCodes.digit4:\n    case charCodes.digit5:\n    case charCodes.digit6:\n    case charCodes.digit7:\n    case charCodes.digit8:\n    case charCodes.digit9:\n      readNumber(false);\n      return;\n\n    // Quotes produce strings.\n    case charCodes.quotationMark:\n    case charCodes.apostrophe:\n      readString(code);\n      return;\n\n    // Operators are parsed inline in tiny state machines. '=' (charCodes.equalsTo) is\n    // often referred to. `finishOp` simply skips the amount of\n    // characters it is given as second argument, and returns a token\n    // of the type given by its first argument.\n\n    case charCodes.slash:\n      readToken_slash();\n      return;\n\n    case charCodes.percentSign:\n    case charCodes.asterisk:\n      readToken_mult_modulo(code);\n      return;\n\n    case charCodes.verticalBar:\n    case charCodes.ampersand:\n      readToken_pipe_amp(code);\n      return;\n\n    case charCodes.caret:\n      readToken_caret();\n      return;\n\n    case charCodes.plusSign:\n    case charCodes.dash:\n      readToken_plus_min(code);\n      return;\n\n    case charCodes.lessThan:\n    case charCodes.greaterThan:\n      readToken_lt_gt(code);\n      return;\n\n    case charCodes.equalsTo:\n    case charCodes.exclamationMark:\n      readToken_eq_excl(code);\n      return;\n\n    case charCodes.tilde:\n      finishOp(tt.tilde, 1);\n      return;\n\n    default:\n      break;\n  }\n\n  unexpected(`Unexpected character '${String.fromCharCode(code)}'`, state.pos);\n}\n\nfunction finishOp(type, size) {\n  state.pos += size;\n  finishToken(type);\n}\n\nfunction readRegexp() {\n  const start = state.pos;\n  let escaped = false;\n  let inClass = false;\n  for (;;) {\n    if (state.pos >= input.length) {\n      unexpected(\"Unterminated regular expression\", start);\n      return;\n    }\n    const code = input.charCodeAt(state.pos);\n    if (escaped) {\n      escaped = false;\n    } else {\n      if (code === charCodes.leftSquareBracket) {\n        inClass = true;\n      } else if (code === charCodes.rightSquareBracket && inClass) {\n        inClass = false;\n      } else if (code === charCodes.slash && !inClass) {\n        break;\n      }\n      escaped = code === charCodes.backslash;\n    }\n    ++state.pos;\n  }\n  ++state.pos;\n  // Need to use `skipWord` because '\\uXXXX' sequences are allowed here (don't ask).\n  skipWord();\n\n  finishToken(tt.regexp);\n}\n\n// Read an integer. We allow any valid digit, including hex digits, plus numeric separators, and\n// stop at any other character.\nfunction readInt() {\n  while (true) {\n    const code = input.charCodeAt(state.pos);\n    if (\n      (code >= charCodes.digit0 && code <= charCodes.digit9) ||\n      (code >= charCodes.lowercaseA && code <= charCodes.lowercaseF) ||\n      (code >= charCodes.uppercaseA && code <= charCodes.uppercaseF) ||\n      code === charCodes.underscore\n    ) {\n      state.pos++;\n    } else {\n      break;\n    }\n  }\n}\n\nfunction readRadixNumber() {\n  let isBigInt = false;\n\n  state.pos += 2; // 0x\n  readInt();\n\n  if (input.charCodeAt(state.pos) === charCodes.lowercaseN) {\n    ++state.pos;\n    isBigInt = true;\n  }\n\n  if (isBigInt) {\n    finishToken(tt.bigint);\n    return;\n  }\n\n  finishToken(tt.num);\n}\n\n// Read an integer, octal integer, or floating-point number.\nfunction readNumber(startsWithDot) {\n  let isBigInt = false;\n\n  if (!startsWithDot) {\n    readInt();\n  }\n\n  let nextChar = input.charCodeAt(state.pos);\n  if (nextChar === charCodes.dot) {\n    ++state.pos;\n    readInt();\n    nextChar = input.charCodeAt(state.pos);\n  }\n\n  if (nextChar === charCodes.uppercaseE || nextChar === charCodes.lowercaseE) {\n    nextChar = input.charCodeAt(++state.pos);\n    if (nextChar === charCodes.plusSign || nextChar === charCodes.dash) {\n      ++state.pos;\n    }\n    readInt();\n    nextChar = input.charCodeAt(state.pos);\n  }\n\n  if (nextChar === charCodes.lowercaseN) {\n    ++state.pos;\n    isBigInt = true;\n  }\n\n  if (isBigInt) {\n    finishToken(tt.bigint);\n    return;\n  }\n  finishToken(tt.num);\n}\n\nfunction readString(quote) {\n  state.pos++;\n  for (;;) {\n    if (state.pos >= input.length) {\n      unexpected(\"Unterminated string constant\");\n      return;\n    }\n    const ch = input.charCodeAt(state.pos);\n    if (ch === charCodes.backslash) {\n      state.pos++;\n    } else if (ch === quote) {\n      break;\n    }\n    state.pos++;\n  }\n  state.pos++;\n  finishToken(tt.string);\n}\n\n// Reads template string tokens.\nfunction readTmplToken() {\n  for (;;) {\n    if (state.pos >= input.length) {\n      unexpected(\"Unterminated template\");\n      return;\n    }\n    const ch = input.charCodeAt(state.pos);\n    if (\n      ch === charCodes.graveAccent ||\n      (ch === charCodes.dollarSign && input.charCodeAt(state.pos + 1) === charCodes.leftCurlyBrace)\n    ) {\n      if (state.pos === state.start && match(tt.template)) {\n        if (ch === charCodes.dollarSign) {\n          state.pos += 2;\n          finishToken(tt.dollarBraceL);\n          return;\n        } else {\n          ++state.pos;\n          finishToken(tt.backQuote);\n          return;\n        }\n      }\n      finishToken(tt.template);\n      return;\n    }\n    if (ch === charCodes.backslash) {\n      state.pos++;\n    }\n    state.pos++;\n  }\n}\n\n// Skip to the end of the current word. Note that this is the same as the snippet at the end of\n// readWord, but calling skipWord from readWord seems to slightly hurt performance from some rough\n// measurements.\nexport function skipWord() {\n  while (state.pos < input.length) {\n    const ch = input.charCodeAt(state.pos);\n    if (IS_IDENTIFIER_CHAR[ch]) {\n      state.pos++;\n    } else if (ch === charCodes.backslash) {\n      // \\u\n      state.pos += 2;\n      if (input.charCodeAt(state.pos) === charCodes.leftCurlyBrace) {\n        while (\n          state.pos < input.length &&\n          input.charCodeAt(state.pos) !== charCodes.rightCurlyBrace\n        ) {\n          state.pos++;\n        }\n        state.pos++;\n      }\n    } else {\n      break;\n    }\n  }\n}\n","import {input, state} from \"../traverser/base\";\nimport {charCodes} from \"../util/charcodes\";\nimport {IS_IDENTIFIER_CHAR} from \"../util/identifier\";\nimport {finishToken} from \"./index\";\nimport {READ_WORD_TREE} from \"./readWordTree\";\nimport {TokenType as tt} from \"./types\";\n\n/**\n * Read an identifier, producing either a name token or matching on one of the existing keywords.\n * For performance, we pre-generate big decision tree that we traverse. Each node represents a\n * prefix and has 27 values, where the first value is the token or contextual token, if any (-1 if\n * not), and the other 26 values are the transitions to other nodes, or -1 to stop.\n */\nexport default function readWord() {\n  let treePos = 0;\n  let code = 0;\n  let pos = state.pos;\n  while (pos < input.length) {\n    code = input.charCodeAt(pos);\n    if (code < charCodes.lowercaseA || code > charCodes.lowercaseZ) {\n      break;\n    }\n    const next = READ_WORD_TREE[treePos + (code - charCodes.lowercaseA) + 1];\n    if (next === -1) {\n      break;\n    } else {\n      treePos = next;\n      pos++;\n    }\n  }\n\n  const keywordValue = READ_WORD_TREE[treePos];\n  if (keywordValue > -1 && !IS_IDENTIFIER_CHAR[code]) {\n    state.pos = pos;\n    if (keywordValue & 1) {\n      finishToken(keywordValue >>> 1);\n    } else {\n      finishToken(tt.name, keywordValue >>> 1);\n    }\n    return;\n  }\n\n  while (pos < input.length) {\n    const ch = input.charCodeAt(pos);\n    if (IS_IDENTIFIER_CHAR[ch]) {\n      pos++;\n    } else if (ch === charCodes.backslash) {\n      // \\u\n      pos += 2;\n      if (input.charCodeAt(pos) === charCodes.leftCurlyBrace) {\n        while (pos < input.length && input.charCodeAt(pos) !== charCodes.rightCurlyBrace) {\n          pos++;\n        }\n        pos++;\n      }\n    } else if (ch === charCodes.atSign && input.charCodeAt(pos + 1) === charCodes.atSign) {\n      pos += 2;\n    } else {\n      break;\n    }\n  }\n  state.pos = pos;\n  finishToken(tt.name);\n}\n","const entities = {\n  quot: \"\\u0022\",\n  amp: \"&\",\n  apos: \"\\u0027\",\n  lt: \"<\",\n  gt: \">\",\n  nbsp: \"\\u00A0\",\n  iexcl: \"\\u00A1\",\n  cent: \"\\u00A2\",\n  pound: \"\\u00A3\",\n  curren: \"\\u00A4\",\n  yen: \"\\u00A5\",\n  brvbar: \"\\u00A6\",\n  sect: \"\\u00A7\",\n  uml: \"\\u00A8\",\n  copy: \"\\u00A9\",\n  ordf: \"\\u00AA\",\n  laquo: \"\\u00AB\",\n  not: \"\\u00AC\",\n  shy: \"\\u00AD\",\n  reg: \"\\u00AE\",\n  macr: \"\\u00AF\",\n  deg: \"\\u00B0\",\n  plusmn: \"\\u00B1\",\n  sup2: \"\\u00B2\",\n  sup3: \"\\u00B3\",\n  acute: \"\\u00B4\",\n  micro: \"\\u00B5\",\n  para: \"\\u00B6\",\n  middot: \"\\u00B7\",\n  cedil: \"\\u00B8\",\n  sup1: \"\\u00B9\",\n  ordm: \"\\u00BA\",\n  raquo: \"\\u00BB\",\n  frac14: \"\\u00BC\",\n  frac12: \"\\u00BD\",\n  frac34: \"\\u00BE\",\n  iquest: \"\\u00BF\",\n  Agrave: \"\\u00C0\",\n  Aacute: \"\\u00C1\",\n  Acirc: \"\\u00C2\",\n  Atilde: \"\\u00C3\",\n  Auml: \"\\u00C4\",\n  Aring: \"\\u00C5\",\n  AElig: \"\\u00C6\",\n  Ccedil: \"\\u00C7\",\n  Egrave: \"\\u00C8\",\n  Eacute: \"\\u00C9\",\n  Ecirc: \"\\u00CA\",\n  Euml: \"\\u00CB\",\n  Igrave: \"\\u00CC\",\n  Iacute: \"\\u00CD\",\n  Icirc: \"\\u00CE\",\n  Iuml: \"\\u00CF\",\n  ETH: \"\\u00D0\",\n  Ntilde: \"\\u00D1\",\n  Ograve: \"\\u00D2\",\n  Oacute: \"\\u00D3\",\n  Ocirc: \"\\u00D4\",\n  Otilde: \"\\u00D5\",\n  Ouml: \"\\u00D6\",\n  times: \"\\u00D7\",\n  Oslash: \"\\u00D8\",\n  Ugrave: \"\\u00D9\",\n  Uacute: \"\\u00DA\",\n  Ucirc: \"\\u00DB\",\n  Uuml: \"\\u00DC\",\n  Yacute: \"\\u00DD\",\n  THORN: \"\\u00DE\",\n  szlig: \"\\u00DF\",\n  agrave: \"\\u00E0\",\n  aacute: \"\\u00E1\",\n  acirc: \"\\u00E2\",\n  atilde: \"\\u00E3\",\n  auml: \"\\u00E4\",\n  aring: \"\\u00E5\",\n  aelig: \"\\u00E6\",\n  ccedil: \"\\u00E7\",\n  egrave: \"\\u00E8\",\n  eacute: \"\\u00E9\",\n  ecirc: \"\\u00EA\",\n  euml: \"\\u00EB\",\n  igrave: \"\\u00EC\",\n  iacute: \"\\u00ED\",\n  icirc: \"\\u00EE\",\n  iuml: \"\\u00EF\",\n  eth: \"\\u00F0\",\n  ntilde: \"\\u00F1\",\n  ograve: \"\\u00F2\",\n  oacute: \"\\u00F3\",\n  ocirc: \"\\u00F4\",\n  otilde: \"\\u00F5\",\n  ouml: \"\\u00F6\",\n  divide: \"\\u00F7\",\n  oslash: \"\\u00F8\",\n  ugrave: \"\\u00F9\",\n  uacute: \"\\u00FA\",\n  ucirc: \"\\u00FB\",\n  uuml: \"\\u00FC\",\n  yacute: \"\\u00FD\",\n  thorn: \"\\u00FE\",\n  yuml: \"\\u00FF\",\n  OElig: \"\\u0152\",\n  oelig: \"\\u0153\",\n  Scaron: \"\\u0160\",\n  scaron: \"\\u0161\",\n  Yuml: \"\\u0178\",\n  fnof: \"\\u0192\",\n  circ: \"\\u02C6\",\n  tilde: \"\\u02DC\",\n  Alpha: \"\\u0391\",\n  Beta: \"\\u0392\",\n  Gamma: \"\\u0393\",\n  Delta: \"\\u0394\",\n  Epsilon: \"\\u0395\",\n  Zeta: \"\\u0396\",\n  Eta: \"\\u0397\",\n  Theta: \"\\u0398\",\n  Iota: \"\\u0399\",\n  Kappa: \"\\u039A\",\n  Lambda: \"\\u039B\",\n  Mu: \"\\u039C\",\n  Nu: \"\\u039D\",\n  Xi: \"\\u039E\",\n  Omicron: \"\\u039F\",\n  Pi: \"\\u03A0\",\n  Rho: \"\\u03A1\",\n  Sigma: \"\\u03A3\",\n  Tau: \"\\u03A4\",\n  Upsilon: \"\\u03A5\",\n  Phi: \"\\u03A6\",\n  Chi: \"\\u03A7\",\n  Psi: \"\\u03A8\",\n  Omega: \"\\u03A9\",\n  alpha: \"\\u03B1\",\n  beta: \"\\u03B2\",\n  gamma: \"\\u03B3\",\n  delta: \"\\u03B4\",\n  epsilon: \"\\u03B5\",\n  zeta: \"\\u03B6\",\n  eta: \"\\u03B7\",\n  theta: \"\\u03B8\",\n  iota: \"\\u03B9\",\n  kappa: \"\\u03BA\",\n  lambda: \"\\u03BB\",\n  mu: \"\\u03BC\",\n  nu: \"\\u03BD\",\n  xi: \"\\u03BE\",\n  omicron: \"\\u03BF\",\n  pi: \"\\u03C0\",\n  rho: \"\\u03C1\",\n  sigmaf: \"\\u03C2\",\n  sigma: \"\\u03C3\",\n  tau: \"\\u03C4\",\n  upsilon: \"\\u03C5\",\n  phi: \"\\u03C6\",\n  chi: \"\\u03C7\",\n  psi: \"\\u03C8\",\n  omega: \"\\u03C9\",\n  thetasym: \"\\u03D1\",\n  upsih: \"\\u03D2\",\n  piv: \"\\u03D6\",\n  ensp: \"\\u2002\",\n  emsp: \"\\u2003\",\n  thinsp: \"\\u2009\",\n  zwnj: \"\\u200C\",\n  zwj: \"\\u200D\",\n  lrm: \"\\u200E\",\n  rlm: \"\\u200F\",\n  ndash: \"\\u2013\",\n  mdash: \"\\u2014\",\n  lsquo: \"\\u2018\",\n  rsquo: \"\\u2019\",\n  sbquo: \"\\u201A\",\n  ldquo: \"\\u201C\",\n  rdquo: \"\\u201D\",\n  bdquo: \"\\u201E\",\n  dagger: \"\\u2020\",\n  Dagger: \"\\u2021\",\n  bull: \"\\u2022\",\n  hellip: \"\\u2026\",\n  permil: \"\\u2030\",\n  prime: \"\\u2032\",\n  Prime: \"\\u2033\",\n  lsaquo: \"\\u2039\",\n  rsaquo: \"\\u203A\",\n  oline: \"\\u203E\",\n  frasl: \"\\u2044\",\n  euro: \"\\u20AC\",\n  image: \"\\u2111\",\n  weierp: \"\\u2118\",\n  real: \"\\u211C\",\n  trade: \"\\u2122\",\n  alefsym: \"\\u2135\",\n  larr: \"\\u2190\",\n  uarr: \"\\u2191\",\n  rarr: \"\\u2192\",\n  darr: \"\\u2193\",\n  harr: \"\\u2194\",\n  crarr: \"\\u21B5\",\n  lArr: \"\\u21D0\",\n  uArr: \"\\u21D1\",\n  rArr: \"\\u21D2\",\n  dArr: \"\\u21D3\",\n  hArr: \"\\u21D4\",\n  forall: \"\\u2200\",\n  part: \"\\u2202\",\n  exist: \"\\u2203\",\n  empty: \"\\u2205\",\n  nabla: \"\\u2207\",\n  isin: \"\\u2208\",\n  notin: \"\\u2209\",\n  ni: \"\\u220B\",\n  prod: \"\\u220F\",\n  sum: \"\\u2211\",\n  minus: \"\\u2212\",\n  lowast: \"\\u2217\",\n  radic: \"\\u221A\",\n  prop: \"\\u221D\",\n  infin: \"\\u221E\",\n  ang: \"\\u2220\",\n  and: \"\\u2227\",\n  or: \"\\u2228\",\n  cap: \"\\u2229\",\n  cup: \"\\u222A\",\n  int: \"\\u222B\",\n  there4: \"\\u2234\",\n  sim: \"\\u223C\",\n  cong: \"\\u2245\",\n  asymp: \"\\u2248\",\n  ne: \"\\u2260\",\n  equiv: \"\\u2261\",\n  le: \"\\u2264\",\n  ge: \"\\u2265\",\n  sub: \"\\u2282\",\n  sup: \"\\u2283\",\n  nsub: \"\\u2284\",\n  sube: \"\\u2286\",\n  supe: \"\\u2287\",\n  oplus: \"\\u2295\",\n  otimes: \"\\u2297\",\n  perp: \"\\u22A5\",\n  sdot: \"\\u22C5\",\n  lceil: \"\\u2308\",\n  rceil: \"\\u2309\",\n  lfloor: \"\\u230A\",\n  rfloor: \"\\u230B\",\n  lang: \"\\u2329\",\n  rang: \"\\u232A\",\n  loz: \"\\u25CA\",\n  spades: \"\\u2660\",\n  clubs: \"\\u2663\",\n  hearts: \"\\u2665\",\n  diams: \"\\u2666\",\n};\nexport default entities;\n","\n\n\n\n\n\n\n\n\nexport default function getJSXPragmaInfo(options) {\n  const [base, suffix] = splitPragma(options.jsxPragma || \"React.createElement\");\n  const [fragmentBase, fragmentSuffix] = splitPragma(options.jsxFragmentPragma || \"React.Fragment\");\n  return {base, suffix, fragmentBase, fragmentSuffix};\n}\n\nfunction splitPragma(pragma) {\n  let dotIndex = pragma.indexOf(\".\");\n  if (dotIndex === -1) {\n    dotIndex = pragma.length;\n  }\n  return [pragma.slice(0, dotIndex), pragma.slice(dotIndex)];\n}\n","export default  class Transformer {\n  // Return true if anything was processed, false otherwise.\n  \n\n  getPrefixCode() {\n    return \"\";\n  }\n\n  getSuffixCode() {\n    return \"\";\n  }\n}\n","\n\n\nimport XHTMLEntities from \"../parser/plugins/jsx/xhtml\";\nimport {TokenType as tt} from \"../parser/tokenizer/types\";\nimport {charCodes} from \"../parser/util/charcodes\";\n\nimport getJSXPragmaInfo, {} from \"../util/getJSXPragmaInfo\";\n\nimport Transformer from \"./Transformer\";\n\nconst HEX_NUMBER = /^[\\da-fA-F]+$/;\nconst DECIMAL_NUMBER = /^\\d+$/;\n\nexport default class JSXTransformer extends Transformer {\n  __init() {this.lastLineNumber = 1}\n  __init2() {this.lastIndex = 0}\n  __init3() {this.filenameVarName = null}\n  \n\n  constructor(\n     rootTransformer,\n     tokens,\n     importProcessor,\n     nameManager,\n     options,\n  ) {\n    super();this.rootTransformer = rootTransformer;this.tokens = tokens;this.importProcessor = importProcessor;this.nameManager = nameManager;this.options = options;JSXTransformer.prototype.__init.call(this);JSXTransformer.prototype.__init2.call(this);JSXTransformer.prototype.__init3.call(this);;\n    this.jsxPragmaInfo = getJSXPragmaInfo(options);\n  }\n\n  process() {\n    if (this.tokens.matches1(tt.jsxTagStart)) {\n      this.processJSXTag();\n      return true;\n    }\n    return false;\n  }\n\n  getPrefixCode() {\n    if (this.filenameVarName) {\n      return `const ${this.filenameVarName} = ${JSON.stringify(this.options.filePath || \"\")};`;\n    } else {\n      return \"\";\n    }\n  }\n\n  /**\n   * Lazily calculate line numbers to avoid unneeded work. We assume this is always called in\n   * increasing order by index.\n   */\n  getLineNumberForIndex(index) {\n    const code = this.tokens.code;\n    while (this.lastIndex < index && this.lastIndex < code.length) {\n      if (code[this.lastIndex] === \"\\n\") {\n        this.lastLineNumber++;\n      }\n      this.lastIndex++;\n    }\n    return this.lastLineNumber;\n  }\n\n  getFilenameVarName() {\n    if (!this.filenameVarName) {\n      this.filenameVarName = this.nameManager.claimFreeName(\"_jsxFileName\");\n    }\n    return this.filenameVarName;\n  }\n\n  processProps(firstTokenStart) {\n    const lineNumber = this.getLineNumberForIndex(firstTokenStart);\n    const devProps = this.options.production\n      ? \"\"\n      : `__self: this, __source: {fileName: ${this.getFilenameVarName()}, lineNumber: ${lineNumber}}`;\n    if (!this.tokens.matches1(tt.jsxName) && !this.tokens.matches1(tt.braceL)) {\n      if (devProps) {\n        this.tokens.appendCode(`, {${devProps}}`);\n      } else {\n        this.tokens.appendCode(`, null`);\n      }\n      return;\n    }\n    this.tokens.appendCode(`, {`);\n    while (true) {\n      if (this.tokens.matches2(tt.jsxName, tt.eq)) {\n        this.processPropKeyName();\n        this.tokens.replaceToken(\": \");\n        if (this.tokens.matches1(tt.braceL)) {\n          this.tokens.replaceToken(\"\");\n          this.rootTransformer.processBalancedCode();\n          this.tokens.replaceToken(\"\");\n        } else if (this.tokens.matches1(tt.jsxTagStart)) {\n          this.processJSXTag();\n        } else {\n          this.processStringPropValue();\n        }\n      } else if (this.tokens.matches1(tt.jsxName)) {\n        this.processPropKeyName();\n        this.tokens.appendCode(\": true\");\n      } else if (this.tokens.matches1(tt.braceL)) {\n        this.tokens.replaceToken(\"\");\n        this.rootTransformer.processBalancedCode();\n        this.tokens.replaceToken(\"\");\n      } else {\n        break;\n      }\n      this.tokens.appendCode(\",\");\n    }\n    if (devProps) {\n      this.tokens.appendCode(` ${devProps}}`);\n    } else {\n      this.tokens.appendCode(\"}\");\n    }\n  }\n\n  processPropKeyName() {\n    const keyName = this.tokens.identifierName();\n    if (keyName.includes(\"-\")) {\n      this.tokens.replaceToken(`'${keyName}'`);\n    } else {\n      this.tokens.copyToken();\n    }\n  }\n\n  processStringPropValue() {\n    const token = this.tokens.currentToken();\n    const valueCode = this.tokens.code.slice(token.start + 1, token.end - 1);\n    const replacementCode = formatJSXTextReplacement(valueCode);\n    const literalCode = formatJSXStringValueLiteral(valueCode);\n    this.tokens.replaceToken(literalCode + replacementCode);\n  }\n\n  /**\n   * Process the first part of a tag, before any props.\n   */\n  processTagIntro() {\n    // Walk forward until we see one of these patterns:\n    // jsxName to start the first prop, preceded by another jsxName to end the tag name.\n    // jsxName to start the first prop, preceded by greaterThan to end the type argument.\n    // [open brace] to start the first prop.\n    // [jsxTagEnd] to end the open-tag.\n    // [slash, jsxTagEnd] to end the self-closing tag.\n    let introEnd = this.tokens.currentIndex() + 1;\n    while (\n      this.tokens.tokens[introEnd].isType ||\n      (!this.tokens.matches2AtIndex(introEnd - 1, tt.jsxName, tt.jsxName) &&\n        !this.tokens.matches2AtIndex(introEnd - 1, tt.greaterThan, tt.jsxName) &&\n        !this.tokens.matches1AtIndex(introEnd, tt.braceL) &&\n        !this.tokens.matches1AtIndex(introEnd, tt.jsxTagEnd) &&\n        !this.tokens.matches2AtIndex(introEnd, tt.slash, tt.jsxTagEnd))\n    ) {\n      introEnd++;\n    }\n    if (introEnd === this.tokens.currentIndex() + 1) {\n      const tagName = this.tokens.identifierName();\n      if (startsWithLowerCase(tagName)) {\n        this.tokens.replaceToken(`'${tagName}'`);\n      }\n    }\n    while (this.tokens.currentIndex() < introEnd) {\n      this.rootTransformer.processToken();\n    }\n  }\n\n  processChildren() {\n    while (true) {\n      if (this.tokens.matches2(tt.jsxTagStart, tt.slash)) {\n        // Closing tag, so no more children.\n        return;\n      }\n      if (this.tokens.matches1(tt.braceL)) {\n        if (this.tokens.matches2(tt.braceL, tt.braceR)) {\n          // Empty interpolations and comment-only interpolations are allowed\n          // and don't create an extra child arg.\n          this.tokens.replaceToken(\"\");\n          this.tokens.replaceToken(\"\");\n        } else {\n          // Interpolated expression.\n          this.tokens.replaceToken(\", \");\n          this.rootTransformer.processBalancedCode();\n          this.tokens.replaceToken(\"\");\n        }\n      } else if (this.tokens.matches1(tt.jsxTagStart)) {\n        // Child JSX element\n        this.tokens.appendCode(\", \");\n        this.processJSXTag();\n      } else if (this.tokens.matches1(tt.jsxText)) {\n        this.processChildTextElement();\n      } else {\n        throw new Error(\"Unexpected token when processing JSX children.\");\n      }\n    }\n  }\n\n  processChildTextElement() {\n    const token = this.tokens.currentToken();\n    const valueCode = this.tokens.code.slice(token.start, token.end);\n    const replacementCode = formatJSXTextReplacement(valueCode);\n    const literalCode = formatJSXTextLiteral(valueCode);\n    if (literalCode === '\"\"') {\n      this.tokens.replaceToken(replacementCode);\n    } else {\n      this.tokens.replaceToken(`, ${literalCode}${replacementCode}`);\n    }\n  }\n\n  processJSXTag() {\n    const {jsxPragmaInfo} = this;\n    const resolvedPragmaBaseName = this.importProcessor\n      ? this.importProcessor.getIdentifierReplacement(jsxPragmaInfo.base) || jsxPragmaInfo.base\n      : jsxPragmaInfo.base;\n    const firstTokenStart = this.tokens.currentToken().start;\n    // First tag is always jsxTagStart.\n    this.tokens.replaceToken(`${resolvedPragmaBaseName}${jsxPragmaInfo.suffix}(`);\n\n    if (this.tokens.matches1(tt.jsxTagEnd)) {\n      // Fragment syntax.\n      const resolvedFragmentPragmaBaseName = this.importProcessor\n        ? this.importProcessor.getIdentifierReplacement(jsxPragmaInfo.fragmentBase) ||\n          jsxPragmaInfo.fragmentBase\n        : jsxPragmaInfo.fragmentBase;\n      this.tokens.replaceToken(\n        `${resolvedFragmentPragmaBaseName}${jsxPragmaInfo.fragmentSuffix}, null`,\n      );\n      // Tag with children.\n      this.processChildren();\n      while (!this.tokens.matches1(tt.jsxTagEnd)) {\n        this.tokens.replaceToken(\"\");\n      }\n      this.tokens.replaceToken(\")\");\n    } else {\n      // Normal open tag or self-closing tag.\n      this.processTagIntro();\n      this.processProps(firstTokenStart);\n\n      if (this.tokens.matches2(tt.slash, tt.jsxTagEnd)) {\n        // Self-closing tag.\n        this.tokens.replaceToken(\"\");\n        this.tokens.replaceToken(\")\");\n      } else if (this.tokens.matches1(tt.jsxTagEnd)) {\n        this.tokens.replaceToken(\"\");\n        // Tag with children.\n        this.processChildren();\n        while (!this.tokens.matches1(tt.jsxTagEnd)) {\n          this.tokens.replaceToken(\"\");\n        }\n        this.tokens.replaceToken(\")\");\n      } else {\n        throw new Error(\"Expected either /> or > at the end of the tag.\");\n      }\n    }\n  }\n}\n\n/**\n * Spec for identifiers: https://tc39.github.io/ecma262/#prod-IdentifierStart.\n *\n * Really only treat anything starting with a-z as tag names.  `_`, `$`, `é`\n * should be treated as copmonent names\n */\nexport function startsWithLowerCase(s) {\n  const firstChar = s.charCodeAt(0);\n  return firstChar >= charCodes.lowercaseA && firstChar <= charCodes.lowercaseZ;\n}\n\n/**\n * Turn the given jsxText string into a JS string literal. Leading and trailing\n * whitespace on lines is removed, except immediately after the open-tag and\n * before the close-tag. Empty lines are completely removed, and spaces are\n * added between lines after that.\n *\n * We use JSON.stringify to introduce escape characters as necessary, and trim\n * the start and end of each line and remove blank lines.\n */\nfunction formatJSXTextLiteral(text) {\n  let result = \"\";\n  let whitespace = \"\";\n\n  let isInInitialLineWhitespace = false;\n  let seenNonWhitespace = false;\n  for (let i = 0; i < text.length; i++) {\n    const c = text[i];\n    if (c === \" \" || c === \"\\t\" || c === \"\\r\") {\n      if (!isInInitialLineWhitespace) {\n        whitespace += c;\n      }\n    } else if (c === \"\\n\") {\n      whitespace = \"\";\n      isInInitialLineWhitespace = true;\n    } else {\n      if (seenNonWhitespace && isInInitialLineWhitespace) {\n        result += \" \";\n      }\n      result += whitespace;\n      whitespace = \"\";\n      if (c === \"&\") {\n        const {entity, newI} = processEntity(text, i + 1);\n        i = newI - 1;\n        result += entity;\n      } else {\n        result += c;\n      }\n      seenNonWhitespace = true;\n      isInInitialLineWhitespace = false;\n    }\n  }\n  if (!isInInitialLineWhitespace) {\n    result += whitespace;\n  }\n  return JSON.stringify(result);\n}\n\n/**\n * Produce the code that should be printed after the JSX text string literal,\n * with most content removed, but all newlines preserved and all spacing at the\n * end preserved.\n */\nfunction formatJSXTextReplacement(text) {\n  let numNewlines = 0;\n  let numSpaces = 0;\n  for (const c of text) {\n    if (c === \"\\n\") {\n      numNewlines++;\n      numSpaces = 0;\n    } else if (c === \" \") {\n      numSpaces++;\n    }\n  }\n  return \"\\n\".repeat(numNewlines) + \" \".repeat(numSpaces);\n}\n\n/**\n * Format a string in the value position of a JSX prop.\n *\n * Use the same implementation as convertAttribute from\n * babel-helper-builder-react-jsx.\n */\nfunction formatJSXStringValueLiteral(text) {\n  let result = \"\";\n  for (let i = 0; i < text.length; i++) {\n    const c = text[i];\n    if (c === \"\\n\") {\n      if (/\\s/.test(text[i + 1])) {\n        result += \" \";\n        while (i < text.length && /\\s/.test(text[i + 1])) {\n          i++;\n        }\n      } else {\n        result += \"\\n\";\n      }\n    } else if (c === \"&\") {\n      const {entity, newI} = processEntity(text, i + 1);\n      result += entity;\n      i = newI - 1;\n    } else {\n      result += c;\n    }\n  }\n  return JSON.stringify(result);\n}\n\n/**\n * Modified from jsxReadString in Babylon.\n */\nfunction processEntity(text, indexAfterAmpersand) {\n  let str = \"\";\n  let count = 0;\n  let entity;\n  let i = indexAfterAmpersand;\n\n  while (i < text.length && count++ < 10) {\n    const ch = text[i];\n    i++;\n    if (ch === \";\") {\n      if (str[0] === \"#\") {\n        if (str[1] === \"x\") {\n          str = str.substr(2);\n          if (HEX_NUMBER.test(str)) {\n            entity = String.fromCodePoint(parseInt(str, 16));\n          }\n        } else {\n          str = str.substr(1);\n          if (DECIMAL_NUMBER.test(str)) {\n            entity = String.fromCodePoint(parseInt(str, 10));\n          }\n        }\n      } else {\n        entity = XHTMLEntities[str];\n      }\n      break;\n    }\n    str += ch;\n  }\n  if (!entity) {\n    return {entity: \"&\", newI: indexAfterAmpersand};\n  }\n  return {entity, newI: i};\n}\n","\nimport {IdentifierRole} from \"../parser/tokenizer\";\nimport {TokenType, TokenType as tt} from \"../parser/tokenizer/types\";\n\nimport {startsWithLowerCase} from \"../transformers/JSXTransformer\";\nimport getJSXPragmaInfo from \"./getJSXPragmaInfo\";\n\nexport function getNonTypeIdentifiers(tokens, options) {\n  const jsxPragmaInfo = getJSXPragmaInfo(options);\n  const nonTypeIdentifiers = new Set();\n  for (let i = 0; i < tokens.tokens.length; i++) {\n    const token = tokens.tokens[i];\n    if (\n      token.type === tt.name &&\n      !token.isType &&\n      (token.identifierRole === IdentifierRole.Access ||\n        token.identifierRole === IdentifierRole.ObjectShorthand ||\n        token.identifierRole === IdentifierRole.ExportAccess) &&\n      !token.shadowsGlobal\n    ) {\n      nonTypeIdentifiers.add(tokens.identifierNameForToken(token));\n    }\n    if (token.type === tt.jsxTagStart) {\n      nonTypeIdentifiers.add(jsxPragmaInfo.base);\n    }\n    if (\n      token.type === tt.jsxTagStart &&\n      i + 1 < tokens.tokens.length &&\n      tokens.tokens[i + 1].type === tt.jsxTagEnd\n    ) {\n      nonTypeIdentifiers.add(jsxPragmaInfo.base);\n      nonTypeIdentifiers.add(jsxPragmaInfo.fragmentBase);\n    }\n    if (token.type === tt.jsxName && token.identifierRole === IdentifierRole.Access) {\n      const identifierName = tokens.identifierNameForToken(token);\n      // Lower-case single-component tag names like \"div\" don't count.\n      if (!startsWithLowerCase(identifierName) || tokens.tokens[i + 1].type === TokenType.dot) {\n        nonTypeIdentifiers.add(tokens.identifierNameForToken(token));\n      }\n    }\n  }\n  return nonTypeIdentifiers;\n}\n","\n\n\nimport {isDeclaration} from \"./parser/tokenizer\";\nimport {ContextualKeyword} from \"./parser/tokenizer/keywords\";\nimport {TokenType as tt} from \"./parser/tokenizer/types\";\n\nimport {getNonTypeIdentifiers} from \"./util/getNonTypeIdentifiers\";\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Class responsible for preprocessing and bookkeeping import and export declarations within the\n * file.\n *\n * TypeScript uses a simpler mechanism that does not use functions like interopRequireDefault and\n * interopRequireWildcard, so we also allow that mode for compatibility.\n */\nexport default class CJSImportProcessor {\n   __init() {this.nonTypeIdentifiers = new Set()}\n   __init2() {this.importInfoByPath = new Map()}\n   __init3() {this.importsToReplace = new Map()}\n   __init4() {this.identifierReplacements = new Map()}\n   __init5() {this.exportBindingsByLocalName = new Map()}\n\n  constructor(\n     nameManager,\n     tokens,\n     enableLegacyTypeScriptModuleInterop,\n     options,\n     isTypeScriptTransformEnabled,\n     helperManager,\n  ) {;this.nameManager = nameManager;this.tokens = tokens;this.enableLegacyTypeScriptModuleInterop = enableLegacyTypeScriptModuleInterop;this.options = options;this.isTypeScriptTransformEnabled = isTypeScriptTransformEnabled;this.helperManager = helperManager;CJSImportProcessor.prototype.__init.call(this);CJSImportProcessor.prototype.__init2.call(this);CJSImportProcessor.prototype.__init3.call(this);CJSImportProcessor.prototype.__init4.call(this);CJSImportProcessor.prototype.__init5.call(this);}\n\n  preprocessTokens() {\n    for (let i = 0; i < this.tokens.tokens.length; i++) {\n      if (\n        this.tokens.matches1AtIndex(i, tt._import) &&\n        !this.tokens.matches3AtIndex(i, tt._import, tt.name, tt.eq)\n      ) {\n        this.preprocessImportAtIndex(i);\n      }\n      if (\n        this.tokens.matches1AtIndex(i, tt._export) &&\n        !this.tokens.matches2AtIndex(i, tt._export, tt.eq)\n      ) {\n        this.preprocessExportAtIndex(i);\n      }\n    }\n    this.generateImportReplacements();\n  }\n\n  /**\n   * In TypeScript, import statements that only import types should be removed. This does not count\n   * bare imports.\n   */\n  pruneTypeOnlyImports() {\n    this.nonTypeIdentifiers = getNonTypeIdentifiers(this.tokens, this.options);\n    for (const [path, importInfo] of this.importInfoByPath.entries()) {\n      if (\n        importInfo.hasBareImport ||\n        importInfo.hasStarExport ||\n        importInfo.exportStarNames.length > 0 ||\n        importInfo.namedExports.length > 0\n      ) {\n        continue;\n      }\n      const names = [\n        ...importInfo.defaultNames,\n        ...importInfo.wildcardNames,\n        ...importInfo.namedImports.map(({localName}) => localName),\n      ];\n      if (names.every((name) => this.isTypeName(name))) {\n        this.importsToReplace.set(path, \"\");\n      }\n    }\n  }\n\n  isTypeName(name) {\n    return this.isTypeScriptTransformEnabled && !this.nonTypeIdentifiers.has(name);\n  }\n\n   generateImportReplacements() {\n    for (const [path, importInfo] of this.importInfoByPath.entries()) {\n      const {\n        defaultNames,\n        wildcardNames,\n        namedImports,\n        namedExports,\n        exportStarNames,\n        hasStarExport,\n      } = importInfo;\n\n      if (\n        defaultNames.length === 0 &&\n        wildcardNames.length === 0 &&\n        namedImports.length === 0 &&\n        namedExports.length === 0 &&\n        exportStarNames.length === 0 &&\n        !hasStarExport\n      ) {\n        // Import is never used, so don't even assign a name.\n        this.importsToReplace.set(path, `require('${path}');`);\n        continue;\n      }\n\n      const primaryImportName = this.getFreeIdentifierForPath(path);\n      let secondaryImportName;\n      if (this.enableLegacyTypeScriptModuleInterop) {\n        secondaryImportName = primaryImportName;\n      } else {\n        secondaryImportName =\n          wildcardNames.length > 0 ? wildcardNames[0] : this.getFreeIdentifierForPath(path);\n      }\n      let requireCode = `var ${primaryImportName} = require('${path}');`;\n      if (wildcardNames.length > 0) {\n        for (const wildcardName of wildcardNames) {\n          const moduleExpr = this.enableLegacyTypeScriptModuleInterop\n            ? primaryImportName\n            : `${this.helperManager.getHelperName(\"interopRequireWildcard\")}(${primaryImportName})`;\n          requireCode += ` var ${wildcardName} = ${moduleExpr};`;\n        }\n      } else if (exportStarNames.length > 0 && secondaryImportName !== primaryImportName) {\n        requireCode += ` var ${secondaryImportName} = ${this.helperManager.getHelperName(\n          \"interopRequireWildcard\",\n        )}(${primaryImportName});`;\n      } else if (defaultNames.length > 0 && secondaryImportName !== primaryImportName) {\n        requireCode += ` var ${secondaryImportName} = ${this.helperManager.getHelperName(\n          \"interopRequireDefault\",\n        )}(${primaryImportName});`;\n      }\n\n      for (const {importedName, localName} of namedExports) {\n        requireCode += ` ${this.helperManager.getHelperName(\n          \"createNamedExportFrom\",\n        )}(${primaryImportName}, '${localName}', '${importedName}');`;\n      }\n      for (const exportStarName of exportStarNames) {\n        requireCode += ` exports.${exportStarName} = ${secondaryImportName};`;\n      }\n      if (hasStarExport) {\n        requireCode += ` ${this.helperManager.getHelperName(\n          \"createStarExport\",\n        )}(${primaryImportName});`;\n      }\n\n      this.importsToReplace.set(path, requireCode);\n\n      for (const defaultName of defaultNames) {\n        this.identifierReplacements.set(defaultName, `${secondaryImportName}.default`);\n      }\n      for (const {importedName, localName} of namedImports) {\n        this.identifierReplacements.set(localName, `${primaryImportName}.${importedName}`);\n      }\n    }\n  }\n\n   getFreeIdentifierForPath(path) {\n    const components = path.split(\"/\");\n    const lastComponent = components[components.length - 1];\n    const baseName = lastComponent.replace(/\\W/g, \"\");\n    return this.nameManager.claimFreeName(`_${baseName}`);\n  }\n\n   preprocessImportAtIndex(index) {\n    const defaultNames = [];\n    const wildcardNames = [];\n    let namedImports = [];\n\n    index++;\n    if (\n      (this.tokens.matchesContextualAtIndex(index, ContextualKeyword._type) ||\n        this.tokens.matches1AtIndex(index, tt._typeof)) &&\n      !this.tokens.matches1AtIndex(index + 1, tt.comma) &&\n      !this.tokens.matchesContextualAtIndex(index + 1, ContextualKeyword._from)\n    ) {\n      // import type declaration, so no need to process anything.\n      return;\n    }\n\n    if (this.tokens.matches1AtIndex(index, tt.parenL)) {\n      // Dynamic import, so nothing to do\n      return;\n    }\n\n    if (this.tokens.matches1AtIndex(index, tt.name)) {\n      defaultNames.push(this.tokens.identifierNameAtIndex(index));\n      index++;\n      if (this.tokens.matches1AtIndex(index, tt.comma)) {\n        index++;\n      }\n    }\n\n    if (this.tokens.matches1AtIndex(index, tt.star)) {\n      // * as\n      index += 2;\n      wildcardNames.push(this.tokens.identifierNameAtIndex(index));\n      index++;\n    }\n\n    if (this.tokens.matches1AtIndex(index, tt.braceL)) {\n      index++;\n      ({newIndex: index, namedImports} = this.getNamedImports(index));\n    }\n\n    if (this.tokens.matchesContextualAtIndex(index, ContextualKeyword._from)) {\n      index++;\n    }\n\n    if (!this.tokens.matches1AtIndex(index, tt.string)) {\n      throw new Error(\"Expected string token at the end of import statement.\");\n    }\n    const path = this.tokens.stringValueAtIndex(index);\n    const importInfo = this.getImportInfo(path);\n    importInfo.defaultNames.push(...defaultNames);\n    importInfo.wildcardNames.push(...wildcardNames);\n    importInfo.namedImports.push(...namedImports);\n    if (defaultNames.length === 0 && wildcardNames.length === 0 && namedImports.length === 0) {\n      importInfo.hasBareImport = true;\n    }\n  }\n\n   preprocessExportAtIndex(index) {\n    if (\n      this.tokens.matches2AtIndex(index, tt._export, tt._var) ||\n      this.tokens.matches2AtIndex(index, tt._export, tt._let) ||\n      this.tokens.matches2AtIndex(index, tt._export, tt._const)\n    ) {\n      this.preprocessVarExportAtIndex(index);\n    } else if (\n      this.tokens.matches2AtIndex(index, tt._export, tt._function) ||\n      this.tokens.matches2AtIndex(index, tt._export, tt._class)\n    ) {\n      const exportName = this.tokens.identifierNameAtIndex(index + 2);\n      this.addExportBinding(exportName, exportName);\n    } else if (this.tokens.matches3AtIndex(index, tt._export, tt.name, tt._function)) {\n      const exportName = this.tokens.identifierNameAtIndex(index + 3);\n      this.addExportBinding(exportName, exportName);\n    } else if (this.tokens.matches2AtIndex(index, tt._export, tt.braceL)) {\n      this.preprocessNamedExportAtIndex(index);\n    } else if (this.tokens.matches2AtIndex(index, tt._export, tt.star)) {\n      this.preprocessExportStarAtIndex(index);\n    }\n  }\n\n   preprocessVarExportAtIndex(index) {\n    let depth = 0;\n    // Handle cases like `export let {x} = y;`, starting at the open-brace in that case.\n    for (let i = index + 2; ; i++) {\n      if (\n        this.tokens.matches1AtIndex(i, tt.braceL) ||\n        this.tokens.matches1AtIndex(i, tt.dollarBraceL) ||\n        this.tokens.matches1AtIndex(i, tt.bracketL)\n      ) {\n        depth++;\n      } else if (\n        this.tokens.matches1AtIndex(i, tt.braceR) ||\n        this.tokens.matches1AtIndex(i, tt.bracketR)\n      ) {\n        depth--;\n      } else if (depth === 0 && !this.tokens.matches1AtIndex(i, tt.name)) {\n        break;\n      } else if (this.tokens.matches1AtIndex(1, tt.eq)) {\n        const endIndex = this.tokens.currentToken().rhsEndIndex;\n        if (endIndex == null) {\n          throw new Error(\"Expected = token with an end index.\");\n        }\n        i = endIndex - 1;\n      } else {\n        const token = this.tokens.tokens[i];\n        if (isDeclaration(token)) {\n          const exportName = this.tokens.identifierNameAtIndex(i);\n          this.identifierReplacements.set(exportName, `exports.${exportName}`);\n        }\n      }\n    }\n  }\n\n  /**\n   * Walk this export statement just in case it's an export...from statement.\n   * If it is, combine it into the import info for that path. Otherwise, just\n   * bail out; it'll be handled later.\n   */\n   preprocessNamedExportAtIndex(index) {\n    // export {\n    index += 2;\n    const {newIndex, namedImports} = this.getNamedImports(index);\n    index = newIndex;\n\n    if (this.tokens.matchesContextualAtIndex(index, ContextualKeyword._from)) {\n      index++;\n    } else {\n      // Reinterpret \"a as b\" to be local/exported rather than imported/local.\n      for (const {importedName: localName, localName: exportedName} of namedImports) {\n        this.addExportBinding(localName, exportedName);\n      }\n      return;\n    }\n\n    if (!this.tokens.matches1AtIndex(index, tt.string)) {\n      throw new Error(\"Expected string token at the end of import statement.\");\n    }\n    const path = this.tokens.stringValueAtIndex(index);\n    const importInfo = this.getImportInfo(path);\n    importInfo.namedExports.push(...namedImports);\n  }\n\n   preprocessExportStarAtIndex(index) {\n    let exportedName = null;\n    if (this.tokens.matches3AtIndex(index, tt._export, tt.star, tt._as)) {\n      // export * as\n      index += 3;\n      exportedName = this.tokens.identifierNameAtIndex(index);\n      // foo from\n      index += 2;\n    } else {\n      // export * from\n      index += 3;\n    }\n    if (!this.tokens.matches1AtIndex(index, tt.string)) {\n      throw new Error(\"Expected string token at the end of star export statement.\");\n    }\n    const path = this.tokens.stringValueAtIndex(index);\n    const importInfo = this.getImportInfo(path);\n    if (exportedName !== null) {\n      importInfo.exportStarNames.push(exportedName);\n    } else {\n      importInfo.hasStarExport = true;\n    }\n  }\n\n   getNamedImports(index) {\n    const namedImports = [];\n    while (true) {\n      if (this.tokens.matches1AtIndex(index, tt.braceR)) {\n        index++;\n        break;\n      }\n\n      // Flow type imports should just be ignored.\n      let isTypeImport = false;\n      if (\n        (this.tokens.matchesContextualAtIndex(index, ContextualKeyword._type) ||\n          this.tokens.matches1AtIndex(index, tt._typeof)) &&\n        this.tokens.matches1AtIndex(index + 1, tt.name) &&\n        !this.tokens.matchesContextualAtIndex(index + 1, ContextualKeyword._as)\n      ) {\n        isTypeImport = true;\n        index++;\n      }\n\n      const importedName = this.tokens.identifierNameAtIndex(index);\n      let localName;\n      index++;\n      if (this.tokens.matchesContextualAtIndex(index, ContextualKeyword._as)) {\n        index++;\n        localName = this.tokens.identifierNameAtIndex(index);\n        index++;\n      } else {\n        localName = importedName;\n      }\n      if (!isTypeImport) {\n        namedImports.push({importedName, localName});\n      }\n      if (this.tokens.matches2AtIndex(index, tt.comma, tt.braceR)) {\n        index += 2;\n        break;\n      } else if (this.tokens.matches1AtIndex(index, tt.braceR)) {\n        index++;\n        break;\n      } else if (this.tokens.matches1AtIndex(index, tt.comma)) {\n        index++;\n      } else {\n        throw new Error(`Unexpected token: ${JSON.stringify(this.tokens.tokens[index])}`);\n      }\n    }\n    return {newIndex: index, namedImports};\n  }\n\n  /**\n   * Get a mutable import info object for this path, creating one if it doesn't\n   * exist yet.\n   */\n   getImportInfo(path) {\n    const existingInfo = this.importInfoByPath.get(path);\n    if (existingInfo) {\n      return existingInfo;\n    }\n    const newInfo = {\n      defaultNames: [],\n      wildcardNames: [],\n      namedImports: [],\n      namedExports: [],\n      hasBareImport: false,\n      exportStarNames: [],\n      hasStarExport: false,\n    };\n    this.importInfoByPath.set(path, newInfo);\n    return newInfo;\n  }\n\n   addExportBinding(localName, exportedName) {\n    if (!this.exportBindingsByLocalName.has(localName)) {\n      this.exportBindingsByLocalName.set(localName, []);\n    }\n    this.exportBindingsByLocalName.get(localName).push(exportedName);\n  }\n\n  /**\n   * Return the code to use for the import for this path, or the empty string if\n   * the code has already been \"claimed\" by a previous import.\n   */\n  claimImportCode(importPath) {\n    const result = this.importsToReplace.get(importPath);\n    this.importsToReplace.set(importPath, \"\");\n    return result || \"\";\n  }\n\n  getIdentifierReplacement(identifierName) {\n    return this.identifierReplacements.get(identifierName) || null;\n  }\n\n  /**\n   * Return a string like `exports.foo = exports.bar`.\n   */\n  resolveExportBinding(assignedName) {\n    const exportedNames = this.exportBindingsByLocalName.get(assignedName);\n    if (!exportedNames || exportedNames.length === 0) {\n      return null;\n    }\n    return exportedNames.map((exportedName) => `exports.${exportedName}`).join(\" = \");\n  }\n\n  /**\n   * Return all imported/exported names where we might be interested in whether usages of those\n   * names are shadowed.\n   */\n  getGlobalNames() {\n    return new Set([\n      ...this.identifierReplacements.keys(),\n      ...this.exportBindingsByLocalName.keys(),\n    ]);\n  }\n}\n","\nimport {charCodes} from \"./parser/util/charcodes\";\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Generate a simple source map indicating that each line maps directly to the original line.\n */\nexport default function computeSourceMap(\n  code,\n  filePath,\n  {compiledFilename},\n) {\n  let mappings = \"AAAA\";\n  for (let i = 0; i < code.length; i++) {\n    if (code.charCodeAt(i) === charCodes.lineFeed) {\n      mappings += \";AACA\";\n    }\n  }\n  return {\n    version: 3,\n    file: compiledFilename || \"\",\n    sources: [filePath],\n    mappings,\n    names: [],\n  };\n}\n","\n\nconst HELPERS = {\n  interopRequireWildcard: `\n    function interopRequireWildcard(obj) {\n      if (obj && obj.__esModule) {\n        return obj;\n      } else {\n        var newObj = {};\n        if (obj != null) {\n          for (var key in obj) {\n            if (Object.prototype.hasOwnProperty.call(obj, key)) {\n              newObj[key] = obj[key];\n            }\n          }\n        }\n        newObj.default = obj;\n        return newObj;\n      }\n    }\n  `,\n  interopRequireDefault: `\n    function interopRequireDefault(obj) {\n      return obj && obj.__esModule ? obj : { default: obj };\n    }\n  `,\n  createNamedExportFrom: `\n    function createNamedExportFrom(obj, localName, importedName) {\n      Object.defineProperty(exports, localName, {enumerable: true, get: () => obj[importedName]});\n    }\n  `,\n  // Note that TypeScript and Babel do this differently; TypeScript does a simple existence\n  // check in the exports object and does a plain assignment, whereas Babel uses\n  // defineProperty and builds an object of explicitly-exported names so that star exports can\n  // always take lower precedence. For now, we do the easier TypeScript thing.\n  createStarExport: `\n    function createStarExport(obj) {\n      Object.keys(obj)\n        .filter((key) => key !== \"default\" && key !== \"__esModule\")\n        .forEach((key) => {\n          if (exports.hasOwnProperty(key)) {\n            return;\n          }\n          Object.defineProperty(exports, key, {enumerable: true, get: () => obj[key]});\n        });\n    }\n  `,\n  nullishCoalesce: `\n    function nullishCoalesce(lhs, rhsFn) {\n      if (lhs != null) {\n        return lhs;\n      } else {\n        return rhsFn();\n      }\n    }\n  `,\n  asyncNullishCoalesce: `\n    async function asyncNullishCoalesce(lhs, rhsFn) {\n      if (lhs != null) {\n        return lhs;\n      } else {\n        return await rhsFn();\n      }\n    }\n  `,\n  optionalChain: `\n    function optionalChain(ops) {\n      let lastAccessLHS = undefined;\n      let value = ops[0];\n      let i = 1;\n      while (i < ops.length) {\n        const op = ops[i];\n        const fn = ops[i + 1];\n        i += 2;\n        if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) {\n          return undefined;\n        }\n        if (op === 'access' || op === 'optionalAccess') {\n          lastAccessLHS = value;\n          value = fn(value);\n        } else if (op === 'call' || op === 'optionalCall') {\n          value = fn((...args) => value.call(lastAccessLHS, ...args));\n          lastAccessLHS = undefined;\n        }\n      }\n      return value;\n    }\n  `,\n  asyncOptionalChain: `\n    async function asyncOptionalChain(ops) {\n      let lastAccessLHS = undefined;\n      let value = ops[0];\n      let i = 1;\n      while (i < ops.length) {\n        const op = ops[i];\n        const fn = ops[i + 1];\n        i += 2;\n        if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) {\n          return undefined;\n        }\n        if (op === 'access' || op === 'optionalAccess') {\n          lastAccessLHS = value;\n          value = await fn(value);\n        } else if (op === 'call' || op === 'optionalCall') {\n          value = await fn((...args) => value.call(lastAccessLHS, ...args));\n          lastAccessLHS = undefined;\n        }\n      }\n      return value;\n    }\n  `,\n  optionalChainDelete: `\n    function optionalChainDelete(ops) {\n      const result = OPTIONAL_CHAIN_NAME(ops);\n      return result == null ? true : result;\n    }\n  `,\n  asyncOptionalChainDelete: `\n    async function asyncOptionalChainDelete(ops) {\n      const result = await ASYNC_OPTIONAL_CHAIN_NAME(ops);\n      return result == null ? true : result;\n    }\n  `,\n};\n\nexport class HelperManager {\n  __init() {this.helperNames = {}}\n  constructor( nameManager) {;this.nameManager = nameManager;HelperManager.prototype.__init.call(this);}\n\n  getHelperName(baseName) {\n    let helperName = this.helperNames[baseName];\n    if (helperName) {\n      return helperName;\n    }\n    helperName = this.nameManager.claimFreeName(`_${baseName}`);\n    this.helperNames[baseName] = helperName;\n    return helperName;\n  }\n\n  emitHelpers() {\n    let resultCode = \"\";\n    if (this.helperNames.optionalChainDelete) {\n      this.getHelperName(\"optionalChain\");\n    }\n    if (this.helperNames.asyncOptionalChainDelete) {\n      this.getHelperName(\"asyncOptionalChain\");\n    }\n    for (const [baseName, helperCodeTemplate] of Object.entries(HELPERS)) {\n      const helperName = this.helperNames[baseName];\n      let helperCode = helperCodeTemplate;\n      if (baseName === \"optionalChainDelete\") {\n        helperCode = helperCode.replace(\"OPTIONAL_CHAIN_NAME\", this.helperNames.optionalChain);\n      } else if (baseName === \"asyncOptionalChainDelete\") {\n        helperCode = helperCode.replace(\n          \"ASYNC_OPTIONAL_CHAIN_NAME\",\n          this.helperNames.asyncOptionalChain,\n        );\n      }\n      if (helperName) {\n        resultCode += \" \";\n        resultCode += helperCode.replace(baseName, helperName).replace(/\\s+/g, \" \").trim();\n      }\n    }\n    return resultCode;\n  }\n}\n","import {\n  isBlockScopedDeclaration,\n  isFunctionScopedDeclaration,\n  isNonTopLevelDeclaration,\n} from \"./parser/tokenizer\";\n\nimport {TokenType as tt} from \"./parser/tokenizer/types\";\n\n\n/**\n * Traverse the given tokens and modify them if necessary to indicate that some names shadow global\n * variables.\n */\nexport default function identifyShadowedGlobals(\n  tokens,\n  scopes,\n  globalNames,\n) {\n  if (!hasShadowedGlobals(tokens, globalNames)) {\n    return;\n  }\n  markShadowedGlobals(tokens, scopes, globalNames);\n}\n\n/**\n * We can do a fast up-front check to see if there are any declarations to global names. If not,\n * then there's no point in computing scope assignments.\n */\n// Exported for testing.\nexport function hasShadowedGlobals(tokens, globalNames) {\n  for (const token of tokens.tokens) {\n    if (\n      token.type === tt.name &&\n      isNonTopLevelDeclaration(token) &&\n      globalNames.has(tokens.identifierNameForToken(token))\n    ) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction markShadowedGlobals(\n  tokens,\n  scopes,\n  globalNames,\n) {\n  const scopeStack = [];\n  let scopeIndex = scopes.length - 1;\n  // Scopes were generated at completion time, so they're sorted by end index, so we can maintain a\n  // good stack by going backwards through them.\n  for (let i = tokens.tokens.length - 1; ; i--) {\n    while (scopeStack.length > 0 && scopeStack[scopeStack.length - 1].startTokenIndex === i + 1) {\n      scopeStack.pop();\n    }\n    while (scopeIndex >= 0 && scopes[scopeIndex].endTokenIndex === i + 1) {\n      scopeStack.push(scopes[scopeIndex]);\n      scopeIndex--;\n    }\n    // Process scopes after the last iteration so we can make sure we pop all of them.\n    if (i < 0) {\n      break;\n    }\n\n    const token = tokens.tokens[i];\n    const name = tokens.identifierNameForToken(token);\n    if (scopeStack.length > 1 && token.type === tt.name && globalNames.has(name)) {\n      if (isBlockScopedDeclaration(token)) {\n        markShadowedForScope(scopeStack[scopeStack.length - 1], tokens, name);\n      } else if (isFunctionScopedDeclaration(token)) {\n        let stackIndex = scopeStack.length - 1;\n        while (stackIndex > 0 && !scopeStack[stackIndex].isFunctionScope) {\n          stackIndex--;\n        }\n        if (stackIndex < 0) {\n          throw new Error(\"Did not find parent function scope.\");\n        }\n        markShadowedForScope(scopeStack[stackIndex], tokens, name);\n      }\n    }\n  }\n  if (scopeStack.length > 0) {\n    throw new Error(\"Expected empty scope stack after processing file.\");\n  }\n}\n\nfunction markShadowedForScope(scope, tokens, name) {\n  for (let i = scope.startTokenIndex; i < scope.endTokenIndex; i++) {\n    const token = tokens.tokens[i];\n    if (token.type === tt.name && tokens.identifierNameForToken(token) === name) {\n      token.shadowsGlobal = true;\n    }\n  }\n}\n","import {\n  eat,\n  lookaheadType,\n  lookaheadTypeAndKeyword,\n  match,\n  next,\n  popTypeContext,\n  pushTypeContext,\n} from \"../tokenizer/index\";\nimport {ContextualKeyword} from \"../tokenizer/keywords\";\nimport {TokenType, TokenType as tt} from \"../tokenizer/types\";\nimport {isJSXEnabled, state} from \"../traverser/base\";\nimport {\n  atPossibleAsync,\n  baseParseMaybeAssign,\n  baseParseSubscript,\n  parseCallExpressionArguments,\n  parseExprAtom,\n  parseExpression,\n  parseFunctionBody,\n  parseIdentifier,\n  parseLiteral,\n  parseMaybeAssign,\n  parseMaybeUnary,\n  parsePropertyName,\n  parseTemplate,\n\n} from \"../traverser/expression\";\nimport {parseBindingIdentifier, parseBindingList, parseImportedIdentifier} from \"../traverser/lval\";\nimport {\n  baseParseMaybeDecoratorArguments,\n  parseBlockBody,\n  parseClass,\n  parseClassProperty,\n  parseClassPropertyName,\n  parseFunction,\n  parseFunctionParams,\n  parsePostMemberNameModifiers,\n  parseStatement,\n  parseVarStatement,\n} from \"../traverser/statement\";\nimport {\n  canInsertSemicolon,\n  eatContextual,\n  expect,\n  expectContextual,\n  hasPrecedingLineBreak,\n  isContextual,\n  isLineTerminator,\n  isLookaheadContextual,\n  semicolon,\n  unexpected,\n} from \"../traverser/util\";\nimport {nextJSXTagToken} from \"./jsx\";\n\nfunction tsIsIdentifier() {\n  // TODO: actually a bit more complex in TypeScript, but shouldn't matter.\n  // See https://github.com/Microsoft/TypeScript/issues/15008\n  return match(tt.name);\n}\n\nfunction tsNextTokenCanFollowModifier() {\n  // Note: TypeScript's implementation is much more complicated because\n  // more things are considered modifiers there.\n  // This implementation only handles modifiers not handled by babylon itself. And \"static\".\n  // TODO: Would be nice to avoid lookahead. Want a hasLineBreakUpNext() method...\n  const snapshot = state.snapshot();\n\n  next();\n  const canFollowModifier =\n    !hasPrecedingLineBreak() &&\n    !match(tt.parenL) &&\n    !match(tt.parenR) &&\n    !match(tt.colon) &&\n    !match(tt.eq) &&\n    !match(tt.question) &&\n    !match(tt.bang);\n\n  if (canFollowModifier) {\n    return true;\n  } else {\n    state.restoreFromSnapshot(snapshot);\n    return false;\n  }\n}\n\n/** Parses a modifier matching one the given modifier names. */\nexport function tsParseModifier(\n  allowedModifiers,\n) {\n  if (!match(tt.name)) {\n    return null;\n  }\n\n  const modifier = state.contextualKeyword;\n  if (allowedModifiers.indexOf(modifier) !== -1 && tsNextTokenCanFollowModifier()) {\n    switch (modifier) {\n      case ContextualKeyword._readonly:\n        state.tokens[state.tokens.length - 1].type = tt._readonly;\n        break;\n      case ContextualKeyword._abstract:\n        state.tokens[state.tokens.length - 1].type = tt._abstract;\n        break;\n      case ContextualKeyword._static:\n        state.tokens[state.tokens.length - 1].type = tt._static;\n        break;\n      case ContextualKeyword._public:\n        state.tokens[state.tokens.length - 1].type = tt._public;\n        break;\n      case ContextualKeyword._private:\n        state.tokens[state.tokens.length - 1].type = tt._private;\n        break;\n      case ContextualKeyword._protected:\n        state.tokens[state.tokens.length - 1].type = tt._protected;\n        break;\n      case ContextualKeyword._declare:\n        state.tokens[state.tokens.length - 1].type = tt._declare;\n        break;\n      default:\n        break;\n    }\n    return modifier;\n  }\n  return null;\n}\n\nfunction tsParseEntityName() {\n  parseIdentifier();\n  while (eat(tt.dot)) {\n    parseIdentifier();\n  }\n}\n\nfunction tsParseTypeReference() {\n  tsParseEntityName();\n  if (!hasPrecedingLineBreak() && match(tt.lessThan)) {\n    tsParseTypeArguments();\n  }\n}\n\nfunction tsParseThisTypePredicate() {\n  next();\n  tsParseTypeAnnotation();\n}\n\nfunction tsParseThisTypeNode() {\n  next();\n}\n\nfunction tsParseTypeQuery() {\n  expect(tt._typeof);\n  if (match(tt._import)) {\n    tsParseImportType();\n  } else {\n    tsParseEntityName();\n  }\n}\n\nfunction tsParseImportType() {\n  expect(tt._import);\n  expect(tt.parenL);\n  expect(tt.string);\n  expect(tt.parenR);\n  if (eat(tt.dot)) {\n    tsParseEntityName();\n  }\n  if (match(tt.lessThan)) {\n    tsParseTypeArguments();\n  }\n}\n\nfunction tsParseTypeParameter() {\n  parseIdentifier();\n  if (eat(tt._extends)) {\n    tsParseType();\n  }\n  if (eat(tt.eq)) {\n    tsParseType();\n  }\n}\n\nexport function tsTryParseTypeParameters() {\n  if (match(tt.lessThan)) {\n    tsParseTypeParameters();\n  }\n}\n\nfunction tsParseTypeParameters() {\n  const oldIsType = pushTypeContext(0);\n  if (match(tt.lessThan) || match(tt.typeParameterStart)) {\n    next();\n  } else {\n    unexpected();\n  }\n\n  while (!eat(tt.greaterThan) && !state.error) {\n    tsParseTypeParameter();\n    eat(tt.comma);\n  }\n  popTypeContext(oldIsType);\n}\n\n// Note: In TypeScript implementation we must provide `yieldContext` and `awaitContext`,\n// but here it's always false, because this is only used for types.\nfunction tsFillSignature(returnToken) {\n  // Arrow fns *must* have return token (`=>`). Normal functions can omit it.\n  const returnTokenRequired = returnToken === tt.arrow;\n  tsTryParseTypeParameters();\n  expect(tt.parenL);\n  // Create a scope even though we're doing type parsing so we don't accidentally\n  // treat params as top-level bindings.\n  state.scopeDepth++;\n  tsParseBindingListForSignature(false /* isBlockScope */);\n  state.scopeDepth--;\n  if (returnTokenRequired) {\n    tsParseTypeOrTypePredicateAnnotation(returnToken);\n  } else if (match(returnToken)) {\n    tsParseTypeOrTypePredicateAnnotation(returnToken);\n  }\n}\n\nfunction tsParseBindingListForSignature(isBlockScope) {\n  parseBindingList(tt.parenR, isBlockScope);\n}\n\nfunction tsParseTypeMemberSemicolon() {\n  if (!eat(tt.comma)) {\n    semicolon();\n  }\n}\n\nfunction tsParseSignatureMember() {\n  tsFillSignature(tt.colon);\n  tsParseTypeMemberSemicolon();\n}\n\nfunction tsIsUnambiguouslyIndexSignature() {\n  const snapshot = state.snapshot();\n  next(); // Skip '{'\n  const isIndexSignature = eat(tt.name) && match(tt.colon);\n  state.restoreFromSnapshot(snapshot);\n  return isIndexSignature;\n}\n\nfunction tsTryParseIndexSignature() {\n  if (!(match(tt.bracketL) && tsIsUnambiguouslyIndexSignature())) {\n    return false;\n  }\n\n  const oldIsType = pushTypeContext(0);\n\n  expect(tt.bracketL);\n  parseIdentifier();\n  tsParseTypeAnnotation();\n  expect(tt.bracketR);\n\n  tsTryParseTypeAnnotation();\n  tsParseTypeMemberSemicolon();\n\n  popTypeContext(oldIsType);\n  return true;\n}\n\nfunction tsParsePropertyOrMethodSignature(isReadonly) {\n  eat(tt.question);\n\n  if (!isReadonly && (match(tt.parenL) || match(tt.lessThan))) {\n    tsFillSignature(tt.colon);\n    tsParseTypeMemberSemicolon();\n  } else {\n    tsTryParseTypeAnnotation();\n    tsParseTypeMemberSemicolon();\n  }\n}\n\nfunction tsParseTypeMember() {\n  if (match(tt.parenL) || match(tt.lessThan)) {\n    // call signature\n    tsParseSignatureMember();\n    return;\n  }\n  if (match(tt._new)) {\n    next();\n    if (match(tt.parenL) || match(tt.lessThan)) {\n      // constructor signature\n      tsParseSignatureMember();\n    } else {\n      tsParsePropertyOrMethodSignature(false);\n    }\n    return;\n  }\n  const readonly = !!tsParseModifier([ContextualKeyword._readonly]);\n\n  const found = tsTryParseIndexSignature();\n  if (found) {\n    return;\n  }\n  parsePropertyName(-1 /* Types don't need context IDs. */);\n  tsParsePropertyOrMethodSignature(readonly);\n}\n\nfunction tsParseTypeLiteral() {\n  tsParseObjectTypeMembers();\n}\n\nfunction tsParseObjectTypeMembers() {\n  expect(tt.braceL);\n  while (!eat(tt.braceR) && !state.error) {\n    tsParseTypeMember();\n  }\n}\n\nfunction tsLookaheadIsStartOfMappedType() {\n  const snapshot = state.snapshot();\n  const isStartOfMappedType = tsIsStartOfMappedType();\n  state.restoreFromSnapshot(snapshot);\n  return isStartOfMappedType;\n}\n\nfunction tsIsStartOfMappedType() {\n  next();\n  if (eat(tt.plus) || eat(tt.minus)) {\n    return isContextual(ContextualKeyword._readonly);\n  }\n  if (isContextual(ContextualKeyword._readonly)) {\n    next();\n  }\n  if (!match(tt.bracketL)) {\n    return false;\n  }\n  next();\n  if (!tsIsIdentifier()) {\n    return false;\n  }\n  next();\n  return match(tt._in);\n}\n\nfunction tsParseMappedTypeParameter() {\n  parseIdentifier();\n  expect(tt._in);\n  tsParseType();\n}\n\nfunction tsParseMappedType() {\n  expect(tt.braceL);\n  if (match(tt.plus) || match(tt.minus)) {\n    next();\n    expectContextual(ContextualKeyword._readonly);\n  } else {\n    eatContextual(ContextualKeyword._readonly);\n  }\n  expect(tt.bracketL);\n  tsParseMappedTypeParameter();\n  expect(tt.bracketR);\n  if (match(tt.plus) || match(tt.minus)) {\n    next();\n    expect(tt.question);\n  } else {\n    eat(tt.question);\n  }\n  tsTryParseType();\n  semicolon();\n  expect(tt.braceR);\n}\n\nfunction tsParseTupleType() {\n  expect(tt.bracketL);\n  while (!eat(tt.bracketR) && !state.error) {\n    tsParseTupleElementType();\n    eat(tt.comma);\n  }\n}\n\nfunction tsParseTupleElementType() {\n  // parses `...TsType[]`\n  if (eat(tt.ellipsis)) {\n    tsParseType();\n    return;\n  }\n  // parses `TsType?`\n  tsParseType();\n  eat(tt.question);\n}\n\nfunction tsParseParenthesizedType() {\n  expect(tt.parenL);\n  tsParseType();\n  expect(tt.parenR);\n}\n\nvar FunctionType; (function (FunctionType) {\n  const TSFunctionType = 0; FunctionType[FunctionType[\"TSFunctionType\"] = TSFunctionType] = \"TSFunctionType\";\n  const TSConstructorType = TSFunctionType + 1; FunctionType[FunctionType[\"TSConstructorType\"] = TSConstructorType] = \"TSConstructorType\";\n})(FunctionType || (FunctionType = {}));\n\nfunction tsParseFunctionOrConstructorType(type) {\n  if (type === FunctionType.TSConstructorType) {\n    expect(tt._new);\n  }\n  tsFillSignature(tt.arrow);\n}\n\nfunction tsParseNonArrayType() {\n  switch (state.type) {\n    case tt.name:\n      tsParseTypeReference();\n      return;\n    case tt._void:\n    case tt._null:\n      next();\n      return;\n    case tt.string:\n    case tt.num:\n    case tt._true:\n    case tt._false:\n      parseLiteral();\n      return;\n    case tt.minus:\n      next();\n      parseLiteral();\n      return;\n    case tt._this: {\n      tsParseThisTypeNode();\n      if (isContextual(ContextualKeyword._is) && !hasPrecedingLineBreak()) {\n        tsParseThisTypePredicate();\n      }\n      return;\n    }\n    case tt._typeof:\n      tsParseTypeQuery();\n      return;\n    case tt._import:\n      tsParseImportType();\n      return;\n    case tt.braceL:\n      if (tsLookaheadIsStartOfMappedType()) {\n        tsParseMappedType();\n      } else {\n        tsParseTypeLiteral();\n      }\n      return;\n    case tt.bracketL:\n      tsParseTupleType();\n      return;\n    case tt.parenL:\n      tsParseParenthesizedType();\n      return;\n    case tt.backQuote:\n      parseTemplate();\n      return;\n    default:\n      if (state.type & TokenType.IS_KEYWORD) {\n        next();\n        state.tokens[state.tokens.length - 1].type = tt.name;\n        return;\n      }\n      break;\n  }\n\n  unexpected();\n}\n\nfunction tsParseArrayTypeOrHigher() {\n  tsParseNonArrayType();\n  while (!hasPrecedingLineBreak() && eat(tt.bracketL)) {\n    if (!eat(tt.bracketR)) {\n      // If we hit ] immediately, this is an array type, otherwise it's an indexed access type.\n      tsParseType();\n      expect(tt.bracketR);\n    }\n  }\n}\n\nfunction tsParseInferType() {\n  expectContextual(ContextualKeyword._infer);\n  parseIdentifier();\n}\n\nfunction tsParseTypeOperatorOrHigher() {\n  if (\n    isContextual(ContextualKeyword._keyof) ||\n    isContextual(ContextualKeyword._unique) ||\n    isContextual(ContextualKeyword._readonly)\n  ) {\n    next();\n    tsParseTypeOperatorOrHigher();\n  } else if (isContextual(ContextualKeyword._infer)) {\n    tsParseInferType();\n  } else {\n    tsParseArrayTypeOrHigher();\n  }\n}\n\nfunction tsParseIntersectionTypeOrHigher() {\n  eat(tt.bitwiseAND);\n  tsParseTypeOperatorOrHigher();\n  if (match(tt.bitwiseAND)) {\n    while (eat(tt.bitwiseAND)) {\n      tsParseTypeOperatorOrHigher();\n    }\n  }\n}\n\nfunction tsParseUnionTypeOrHigher() {\n  eat(tt.bitwiseOR);\n  tsParseIntersectionTypeOrHigher();\n  if (match(tt.bitwiseOR)) {\n    while (eat(tt.bitwiseOR)) {\n      tsParseIntersectionTypeOrHigher();\n    }\n  }\n}\n\nfunction tsIsStartOfFunctionType() {\n  if (match(tt.lessThan)) {\n    return true;\n  }\n  return match(tt.parenL) && tsLookaheadIsUnambiguouslyStartOfFunctionType();\n}\n\nfunction tsSkipParameterStart() {\n  if (match(tt.name) || match(tt._this)) {\n    next();\n    return true;\n  }\n  // If this is a possible array/object destructure, walk to the matching bracket/brace.\n  // The next token after will tell us definitively whether this is a function param.\n  if (match(tt.braceL) || match(tt.bracketL)) {\n    let depth = 1;\n    next();\n    while (depth > 0 && !state.error) {\n      if (match(tt.braceL) || match(tt.bracketL)) {\n        depth++;\n      } else if (match(tt.braceR) || match(tt.bracketR)) {\n        depth--;\n      }\n      next();\n    }\n    return true;\n  }\n  return false;\n}\n\nfunction tsLookaheadIsUnambiguouslyStartOfFunctionType() {\n  const snapshot = state.snapshot();\n  const isUnambiguouslyStartOfFunctionType = tsIsUnambiguouslyStartOfFunctionType();\n  state.restoreFromSnapshot(snapshot);\n  return isUnambiguouslyStartOfFunctionType;\n}\n\nfunction tsIsUnambiguouslyStartOfFunctionType() {\n  next();\n  if (match(tt.parenR) || match(tt.ellipsis)) {\n    // ( )\n    // ( ...\n    return true;\n  }\n  if (tsSkipParameterStart()) {\n    if (match(tt.colon) || match(tt.comma) || match(tt.question) || match(tt.eq)) {\n      // ( xxx :\n      // ( xxx ,\n      // ( xxx ?\n      // ( xxx =\n      return true;\n    }\n    if (match(tt.parenR)) {\n      next();\n      if (match(tt.arrow)) {\n        // ( xxx ) =>\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nfunction tsParseTypeOrTypePredicateAnnotation(returnToken) {\n  const oldIsType = pushTypeContext(0);\n  expect(returnToken);\n  const finishedReturn = tsParseTypePredicateOrAssertsPrefix();\n  if (!finishedReturn) {\n    tsParseType();\n  }\n  popTypeContext(oldIsType);\n}\n\nfunction tsTryParseTypeOrTypePredicateAnnotation() {\n  if (match(tt.colon)) {\n    tsParseTypeOrTypePredicateAnnotation(tt.colon);\n  }\n}\n\nexport function tsTryParseTypeAnnotation() {\n  if (match(tt.colon)) {\n    tsParseTypeAnnotation();\n  }\n}\n\nfunction tsTryParseType() {\n  if (eat(tt.colon)) {\n    tsParseType();\n  }\n}\n\n/**\n * Detect a few special return syntax cases: `x is T`, `asserts x`, `asserts x is T`,\n * `asserts this is T`.\n *\n * Returns true if we parsed the return type, false if there's still a type to be parsed.\n */\nfunction tsParseTypePredicateOrAssertsPrefix() {\n  const snapshot = state.snapshot();\n  if (isContextual(ContextualKeyword._asserts) && !hasPrecedingLineBreak()) {\n    // Normally this is `asserts x is T`, but at this point, it might be `asserts is T` (a user-\n    // defined type guard on the `asserts` variable) or just a type called `asserts`.\n    next();\n    if (eatContextual(ContextualKeyword._is)) {\n      // If we see `asserts is`, then this must be of the form `asserts is T`, since\n      // `asserts is is T` isn't valid.\n      tsParseType();\n      return true;\n    } else if (tsIsIdentifier() || match(tt._this)) {\n      next();\n      if (eatContextual(ContextualKeyword._is)) {\n        // If we see `is`, then this is `asserts x is T`. Otherwise, it's `asserts x`.\n        tsParseType();\n      }\n      return true;\n    } else {\n      // Regular type, so bail out and start type parsing from scratch.\n      state.restoreFromSnapshot(snapshot);\n      return false;\n    }\n  } else if (tsIsIdentifier() || match(tt._this)) {\n    // This is a regular identifier, which may or may not have \"is\" after it.\n    next();\n    if (isContextual(ContextualKeyword._is) && !hasPrecedingLineBreak()) {\n      next();\n      tsParseType();\n      return true;\n    } else {\n      // Regular type, so bail out and start type parsing from scratch.\n      state.restoreFromSnapshot(snapshot);\n      return false;\n    }\n  }\n  return false;\n}\n\nexport function tsParseTypeAnnotation() {\n  const oldIsType = pushTypeContext(0);\n  expect(tt.colon);\n  tsParseType();\n  popTypeContext(oldIsType);\n}\n\nexport function tsParseType() {\n  tsParseNonConditionalType();\n  if (hasPrecedingLineBreak() || !eat(tt._extends)) {\n    return;\n  }\n  // extends type\n  tsParseNonConditionalType();\n  expect(tt.question);\n  // true type\n  tsParseType();\n  expect(tt.colon);\n  // false type\n  tsParseType();\n}\n\nexport function tsParseNonConditionalType() {\n  if (tsIsStartOfFunctionType()) {\n    tsParseFunctionOrConstructorType(FunctionType.TSFunctionType);\n    return;\n  }\n  if (match(tt._new)) {\n    // As in `new () => Date`\n    tsParseFunctionOrConstructorType(FunctionType.TSConstructorType);\n    return;\n  }\n  tsParseUnionTypeOrHigher();\n}\n\nexport function tsParseTypeAssertion() {\n  const oldIsType = pushTypeContext(1);\n  tsParseType();\n  expect(tt.greaterThan);\n  popTypeContext(oldIsType);\n  parseMaybeUnary();\n}\n\nexport function tsTryParseJSXTypeArgument() {\n  if (eat(tt.jsxTagStart)) {\n    state.tokens[state.tokens.length - 1].type = tt.typeParameterStart;\n    const oldIsType = pushTypeContext(1);\n    while (!match(tt.greaterThan) && !state.error) {\n      tsParseType();\n      eat(tt.comma);\n    }\n    // Process >, but the one after needs to be parsed JSX-style.\n    nextJSXTagToken();\n    popTypeContext(oldIsType);\n  }\n}\n\nfunction tsParseHeritageClause() {\n  while (!match(tt.braceL) && !state.error) {\n    tsParseExpressionWithTypeArguments();\n    eat(tt.comma);\n  }\n}\n\nfunction tsParseExpressionWithTypeArguments() {\n  // Note: TS uses parseLeftHandSideExpressionOrHigher,\n  // then has grammar errors later if it's not an EntityName.\n  tsParseEntityName();\n  if (match(tt.lessThan)) {\n    tsParseTypeArguments();\n  }\n}\n\nfunction tsParseInterfaceDeclaration() {\n  parseBindingIdentifier(false);\n  tsTryParseTypeParameters();\n  if (eat(tt._extends)) {\n    tsParseHeritageClause();\n  }\n  tsParseObjectTypeMembers();\n}\n\nfunction tsParseTypeAliasDeclaration() {\n  parseBindingIdentifier(false);\n  tsTryParseTypeParameters();\n  expect(tt.eq);\n  tsParseType();\n  semicolon();\n}\n\nfunction tsParseEnumMember() {\n  // Computed property names are grammar errors in an enum, so accept just string literal or identifier.\n  if (match(tt.string)) {\n    parseLiteral();\n  } else {\n    parseIdentifier();\n  }\n  if (eat(tt.eq)) {\n    const eqIndex = state.tokens.length - 1;\n    parseMaybeAssign();\n    state.tokens[eqIndex].rhsEndIndex = state.tokens.length;\n  }\n}\n\nfunction tsParseEnumDeclaration() {\n  parseBindingIdentifier(false);\n  expect(tt.braceL);\n  while (!eat(tt.braceR) && !state.error) {\n    tsParseEnumMember();\n    eat(tt.comma);\n  }\n}\n\nfunction tsParseModuleBlock() {\n  expect(tt.braceL);\n  parseBlockBody(/* end */ tt.braceR);\n}\n\nfunction tsParseModuleOrNamespaceDeclaration() {\n  parseBindingIdentifier(false);\n  if (eat(tt.dot)) {\n    tsParseModuleOrNamespaceDeclaration();\n  } else {\n    tsParseModuleBlock();\n  }\n}\n\nfunction tsParseAmbientExternalModuleDeclaration() {\n  if (isContextual(ContextualKeyword._global)) {\n    parseIdentifier();\n  } else if (match(tt.string)) {\n    parseExprAtom();\n  } else {\n    unexpected();\n  }\n\n  if (match(tt.braceL)) {\n    tsParseModuleBlock();\n  } else {\n    semicolon();\n  }\n}\n\nexport function tsParseImportEqualsDeclaration() {\n  parseImportedIdentifier();\n  expect(tt.eq);\n  tsParseModuleReference();\n  semicolon();\n}\n\nfunction tsIsExternalModuleReference() {\n  return isContextual(ContextualKeyword._require) && lookaheadType() === tt.parenL;\n}\n\nfunction tsParseModuleReference() {\n  if (tsIsExternalModuleReference()) {\n    tsParseExternalModuleReference();\n  } else {\n    tsParseEntityName();\n  }\n}\n\nfunction tsParseExternalModuleReference() {\n  expectContextual(ContextualKeyword._require);\n  expect(tt.parenL);\n  if (!match(tt.string)) {\n    unexpected();\n  }\n  parseLiteral();\n  expect(tt.parenR);\n}\n\n// Utilities\n\n// Returns true if a statement matched.\nfunction tsTryParseDeclare() {\n  if (isLineTerminator()) {\n    return false;\n  }\n  switch (state.type) {\n    case tt._function: {\n      const oldIsType = pushTypeContext(1);\n      next();\n      // We don't need to precisely get the function start here, since it's only used to mark\n      // the function as a type if it's bodiless, and it's already a type here.\n      const functionStart = state.start;\n      parseFunction(functionStart, /* isStatement */ true);\n      popTypeContext(oldIsType);\n      return true;\n    }\n    case tt._class: {\n      const oldIsType = pushTypeContext(1);\n      parseClass(/* isStatement */ true, /* optionalId */ false);\n      popTypeContext(oldIsType);\n      return true;\n    }\n    case tt._const: {\n      if (match(tt._const) && isLookaheadContextual(ContextualKeyword._enum)) {\n        const oldIsType = pushTypeContext(1);\n        // `const enum = 0;` not allowed because \"enum\" is a strict mode reserved word.\n        expect(tt._const);\n        expectContextual(ContextualKeyword._enum);\n        state.tokens[state.tokens.length - 1].type = tt._enum;\n        tsParseEnumDeclaration();\n        popTypeContext(oldIsType);\n        return true;\n      }\n    }\n    // falls through\n    case tt._var:\n    case tt._let: {\n      const oldIsType = pushTypeContext(1);\n      parseVarStatement(state.type);\n      popTypeContext(oldIsType);\n      return true;\n    }\n    case tt.name: {\n      const oldIsType = pushTypeContext(1);\n      const contextualKeyword = state.contextualKeyword;\n      let matched = false;\n      if (contextualKeyword === ContextualKeyword._global) {\n        tsParseAmbientExternalModuleDeclaration();\n        matched = true;\n      } else {\n        matched = tsParseDeclaration(contextualKeyword, /* isBeforeToken */ true);\n      }\n      popTypeContext(oldIsType);\n      return matched;\n    }\n    default:\n      return false;\n  }\n}\n\n// Note: this won't be called unless the keyword is allowed in `shouldParseExportDeclaration`.\n// Returns true if it matched a declaration.\nfunction tsTryParseExportDeclaration() {\n  return tsParseDeclaration(state.contextualKeyword, /* isBeforeToken */ true);\n}\n\n// Returns true if it matched a statement.\nfunction tsParseExpressionStatement(contextualKeyword) {\n  switch (contextualKeyword) {\n    case ContextualKeyword._declare: {\n      const declareTokenIndex = state.tokens.length - 1;\n      const matched = tsTryParseDeclare();\n      if (matched) {\n        state.tokens[declareTokenIndex].type = tt._declare;\n        return true;\n      }\n      break;\n    }\n    case ContextualKeyword._global:\n      // `global { }` (with no `declare`) may appear inside an ambient module declaration.\n      // Would like to use tsParseAmbientExternalModuleDeclaration here, but already ran past \"global\".\n      if (match(tt.braceL)) {\n        tsParseModuleBlock();\n        return true;\n      }\n      break;\n\n    default:\n      return tsParseDeclaration(contextualKeyword, /* isBeforeToken */ false);\n  }\n  return false;\n}\n\n// Common to tsTryParseDeclare, tsTryParseExportDeclaration, and tsParseExpressionStatement.\n// Returns true if it matched a declaration.\nfunction tsParseDeclaration(contextualKeyword, isBeforeToken) {\n  switch (contextualKeyword) {\n    case ContextualKeyword._abstract:\n      if (tsCheckLineTerminatorAndMatch(tt._class, isBeforeToken)) {\n        if (isBeforeToken) next();\n        state.tokens[state.tokens.length - 1].type = tt._abstract;\n        parseClass(/* isStatement */ true, /* optionalId */ false);\n        return true;\n      }\n      break;\n\n    case ContextualKeyword._enum:\n      if (tsCheckLineTerminatorAndMatch(tt.name, isBeforeToken)) {\n        if (isBeforeToken) next();\n        state.tokens[state.tokens.length - 1].type = tt._enum;\n        tsParseEnumDeclaration();\n        return true;\n      }\n      break;\n\n    case ContextualKeyword._interface:\n      if (tsCheckLineTerminatorAndMatch(tt.name, isBeforeToken)) {\n        // `next` is true in \"export\" and \"declare\" contexts, so we want to remove that token\n        // as well.\n        const oldIsType = pushTypeContext(1);\n        if (isBeforeToken) next();\n        tsParseInterfaceDeclaration();\n        popTypeContext(oldIsType);\n        return true;\n      }\n      break;\n\n    case ContextualKeyword._module:\n      if (isBeforeToken) next();\n      if (match(tt.string)) {\n        const oldIsType = pushTypeContext(isBeforeToken ? 2 : 1);\n        tsParseAmbientExternalModuleDeclaration();\n        popTypeContext(oldIsType);\n        return true;\n      } else if (tsCheckLineTerminatorAndMatch(tt.name, isBeforeToken)) {\n        const oldIsType = pushTypeContext(isBeforeToken ? 2 : 1);\n        if (isBeforeToken) next();\n        tsParseModuleOrNamespaceDeclaration();\n        popTypeContext(oldIsType);\n        return true;\n      }\n      break;\n\n    case ContextualKeyword._namespace:\n      if (tsCheckLineTerminatorAndMatch(tt.name, isBeforeToken)) {\n        const oldIsType = pushTypeContext(1);\n        if (isBeforeToken) next();\n        tsParseModuleOrNamespaceDeclaration();\n        popTypeContext(oldIsType);\n        return true;\n      }\n      break;\n\n    case ContextualKeyword._type:\n      if (tsCheckLineTerminatorAndMatch(tt.name, isBeforeToken)) {\n        const oldIsType = pushTypeContext(1);\n        if (isBeforeToken) next();\n        tsParseTypeAliasDeclaration();\n        popTypeContext(oldIsType);\n        return true;\n      }\n      break;\n\n    default:\n      break;\n  }\n  return false;\n}\n\nfunction tsCheckLineTerminatorAndMatch(tokenType, isBeforeToken) {\n  return !isLineTerminator() && (isBeforeToken || match(tokenType));\n}\n\n// Returns true if there was a generic async arrow function.\nfunction tsTryParseGenericAsyncArrowFunction() {\n  const snapshot = state.snapshot();\n\n  tsParseTypeParameters();\n  parseFunctionParams();\n  tsTryParseTypeOrTypePredicateAnnotation();\n  expect(tt.arrow);\n\n  if (state.error) {\n    state.restoreFromSnapshot(snapshot);\n    return false;\n  }\n\n  parseFunctionBody(true);\n  return true;\n}\n\nfunction tsParseTypeArguments() {\n  const oldIsType = pushTypeContext(0);\n  expect(tt.lessThan);\n  while (!eat(tt.greaterThan) && !state.error) {\n    tsParseType();\n    eat(tt.comma);\n  }\n  popTypeContext(oldIsType);\n}\n\nexport function tsIsDeclarationStart() {\n  if (match(tt.name)) {\n    switch (state.contextualKeyword) {\n      case ContextualKeyword._abstract:\n      case ContextualKeyword._declare:\n      case ContextualKeyword._enum:\n      case ContextualKeyword._interface:\n      case ContextualKeyword._module:\n      case ContextualKeyword._namespace:\n      case ContextualKeyword._type:\n        return true;\n      default:\n        break;\n    }\n  }\n\n  return false;\n}\n\n// ======================================================\n// OVERRIDES\n// ======================================================\n\nexport function tsParseFunctionBodyAndFinish(functionStart, funcContextId) {\n  // For arrow functions, `parseArrow` handles the return type itself.\n  if (match(tt.colon)) {\n    tsParseTypeOrTypePredicateAnnotation(tt.colon);\n  }\n\n  // The original code checked the node type to make sure this function type allows a missing\n  // body, but we skip that to avoid sending around the node type. We instead just use the\n  // allowExpressionBody boolean to make sure it's not an arrow function.\n  if (!match(tt.braceL) && isLineTerminator()) {\n    // Retroactively mark the function declaration as a type.\n    let i = state.tokens.length - 1;\n    while (\n      i >= 0 &&\n      (state.tokens[i].start >= functionStart ||\n        state.tokens[i].type === tt._default ||\n        state.tokens[i].type === tt._export)\n    ) {\n      state.tokens[i].isType = true;\n      i--;\n    }\n    return;\n  }\n\n  parseFunctionBody(false, funcContextId);\n}\n\nexport function tsParseSubscript(\n  startTokenIndex,\n  noCalls,\n  stopState,\n) {\n  if (!hasPrecedingLineBreak() && eat(tt.bang)) {\n    state.tokens[state.tokens.length - 1].type = tt.nonNullAssertion;\n    return;\n  }\n\n  if (match(tt.lessThan)) {\n    // There are number of things we are going to \"maybe\" parse, like type arguments on\n    // tagged template expressions. If any of them fail, walk it back and continue.\n    const snapshot = state.snapshot();\n\n    if (!noCalls && atPossibleAsync()) {\n      // Almost certainly this is a generic async function `async <T>() => ...\n      // But it might be a call with a type argument `async<T>();`\n      const asyncArrowFn = tsTryParseGenericAsyncArrowFunction();\n      if (asyncArrowFn) {\n        return;\n      }\n    }\n    tsParseTypeArguments();\n    if (!noCalls && eat(tt.parenL)) {\n      // With f<T>(), the subscriptStartIndex marker is on the ( token.\n      state.tokens[state.tokens.length - 1].subscriptStartIndex = startTokenIndex;\n      parseCallExpressionArguments();\n    } else if (match(tt.backQuote)) {\n      // Tagged template with a type argument.\n      parseTemplate();\n    } else {\n      unexpected();\n    }\n\n    if (state.error) {\n      state.restoreFromSnapshot(snapshot);\n    } else {\n      return;\n    }\n  } else if (!noCalls && match(tt.questionDot) && lookaheadType() === tt.lessThan) {\n    // If we see f?.<, then this must be an optional call with a type argument.\n    next();\n    state.tokens[startTokenIndex].isOptionalChainStart = true;\n    // With f?.<T>(), the subscriptStartIndex marker is on the ?. token.\n    state.tokens[state.tokens.length - 1].subscriptStartIndex = startTokenIndex;\n\n    tsParseTypeArguments();\n    expect(tt.parenL);\n    parseCallExpressionArguments();\n  }\n  baseParseSubscript(startTokenIndex, noCalls, stopState);\n}\n\nexport function tsStartParseNewArguments() {\n  if (match(tt.lessThan)) {\n    // 99% certain this is `new C<T>();`. But may be `new C < T;`, which is also legal.\n    const snapshot = state.snapshot();\n\n    state.type = tt.typeParameterStart;\n    tsParseTypeArguments();\n    if (!match(tt.parenL)) {\n      unexpected();\n    }\n\n    if (state.error) {\n      state.restoreFromSnapshot(snapshot);\n    }\n  }\n}\n\nexport function tsTryParseExport() {\n  if (match(tt._import)) {\n    // `export import A = B;`\n    expect(tt._import);\n    tsParseImportEqualsDeclaration();\n    return true;\n  } else if (eat(tt.eq)) {\n    // `export = x;`\n    parseExpression();\n    semicolon();\n    return true;\n  } else if (eatContextual(ContextualKeyword._as)) {\n    // `export as namespace A;`\n    // See `parseNamespaceExportDeclaration` in TypeScript's own parser\n    expectContextual(ContextualKeyword._namespace);\n    parseIdentifier();\n    semicolon();\n    return true;\n  } else {\n    if (isContextual(ContextualKeyword._type) && lookaheadType() === tt.braceL) {\n      next();\n    }\n    return false;\n  }\n}\n\nexport function tsTryParseExportDefaultExpression() {\n  if (isContextual(ContextualKeyword._abstract) && lookaheadType() === tt._class) {\n    state.type = tt._abstract;\n    next(); // Skip \"abstract\"\n    parseClass(true, true);\n    return true;\n  }\n  if (isContextual(ContextualKeyword._interface)) {\n    // Make sure \"export default\" are considered type tokens so the whole thing is removed.\n    const oldIsType = pushTypeContext(2);\n    tsParseDeclaration(ContextualKeyword._interface, true);\n    popTypeContext(oldIsType);\n    return true;\n  }\n  return false;\n}\n\nexport function tsTryParseStatementContent() {\n  if (state.type === tt._const) {\n    const ahead = lookaheadTypeAndKeyword();\n    if (ahead.type === tt.name && ahead.contextualKeyword === ContextualKeyword._enum) {\n      expect(tt._const);\n      expectContextual(ContextualKeyword._enum);\n      state.tokens[state.tokens.length - 1].type = tt._enum;\n      tsParseEnumDeclaration();\n      return true;\n    }\n  }\n  return false;\n}\n\nexport function tsParseAccessModifier() {\n  tsParseModifier([\n    ContextualKeyword._public,\n    ContextualKeyword._protected,\n    ContextualKeyword._private,\n  ]);\n}\n\nexport function tsTryParseClassMemberWithIsStatic(\n  isStatic,\n  classContextId,\n) {\n  let isAbstract = false;\n  let isReadonly = false;\n\n  while (true) {\n    const mod = tsParseModifier([\n      ContextualKeyword._abstract,\n      ContextualKeyword._readonly,\n      ContextualKeyword._declare,\n    ]);\n    if (mod == null) {\n      break;\n    }\n    if (mod === ContextualKeyword._readonly) {\n      isReadonly = true;\n    }\n    if (mod === ContextualKeyword._abstract) {\n      isAbstract = true;\n    }\n  }\n\n  // We no longer check for public/private/etc, but tsTryParseIndexSignature should just return\n  // false in that case for valid code.\n  if (!isAbstract && !isStatic) {\n    const found = tsTryParseIndexSignature();\n    if (found) {\n      return true;\n    }\n  }\n\n  if (isReadonly) {\n    // Must be a property (if not an index signature).\n    parseClassPropertyName(classContextId);\n    parsePostMemberNameModifiers();\n    parseClassProperty();\n    return true;\n  }\n  return false;\n}\n\n// Note: The reason we do this in `parseIdentifierStatement` and not `parseStatement`\n// is that e.g. `type()` is valid JS, so we must try parsing that first.\n// If it's really a type, we will parse `type` as the statement, and can correct it here\n// by parsing the rest.\nexport function tsParseIdentifierStatement(contextualKeyword) {\n  const matched = tsParseExpressionStatement(contextualKeyword);\n  if (!matched) {\n    semicolon();\n  }\n}\n\nexport function tsParseExportDeclaration() {\n  // \"export declare\" is equivalent to just \"export\".\n  const isDeclare = eatContextual(ContextualKeyword._declare);\n  if (isDeclare) {\n    state.tokens[state.tokens.length - 1].type = tt._declare;\n  }\n\n  let matchedDeclaration = false;\n  if (match(tt.name)) {\n    if (isDeclare) {\n      const oldIsType = pushTypeContext(2);\n      matchedDeclaration = tsTryParseExportDeclaration();\n      popTypeContext(oldIsType);\n    } else {\n      matchedDeclaration = tsTryParseExportDeclaration();\n    }\n  }\n  if (!matchedDeclaration) {\n    if (isDeclare) {\n      const oldIsType = pushTypeContext(2);\n      parseStatement(true);\n      popTypeContext(oldIsType);\n    } else {\n      parseStatement(true);\n    }\n  }\n}\n\nexport function tsAfterParseClassSuper(hasSuper) {\n  if (hasSuper && match(tt.lessThan)) {\n    tsParseTypeArguments();\n  }\n  if (eatContextual(ContextualKeyword._implements)) {\n    state.tokens[state.tokens.length - 1].type = tt._implements;\n    const oldIsType = pushTypeContext(1);\n    tsParseHeritageClause();\n    popTypeContext(oldIsType);\n  }\n}\n\nexport function tsStartParseObjPropValue() {\n  tsTryParseTypeParameters();\n}\n\nexport function tsStartParseFunctionParams() {\n  tsTryParseTypeParameters();\n}\n\n// `let x: number;`\nexport function tsAfterParseVarHead() {\n  const oldIsType = pushTypeContext(0);\n  eat(tt.bang);\n  tsTryParseTypeAnnotation();\n  popTypeContext(oldIsType);\n}\n\n// parse the return type of an async arrow function - let foo = (async (): number => {});\nexport function tsStartParseAsyncArrowFromCallExpression() {\n  if (match(tt.colon)) {\n    tsParseTypeAnnotation();\n  }\n}\n\n// Returns true if the expression was an arrow function.\nexport function tsParseMaybeAssign(noIn, isWithinParens) {\n  // Note: When the JSX plugin is on, type assertions (`<T> x`) aren't valid syntax.\n  if (isJSXEnabled) {\n    return tsParseMaybeAssignWithJSX(noIn, isWithinParens);\n  } else {\n    return tsParseMaybeAssignWithoutJSX(noIn, isWithinParens);\n  }\n}\n\nexport function tsParseMaybeAssignWithJSX(noIn, isWithinParens) {\n  if (!match(tt.lessThan)) {\n    return baseParseMaybeAssign(noIn, isWithinParens);\n  }\n\n  // Prefer to parse JSX if possible. But may be an arrow fn.\n  const snapshot = state.snapshot();\n  let wasArrow = baseParseMaybeAssign(noIn, isWithinParens);\n  if (state.error) {\n    state.restoreFromSnapshot(snapshot);\n  } else {\n    return wasArrow;\n  }\n\n  // Otherwise, try as type-parameterized arrow function.\n  state.type = tt.typeParameterStart;\n  // This is similar to TypeScript's `tryParseParenthesizedArrowFunctionExpression`.\n  tsParseTypeParameters();\n  wasArrow = baseParseMaybeAssign(noIn, isWithinParens);\n  if (!wasArrow) {\n    unexpected();\n  }\n\n  return wasArrow;\n}\n\nexport function tsParseMaybeAssignWithoutJSX(noIn, isWithinParens) {\n  if (!match(tt.lessThan)) {\n    return baseParseMaybeAssign(noIn, isWithinParens);\n  }\n\n  const snapshot = state.snapshot();\n  // This is similar to TypeScript's `tryParseParenthesizedArrowFunctionExpression`.\n  tsParseTypeParameters();\n  const wasArrow = baseParseMaybeAssign(noIn, isWithinParens);\n  if (!wasArrow) {\n    unexpected();\n  }\n  if (state.error) {\n    state.restoreFromSnapshot(snapshot);\n  } else {\n    return wasArrow;\n  }\n\n  // Try parsing a type cast instead of an arrow function.\n  // This will start with a type assertion (via parseMaybeUnary).\n  // But don't directly call `tsParseTypeAssertion` because we want to handle any binary after it.\n  return baseParseMaybeAssign(noIn, isWithinParens);\n}\n\nexport function tsParseArrow() {\n  if (match(tt.colon)) {\n    // This is different from how the TS parser does it.\n    // TS uses lookahead. Babylon parses it as a parenthesized expression and converts.\n    const snapshot = state.snapshot();\n\n    tsParseTypeOrTypePredicateAnnotation(tt.colon);\n    if (canInsertSemicolon()) unexpected();\n    if (!match(tt.arrow)) unexpected();\n\n    if (state.error) {\n      state.restoreFromSnapshot(snapshot);\n    }\n  }\n  return eat(tt.arrow);\n}\n\n// Allow type annotations inside of a parameter list.\nexport function tsParseAssignableListItemTypes() {\n  const oldIsType = pushTypeContext(0);\n  eat(tt.question);\n  tsTryParseTypeAnnotation();\n  popTypeContext(oldIsType);\n}\n\nexport function tsParseMaybeDecoratorArguments() {\n  if (match(tt.lessThan)) {\n    tsParseTypeArguments();\n  }\n  baseParseMaybeDecoratorArguments();\n}\n","\nimport getIdentifierNames from \"./util/getIdentifierNames\";\n\nexport default class NameManager {\n    __init() {this.usedNames = new Set()}\n\n  constructor(code, tokens) {;NameManager.prototype.__init.call(this);\n    this.usedNames = new Set(getIdentifierNames(code, tokens));\n  }\n\n  claimFreeName(name) {\n    const newName = this.findFreeName(name);\n    this.usedNames.add(newName);\n    return newName;\n  }\n\n  findFreeName(name) {\n    if (!this.usedNames.has(name)) {\n      return name;\n    }\n    let suffixNum = 2;\n    while (this.usedNames.has(name + suffixNum)) {\n      suffixNum++;\n    }\n    return name + suffixNum;\n  }\n}\n","\nimport {TokenType as tt} from \"../parser/tokenizer/types\";\n\n/**\n * Get all identifier names in the code, in order, including duplicates.\n */\nexport default function getIdentifierNames(code, tokens) {\n  const names = [];\n  for (const token of tokens) {\n    if (token.type === tt.name) {\n      names.push(code.slice(token.start, token.end));\n    }\n  }\n  return names;\n}\n","/**\n * This module was automatically generated by `ts-interface-builder`\n */\nimport * as t from \"ts-interface-checker\";\n// tslint:disable:object-literal-key-quotes\n\nexport const Transform = t.union(\n  t.lit(\"jsx\"),\n  t.lit(\"typescript\"),\n  t.lit(\"flow\"),\n  t.lit(\"imports\"),\n  t.lit(\"react-hot-loader\"),\n);\n\nexport const SourceMapOptions = t.iface([], {\n  compiledFilename: \"string\",\n});\n\nexport const Options = t.iface([], {\n  transforms: t.array(\"Transform\"),\n  jsxPragma: t.opt(\"string\"),\n  jsxFragmentPragma: t.opt(\"string\"),\n  enableLegacyTypeScriptModuleInterop: t.opt(\"boolean\"),\n  enableLegacyBabel5ModuleInterop: t.opt(\"boolean\"),\n  sourceMapOptions: t.opt(\"SourceMapOptions\"),\n  filePath: t.opt(\"string\"),\n  production: t.opt(\"boolean\"),\n});\n\nconst exportedTypeSuite = {\n  Transform,\n  SourceMapOptions,\n  Options,\n};\nexport default exportedTypeSuite;\n","import {createCheckers} from \"ts-interface-checker\";\nimport OptionsGenTypes from \"./Options-gen-types\";\n\nconst {Options: OptionsChecker} = createCheckers(OptionsGenTypes);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nexport function validateOptions(options) {\n  OptionsChecker.strictCheck(options);\n}\n","import {flowParseAssignableListItemTypes} from \"../plugins/flow\";\nimport {\n  tsParseAccessModifier,\n  tsParseAssignableListItemTypes,\n  tsParseModifier,\n} from \"../plugins/typescript\";\nimport {\n  eat,\n  IdentifierRole,\n  match,\n  next,\n  popTypeContext,\n  pushTypeContext,\n} from \"../tokenizer/index\";\nimport {ContextualKeyword} from \"../tokenizer/keywords\";\nimport {TokenType, TokenType as tt} from \"../tokenizer/types\";\nimport {isFlowEnabled, isTypeScriptEnabled, state} from \"./base\";\nimport {parseIdentifier, parseMaybeAssign, parseObj} from \"./expression\";\nimport {expect, unexpected} from \"./util\";\n\nexport function parseSpread() {\n  next();\n  parseMaybeAssign(false);\n}\n\nexport function parseRest(isBlockScope) {\n  next();\n  parseBindingAtom(isBlockScope);\n}\n\nexport function parseBindingIdentifier(isBlockScope) {\n  parseIdentifier();\n  markPriorBindingIdentifier(isBlockScope);\n}\n\nexport function parseImportedIdentifier() {\n  parseIdentifier();\n  state.tokens[state.tokens.length - 1].identifierRole = IdentifierRole.ImportDeclaration;\n}\n\nexport function markPriorBindingIdentifier(isBlockScope) {\n  if (state.scopeDepth === 0) {\n    state.tokens[state.tokens.length - 1].identifierRole = IdentifierRole.TopLevelDeclaration;\n  } else {\n    state.tokens[state.tokens.length - 1].identifierRole = isBlockScope\n      ? IdentifierRole.BlockScopedDeclaration\n      : IdentifierRole.FunctionScopedDeclaration;\n  }\n}\n\n// Parses lvalue (assignable) atom.\nexport function parseBindingAtom(isBlockScope) {\n  switch (state.type) {\n    case tt._this: {\n      // In TypeScript, \"this\" may be the name of a parameter, so allow it.\n      const oldIsType = pushTypeContext(0);\n      next();\n      popTypeContext(oldIsType);\n      return;\n    }\n\n    case tt._yield:\n    case tt.name: {\n      state.type = tt.name;\n      parseBindingIdentifier(isBlockScope);\n      return;\n    }\n\n    case tt.bracketL: {\n      next();\n      parseBindingList(tt.bracketR, isBlockScope, true /* allowEmpty */);\n      return;\n    }\n\n    case tt.braceL:\n      parseObj(true, isBlockScope);\n      return;\n\n    default:\n      unexpected();\n  }\n}\n\nexport function parseBindingList(\n  close,\n  isBlockScope,\n  allowEmpty = false,\n  allowModifiers = false,\n  contextId = 0,\n) {\n  let first = true;\n\n  let hasRemovedComma = false;\n  const firstItemTokenIndex = state.tokens.length;\n\n  while (!eat(close) && !state.error) {\n    if (first) {\n      first = false;\n    } else {\n      expect(tt.comma);\n      state.tokens[state.tokens.length - 1].contextId = contextId;\n      // After a \"this\" type in TypeScript, we need to set the following comma (if any) to also be\n      // a type token so that it will be removed.\n      if (!hasRemovedComma && state.tokens[firstItemTokenIndex].isType) {\n        state.tokens[state.tokens.length - 1].isType = true;\n        hasRemovedComma = true;\n      }\n    }\n    if (allowEmpty && match(tt.comma)) {\n      // Empty item; nothing further to parse for this item.\n    } else if (eat(close)) {\n      break;\n    } else if (match(tt.ellipsis)) {\n      parseRest(isBlockScope);\n      parseAssignableListItemTypes();\n      // Support rest element trailing commas allowed by TypeScript <2.9.\n      eat(TokenType.comma);\n      expect(close);\n      break;\n    } else {\n      parseAssignableListItem(allowModifiers, isBlockScope);\n    }\n  }\n}\n\nfunction parseAssignableListItem(allowModifiers, isBlockScope) {\n  if (allowModifiers) {\n    tsParseAccessModifier();\n    tsParseModifier([ContextualKeyword._readonly]);\n  }\n\n  parseMaybeDefault(isBlockScope);\n  parseAssignableListItemTypes();\n  parseMaybeDefault(isBlockScope, true /* leftAlreadyParsed */);\n}\n\nfunction parseAssignableListItemTypes() {\n  if (isFlowEnabled) {\n    flowParseAssignableListItemTypes();\n  } else if (isTypeScriptEnabled) {\n    tsParseAssignableListItemTypes();\n  }\n}\n\n// Parses assignment pattern around given atom if possible.\nexport function parseMaybeDefault(isBlockScope, leftAlreadyParsed = false) {\n  if (!leftAlreadyParsed) {\n    parseBindingAtom(isBlockScope);\n  }\n  if (!eat(tt.eq)) {\n    return;\n  }\n  const eqIndex = state.tokens.length - 1;\n  parseMaybeAssign();\n  state.tokens[eqIndex].rhsEndIndex = state.tokens.length;\n}\n","/* eslint max-len: 0 */\n\nimport {\n  eat,\n  lookaheadType,\n  lookaheadTypeAndKeyword,\n  match,\n  next,\n  popTypeContext,\n  pushTypeContext,\n\n} from \"../tokenizer/index\";\nimport {ContextualKeyword} from \"../tokenizer/keywords\";\nimport {TokenType, TokenType as tt} from \"../tokenizer/types\";\nimport {input, state} from \"../traverser/base\";\nimport {\n  baseParseMaybeAssign,\n  baseParseSubscript,\n  baseParseSubscripts,\n  parseArrow,\n  parseArrowExpression,\n  parseCallExpressionArguments,\n  parseExprAtom,\n  parseExpression,\n  parseFunctionBody,\n  parseIdentifier,\n  parseLiteral,\n\n} from \"../traverser/expression\";\nimport {\n  baseParseExportStar,\n  parseExport,\n  parseExportFrom,\n  parseExportSpecifiers,\n  parseFunctionParams,\n  parseImport,\n  parseStatement,\n} from \"../traverser/statement\";\nimport {\n  canInsertSemicolon,\n  eatContextual,\n  expect,\n  expectContextual,\n  isContextual,\n  isLookaheadContextual,\n  semicolon,\n  unexpected,\n} from \"../traverser/util\";\n\nfunction isMaybeDefaultImport(lookahead) {\n  return (\n    (lookahead.type === tt.name || !!(lookahead.type & TokenType.IS_KEYWORD)) &&\n    lookahead.contextualKeyword !== ContextualKeyword._from\n  );\n}\n\nfunction flowParseTypeInitialiser(tok) {\n  const oldIsType = pushTypeContext(0);\n  expect(tok || tt.colon);\n  flowParseType();\n  popTypeContext(oldIsType);\n}\n\nfunction flowParsePredicate() {\n  expect(tt.modulo);\n  expectContextual(ContextualKeyword._checks);\n  if (eat(tt.parenL)) {\n    parseExpression();\n    expect(tt.parenR);\n  }\n}\n\nfunction flowParseTypeAndPredicateInitialiser() {\n  const oldIsType = pushTypeContext(0);\n  expect(tt.colon);\n  if (match(tt.modulo)) {\n    flowParsePredicate();\n  } else {\n    flowParseType();\n    if (match(tt.modulo)) {\n      flowParsePredicate();\n    }\n  }\n  popTypeContext(oldIsType);\n}\n\nfunction flowParseDeclareClass() {\n  next();\n  flowParseInterfaceish(/* isClass */ true);\n}\n\nfunction flowParseDeclareFunction() {\n  next();\n  parseIdentifier();\n\n  if (match(tt.lessThan)) {\n    flowParseTypeParameterDeclaration();\n  }\n\n  expect(tt.parenL);\n  flowParseFunctionTypeParams();\n  expect(tt.parenR);\n\n  flowParseTypeAndPredicateInitialiser();\n\n  semicolon();\n}\n\nfunction flowParseDeclare() {\n  if (match(tt._class)) {\n    flowParseDeclareClass();\n  } else if (match(tt._function)) {\n    flowParseDeclareFunction();\n  } else if (match(tt._var)) {\n    flowParseDeclareVariable();\n  } else if (eatContextual(ContextualKeyword._module)) {\n    if (eat(tt.dot)) {\n      flowParseDeclareModuleExports();\n    } else {\n      flowParseDeclareModule();\n    }\n  } else if (isContextual(ContextualKeyword._type)) {\n    flowParseDeclareTypeAlias();\n  } else if (isContextual(ContextualKeyword._opaque)) {\n    flowParseDeclareOpaqueType();\n  } else if (isContextual(ContextualKeyword._interface)) {\n    flowParseDeclareInterface();\n  } else if (match(tt._export)) {\n    flowParseDeclareExportDeclaration();\n  } else {\n    unexpected();\n  }\n}\n\nfunction flowParseDeclareVariable() {\n  next();\n  flowParseTypeAnnotatableIdentifier();\n  semicolon();\n}\n\nfunction flowParseDeclareModule() {\n  if (match(tt.string)) {\n    parseExprAtom();\n  } else {\n    parseIdentifier();\n  }\n\n  expect(tt.braceL);\n  while (!match(tt.braceR) && !state.error) {\n    if (match(tt._import)) {\n      next();\n      parseImport();\n    } else {\n      unexpected();\n    }\n  }\n  expect(tt.braceR);\n}\n\nfunction flowParseDeclareExportDeclaration() {\n  expect(tt._export);\n\n  if (eat(tt._default)) {\n    if (match(tt._function) || match(tt._class)) {\n      // declare export default class ...\n      // declare export default function ...\n      flowParseDeclare();\n    } else {\n      // declare export default [type];\n      flowParseType();\n      semicolon();\n    }\n  } else if (\n    match(tt._var) || // declare export var ...\n    match(tt._function) || // declare export function ...\n    match(tt._class) || // declare export class ...\n    isContextual(ContextualKeyword._opaque) // declare export opaque ..\n  ) {\n    flowParseDeclare();\n  } else if (\n    match(tt.star) || // declare export * from ''\n    match(tt.braceL) || // declare export {} ...\n    isContextual(ContextualKeyword._interface) || // declare export interface ...\n    isContextual(ContextualKeyword._type) || // declare export type ...\n    isContextual(ContextualKeyword._opaque) // declare export opaque type ...\n  ) {\n    parseExport();\n  } else {\n    unexpected();\n  }\n}\n\nfunction flowParseDeclareModuleExports() {\n  expectContextual(ContextualKeyword._exports);\n  flowParseTypeAnnotation();\n  semicolon();\n}\n\nfunction flowParseDeclareTypeAlias() {\n  next();\n  flowParseTypeAlias();\n}\n\nfunction flowParseDeclareOpaqueType() {\n  next();\n  flowParseOpaqueType(true);\n}\n\nfunction flowParseDeclareInterface() {\n  next();\n  flowParseInterfaceish();\n}\n\n// Interfaces\n\nfunction flowParseInterfaceish(isClass = false) {\n  flowParseRestrictedIdentifier();\n\n  if (match(tt.lessThan)) {\n    flowParseTypeParameterDeclaration();\n  }\n\n  if (eat(tt._extends)) {\n    do {\n      flowParseInterfaceExtends();\n    } while (!isClass && eat(tt.comma));\n  }\n\n  if (isContextual(ContextualKeyword._mixins)) {\n    next();\n    do {\n      flowParseInterfaceExtends();\n    } while (eat(tt.comma));\n  }\n\n  if (isContextual(ContextualKeyword._implements)) {\n    next();\n    do {\n      flowParseInterfaceExtends();\n    } while (eat(tt.comma));\n  }\n\n  flowParseObjectType(isClass, false, isClass);\n}\n\nfunction flowParseInterfaceExtends() {\n  flowParseQualifiedTypeIdentifier(false);\n  if (match(tt.lessThan)) {\n    flowParseTypeParameterInstantiation();\n  }\n}\n\nfunction flowParseInterface() {\n  flowParseInterfaceish();\n}\n\nfunction flowParseRestrictedIdentifier() {\n  parseIdentifier();\n}\n\nfunction flowParseTypeAlias() {\n  flowParseRestrictedIdentifier();\n\n  if (match(tt.lessThan)) {\n    flowParseTypeParameterDeclaration();\n  }\n\n  flowParseTypeInitialiser(tt.eq);\n  semicolon();\n}\n\nfunction flowParseOpaqueType(declare) {\n  expectContextual(ContextualKeyword._type);\n  flowParseRestrictedIdentifier();\n\n  if (match(tt.lessThan)) {\n    flowParseTypeParameterDeclaration();\n  }\n\n  // Parse the supertype\n  if (match(tt.colon)) {\n    flowParseTypeInitialiser(tt.colon);\n  }\n\n  if (!declare) {\n    flowParseTypeInitialiser(tt.eq);\n  }\n  semicolon();\n}\n\nfunction flowParseTypeParameter() {\n  flowParseVariance();\n  flowParseTypeAnnotatableIdentifier();\n\n  if (eat(tt.eq)) {\n    flowParseType();\n  }\n}\n\nexport function flowParseTypeParameterDeclaration() {\n  const oldIsType = pushTypeContext(0);\n  // istanbul ignore else: this condition is already checked at all call sites\n  if (match(tt.lessThan) || match(tt.typeParameterStart)) {\n    next();\n  } else {\n    unexpected();\n  }\n\n  do {\n    flowParseTypeParameter();\n    if (!match(tt.greaterThan)) {\n      expect(tt.comma);\n    }\n  } while (!match(tt.greaterThan) && !state.error);\n  expect(tt.greaterThan);\n  popTypeContext(oldIsType);\n}\n\nfunction flowParseTypeParameterInstantiation() {\n  const oldIsType = pushTypeContext(0);\n  expect(tt.lessThan);\n  while (!match(tt.greaterThan) && !state.error) {\n    flowParseType();\n    if (!match(tt.greaterThan)) {\n      expect(tt.comma);\n    }\n  }\n  expect(tt.greaterThan);\n  popTypeContext(oldIsType);\n}\n\nfunction flowParseInterfaceType() {\n  expectContextual(ContextualKeyword._interface);\n  if (eat(tt._extends)) {\n    do {\n      flowParseInterfaceExtends();\n    } while (eat(tt.comma));\n  }\n  flowParseObjectType(false, false, false);\n}\n\nfunction flowParseObjectPropertyKey() {\n  if (match(tt.num) || match(tt.string)) {\n    parseExprAtom();\n  } else {\n    parseIdentifier();\n  }\n}\n\nfunction flowParseObjectTypeIndexer() {\n  // Note: bracketL has already been consumed\n  if (lookaheadType() === tt.colon) {\n    flowParseObjectPropertyKey();\n    flowParseTypeInitialiser();\n  } else {\n    flowParseType();\n  }\n  expect(tt.bracketR);\n  flowParseTypeInitialiser();\n}\n\nfunction flowParseObjectTypeInternalSlot() {\n  // Note: both bracketL have already been consumed\n  flowParseObjectPropertyKey();\n  expect(tt.bracketR);\n  expect(tt.bracketR);\n  if (match(tt.lessThan) || match(tt.parenL)) {\n    flowParseObjectTypeMethodish();\n  } else {\n    eat(tt.question);\n    flowParseTypeInitialiser();\n  }\n}\n\nfunction flowParseObjectTypeMethodish() {\n  if (match(tt.lessThan)) {\n    flowParseTypeParameterDeclaration();\n  }\n\n  expect(tt.parenL);\n  while (!match(tt.parenR) && !match(tt.ellipsis) && !state.error) {\n    flowParseFunctionTypeParam();\n    if (!match(tt.parenR)) {\n      expect(tt.comma);\n    }\n  }\n\n  if (eat(tt.ellipsis)) {\n    flowParseFunctionTypeParam();\n  }\n  expect(tt.parenR);\n  flowParseTypeInitialiser();\n}\n\nfunction flowParseObjectTypeCallProperty() {\n  flowParseObjectTypeMethodish();\n}\n\nfunction flowParseObjectType(allowStatic, allowExact, allowProto) {\n  let endDelim;\n  if (allowExact && match(tt.braceBarL)) {\n    expect(tt.braceBarL);\n    endDelim = tt.braceBarR;\n  } else {\n    expect(tt.braceL);\n    endDelim = tt.braceR;\n  }\n\n  while (!match(endDelim) && !state.error) {\n    if (allowProto && isContextual(ContextualKeyword._proto)) {\n      const lookahead = lookaheadType();\n      if (lookahead !== tt.colon && lookahead !== tt.question) {\n        next();\n        allowStatic = false;\n      }\n    }\n    if (allowStatic && isContextual(ContextualKeyword._static)) {\n      const lookahead = lookaheadType();\n      if (lookahead !== tt.colon && lookahead !== tt.question) {\n        next();\n      }\n    }\n\n    flowParseVariance();\n\n    if (eat(tt.bracketL)) {\n      if (eat(tt.bracketL)) {\n        flowParseObjectTypeInternalSlot();\n      } else {\n        flowParseObjectTypeIndexer();\n      }\n    } else if (match(tt.parenL) || match(tt.lessThan)) {\n      flowParseObjectTypeCallProperty();\n    } else {\n      if (isContextual(ContextualKeyword._get) || isContextual(ContextualKeyword._set)) {\n        const lookahead = lookaheadType();\n        if (lookahead === tt.name || lookahead === tt.string || lookahead === tt.num) {\n          next();\n        }\n      }\n\n      flowParseObjectTypeProperty();\n    }\n\n    flowObjectTypeSemicolon();\n  }\n\n  expect(endDelim);\n}\n\nfunction flowParseObjectTypeProperty() {\n  if (match(tt.ellipsis)) {\n    expect(tt.ellipsis);\n    if (!eat(tt.comma)) {\n      eat(tt.semi);\n    }\n    // Explicit inexact object syntax.\n    if (match(tt.braceR)) {\n      return;\n    }\n    flowParseType();\n  } else {\n    flowParseObjectPropertyKey();\n    if (match(tt.lessThan) || match(tt.parenL)) {\n      // This is a method property\n      flowParseObjectTypeMethodish();\n    } else {\n      eat(tt.question);\n      flowParseTypeInitialiser();\n    }\n  }\n}\n\nfunction flowObjectTypeSemicolon() {\n  if (!eat(tt.semi) && !eat(tt.comma) && !match(tt.braceR) && !match(tt.braceBarR)) {\n    unexpected();\n  }\n}\n\nfunction flowParseQualifiedTypeIdentifier(initialIdAlreadyParsed) {\n  if (!initialIdAlreadyParsed) {\n    parseIdentifier();\n  }\n  while (eat(tt.dot)) {\n    parseIdentifier();\n  }\n}\n\nfunction flowParseGenericType() {\n  flowParseQualifiedTypeIdentifier(true);\n  if (match(tt.lessThan)) {\n    flowParseTypeParameterInstantiation();\n  }\n}\n\nfunction flowParseTypeofType() {\n  expect(tt._typeof);\n  flowParsePrimaryType();\n}\n\nfunction flowParseTupleType() {\n  expect(tt.bracketL);\n  // We allow trailing commas\n  while (state.pos < input.length && !match(tt.bracketR)) {\n    flowParseType();\n    if (match(tt.bracketR)) {\n      break;\n    }\n    expect(tt.comma);\n  }\n  expect(tt.bracketR);\n}\n\nfunction flowParseFunctionTypeParam() {\n  const lookahead = lookaheadType();\n  if (lookahead === tt.colon || lookahead === tt.question) {\n    parseIdentifier();\n    eat(tt.question);\n    flowParseTypeInitialiser();\n  } else {\n    flowParseType();\n  }\n}\n\nfunction flowParseFunctionTypeParams() {\n  while (!match(tt.parenR) && !match(tt.ellipsis) && !state.error) {\n    flowParseFunctionTypeParam();\n    if (!match(tt.parenR)) {\n      expect(tt.comma);\n    }\n  }\n  if (eat(tt.ellipsis)) {\n    flowParseFunctionTypeParam();\n  }\n}\n\n// The parsing of types roughly parallels the parsing of expressions, and\n// primary types are kind of like primary expressions...they're the\n// primitives with which other types are constructed.\nfunction flowParsePrimaryType() {\n  let isGroupedType = false;\n  const oldNoAnonFunctionType = state.noAnonFunctionType;\n\n  switch (state.type) {\n    case tt.name: {\n      if (isContextual(ContextualKeyword._interface)) {\n        flowParseInterfaceType();\n        return;\n      }\n      parseIdentifier();\n      flowParseGenericType();\n      return;\n    }\n\n    case tt.braceL:\n      flowParseObjectType(false, false, false);\n      return;\n\n    case tt.braceBarL:\n      flowParseObjectType(false, true, false);\n      return;\n\n    case tt.bracketL:\n      flowParseTupleType();\n      return;\n\n    case tt.lessThan:\n      flowParseTypeParameterDeclaration();\n      expect(tt.parenL);\n      flowParseFunctionTypeParams();\n      expect(tt.parenR);\n      expect(tt.arrow);\n      flowParseType();\n      return;\n\n    case tt.parenL:\n      next();\n\n      // Check to see if this is actually a grouped type\n      if (!match(tt.parenR) && !match(tt.ellipsis)) {\n        if (match(tt.name)) {\n          const token = lookaheadType();\n          isGroupedType = token !== tt.question && token !== tt.colon;\n        } else {\n          isGroupedType = true;\n        }\n      }\n\n      if (isGroupedType) {\n        state.noAnonFunctionType = false;\n        flowParseType();\n        state.noAnonFunctionType = oldNoAnonFunctionType;\n\n        // A `,` or a `) =>` means this is an anonymous function type\n        if (\n          state.noAnonFunctionType ||\n          !(match(tt.comma) || (match(tt.parenR) && lookaheadType() === tt.arrow))\n        ) {\n          expect(tt.parenR);\n          return;\n        } else {\n          // Eat a comma if there is one\n          eat(tt.comma);\n        }\n      }\n\n      flowParseFunctionTypeParams();\n\n      expect(tt.parenR);\n      expect(tt.arrow);\n      flowParseType();\n      return;\n\n    case tt.minus:\n      next();\n      parseLiteral();\n      return;\n\n    case tt.string:\n    case tt.num:\n    case tt._true:\n    case tt._false:\n    case tt._null:\n    case tt._this:\n    case tt._void:\n    case tt.star:\n      next();\n      return;\n\n    default:\n      if (state.type === tt._typeof) {\n        flowParseTypeofType();\n        return;\n      } else if (state.type & TokenType.IS_KEYWORD) {\n        next();\n        state.tokens[state.tokens.length - 1].type = tt.name;\n        return;\n      }\n  }\n\n  unexpected();\n}\n\nfunction flowParsePostfixType() {\n  flowParsePrimaryType();\n  while (!canInsertSemicolon() && match(tt.bracketL)) {\n    expect(tt.bracketL);\n    expect(tt.bracketR);\n  }\n}\n\nfunction flowParsePrefixType() {\n  if (eat(tt.question)) {\n    flowParsePrefixType();\n  } else {\n    flowParsePostfixType();\n  }\n}\n\nfunction flowParseAnonFunctionWithoutParens() {\n  flowParsePrefixType();\n  if (!state.noAnonFunctionType && eat(tt.arrow)) {\n    flowParseType();\n  }\n}\n\nfunction flowParseIntersectionType() {\n  eat(tt.bitwiseAND);\n  flowParseAnonFunctionWithoutParens();\n  while (eat(tt.bitwiseAND)) {\n    flowParseAnonFunctionWithoutParens();\n  }\n}\n\nfunction flowParseUnionType() {\n  eat(tt.bitwiseOR);\n  flowParseIntersectionType();\n  while (eat(tt.bitwiseOR)) {\n    flowParseIntersectionType();\n  }\n}\n\nfunction flowParseType() {\n  flowParseUnionType();\n}\n\nexport function flowParseTypeAnnotation() {\n  flowParseTypeInitialiser();\n}\n\nfunction flowParseTypeAnnotatableIdentifier() {\n  parseIdentifier();\n  if (match(tt.colon)) {\n    flowParseTypeAnnotation();\n  }\n}\n\nexport function flowParseVariance() {\n  if (match(tt.plus) || match(tt.minus)) {\n    next();\n  }\n}\n\n// ==================================\n// Overrides\n// ==================================\n\nexport function flowParseFunctionBodyAndFinish(funcContextId) {\n  // For arrow functions, `parseArrow` handles the return type itself.\n  if (match(tt.colon)) {\n    flowParseTypeAndPredicateInitialiser();\n  }\n\n  parseFunctionBody(false, funcContextId);\n}\n\nexport function flowParseSubscript(\n  startTokenIndex,\n  noCalls,\n  stopState,\n) {\n  if (match(tt.questionDot) && lookaheadType() === tt.lessThan) {\n    if (noCalls) {\n      stopState.stop = true;\n      return;\n    }\n    next();\n    flowParseTypeParameterInstantiation();\n    expect(tt.parenL);\n    parseCallExpressionArguments();\n    return;\n  } else if (!noCalls && match(tt.lessThan)) {\n    const snapshot = state.snapshot();\n    flowParseTypeParameterInstantiation();\n    expect(tt.parenL);\n    parseCallExpressionArguments();\n    if (state.error) {\n      state.restoreFromSnapshot(snapshot);\n    } else {\n      return;\n    }\n  }\n  baseParseSubscript(startTokenIndex, noCalls, stopState);\n}\n\nexport function flowStartParseNewArguments() {\n  if (match(tt.lessThan)) {\n    const snapshot = state.snapshot();\n    flowParseTypeParameterInstantiation();\n    if (state.error) {\n      state.restoreFromSnapshot(snapshot);\n    }\n  }\n}\n\n// interfaces\nexport function flowTryParseStatement() {\n  if (match(tt.name) && state.contextualKeyword === ContextualKeyword._interface) {\n    const oldIsType = pushTypeContext(0);\n    next();\n    flowParseInterface();\n    popTypeContext(oldIsType);\n    return true;\n  } else {\n    return false;\n  }\n}\n\n// declares, interfaces and type aliases\nexport function flowParseIdentifierStatement(contextualKeyword) {\n  if (contextualKeyword === ContextualKeyword._declare) {\n    if (\n      match(tt._class) ||\n      match(tt.name) ||\n      match(tt._function) ||\n      match(tt._var) ||\n      match(tt._export)\n    ) {\n      const oldIsType = pushTypeContext(1);\n      flowParseDeclare();\n      popTypeContext(oldIsType);\n    }\n  } else if (match(tt.name)) {\n    if (contextualKeyword === ContextualKeyword._interface) {\n      const oldIsType = pushTypeContext(1);\n      flowParseInterface();\n      popTypeContext(oldIsType);\n    } else if (contextualKeyword === ContextualKeyword._type) {\n      const oldIsType = pushTypeContext(1);\n      flowParseTypeAlias();\n      popTypeContext(oldIsType);\n    } else if (contextualKeyword === ContextualKeyword._opaque) {\n      const oldIsType = pushTypeContext(1);\n      flowParseOpaqueType(false);\n      popTypeContext(oldIsType);\n    }\n  }\n  semicolon();\n}\n\n// export type\nexport function flowShouldParseExportDeclaration() {\n  return (\n    isContextual(ContextualKeyword._type) ||\n    isContextual(ContextualKeyword._interface) ||\n    isContextual(ContextualKeyword._opaque)\n  );\n}\n\nexport function flowShouldDisallowExportDefaultSpecifier() {\n  return (\n    match(tt.name) &&\n    (state.contextualKeyword === ContextualKeyword._type ||\n      state.contextualKeyword === ContextualKeyword._interface ||\n      state.contextualKeyword === ContextualKeyword._opaque)\n  );\n}\n\nexport function flowParseExportDeclaration() {\n  if (isContextual(ContextualKeyword._type)) {\n    const oldIsType = pushTypeContext(1);\n    next();\n\n    if (match(tt.braceL)) {\n      // export type { foo, bar };\n      parseExportSpecifiers();\n      parseExportFrom();\n    } else {\n      // export type Foo = Bar;\n      flowParseTypeAlias();\n    }\n    popTypeContext(oldIsType);\n  } else if (isContextual(ContextualKeyword._opaque)) {\n    const oldIsType = pushTypeContext(1);\n    next();\n    // export opaque type Foo = Bar;\n    flowParseOpaqueType(false);\n    popTypeContext(oldIsType);\n  } else if (isContextual(ContextualKeyword._interface)) {\n    const oldIsType = pushTypeContext(1);\n    next();\n    flowParseInterface();\n    popTypeContext(oldIsType);\n  } else {\n    parseStatement(true);\n  }\n}\n\nexport function flowShouldParseExportStar() {\n  return match(tt.star) || (isContextual(ContextualKeyword._type) && lookaheadType() === tt.star);\n}\n\nexport function flowParseExportStar() {\n  if (eatContextual(ContextualKeyword._type)) {\n    const oldIsType = pushTypeContext(2);\n    baseParseExportStar();\n    popTypeContext(oldIsType);\n  } else {\n    baseParseExportStar();\n  }\n}\n\n// parse a the super class type parameters and implements\nexport function flowAfterParseClassSuper(hasSuper) {\n  if (hasSuper && match(tt.lessThan)) {\n    flowParseTypeParameterInstantiation();\n  }\n  if (isContextual(ContextualKeyword._implements)) {\n    const oldIsType = pushTypeContext(0);\n    next();\n    state.tokens[state.tokens.length - 1].type = tt._implements;\n    do {\n      flowParseRestrictedIdentifier();\n      if (match(tt.lessThan)) {\n        flowParseTypeParameterInstantiation();\n      }\n    } while (eat(tt.comma));\n    popTypeContext(oldIsType);\n  }\n}\n\n// parse type parameters for object method shorthand\nexport function flowStartParseObjPropValue() {\n  // method shorthand\n  if (match(tt.lessThan)) {\n    flowParseTypeParameterDeclaration();\n    if (!match(tt.parenL)) unexpected();\n  }\n}\n\nexport function flowParseAssignableListItemTypes() {\n  const oldIsType = pushTypeContext(0);\n  eat(tt.question);\n  if (match(tt.colon)) {\n    flowParseTypeAnnotation();\n  }\n  popTypeContext(oldIsType);\n}\n\n// parse typeof and type imports\nexport function flowStartParseImportSpecifiers() {\n  if (match(tt._typeof) || isContextual(ContextualKeyword._type)) {\n    const lh = lookaheadTypeAndKeyword();\n    if (isMaybeDefaultImport(lh) || lh.type === tt.braceL || lh.type === tt.star) {\n      next();\n    }\n  }\n}\n\n// parse import-type/typeof shorthand\nexport function flowParseImportSpecifier() {\n  const isTypeKeyword =\n    state.contextualKeyword === ContextualKeyword._type || state.type === tt._typeof;\n  if (isTypeKeyword) {\n    next();\n  } else {\n    parseIdentifier();\n  }\n\n  if (isContextual(ContextualKeyword._as) && !isLookaheadContextual(ContextualKeyword._as)) {\n    parseIdentifier();\n    if (isTypeKeyword && !match(tt.name) && !(state.type & TokenType.IS_KEYWORD)) {\n      // `import {type as ,` or `import {type as }`\n    } else {\n      // `import {type as foo`\n      parseIdentifier();\n    }\n  } else if (isTypeKeyword && (match(tt.name) || !!(state.type & TokenType.IS_KEYWORD))) {\n    // `import {type foo`\n    parseIdentifier();\n    if (eatContextual(ContextualKeyword._as)) {\n      parseIdentifier();\n    }\n  }\n}\n\n// parse function type parameters - function foo<T>() {}\nexport function flowStartParseFunctionParams() {\n  // Originally this checked if the method is a getter/setter, but if it was, we'd crash soon\n  // anyway, so don't try to propagate that information.\n  if (match(tt.lessThan)) {\n    const oldIsType = pushTypeContext(0);\n    flowParseTypeParameterDeclaration();\n    popTypeContext(oldIsType);\n  }\n}\n\n// parse flow type annotations on variable declarator heads - let foo: string = bar\nexport function flowAfterParseVarHead() {\n  if (match(tt.colon)) {\n    flowParseTypeAnnotation();\n  }\n}\n\n// parse the return type of an async arrow function - let foo = (async (): number => {});\nexport function flowStartParseAsyncArrowFromCallExpression() {\n  if (match(tt.colon)) {\n    const oldNoAnonFunctionType = state.noAnonFunctionType;\n    state.noAnonFunctionType = true;\n    flowParseTypeAnnotation();\n    state.noAnonFunctionType = oldNoAnonFunctionType;\n  }\n}\n\n// We need to support type parameter declarations for arrow functions. This\n// is tricky. There are three situations we need to handle\n//\n// 1. This is either JSX or an arrow function. We'll try JSX first. If that\n//    fails, we'll try an arrow function. If that fails, we'll throw the JSX\n//    error.\n// 2. This is an arrow function. We'll parse the type parameter declaration,\n//    parse the rest, make sure the rest is an arrow function, and go from\n//    there\n// 3. This is neither. Just call the super method\nexport function flowParseMaybeAssign(noIn, isWithinParens) {\n  if (match(tt.lessThan)) {\n    const snapshot = state.snapshot();\n    let wasArrow = baseParseMaybeAssign(noIn, isWithinParens);\n    if (state.error) {\n      state.restoreFromSnapshot(snapshot);\n      state.type = tt.typeParameterStart;\n    } else {\n      return wasArrow;\n    }\n\n    const oldIsType = pushTypeContext(0);\n    flowParseTypeParameterDeclaration();\n    popTypeContext(oldIsType);\n    wasArrow = baseParseMaybeAssign(noIn, isWithinParens);\n    if (wasArrow) {\n      return true;\n    }\n    unexpected();\n  }\n\n  return baseParseMaybeAssign(noIn, isWithinParens);\n}\n\n// handle return types for arrow functions\nexport function flowParseArrow() {\n  if (match(tt.colon)) {\n    const oldIsType = pushTypeContext(0);\n    const snapshot = state.snapshot();\n\n    const oldNoAnonFunctionType = state.noAnonFunctionType;\n    state.noAnonFunctionType = true;\n    flowParseTypeAndPredicateInitialiser();\n    state.noAnonFunctionType = oldNoAnonFunctionType;\n\n    if (canInsertSemicolon()) unexpected();\n    if (!match(tt.arrow)) unexpected();\n\n    if (state.error) {\n      state.restoreFromSnapshot(snapshot);\n    }\n    popTypeContext(oldIsType);\n  }\n  return eat(tt.arrow);\n}\n\nexport function flowParseSubscripts(startTokenIndex, noCalls = false) {\n  if (\n    state.tokens[state.tokens.length - 1].contextualKeyword === ContextualKeyword._async &&\n    match(tt.lessThan)\n  ) {\n    const snapshot = state.snapshot();\n    const wasArrow = parseAsyncArrowWithTypeParameters();\n    if (wasArrow && !state.error) {\n      return;\n    }\n    state.restoreFromSnapshot(snapshot);\n  }\n\n  baseParseSubscripts(startTokenIndex, noCalls);\n}\n\n// Returns true if there was an arrow function here.\nfunction parseAsyncArrowWithTypeParameters() {\n  state.scopeDepth++;\n  const startTokenIndex = state.tokens.length;\n  parseFunctionParams();\n  if (!parseArrow()) {\n    return false;\n  }\n  parseArrowExpression(startTokenIndex);\n  return true;\n}\n","import {\n  eat,\n  finishToken,\n  getTokenFromCode,\n  IdentifierRole,\n  match,\n  next,\n  skipSpace,\n  Token,\n} from \"../../tokenizer/index\";\nimport {TokenType as tt} from \"../../tokenizer/types\";\nimport {input, isTypeScriptEnabled, state} from \"../../traverser/base\";\nimport {parseExpression, parseMaybeAssign} from \"../../traverser/expression\";\nimport {expect, unexpected} from \"../../traverser/util\";\nimport {charCodes} from \"../../util/charcodes\";\nimport {IS_IDENTIFIER_CHAR, IS_IDENTIFIER_START} from \"../../util/identifier\";\nimport {tsTryParseJSXTypeArgument} from \"../typescript\";\n\n// Reads inline JSX contents token.\nfunction jsxReadToken() {\n  for (;;) {\n    if (state.pos >= input.length) {\n      unexpected(\"Unterminated JSX contents\");\n      return;\n    }\n\n    const ch = input.charCodeAt(state.pos);\n\n    switch (ch) {\n      case charCodes.lessThan:\n      case charCodes.leftCurlyBrace:\n        if (state.pos === state.start) {\n          if (ch === charCodes.lessThan) {\n            state.pos++;\n            finishToken(tt.jsxTagStart);\n            return;\n          }\n          getTokenFromCode(ch);\n          return;\n        }\n        finishToken(tt.jsxText);\n        return;\n\n      default:\n        state.pos++;\n    }\n  }\n}\n\nfunction jsxReadString(quote) {\n  state.pos++;\n  for (;;) {\n    if (state.pos >= input.length) {\n      unexpected(\"Unterminated string constant\");\n      return;\n    }\n\n    const ch = input.charCodeAt(state.pos);\n    if (ch === quote) {\n      state.pos++;\n      break;\n    }\n    state.pos++;\n  }\n  finishToken(tt.string);\n}\n\n// Read a JSX identifier (valid tag or attribute name).\n//\n// Optimized version since JSX identifiers can't contain\n// escape characters and so can be read as single slice.\n// Also assumes that first character was already checked\n// by isIdentifierStart in readToken.\n\nfunction jsxReadWord() {\n  let ch;\n  do {\n    if (state.pos > input.length) {\n      unexpected(\"Unexpectedly reached the end of input.\");\n      return;\n    }\n    ch = input.charCodeAt(++state.pos);\n  } while (IS_IDENTIFIER_CHAR[ch] || ch === charCodes.dash);\n  finishToken(tt.jsxName);\n}\n\n// Parse next token as JSX identifier\nfunction jsxParseIdentifier() {\n  nextJSXTagToken();\n}\n\n// Parse namespaced identifier.\nfunction jsxParseNamespacedName(identifierRole) {\n  jsxParseIdentifier();\n  if (!eat(tt.colon)) {\n    // Plain identifier, so this is an access.\n    state.tokens[state.tokens.length - 1].identifierRole = identifierRole;\n    return;\n  }\n  // Process the second half of the namespaced name.\n  jsxParseIdentifier();\n}\n\n// Parses element name in any form - namespaced, member\n// or single identifier.\nfunction jsxParseElementName() {\n  jsxParseNamespacedName(IdentifierRole.Access);\n  while (match(tt.dot)) {\n    nextJSXTagToken();\n    jsxParseIdentifier();\n  }\n}\n\n// Parses any type of JSX attribute value.\nfunction jsxParseAttributeValue() {\n  switch (state.type) {\n    case tt.braceL:\n      next();\n      jsxParseExpressionContainer();\n      nextJSXTagToken();\n      return;\n\n    case tt.jsxTagStart:\n      jsxParseElement();\n      nextJSXTagToken();\n      return;\n\n    case tt.string:\n      nextJSXTagToken();\n      return;\n\n    default:\n      unexpected(\"JSX value should be either an expression or a quoted JSX text\");\n  }\n}\n\nfunction jsxParseEmptyExpression() {\n  // Do nothing.\n}\n\n// Parse JSX spread child, after already processing the {\n// Does not parse the closing }\nfunction jsxParseSpreadChild() {\n  expect(tt.ellipsis);\n  parseExpression();\n}\n\n// Parses JSX expression enclosed into curly brackets, after already processing the {\n// Does not parse the closing }\nfunction jsxParseExpressionContainer() {\n  if (match(tt.braceR)) {\n    jsxParseEmptyExpression();\n  } else {\n    parseExpression();\n  }\n}\n\n// Parses following JSX attribute name-value pair.\nfunction jsxParseAttribute() {\n  if (eat(tt.braceL)) {\n    expect(tt.ellipsis);\n    parseMaybeAssign();\n    // }\n    nextJSXTagToken();\n    return;\n  }\n  jsxParseNamespacedName(IdentifierRole.ObjectKey);\n  if (match(tt.eq)) {\n    nextJSXTagToken();\n    jsxParseAttributeValue();\n  }\n}\n\n// Parses JSX opening tag starting after \"<\".\n// Returns true if the tag was self-closing.\n// Does not parse the last token.\nfunction jsxParseOpeningElement() {\n  if (match(tt.jsxTagEnd)) {\n    // This is an open-fragment.\n    return false;\n  }\n  jsxParseElementName();\n  if (isTypeScriptEnabled) {\n    tsTryParseJSXTypeArgument();\n  }\n  while (!match(tt.slash) && !match(tt.jsxTagEnd) && !state.error) {\n    jsxParseAttribute();\n  }\n  const isSelfClosing = match(tt.slash);\n  if (isSelfClosing) {\n    // /\n    nextJSXTagToken();\n  }\n  return isSelfClosing;\n}\n\n// Parses JSX closing tag starting after \"</\".\n// Does not parse the last token.\nfunction jsxParseClosingElement() {\n  if (match(tt.jsxTagEnd)) {\n    // Fragment syntax, so we immediately have a tag end.\n    return;\n  }\n  jsxParseElementName();\n}\n\n// Parses entire JSX element, including its opening tag\n// (starting after \"<\"), attributes, contents and closing tag.\n// Does not parse the last token.\nfunction jsxParseElementAt() {\n  const isSelfClosing = jsxParseOpeningElement();\n  if (!isSelfClosing) {\n    nextJSXExprToken();\n    while (true) {\n      switch (state.type) {\n        case tt.jsxTagStart:\n          nextJSXTagToken();\n          if (match(tt.slash)) {\n            nextJSXTagToken();\n            jsxParseClosingElement();\n            return;\n          }\n          jsxParseElementAt();\n          nextJSXExprToken();\n          break;\n\n        case tt.jsxText:\n          nextJSXExprToken();\n          break;\n\n        case tt.braceL:\n          next();\n          if (match(tt.ellipsis)) {\n            jsxParseSpreadChild();\n            nextJSXExprToken();\n          } else {\n            jsxParseExpressionContainer();\n            nextJSXExprToken();\n          }\n\n          break;\n\n        // istanbul ignore next - should never happen\n        default:\n          unexpected();\n          return;\n      }\n    }\n  }\n}\n\n// Parses entire JSX element from current position.\n// Does not parse the last token.\nexport function jsxParseElement() {\n  nextJSXTagToken();\n  jsxParseElementAt();\n}\n\n// ==================================\n// Overrides\n// ==================================\n\nexport function nextJSXTagToken() {\n  state.tokens.push(new Token());\n  skipSpace();\n  state.start = state.pos;\n  const code = input.charCodeAt(state.pos);\n\n  if (IS_IDENTIFIER_START[code]) {\n    jsxReadWord();\n  } else if (code === charCodes.quotationMark || code === charCodes.apostrophe) {\n    jsxReadString(code);\n  } else {\n    // The following tokens are just one character each.\n    ++state.pos;\n    switch (code) {\n      case charCodes.greaterThan:\n        finishToken(tt.jsxTagEnd);\n        break;\n      case charCodes.lessThan:\n        finishToken(tt.jsxTagStart);\n        break;\n      case charCodes.slash:\n        finishToken(tt.slash);\n        break;\n      case charCodes.equalsTo:\n        finishToken(tt.eq);\n        break;\n      case charCodes.leftCurlyBrace:\n        finishToken(tt.braceL);\n        break;\n      case charCodes.dot:\n        finishToken(tt.dot);\n        break;\n      case charCodes.colon:\n        finishToken(tt.colon);\n        break;\n      default:\n        unexpected();\n    }\n  }\n}\n\nfunction nextJSXExprToken() {\n  state.tokens.push(new Token());\n  state.start = state.pos;\n  jsxReadToken();\n}\n","/* eslint max-len: 0 */\n\n// A recursive descent parser operates by defining functions for all\n// syntactic elements, and recursively calling those, each function\n// advancing the input stream and returning an AST node. Precedence\n// of constructs (for example, the fact that `!x[1]` means `!(x[1])`\n// instead of `(!x)[1]` is handled by the fact that the parser\n// function that parses unary prefix operators is called first, and\n// in turn calls the function that parses `[]` subscripts — that\n// way, it'll receive the node for `x[1]` already parsed, and wraps\n// *that* in the unary operator node.\n//\n// Acorn uses an [operator precedence parser][opp] to handle binary\n// operator precedence, because it is much more compact than using\n// the technique outlined above, which uses different, nesting\n// functions to specify precedence, for all of the ten binary\n// precedence levels that JavaScript defines.\n//\n// [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser\n\nimport {\n  flowParseArrow,\n  flowParseFunctionBodyAndFinish,\n  flowParseMaybeAssign,\n  flowParseSubscript,\n  flowParseSubscripts,\n  flowParseVariance,\n  flowStartParseAsyncArrowFromCallExpression,\n  flowStartParseNewArguments,\n  flowStartParseObjPropValue,\n} from \"../plugins/flow\";\nimport {jsxParseElement} from \"../plugins/jsx/index\";\nimport {typedParseConditional, typedParseParenItem} from \"../plugins/types\";\nimport {\n  tsParseArrow,\n  tsParseFunctionBodyAndFinish,\n  tsParseMaybeAssign,\n  tsParseSubscript,\n  tsParseType,\n  tsParseTypeAssertion,\n  tsStartParseAsyncArrowFromCallExpression,\n  tsStartParseNewArguments,\n  tsStartParseObjPropValue,\n} from \"../plugins/typescript\";\nimport {\n  eat,\n  IdentifierRole,\n  lookaheadType,\n  match,\n  next,\n  nextTemplateToken,\n  popTypeContext,\n  pushTypeContext,\n  retokenizeSlashAsRegex,\n} from \"../tokenizer/index\";\nimport {ContextualKeyword} from \"../tokenizer/keywords\";\nimport {Scope} from \"../tokenizer/state\";\nimport {TokenType, TokenType as tt} from \"../tokenizer/types\";\nimport {getNextContextId, isFlowEnabled, isJSXEnabled, isTypeScriptEnabled, state} from \"./base\";\nimport {\n  markPriorBindingIdentifier,\n  parseBindingIdentifier,\n  parseMaybeDefault,\n  parseRest,\n  parseSpread,\n} from \"./lval\";\nimport {\n  parseBlock,\n  parseClass,\n  parseDecorators,\n  parseFunction,\n  parseFunctionParams,\n} from \"./statement\";\nimport {\n  canInsertSemicolon,\n  eatContextual,\n  expect,\n  hasPrecedingLineBreak,\n  isContextual,\n  unexpected,\n} from \"./util\";\n\nexport class StopState {\n  \n  constructor(stop) {\n    this.stop = stop;\n  }\n}\n\n// ### Expression parsing\n\n// These nest, from the most general expression type at the top to\n// 'atomic', nondivisible expression types at the bottom. Most of\n// the functions will simply let the function (s) below them parse,\n// and, *if* the syntactic construct they handle is present, wrap\n// the AST node that the inner parser gave them in another node.\nexport function parseExpression(noIn = false) {\n  parseMaybeAssign(noIn);\n  if (match(tt.comma)) {\n    while (eat(tt.comma)) {\n      parseMaybeAssign(noIn);\n    }\n  }\n}\n\n/**\n * noIn is used when parsing a for loop so that we don't interpret a following \"in\" as the binary\n * operatior.\n * isWithinParens is used to indicate that we're parsing something that might be a comma expression\n * or might be an arrow function or might be a Flow type assertion (which requires explicit parens).\n * In these cases, we should allow : and ?: after the initial \"left\" part.\n */\nexport function parseMaybeAssign(noIn = false, isWithinParens = false) {\n  if (isTypeScriptEnabled) {\n    return tsParseMaybeAssign(noIn, isWithinParens);\n  } else if (isFlowEnabled) {\n    return flowParseMaybeAssign(noIn, isWithinParens);\n  } else {\n    return baseParseMaybeAssign(noIn, isWithinParens);\n  }\n}\n\n// Parse an assignment expression. This includes applications of\n// operators like `+=`.\n// Returns true if the expression was an arrow function.\nexport function baseParseMaybeAssign(noIn, isWithinParens) {\n  if (match(tt._yield)) {\n    parseYield();\n    return false;\n  }\n\n  if (match(tt.parenL) || match(tt.name) || match(tt._yield)) {\n    state.potentialArrowAt = state.start;\n  }\n\n  const wasArrow = parseMaybeConditional(noIn);\n  if (isWithinParens) {\n    parseParenItem();\n  }\n  if (state.type & TokenType.IS_ASSIGN) {\n    next();\n    parseMaybeAssign(noIn);\n    return false;\n  }\n  return wasArrow;\n}\n\n// Parse a ternary conditional (`?:`) operator.\n// Returns true if the expression was an arrow function.\nfunction parseMaybeConditional(noIn) {\n  const wasArrow = parseExprOps(noIn);\n  if (wasArrow) {\n    return true;\n  }\n  parseConditional(noIn);\n  return false;\n}\n\nfunction parseConditional(noIn) {\n  if (isTypeScriptEnabled || isFlowEnabled) {\n    typedParseConditional(noIn);\n  } else {\n    baseParseConditional(noIn);\n  }\n}\n\nexport function baseParseConditional(noIn) {\n  if (eat(tt.question)) {\n    parseMaybeAssign();\n    expect(tt.colon);\n    parseMaybeAssign(noIn);\n  }\n}\n\n// Start the precedence parser.\n// Returns true if this was an arrow function\nfunction parseExprOps(noIn) {\n  const startTokenIndex = state.tokens.length;\n  const wasArrow = parseMaybeUnary();\n  if (wasArrow) {\n    return true;\n  }\n  parseExprOp(startTokenIndex, -1, noIn);\n  return false;\n}\n\n// Parse binary operators with the operator precedence parsing\n// algorithm. `left` is the left-hand side of the operator.\n// `minPrec` provides context that allows the function to stop and\n// defer further parser to one of its callers when it encounters an\n// operator that has a lower precedence than the set it is parsing.\nfunction parseExprOp(startTokenIndex, minPrec, noIn) {\n  if (\n    isTypeScriptEnabled &&\n    (tt._in & TokenType.PRECEDENCE_MASK) > minPrec &&\n    !hasPrecedingLineBreak() &&\n    eatContextual(ContextualKeyword._as)\n  ) {\n    state.tokens[state.tokens.length - 1].type = tt._as;\n    const oldIsType = pushTypeContext(1);\n    tsParseType();\n    popTypeContext(oldIsType);\n    parseExprOp(startTokenIndex, minPrec, noIn);\n    return;\n  }\n\n  const prec = state.type & TokenType.PRECEDENCE_MASK;\n  if (prec > 0 && (!noIn || !match(tt._in))) {\n    if (prec > minPrec) {\n      const op = state.type;\n      next();\n      if (op === tt.nullishCoalescing) {\n        state.tokens[state.tokens.length - 1].nullishStartIndex = startTokenIndex;\n      }\n\n      const rhsStartTokenIndex = state.tokens.length;\n      parseMaybeUnary();\n      // Extend the right operand of this operator if possible.\n      parseExprOp(rhsStartTokenIndex, op & TokenType.IS_RIGHT_ASSOCIATIVE ? prec - 1 : prec, noIn);\n      if (op === tt.nullishCoalescing) {\n        state.tokens[startTokenIndex].numNullishCoalesceStarts++;\n        state.tokens[state.tokens.length - 1].numNullishCoalesceEnds++;\n      }\n      // Continue with any future operator holding this expression as the left operand.\n      parseExprOp(startTokenIndex, minPrec, noIn);\n    }\n  }\n}\n\n// Parse unary operators, both prefix and postfix.\n// Returns true if this was an arrow function.\nexport function parseMaybeUnary() {\n  if (isTypeScriptEnabled && !isJSXEnabled && eat(tt.lessThan)) {\n    tsParseTypeAssertion();\n    return false;\n  }\n\n  if (state.type & TokenType.IS_PREFIX) {\n    next();\n    parseMaybeUnary();\n    return false;\n  }\n\n  const wasArrow = parseExprSubscripts();\n  if (wasArrow) {\n    return true;\n  }\n  while (state.type & TokenType.IS_POSTFIX && !canInsertSemicolon()) {\n    // The tokenizer calls everything a preincrement, so make it a postincrement when\n    // we see it in that context.\n    if (state.type === tt.preIncDec) {\n      state.type = tt.postIncDec;\n    }\n    next();\n  }\n  return false;\n}\n\n// Parse call, dot, and `[]`-subscript expressions.\n// Returns true if this was an arrow function.\nexport function parseExprSubscripts() {\n  const startTokenIndex = state.tokens.length;\n  const wasArrow = parseExprAtom();\n  if (wasArrow) {\n    return true;\n  }\n  parseSubscripts(startTokenIndex);\n  // If there was any optional chain operation, the start token would be marked\n  // as such, so also mark the end now.\n  if (state.tokens.length > startTokenIndex && state.tokens[startTokenIndex].isOptionalChainStart) {\n    state.tokens[state.tokens.length - 1].isOptionalChainEnd = true;\n  }\n  return false;\n}\n\nfunction parseSubscripts(startTokenIndex, noCalls = false) {\n  if (isFlowEnabled) {\n    flowParseSubscripts(startTokenIndex, noCalls);\n  } else {\n    baseParseSubscripts(startTokenIndex, noCalls);\n  }\n}\n\nexport function baseParseSubscripts(startTokenIndex, noCalls = false) {\n  const stopState = new StopState(false);\n  do {\n    parseSubscript(startTokenIndex, noCalls, stopState);\n  } while (!stopState.stop && !state.error);\n}\n\nfunction parseSubscript(startTokenIndex, noCalls, stopState) {\n  if (isTypeScriptEnabled) {\n    tsParseSubscript(startTokenIndex, noCalls, stopState);\n  } else if (isFlowEnabled) {\n    flowParseSubscript(startTokenIndex, noCalls, stopState);\n  } else {\n    baseParseSubscript(startTokenIndex, noCalls, stopState);\n  }\n}\n\n/** Set 'state.stop = true' to indicate that we should stop parsing subscripts. */\nexport function baseParseSubscript(\n  startTokenIndex,\n  noCalls,\n  stopState,\n) {\n  if (!noCalls && eat(tt.doubleColon)) {\n    parseNoCallExpr();\n    stopState.stop = true;\n    // Propagate startTokenIndex so that `a::b?.()` will keep `a` as the first token. We may want\n    // to revisit this in the future when fully supporting bind syntax.\n    parseSubscripts(startTokenIndex, noCalls);\n  } else if (match(tt.questionDot)) {\n    state.tokens[startTokenIndex].isOptionalChainStart = true;\n    if (noCalls && lookaheadType() === tt.parenL) {\n      stopState.stop = true;\n      return;\n    }\n    next();\n    state.tokens[state.tokens.length - 1].subscriptStartIndex = startTokenIndex;\n\n    if (eat(tt.bracketL)) {\n      parseExpression();\n      expect(tt.bracketR);\n    } else if (eat(tt.parenL)) {\n      parseCallExpressionArguments();\n    } else {\n      parseIdentifier();\n    }\n  } else if (eat(tt.dot)) {\n    state.tokens[state.tokens.length - 1].subscriptStartIndex = startTokenIndex;\n    parseMaybePrivateName();\n  } else if (eat(tt.bracketL)) {\n    state.tokens[state.tokens.length - 1].subscriptStartIndex = startTokenIndex;\n    parseExpression();\n    expect(tt.bracketR);\n  } else if (!noCalls && match(tt.parenL)) {\n    if (atPossibleAsync()) {\n      // We see \"async\", but it's possible it's a usage of the name \"async\". Parse as if it's a\n      // function call, and if we see an arrow later, backtrack and re-parse as a parameter list.\n      const snapshot = state.snapshot();\n      const asyncStartTokenIndex = state.tokens.length;\n      next();\n      state.tokens[state.tokens.length - 1].subscriptStartIndex = startTokenIndex;\n\n      const callContextId = getNextContextId();\n\n      state.tokens[state.tokens.length - 1].contextId = callContextId;\n      parseCallExpressionArguments();\n      state.tokens[state.tokens.length - 1].contextId = callContextId;\n\n      if (shouldParseAsyncArrow()) {\n        // We hit an arrow, so backtrack and start again parsing function parameters.\n        state.restoreFromSnapshot(snapshot);\n        stopState.stop = true;\n        state.scopeDepth++;\n\n        parseFunctionParams();\n        parseAsyncArrowFromCallExpression(asyncStartTokenIndex);\n      }\n    } else {\n      next();\n      state.tokens[state.tokens.length - 1].subscriptStartIndex = startTokenIndex;\n      const callContextId = getNextContextId();\n      state.tokens[state.tokens.length - 1].contextId = callContextId;\n      parseCallExpressionArguments();\n      state.tokens[state.tokens.length - 1].contextId = callContextId;\n    }\n  } else if (match(tt.backQuote)) {\n    // Tagged template expression.\n    parseTemplate();\n  } else {\n    stopState.stop = true;\n  }\n}\n\nexport function atPossibleAsync() {\n  // This was made less strict than the original version to avoid passing around nodes, but it\n  // should be safe to have rare false positives here.\n  return (\n    state.tokens[state.tokens.length - 1].contextualKeyword === ContextualKeyword._async &&\n    !canInsertSemicolon()\n  );\n}\n\nexport function parseCallExpressionArguments() {\n  let first = true;\n  while (!eat(tt.parenR) && !state.error) {\n    if (first) {\n      first = false;\n    } else {\n      expect(tt.comma);\n      if (eat(tt.parenR)) {\n        break;\n      }\n    }\n\n    parseExprListItem(false);\n  }\n}\n\nfunction shouldParseAsyncArrow() {\n  return match(tt.colon) || match(tt.arrow);\n}\n\nfunction parseAsyncArrowFromCallExpression(startTokenIndex) {\n  if (isTypeScriptEnabled) {\n    tsStartParseAsyncArrowFromCallExpression();\n  } else if (isFlowEnabled) {\n    flowStartParseAsyncArrowFromCallExpression();\n  }\n  expect(tt.arrow);\n  parseArrowExpression(startTokenIndex);\n}\n\n// Parse a no-call expression (like argument of `new` or `::` operators).\n\nfunction parseNoCallExpr() {\n  const startTokenIndex = state.tokens.length;\n  parseExprAtom();\n  parseSubscripts(startTokenIndex, true);\n}\n\n// Parse an atomic expression — either a single token that is an\n// expression, an expression started by a keyword like `function` or\n// `new`, or an expression wrapped in punctuation like `()`, `[]`,\n// or `{}`.\n// Returns true if the parsed expression was an arrow function.\nexport function parseExprAtom() {\n  if (eat(tt.modulo)) {\n    // V8 intrinsic expression. Just parse the identifier, and the function invocation is parsed\n    // naturally.\n    parseIdentifier();\n    return false;\n  }\n\n  if (match(tt.jsxText)) {\n    parseLiteral();\n    return false;\n  } else if (match(tt.lessThan) && isJSXEnabled) {\n    state.type = tt.jsxTagStart;\n    jsxParseElement();\n    next();\n    return false;\n  }\n\n  const canBeArrow = state.potentialArrowAt === state.start;\n  switch (state.type) {\n    case tt.slash:\n    case tt.assign:\n      retokenizeSlashAsRegex();\n    // Fall through.\n\n    case tt._super:\n    case tt._this:\n    case tt.regexp:\n    case tt.num:\n    case tt.bigint:\n    case tt.string:\n    case tt._null:\n    case tt._true:\n    case tt._false:\n      next();\n      return false;\n\n    case tt._import:\n      next();\n      if (match(tt.dot)) {\n        // import.meta\n        state.tokens[state.tokens.length - 1].type = tt.name;\n        next();\n        parseIdentifier();\n      }\n      return false;\n\n    case tt.name: {\n      const startTokenIndex = state.tokens.length;\n      const functionStart = state.start;\n      const contextualKeyword = state.contextualKeyword;\n      parseIdentifier();\n      if (contextualKeyword === ContextualKeyword._await) {\n        parseAwait();\n        return false;\n      } else if (\n        contextualKeyword === ContextualKeyword._async &&\n        match(tt._function) &&\n        !canInsertSemicolon()\n      ) {\n        next();\n        parseFunction(functionStart, false);\n        return false;\n      } else if (\n        canBeArrow &&\n        !canInsertSemicolon() &&\n        contextualKeyword === ContextualKeyword._async &&\n        match(tt.name)\n      ) {\n        state.scopeDepth++;\n        parseBindingIdentifier(false);\n        expect(tt.arrow);\n        // let foo = async bar => {};\n        parseArrowExpression(startTokenIndex);\n        return true;\n      }\n\n      if (canBeArrow && !canInsertSemicolon() && match(tt.arrow)) {\n        state.scopeDepth++;\n        markPriorBindingIdentifier(false);\n        expect(tt.arrow);\n        parseArrowExpression(startTokenIndex);\n        return true;\n      }\n\n      state.tokens[state.tokens.length - 1].identifierRole = IdentifierRole.Access;\n      return false;\n    }\n\n    case tt._do: {\n      next();\n      parseBlock(false);\n      return false;\n    }\n\n    case tt.parenL: {\n      const wasArrow = parseParenAndDistinguishExpression(canBeArrow);\n      return wasArrow;\n    }\n\n    case tt.bracketL:\n      next();\n      parseExprList(tt.bracketR, true);\n      return false;\n\n    case tt.braceL:\n      parseObj(false, false);\n      return false;\n\n    case tt._function:\n      parseFunctionExpression();\n      return false;\n\n    case tt.at:\n      parseDecorators();\n    // Fall through.\n\n    case tt._class:\n      parseClass(false);\n      return false;\n\n    case tt._new:\n      parseNew();\n      return false;\n\n    case tt.backQuote:\n      parseTemplate();\n      return false;\n\n    case tt.doubleColon: {\n      next();\n      parseNoCallExpr();\n      return false;\n    }\n\n    case tt.hash: {\n      // Smart pipeline topic reference.\n      next();\n      return false;\n    }\n\n    default:\n      unexpected();\n      return false;\n  }\n}\n\nfunction parseMaybePrivateName() {\n  eat(tt.hash);\n  parseIdentifier();\n}\n\nfunction parseFunctionExpression() {\n  const functionStart = state.start;\n  parseIdentifier();\n  if (eat(tt.dot)) {\n    // function.sent\n    parseIdentifier();\n  }\n  parseFunction(functionStart, false);\n}\n\nexport function parseLiteral() {\n  next();\n}\n\nexport function parseParenExpression() {\n  expect(tt.parenL);\n  parseExpression();\n  expect(tt.parenR);\n}\n\n// Returns true if this was an arrow expression.\nfunction parseParenAndDistinguishExpression(canBeArrow) {\n  // Assume this is a normal parenthesized expression, but if we see an arrow, we'll bail and\n  // start over as a parameter list.\n  const snapshot = state.snapshot();\n\n  const startTokenIndex = state.tokens.length;\n  expect(tt.parenL);\n\n  let first = true;\n\n  while (!match(tt.parenR) && !state.error) {\n    if (first) {\n      first = false;\n    } else {\n      expect(tt.comma);\n      if (match(tt.parenR)) {\n        break;\n      }\n    }\n\n    if (match(tt.ellipsis)) {\n      parseRest(false /* isBlockScope */);\n      parseParenItem();\n      break;\n    } else {\n      parseMaybeAssign(false, true);\n    }\n  }\n\n  expect(tt.parenR);\n\n  if (canBeArrow && shouldParseArrow()) {\n    const wasArrow = parseArrow();\n    if (wasArrow) {\n      // It was an arrow function this whole time, so start over and parse it as params so that we\n      // get proper token annotations.\n      state.restoreFromSnapshot(snapshot);\n      state.scopeDepth++;\n      // Don't specify a context ID because arrow functions don't need a context ID.\n      parseFunctionParams();\n      parseArrow();\n      parseArrowExpression(startTokenIndex);\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction shouldParseArrow() {\n  return match(tt.colon) || !canInsertSemicolon();\n}\n\n// Returns whether there was an arrow token.\nexport function parseArrow() {\n  if (isTypeScriptEnabled) {\n    return tsParseArrow();\n  } else if (isFlowEnabled) {\n    return flowParseArrow();\n  } else {\n    return eat(tt.arrow);\n  }\n}\n\nfunction parseParenItem() {\n  if (isTypeScriptEnabled || isFlowEnabled) {\n    typedParseParenItem();\n  }\n}\n\n// New's precedence is slightly tricky. It must allow its argument to\n// be a `[]` or dot subscript expression, but not a call — at least,\n// not without wrapping it in parentheses. Thus, it uses the noCalls\n// argument to parseSubscripts to prevent it from consuming the\n// argument list.\nfunction parseNew() {\n  expect(tt._new);\n  if (eat(tt.dot)) {\n    // new.target\n    parseIdentifier();\n    return;\n  }\n  parseNoCallExpr();\n  eat(tt.questionDot);\n  parseNewArguments();\n}\n\nfunction parseNewArguments() {\n  if (isTypeScriptEnabled) {\n    tsStartParseNewArguments();\n  } else if (isFlowEnabled) {\n    flowStartParseNewArguments();\n  }\n  if (eat(tt.parenL)) {\n    parseExprList(tt.parenR);\n  }\n}\n\nexport function parseTemplate() {\n  // Finish `, read quasi\n  nextTemplateToken();\n  // Finish quasi, read ${\n  nextTemplateToken();\n  while (!match(tt.backQuote) && !state.error) {\n    expect(tt.dollarBraceL);\n    parseExpression();\n    // Finish }, read quasi\n    nextTemplateToken();\n    // Finish quasi, read either ${ or `\n    nextTemplateToken();\n  }\n  next();\n}\n\n// Parse an object literal or binding pattern.\nexport function parseObj(isPattern, isBlockScope) {\n  // Attach a context ID to the object open and close brace and each object key.\n  const contextId = getNextContextId();\n  let first = true;\n\n  next();\n  state.tokens[state.tokens.length - 1].contextId = contextId;\n\n  while (!eat(tt.braceR) && !state.error) {\n    if (first) {\n      first = false;\n    } else {\n      expect(tt.comma);\n      if (eat(tt.braceR)) {\n        break;\n      }\n    }\n\n    let isGenerator = false;\n    if (match(tt.ellipsis)) {\n      const previousIndex = state.tokens.length;\n      parseSpread();\n      if (isPattern) {\n        // Mark role when the only thing being spread over is an identifier.\n        if (state.tokens.length === previousIndex + 2) {\n          markPriorBindingIdentifier(isBlockScope);\n        }\n        if (eat(tt.braceR)) {\n          break;\n        }\n      }\n      continue;\n    }\n\n    if (!isPattern) {\n      isGenerator = eat(tt.star);\n    }\n\n    if (!isPattern && isContextual(ContextualKeyword._async)) {\n      if (isGenerator) unexpected();\n\n      parseIdentifier();\n      if (\n        match(tt.colon) ||\n        match(tt.parenL) ||\n        match(tt.braceR) ||\n        match(tt.eq) ||\n        match(tt.comma)\n      ) {\n        // This is a key called \"async\" rather than an async function.\n      } else {\n        if (match(tt.star)) {\n          next();\n          isGenerator = true;\n        }\n        parsePropertyName(contextId);\n      }\n    } else {\n      parsePropertyName(contextId);\n    }\n\n    parseObjPropValue(isPattern, isBlockScope, contextId);\n  }\n\n  state.tokens[state.tokens.length - 1].contextId = contextId;\n}\n\nfunction isGetterOrSetterMethod(isPattern) {\n  // We go off of the next and don't bother checking if the node key is actually \"get\" or \"set\".\n  // This lets us avoid generating a node, and should only make the validation worse.\n  return (\n    !isPattern &&\n    (match(tt.string) || // get \"string\"() {}\n    match(tt.num) || // get 1() {}\n    match(tt.bracketL) || // get [\"string\"]() {}\n    match(tt.name) || // get foo() {}\n      !!(state.type & TokenType.IS_KEYWORD)) // get debugger() {}\n  );\n}\n\n// Returns true if this was a method.\nfunction parseObjectMethod(isPattern, objectContextId) {\n  // We don't need to worry about modifiers because object methods can't have optional bodies, so\n  // the start will never be used.\n  const functionStart = state.start;\n  if (match(tt.parenL)) {\n    if (isPattern) unexpected();\n    parseMethod(functionStart, /* isConstructor */ false);\n    return true;\n  }\n\n  if (isGetterOrSetterMethod(isPattern)) {\n    parsePropertyName(objectContextId);\n    parseMethod(functionStart, /* isConstructor */ false);\n    return true;\n  }\n  return false;\n}\n\nfunction parseObjectProperty(isPattern, isBlockScope) {\n  if (eat(tt.colon)) {\n    if (isPattern) {\n      parseMaybeDefault(isBlockScope);\n    } else {\n      parseMaybeAssign(false);\n    }\n    return;\n  }\n\n  // Since there's no colon, we assume this is an object shorthand.\n\n  // If we're in a destructuring, we've now discovered that the key was actually an assignee, so\n  // we need to tag it as a declaration with the appropriate scope. Otherwise, we might need to\n  // transform it on access, so mark it as a normal object shorthand.\n  if (isPattern) {\n    state.tokens[state.tokens.length - 1].identifierRole = isBlockScope\n      ? IdentifierRole.ObjectShorthandBlockScopedDeclaration\n      : IdentifierRole.ObjectShorthandFunctionScopedDeclaration;\n  } else {\n    state.tokens[state.tokens.length - 1].identifierRole = IdentifierRole.ObjectShorthand;\n  }\n\n  // Regardless of whether we know this to be a pattern or if we're in an ambiguous context, allow\n  // parsing as if there's a default value.\n  parseMaybeDefault(isBlockScope, true);\n}\n\nfunction parseObjPropValue(\n  isPattern,\n  isBlockScope,\n  objectContextId,\n) {\n  if (isTypeScriptEnabled) {\n    tsStartParseObjPropValue();\n  } else if (isFlowEnabled) {\n    flowStartParseObjPropValue();\n  }\n  const wasMethod = parseObjectMethod(isPattern, objectContextId);\n  if (!wasMethod) {\n    parseObjectProperty(isPattern, isBlockScope);\n  }\n}\n\nexport function parsePropertyName(objectContextId) {\n  if (isFlowEnabled) {\n    flowParseVariance();\n  }\n  if (eat(tt.bracketL)) {\n    state.tokens[state.tokens.length - 1].contextId = objectContextId;\n    parseMaybeAssign();\n    expect(tt.bracketR);\n    state.tokens[state.tokens.length - 1].contextId = objectContextId;\n  } else {\n    if (match(tt.num) || match(tt.string) || match(tt.bigint)) {\n      parseExprAtom();\n    } else {\n      parseMaybePrivateName();\n    }\n\n    state.tokens[state.tokens.length - 1].identifierRole = IdentifierRole.ObjectKey;\n    state.tokens[state.tokens.length - 1].contextId = objectContextId;\n  }\n}\n\n// Parse object or class method.\nexport function parseMethod(functionStart, isConstructor) {\n  const funcContextId = getNextContextId();\n\n  state.scopeDepth++;\n  const startTokenIndex = state.tokens.length;\n  const allowModifiers = isConstructor; // For TypeScript parameter properties\n  parseFunctionParams(allowModifiers, funcContextId);\n  parseFunctionBodyAndFinish(functionStart, funcContextId);\n  const endTokenIndex = state.tokens.length;\n  state.scopes.push(new Scope(startTokenIndex, endTokenIndex, true));\n  state.scopeDepth--;\n}\n\n// Parse arrow function expression.\n// If the parameters are provided, they will be converted to an\n// assignable list.\nexport function parseArrowExpression(startTokenIndex) {\n  parseFunctionBody(true);\n  const endTokenIndex = state.tokens.length;\n  state.scopes.push(new Scope(startTokenIndex, endTokenIndex, true));\n  state.scopeDepth--;\n}\n\nexport function parseFunctionBodyAndFinish(functionStart, funcContextId = 0) {\n  if (isTypeScriptEnabled) {\n    tsParseFunctionBodyAndFinish(functionStart, funcContextId);\n  } else if (isFlowEnabled) {\n    flowParseFunctionBodyAndFinish(funcContextId);\n  } else {\n    parseFunctionBody(false, funcContextId);\n  }\n}\n\nexport function parseFunctionBody(allowExpression, funcContextId = 0) {\n  const isExpression = allowExpression && !match(tt.braceL);\n\n  if (isExpression) {\n    parseMaybeAssign();\n  } else {\n    parseBlock(true /* allowDirectives */, true /* isFunctionScope */, funcContextId);\n  }\n}\n\n// Parses a comma-separated list of expressions, and returns them as\n// an array. `close` is the token type that ends the list, and\n// `allowEmpty` can be turned on to allow subsequent commas with\n// nothing in between them to be parsed as `null` (which is needed\n// for array literals).\n\nfunction parseExprList(close, allowEmpty = false) {\n  let first = true;\n  while (!eat(close) && !state.error) {\n    if (first) {\n      first = false;\n    } else {\n      expect(tt.comma);\n      if (eat(close)) break;\n    }\n    parseExprListItem(allowEmpty);\n  }\n}\n\nfunction parseExprListItem(allowEmpty) {\n  if (allowEmpty && match(tt.comma)) {\n    // Empty item; nothing more to parse for this item.\n  } else if (match(tt.ellipsis)) {\n    parseSpread();\n    parseParenItem();\n  } else if (match(tt.question)) {\n    // Partial function application proposal.\n    next();\n  } else {\n    parseMaybeAssign(false, true);\n  }\n}\n\n// Parse the next token as an identifier.\nexport function parseIdentifier() {\n  next();\n  state.tokens[state.tokens.length - 1].type = tt.name;\n}\n\n// Parses await expression inside async function.\nfunction parseAwait() {\n  parseMaybeUnary();\n}\n\n// Parses yield expression inside generator.\nfunction parseYield() {\n  next();\n  if (!match(tt.semi) && !canInsertSemicolon()) {\n    eat(tt.star);\n    parseMaybeAssign();\n  }\n}\n","import {eat, lookaheadType, match} from \"../tokenizer/index\";\nimport {TokenType as tt} from \"../tokenizer/types\";\nimport {isFlowEnabled, isTypeScriptEnabled, state} from \"../traverser/base\";\nimport {baseParseConditional} from \"../traverser/expression\";\nimport {flowParseTypeAnnotation} from \"./flow\";\nimport {tsParseTypeAnnotation} from \"./typescript\";\n\n/**\n * Common parser code for TypeScript and Flow.\n */\n\n// An apparent conditional expression could actually be an optional parameter in an arrow function.\nexport function typedParseConditional(noIn) {\n  // If we see ?:, this can't possibly be a valid conditional. typedParseParenItem will be called\n  // later to finish off the arrow parameter. We also need to handle bare ? tokens for optional\n  // parameters without type annotations, i.e. ?, and ?) .\n  if (match(tt.question)) {\n    const nextType = lookaheadType();\n    if (nextType === tt.colon || nextType === tt.comma || nextType === tt.parenR) {\n      return;\n    }\n  }\n  baseParseConditional(noIn);\n}\n\n// Note: These \"type casts\" are *not* valid TS expressions.\n// But we parse them here and change them when completing the arrow function.\nexport function typedParseParenItem() {\n  if (eat(tt.question)) {\n    state.tokens[state.tokens.length - 1].isType = true;\n  }\n  if (match(tt.colon)) {\n    if (isTypeScriptEnabled) {\n      tsParseTypeAnnotation();\n    } else if (isFlowEnabled) {\n      flowParseTypeAnnotation();\n    }\n  }\n}\n","/* eslint max-len: 0 */\n\nimport {File} from \"../index\";\nimport {\n  flowAfterParseClassSuper,\n  flowAfterParseVarHead,\n  flowParseExportDeclaration,\n  flowParseExportStar,\n  flowParseIdentifierStatement,\n  flowParseImportSpecifier,\n  flowParseTypeAnnotation,\n  flowParseTypeParameterDeclaration,\n  flowShouldDisallowExportDefaultSpecifier,\n  flowShouldParseExportDeclaration,\n  flowShouldParseExportStar,\n  flowStartParseFunctionParams,\n  flowStartParseImportSpecifiers,\n  flowTryParseStatement,\n} from \"../plugins/flow\";\nimport {\n  tsAfterParseClassSuper,\n  tsAfterParseVarHead,\n  tsIsDeclarationStart,\n  tsParseAccessModifier,\n  tsParseExportDeclaration,\n  tsParseIdentifierStatement,\n  tsParseImportEqualsDeclaration,\n  tsParseMaybeDecoratorArguments,\n  tsStartParseFunctionParams,\n  tsTryParseClassMemberWithIsStatic,\n  tsTryParseExport,\n  tsTryParseExportDefaultExpression,\n  tsTryParseStatementContent,\n  tsTryParseTypeAnnotation,\n  tsTryParseTypeParameters,\n} from \"../plugins/typescript\";\nimport {\n  eat,\n  IdentifierRole,\n  lookaheadType,\n  lookaheadTypeAndKeyword,\n  match,\n  next,\n  popTypeContext,\n  pushTypeContext,\n} from \"../tokenizer\";\nimport {ContextualKeyword} from \"../tokenizer/keywords\";\nimport {Scope} from \"../tokenizer/state\";\nimport { TokenType as tt} from \"../tokenizer/types\";\nimport {getNextContextId, isFlowEnabled, isTypeScriptEnabled, state} from \"./base\";\nimport {\n  parseCallExpressionArguments,\n  parseExprAtom,\n  parseExpression,\n  parseExprSubscripts,\n  parseFunctionBodyAndFinish,\n  parseIdentifier,\n  parseMaybeAssign,\n  parseMethod,\n  parseParenExpression,\n  parsePropertyName,\n} from \"./expression\";\nimport {\n  parseBindingAtom,\n  parseBindingIdentifier,\n  parseBindingList,\n  parseImportedIdentifier,\n} from \"./lval\";\nimport {\n  canInsertSemicolon,\n  eatContextual,\n  expect,\n  expectContextual,\n  isContextual,\n  isLineTerminator,\n  semicolon,\n  unexpected,\n} from \"./util\";\n\nexport function parseTopLevel() {\n  parseBlockBody(tt.eof);\n  state.scopes.push(new Scope(0, state.tokens.length, true));\n  if (state.scopeDepth !== 0) {\n    throw new Error(`Invalid scope depth at end of file: ${state.scopeDepth}`);\n  }\n  return new File(state.tokens, state.scopes);\n}\n\n// Parse a single statement.\n//\n// If expecting a statement and finding a slash operator, parse a\n// regular expression literal. This is to handle cases like\n// `if (foo) /blah/.exec(foo)`, where looking at the previous token\n// does not help.\n\nexport function parseStatement(declaration) {\n  if (isFlowEnabled) {\n    if (flowTryParseStatement()) {\n      return;\n    }\n  }\n  if (match(tt.at)) {\n    parseDecorators();\n  }\n  parseStatementContent(declaration);\n}\n\nfunction parseStatementContent(declaration) {\n  if (isTypeScriptEnabled) {\n    if (tsTryParseStatementContent()) {\n      return;\n    }\n  }\n\n  const starttype = state.type;\n\n  // Most types of statements are recognized by the keyword they\n  // start with. Many are trivial to parse, some require a bit of\n  // complexity.\n\n  switch (starttype) {\n    case tt._break:\n    case tt._continue:\n      parseBreakContinueStatement();\n      return;\n    case tt._debugger:\n      parseDebuggerStatement();\n      return;\n    case tt._do:\n      parseDoStatement();\n      return;\n    case tt._for:\n      parseForStatement();\n      return;\n    case tt._function:\n      if (lookaheadType() === tt.dot) break;\n      if (!declaration) unexpected();\n      parseFunctionStatement();\n      return;\n\n    case tt._class:\n      if (!declaration) unexpected();\n      parseClass(true);\n      return;\n\n    case tt._if:\n      parseIfStatement();\n      return;\n    case tt._return:\n      parseReturnStatement();\n      return;\n    case tt._switch:\n      parseSwitchStatement();\n      return;\n    case tt._throw:\n      parseThrowStatement();\n      return;\n    case tt._try:\n      parseTryStatement();\n      return;\n\n    case tt._let:\n    case tt._const:\n      if (!declaration) unexpected(); // NOTE: falls through to _var\n\n    case tt._var:\n      parseVarStatement(starttype);\n      return;\n\n    case tt._while:\n      parseWhileStatement();\n      return;\n    case tt.braceL:\n      parseBlock();\n      return;\n    case tt.semi:\n      parseEmptyStatement();\n      return;\n    case tt._export:\n    case tt._import: {\n      const nextType = lookaheadType();\n      if (nextType === tt.parenL || nextType === tt.dot) {\n        break;\n      }\n      next();\n      if (starttype === tt._import) {\n        parseImport();\n      } else {\n        parseExport();\n      }\n      return;\n    }\n    case tt.name:\n      if (state.contextualKeyword === ContextualKeyword._async) {\n        const functionStart = state.start;\n        // peek ahead and see if next token is a function\n        const snapshot = state.snapshot();\n        next();\n        if (match(tt._function) && !canInsertSemicolon()) {\n          expect(tt._function);\n          parseFunction(functionStart, true);\n          return;\n        } else {\n          state.restoreFromSnapshot(snapshot);\n        }\n      }\n    default:\n      // Do nothing.\n      break;\n  }\n\n  // If the statement does not start with a statement keyword or a\n  // brace, it's an ExpressionStatement or LabeledStatement. We\n  // simply start parsing an expression, and afterwards, if the\n  // next token is a colon and the expression was a simple\n  // Identifier node, we switch to interpreting it as a label.\n  const initialTokensLength = state.tokens.length;\n  parseExpression();\n  let simpleName = null;\n  if (state.tokens.length === initialTokensLength + 1) {\n    const token = state.tokens[state.tokens.length - 1];\n    if (token.type === tt.name) {\n      simpleName = token.contextualKeyword;\n    }\n  }\n  if (simpleName == null) {\n    semicolon();\n    return;\n  }\n  if (eat(tt.colon)) {\n    parseLabeledStatement();\n  } else {\n    // This was an identifier, so we might want to handle flow/typescript-specific cases.\n    parseIdentifierStatement(simpleName);\n  }\n}\n\nexport function parseDecorators() {\n  while (match(tt.at)) {\n    parseDecorator();\n  }\n}\n\nfunction parseDecorator() {\n  next();\n  if (eat(tt.parenL)) {\n    parseExpression();\n    expect(tt.parenR);\n  } else {\n    parseIdentifier();\n    while (eat(tt.dot)) {\n      parseIdentifier();\n    }\n  }\n  parseMaybeDecoratorArguments();\n}\n\nfunction parseMaybeDecoratorArguments() {\n  if (isTypeScriptEnabled) {\n    tsParseMaybeDecoratorArguments();\n  } else {\n    baseParseMaybeDecoratorArguments();\n  }\n}\n\nexport function baseParseMaybeDecoratorArguments() {\n  if (eat(tt.parenL)) {\n    parseCallExpressionArguments();\n  }\n}\n\nfunction parseBreakContinueStatement() {\n  next();\n  if (!isLineTerminator()) {\n    parseIdentifier();\n    semicolon();\n  }\n}\n\nfunction parseDebuggerStatement() {\n  next();\n  semicolon();\n}\n\nfunction parseDoStatement() {\n  next();\n  parseStatement(false);\n  expect(tt._while);\n  parseParenExpression();\n  eat(tt.semi);\n}\n\nfunction parseForStatement() {\n  state.scopeDepth++;\n  const startTokenIndex = state.tokens.length;\n  parseAmbiguousForStatement();\n  const endTokenIndex = state.tokens.length;\n  state.scopes.push(new Scope(startTokenIndex, endTokenIndex, false));\n  state.scopeDepth--;\n}\n\n// Disambiguating between a `for` and a `for`/`in` or `for`/`of`\n// loop is non-trivial. Basically, we have to parse the init `var`\n// statement or expression, disallowing the `in` operator (see\n// the second parameter to `parseExpression`), and then check\n// whether the next token is `in` or `of`. When there is no init\n// part (semicolon immediately after the opening parenthesis), it\n// is a regular `for` loop.\nfunction parseAmbiguousForStatement() {\n  next();\n\n  let forAwait = false;\n  if (isContextual(ContextualKeyword._await)) {\n    forAwait = true;\n    next();\n  }\n  expect(tt.parenL);\n\n  if (match(tt.semi)) {\n    if (forAwait) {\n      unexpected();\n    }\n    parseFor();\n    return;\n  }\n\n  if (match(tt._var) || match(tt._let) || match(tt._const)) {\n    const varKind = state.type;\n    next();\n    parseVar(true, varKind);\n    if (match(tt._in) || isContextual(ContextualKeyword._of)) {\n      parseForIn(forAwait);\n      return;\n    }\n    parseFor();\n    return;\n  }\n\n  parseExpression(true);\n  if (match(tt._in) || isContextual(ContextualKeyword._of)) {\n    parseForIn(forAwait);\n    return;\n  }\n  if (forAwait) {\n    unexpected();\n  }\n  parseFor();\n}\n\nfunction parseFunctionStatement() {\n  const functionStart = state.start;\n  next();\n  parseFunction(functionStart, true);\n}\n\nfunction parseIfStatement() {\n  next();\n  parseParenExpression();\n  parseStatement(false);\n  if (eat(tt._else)) {\n    parseStatement(false);\n  }\n}\n\nfunction parseReturnStatement() {\n  next();\n\n  // In `return` (and `break`/`continue`), the keywords with\n  // optional arguments, we eagerly look for a semicolon or the\n  // possibility to insert one.\n\n  if (!isLineTerminator()) {\n    parseExpression();\n    semicolon();\n  }\n}\n\nfunction parseSwitchStatement() {\n  next();\n  parseParenExpression();\n  state.scopeDepth++;\n  const startTokenIndex = state.tokens.length;\n  expect(tt.braceL);\n\n  // Don't bother validation; just go through any sequence of cases, defaults, and statements.\n  while (!match(tt.braceR) && !state.error) {\n    if (match(tt._case) || match(tt._default)) {\n      const isCase = match(tt._case);\n      next();\n      if (isCase) {\n        parseExpression();\n      }\n      expect(tt.colon);\n    } else {\n      parseStatement(true);\n    }\n  }\n  next(); // Closing brace\n  const endTokenIndex = state.tokens.length;\n  state.scopes.push(new Scope(startTokenIndex, endTokenIndex, false));\n  state.scopeDepth--;\n}\n\nfunction parseThrowStatement() {\n  next();\n  parseExpression();\n  semicolon();\n}\n\nfunction parseTryStatement() {\n  next();\n\n  parseBlock();\n\n  if (match(tt._catch)) {\n    next();\n    let catchBindingStartTokenIndex = null;\n    if (match(tt.parenL)) {\n      state.scopeDepth++;\n      catchBindingStartTokenIndex = state.tokens.length;\n      expect(tt.parenL);\n      parseBindingAtom(true /* isBlockScope */);\n      expect(tt.parenR);\n    }\n    parseBlock();\n    if (catchBindingStartTokenIndex != null) {\n      // We need a special scope for the catch binding which includes the binding itself and the\n      // catch block.\n      const endTokenIndex = state.tokens.length;\n      state.scopes.push(new Scope(catchBindingStartTokenIndex, endTokenIndex, false));\n      state.scopeDepth--;\n    }\n  }\n  if (eat(tt._finally)) {\n    parseBlock();\n  }\n}\n\nexport function parseVarStatement(kind) {\n  next();\n  parseVar(false, kind);\n  semicolon();\n}\n\nfunction parseWhileStatement() {\n  next();\n  parseParenExpression();\n  parseStatement(false);\n}\n\nfunction parseEmptyStatement() {\n  next();\n}\n\nfunction parseLabeledStatement() {\n  parseStatement(true);\n}\n\n/**\n * Parse a statement starting with an identifier of the given name. Subclasses match on the name\n * to handle statements like \"declare\".\n */\nfunction parseIdentifierStatement(contextualKeyword) {\n  if (isTypeScriptEnabled) {\n    tsParseIdentifierStatement(contextualKeyword);\n  } else if (isFlowEnabled) {\n    flowParseIdentifierStatement(contextualKeyword);\n  } else {\n    semicolon();\n  }\n}\n\n// Parse a semicolon-enclosed block of statements, handling `\"use\n// strict\"` declarations when `allowStrict` is true (used for\n// function bodies).\n\nexport function parseBlock(\n  allowDirectives = false,\n  isFunctionScope = false,\n  contextId = 0,\n) {\n  const startTokenIndex = state.tokens.length;\n  state.scopeDepth++;\n  expect(tt.braceL);\n  if (contextId) {\n    state.tokens[state.tokens.length - 1].contextId = contextId;\n  }\n  parseBlockBody(tt.braceR);\n  if (contextId) {\n    state.tokens[state.tokens.length - 1].contextId = contextId;\n  }\n  const endTokenIndex = state.tokens.length;\n  state.scopes.push(new Scope(startTokenIndex, endTokenIndex, isFunctionScope));\n  state.scopeDepth--;\n}\n\nexport function parseBlockBody(end) {\n  while (!eat(end) && !state.error) {\n    parseStatement(true);\n  }\n}\n\n// Parse a regular `for` loop. The disambiguation code in\n// `parseStatement` will already have parsed the init statement or\n// expression.\n\nfunction parseFor() {\n  expect(tt.semi);\n  if (!match(tt.semi)) {\n    parseExpression();\n  }\n  expect(tt.semi);\n  if (!match(tt.parenR)) {\n    parseExpression();\n  }\n  expect(tt.parenR);\n  parseStatement(false);\n}\n\n// Parse a `for`/`in` and `for`/`of` loop, which are almost\n// same from parser's perspective.\n\nfunction parseForIn(forAwait) {\n  if (forAwait) {\n    eatContextual(ContextualKeyword._of);\n  } else {\n    next();\n  }\n  parseExpression();\n  expect(tt.parenR);\n  parseStatement(false);\n}\n\n// Parse a list of variable declarations.\n\nfunction parseVar(isFor, kind) {\n  while (true) {\n    const isBlockScope = kind === tt._const || kind === tt._let;\n    parseVarHead(isBlockScope);\n    if (eat(tt.eq)) {\n      const eqIndex = state.tokens.length - 1;\n      parseMaybeAssign(isFor);\n      state.tokens[eqIndex].rhsEndIndex = state.tokens.length;\n    }\n    if (!eat(tt.comma)) {\n      break;\n    }\n  }\n}\n\nfunction parseVarHead(isBlockScope) {\n  parseBindingAtom(isBlockScope);\n  if (isTypeScriptEnabled) {\n    tsAfterParseVarHead();\n  } else if (isFlowEnabled) {\n    flowAfterParseVarHead();\n  }\n}\n\n// Parse a function declaration or literal (depending on the\n// `isStatement` parameter).\n\nexport function parseFunction(\n  functionStart,\n  isStatement,\n  optionalId = false,\n) {\n  if (match(tt.star)) {\n    next();\n  }\n\n  if (isStatement && !optionalId && !match(tt.name) && !match(tt._yield)) {\n    unexpected();\n  }\n\n  let nameScopeStartTokenIndex = null;\n\n  if (match(tt.name)) {\n    // Expression-style functions should limit their name's scope to the function body, so we make\n    // a new function scope to enforce that.\n    if (!isStatement) {\n      nameScopeStartTokenIndex = state.tokens.length;\n      state.scopeDepth++;\n    }\n    parseBindingIdentifier(false);\n  }\n\n  const startTokenIndex = state.tokens.length;\n  state.scopeDepth++;\n  parseFunctionParams();\n  parseFunctionBodyAndFinish(functionStart);\n  const endTokenIndex = state.tokens.length;\n  // In addition to the block scope of the function body, we need a separate function-style scope\n  // that includes the params.\n  state.scopes.push(new Scope(startTokenIndex, endTokenIndex, true));\n  state.scopeDepth--;\n  if (nameScopeStartTokenIndex !== null) {\n    state.scopes.push(new Scope(nameScopeStartTokenIndex, endTokenIndex, true));\n    state.scopeDepth--;\n  }\n}\n\nexport function parseFunctionParams(\n  allowModifiers = false,\n  funcContextId = 0,\n) {\n  if (isTypeScriptEnabled) {\n    tsStartParseFunctionParams();\n  } else if (isFlowEnabled) {\n    flowStartParseFunctionParams();\n  }\n\n  expect(tt.parenL);\n  if (funcContextId) {\n    state.tokens[state.tokens.length - 1].contextId = funcContextId;\n  }\n  parseBindingList(\n    tt.parenR,\n    false /* isBlockScope */,\n    false /* allowEmpty */,\n    allowModifiers,\n    funcContextId,\n  );\n  if (funcContextId) {\n    state.tokens[state.tokens.length - 1].contextId = funcContextId;\n  }\n}\n\n// Parse a class declaration or literal (depending on the\n// `isStatement` parameter).\n\nexport function parseClass(isStatement, optionalId = false) {\n  // Put a context ID on the class keyword, the open-brace, and the close-brace, so that later\n  // code can easily navigate to meaningful points on the class.\n  const contextId = getNextContextId();\n\n  next();\n  state.tokens[state.tokens.length - 1].contextId = contextId;\n  state.tokens[state.tokens.length - 1].isExpression = !isStatement;\n  // Like with functions, we declare a special \"name scope\" from the start of the name to the end\n  // of the class, but only with expression-style classes, to represent the fact that the name is\n  // available to the body of the class but not an outer declaration.\n  let nameScopeStartTokenIndex = null;\n  if (!isStatement) {\n    nameScopeStartTokenIndex = state.tokens.length;\n    state.scopeDepth++;\n  }\n  parseClassId(isStatement, optionalId);\n  parseClassSuper();\n  const openBraceIndex = state.tokens.length;\n  parseClassBody(contextId);\n  if (state.error) {\n    return;\n  }\n  state.tokens[openBraceIndex].contextId = contextId;\n  state.tokens[state.tokens.length - 1].contextId = contextId;\n  if (nameScopeStartTokenIndex !== null) {\n    const endTokenIndex = state.tokens.length;\n    state.scopes.push(new Scope(nameScopeStartTokenIndex, endTokenIndex, false));\n    state.scopeDepth--;\n  }\n}\n\nfunction isClassProperty() {\n  return match(tt.eq) || match(tt.semi) || match(tt.braceR) || match(tt.bang) || match(tt.colon);\n}\n\nfunction isClassMethod() {\n  return match(tt.parenL) || match(tt.lessThan);\n}\n\nfunction parseClassBody(classContextId) {\n  expect(tt.braceL);\n\n  while (!eat(tt.braceR) && !state.error) {\n    if (eat(tt.semi)) {\n      continue;\n    }\n\n    if (match(tt.at)) {\n      parseDecorator();\n      continue;\n    }\n    const memberStart = state.start;\n    parseClassMember(memberStart, classContextId);\n  }\n}\n\nfunction parseClassMember(memberStart, classContextId) {\n  if (isTypeScriptEnabled) {\n    eatContextual(ContextualKeyword._declare);\n    tsParseAccessModifier();\n    eatContextual(ContextualKeyword._declare);\n  }\n  let isStatic = false;\n  if (match(tt.name) && state.contextualKeyword === ContextualKeyword._static) {\n    parseIdentifier(); // eats 'static'\n    if (isClassMethod()) {\n      parseClassMethod(memberStart, /* isConstructor */ false);\n      return;\n    } else if (isClassProperty()) {\n      parseClassProperty();\n      return;\n    }\n    // otherwise something static\n    state.tokens[state.tokens.length - 1].type = tt._static;\n    isStatic = true;\n  }\n\n  parseClassMemberWithIsStatic(memberStart, isStatic, classContextId);\n}\n\nfunction parseClassMemberWithIsStatic(\n  memberStart,\n  isStatic,\n  classContextId,\n) {\n  if (isTypeScriptEnabled) {\n    if (tsTryParseClassMemberWithIsStatic(isStatic, classContextId)) {\n      return;\n    }\n  }\n  if (eat(tt.star)) {\n    // a generator\n    parseClassPropertyName(classContextId);\n    parseClassMethod(memberStart, /* isConstructor */ false);\n    return;\n  }\n\n  // Get the identifier name so we can tell if it's actually a keyword like \"async\", \"get\", or\n  // \"set\".\n  parseClassPropertyName(classContextId);\n  let isConstructor = false;\n  const token = state.tokens[state.tokens.length - 1];\n  // We allow \"constructor\" as either an identifier or a string.\n  if (token.contextualKeyword === ContextualKeyword._constructor) {\n    isConstructor = true;\n  }\n  parsePostMemberNameModifiers();\n\n  if (isClassMethod()) {\n    parseClassMethod(memberStart, isConstructor);\n  } else if (isClassProperty()) {\n    parseClassProperty();\n  } else if (token.contextualKeyword === ContextualKeyword._async && !isLineTerminator()) {\n    state.tokens[state.tokens.length - 1].type = tt._async;\n    // an async method\n    const isGenerator = match(tt.star);\n    if (isGenerator) {\n      next();\n    }\n\n    // The so-called parsed name would have been \"async\": get the real name.\n    parseClassPropertyName(classContextId);\n    parsePostMemberNameModifiers();\n    parseClassMethod(memberStart, false /* isConstructor */);\n  } else if (\n    (token.contextualKeyword === ContextualKeyword._get ||\n      token.contextualKeyword === ContextualKeyword._set) &&\n    !(isLineTerminator() && match(tt.star))\n  ) {\n    if (token.contextualKeyword === ContextualKeyword._get) {\n      state.tokens[state.tokens.length - 1].type = tt._get;\n    } else {\n      state.tokens[state.tokens.length - 1].type = tt._set;\n    }\n    // `get\\n*` is an uninitialized property named 'get' followed by a generator.\n    // a getter or setter\n    // The so-called parsed name would have been \"get/set\": get the real name.\n    parseClassPropertyName(classContextId);\n    parseClassMethod(memberStart, /* isConstructor */ false);\n  } else if (isLineTerminator()) {\n    // an uninitialized class property (due to ASI, since we don't otherwise recognize the next token)\n    parseClassProperty();\n  } else {\n    unexpected();\n  }\n}\n\nfunction parseClassMethod(functionStart, isConstructor) {\n  if (isTypeScriptEnabled) {\n    tsTryParseTypeParameters();\n  } else if (isFlowEnabled) {\n    if (match(tt.lessThan)) {\n      flowParseTypeParameterDeclaration();\n    }\n  }\n  parseMethod(functionStart, isConstructor);\n}\n\n// Return the name of the class property, if it is a simple identifier.\nexport function parseClassPropertyName(classContextId) {\n  parsePropertyName(classContextId);\n}\n\nexport function parsePostMemberNameModifiers() {\n  if (isTypeScriptEnabled) {\n    const oldIsType = pushTypeContext(0);\n    eat(tt.question);\n    popTypeContext(oldIsType);\n  }\n}\n\nexport function parseClassProperty() {\n  if (isTypeScriptEnabled) {\n    eat(tt.bang);\n    tsTryParseTypeAnnotation();\n  } else if (isFlowEnabled) {\n    if (match(tt.colon)) {\n      flowParseTypeAnnotation();\n    }\n  }\n\n  if (match(tt.eq)) {\n    const equalsTokenIndex = state.tokens.length;\n    next();\n    parseMaybeAssign();\n    state.tokens[equalsTokenIndex].rhsEndIndex = state.tokens.length;\n  }\n  semicolon();\n}\n\nfunction parseClassId(isStatement, optionalId = false) {\n  if (\n    isTypeScriptEnabled &&\n    (!isStatement || optionalId) &&\n    isContextual(ContextualKeyword._implements)\n  ) {\n    return;\n  }\n\n  if (match(tt.name)) {\n    parseBindingIdentifier(true);\n  }\n\n  if (isTypeScriptEnabled) {\n    tsTryParseTypeParameters();\n  } else if (isFlowEnabled) {\n    if (match(tt.lessThan)) {\n      flowParseTypeParameterDeclaration();\n    }\n  }\n}\n\n// Returns true if there was a superclass.\nfunction parseClassSuper() {\n  let hasSuper = false;\n  if (eat(tt._extends)) {\n    parseExprSubscripts();\n    hasSuper = true;\n  } else {\n    hasSuper = false;\n  }\n  if (isTypeScriptEnabled) {\n    tsAfterParseClassSuper(hasSuper);\n  } else if (isFlowEnabled) {\n    flowAfterParseClassSuper(hasSuper);\n  }\n}\n\n// Parses module export declaration.\n\nexport function parseExport() {\n  const exportIndex = state.tokens.length - 1;\n  if (isTypeScriptEnabled) {\n    if (tsTryParseExport()) {\n      return;\n    }\n  }\n  // export * from '...'\n  if (shouldParseExportStar()) {\n    parseExportStar();\n  } else if (isExportDefaultSpecifier()) {\n    // export default from\n    parseIdentifier();\n    if (match(tt.comma) && lookaheadType() === tt.star) {\n      expect(tt.comma);\n      expect(tt.star);\n      expectContextual(ContextualKeyword._as);\n      parseIdentifier();\n    } else {\n      parseExportSpecifiersMaybe();\n    }\n    parseExportFrom();\n  } else if (eat(tt._default)) {\n    // export default ...\n    parseExportDefaultExpression();\n  } else if (shouldParseExportDeclaration()) {\n    parseExportDeclaration();\n  } else {\n    // export { x, y as z } [from '...']\n    parseExportSpecifiers();\n    parseExportFrom();\n  }\n  state.tokens[exportIndex].rhsEndIndex = state.tokens.length;\n}\n\nfunction parseExportDefaultExpression() {\n  if (isTypeScriptEnabled) {\n    if (tsTryParseExportDefaultExpression()) {\n      return;\n    }\n  }\n  const functionStart = state.start;\n  if (eat(tt._function)) {\n    parseFunction(functionStart, true, true);\n  } else if (isContextual(ContextualKeyword._async) && lookaheadType() === tt._function) {\n    // async function declaration\n    eatContextual(ContextualKeyword._async);\n    eat(tt._function);\n    parseFunction(functionStart, true, true);\n  } else if (match(tt._class)) {\n    parseClass(true, true);\n  } else if (match(tt.at)) {\n    parseDecorators();\n    parseClass(true, true);\n  } else {\n    parseMaybeAssign();\n    semicolon();\n  }\n}\n\nfunction parseExportDeclaration() {\n  if (isTypeScriptEnabled) {\n    tsParseExportDeclaration();\n  } else if (isFlowEnabled) {\n    flowParseExportDeclaration();\n  } else {\n    parseStatement(true);\n  }\n}\n\nfunction isExportDefaultSpecifier() {\n  if (isTypeScriptEnabled && tsIsDeclarationStart()) {\n    return false;\n  } else if (isFlowEnabled && flowShouldDisallowExportDefaultSpecifier()) {\n    return false;\n  }\n  if (match(tt.name)) {\n    return state.contextualKeyword !== ContextualKeyword._async;\n  }\n\n  if (!match(tt._default)) {\n    return false;\n  }\n\n  const lookahead = lookaheadTypeAndKeyword();\n  return (\n    lookahead.type === tt.comma ||\n    (lookahead.type === tt.name && lookahead.contextualKeyword === ContextualKeyword._from)\n  );\n}\n\nfunction parseExportSpecifiersMaybe() {\n  if (eat(tt.comma)) {\n    parseExportSpecifiers();\n  }\n}\n\nexport function parseExportFrom() {\n  if (eatContextual(ContextualKeyword._from)) {\n    parseExprAtom();\n  }\n  semicolon();\n}\n\nfunction shouldParseExportStar() {\n  if (isFlowEnabled) {\n    return flowShouldParseExportStar();\n  } else {\n    return match(tt.star);\n  }\n}\n\nfunction parseExportStar() {\n  if (isFlowEnabled) {\n    flowParseExportStar();\n  } else {\n    baseParseExportStar();\n  }\n}\n\nexport function baseParseExportStar() {\n  expect(tt.star);\n\n  if (isContextual(ContextualKeyword._as)) {\n    parseExportNamespace();\n  } else {\n    parseExportFrom();\n  }\n}\n\nfunction parseExportNamespace() {\n  next();\n  state.tokens[state.tokens.length - 1].type = tt._as;\n  parseIdentifier();\n  parseExportSpecifiersMaybe();\n  parseExportFrom();\n}\n\nfunction shouldParseExportDeclaration() {\n  return (\n    (isTypeScriptEnabled && tsIsDeclarationStart()) ||\n    (isFlowEnabled && flowShouldParseExportDeclaration()) ||\n    state.type === tt._var ||\n    state.type === tt._const ||\n    state.type === tt._let ||\n    state.type === tt._function ||\n    state.type === tt._class ||\n    isContextual(ContextualKeyword._async) ||\n    match(tt.at)\n  );\n}\n\n// Parses a comma-separated list of module exports.\nexport function parseExportSpecifiers() {\n  let first = true;\n\n  // export { x, y as z } [from '...']\n  expect(tt.braceL);\n\n  while (!eat(tt.braceR) && !state.error) {\n    if (first) {\n      first = false;\n    } else {\n      expect(tt.comma);\n      if (eat(tt.braceR)) {\n        break;\n      }\n    }\n\n    parseIdentifier();\n    state.tokens[state.tokens.length - 1].identifierRole = IdentifierRole.ExportAccess;\n    if (eatContextual(ContextualKeyword._as)) {\n      parseIdentifier();\n    }\n  }\n}\n\n// Parses import declaration.\n\nexport function parseImport() {\n  if (isTypeScriptEnabled && match(tt.name) && lookaheadType() === tt.eq) {\n    tsParseImportEqualsDeclaration();\n    return;\n  }\n  if (isTypeScriptEnabled) {\n    eatContextual(ContextualKeyword._type);\n  }\n\n  // import '...'\n  if (match(tt.string)) {\n    parseExprAtom();\n  } else {\n    parseImportSpecifiers();\n    expectContextual(ContextualKeyword._from);\n    parseExprAtom();\n  }\n  semicolon();\n}\n\n// eslint-disable-next-line no-unused-vars\nfunction shouldParseDefaultImport() {\n  return match(tt.name);\n}\n\nfunction parseImportSpecifierLocal() {\n  parseImportedIdentifier();\n}\n\n// Parses a comma-separated list of module imports.\nfunction parseImportSpecifiers() {\n  if (isFlowEnabled) {\n    flowStartParseImportSpecifiers();\n  }\n\n  let first = true;\n  if (shouldParseDefaultImport()) {\n    // import defaultObj, { x, y as z } from '...'\n    parseImportSpecifierLocal();\n\n    if (!eat(tt.comma)) return;\n  }\n\n  if (match(tt.star)) {\n    next();\n    expectContextual(ContextualKeyword._as);\n\n    parseImportSpecifierLocal();\n\n    return;\n  }\n\n  expect(tt.braceL);\n  while (!eat(tt.braceR) && !state.error) {\n    if (first) {\n      first = false;\n    } else {\n      // Detect an attempt to deep destructure\n      if (eat(tt.colon)) {\n        unexpected(\n          \"ES2015 named imports do not destructure. Use another statement for destructuring after the import.\",\n        );\n      }\n\n      expect(tt.comma);\n      if (eat(tt.braceR)) {\n        break;\n      }\n    }\n\n    parseImportSpecifier();\n  }\n}\n\nfunction parseImportSpecifier() {\n  if (isFlowEnabled) {\n    flowParseImportSpecifier();\n    return;\n  }\n  parseImportedIdentifier();\n  if (isContextual(ContextualKeyword._as)) {\n    state.tokens[state.tokens.length - 1].identifierRole = IdentifierRole.ImportAccess;\n    next();\n    parseImportedIdentifier();\n  }\n}\n","\nimport {nextToken, skipLineComment} from \"../tokenizer/index\";\nimport {charCodes} from \"../util/charcodes\";\nimport {input, state} from \"./base\";\nimport {parseTopLevel} from \"./statement\";\n\nexport function parseFile() {\n  // If enabled, skip leading hashbang line.\n  if (\n    state.pos === 0 &&\n    input.charCodeAt(0) === charCodes.numberSign &&\n    input.charCodeAt(1) === charCodes.exclamationMark\n  ) {\n    skipLineComment(2);\n  }\n  nextToken();\n  return parseTopLevel();\n}\n","\n\nimport {augmentError, initParser, state} from \"./traverser/base\";\nimport {parseFile} from \"./traverser/index\";\n\nexport class File {\n  \n  \n\n  constructor(tokens, scopes) {\n    this.tokens = tokens;\n    this.scopes = scopes;\n  }\n}\n\nexport function parse(\n  input,\n  isJSXEnabled,\n  isTypeScriptEnabled,\n  isFlowEnabled,\n) {\n  if (isFlowEnabled && isTypeScriptEnabled) {\n    throw new Error(\"Cannot combine flow and typescript plugins.\");\n  }\n  initParser(input, isJSXEnabled, isTypeScriptEnabled, isFlowEnabled);\n  const result = parseFile();\n  if (state.error) {\n    throw augmentError(state.error);\n  }\n  return result;\n}\n","\n\n\nimport { TokenType as tt} from \"./parser/tokenizer/types\";\nimport isAsyncOperation from \"./util/isAsyncOperation\";\n\n\n\n\n\n\nexport default class TokenProcessor {\n   __init() {this.resultCode = \"\"}\n   __init2() {this.tokenIndex = 0}\n\n  constructor(\n     code,\n     tokens,\n     isFlowEnabled,\n     helperManager,\n  ) {;this.code = code;this.tokens = tokens;this.isFlowEnabled = isFlowEnabled;this.helperManager = helperManager;TokenProcessor.prototype.__init.call(this);TokenProcessor.prototype.__init2.call(this);}\n\n  /**\n   * Make a new TokenProcessor for things like lookahead.\n   */\n  snapshot() {\n    return {resultCode: this.resultCode, tokenIndex: this.tokenIndex};\n  }\n\n  restoreToSnapshot(snapshot) {\n    this.resultCode = snapshot.resultCode;\n    this.tokenIndex = snapshot.tokenIndex;\n  }\n\n  getResultCodeIndex() {\n    return this.resultCode.length;\n  }\n\n  reset() {\n    this.resultCode = \"\";\n    this.tokenIndex = 0;\n  }\n\n  matchesContextualAtIndex(index, contextualKeyword) {\n    return (\n      this.matches1AtIndex(index, tt.name) &&\n      this.tokens[index].contextualKeyword === contextualKeyword\n    );\n  }\n\n  identifierNameAtIndex(index) {\n    // TODO: We need to process escapes since technically you can have unicode escapes in variable\n    // names.\n    return this.identifierNameForToken(this.tokens[index]);\n  }\n\n  identifierName() {\n    return this.identifierNameForToken(this.currentToken());\n  }\n\n  identifierNameForToken(token) {\n    return this.code.slice(token.start, token.end);\n  }\n\n  rawCodeForToken(token) {\n    return this.code.slice(token.start, token.end);\n  }\n\n  stringValueAtIndex(index) {\n    return this.stringValueForToken(this.tokens[index]);\n  }\n\n  stringValue() {\n    return this.stringValueForToken(this.currentToken());\n  }\n\n  stringValueForToken(token) {\n    // This is used to identify when two imports are the same and to resolve TypeScript enum keys.\n    // Ideally we'd process escapes within the strings, but for now we pretty much take the raw\n    // code.\n    return this.code.slice(token.start + 1, token.end - 1);\n  }\n\n  matches1AtIndex(index, t1) {\n    return this.tokens[index].type === t1;\n  }\n\n  matches2AtIndex(index, t1, t2) {\n    return this.tokens[index].type === t1 && this.tokens[index + 1].type === t2;\n  }\n\n  matches3AtIndex(index, t1, t2, t3) {\n    return (\n      this.tokens[index].type === t1 &&\n      this.tokens[index + 1].type === t2 &&\n      this.tokens[index + 2].type === t3\n    );\n  }\n\n  matches1(t1) {\n    return this.tokens[this.tokenIndex].type === t1;\n  }\n\n  matches2(t1, t2) {\n    return this.tokens[this.tokenIndex].type === t1 && this.tokens[this.tokenIndex + 1].type === t2;\n  }\n\n  matches3(t1, t2, t3) {\n    return (\n      this.tokens[this.tokenIndex].type === t1 &&\n      this.tokens[this.tokenIndex + 1].type === t2 &&\n      this.tokens[this.tokenIndex + 2].type === t3\n    );\n  }\n\n  matches4(t1, t2, t3, t4) {\n    return (\n      this.tokens[this.tokenIndex].type === t1 &&\n      this.tokens[this.tokenIndex + 1].type === t2 &&\n      this.tokens[this.tokenIndex + 2].type === t3 &&\n      this.tokens[this.tokenIndex + 3].type === t4\n    );\n  }\n\n  matches5(t1, t2, t3, t4, t5) {\n    return (\n      this.tokens[this.tokenIndex].type === t1 &&\n      this.tokens[this.tokenIndex + 1].type === t2 &&\n      this.tokens[this.tokenIndex + 2].type === t3 &&\n      this.tokens[this.tokenIndex + 3].type === t4 &&\n      this.tokens[this.tokenIndex + 4].type === t5\n    );\n  }\n\n  matchesContextual(contextualKeyword) {\n    return this.matchesContextualAtIndex(this.tokenIndex, contextualKeyword);\n  }\n\n  matchesContextIdAndLabel(type, contextId) {\n    return this.matches1(type) && this.currentToken().contextId === contextId;\n  }\n\n  previousWhitespaceAndComments() {\n    let whitespaceAndComments = this.code.slice(\n      this.tokenIndex > 0 ? this.tokens[this.tokenIndex - 1].end : 0,\n      this.tokenIndex < this.tokens.length ? this.tokens[this.tokenIndex].start : this.code.length,\n    );\n    if (this.isFlowEnabled) {\n      whitespaceAndComments = whitespaceAndComments.replace(/@flow/g, \"\");\n    }\n    return whitespaceAndComments;\n  }\n\n  replaceToken(newCode) {\n    this.resultCode += this.previousWhitespaceAndComments();\n    this.appendTokenPrefix();\n    this.resultCode += newCode;\n    this.appendTokenSuffix();\n    this.tokenIndex++;\n  }\n\n  replaceTokenTrimmingLeftWhitespace(newCode) {\n    this.resultCode += this.previousWhitespaceAndComments().replace(/[^\\r\\n]/g, \"\");\n    this.appendTokenPrefix();\n    this.resultCode += newCode;\n    this.appendTokenSuffix();\n    this.tokenIndex++;\n  }\n\n  removeInitialToken() {\n    this.replaceToken(\"\");\n  }\n\n  removeToken() {\n    this.replaceTokenTrimmingLeftWhitespace(\"\");\n  }\n\n  copyExpectedToken(tokenType) {\n    if (this.tokens[this.tokenIndex].type !== tokenType) {\n      throw new Error(`Expected token ${tokenType}`);\n    }\n    this.copyToken();\n  }\n\n  copyToken() {\n    this.resultCode += this.previousWhitespaceAndComments();\n    this.appendTokenPrefix();\n    this.resultCode += this.code.slice(\n      this.tokens[this.tokenIndex].start,\n      this.tokens[this.tokenIndex].end,\n    );\n    this.appendTokenSuffix();\n    this.tokenIndex++;\n  }\n\n  copyTokenWithPrefix(prefix) {\n    this.resultCode += this.previousWhitespaceAndComments();\n    this.appendTokenPrefix();\n    this.resultCode += prefix;\n    this.resultCode += this.code.slice(\n      this.tokens[this.tokenIndex].start,\n      this.tokens[this.tokenIndex].end,\n    );\n    this.appendTokenSuffix();\n    this.tokenIndex++;\n  }\n\n   appendTokenPrefix() {\n    const token = this.currentToken();\n    if (token.numNullishCoalesceStarts || token.isOptionalChainStart) {\n      token.isAsyncOperation = isAsyncOperation(this);\n    }\n    if (token.numNullishCoalesceStarts) {\n      for (let i = 0; i < token.numNullishCoalesceStarts; i++) {\n        if (token.isAsyncOperation) {\n          this.resultCode += \"await \";\n          this.resultCode += this.helperManager.getHelperName(\"asyncNullishCoalesce\");\n        } else {\n          this.resultCode += this.helperManager.getHelperName(\"nullishCoalesce\");\n        }\n        this.resultCode += \"(\";\n      }\n    }\n    if (token.isOptionalChainStart) {\n      if (token.isAsyncOperation) {\n        this.resultCode += \"await \";\n      }\n      if (this.tokenIndex > 0 && this.tokenAtRelativeIndex(-1).type === tt._delete) {\n        if (token.isAsyncOperation) {\n          this.resultCode += this.helperManager.getHelperName(\"asyncOptionalChainDelete\");\n        } else {\n          this.resultCode += this.helperManager.getHelperName(\"optionalChainDelete\");\n        }\n      } else if (token.isAsyncOperation) {\n        this.resultCode += this.helperManager.getHelperName(\"asyncOptionalChain\");\n      } else {\n        this.resultCode += this.helperManager.getHelperName(\"optionalChain\");\n      }\n      this.resultCode += \"([\";\n    }\n  }\n\n   appendTokenSuffix() {\n    const token = this.currentToken();\n    if (token.isOptionalChainEnd) {\n      this.resultCode += \"])\";\n    }\n    if (token.numNullishCoalesceEnds) {\n      for (let i = 0; i < token.numNullishCoalesceEnds; i++) {\n        this.resultCode += \"))\";\n      }\n    }\n  }\n\n  appendCode(code) {\n    this.resultCode += code;\n  }\n\n  currentToken() {\n    return this.tokens[this.tokenIndex];\n  }\n\n  currentTokenCode() {\n    const token = this.currentToken();\n    return this.code.slice(token.start, token.end);\n  }\n\n  tokenAtRelativeIndex(relativeIndex) {\n    return this.tokens[this.tokenIndex + relativeIndex];\n  }\n\n  currentIndex() {\n    return this.tokenIndex;\n  }\n\n  /**\n   * Move to the next token. Only suitable in preprocessing steps. When\n   * generating new code, you should use copyToken or removeToken.\n   */\n  nextToken() {\n    if (this.tokenIndex === this.tokens.length) {\n      throw new Error(\"Unexpectedly reached end of input.\");\n    }\n    this.tokenIndex++;\n  }\n\n  previousToken() {\n    this.tokenIndex--;\n  }\n\n  finish() {\n    if (this.tokenIndex !== this.tokens.length) {\n      throw new Error(\"Tried to finish processing tokens before reaching the end.\");\n    }\n    this.resultCode += this.previousWhitespaceAndComments();\n    return this.resultCode;\n  }\n\n  isAtEnd() {\n    return this.tokenIndex === this.tokens.length;\n  }\n}\n","import {ContextualKeyword} from \"../parser/tokenizer/keywords\";\n\n\n/**\n * Determine whether this optional chain or nullish coalescing operation has any await statements in\n * it. If so, we'll need to transpile to an async operation.\n *\n * We compute this by walking the length of the operation and returning true if we see an await\n * keyword used as a real await (rather than an object key or property access). Nested optional\n * chain/nullish operations need to be tracked but don't silence await, but a nested async function\n * (or any other nested scope) will make the await not count.\n */\nexport default function isAsyncOperation(tokens) {\n  let index = tokens.currentIndex();\n  let depth = 0;\n  const startToken = tokens.currentToken();\n  do {\n    const token = tokens.tokens[index];\n    if (token.isOptionalChainStart) {\n      depth++;\n    }\n    if (token.isOptionalChainEnd) {\n      depth--;\n    }\n    depth += token.numNullishCoalesceStarts;\n    depth -= token.numNullishCoalesceEnds;\n\n    if (\n      token.contextualKeyword === ContextualKeyword._await &&\n      token.identifierRole == null &&\n      token.scopeDepth === startToken.scopeDepth\n    ) {\n      return true;\n    }\n    index += 1;\n  } while (depth > 0 && index < tokens.tokens.length);\n  return false;\n}\n","\n\nimport {ContextualKeyword} from \"../parser/tokenizer/keywords\";\nimport {TokenType as tt} from \"../parser/tokenizer/types\";\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Get information about the class fields for this class, given a token processor pointing to the\n * open-brace at the start of the class.\n */\nexport default function getClassInfo(\n  rootTransformer,\n  tokens,\n  nameManager,\n) {\n  const snapshot = tokens.snapshot();\n\n  const headerInfo = processClassHeader(tokens);\n\n  let constructorInitializerStatements = [];\n  const instanceInitializerNames = [];\n  const staticInitializerNames = [];\n  let constructorInsertPos = null;\n  const fields = [];\n  const rangesToRemove = [];\n\n  const classContextId = tokens.currentToken().contextId;\n  if (classContextId == null) {\n    throw new Error(\"Expected non-null class context ID on class open-brace.\");\n  }\n\n  tokens.nextToken();\n  while (!tokens.matchesContextIdAndLabel(tt.braceR, classContextId)) {\n    if (tokens.matchesContextual(ContextualKeyword._constructor) && !tokens.currentToken().isType) {\n      ({constructorInitializerStatements, constructorInsertPos} = processConstructor(tokens));\n    } else if (tokens.matches1(tt.semi)) {\n      rangesToRemove.push({start: tokens.currentIndex(), end: tokens.currentIndex() + 1});\n      tokens.nextToken();\n    } else if (tokens.currentToken().isType) {\n      tokens.nextToken();\n    } else {\n      // Either a method or a field. Skip to the identifier part.\n      const statementStartIndex = tokens.currentIndex();\n      let isStatic = false;\n      while (isAccessModifier(tokens.currentToken())) {\n        if (tokens.matches1(tt._static)) {\n          isStatic = true;\n        }\n        tokens.nextToken();\n      }\n      if (\n        tokens.matchesContextual(ContextualKeyword._constructor) &&\n        !tokens.currentToken().isType\n      ) {\n        ({constructorInitializerStatements, constructorInsertPos} = processConstructor(tokens));\n        continue;\n      }\n      const nameStartIndex = tokens.currentIndex();\n      skipFieldName(tokens);\n      if (tokens.matches1(tt.lessThan) || tokens.matches1(tt.parenL)) {\n        // This is a method, so just skip to the next method/field. To do that, we seek forward to\n        // the next start of a class name (either an open bracket or an identifier, or the closing\n        // curly brace), then seek backward to include any access modifiers.\n        while (tokens.currentToken().contextId !== classContextId) {\n          tokens.nextToken();\n        }\n        while (isAccessModifier(tokens.tokenAtRelativeIndex(-1))) {\n          tokens.previousToken();\n        }\n        continue;\n      }\n      // There might be a type annotation that we need to skip.\n      while (tokens.currentToken().isType) {\n        tokens.nextToken();\n      }\n      if (tokens.matches1(tt.eq)) {\n        const equalsIndex = tokens.currentIndex();\n        // This is an initializer, so we need to wrap in an initializer method.\n        const valueEnd = tokens.currentToken().rhsEndIndex;\n        if (valueEnd == null) {\n          throw new Error(\"Expected rhsEndIndex on class field assignment.\");\n        }\n        tokens.nextToken();\n        while (tokens.currentIndex() < valueEnd) {\n          rootTransformer.processToken();\n        }\n        let initializerName;\n        if (isStatic) {\n          initializerName = nameManager.claimFreeName(\"__initStatic\");\n          staticInitializerNames.push(initializerName);\n        } else {\n          initializerName = nameManager.claimFreeName(\"__init\");\n          instanceInitializerNames.push(initializerName);\n        }\n        // Fields start at the name, so `static x = 1;` has a field range of `x = 1;`.\n        fields.push({\n          initializerName,\n          equalsIndex,\n          start: nameStartIndex,\n          end: tokens.currentIndex(),\n        });\n      } else {\n        // This is just a declaration, so doesn't need to produce any code in the output.\n        rangesToRemove.push({start: statementStartIndex, end: tokens.currentIndex()});\n      }\n    }\n  }\n\n  tokens.restoreToSnapshot(snapshot);\n  return {\n    headerInfo,\n    constructorInitializerStatements,\n    instanceInitializerNames,\n    staticInitializerNames,\n    constructorInsertPos,\n    fields,\n    rangesToRemove,\n  };\n}\n\nfunction processClassHeader(tokens) {\n  const classToken = tokens.currentToken();\n  const contextId = classToken.contextId;\n  if (contextId == null) {\n    throw new Error(\"Expected context ID on class token.\");\n  }\n  const isExpression = classToken.isExpression;\n  if (isExpression == null) {\n    throw new Error(\"Expected isExpression on class token.\");\n  }\n  let className = null;\n  let hasSuperclass = false;\n  tokens.nextToken();\n  if (tokens.matches1(tt.name)) {\n    className = tokens.identifierName();\n  }\n  while (!tokens.matchesContextIdAndLabel(tt.braceL, contextId)) {\n    // If this has a superclass, there will always be an `extends` token. If it doesn't have a\n    // superclass, only type parameters and `implements` clauses can show up here, all of which\n    // consist only of type tokens. A declaration like `class A<B extends C> {` should *not* count\n    // as having a superclass.\n    if (tokens.matches1(tt._extends) && !tokens.currentToken().isType) {\n      hasSuperclass = true;\n    }\n    tokens.nextToken();\n  }\n  return {isExpression, className, hasSuperclass};\n}\n\n/**\n * Extract useful information out of a constructor, starting at the \"constructor\" name.\n */\nfunction processConstructor(\n  tokens,\n) {\n  const constructorInitializerStatements = [];\n\n  tokens.nextToken();\n  const constructorContextId = tokens.currentToken().contextId;\n  if (constructorContextId == null) {\n    throw new Error(\"Expected context ID on open-paren starting constructor params.\");\n  }\n  // Advance through parameters looking for access modifiers.\n  while (!tokens.matchesContextIdAndLabel(tt.parenR, constructorContextId)) {\n    if (tokens.currentToken().contextId === constructorContextId) {\n      // Current token is an open paren or comma just before a param, so check\n      // that param for access modifiers.\n      tokens.nextToken();\n      if (isAccessModifier(tokens.currentToken())) {\n        tokens.nextToken();\n        while (isAccessModifier(tokens.currentToken())) {\n          tokens.nextToken();\n        }\n        const token = tokens.currentToken();\n        if (token.type !== tt.name) {\n          throw new Error(\"Expected identifier after access modifiers in constructor arg.\");\n        }\n        const name = tokens.identifierNameForToken(token);\n        constructorInitializerStatements.push(`this.${name} = ${name}`);\n      }\n    } else {\n      tokens.nextToken();\n    }\n  }\n  // )\n  tokens.nextToken();\n  let constructorInsertPos = tokens.currentIndex();\n\n  // Advance through body looking for a super call.\n  let foundSuperCall = false;\n  while (!tokens.matchesContextIdAndLabel(tt.braceR, constructorContextId)) {\n    if (!foundSuperCall && tokens.matches2(tt._super, tt.parenL)) {\n      tokens.nextToken();\n      const superCallContextId = tokens.currentToken().contextId;\n      if (superCallContextId == null) {\n        throw new Error(\"Expected a context ID on the super call\");\n      }\n      while (!tokens.matchesContextIdAndLabel(tt.parenR, superCallContextId)) {\n        tokens.nextToken();\n      }\n      constructorInsertPos = tokens.currentIndex();\n      foundSuperCall = true;\n    }\n    tokens.nextToken();\n  }\n  // }\n  tokens.nextToken();\n\n  return {constructorInitializerStatements, constructorInsertPos};\n}\n\n/**\n * Determine if this is any token that can go before the name in a method/field.\n */\nfunction isAccessModifier(token) {\n  return [\n    tt._async,\n    tt._get,\n    tt._set,\n    tt.plus,\n    tt.minus,\n    tt._readonly,\n    tt._static,\n    tt._public,\n    tt._private,\n    tt._protected,\n    tt._abstract,\n    tt.star,\n    tt._declare,\n  ].includes(token.type);\n}\n\n/**\n * The next token or set of tokens is either an identifier or an expression in square brackets, for\n * a method or field name.\n */\nfunction skipFieldName(tokens) {\n  if (tokens.matches1(tt.bracketL)) {\n    const startToken = tokens.currentToken();\n    const classContextId = startToken.contextId;\n    if (classContextId == null) {\n      throw new Error(\"Expected class context ID on computed name open bracket.\");\n    }\n    while (!tokens.matchesContextIdAndLabel(tt.bracketR, classContextId)) {\n      tokens.nextToken();\n    }\n    tokens.nextToken();\n  } else {\n    tokens.nextToken();\n  }\n}\n","import {TokenType as tt} from \"../parser/tokenizer/types\";\n\n\nexport default function elideImportEquals(tokens) {\n  // import\n  tokens.removeInitialToken();\n  // name\n  tokens.removeToken();\n  // =\n  tokens.removeToken();\n  // name or require\n  tokens.removeToken();\n  // Handle either `import A = require('A')` or `import A = B.C.D`.\n  if (tokens.matches1(tt.parenL)) {\n    // (\n    tokens.removeToken();\n    // path string\n    tokens.removeToken();\n    // )\n    tokens.removeToken();\n  } else {\n    while (tokens.matches1(tt.dot)) {\n      // .\n      tokens.removeToken();\n      // name\n      tokens.removeToken();\n    }\n  }\n}\n","import {isTopLevelDeclaration} from \"../parser/tokenizer\";\nimport {TokenType as tt} from \"../parser/tokenizer/types\";\n\n\n\n\n\n\n\nexport const EMPTY_DECLARATION_INFO = {\n  typeDeclarations: new Set(),\n  valueDeclarations: new Set(),\n};\n\n/**\n * Get all top-level identifiers that should be preserved when exported in TypeScript.\n *\n * Examples:\n * - If an identifier is declared as `const x`, then `export {x}` should be preserved.\n * - If it's declared as `type x`, then `export {x}` should be removed.\n * - If it's declared as both `const x` and `type x`, then the export should be preserved.\n * - Classes and enums should be preserved (even though they also introduce types).\n * - Imported identifiers should be preserved since we don't have enough information to\n *   rule them out. --isolatedModules disallows re-exports, which catches errors here.\n */\nexport default function getDeclarationInfo(tokens) {\n  const typeDeclarations = new Set();\n  const valueDeclarations = new Set();\n  for (let i = 0; i < tokens.tokens.length; i++) {\n    const token = tokens.tokens[i];\n    if (token.type === tt.name && isTopLevelDeclaration(token)) {\n      if (token.isType) {\n        typeDeclarations.add(tokens.identifierNameForToken(token));\n      } else {\n        valueDeclarations.add(tokens.identifierNameForToken(token));\n      }\n    }\n  }\n  return {typeDeclarations, valueDeclarations};\n}\n","import {TokenType as tt} from \"../parser/tokenizer/types\";\n\n\n\n/**\n * Common method sharing code between CJS and ESM cases, since they're the same here.\n */\nexport default function shouldElideDefaultExport(\n  isTypeScriptTransformEnabled,\n  tokens,\n  declarationInfo,\n) {\n  if (!isTypeScriptTransformEnabled) {\n    return false;\n  }\n  const exportToken = tokens.currentToken();\n  if (exportToken.rhsEndIndex == null) {\n    throw new Error(\"Expected non-null rhsEndIndex on export token.\");\n  }\n  // The export must be of the form `export default a` or `export default a;`.\n  const numTokens = exportToken.rhsEndIndex - tokens.currentIndex();\n  if (\n    numTokens !== 3 &&\n    !(numTokens === 4 && tokens.matches1AtIndex(exportToken.rhsEndIndex - 1, tt.semi))\n  ) {\n    return false;\n  }\n  const identifierToken = tokens.tokenAtRelativeIndex(2);\n  if (identifierToken.type !== tt.name) {\n    return false;\n  }\n  const exportedName = tokens.identifierNameForToken(identifierToken);\n  return (\n    declarationInfo.typeDeclarations.has(exportedName) &&\n    !declarationInfo.valueDeclarations.has(exportedName)\n  );\n}\n","\n\nimport {IdentifierRole, isDeclaration, isObjectShorthandDeclaration} from \"../parser/tokenizer\";\nimport {ContextualKeyword} from \"../parser/tokenizer/keywords\";\nimport {TokenType as tt} from \"../parser/tokenizer/types\";\n\nimport elideImportEquals from \"../util/elideImportEquals\";\nimport getDeclarationInfo, {\n\n  EMPTY_DECLARATION_INFO,\n} from \"../util/getDeclarationInfo\";\nimport shouldElideDefaultExport from \"../util/shouldElideDefaultExport\";\n\n\nimport Transformer from \"./Transformer\";\n\n/**\n * Class for editing import statements when we are transforming to commonjs.\n */\nexport default class CJSImportTransformer extends Transformer {\n   __init() {this.hadExport = false}\n   __init2() {this.hadNamedExport = false}\n   __init3() {this.hadDefaultExport = false}\n  \n\n  constructor(\n     rootTransformer,\n     tokens,\n     importProcessor,\n     nameManager,\n     reactHotLoaderTransformer,\n     enableLegacyBabel5ModuleInterop,\n     isTypeScriptTransformEnabled,\n  ) {\n    super();this.rootTransformer = rootTransformer;this.tokens = tokens;this.importProcessor = importProcessor;this.nameManager = nameManager;this.reactHotLoaderTransformer = reactHotLoaderTransformer;this.enableLegacyBabel5ModuleInterop = enableLegacyBabel5ModuleInterop;this.isTypeScriptTransformEnabled = isTypeScriptTransformEnabled;CJSImportTransformer.prototype.__init.call(this);CJSImportTransformer.prototype.__init2.call(this);CJSImportTransformer.prototype.__init3.call(this);;\n    this.declarationInfo = isTypeScriptTransformEnabled\n      ? getDeclarationInfo(tokens)\n      : EMPTY_DECLARATION_INFO;\n  }\n\n  getPrefixCode() {\n    let prefix = \"\";\n    if (this.hadExport) {\n      prefix += 'Object.defineProperty(exports, \"__esModule\", {value: true});';\n    }\n    return prefix;\n  }\n\n  getSuffixCode() {\n    if (this.enableLegacyBabel5ModuleInterop && this.hadDefaultExport && !this.hadNamedExport) {\n      return \"\\nmodule.exports = exports.default;\\n\";\n    }\n    return \"\";\n  }\n\n  process() {\n    // TypeScript `import foo = require('foo');` should always just be translated to plain require.\n    if (this.tokens.matches3(tt._import, tt.name, tt.eq)) {\n      return this.processImportEquals();\n    }\n    if (this.tokens.matches1(tt._import)) {\n      this.processImport();\n      return true;\n    }\n    if (this.tokens.matches2(tt._export, tt.eq)) {\n      this.tokens.replaceToken(\"module.exports\");\n      return true;\n    }\n    if (this.tokens.matches1(tt._export) && !this.tokens.currentToken().isType) {\n      this.hadExport = true;\n      return this.processExport();\n    }\n    if (this.tokens.matches2(tt.name, tt.postIncDec)) {\n      // Fall through to normal identifier matching if this doesn't apply.\n      if (this.processPostIncDec()) {\n        return true;\n      }\n    }\n    if (this.tokens.matches1(tt.name) || this.tokens.matches1(tt.jsxName)) {\n      return this.processIdentifier();\n    }\n    if (this.tokens.matches1(tt.eq)) {\n      return this.processAssignment();\n    }\n    if (this.tokens.matches1(tt.assign)) {\n      return this.processComplexAssignment();\n    }\n    if (this.tokens.matches1(tt.preIncDec)) {\n      return this.processPreIncDec();\n    }\n    return false;\n  }\n\n   processImportEquals() {\n    const importName = this.tokens.identifierNameAtIndex(this.tokens.currentIndex() + 1);\n    if (this.importProcessor.isTypeName(importName)) {\n      // If this name is only used as a type, elide the whole import.\n      elideImportEquals(this.tokens);\n    } else {\n      // Otherwise, switch `import` to `const`.\n      this.tokens.replaceToken(\"const\");\n    }\n    return true;\n  }\n\n  /**\n   * Transform this:\n   * import foo, {bar} from 'baz';\n   * into\n   * var _baz = require('baz'); var _baz2 = _interopRequireDefault(_baz);\n   *\n   * The import code was already generated in the import preprocessing step, so\n   * we just need to look it up.\n   */\n   processImport() {\n    if (this.tokens.matches2(tt._import, tt.parenL)) {\n      this.tokens.replaceToken(\"Promise.resolve().then(() => require\");\n      const contextId = this.tokens.currentToken().contextId;\n      if (contextId == null) {\n        throw new Error(\"Expected context ID on dynamic import invocation.\");\n      }\n      this.tokens.copyToken();\n      while (!this.tokens.matchesContextIdAndLabel(tt.parenR, contextId)) {\n        this.rootTransformer.processToken();\n      }\n      this.tokens.replaceToken(\"))\");\n      return;\n    }\n\n    const wasOnlyTypes = this.removeImportAndDetectIfType();\n\n    if (wasOnlyTypes) {\n      this.tokens.removeToken();\n    } else {\n      const path = this.tokens.stringValue();\n      this.tokens.replaceTokenTrimmingLeftWhitespace(this.importProcessor.claimImportCode(path));\n      this.tokens.appendCode(this.importProcessor.claimImportCode(path));\n    }\n    if (this.tokens.matches1(tt.semi)) {\n      this.tokens.removeToken();\n    }\n  }\n\n  /**\n   * Erase this import, and return true if it was either of the form \"import type\" or contained only\n   * \"type\" named imports. Such imports should not even do a side-effect import.\n   *\n   * The position should end at the import string.\n   */\n   removeImportAndDetectIfType() {\n    this.tokens.removeInitialToken();\n    if (\n      this.tokens.matchesContextual(ContextualKeyword._type) &&\n      !this.tokens.matches1AtIndex(this.tokens.currentIndex() + 1, tt.comma) &&\n      !this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 1, ContextualKeyword._from)\n    ) {\n      // This is an \"import type\" statement, so exit early.\n      this.removeRemainingImport();\n      return true;\n    }\n\n    if (this.tokens.matches1(tt.name) || this.tokens.matches1(tt.star)) {\n      // We have a default import or namespace import, so there must be some\n      // non-type import.\n      this.removeRemainingImport();\n      return false;\n    }\n\n    if (this.tokens.matches1(tt.string)) {\n      // This is a bare import, so we should proceed with the import.\n      return false;\n    }\n\n    let foundNonType = false;\n    while (!this.tokens.matches1(tt.string)) {\n      // Check if any named imports are of the form \"foo\" or \"foo as bar\", with\n      // no leading \"type\".\n      if ((!foundNonType && this.tokens.matches1(tt.braceL)) || this.tokens.matches1(tt.comma)) {\n        this.tokens.removeToken();\n        if (\n          this.tokens.matches2(tt.name, tt.comma) ||\n          this.tokens.matches2(tt.name, tt.braceR) ||\n          this.tokens.matches4(tt.name, tt.name, tt.name, tt.comma) ||\n          this.tokens.matches4(tt.name, tt.name, tt.name, tt.braceR)\n        ) {\n          foundNonType = true;\n        }\n      }\n      this.tokens.removeToken();\n    }\n    return !foundNonType;\n  }\n\n   removeRemainingImport() {\n    while (!this.tokens.matches1(tt.string)) {\n      this.tokens.removeToken();\n    }\n  }\n\n   processIdentifier() {\n    const token = this.tokens.currentToken();\n    if (token.shadowsGlobal) {\n      return false;\n    }\n\n    if (token.identifierRole === IdentifierRole.ObjectShorthand) {\n      return this.processObjectShorthand();\n    }\n\n    if (token.identifierRole !== IdentifierRole.Access) {\n      return false;\n    }\n    const replacement = this.importProcessor.getIdentifierReplacement(\n      this.tokens.identifierNameForToken(token),\n    );\n    if (!replacement) {\n      return false;\n    }\n    // Tolerate any number of closing parens while looking for an opening paren\n    // that indicates a function call.\n    let possibleOpenParenIndex = this.tokens.currentIndex() + 1;\n    while (\n      possibleOpenParenIndex < this.tokens.tokens.length &&\n      this.tokens.tokens[possibleOpenParenIndex].type === tt.parenR\n    ) {\n      possibleOpenParenIndex++;\n    }\n    // Avoid treating imported functions as methods of their `exports` object\n    // by using `(0, f)` when the identifier is in a paren expression. Else\n    // use `Function.prototype.call` when the identifier is a guaranteed\n    // function call. When using `call`, pass undefined as the context.\n    if (this.tokens.tokens[possibleOpenParenIndex].type === tt.parenL) {\n      if (\n        this.tokens.tokenAtRelativeIndex(1).type === tt.parenL &&\n        this.tokens.tokenAtRelativeIndex(-1).type !== tt._new\n      ) {\n        this.tokens.replaceToken(`${replacement}.call(void 0, `);\n        // Remove the old paren.\n        this.tokens.removeToken();\n        // Balance out the new paren.\n        this.rootTransformer.processBalancedCode();\n        this.tokens.copyExpectedToken(tt.parenR);\n      } else {\n        // See here: http://2ality.com/2015/12/references.html\n        this.tokens.replaceToken(`(0, ${replacement})`);\n      }\n    } else {\n      this.tokens.replaceToken(replacement);\n    }\n    return true;\n  }\n\n  processObjectShorthand() {\n    const identifier = this.tokens.identifierName();\n    const replacement = this.importProcessor.getIdentifierReplacement(identifier);\n    if (!replacement) {\n      return false;\n    }\n    this.tokens.replaceToken(`${identifier}: ${replacement}`);\n    return true;\n  }\n\n  processExport() {\n    if (\n      this.tokens.matches2(tt._export, tt._enum) ||\n      this.tokens.matches3(tt._export, tt._const, tt._enum)\n    ) {\n      // Let the TypeScript transform handle it.\n      return false;\n    }\n    if (this.tokens.matches2(tt._export, tt._default)) {\n      this.processExportDefault();\n      this.hadDefaultExport = true;\n      return true;\n    }\n    this.hadNamedExport = true;\n    if (\n      this.tokens.matches2(tt._export, tt._var) ||\n      this.tokens.matches2(tt._export, tt._let) ||\n      this.tokens.matches2(tt._export, tt._const)\n    ) {\n      this.processExportVar();\n      return true;\n    } else if (\n      this.tokens.matches2(tt._export, tt._function) ||\n      // export async function\n      this.tokens.matches3(tt._export, tt.name, tt._function)\n    ) {\n      this.processExportFunction();\n      return true;\n    } else if (\n      this.tokens.matches2(tt._export, tt._class) ||\n      this.tokens.matches3(tt._export, tt._abstract, tt._class)\n    ) {\n      this.processExportClass();\n      return true;\n    } else if (this.tokens.matches2(tt._export, tt.braceL)) {\n      this.processExportBindings();\n      return true;\n    } else if (this.tokens.matches2(tt._export, tt.star)) {\n      this.processExportStar();\n      return true;\n    } else if (\n      this.tokens.matches3(tt._export, tt.name, tt.braceL) &&\n      this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 1, ContextualKeyword._type)\n    ) {\n      // TS `export type {` case: just remove the export entirely.\n      this.tokens.removeInitialToken();\n      while (!this.tokens.matches1(tt.braceR)) {\n        this.tokens.removeToken();\n      }\n      this.tokens.removeToken();\n\n      // Remove type re-export `... } from './T'`\n      if (\n        this.tokens.matchesContextual(ContextualKeyword._from) &&\n        this.tokens.matches1AtIndex(this.tokens.currentIndex() + 1, tt.string)\n      ) {\n        this.tokens.removeToken();\n        this.tokens.removeToken();\n      }\n      return true;\n    } else {\n      throw new Error(\"Unrecognized export syntax.\");\n    }\n  }\n\n   processAssignment() {\n    const index = this.tokens.currentIndex();\n    const identifierToken = this.tokens.tokens[index - 1];\n    // If the LHS is a type identifier, this must be a declaration like `let a: b = c;`,\n    // with `b` as the identifier, so nothing needs to be done in that case.\n    if (identifierToken.isType || identifierToken.type !== tt.name) {\n      return false;\n    }\n    if (identifierToken.shadowsGlobal) {\n      return false;\n    }\n    if (index >= 2 && this.tokens.matches1AtIndex(index - 2, tt.dot)) {\n      return false;\n    }\n    if (index >= 2 && [tt._var, tt._let, tt._const].includes(this.tokens.tokens[index - 2].type)) {\n      // Declarations don't need an extra assignment. This doesn't avoid the\n      // assignment for comma-separated declarations, but it's still correct\n      // since the assignment is just redundant.\n      return false;\n    }\n    const assignmentSnippet = this.importProcessor.resolveExportBinding(\n      this.tokens.identifierNameForToken(identifierToken),\n    );\n    if (!assignmentSnippet) {\n      return false;\n    }\n    this.tokens.copyToken();\n    this.tokens.appendCode(` ${assignmentSnippet} =`);\n    return true;\n  }\n\n  /**\n   * Process something like `a += 3`, where `a` might be an exported value.\n   */\n   processComplexAssignment() {\n    const index = this.tokens.currentIndex();\n    const identifierToken = this.tokens.tokens[index - 1];\n    if (identifierToken.type !== tt.name) {\n      return false;\n    }\n    if (identifierToken.shadowsGlobal) {\n      return false;\n    }\n    if (index >= 2 && this.tokens.matches1AtIndex(index - 2, tt.dot)) {\n      return false;\n    }\n    const assignmentSnippet = this.importProcessor.resolveExportBinding(\n      this.tokens.identifierNameForToken(identifierToken),\n    );\n    if (!assignmentSnippet) {\n      return false;\n    }\n    this.tokens.appendCode(` = ${assignmentSnippet}`);\n    this.tokens.copyToken();\n    return true;\n  }\n\n  /**\n   * Process something like `++a`, where `a` might be an exported value.\n   */\n   processPreIncDec() {\n    const index = this.tokens.currentIndex();\n    const identifierToken = this.tokens.tokens[index + 1];\n    if (identifierToken.type !== tt.name) {\n      return false;\n    }\n    if (identifierToken.shadowsGlobal) {\n      return false;\n    }\n    // Ignore things like ++a.b and ++a[b] and ++a().b.\n    if (\n      index + 2 < this.tokens.tokens.length &&\n      (this.tokens.matches1AtIndex(index + 2, tt.dot) ||\n        this.tokens.matches1AtIndex(index + 2, tt.bracketL) ||\n        this.tokens.matches1AtIndex(index + 2, tt.parenL))\n    ) {\n      return false;\n    }\n    const identifierName = this.tokens.identifierNameForToken(identifierToken);\n    const assignmentSnippet = this.importProcessor.resolveExportBinding(identifierName);\n    if (!assignmentSnippet) {\n      return false;\n    }\n    this.tokens.appendCode(`${assignmentSnippet} = `);\n    this.tokens.copyToken();\n    return true;\n  }\n\n  /**\n   * Process something like `a++`, where `a` might be an exported value.\n   * This starts at the `a`, not at the `++`.\n   */\n   processPostIncDec() {\n    const index = this.tokens.currentIndex();\n    const identifierToken = this.tokens.tokens[index];\n    const operatorToken = this.tokens.tokens[index + 1];\n    if (identifierToken.type !== tt.name) {\n      return false;\n    }\n    if (identifierToken.shadowsGlobal) {\n      return false;\n    }\n    if (index >= 1 && this.tokens.matches1AtIndex(index - 1, tt.dot)) {\n      return false;\n    }\n    const identifierName = this.tokens.identifierNameForToken(identifierToken);\n    const assignmentSnippet = this.importProcessor.resolveExportBinding(identifierName);\n    if (!assignmentSnippet) {\n      return false;\n    }\n    const operatorCode = this.tokens.rawCodeForToken(operatorToken);\n    // We might also replace the identifier with something like exports.x, so\n    // do that replacement here as well.\n    const base = this.importProcessor.getIdentifierReplacement(identifierName) || identifierName;\n    if (operatorCode === \"++\") {\n      this.tokens.replaceToken(`(${base} = ${assignmentSnippet} = ${base} + 1, ${base} - 1)`);\n    } else if (operatorCode === \"--\") {\n      this.tokens.replaceToken(`(${base} = ${assignmentSnippet} = ${base} - 1, ${base} + 1)`);\n    } else {\n      throw new Error(`Unexpected operator: ${operatorCode}`);\n    }\n    this.tokens.removeToken();\n    return true;\n  }\n\n   processExportDefault() {\n    if (\n      this.tokens.matches4(tt._export, tt._default, tt._function, tt.name) ||\n      // export default async function\n      this.tokens.matches5(tt._export, tt._default, tt.name, tt._function, tt.name)\n    ) {\n      this.tokens.removeInitialToken();\n      this.tokens.removeToken();\n      // Named function export case: change it to a top-level function\n      // declaration followed by exports statement.\n      const name = this.processNamedFunction();\n      this.tokens.appendCode(` exports.default = ${name};`);\n    } else if (\n      this.tokens.matches4(tt._export, tt._default, tt._class, tt.name) ||\n      this.tokens.matches5(tt._export, tt._default, tt._abstract, tt._class, tt.name)\n    ) {\n      this.tokens.removeInitialToken();\n      this.tokens.removeToken();\n      if (this.tokens.matches1(tt._abstract)) {\n        this.tokens.removeToken();\n      }\n      const name = this.rootTransformer.processNamedClass();\n      this.tokens.appendCode(` exports.default = ${name};`);\n    } else if (this.tokens.matches3(tt._export, tt._default, tt.at)) {\n      throw new Error(\"Export default statements with decorators are not yet supported.\");\n      // After this point, this is a plain \"export default E\" statement.\n    } else if (\n      shouldElideDefaultExport(this.isTypeScriptTransformEnabled, this.tokens, this.declarationInfo)\n    ) {\n      // If the exported value is just an identifier and should be elided by TypeScript\n      // rules, then remove it entirely. It will always have the form `export default e`,\n      // where `e` is an identifier.\n      this.tokens.removeInitialToken();\n      this.tokens.removeToken();\n      this.tokens.removeToken();\n    } else if (this.reactHotLoaderTransformer) {\n      // We need to assign E to a variable. Change \"export default E\" to\n      // \"let _default; exports.default = _default = E\"\n      const defaultVarName = this.nameManager.claimFreeName(\"_default\");\n      this.tokens.replaceToken(`let ${defaultVarName}; exports.`);\n      this.tokens.copyToken();\n      this.tokens.appendCode(` = ${defaultVarName} =`);\n      this.reactHotLoaderTransformer.setExtractedDefaultExportName(defaultVarName);\n    } else {\n      // Change \"export default E\" to \"exports.default = E\"\n      this.tokens.replaceToken(\"exports.\");\n      this.tokens.copyToken();\n      this.tokens.appendCode(\" =\");\n    }\n  }\n\n  /**\n   * Transform a declaration like `export var`, `export let`, or `export const`.\n   */\n   processExportVar() {\n    if (this.isSimpleExportVar()) {\n      this.processSimpleExportVar();\n    } else {\n      this.processComplexExportVar();\n    }\n  }\n\n  /**\n   * Determine if the export is of the form:\n   * export var/let/const [varName] = [expr];\n   * In other words, determine if function name inference might apply.\n   */\n   isSimpleExportVar() {\n    let tokenIndex = this.tokens.currentIndex();\n    // export\n    tokenIndex++;\n    // var/let/const\n    tokenIndex++;\n    if (!this.tokens.matches1AtIndex(tokenIndex, tt.name)) {\n      return false;\n    }\n    tokenIndex++;\n    while (tokenIndex < this.tokens.tokens.length && this.tokens.tokens[tokenIndex].isType) {\n      tokenIndex++;\n    }\n    if (!this.tokens.matches1AtIndex(tokenIndex, tt.eq)) {\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * Transform an `export var` declaration initializing a single variable.\n   *\n   * For example, this:\n   * export const f = () => {};\n   * becomes this:\n   * const f = () => {}; exports.f = f;\n   *\n   * The variable is unused (e.g. exports.f has the true value of the export).\n   * We need to produce an assignment of this form so that the function will\n   * have an inferred name of \"f\", which wouldn't happen in the more general\n   * case below.\n   */\n   processSimpleExportVar() {\n    // export\n    this.tokens.removeInitialToken();\n    // var/let/const\n    this.tokens.copyToken();\n    const varName = this.tokens.identifierName();\n    // x: number  ->  x\n    while (!this.tokens.matches1(tt.eq)) {\n      this.rootTransformer.processToken();\n    }\n    const endIndex = this.tokens.currentToken().rhsEndIndex;\n    if (endIndex == null) {\n      throw new Error(\"Expected = token with an end index.\");\n    }\n    while (this.tokens.currentIndex() < endIndex) {\n      this.rootTransformer.processToken();\n    }\n    this.tokens.appendCode(`; exports.${varName} = ${varName}`);\n  }\n\n  /**\n   * Transform normal declaration exports, including handling destructuring.\n   * For example, this:\n   * export const {x: [a = 2, b], c} = d;\n   * becomes this:\n   * ({x: [exports.a = 2, exports.b], c: exports.c} = d;)\n   */\n   processComplexExportVar() {\n    this.tokens.removeInitialToken();\n    this.tokens.removeToken();\n    const needsParens = this.tokens.matches1(tt.braceL);\n    if (needsParens) {\n      this.tokens.appendCode(\"(\");\n    }\n\n    let depth = 0;\n    while (true) {\n      if (\n        this.tokens.matches1(tt.braceL) ||\n        this.tokens.matches1(tt.dollarBraceL) ||\n        this.tokens.matches1(tt.bracketL)\n      ) {\n        depth++;\n        this.tokens.copyToken();\n      } else if (this.tokens.matches1(tt.braceR) || this.tokens.matches1(tt.bracketR)) {\n        depth--;\n        this.tokens.copyToken();\n      } else if (\n        depth === 0 &&\n        !this.tokens.matches1(tt.name) &&\n        !this.tokens.currentToken().isType\n      ) {\n        break;\n      } else if (this.tokens.matches1(tt.eq)) {\n        // Default values might have assignments in the RHS that we want to ignore, so skip past\n        // them.\n        const endIndex = this.tokens.currentToken().rhsEndIndex;\n        if (endIndex == null) {\n          throw new Error(\"Expected = token with an end index.\");\n        }\n        while (this.tokens.currentIndex() < endIndex) {\n          this.rootTransformer.processToken();\n        }\n      } else {\n        const token = this.tokens.currentToken();\n        if (isDeclaration(token)) {\n          const name = this.tokens.identifierName();\n          let replacement = this.importProcessor.getIdentifierReplacement(name);\n          if (replacement === null) {\n            throw new Error(`Expected a replacement for ${name} in \\`export var\\` syntax.`);\n          }\n          if (isObjectShorthandDeclaration(token)) {\n            replacement = `${name}: ${replacement}`;\n          }\n          this.tokens.replaceToken(replacement);\n        } else {\n          this.rootTransformer.processToken();\n        }\n      }\n    }\n\n    if (needsParens) {\n      // Seek to the end of the RHS.\n      const endIndex = this.tokens.currentToken().rhsEndIndex;\n      if (endIndex == null) {\n        throw new Error(\"Expected = token with an end index.\");\n      }\n      while (this.tokens.currentIndex() < endIndex) {\n        this.rootTransformer.processToken();\n      }\n      this.tokens.appendCode(\")\");\n    }\n  }\n\n  /**\n   * Transform this:\n   * export function foo() {}\n   * into this:\n   * function foo() {} exports.foo = foo;\n   */\n   processExportFunction() {\n    this.tokens.replaceToken(\"\");\n    const name = this.processNamedFunction();\n    this.tokens.appendCode(` exports.${name} = ${name};`);\n  }\n\n  /**\n   * Skip past a function with a name and return that name.\n   */\n   processNamedFunction() {\n    if (this.tokens.matches1(tt._function)) {\n      this.tokens.copyToken();\n    } else if (this.tokens.matches2(tt.name, tt._function)) {\n      if (!this.tokens.matchesContextual(ContextualKeyword._async)) {\n        throw new Error(\"Expected async keyword in function export.\");\n      }\n      this.tokens.copyToken();\n      this.tokens.copyToken();\n    }\n    if (this.tokens.matches1(tt.star)) {\n      this.tokens.copyToken();\n    }\n    if (!this.tokens.matches1(tt.name)) {\n      throw new Error(\"Expected identifier for exported function name.\");\n    }\n    const name = this.tokens.identifierName();\n    this.tokens.copyToken();\n    if (this.tokens.currentToken().isType) {\n      this.tokens.removeInitialToken();\n      while (this.tokens.currentToken().isType) {\n        this.tokens.removeToken();\n      }\n    }\n    this.tokens.copyExpectedToken(tt.parenL);\n    this.rootTransformer.processBalancedCode();\n    this.tokens.copyExpectedToken(tt.parenR);\n    this.rootTransformer.processPossibleTypeRange();\n    this.tokens.copyExpectedToken(tt.braceL);\n    this.rootTransformer.processBalancedCode();\n    this.tokens.copyExpectedToken(tt.braceR);\n    return name;\n  }\n\n  /**\n   * Transform this:\n   * export class A {}\n   * into this:\n   * class A {} exports.A = A;\n   */\n   processExportClass() {\n    this.tokens.removeInitialToken();\n    if (this.tokens.matches1(tt._abstract)) {\n      this.tokens.removeToken();\n    }\n    const name = this.rootTransformer.processNamedClass();\n    this.tokens.appendCode(` exports.${name} = ${name};`);\n  }\n\n  /**\n   * Transform this:\n   * export {a, b as c};\n   * into this:\n   * exports.a = a; exports.c = b;\n   *\n   * OR\n   *\n   * Transform this:\n   * export {a, b as c} from './foo';\n   * into the pre-generated Object.defineProperty code from the ImportProcessor.\n   *\n   * For the first case, if the TypeScript transform is enabled, we need to skip\n   * exports that are only defined as types.\n   */\n   processExportBindings() {\n    this.tokens.removeInitialToken();\n    this.tokens.removeToken();\n\n    const exportStatements = [];\n    while (true) {\n      if (this.tokens.matches1(tt.braceR)) {\n        this.tokens.removeToken();\n        break;\n      }\n\n      const localName = this.tokens.identifierName();\n      let exportedName;\n      this.tokens.removeToken();\n      if (this.tokens.matchesContextual(ContextualKeyword._as)) {\n        this.tokens.removeToken();\n        exportedName = this.tokens.identifierName();\n        this.tokens.removeToken();\n      } else {\n        exportedName = localName;\n      }\n      if (!this.shouldElideExportedIdentifier(localName)) {\n        const newLocalName = this.importProcessor.getIdentifierReplacement(localName);\n        exportStatements.push(`exports.${exportedName} = ${newLocalName || localName};`);\n      }\n\n      if (this.tokens.matches1(tt.braceR)) {\n        this.tokens.removeToken();\n        break;\n      }\n      if (this.tokens.matches2(tt.comma, tt.braceR)) {\n        this.tokens.removeToken();\n        this.tokens.removeToken();\n        break;\n      } else if (this.tokens.matches1(tt.comma)) {\n        this.tokens.removeToken();\n      } else {\n        throw new Error(`Unexpected token: ${JSON.stringify(this.tokens.currentToken())}`);\n      }\n    }\n\n    if (this.tokens.matchesContextual(ContextualKeyword._from)) {\n      // This is an export...from, so throw away the normal named export code\n      // and use the Object.defineProperty code from ImportProcessor.\n      this.tokens.removeToken();\n      const path = this.tokens.stringValue();\n      this.tokens.replaceTokenTrimmingLeftWhitespace(this.importProcessor.claimImportCode(path));\n    } else {\n      // This is a normal named export, so use that.\n      this.tokens.appendCode(exportStatements.join(\" \"));\n    }\n\n    if (this.tokens.matches1(tt.semi)) {\n      this.tokens.removeToken();\n    }\n  }\n\n   processExportStar() {\n    this.tokens.removeInitialToken();\n    while (!this.tokens.matches1(tt.string)) {\n      this.tokens.removeToken();\n    }\n    const path = this.tokens.stringValue();\n    this.tokens.replaceTokenTrimmingLeftWhitespace(this.importProcessor.claimImportCode(path));\n    if (this.tokens.matches1(tt.semi)) {\n      this.tokens.removeToken();\n    }\n  }\n\n   shouldElideExportedIdentifier(name) {\n    return this.isTypeScriptTransformEnabled && !this.declarationInfo.valueDeclarations.has(name);\n  }\n}\n","\n\nimport {ContextualKeyword} from \"../parser/tokenizer/keywords\";\nimport {TokenType as tt} from \"../parser/tokenizer/types\";\n\nimport elideImportEquals from \"../util/elideImportEquals\";\nimport getDeclarationInfo, {\n\n  EMPTY_DECLARATION_INFO,\n} from \"../util/getDeclarationInfo\";\nimport {getNonTypeIdentifiers} from \"../util/getNonTypeIdentifiers\";\nimport shouldElideDefaultExport from \"../util/shouldElideDefaultExport\";\n\nimport Transformer from \"./Transformer\";\n\n/**\n * Class for editing import statements when we are keeping the code as ESM. We still need to remove\n * type-only imports in TypeScript and Flow.\n */\nexport default class ESMImportTransformer extends Transformer {\n  \n  \n\n  constructor(\n     tokens,\n     nameManager,\n     reactHotLoaderTransformer,\n     isTypeScriptTransformEnabled,\n    options,\n  ) {\n    super();this.tokens = tokens;this.nameManager = nameManager;this.reactHotLoaderTransformer = reactHotLoaderTransformer;this.isTypeScriptTransformEnabled = isTypeScriptTransformEnabled;;\n    this.nonTypeIdentifiers = isTypeScriptTransformEnabled\n      ? getNonTypeIdentifiers(tokens, options)\n      : new Set();\n    this.declarationInfo = isTypeScriptTransformEnabled\n      ? getDeclarationInfo(tokens)\n      : EMPTY_DECLARATION_INFO;\n  }\n\n  process() {\n    // TypeScript `import foo = require('foo');` should always just be translated to plain require.\n    if (this.tokens.matches3(tt._import, tt.name, tt.eq)) {\n      return this.processImportEquals();\n    }\n    if (this.tokens.matches2(tt._export, tt.eq)) {\n      this.tokens.replaceToken(\"module.exports\");\n      return true;\n    }\n    if (this.tokens.matches1(tt._import)) {\n      return this.processImport();\n    }\n    if (this.tokens.matches2(tt._export, tt._default)) {\n      return this.processExportDefault();\n    }\n    if (this.tokens.matches2(tt._export, tt.braceL)) {\n      return this.processNamedExports();\n    }\n    if (\n      this.tokens.matches3(tt._export, tt.name, tt.braceL) &&\n      this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 1, ContextualKeyword._type)\n    ) {\n      // TS `export type {` case: just remove the export entirely.\n      this.tokens.removeInitialToken();\n      while (!this.tokens.matches1(tt.braceR)) {\n        this.tokens.removeToken();\n      }\n      this.tokens.removeToken();\n\n      // Remove type re-export `... } from './T'`\n      if (\n        this.tokens.matchesContextual(ContextualKeyword._from) &&\n        this.tokens.matches1AtIndex(this.tokens.currentIndex() + 1, tt.string)\n      ) {\n        this.tokens.removeToken();\n        this.tokens.removeToken();\n      }\n      return true;\n    }\n    return false;\n  }\n\n   processImportEquals() {\n    const importName = this.tokens.identifierNameAtIndex(this.tokens.currentIndex() + 1);\n    if (this.isTypeName(importName)) {\n      // If this name is only used as a type, elide the whole import.\n      elideImportEquals(this.tokens);\n    } else {\n      // Otherwise, switch `import` to `const`.\n      this.tokens.replaceToken(\"const\");\n    }\n    return true;\n  }\n\n   processImport() {\n    if (this.tokens.matches2(tt._import, tt.parenL)) {\n      // Dynamic imports don't need to be transformed.\n      return false;\n    }\n\n    const snapshot = this.tokens.snapshot();\n    const allImportsRemoved = this.removeImportTypeBindings();\n    if (allImportsRemoved) {\n      this.tokens.restoreToSnapshot(snapshot);\n      while (!this.tokens.matches1(tt.string)) {\n        this.tokens.removeToken();\n      }\n      this.tokens.removeToken();\n      if (this.tokens.matches1(tt.semi)) {\n        this.tokens.removeToken();\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Remove type bindings from this import, leaving the rest of the import intact.\n   *\n   * Return true if this import was ONLY types, and thus is eligible for removal. This will bail out\n   * of the replacement operation, so we can return early here.\n   */\n   removeImportTypeBindings() {\n    this.tokens.copyExpectedToken(tt._import);\n    if (\n      this.tokens.matchesContextual(ContextualKeyword._type) &&\n      !this.tokens.matches1AtIndex(this.tokens.currentIndex() + 1, tt.comma) &&\n      !this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 1, ContextualKeyword._from)\n    ) {\n      // This is an \"import type\" statement, so exit early.\n      return true;\n    }\n\n    if (this.tokens.matches1(tt.string)) {\n      // This is a bare import, so we should proceed with the import.\n      this.tokens.copyToken();\n      return false;\n    }\n\n    let foundNonTypeImport = false;\n\n    if (this.tokens.matches1(tt.name)) {\n      if (this.isTypeName(this.tokens.identifierName())) {\n        this.tokens.removeToken();\n        if (this.tokens.matches1(tt.comma)) {\n          this.tokens.removeToken();\n        }\n      } else {\n        foundNonTypeImport = true;\n        this.tokens.copyToken();\n        if (this.tokens.matches1(tt.comma)) {\n          this.tokens.copyToken();\n        }\n      }\n    }\n\n    if (this.tokens.matches1(tt.star)) {\n      if (this.isTypeName(this.tokens.identifierNameAtIndex(this.tokens.currentIndex() + 2))) {\n        this.tokens.removeToken();\n        this.tokens.removeToken();\n        this.tokens.removeToken();\n      } else {\n        foundNonTypeImport = true;\n        this.tokens.copyExpectedToken(tt.star);\n        this.tokens.copyExpectedToken(tt.name);\n        this.tokens.copyExpectedToken(tt.name);\n      }\n    } else if (this.tokens.matches1(tt.braceL)) {\n      this.tokens.copyToken();\n      while (!this.tokens.matches1(tt.braceR)) {\n        if (\n          this.tokens.matches3(tt.name, tt.name, tt.comma) ||\n          this.tokens.matches3(tt.name, tt.name, tt.braceR)\n        ) {\n          // type foo\n          this.tokens.removeToken();\n          this.tokens.removeToken();\n          if (this.tokens.matches1(tt.comma)) {\n            this.tokens.removeToken();\n          }\n        } else if (\n          this.tokens.matches5(tt.name, tt.name, tt.name, tt.name, tt.comma) ||\n          this.tokens.matches5(tt.name, tt.name, tt.name, tt.name, tt.braceR)\n        ) {\n          // type foo as bar\n          this.tokens.removeToken();\n          this.tokens.removeToken();\n          this.tokens.removeToken();\n          this.tokens.removeToken();\n          if (this.tokens.matches1(tt.comma)) {\n            this.tokens.removeToken();\n          }\n        } else if (\n          this.tokens.matches2(tt.name, tt.comma) ||\n          this.tokens.matches2(tt.name, tt.braceR)\n        ) {\n          // foo\n          if (this.isTypeName(this.tokens.identifierName())) {\n            this.tokens.removeToken();\n            if (this.tokens.matches1(tt.comma)) {\n              this.tokens.removeToken();\n            }\n          } else {\n            foundNonTypeImport = true;\n            this.tokens.copyToken();\n            if (this.tokens.matches1(tt.comma)) {\n              this.tokens.copyToken();\n            }\n          }\n        } else if (\n          this.tokens.matches4(tt.name, tt.name, tt.name, tt.comma) ||\n          this.tokens.matches4(tt.name, tt.name, tt.name, tt.braceR)\n        ) {\n          // foo as bar\n          if (this.isTypeName(this.tokens.identifierNameAtIndex(this.tokens.currentIndex() + 2))) {\n            this.tokens.removeToken();\n            this.tokens.removeToken();\n            this.tokens.removeToken();\n            if (this.tokens.matches1(tt.comma)) {\n              this.tokens.removeToken();\n            }\n          } else {\n            foundNonTypeImport = true;\n            this.tokens.copyToken();\n            this.tokens.copyToken();\n            this.tokens.copyToken();\n            if (this.tokens.matches1(tt.comma)) {\n              this.tokens.copyToken();\n            }\n          }\n        } else {\n          throw new Error(\"Unexpected import form.\");\n        }\n      }\n      this.tokens.copyExpectedToken(tt.braceR);\n    }\n\n    return !foundNonTypeImport;\n  }\n\n   isTypeName(name) {\n    return this.isTypeScriptTransformEnabled && !this.nonTypeIdentifiers.has(name);\n  }\n\n   processExportDefault() {\n    if (\n      shouldElideDefaultExport(this.isTypeScriptTransformEnabled, this.tokens, this.declarationInfo)\n    ) {\n      // If the exported value is just an identifier and should be elided by TypeScript\n      // rules, then remove it entirely. It will always have the form `export default e`,\n      // where `e` is an identifier.\n      this.tokens.removeInitialToken();\n      this.tokens.removeToken();\n      this.tokens.removeToken();\n      return true;\n    }\n\n    const alreadyHasName =\n      this.tokens.matches4(tt._export, tt._default, tt._function, tt.name) ||\n      // export default async function\n      this.tokens.matches5(tt._export, tt._default, tt.name, tt._function, tt.name) ||\n      this.tokens.matches4(tt._export, tt._default, tt._class, tt.name) ||\n      this.tokens.matches5(tt._export, tt._default, tt._abstract, tt._class, tt.name);\n\n    if (!alreadyHasName && this.reactHotLoaderTransformer) {\n      // This is a plain \"export default E\" statement and we need to assign E to a variable.\n      // Change \"export default E\" to \"let _default; export default _default = E\"\n      const defaultVarName = this.nameManager.claimFreeName(\"_default\");\n      this.tokens.replaceToken(`let ${defaultVarName}; export`);\n      this.tokens.copyToken();\n      this.tokens.appendCode(` ${defaultVarName} =`);\n      this.reactHotLoaderTransformer.setExtractedDefaultExportName(defaultVarName);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * In TypeScript, we need to remove named exports that were never declared or only declared as a\n   * type.\n   */\n   processNamedExports() {\n    if (!this.isTypeScriptTransformEnabled) {\n      return false;\n    }\n    this.tokens.copyExpectedToken(tt._export);\n    this.tokens.copyExpectedToken(tt.braceL);\n\n    while (!this.tokens.matches1(tt.braceR)) {\n      if (!this.tokens.matches1(tt.name)) {\n        throw new Error(\"Expected identifier at the start of named export.\");\n      }\n      if (this.shouldElideExportedName(this.tokens.identifierName())) {\n        while (\n          !this.tokens.matches1(tt.comma) &&\n          !this.tokens.matches1(tt.braceR) &&\n          !this.tokens.isAtEnd()\n        ) {\n          this.tokens.removeToken();\n        }\n        if (this.tokens.matches1(tt.comma)) {\n          this.tokens.removeToken();\n        }\n      } else {\n        while (\n          !this.tokens.matches1(tt.comma) &&\n          !this.tokens.matches1(tt.braceR) &&\n          !this.tokens.isAtEnd()\n        ) {\n          this.tokens.copyToken();\n        }\n        if (this.tokens.matches1(tt.comma)) {\n          this.tokens.copyToken();\n        }\n      }\n    }\n    this.tokens.copyExpectedToken(tt.braceR);\n    return true;\n  }\n\n  /**\n   * ESM elides all imports with the rule that we only elide if we see that it's\n   * a type and never see it as a value. This is in contract to CJS, which\n   * elides imports that are completely unknown.\n   */\n   shouldElideExportedName(name) {\n    return (\n      this.isTypeScriptTransformEnabled &&\n      this.declarationInfo.typeDeclarations.has(name) &&\n      !this.declarationInfo.valueDeclarations.has(name)\n    );\n  }\n}\n","\n\nimport Transformer from \"./Transformer\";\n\nexport default class FlowTransformer extends Transformer {\n  constructor( rootTransformer,  tokens) {\n    super();this.rootTransformer = rootTransformer;this.tokens = tokens;;\n  }\n\n  process() {\n    return (\n      this.rootTransformer.processPossibleArrowParamEnd() ||\n      this.rootTransformer.processPossibleAsyncArrowWithTypeParams() ||\n      this.rootTransformer.processPossibleTypeRange()\n    );\n  }\n}\n","import {TokenType as tt} from \"../parser/tokenizer/types\";\n\nimport Transformer from \"./Transformer\";\n\nexport default class NumericSeparatorTransformer extends Transformer {\n  constructor( tokens) {\n    super();this.tokens = tokens;;\n  }\n\n  process() {\n    if (this.tokens.matches1(tt.num)) {\n      const code = this.tokens.currentTokenCode();\n      if (code.includes(\"_\")) {\n        this.tokens.replaceToken(code.replace(/_/g, \"\"));\n        return true;\n      }\n    }\n    return false;\n  }\n}\n","\nimport {TokenType as tt} from \"../parser/tokenizer/types\";\n\nimport Transformer from \"./Transformer\";\n\nexport default class OptionalCatchBindingTransformer extends Transformer {\n  constructor( tokens,  nameManager) {\n    super();this.tokens = tokens;this.nameManager = nameManager;;\n  }\n\n  process() {\n    if (this.tokens.matches2(tt._catch, tt.braceL)) {\n      this.tokens.copyToken();\n      this.tokens.appendCode(` (${this.nameManager.claimFreeName(\"e\")})`);\n      return true;\n    }\n    return false;\n  }\n}\n","\nimport {TokenType as tt} from \"../parser/tokenizer/types\";\n\nimport Transformer from \"./Transformer\";\n\n/**\n * Transformer supporting the optional chaining and nullish coalescing operators.\n *\n * Tech plan here:\n * https://github.com/alangpierce/sucrase/wiki/Sucrase-Optional-Chaining-and-Nullish-Coalescing-Technical-Plan\n *\n * The prefix and suffix code snippets are handled by TokenProcessor, and this transformer handles\n * the operators themselves.\n */\nexport default class OptionalChainingNullishTransformer extends Transformer {\n  constructor( tokens,  nameManager) {\n    super();this.tokens = tokens;this.nameManager = nameManager;;\n  }\n\n  process() {\n    if (this.tokens.matches1(tt.nullishCoalescing)) {\n      const token = this.tokens.currentToken();\n      if (this.tokens.tokens[token.nullishStartIndex].isAsyncOperation) {\n        this.tokens.replaceTokenTrimmingLeftWhitespace(\", async () => (\");\n      } else {\n        this.tokens.replaceTokenTrimmingLeftWhitespace(\", () => (\");\n      }\n      return true;\n    }\n    if (this.tokens.matches1(tt._delete)) {\n      const nextToken = this.tokens.tokenAtRelativeIndex(1);\n      if (nextToken.isOptionalChainStart) {\n        this.tokens.removeInitialToken();\n        return true;\n      }\n    }\n    const token = this.tokens.currentToken();\n    const chainStart = token.subscriptStartIndex;\n    if (\n      chainStart != null &&\n      this.tokens.tokens[chainStart].isOptionalChainStart &&\n      // Super subscripts can't be optional (since super is never null/undefined), and the syntax\n      // relies on the subscript being intact, so leave this token alone.\n      this.tokens.tokenAtRelativeIndex(-1).type !== tt._super\n    ) {\n      const param = this.nameManager.claimFreeName(\"_\");\n      let arrowStartSnippet;\n      if (\n        chainStart > 0 &&\n        this.tokens.matches1AtIndex(chainStart - 1, tt._delete) &&\n        this.isLastSubscriptInChain()\n      ) {\n        // Delete operations are special: we already removed the delete keyword, and to still\n        // perform a delete, we need to insert a delete in the very last part of the chain, which\n        // in correct code will always be a property access.\n        arrowStartSnippet = `${param} => delete ${param}`;\n      } else {\n        arrowStartSnippet = `${param} => ${param}`;\n      }\n      if (this.tokens.tokens[chainStart].isAsyncOperation) {\n        arrowStartSnippet = `async ${arrowStartSnippet}`;\n      }\n      if (\n        this.tokens.matches2(tt.questionDot, tt.parenL) ||\n        this.tokens.matches2(tt.questionDot, tt.lessThan)\n      ) {\n        if (this.justSkippedSuper()) {\n          this.tokens.appendCode(\".bind(this)\");\n        }\n        this.tokens.replaceTokenTrimmingLeftWhitespace(`, 'optionalCall', ${arrowStartSnippet}`);\n      } else if (this.tokens.matches2(tt.questionDot, tt.bracketL)) {\n        this.tokens.replaceTokenTrimmingLeftWhitespace(`, 'optionalAccess', ${arrowStartSnippet}`);\n      } else if (this.tokens.matches1(tt.questionDot)) {\n        this.tokens.replaceTokenTrimmingLeftWhitespace(`, 'optionalAccess', ${arrowStartSnippet}.`);\n      } else if (this.tokens.matches1(tt.dot)) {\n        this.tokens.replaceTokenTrimmingLeftWhitespace(`, 'access', ${arrowStartSnippet}.`);\n      } else if (this.tokens.matches1(tt.bracketL)) {\n        this.tokens.replaceTokenTrimmingLeftWhitespace(`, 'access', ${arrowStartSnippet}[`);\n      } else if (this.tokens.matches1(tt.parenL)) {\n        if (this.justSkippedSuper()) {\n          this.tokens.appendCode(\".bind(this)\");\n        }\n        this.tokens.replaceTokenTrimmingLeftWhitespace(`, 'call', ${arrowStartSnippet}(`);\n      } else {\n        throw new Error(\"Unexpected subscript operator in optional chain.\");\n      }\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Determine if the current token is the last of its chain, so that we know whether it's eligible\n   * to have a delete op inserted.\n   *\n   * We can do this by walking forward until we determine one way or another. Each\n   * isOptionalChainStart token must be paired with exactly one isOptionalChainEnd token after it in\n   * a nesting way, so we can track depth and walk to the end of the chain (the point where the\n   * depth goes negative) and see if any other subscript token is after us in the chain.\n   */\n  isLastSubscriptInChain() {\n    let depth = 0;\n    for (let i = this.tokens.currentIndex() + 1; ; i++) {\n      if (i >= this.tokens.tokens.length) {\n        throw new Error(\"Reached the end of the code while finding the end of the access chain.\");\n      }\n      if (this.tokens.tokens[i].isOptionalChainStart) {\n        depth++;\n      } else if (this.tokens.tokens[i].isOptionalChainEnd) {\n        depth--;\n      }\n      if (depth < 0) {\n        return true;\n      }\n\n      // This subscript token is a later one in the same chain.\n      if (depth === 0 && this.tokens.tokens[i].subscriptStartIndex != null) {\n        return false;\n      }\n    }\n  }\n\n  /**\n   * Determine if we are the open-paren in an expression like super.a()?.b.\n   *\n   * We can do this by walking backward to find the previous subscript. If that subscript was\n   * preceded by a super, then we must be the subscript after it, so if this is a call expression,\n   * we'll need to attach the right context.\n   */\n  justSkippedSuper() {\n    let depth = 0;\n    let index = this.tokens.currentIndex() - 1;\n    while (true) {\n      if (index < 0) {\n        throw new Error(\n          \"Reached the start of the code while finding the start of the access chain.\",\n        );\n      }\n      if (this.tokens.tokens[index].isOptionalChainStart) {\n        depth--;\n      } else if (this.tokens.tokens[index].isOptionalChainEnd) {\n        depth++;\n      }\n      if (depth < 0) {\n        return false;\n      }\n\n      // This subscript token is a later one in the same chain.\n      if (depth === 0 && this.tokens.tokens[index].subscriptStartIndex != null) {\n        return this.tokens.tokens[index - 1].type === tt._super;\n      }\n      index--;\n    }\n  }\n}\n","\n\nimport {IdentifierRole} from \"../parser/tokenizer\";\nimport {TokenType as tt} from \"../parser/tokenizer/types\";\n\n\nimport Transformer from \"./Transformer\";\n\n/**\n * Implementation of babel-plugin-transform-react-display-name, which adds a\n * display name to usages of React.createClass and createReactClass.\n */\nexport default class ReactDisplayNameTransformer extends Transformer {\n  constructor(\n     rootTransformer,\n     tokens,\n     importProcessor,\n     options,\n  ) {\n    super();this.rootTransformer = rootTransformer;this.tokens = tokens;this.importProcessor = importProcessor;this.options = options;;\n  }\n\n  process() {\n    const startIndex = this.tokens.currentIndex();\n    if (this.tokens.identifierName() === \"createReactClass\") {\n      const newName =\n        this.importProcessor && this.importProcessor.getIdentifierReplacement(\"createReactClass\");\n      if (newName) {\n        this.tokens.replaceToken(`(0, ${newName})`);\n      } else {\n        this.tokens.copyToken();\n      }\n      this.tryProcessCreateClassCall(startIndex);\n      return true;\n    }\n    if (\n      this.tokens.matches3(tt.name, tt.dot, tt.name) &&\n      this.tokens.identifierName() === \"React\" &&\n      this.tokens.identifierNameAtIndex(this.tokens.currentIndex() + 2) === \"createClass\"\n    ) {\n      const newName = this.importProcessor\n        ? this.importProcessor.getIdentifierReplacement(\"React\") || \"React\"\n        : \"React\";\n      if (newName) {\n        this.tokens.replaceToken(newName);\n        this.tokens.copyToken();\n        this.tokens.copyToken();\n      } else {\n        this.tokens.copyToken();\n        this.tokens.copyToken();\n        this.tokens.copyToken();\n      }\n      this.tryProcessCreateClassCall(startIndex);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * This is called with the token position at the open-paren.\n   */\n   tryProcessCreateClassCall(startIndex) {\n    const displayName = this.findDisplayName(startIndex);\n    if (!displayName) {\n      return;\n    }\n\n    if (this.classNeedsDisplayName()) {\n      this.tokens.copyExpectedToken(tt.parenL);\n      this.tokens.copyExpectedToken(tt.braceL);\n      this.tokens.appendCode(`displayName: '${displayName}',`);\n      this.rootTransformer.processBalancedCode();\n      this.tokens.copyExpectedToken(tt.braceR);\n      this.tokens.copyExpectedToken(tt.parenR);\n    }\n  }\n\n   findDisplayName(startIndex) {\n    if (startIndex < 2) {\n      return null;\n    }\n    if (this.tokens.matches2AtIndex(startIndex - 2, tt.name, tt.eq)) {\n      // This is an assignment (or declaration) and the LHS is either an identifier or a member\n      // expression ending in an identifier, so use that identifier name.\n      return this.tokens.identifierNameAtIndex(startIndex - 2);\n    }\n    if (\n      startIndex >= 2 &&\n      this.tokens.tokens[startIndex - 2].identifierRole === IdentifierRole.ObjectKey\n    ) {\n      // This is an object literal value.\n      return this.tokens.identifierNameAtIndex(startIndex - 2);\n    }\n    if (this.tokens.matches2AtIndex(startIndex - 2, tt._export, tt._default)) {\n      return this.getDisplayNameFromFilename();\n    }\n    return null;\n  }\n\n   getDisplayNameFromFilename() {\n    const filePath = this.options.filePath || \"unknown\";\n    const pathSegments = filePath.split(\"/\");\n    const filename = pathSegments[pathSegments.length - 1];\n    const dotIndex = filename.lastIndexOf(\".\");\n    const baseFilename = dotIndex === -1 ? filename : filename.slice(0, dotIndex);\n    if (baseFilename === \"index\" && pathSegments[pathSegments.length - 2]) {\n      return pathSegments[pathSegments.length - 2];\n    } else {\n      return baseFilename;\n    }\n  }\n\n  /**\n   * We only want to add a display name when this is a function call containing\n   * one argument, which is an object literal without `displayName` as an\n   * existing key.\n   */\n   classNeedsDisplayName() {\n    let index = this.tokens.currentIndex();\n    if (!this.tokens.matches2(tt.parenL, tt.braceL)) {\n      return false;\n    }\n    // The block starts on the {, and we expect any displayName key to be in\n    // that context. We need to ignore other other contexts to avoid matching\n    // nested displayName keys.\n    const objectStartIndex = index + 1;\n    const objectContextId = this.tokens.tokens[objectStartIndex].contextId;\n    if (objectContextId == null) {\n      throw new Error(\"Expected non-null context ID on object open-brace.\");\n    }\n\n    for (; index < this.tokens.tokens.length; index++) {\n      const token = this.tokens.tokens[index];\n      if (token.type === tt.braceR && token.contextId === objectContextId) {\n        index++;\n        break;\n      }\n\n      if (\n        this.tokens.identifierNameAtIndex(index) === \"displayName\" &&\n        this.tokens.tokens[index].identifierRole === IdentifierRole.ObjectKey &&\n        token.contextId === objectContextId\n      ) {\n        // We found a displayName key, so bail out.\n        return false;\n      }\n    }\n\n    if (index === this.tokens.tokens.length) {\n      throw new Error(\"Unexpected end of input when processing React class.\");\n    }\n\n    // If we got this far, we know we have createClass with an object with no\n    // display name, so we want to proceed as long as that was the only argument.\n    return (\n      this.tokens.matches1AtIndex(index, tt.parenR) ||\n      this.tokens.matches2AtIndex(index, tt.comma, tt.parenR)\n    );\n  }\n}\n","import {IdentifierRole, isTopLevelDeclaration} from \"../parser/tokenizer\";\n\nimport Transformer from \"./Transformer\";\n\nexport default class ReactHotLoaderTransformer extends Transformer {\n   __init() {this.extractedDefaultExportName = null}\n\n  constructor( tokens,  filePath) {\n    super();this.tokens = tokens;this.filePath = filePath;ReactHotLoaderTransformer.prototype.__init.call(this);;\n  }\n\n  setExtractedDefaultExportName(extractedDefaultExportName) {\n    this.extractedDefaultExportName = extractedDefaultExportName;\n  }\n\n  getPrefixCode() {\n    return `\n      (function () {\n        var enterModule = require('react-hot-loader').enterModule;\n        enterModule && enterModule(module);\n      })();`\n      .replace(/\\s+/g, \" \")\n      .trim();\n  }\n\n  getSuffixCode() {\n    const topLevelNames = new Set();\n    for (const token of this.tokens.tokens) {\n      if (\n        !token.isType &&\n        isTopLevelDeclaration(token) &&\n        token.identifierRole !== IdentifierRole.ImportDeclaration\n      ) {\n        topLevelNames.add(this.tokens.identifierNameForToken(token));\n      }\n    }\n    const namesToRegister = Array.from(topLevelNames).map((name) => ({\n      variableName: name,\n      uniqueLocalName: name,\n    }));\n    if (this.extractedDefaultExportName) {\n      namesToRegister.push({\n        variableName: this.extractedDefaultExportName,\n        uniqueLocalName: \"default\",\n      });\n    }\n    return `\n;(function () {\n  var reactHotLoader = require('react-hot-loader').default;\n  var leaveModule = require('react-hot-loader').leaveModule;\n  if (!reactHotLoader) {\n    return;\n  }\n${namesToRegister\n  .map(\n    ({variableName, uniqueLocalName}) =>\n      `  reactHotLoader.register(${variableName}, \"${uniqueLocalName}\", ${JSON.stringify(\n        this.filePath || \"\",\n      )});`,\n  )\n  .join(\"\\n\")}\n  leaveModule(module);\n})();`;\n  }\n\n  process() {\n    return false;\n  }\n}\n","import {IS_IDENTIFIER_CHAR, IS_IDENTIFIER_START} from \"../parser/util/identifier\";\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Lexical_grammar\n// Hard-code a list of reserved words rather than trying to use keywords or contextual keywords\n// from the parser, since currently there are various exceptions, like `package` being reserved\n// but unused and various contextual keywords being reserved. Note that we assume that all code\n// compiled by Sucrase is in a module, so strict mode words and await are all considered reserved\n// here.\nconst RESERVED_WORDS = new Set([\n  // Reserved keywords as of ECMAScript 2015\n  \"break\",\n  \"case\",\n  \"catch\",\n  \"class\",\n  \"const\",\n  \"continue\",\n  \"debugger\",\n  \"default\",\n  \"delete\",\n  \"do\",\n  \"else\",\n  \"export\",\n  \"extends\",\n  \"finally\",\n  \"for\",\n  \"function\",\n  \"if\",\n  \"import\",\n  \"in\",\n  \"instanceof\",\n  \"new\",\n  \"return\",\n  \"super\",\n  \"switch\",\n  \"this\",\n  \"throw\",\n  \"try\",\n  \"typeof\",\n  \"var\",\n  \"void\",\n  \"while\",\n  \"with\",\n  \"yield\",\n  // Future reserved keywords\n  \"enum\",\n  \"implements\",\n  \"interface\",\n  \"let\",\n  \"package\",\n  \"private\",\n  \"protected\",\n  \"public\",\n  \"static\",\n  \"await\",\n]);\n\nexport default function isIdentifier(name) {\n  if (name.length === 0) {\n    return false;\n  }\n  if (!IS_IDENTIFIER_START[name.charCodeAt(0)]) {\n    return false;\n  }\n  for (let i = 1; i < name.length; i++) {\n    if (!IS_IDENTIFIER_CHAR[name.charCodeAt(i)]) {\n      return false;\n    }\n  }\n  return !RESERVED_WORDS.has(name);\n}\n","import {TokenType as tt} from \"../parser/tokenizer/types\";\n\nimport isIdentifier from \"../util/isIdentifier\";\n\nimport Transformer from \"./Transformer\";\n\nexport default class TypeScriptTransformer extends Transformer {\n  constructor(\n     rootTransformer,\n     tokens,\n     isImportsTransformEnabled,\n  ) {\n    super();this.rootTransformer = rootTransformer;this.tokens = tokens;this.isImportsTransformEnabled = isImportsTransformEnabled;;\n  }\n\n  process() {\n    if (\n      this.rootTransformer.processPossibleArrowParamEnd() ||\n      this.rootTransformer.processPossibleAsyncArrowWithTypeParams() ||\n      this.rootTransformer.processPossibleTypeRange()\n    ) {\n      return true;\n    }\n    if (\n      this.tokens.matches1(tt._public) ||\n      this.tokens.matches1(tt._protected) ||\n      this.tokens.matches1(tt._private) ||\n      this.tokens.matches1(tt._abstract) ||\n      this.tokens.matches1(tt._readonly) ||\n      this.tokens.matches1(tt.nonNullAssertion)\n    ) {\n      this.tokens.removeInitialToken();\n      return true;\n    }\n    if (this.tokens.matches1(tt._enum) || this.tokens.matches2(tt._const, tt._enum)) {\n      this.processEnum();\n      return true;\n    }\n    if (\n      this.tokens.matches2(tt._export, tt._enum) ||\n      this.tokens.matches3(tt._export, tt._const, tt._enum)\n    ) {\n      this.processEnum(true);\n      return true;\n    }\n    return false;\n  }\n\n  processEnum(isExport = false) {\n    // We might have \"export const enum\", so just remove all relevant tokens.\n    this.tokens.removeInitialToken();\n    while (this.tokens.matches1(tt._const) || this.tokens.matches1(tt._enum)) {\n      this.tokens.removeToken();\n    }\n    const enumName = this.tokens.identifierName();\n    this.tokens.removeToken();\n    if (isExport && !this.isImportsTransformEnabled) {\n      this.tokens.appendCode(\"export \");\n    }\n    this.tokens.appendCode(`var ${enumName}; (function (${enumName})`);\n    this.tokens.copyExpectedToken(tt.braceL);\n    this.processEnumBody(enumName);\n    this.tokens.copyExpectedToken(tt.braceR);\n    if (isExport && this.isImportsTransformEnabled) {\n      this.tokens.appendCode(`)(${enumName} || (exports.${enumName} = ${enumName} = {}));`);\n    } else {\n      this.tokens.appendCode(`)(${enumName} || (${enumName} = {}));`);\n    }\n  }\n\n  /**\n   * Rather than try to compute the actual enum values at compile time, we just create variables for\n   * each one and let everything evaluate at runtime. There's some additional complexity due to\n   * handling string literal names, including ones that happen to be valid identifiers.\n   */\n  processEnumBody(enumName) {\n    let isPreviousValidIdentifier = false;\n    let lastValueReference = null;\n    while (true) {\n      if (this.tokens.matches1(tt.braceR)) {\n        break;\n      }\n      const nameToken = this.tokens.currentToken();\n      let name;\n      let nameStringCode;\n      if (nameToken.type === tt.name) {\n        name = this.tokens.identifierNameForToken(nameToken);\n        nameStringCode = `\"${name}\"`;\n      } else if (nameToken.type === tt.string) {\n        name = this.tokens.stringValueForToken(nameToken);\n        nameStringCode = this.tokens.code.slice(nameToken.start, nameToken.end);\n      } else {\n        throw new Error(\"Expected name or string at beginning of enum element.\");\n      }\n      const isValidIdentifier = isIdentifier(name);\n      this.tokens.removeInitialToken();\n\n      let valueIsString;\n      let valueCode;\n\n      if (this.tokens.matches1(tt.eq)) {\n        const rhsEndIndex = this.tokens.currentToken().rhsEndIndex;\n        if (rhsEndIndex == null) {\n          throw new Error(\"Expected rhsEndIndex on enum assign.\");\n        }\n        this.tokens.removeToken();\n        if (\n          this.tokens.matches2(tt.string, tt.comma) ||\n          this.tokens.matches2(tt.string, tt.braceR)\n        ) {\n          valueIsString = true;\n        }\n        const startToken = this.tokens.currentToken();\n        while (this.tokens.currentIndex() < rhsEndIndex) {\n          this.tokens.removeToken();\n        }\n        valueCode = this.tokens.code.slice(\n          startToken.start,\n          this.tokens.tokenAtRelativeIndex(-1).end,\n        );\n      } else {\n        valueIsString = false;\n        if (lastValueReference != null) {\n          if (isPreviousValidIdentifier) {\n            valueCode = `${lastValueReference} + 1`;\n          } else {\n            valueCode = `(${lastValueReference}) + 1`;\n          }\n        } else {\n          valueCode = \"0\";\n        }\n      }\n      if (this.tokens.matches1(tt.comma)) {\n        this.tokens.removeToken();\n      }\n\n      let valueReference;\n      if (isValidIdentifier) {\n        this.tokens.appendCode(`const ${name} = ${valueCode}; `);\n        valueReference = name;\n      } else {\n        valueReference = valueCode;\n      }\n\n      if (valueIsString) {\n        this.tokens.appendCode(`${enumName}[${nameStringCode}] = ${valueReference};`);\n      } else {\n        this.tokens.appendCode(\n          `${enumName}[${enumName}[${nameStringCode}] = ${valueReference}] = ${nameStringCode};`,\n        );\n      }\n      lastValueReference = valueReference;\n      isPreviousValidIdentifier = isValidIdentifier;\n    }\n  }\n}\n","\n\n\nimport {ContextualKeyword} from \"../parser/tokenizer/keywords\";\nimport {TokenType as tt} from \"../parser/tokenizer/types\";\n\nimport getClassInfo, {} from \"../util/getClassInfo\";\nimport CJSImportTransformer from \"./CJSImportTransformer\";\nimport ESMImportTransformer from \"./ESMImportTransformer\";\nimport FlowTransformer from \"./FlowTransformer\";\nimport JSXTransformer from \"./JSXTransformer\";\nimport NumericSeparatorTransformer from \"./NumericSeparatorTransformer\";\nimport OptionalCatchBindingTransformer from \"./OptionalCatchBindingTransformer\";\nimport OptionalChainingNullishTransformer from \"./OptionalChainingNullishTransformer\";\nimport ReactDisplayNameTransformer from \"./ReactDisplayNameTransformer\";\nimport ReactHotLoaderTransformer from \"./ReactHotLoaderTransformer\";\n\nimport TypeScriptTransformer from \"./TypeScriptTransformer\";\n\nexport default class RootTransformer {\n   __init() {this.transformers = []}\n  \n  \n   __init2() {this.generatedVariables = []}\n  \n  \n  \n\n  constructor(\n    sucraseContext,\n    transforms,\n    enableLegacyBabel5ModuleInterop,\n    options,\n  ) {;RootTransformer.prototype.__init.call(this);RootTransformer.prototype.__init2.call(this);\n    this.nameManager = sucraseContext.nameManager;\n    this.helperManager = sucraseContext.helperManager;\n    const {tokenProcessor, importProcessor} = sucraseContext;\n    this.tokens = tokenProcessor;\n    this.isImportsTransformEnabled = transforms.includes(\"imports\");\n    this.isReactHotLoaderTransformEnabled = transforms.includes(\"react-hot-loader\");\n\n    this.transformers.push(\n      new OptionalChainingNullishTransformer(tokenProcessor, this.nameManager),\n    );\n    this.transformers.push(new NumericSeparatorTransformer(tokenProcessor));\n    this.transformers.push(new OptionalCatchBindingTransformer(tokenProcessor, this.nameManager));\n    if (transforms.includes(\"jsx\")) {\n      this.transformers.push(\n        new JSXTransformer(this, tokenProcessor, importProcessor, this.nameManager, options),\n      );\n      this.transformers.push(\n        new ReactDisplayNameTransformer(this, tokenProcessor, importProcessor, options),\n      );\n    }\n\n    let reactHotLoaderTransformer = null;\n    if (transforms.includes(\"react-hot-loader\")) {\n      if (!options.filePath) {\n        throw new Error(\"filePath is required when using the react-hot-loader transform.\");\n      }\n      reactHotLoaderTransformer = new ReactHotLoaderTransformer(tokenProcessor, options.filePath);\n      this.transformers.push(reactHotLoaderTransformer);\n    }\n\n    // Note that we always want to enable the imports transformer, even when the import transform\n    // itself isn't enabled, since we need to do type-only import pruning for both Flow and\n    // TypeScript.\n    if (transforms.includes(\"imports\")) {\n      if (importProcessor === null) {\n        throw new Error(\"Expected non-null importProcessor with imports transform enabled.\");\n      }\n      this.transformers.push(\n        new CJSImportTransformer(\n          this,\n          tokenProcessor,\n          importProcessor,\n          this.nameManager,\n          reactHotLoaderTransformer,\n          enableLegacyBabel5ModuleInterop,\n          transforms.includes(\"typescript\"),\n        ),\n      );\n    } else {\n      this.transformers.push(\n        new ESMImportTransformer(\n          tokenProcessor,\n          this.nameManager,\n          reactHotLoaderTransformer,\n          transforms.includes(\"typescript\"),\n          options,\n        ),\n      );\n    }\n\n    if (transforms.includes(\"flow\")) {\n      this.transformers.push(new FlowTransformer(this, tokenProcessor));\n    }\n    if (transforms.includes(\"typescript\")) {\n      this.transformers.push(\n        new TypeScriptTransformer(this, tokenProcessor, transforms.includes(\"imports\")),\n      );\n    }\n  }\n\n  transform() {\n    this.tokens.reset();\n    this.processBalancedCode();\n    const shouldAddUseStrict = this.isImportsTransformEnabled;\n    // \"use strict\" always needs to be first, so override the normal transformer order.\n    let prefix = shouldAddUseStrict ? '\"use strict\";' : \"\";\n    for (const transformer of this.transformers) {\n      prefix += transformer.getPrefixCode();\n    }\n    prefix += this.helperManager.emitHelpers();\n    prefix += this.generatedVariables.map((v) => ` var ${v};`).join(\"\");\n    let suffix = \"\";\n    for (const transformer of this.transformers) {\n      suffix += transformer.getSuffixCode();\n    }\n    let code = this.tokens.finish();\n    if (code.startsWith(\"#!\")) {\n      let newlineIndex = code.indexOf(\"\\n\");\n      if (newlineIndex === -1) {\n        newlineIndex = code.length;\n        code += \"\\n\";\n      }\n      return code.slice(0, newlineIndex + 1) + prefix + code.slice(newlineIndex + 1) + suffix;\n    } else {\n      return prefix + this.tokens.finish() + suffix;\n    }\n  }\n\n  processBalancedCode() {\n    let braceDepth = 0;\n    let parenDepth = 0;\n    while (!this.tokens.isAtEnd()) {\n      if (this.tokens.matches1(tt.braceL) || this.tokens.matches1(tt.dollarBraceL)) {\n        braceDepth++;\n      } else if (this.tokens.matches1(tt.braceR)) {\n        if (braceDepth === 0) {\n          return;\n        }\n        braceDepth--;\n      }\n      if (this.tokens.matches1(tt.parenL)) {\n        parenDepth++;\n      } else if (this.tokens.matches1(tt.parenR)) {\n        if (parenDepth === 0) {\n          return;\n        }\n        parenDepth--;\n      }\n      this.processToken();\n    }\n  }\n\n  processToken() {\n    if (this.tokens.matches1(tt._class)) {\n      this.processClass();\n      return;\n    }\n    for (const transformer of this.transformers) {\n      const wasProcessed = transformer.process();\n      if (wasProcessed) {\n        return;\n      }\n    }\n    this.tokens.copyToken();\n  }\n\n  /**\n   * Skip past a class with a name and return that name.\n   */\n  processNamedClass() {\n    if (!this.tokens.matches2(tt._class, tt.name)) {\n      throw new Error(\"Expected identifier for exported class name.\");\n    }\n    const name = this.tokens.identifierNameAtIndex(this.tokens.currentIndex() + 1);\n    this.processClass();\n    return name;\n  }\n\n  processClass() {\n    const classInfo = getClassInfo(this, this.tokens, this.nameManager);\n\n    // Both static and instance initializers need a class name to use to invoke the initializer, so\n    // assign to one if necessary.\n    const needsCommaExpression =\n      classInfo.headerInfo.isExpression &&\n      classInfo.staticInitializerNames.length + classInfo.instanceInitializerNames.length > 0;\n\n    let className = classInfo.headerInfo.className;\n    if (needsCommaExpression) {\n      className = this.nameManager.claimFreeName(\"_class\");\n      this.generatedVariables.push(className);\n      this.tokens.appendCode(` (${className} =`);\n    }\n\n    const classToken = this.tokens.currentToken();\n    const contextId = classToken.contextId;\n    if (contextId == null) {\n      throw new Error(\"Expected class to have a context ID.\");\n    }\n    this.tokens.copyExpectedToken(tt._class);\n    while (!this.tokens.matchesContextIdAndLabel(tt.braceL, contextId)) {\n      this.processToken();\n    }\n\n    this.processClassBody(classInfo, className);\n\n    const staticInitializerStatements = classInfo.staticInitializerNames.map(\n      (name) => `${className}.${name}()`,\n    );\n    if (needsCommaExpression) {\n      this.tokens.appendCode(\n        `, ${staticInitializerStatements.map((s) => `${s}, `).join(\"\")}${className})`,\n      );\n    } else if (classInfo.staticInitializerNames.length > 0) {\n      this.tokens.appendCode(` ${staticInitializerStatements.map((s) => `${s};`).join(\" \")}`);\n    }\n  }\n\n  /**\n   * We want to just handle class fields in all contexts, since TypeScript supports them. Later,\n   * when some JS implementations support class fields, this should be made optional.\n   */\n  processClassBody(classInfo, className) {\n    const {\n      headerInfo,\n      constructorInsertPos,\n      constructorInitializerStatements,\n      fields,\n      instanceInitializerNames,\n      rangesToRemove,\n    } = classInfo;\n    let fieldIndex = 0;\n    let rangeToRemoveIndex = 0;\n    const classContextId = this.tokens.currentToken().contextId;\n    if (classContextId == null) {\n      throw new Error(\"Expected non-null context ID on class.\");\n    }\n    this.tokens.copyExpectedToken(tt.braceL);\n    if (this.isReactHotLoaderTransformEnabled) {\n      this.tokens.appendCode(\n        \"__reactstandin__regenerateByEval(key, code) {this[key] = eval(code);}\",\n      );\n    }\n\n    const needsConstructorInit =\n      constructorInitializerStatements.length + instanceInitializerNames.length > 0;\n\n    if (constructorInsertPos === null && needsConstructorInit) {\n      const constructorInitializersCode = this.makeConstructorInitCode(\n        constructorInitializerStatements,\n        instanceInitializerNames,\n        className,\n      );\n      if (headerInfo.hasSuperclass) {\n        const argsName = this.nameManager.claimFreeName(\"args\");\n        this.tokens.appendCode(\n          `constructor(...${argsName}) { super(...${argsName}); ${constructorInitializersCode}; }`,\n        );\n      } else {\n        this.tokens.appendCode(`constructor() { ${constructorInitializersCode}; }`);\n      }\n    }\n\n    while (!this.tokens.matchesContextIdAndLabel(tt.braceR, classContextId)) {\n      if (fieldIndex < fields.length && this.tokens.currentIndex() === fields[fieldIndex].start) {\n        let needsCloseBrace = false;\n        if (this.tokens.matches1(tt.bracketL)) {\n          this.tokens.copyTokenWithPrefix(`${fields[fieldIndex].initializerName}() {this`);\n        } else if (this.tokens.matches1(tt.string) || this.tokens.matches1(tt.num)) {\n          this.tokens.copyTokenWithPrefix(`${fields[fieldIndex].initializerName}() {this[`);\n          needsCloseBrace = true;\n        } else {\n          this.tokens.copyTokenWithPrefix(`${fields[fieldIndex].initializerName}() {this.`);\n        }\n        while (this.tokens.currentIndex() < fields[fieldIndex].end) {\n          if (needsCloseBrace && this.tokens.currentIndex() === fields[fieldIndex].equalsIndex) {\n            this.tokens.appendCode(\"]\");\n          }\n          this.processToken();\n        }\n        this.tokens.appendCode(\"}\");\n        fieldIndex++;\n      } else if (\n        rangeToRemoveIndex < rangesToRemove.length &&\n        this.tokens.currentIndex() === rangesToRemove[rangeToRemoveIndex].start\n      ) {\n        this.tokens.removeInitialToken();\n        while (this.tokens.currentIndex() < rangesToRemove[rangeToRemoveIndex].end) {\n          this.tokens.removeToken();\n        }\n        rangeToRemoveIndex++;\n      } else if (this.tokens.currentIndex() === constructorInsertPos) {\n        this.tokens.copyToken();\n        if (needsConstructorInit) {\n          this.tokens.appendCode(\n            `;${this.makeConstructorInitCode(\n              constructorInitializerStatements,\n              instanceInitializerNames,\n              className,\n            )};`,\n          );\n        }\n        this.processToken();\n      } else {\n        this.processToken();\n      }\n    }\n    this.tokens.copyExpectedToken(tt.braceR);\n  }\n\n  makeConstructorInitCode(\n    constructorInitializerStatements,\n    instanceInitializerNames,\n    className,\n  ) {\n    return [\n      ...constructorInitializerStatements,\n      ...instanceInitializerNames.map((name) => `${className}.prototype.${name}.call(this)`),\n    ].join(\";\");\n  }\n\n  /**\n   * Normally it's ok to simply remove type tokens, but we need to be more careful when dealing with\n   * arrow function return types since they can confuse the parser. In that case, we want to move\n   * the close-paren to the same line as the arrow.\n   *\n   * See https://github.com/alangpierce/sucrase/issues/391 for more details.\n   */\n  processPossibleArrowParamEnd() {\n    if (this.tokens.matches2(tt.parenR, tt.colon) && this.tokens.tokenAtRelativeIndex(1).isType) {\n      let nextNonTypeIndex = this.tokens.currentIndex() + 1;\n      // Look ahead to see if this is an arrow function or something else.\n      while (this.tokens.tokens[nextNonTypeIndex].isType) {\n        nextNonTypeIndex++;\n      }\n      if (this.tokens.matches1AtIndex(nextNonTypeIndex, tt.arrow)) {\n        this.tokens.removeInitialToken();\n        while (this.tokens.currentIndex() < nextNonTypeIndex) {\n          this.tokens.removeToken();\n        }\n        this.tokens.replaceTokenTrimmingLeftWhitespace(\") =>\");\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * An async arrow function might be of the form:\n   *\n   * async <\n   *   T\n   * >() => {}\n   *\n   * in which case, removing the type parameters will cause a syntax error. Detect this case and\n   * move the open-paren earlier.\n   */\n  processPossibleAsyncArrowWithTypeParams() {\n    if (\n      !this.tokens.matchesContextual(ContextualKeyword._async) &&\n      !this.tokens.matches1(tt._async)\n    ) {\n      return false;\n    }\n    const nextToken = this.tokens.tokenAtRelativeIndex(1);\n    if (nextToken.type !== tt.lessThan || !nextToken.isType) {\n      return false;\n    }\n\n    let nextNonTypeIndex = this.tokens.currentIndex() + 1;\n    // Look ahead to see if this is an arrow function or something else.\n    while (this.tokens.tokens[nextNonTypeIndex].isType) {\n      nextNonTypeIndex++;\n    }\n    if (this.tokens.matches1AtIndex(nextNonTypeIndex, tt.parenL)) {\n      this.tokens.replaceToken(\"async (\");\n      this.tokens.removeInitialToken();\n      while (this.tokens.currentIndex() < nextNonTypeIndex) {\n        this.tokens.removeToken();\n      }\n      this.tokens.removeToken();\n      // We ate a ( token, so we need to process the tokens in between and then the ) token so that\n      // we remain balanced.\n      this.processBalancedCode();\n      this.processToken();\n      return true;\n    }\n    return false;\n  }\n\n  processPossibleTypeRange() {\n    if (this.tokens.currentToken().isType) {\n      this.tokens.removeInitialToken();\n      while (this.tokens.currentToken().isType) {\n        this.tokens.removeToken();\n      }\n      return true;\n    }\n    return false;\n  }\n}\n","import {ContextualKeyword} from \"../parser/tokenizer/keywords\";\nimport {TokenType as tt} from \"../parser/tokenizer/types\";\n\n\n/**\n * Special case code to scan for imported names in ESM TypeScript. We need to do this so we can\n * properly get globals so we can compute shadowed globals.\n *\n * This is similar to logic in CJSImportProcessor, but trimmed down to avoid logic with CJS\n * replacement and flow type imports.\n */\nexport default function getTSImportedNames(tokens) {\n  const importedNames = new Set();\n  for (let i = 0; i < tokens.tokens.length; i++) {\n    if (\n      tokens.matches1AtIndex(i, tt._import) &&\n      !tokens.matches3AtIndex(i, tt._import, tt.name, tt.eq)\n    ) {\n      collectNamesForImport(tokens, i, importedNames);\n    }\n  }\n  return importedNames;\n}\n\nfunction collectNamesForImport(\n  tokens,\n  index,\n  importedNames,\n) {\n  index++;\n\n  if (tokens.matches1AtIndex(index, tt.parenL)) {\n    // Dynamic import, so nothing to do\n    return;\n  }\n\n  if (tokens.matches1AtIndex(index, tt.name)) {\n    importedNames.add(tokens.identifierNameAtIndex(index));\n    index++;\n    if (tokens.matches1AtIndex(index, tt.comma)) {\n      index++;\n    }\n  }\n\n  if (tokens.matches1AtIndex(index, tt.star)) {\n    // * as\n    index += 2;\n    importedNames.add(tokens.identifierNameAtIndex(index));\n    index++;\n  }\n\n  if (tokens.matches1AtIndex(index, tt.braceL)) {\n    index++;\n    collectNamesForNamedImport(tokens, index, importedNames);\n  }\n}\n\nfunction collectNamesForNamedImport(\n  tokens,\n  index,\n  importedNames,\n) {\n  while (true) {\n    if (tokens.matches1AtIndex(index, tt.braceR)) {\n      return;\n    }\n\n    // We care about the local name, which might be the first token, or if there's an \"as\", is the\n    // one after that.\n    let name = tokens.identifierNameAtIndex(index);\n    index++;\n    if (tokens.matchesContextualAtIndex(index, ContextualKeyword._as)) {\n      index++;\n      name = tokens.identifierNameAtIndex(index);\n      index++;\n    }\n    importedNames.add(name);\n    if (tokens.matches2AtIndex(index, tt.comma, tt.braceR)) {\n      return;\n    } else if (tokens.matches1AtIndex(index, tt.braceR)) {\n      return;\n    } else if (tokens.matches1AtIndex(index, tt.comma)) {\n      index++;\n    } else {\n      throw new Error(`Unexpected token: ${JSON.stringify(tokens.tokens[index])}`);\n    }\n  }\n}\n","import CJSImportProcessor from \"./CJSImportProcessor\";\nimport computeSourceMap, {} from \"./computeSourceMap\";\nimport {HelperManager} from \"./HelperManager\";\nimport identifyShadowedGlobals from \"./identifyShadowedGlobals\";\nimport NameManager from \"./NameManager\";\nimport {validateOptions} from \"./Options\";\nimport {parse} from \"./parser\";\n\nimport TokenProcessor from \"./TokenProcessor\";\nimport RootTransformer from \"./transformers/RootTransformer\";\nimport formatTokens from \"./util/formatTokens\";\nimport getTSImportedNames from \"./util/getTSImportedNames\";\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nexport function getVersion() {\n  // eslint-disable-next-line\n  return require(\"../package.json\").version;\n}\n\nexport function transform(code, options) {\n  validateOptions(options);\n  try {\n    const sucraseContext = getSucraseContext(code, options);\n    const transformer = new RootTransformer(\n      sucraseContext,\n      options.transforms,\n      Boolean(options.enableLegacyBabel5ModuleInterop),\n      options,\n    );\n    let result = {code: transformer.transform()};\n    if (options.sourceMapOptions) {\n      if (!options.filePath) {\n        throw new Error(\"filePath must be specified when generating a source map.\");\n      }\n      result = {\n        ...result,\n        sourceMap: computeSourceMap(result.code, options.filePath, options.sourceMapOptions),\n      };\n    }\n    return result;\n  } catch (e) {\n    if (options.filePath) {\n      e.message = `Error transforming ${options.filePath}: ${e.message}`;\n    }\n    throw e;\n  }\n}\n\n/**\n * Return a string representation of the sucrase tokens, mostly useful for\n * diagnostic purposes.\n */\nexport function getFormattedTokens(code, options) {\n  const tokens = getSucraseContext(code, options).tokenProcessor.tokens;\n  return formatTokens(code, tokens);\n}\n\n/**\n * Call into the parser/tokenizer and do some further preprocessing:\n * - Come up with a set of used names so that we can assign new names.\n * - Preprocess all import/export statements so we know which globals we are interested in.\n * - Compute situations where any of those globals are shadowed.\n *\n * In the future, some of these preprocessing steps can be skipped based on what actual work is\n * being done.\n */\nfunction getSucraseContext(code, options) {\n  const isJSXEnabled = options.transforms.includes(\"jsx\");\n  const isTypeScriptEnabled = options.transforms.includes(\"typescript\");\n  const isFlowEnabled = options.transforms.includes(\"flow\");\n  const file = parse(code, isJSXEnabled, isTypeScriptEnabled, isFlowEnabled);\n  const tokens = file.tokens;\n  const scopes = file.scopes;\n\n  const nameManager = new NameManager(code, tokens);\n  const helperManager = new HelperManager(nameManager);\n  const tokenProcessor = new TokenProcessor(code, tokens, isFlowEnabled, helperManager);\n  const enableLegacyTypeScriptModuleInterop = Boolean(options.enableLegacyTypeScriptModuleInterop);\n\n  let importProcessor = null;\n  if (options.transforms.includes(\"imports\")) {\n    importProcessor = new CJSImportProcessor(\n      nameManager,\n      tokenProcessor,\n      enableLegacyTypeScriptModuleInterop,\n      options,\n      options.transforms.includes(\"typescript\"),\n      helperManager,\n    );\n    importProcessor.preprocessTokens();\n    // We need to mark shadowed globals after processing imports so we know that the globals are,\n    // but before type-only import pruning, since that relies on shadowing information.\n    identifyShadowedGlobals(tokenProcessor, scopes, importProcessor.getGlobalNames());\n    if (options.transforms.includes(\"typescript\")) {\n      importProcessor.pruneTypeOnlyImports();\n    }\n  } else if (options.transforms.includes(\"typescript\")) {\n    identifyShadowedGlobals(tokenProcessor, scopes, getTSImportedNames(tokenProcessor));\n  }\n  return {tokenProcessor, scopes, nameManager, importProcessor, helperManager};\n}\n","import type { Plugin } from '@velcro/bundler';\nimport { Options, transform } from 'sucrase';\n\nexport interface SucrasePluginOptions\n  extends Partial<Pick<Options, 'jsxFragmentPragma' | 'jsxPragma' | 'transforms'>> {}\n\nexport function sucrasePlugin(options: SucrasePluginOptions = {}): Plugin {\n  const extensions = ['js'];\n\n  if (options.transforms) {\n    for (const transform of options.transforms) {\n      switch (transform) {\n        case 'jsx':\n          extensions.push('jsx');\n          break;\n        case 'typescript':\n          extensions.push('ts', 'tsx');\n          break;\n      }\n    }\n  }\n\n  const uriTestRx = new RegExp(`\\.(?:${extensions.join('|')})$`, 'i');\n\n  const jsxPragmaRx = /\\/\\*\\*\\s*@jsx\\s+(\\S+)\\s*\\*+\\//;\n  const jsxFragmentPragmaRx = /\\/\\*\\*\\s*@jsxFragment\\s+(\\S+)\\s*\\*+\\//;\n\n  return {\n    name: 'sucrasePlugin',\n    transform(ctx, uri, code) {\n      if (!uriTestRx.test(uri.path)) {\n        return;\n      }\n\n      const sucraseOptions: Options = {\n        transforms: ['imports', ...(options.transforms || [])],\n        filePath: uri.toString(),\n        production: ctx.nodeEnv === 'production',\n        sourceMapOptions: {\n          compiledFilename: uri.toString(),\n        },\n      };\n\n      if (!options.jsxPragma) {\n        // If not specified try to detect the pragma\n        const jsxPragmaMatches = code.match(jsxPragmaRx);\n        if (jsxPragmaMatches) {\n          sucraseOptions.jsxPragma = jsxPragmaMatches[1];\n        }\n      }\n\n      if (!options.jsxFragmentPragma) {\n        // If not specified try to detect the pragma\n        const jsxFragmentPragmaMatches = code.match(jsxFragmentPragmaRx);\n        if (jsxFragmentPragmaMatches) {\n          sucraseOptions.jsxFragmentPragma = jsxFragmentPragmaMatches[1];\n        }\n      }\n\n      const result = transform(code, sucraseOptions);\n\n      return {\n        code: result.code,\n        sourceMap: result.sourceMap,\n      };\n    },\n  };\n}\n","import {\n  all,\n  basename,\n  CancellationToken,\n  checkCancellation,\n  EntryNotFoundError,\n  isThenable,\n  PackageJson,\n  parseBufferAsPackageJson,\n  Thenable,\n  Uri,\n} from '@velcro/common';\nimport {\n  AbstractResolverStrategyWithRoot,\n  ResolverContext,\n  ResolverStrategy,\n  ResolverStrategyWithRoot,\n} from '@velcro/resolver';\nimport { satisfies, validRange } from 'semver';\n\ninterface AbstractCdn {\n  name: string;\n\n  isValidUrl(url: Uri): boolean;\n  normalizePackageListing(result: unknown): CdnStrategy.Directory;\n  parseUrl(url: Uri | string): CdnStrategy.Spec;\n  urlForPackageFile(spec: string, pathname: string): Uri;\n  urlForPackageList(spec: string): Uri;\n}\n\nfunction isValidEntry(entry: unknown): entry is CdnStrategy.Entry {\n  if (!entry || typeof entry !== 'object') return false;\n\n  return isValidFile(entry) || isValidDirectory(entry);\n}\n\nfunction isValidDirectory(entry: unknown): entry is CdnStrategy.Directory {\n  return (\n    typeof entry === 'object' &&\n    entry &&\n    (entry as any).type === ResolverStrategy.EntryKind.Directory &&\n    typeof (entry as any).path === 'string' &&\n    (entry as any).path &&\n    (typeof (entry as any).files === 'undefined' ||\n      (Array.isArray((entry as any).files) && (entry as any).files.every(isValidEntry)))\n  );\n}\n\nfunction isValidFile(entry: unknown): entry is File {\n  return (\n    typeof entry === 'object' &&\n    entry &&\n    (entry as any).type === ResolverStrategy.EntryKind.File &&\n    typeof (entry as any).path === 'string' &&\n    (entry as any).path\n  );\n}\n\nfunction specToString(spec: CdnStrategy.Spec) {\n  return `${spec.spec}${spec.pathname}`;\n}\n\nclass JSDelivrCdn implements AbstractCdn {\n  name = 'jsdelivr';\n\n  private readonly specRx = /^\\/((@[^/]+\\/[^/@]+|[^/@]+)(?:@([^/]+))?)(.*)?$/;\n\n  isValidUrl(url: Uri) {\n    return url.scheme === JSDelivrCdn.protocol || url.authority === JSDelivrCdn.host;\n  }\n\n  normalizePackageListing(result: unknown): CdnStrategy.Directory {\n    if (!result || typeof result !== 'object') {\n      throw new Error(`Unexpected package listing contents`);\n    }\n\n    const files = (result as any).files;\n\n    if (!Array.isArray(files)) {\n      throw new Error(`Unexpected package listing contents`);\n    }\n\n    const mapChildEntry = (parent: string, child: unknown): CdnStrategy.Entry => {\n      if (!child || typeof child !== 'object') {\n        throw new Error(`Unexpected entry in package listing contents`);\n      }\n\n      const name = (child as any).name;\n\n      if (typeof name !== 'string') {\n        throw new Error(`Unexpected entry in package listing contents`);\n      }\n\n      const path = `${parent}/${name}`;\n\n      if ((child as any).type === ResolverStrategy.EntryKind.Directory) {\n        const files = (child as any).files;\n\n        if (!Array.isArray(files)) {\n          throw new Error(`Unexpected entry in package listing contents`);\n        }\n        return {\n          type: ResolverStrategy.EntryKind.Directory,\n          path,\n          files: files.map((file) => mapChildEntry(path, file)),\n        };\n      } else if ((child as any).type === ResolverStrategy.EntryKind.File) {\n        return {\n          type: ResolverStrategy.EntryKind.File,\n          path,\n        };\n      }\n\n      throw new Error(`Error mapping child entry in package file listing`);\n    };\n\n    return {\n      type: ResolverStrategy.EntryKind.Directory,\n      path: '/',\n      files: files.map((file) => mapChildEntry('', file)),\n    };\n  }\n\n  parseUrl(url: Uri | string) {\n    if (Uri.isUri(url)) {\n      url = url.path;\n    }\n\n    const prefix = `/npm`;\n\n    if (!url.startsWith(prefix)) {\n      throw new Error(`Unable to parse unexpected ${this.name} url: ${url}`);\n    }\n\n    url = url.slice(prefix.length);\n\n    /**\n     * 1: scope + name + version\n     * 2: scope + name\n     * 3: version?\n     * 4: pathname\n     */\n    const matches = url.match(this.specRx);\n\n    if (!matches) {\n      throw new Error(`Unable to parse unexpected unpkg url: ${url}`);\n    }\n\n    return {\n      spec: matches[1],\n      name: matches[2],\n      version: matches[3] || '',\n      pathname: matches[4] || '',\n    };\n  }\n\n  urlForPackageFile(spec: string, pathname: string): Uri {\n    return Uri.from({\n      scheme: JSDelivrCdn.protocol,\n      authority: JSDelivrCdn.host,\n      path: `/npm/${spec}${pathname}`,\n    });\n  }\n\n  urlForPackageList(spec: string): Uri {\n    return Uri.from({\n      scheme: JSDelivrCdn.protocol,\n      authority: JSDelivrCdn.dataHost,\n      path: `/v1/package/npm/${spec}/tree`,\n    });\n  }\n\n  static readonly protocol = 'https';\n  static readonly host = 'cdn.jsdelivr.net';\n  static readonly dataHost = 'data.jsdelivr.com';\n}\n\nclass UnpkgCdn implements AbstractCdn {\n  name = 'unpkg';\n\n  private readonly UNPKG_SPEC_RX = /^\\/((@[^/]+\\/[^/@]+|[^/@]+)(?:@([^/]+))?)(.*)?$/;\n\n  isValidUrl(url: Uri) {\n    return url.scheme === UnpkgCdn.protocol || url.authority === UnpkgCdn.host;\n  }\n\n  normalizePackageListing(result: unknown) {\n    if (!isValidDirectory(result)) {\n      throw new Error(`Error normalizing directory listing`);\n    }\n\n    return result;\n  }\n\n  parseUrl(url: Uri | string) {\n    if (Uri.isUri(url)) {\n      url = url.path;\n    }\n\n    /**\n     * 1: scope + name + version\n     * 2: scope + name\n     * 3: version?\n     * 4: pathname\n     */\n    const matches = url.match(this.UNPKG_SPEC_RX);\n\n    if (!matches) {\n      throw new Error(`Unable to parse unexpected unpkg url: ${url}`);\n    }\n\n    return {\n      spec: matches[1],\n      name: matches[2],\n      version: matches[3] || '',\n      pathname: matches[4] || '',\n    };\n  }\n\n  urlForPackageFile(spec: string, pathname: string): Uri {\n    return Uri.from({\n      scheme: UnpkgCdn.protocol,\n      authority: UnpkgCdn.host,\n      path: `/${spec}${pathname}`,\n    });\n  }\n\n  urlForPackageList(spec: string) {\n    return Uri.from({\n      scheme: UnpkgCdn.protocol,\n      authority: UnpkgCdn.host,\n      path: `/${spec}/`,\n      query: 'meta',\n    });\n  }\n\n  static readonly protocol = 'https';\n  static readonly host = 'unpkg.com';\n}\n\nexport namespace CdnStrategy {\n  export type Spec = {\n    spec: string;\n    name: string;\n    version: string;\n    pathname: string;\n  };\n\n  export type Directory = {\n    type: ResolverStrategy.EntryKind.Directory;\n    path: string;\n    files?: ReadonlyArray<Entry>;\n  };\n  export type File = {\n    type: ResolverStrategy.EntryKind.File;\n    path: string;\n  };\n  export type Entry = Directory | File;\n\n  export type UrlContentFetcher = (\n    href: string,\n    token: CancellationToken\n  ) => Thenable<ArrayBuffer | null>;\n}\n\nexport class CdnStrategy extends AbstractResolverStrategyWithRoot\n  implements ResolverStrategyWithRoot {\n  private readonly cdn: AbstractCdn;\n  private readonly contentCache = new Map<\n    string,\n    null | { content: ArrayBuffer } | Thenable<{ content: ArrayBuffer }>\n  >();\n  private readonly locks = new Map<string, unknown | Thenable<unknown>>();\n  private readonly packageEntriesCache = new Map<string, Map<string, CdnStrategy.Directory>>();\n  private readonly packageJsonCache = new Map<\n    string,\n    Map<string, { packageJson: PackageJson; visited: ResolverContext.Visit[] }>\n  >();\n  private readonly readUrlFn: CdnStrategy.UrlContentFetcher;\n\n  constructor(readUrlFn: CdnStrategy.UrlContentFetcher, cdn: AbstractCdn) {\n    super(cdn.urlForPackageFile('', ''));\n\n    this.cdn = cdn;\n    this.readUrlFn = readUrlFn;\n  }\n\n  private _withRootUriCheck<T extends unknown | Thenable<unknown>>(\n    uri: Uri,\n    fn: (rootUri: Uri) => T\n  ): T {\n    if (!Uri.isPrefixOf(this.rootUri, uri)) {\n      throw new Error(\n        `This strategy is only able to handle URIs under '${this.rootUri.toString()}' and is unable to handle '${uri.toString()}'`\n      );\n    }\n\n    return fn(this.rootUri);\n  }\n\n  async getUrlForBareModule(\n    ctx: ResolverContext,\n    name: string,\n    spec: string,\n    path: string\n  ): Promise<ResolverStrategy.BareModuleResult> {\n    const unresolvedUri = this.cdn.urlForPackageFile(`${name}@${spec}`, path);\n    const resolveReturn = await ctx.resolveUri(unresolvedUri);\n\n    return resolveReturn;\n  }\n\n  getCanonicalUrl(ctx: ResolverContext, uri: Uri): Promise<ResolverStrategy.CanonicalizeResult> {\n    return this._withRootUriCheck(uri, async () => {\n      const unresolvedSpec = this.cdn.parseUrl(uri);\n      const packageJsonReturn = ctx.runInChildContext(\n        'CdnStrategy._readPackageJsonWithCache',\n        specToString(unresolvedSpec),\n        (ctx) => this._readPackageJsonWithCache(ctx, unresolvedSpec)\n      );\n      const packageJson = isThenable(packageJsonReturn)\n        ? await packageJsonReturn\n        : packageJsonReturn;\n\n      return {\n        uri: this.cdn.urlForPackageFile(\n          `${packageJson.name}@${packageJson.version}`,\n          unresolvedSpec.pathname\n        ),\n      };\n    });\n    // const results = all([ctx.getRootUrl(uri), ctx.getResolveRoot(uri)], ctx.token);\n    // const [rootUriResult, resolveRootResult] = isThenable(results) ? await results : results;\n  }\n\n  getResolveRoot(ctx: ResolverContext, uri: Uri): Promise<ResolverStrategy.ResolveRootResult> {\n    return this._withRootUriCheck(uri, async () => {\n      const unresolvedSpec = this.cdn.parseUrl(uri);\n      const packageJsonReturn = this._readPackageJsonWithCache(ctx, unresolvedSpec);\n      const packageJson = isThenable(packageJsonReturn)\n        ? await packageJsonReturn\n        : packageJsonReturn;\n\n      return {\n        uri: this.cdn.urlForPackageFile(`${packageJson.name}@${packageJson.version}`, '/'),\n      };\n    });\n  }\n\n  getRootUrl() {\n    return {\n      uri: this.cdn.urlForPackageFile('', ''),\n    };\n  }\n\n  listEntries(ctx: ResolverContext, uri: Uri): Promise<ResolverStrategy.ListEntriesResult> {\n    return this._withRootUriCheck(\n      uri,\n      async (): Promise<ResolverStrategy.ListEntriesResult> => {\n        const unresolvedSpec = this.cdn.parseUrl(uri);\n        const results = all(\n          [\n            ctx.getResolveRoot(uri),\n            this._readPackageJsonWithCache(ctx, unresolvedSpec),\n            this._readPackageEntriesWithCache(ctx, unresolvedSpec),\n          ],\n          ctx.token\n        );\n\n        const [{ uri: resolveRootUri }, packageJson, entriesReturn] = isThenable(results)\n          ? await results\n          : results;\n        const canonicalizedSpec: CdnStrategy.Spec = {\n          name: packageJson.name,\n          pathname: unresolvedSpec.pathname,\n          spec: `${packageJson.name}@${packageJson.version}`,\n          version: packageJson.version,\n        };\n\n        // Proactively cache the canonicalized package entries\n        this.packageEntriesCache.get(packageJson.name)!.set(packageJson.version, entriesReturn);\n\n        const traversalSegments = canonicalizedSpec.pathname.split('/').filter(Boolean);\n\n        let parentEntry: CdnStrategy.Directory | undefined = entriesReturn;\n\n        while (parentEntry && traversalSegments.length) {\n          const segment = traversalSegments.shift() as string;\n\n          if (parentEntry.type !== ResolverStrategy.EntryKind.Directory || !parentEntry.files) {\n            throw new EntryNotFoundError(uri);\n          }\n\n          parentEntry = parentEntry.files.find(\n            (file) =>\n              file.type === ResolverStrategy.EntryKind.Directory && basename(file.path) === segment\n          ) as CdnStrategy.Directory | undefined;\n        }\n\n        if (!parentEntry) {\n          throw new EntryNotFoundError(uri);\n        }\n\n        if (!parentEntry.files) {\n          return {\n            entries: [],\n          };\n        }\n\n        return {\n          entries: parentEntry.files.map((entry) => {\n            return {\n              type: entry.type,\n              uri: Uri.joinPath(resolveRootUri, `.${entry.path}`),\n            };\n          }),\n        };\n      }\n    );\n  }\n\n  readFileContent(ctx: ResolverContext, uri: Uri) {\n    return this._withRootUriCheck(uri, () => {\n      const uriStr = uri.toString();\n      const cached = this.contentCache.get(uriStr);\n\n      if (cached === null) {\n        return Promise.reject(new EntryNotFoundError(uri));\n      }\n\n      if (cached) {\n        return cached;\n      }\n\n      ctx.recordVisit(uri, ResolverContext.VisitKind.File);\n      const readReturn = this.readUrlFn(uriStr, ctx.token);\n\n      if (readReturn === null) {\n        this.contentCache.set(uriStr, null);\n\n        return Promise.reject(new EntryNotFoundError(uri));\n      }\n\n      if (isThenable(readReturn)) {\n        const wrappedReturn = readReturn.then((data) => {\n          if (data === null) {\n            this.contentCache.delete(uriStr);\n\n            return Promise.reject(new EntryNotFoundError(uri));\n          }\n\n          const entry = { content: data };\n\n          this.contentCache.set(uriStr, entry);\n\n          return entry;\n        });\n\n        this.contentCache.set(uriStr, wrappedReturn);\n\n        return wrappedReturn;\n      }\n\n      const entry = { content: readReturn };\n      this.contentCache.set(uriStr, entry);\n\n      return entry;\n    });\n  }\n\n  private _readPackageEntriesWithCache(ctx: ResolverContext, spec: CdnStrategy.Spec) {\n    ctx.debug('%s._readPackageEntriesWithCache(%s)', this.constructor.name, specToString(spec));\n\n    return this._withLock(`packageEntries:${spec.name}`, () => {\n      let packageEntriesCacheForModule = this.packageEntriesCache.get(spec.name);\n\n      if (packageEntriesCacheForModule) {\n        const exactMatch = packageEntriesCacheForModule.get(spec.version);\n\n        if (exactMatch) {\n          // console.log('[HIT-EXACT] readPackageJsonWithCache(%s)', spec.spec);\n          return exactMatch;\n        }\n\n        const range = validRange(spec.version);\n\n        if (range) {\n          for (const [version, entries] of packageEntriesCacheForModule) {\n            if (satisfies(version, range)) {\n              return entries;\n            }\n          }\n        }\n      } else {\n        packageEntriesCacheForModule = new Map();\n        this.packageEntriesCache.set(spec.name, packageEntriesCacheForModule);\n      }\n\n      return this._readPackageEntries(ctx, spec).then((rootDir) => {\n        packageEntriesCacheForModule!.set(spec.version, rootDir);\n\n        return rootDir;\n      });\n    });\n  }\n\n  private async _readPackageEntries(ctx: ResolverContext, spec: CdnStrategy.Spec) {\n    ctx.debug('%s._readPackageEntries(%s)', this.constructor.name, specToString(spec));\n\n    const uri = this.cdn.urlForPackageList(spec.spec);\n    const href = uri.toString();\n    ctx.recordVisit(uri, ResolverContext.VisitKind.Directory);\n    const data = await checkCancellation(this.readUrlFn(href, ctx.token), ctx.token);\n\n    if (data === null) {\n      throw new EntryNotFoundError(spec);\n    }\n\n    const dataStr = ctx.decoder.decode(data);\n\n    return this.cdn.normalizePackageListing(JSON.parse(dataStr));\n  }\n\n  private _readPackageJsonWithCache(ctx: ResolverContext, spec: CdnStrategy.Spec) {\n    return this._withLock(`packageJson:${spec.name}`, () => {\n      let packageJsonCacheForModule = this.packageJsonCache.get(spec.name);\n\n      if (packageJsonCacheForModule) {\n        const exactMatch = packageJsonCacheForModule.get(spec.version);\n\n        if (exactMatch) {\n          // console.log('[HIT-EXACT] readPackageJsonWithCache(%s)', spec.spec);\n          for (const visit of exactMatch.visited) {\n            ctx.recordVisit(visit.uri, visit.type);\n          }\n          return exactMatch.packageJson;\n        }\n\n        const range = validRange(spec.version);\n\n        if (range) {\n          for (const [version, entry] of packageJsonCacheForModule) {\n            if (satisfies(version, range)) {\n              // console.log('[HIT] readPackageJsonWithCache(%s)', spec.spec);\n              for (const visit of entry.visited) {\n                ctx.recordVisit(visit.uri, visit.type);\n              }\n              return entry.packageJson;\n            }\n          }\n        }\n      } else {\n        packageJsonCacheForModule = new Map();\n        this.packageJsonCache.set(spec.name, packageJsonCacheForModule);\n      }\n\n      return this._readPackageJson(spec, ctx).then((packageJson) => {\n        packageJsonCacheForModule!.set(packageJson.version, { packageJson, visited: ctx.visited });\n\n        return packageJson;\n      });\n    });\n  }\n\n  private async _readPackageJson(\n    spec: CdnStrategy.Spec,\n    ctx: ResolverContext\n  ): Promise<PackageJson> {\n    ctx.debug('%s._readPackageJson(%s)', this.constructor.name, specToString(spec));\n    const uri = this.cdn.urlForPackageFile(spec.spec, '/package.json');\n    const contentReturn = ctx.readFileContent(uri);\n    const contentResult = isThenable(contentReturn) ? await contentReturn : contentReturn;\n\n    let manifest: PackageJson;\n\n    try {\n      manifest = parseBufferAsPackageJson(ctx.decoder, contentResult.content, spec.spec);\n    } catch (err) {\n      throw new Error(`Error parsing manifest as json for package ${spec}: ${err.message}`);\n    }\n\n    // Since we know what the canonicalized version is now (we didn't until the promise resolved)\n    // and the package.json was parsed), we can proactively seed the content cache for the\n    // canonical url.\n    const canonicalHref = this.cdn\n      .urlForPackageFile(`${manifest.name}@${manifest.version}`, '/package.json')\n      .toString();\n\n    this.contentCache.set(canonicalHref, contentResult);\n\n    return manifest;\n  }\n\n  private _withLock<T extends unknown | Promise<unknown>>(\n    lockKey: string,\n    fn: (...args: any[]) => T\n  ): T {\n    const lock = this.locks.get(lockKey);\n    const runCriticalSection = (): T => {\n      const ret = fn();\n\n      if (isThenable(ret)) {\n        const locked = ret.then(\n          (result) => {\n            this.locks.delete(lockKey);\n\n            return result;\n          },\n          (err) => {\n            this.locks.delete(lockKey);\n\n            return Promise.reject(err);\n          }\n        );\n\n        this.locks.set(lockKey, locked);\n\n        return ret;\n      }\n\n      // No need to lock in non-promise\n      return ret;\n    };\n\n    if (isThenable(lock)) {\n      return lock.then(runCriticalSection) as T;\n    }\n\n    return runCriticalSection();\n  }\n\n  static forJsDelivr(readUrlFn: CdnStrategy.UrlContentFetcher) {\n    return new CdnStrategy(readUrlFn, new JSDelivrCdn());\n  }\n\n  static forUnpkg(readUrlFn: CdnStrategy.UrlContentFetcher) {\n    return new CdnStrategy(readUrlFn, new UnpkgCdn());\n  }\n}\n","import {\n  ResolverContext,\n  AbstractResolverStrategy,\n  ResolverStrategy,\n  ResolverStrategyWithRoot,\n} from '@velcro/resolver';\nimport { Uri } from '@velcro/common';\n\ntype StrategyMethodsNames =\n  | 'getCanonicalUrl'\n  | 'getResolveRoot'\n  | 'getSettings'\n  | 'listEntries'\n  | 'readFileContent';\n\ninterface ResolverHostFsOptions {\n  strategies: ResolverStrategyWithRoot[];\n}\n\nexport class CompoundStrategy extends AbstractResolverStrategy implements ResolverStrategy {\n  private readonly strategies: Set<ResolverStrategyWithRoot>;\n\n  constructor(options: ResolverHostFsOptions) {\n    super();\n\n    this.strategies = new Set(options.strategies);\n  }\n\n  private _delegateToStrategy<\n    TMethodName extends StrategyMethodsNames,\n    TMethod extends (ctx: ResolverContext, uri: Uri) => any = ResolverStrategy[TMethodName]\n  >(method: TMethodName, ctx: ResolverContext, uri: Uri) {\n    for (const strategy of this.strategies) {\n      if (Uri.isPrefixOf(strategy.rootUri, uri)) {\n        return strategy[method](ctx, uri) as ReturnType<TMethod>;\n      }\n    }\n\n    return Promise.reject(\n      new Error(`No strategy found whose root is a prefix of ${uri}`)\n    ) as ReturnType<TMethod>;\n  }\n\n  getCanonicalUrl(ctx: ResolverContext, uri: Uri) {\n    return this._delegateToStrategy('getCanonicalUrl', ctx, uri);\n  }\n\n  getResolveRoot(ctx: ResolverContext, uri: Uri) {\n    return this._delegateToStrategy('getResolveRoot', ctx, uri);\n  }\n\n  getUrlForBareModule(ctx: ResolverContext, name: string, spec: string, path: string) {\n    for (const strategy of this.strategies) {\n      if (strategy.getUrlForBareModule) {\n        return strategy.getUrlForBareModule(ctx, name, spec, path);\n      }\n    }\n    return {\n      found: false,\n      uri: null,\n    };\n  }\n\n  listEntries(ctx: ResolverContext, uri: Uri) {\n    return this._delegateToStrategy('listEntries', ctx, uri);\n  }\n\n  readFileContent(ctx: ResolverContext, uri: Uri) {\n    return this._delegateToStrategy('readFileContent', ctx, uri);\n  }\n}\n","import { DisposableStore, Emitter, Event, IDisposable } from '@velcro/common';\n\ntype AnyFunc = (...args: any[]) => any;\n\nexport type DefineEvent<TEventName extends string, TData = never> = {\n  eventName: TEventName;\n  data: TData;\n};\ntype AnyEvent = DefineEvent<string> | DefineEvent<string, unknown>;\ntype EventWithData<TEvent extends AnyEvent> = TEvent extends AnyEvent\n  ? [TEvent['data']] extends [never]\n    ? never\n    : TEvent\n  : never;\ntype EventWithoutData<TEvent extends AnyEvent> = Exclude<TEvent, EventWithData<TEvent>>;\n\nexport type DefineState<TStateName extends string, TData = never> = TStateName extends string\n  ? [TData] extends [never]\n    ? {\n        stateName: TStateName;\n      }\n    : {\n        stateName: TStateName;\n        data: TData;\n      }\n  : never;\ntype AnyState = DefineState<string> | DefineState<string, unknown>;\n\nexport type OnEnterHandlerContext<\n  TState extends AnyState,\n  TEvent extends AnyEvent,\n  TStateName extends TState['stateName'] = TState['stateName']\n> = {\n  event: TEvent;\n  registerDisposable(disposable: IDisposable): void;\n  sendEvent: SendEventFunction<TEvent>;\n  state: Extract<TState, { stateName: TStateName }>;\n  transitionTo: TransitionToFunction<TState, TEvent>;\n};\n\nexport type OnEnterHandlerFunction<\n  TState extends AnyState,\n  TEvent extends AnyEvent,\n  TStateName extends TState['stateName'] = TState['stateName']\n> = (ctx: OnEnterHandlerContext<TState, TEvent, TStateName>) => void;\n\n/**\n * Conditional, mapped type that takes valid states (`TStates`), valid events (`TEvents`)\n * and actions and results in only the *names* of those actions that can be used as enter\n * handlers for the state `TStateName`.\n */\ntype OnEnterHandlerAction<\n  TState extends AnyState,\n  TEvent extends AnyEvent,\n  TStateName extends TState['stateName'],\n  TActions extends { [name: string]: AnyFunc }\n> = {\n  [TActionName in keyof TActions]: TActions[TActionName] extends OnEnterHandlerFunction<\n    TState,\n    TEvent,\n    TStateName\n  >\n    ? TActionName\n    : never;\n}[keyof TActions];\n\nexport type OnEventHandlerContext<\n  TState extends AnyState,\n  TEvent extends AnyEvent,\n  TEventName extends TEvent['eventName'] = TEvent['eventName'],\n  TStateName extends TState['stateName'] = TState['stateName']\n> = {\n  event: Extract<TEvent, { eventName: TEventName }>;\n  registerDisposable(disposable: IDisposable): void;\n  sendEvent: SendEventFunction<TEvent>;\n  state: Extract<TState, { stateName: TStateName }>;\n  transitionTo: TransitionToFunction<TState, TEvent>;\n};\n\nexport type OnEventHandlerFunction<\n  TState extends AnyState,\n  TEvent extends AnyEvent,\n  TEventName extends TEvent['eventName'] = TEvent['eventName'],\n  TStateName extends TState['stateName'] = TState['stateName']\n> = (ctx: OnEventHandlerContext<TState, TEvent, TEventName, TStateName>) => void;\n\nexport type OnExitHandlerContext<\n  TState extends AnyState,\n  TEvent extends AnyEvent,\n  TStateName extends TState['stateName'] = TState['stateName']\n> = { event: TEvent; state: Extract<TState, { stateName: TStateName }> };\n\nexport type OnExitHandlerFunction<\n  TState extends AnyState,\n  TEvent extends AnyEvent,\n  TStateName extends TState['stateName'] = TState['stateName']\n> = (ctx: OnExitHandlerContext<TState, TEvent, TStateName>) => void;\n\ntype ChartDefinition<\n  TState extends AnyState,\n  TEvent extends AnyEvent,\n  TActions extends { [name: string]: AnyFunc } = Record<never, AnyFunc>\n> = {\n  onEnter?: OnEnterHandlerFunction<TState, TEvent>;\n  onEvent?: {\n    [TEventName in TEvent['eventName']]?: OnEventHandlerFunction<TState, TEvent, TEventName>;\n  };\n  onExit?: OnExitHandlerFunction<TState, TEvent>;\n  states: {\n    [TStateName in TState['stateName']]: {\n      onEnter?:\n        | OnEnterHandlerFunction<TState, TEvent, TStateName>\n        | OnEnterHandlerAction<TState, TEvent, TStateName, TActions>;\n      onEvent?: {\n        [TEventName in TEvent['eventName']]?: OnEventHandlerFunction<\n          TState,\n          TEvent,\n          TEventName,\n          TStateName\n        >;\n      };\n      onExit?: OnExitHandlerFunction<TState, TEvent, TStateName>;\n    };\n  };\n};\n\ninterface SendEventFunction<TEvent extends AnyEvent> {\n  <TSentEvent extends EventWithoutData<TEvent>>(eventName: TSentEvent['eventName']): void;\n  <TSentEvent extends EventWithData<TEvent>>(\n    eventName: TSentEvent['eventName'],\n    data: TSentEvent['data']\n  ): void;\n}\n\ninterface TransitionToFunction<TState extends AnyState, TEvent extends AnyEvent> {\n  <TTargetState extends TState, TTriggeringEvent extends TEvent>(\n    state: TTargetState,\n    event: TTriggeringEvent\n  ): void;\n}\n\nexport class FSM<\n  TState extends AnyState,\n  TEvent extends AnyEvent,\n  TActions extends { [name: string]: AnyFunc } = Record<never, AnyFunc>\n> {\n  private readonly onEventEmitter = new Emitter<Readonly<TEvent>>();\n  private readonly onStateChangeEmitter = new Emitter<Readonly<TState>>();\n\n  private readonly actions: TActions;\n  private readonly states: ChartDefinition<TState, TEvent, TActions>;\n  private handlingEvents = false;\n  private isDisposed = false;\n  private mutableState: TState;\n  private pendingExternalEvents: TEvent[] = [];\n  private pendingInternalEvents: TEvent[] = [];\n  private readonly stateDisposer = new DisposableStore();\n\n  constructor(\n    states: ChartDefinition<TState, TEvent, TActions>,\n    initialState: TState,\n    actions?: TActions\n  ) {\n    this.states = states;\n    this.mutableState = initialState;\n    this.actions = actions || ({} as TActions);\n  }\n\n  get onEvent(): Event<Readonly<TEvent>> {\n    return this.onEventEmitter.event;\n  }\n\n  get onStateChange(): Event<Readonly<TState>> {\n    return this.onStateChangeEmitter.event;\n  }\n\n  get state(): Readonly<TState> {\n    return this.mutableState;\n  }\n\n  dispose() {\n    this.stateDisposer.dispose();\n    this.isDisposed = true;\n  }\n\n  sendEvent<TSentEvent extends EventWithoutData<TEvent>>(event: TSentEvent['eventName']): void;\n  sendEvent<TSentEvent extends EventWithData<TEvent>>(\n    event: TSentEvent['eventName'],\n    data: TSentEvent['data']\n  ): void;\n  sendEvent<TSentEvent extends TEvent>(\n    eventName: TSentEvent['eventName'],\n    data?: TSentEvent['data']\n  ): void {\n    if (this.isDisposed) return;\n\n    // console.group();\n    // console.log('sendEvent(%s, %s)', this.state.stateName, eventName, data);\n    this.pendingExternalEvents.push({ eventName, data } as TEvent);\n\n    if (!this.handlingEvents) {\n      this.processEvents();\n    }\n  }\n\n  private processEvents() {\n    if (this.handlingEvents) {\n      throw new Error(\n        'Invariant violation: processEvents should never be called while already processing events.'\n      );\n    }\n\n    this.handlingEvents = true;\n\n    while (\n      !this.isDisposed &&\n      (this.pendingExternalEvents.length || this.pendingInternalEvents.length)\n    ) {\n      while (!this.isDisposed && this.pendingInternalEvents.length) {\n        const event = this.pendingInternalEvents.shift() as TEvent;\n\n        this.onEventEmitter.fire(event);\n\n        const currentStateDef = this.states.states[\n          this.mutableState.stateName as TState['stateName']\n        ];\n\n        // While the current state might not have a handler, there may be a global\n        // handler.\n        const handler =\n          currentStateDef.onEvent?.[event.eventName as TEvent['eventName']] ||\n          this.states.onEvent?.[event.eventName as TEvent['eventName']];\n\n        if (handler) {\n          const state = this.state;\n          handler({\n            event: event as any,\n            registerDisposable: this.stateDisposer.add.bind(this.stateDisposer),\n            sendEvent: this.sendEventInternal.bind(this),\n            state: state as any,\n            transitionTo: this.transitionTo.bind(this),\n          });\n        }\n      }\n\n      while (!this.isDisposed && this.pendingExternalEvents.length) {\n        // Move external events into the internal event queue for the next tick\n        // of the outer loop.\n        this.pendingInternalEvents.push(this.pendingExternalEvents.pop()!);\n      }\n    }\n\n    this.handlingEvents = false;\n  }\n\n  private sendEventInternal<TSentEvent extends EventWithoutData<TEvent>>(\n    event: TSentEvent['eventName']\n  ): void;\n  private sendEventInternal<TSentEvent extends EventWithData<TEvent>>(\n    event: TSentEvent['eventName'],\n    data: TSentEvent['data']\n  ): void;\n  private sendEventInternal<TSentEvent extends TEvent>(\n    eventName: TSentEvent['eventName'],\n    data?: TSentEvent['data']\n  ): void {\n    if (this.isDisposed) return;\n\n    this.pendingInternalEvents.push({ eventName, data } as TEvent);\n\n    if (!this.handlingEvents) {\n      this.processEvents();\n    }\n  }\n\n  private transitionTo<TTargetState extends TState, TTriggeringEvent extends TEvent>(\n    state: TTargetState,\n    event: TTriggeringEvent\n  ) {\n    const fromStateConfig = this.states.states[this.mutableState.stateName as TState['stateName']];\n    const nextStateConfig = this.states.states[state.stateName as TState['stateName']];\n    const fromState = { ...this.mutableState };\n\n    this.mutableState = { ...state };\n    this.onStateChangeEmitter.fire(this.state);\n\n    if (state.stateName !== fromState.stateName) {\n      this.stateDisposer.clear();\n\n      if (fromStateConfig.onExit) {\n        fromStateConfig.onExit({\n          event,\n          state: state as any,\n        });\n      }\n\n      const onEnterDef = nextStateConfig.onEnter;\n\n      if (onEnterDef) {\n        let onEnterHandler:\n          | OnEnterHandlerFunction<TState, TEvent, TState['stateName']>\n          | undefined = undefined;\n\n        if (typeof onEnterDef === 'string') {\n          onEnterHandler = this.actions[onEnterDef];\n        } else if (typeof onEnterDef === 'function') {\n          onEnterHandler = onEnterDef;\n        }\n\n        if (!onEnterHandler) {\n          // TODO: Should we warn / error?\n          return;\n        }\n\n        onEnterHandler({\n          event,\n          registerDisposable: this.stateDisposer.add.bind(this.stateDisposer),\n          sendEvent: this.sendEventInternal.bind(this),\n          state: state as any,\n          transitionTo: this.transitionTo.bind(this),\n        });\n      }\n    }\n  }\n}\n","import { ChunkOutput, GraphBuilder, Plugin, VelcroRuntime } from '@velcro/bundler';\nimport { Uri } from '@velcro/common';\nimport { Resolver } from '@velcro/resolver';\nimport { CdnStrategy } from '@velcro/strategy-cdn';\nimport { CompoundStrategy } from '@velcro/strategy-compound';\nimport { MemoryStrategy } from '@velcro/strategy-memory';\n\nconst defaultExtensions: Resolver.Settings['extensions'] = ['.js', '.json'];\nconst defaultPackageMain: Resolver.Settings['packageMain'] = ['browser', 'main'];\n\nexport interface BuildOptions {\n  cdn?: 'jsdelivr' | 'unpkg';\n  dependencies?: { [key: string]: string };\n  extensions?: Resolver.Settings['extensions'];\n  external?: GraphBuilder.Options['external'];\n  nodeEnv?: string;\n  plugins?: Plugin[];\n  packageMain?: Resolver.Settings['packageMain'];\n  readUrl: CdnStrategy.UrlContentFetcher;\n}\n\nexport interface ExecuteOptions extends BuildOptions {\n  sourceMap?: boolean;\n  injectModules?: { [id: string]: unknown };\n}\n\nexport async function build(\n  code: string,\n  options: BuildOptions\n): Promise<{ entrypointUri: Uri; output: ChunkOutput }> {\n  const entrypointPath = `index.js`;\n  const cdnStrategy =\n    options.cdn === 'unpkg'\n      ? CdnStrategy.forUnpkg(options.readUrl)\n      : CdnStrategy.forJsDelivr(options.readUrl);\n  const memoryStrategy = new MemoryStrategy(\n    {\n      [entrypointPath]: code,\n      ['package.json']: JSON.stringify({\n        name: '@@velcro/execute',\n        version: '0.0.0',\n        dependencies: options.dependencies,\n      }),\n    },\n    Uri.parse(`velcro://${Math.random().toString(16).slice(2)}/`)\n  );\n  const entrypointUri = memoryStrategy.uriForPath(entrypointPath);\n  const compoundStrategy = new CompoundStrategy({ strategies: [cdnStrategy, memoryStrategy] });\n  const resolver = new Resolver(compoundStrategy, {\n    extensions: options.extensions || defaultExtensions,\n    packageMain: options.packageMain || defaultPackageMain,\n  });\n  const graphBuilder = new GraphBuilder({\n    external: options.external,\n    resolver,\n    nodeEnv: options.nodeEnv || 'development',\n    plugins: options.plugins,\n  });\n  const build = graphBuilder.build([entrypointUri]);\n  const graph = await build.done;\n  const [chunk] = graph.splitChunks();\n  const output = chunk.buildForStaticRuntime({\n    injectRuntime: true,\n  });\n\n  return { entrypointUri, output };\n}\n\nexport async function execute<T = unknown>(code: string, options: ExecuteOptions): Promise<T> {\n  if (options.injectModules) {\n    const injectedModuleSpecs = new Set(Object.keys(options.injectModules));\n    const optionsExternal = options.external;\n    const isExternal: GraphBuilder.Options['external'] = (dependency, fromSourceModule) => {\n      if (injectedModuleSpecs.has(dependency.spec)) {\n        return true;\n      }\n\n      return typeof optionsExternal === 'function'\n        ? optionsExternal(dependency, fromSourceModule)\n        : false;\n    };\n\n    options.external = isExternal;\n  }\n\n  const { entrypointUri, output } = await build(code, options);\n  const codeWithStart = `${output.code}\\n\\nreturn Velcro.runtime;\\n`;\n  const runtimeCode = options.sourceMap\n    ? `${codeWithStart}\\n//# sourceMappingURL=${output.sourceMapDataUri}`\n    : codeWithStart;\n\n  const runtimeFn = new Function(runtimeCode) as () => VelcroRuntime;\n  const velcro = runtimeFn();\n\n  if (options.injectModules) {\n    for (const id in options.injectModules) {\n      velcro.inject(id, options.injectModules[id]);\n    }\n  }\n\n  const result = velcro.require(entrypointUri.toString());\n\n  return result as T;\n}\n","export function readUrl(href: string) {\n  return fetch(href).then((res) => {\n    if (!res.ok) {\n      return Promise.reject(\n        new Error(\n          `Error while fetching from '${href}' with status: ${res.status} ${res.statusText}`\n        )\n      );\n    }\n\n    return res.arrayBuffer();\n  });\n}\n","import { execute } from '@velcro/runner';\nimport { version as svelteVersion } from 'svelte/package.json';\n\nimport { readUrl } from '../util';\nimport { Plugin } from '@velcro/bundler';\n\nexport function sveltePlugin(): Plugin {\n  let svelteCompilerPromise: Promise<typeof import('svelte/compiler')> | undefined = undefined;\n\n  const loadCompiler = () => {\n    if (!svelteCompilerPromise) {\n      svelteCompilerPromise = execute('module.exports = require(\"svelte/compiler\")', {\n        readUrl,\n        cdn: 'jsdelivr',\n        dependencies: {\n          svelte: svelteVersion,\n        },\n        nodeEnv: 'production',\n        // plugins: [sucrasePlugin()],\n      });\n\n      svelteCompilerPromise.catch((err) => {\n        console.trace(err);\n      });\n    }\n\n    return svelteCompilerPromise;\n  };\n\n  return {\n    name: 'svelte',\n    async transform(ctx, uri, code) {\n      if (uri.fsPath.endsWith('.svelte')) {\n        const compiler = await loadCompiler();\n        const compilationResult = compiler.compile(code, {\n          css: false,\n          outputFilename: uri.toString(),\n          format: 'cjs',\n        });\n\n        // The CommonJS produced by svelte dumps the component on `exports.default` but doesn't use the `__esModule`\n        // interop hint. This is a little hack to work around that.\n        code = `${compilationResult.js.code}; Object.defineProperty(module.exports, '__esModule', { value: true });`;\n\n        return {\n          code,\n          sourceMap: compilationResult.js.map,\n        };\n      }\n      return undefined;\n    },\n  };\n}\n","import { GraphBuilder } from '@velcro/bundler';\nimport { CancellationTokenSource, Uri } from '@velcro/common';\nimport { cssPlugin } from '@velcro/plugin-css';\nimport { sucrasePlugin } from '@velcro/plugin-sucrase';\nimport { Resolver } from '@velcro/resolver';\nimport { CdnStrategy } from '@velcro/strategy-cdn';\nimport { CompoundStrategy } from '@velcro/strategy-compound';\nimport { MemoryStrategy } from '@velcro/strategy-memory';\nimport { VelcroBuilder } from './builder';\nimport { Events } from './events';\nimport { FSM, OnEventHandlerContext } from './fsm';\nimport { sveltePlugin } from './plugins/svelte';\nimport { States } from './states';\nimport { readUrl } from './util';\n\nexport class VelcroBuilderServer extends FSM<States, Events> implements VelcroBuilder {\n  private readonly localStrategy = new MemoryStrategy({}, Uri.file('/'));\n  private readonly npmStrategy = CdnStrategy.forJsDelivr(readUrl);\n  private readonly rootStrategy = new CompoundStrategy({\n    strategies: [this.localStrategy, this.npmStrategy],\n  });\n  private readonly resolver: Resolver;\n  private readonly graphBuilder: GraphBuilder;\n\n  constructor() {\n    super(\n      {\n        onEvent: {\n          file_create: (ctx) => this.onFileCreate(ctx),\n          file_remove: (ctx) => this.onFileRemove(ctx),\n          file_update: (ctx) => this.onFileUpdate(ctx),\n          start_build: ({ event, transitionTo }) =>\n            transitionTo(\n              {\n                stateName: 'build_in_progress',\n                data: {\n                  generateSourceMap: event.data.generateSourceMap,\n                  completed: 0,\n                  pending: 0,\n                  start: Date.now(),\n                },\n              },\n              event\n            ),\n        },\n        states: {\n          idle: {},\n          dirty_reset: {},\n          dirty: {},\n          build_in_progress: {\n            onEnter: ({ registerDisposable, sendEvent, state }) => {\n              const tokenSource = new CancellationTokenSource();\n              const start = Date.now();\n              const build = this.graphBuilder.build([this.localStrategy.rootUri], {\n                incremental: false,\n                token: tokenSource.token,\n              });\n\n              registerDisposable({\n                dispose() {\n                  tokenSource.dispose(true);\n                },\n              });\n              registerDisposable(\n                build.onCompleted(({ graph }) => {\n                  const [chunk] = graph.splitChunks();\n                  const build = chunk.buildForStaticRuntime({ injectRuntime: true });\n\n                  let sourceMap = '';\n\n                  switch (state.data.generateSourceMap) {\n                    case 'data-uri':\n                      sourceMap = build.sourceMapDataUri;\n                      break;\n                    case 'string':\n                      sourceMap = build.sourceMapString;\n                      break;\n                  }\n\n                  sendEvent('build_complete', {\n                    code: build.code,\n                    sourceMap,\n                    start,\n                    end: Date.now(),\n                  });\n                })\n              );\n              registerDisposable(\n                build.onProgress(({ progress }) =>\n                  sendEvent('build_progress', { start, ...progress })\n                )\n              );\n              registerDisposable(\n                build.onError(({ error }) => {\n                  return sendEvent('build_error', { error: error.message, start, end: Date.now() });\n                })\n              );\n\n              this.graphBuilder.build([this.localStrategy.rootUri], {\n                incremental: false,\n                token: tokenSource.token,\n              });\n            },\n            onEvent: {\n              build_progress: ({ event, state, transitionTo }) =>\n                transitionTo(\n                  { stateName: 'build_in_progress', data: { ...state.data, ...event.data } },\n                  event\n                ),\n              build_complete: ({ event, state, transitionTo }) =>\n                transitionTo({ stateName: 'build_complete', data: event.data }, event),\n              build_error: ({ event, state, transitionTo }) =>\n                transitionTo({ stateName: 'build_error', data: event.data }, event),\n            },\n          },\n          build_complete: {},\n          build_error: {},\n        },\n      },\n      { stateName: 'idle' }\n    );\n\n    this.resolver = new Resolver(this.rootStrategy, {\n      debug: false,\n      extensions: ['.js', '.jsx', '.json', '.ts', '.tsx', '.mjs', '.cjs'],\n      packageMain: ['browser', 'main'],\n    });\n    this.graphBuilder = new GraphBuilder({\n      resolver: this.resolver,\n      nodeEnv: 'development',\n      plugins: [\n        cssPlugin(),\n        sveltePlugin(),\n        sucrasePlugin({ transforms: ['imports', 'jsx', 'typescript'] }),\n      ],\n    });\n  }\n\n  private onFileCreate({\n    event,\n    transitionTo,\n  }: OnEventHandlerContext<States, Events, 'file_create'>) {\n    const uri = Uri.parse(event.data.href);\n\n    if (!Uri.isPrefixOf(this.localStrategy.rootUri, uri)) {\n      return false;\n    }\n\n    this.localStrategy.addFile(uri.fsPath, event.data.content);\n    this.graphBuilder.invalidate(uri);\n    this.graphBuilder.invalidate(Uri.joinPath(uri, '..'));\n\n    transitionTo({ stateName: 'dirty' }, event);\n  }\n\n  private onFileRemove({\n    event,\n    transitionTo,\n  }: OnEventHandlerContext<States, Events, 'file_remove'>) {\n    const uri = Uri.parse(event.data.href);\n\n    if (!Uri.isPrefixOf(this.localStrategy.rootUri, uri)) {\n      return false;\n    }\n\n    this.localStrategy.removeFile(uri.fsPath);\n    this.graphBuilder.invalidate(uri);\n    this.graphBuilder.invalidate(Uri.joinPath(uri, '..'));\n\n    transitionTo({ stateName: 'dirty' }, event);\n  }\n\n  private onFileUpdate({\n    event,\n    transitionTo,\n  }: OnEventHandlerContext<States, Events, 'file_update'>) {\n    const uri = Uri.parse(event.data.href);\n\n    if (!Uri.isPrefixOf(this.localStrategy.rootUri, uri)) {\n      return false;\n    }\n\n    this.localStrategy.addFile(uri.fsPath, event.data.content, { overwrite: true });\n    this.graphBuilder.invalidate(uri);\n\n    transitionTo({ stateName: 'dirty' }, event);\n  }\n}\n","import type { Plugin } from '@velcro/bundler';\n\nexport function cssPlugin(): Plugin {\n  return {\n    name: 'cssPlugin',\n    transform(ctx, uri, code) {\n      if (!uri.path.endsWith('.css')) {\n        return;\n      }\n\n      const cssCode = code;\n      const magicString = ctx.createMagicString();\n      const BACKSLASH = '\\\\'.charCodeAt(0);\n      const SINGLE_QUOTE = \"'\".charCodeAt(0);\n      const NL = '\\n'.charCodeAt(0);\n      const CR = '\\r'.charCodeAt(0);\n\n      for (let i = 0; i < cssCode.length; i++) {\n        const char = cssCode.charCodeAt(i);\n        // Escape certain characters (if not already escaped)\n        switch (char) {\n          case CR:\n          case NL:\n            // Break the resulting JavaScript string across new lines\n            // so that original css lines have a 1:1 with JavaScript lines.\n            // This allows the resulting source-map to correct show the\n            // original source whereas if the source had been collapsed to\n            // a JavaScript string on a single line, all the detail is lost.\n            magicString.overwrite(i, i + 1, \"',\\n'\");\n            break;\n          case BACKSLASH:\n          case SINGLE_QUOTE:\n            magicString.prependRight(i, '\\\\');\n            break;\n        }\n      }\n\n      magicString.prepend(`\n        function reload(){\n          var styleTag = document.createElement(\"style\");\n          styleTag.type = \"text/css\";\n          styleTag.innerHTML = ['`);\n      magicString.append(`'].join('\\\\n');\n          document.head.appendChild(styleTag);\n          return {\n            dispose: function() {    \n              if (styleTag && styleTag.parentElement) {\n                styleTag.parentElement.removeChild(styleTag);\n              }\n            },\n            element: styleTag\n          };\n        };\n        var result = reload();\n        module.exports = result.element;\n        if (module.hot && module.hot.dispose) {\n          module.hot.dispose(function() {\n            result.dispose();\n          });\n        }\n      `);\n\n      return {\n        code: magicString.toString(),\n        sourceMap: magicString.generateDecodedMap(),\n      };\n    },\n  };\n}\n","/**\n * @since 2.0.0\n */\n/**\n * @since 2.0.0\n */\nexport function identity(a) {\n    return a;\n}\n/**\n * @since 2.0.0\n */\nexport var unsafeCoerce = identity;\n/**\n * @since 2.0.0\n */\nexport function not(predicate) {\n    return function (a) { return !predicate(a); };\n}\n/**\n * @since 2.0.0\n */\nexport function constant(a) {\n    return function () { return a; };\n}\n/**\n * A thunk that returns always `true`\n *\n * @since 2.0.0\n */\nexport var constTrue = function () {\n    return true;\n};\n/**\n * A thunk that returns always `false`\n *\n * @since 2.0.0\n */\nexport var constFalse = function () {\n    return false;\n};\n/**\n * A thunk that returns always `null`\n *\n * @since 2.0.0\n */\nexport var constNull = function () {\n    return null;\n};\n/**\n * A thunk that returns always `undefined`\n *\n * @since 2.0.0\n */\nexport var constUndefined = function () {\n    return;\n};\n/**\n * A thunk that returns always `void`\n *\n * @since 2.0.0\n */\nexport var constVoid = function () {\n    return;\n};\n// TODO: remove in v3\n/**\n * Flips the order of the arguments of a function of two arguments.\n *\n * @since 2.0.0\n */\nexport function flip(f) {\n    return function (b, a) { return f(a, b); };\n}\nexport function flow(ab, bc, cd, de, ef, fg, gh, hi, ij) {\n    switch (arguments.length) {\n        case 1:\n            return ab;\n        case 2:\n            return function () {\n                return bc(ab.apply(this, arguments));\n            };\n        case 3:\n            return function () {\n                return cd(bc(ab.apply(this, arguments)));\n            };\n        case 4:\n            return function () {\n                return de(cd(bc(ab.apply(this, arguments))));\n            };\n        case 5:\n            return function () {\n                return ef(de(cd(bc(ab.apply(this, arguments)))));\n            };\n        case 6:\n            return function () {\n                return fg(ef(de(cd(bc(ab.apply(this, arguments))))));\n            };\n        case 7:\n            return function () {\n                return gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))));\n            };\n        case 8:\n            return function () {\n                return hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments))))))));\n            };\n        case 9:\n            return function () {\n                return ij(hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))))));\n            };\n    }\n    return;\n}\n/**\n * @since 2.0.0\n */\nexport function tuple() {\n    var t = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        t[_i] = arguments[_i];\n    }\n    return t;\n}\n/**\n * @since 2.0.0\n */\nexport function increment(n) {\n    return n + 1;\n}\n/**\n * @since 2.0.0\n */\nexport function decrement(n) {\n    return n - 1;\n}\n/**\n * @since 2.0.0\n */\nexport function absurd(_) {\n    throw new Error('Called `absurd` function which should be uncallable');\n}\n/**\n * Creates a tupled version of this function: instead of `n` arguments, it accepts a single tuple argument.\n *\n * @example\n * import { tupled } from 'fp-ts/function'\n *\n * const add = tupled((x: number, y: number): number => x + y)\n *\n * assert.strictEqual(add([1, 2]), 3)\n *\n * @since 2.4.0\n */\nexport function tupled(f) {\n    return function (a) { return f.apply(void 0, a); };\n}\n/**\n * Inverse function of `tupled`\n *\n * @since 2.4.0\n */\nexport function untupled(f) {\n    return function () {\n        var a = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            a[_i] = arguments[_i];\n        }\n        return f(a);\n    };\n}\nexport function pipe(a, ab, bc, cd, de, ef, fg, gh, hi, ij) {\n    switch (arguments.length) {\n        case 1:\n            return a;\n        case 2:\n            return ab(a);\n        case 3:\n            return bc(ab(a));\n        case 4:\n            return cd(bc(ab(a)));\n        case 5:\n            return de(cd(bc(ab(a))));\n        case 6:\n            return ef(de(cd(bc(ab(a)))));\n        case 7:\n            return fg(ef(de(cd(bc(ab(a))))));\n        case 8:\n            return gh(fg(ef(de(cd(bc(ab(a)))))));\n        case 9:\n            return hi(gh(fg(ef(de(cd(bc(ab(a))))))));\n        case 10:\n            return ij(hi(gh(fg(ef(de(cd(bc(ab(a)))))))));\n    }\n    return;\n}\n/**\n * Type hole simulation\n *\n * @since 2.7.0\n */\nexport var hole = absurd;\n/**\n * @internal\n */\nexport var bind_ = function (a, name, b) {\n    var _a;\n    return Object.assign({}, a, (_a = {}, _a[name] = b, _a));\n};\n/**\n * @internal\n */\nexport var bindTo_ = function (name) { return function (b) {\n    var _a;\n    return (_a = {}, _a[name] = b, _a);\n}; };\n","import { tailRec } from './ChainRec';\nimport { identity, pipe, bind_, bindTo_, flow } from './function';\n// -------------------------------------------------------------------------------------\n// guards\n// -------------------------------------------------------------------------------------\n/**\n * Returns `true` if the either is an instance of `Left`, `false` otherwise\n *\n * @category guards\n * @since 2.0.0\n */\nexport var isLeft = function (ma) { return ma._tag === 'Left'; };\n/**\n * Returns `true` if the either is an instance of `Right`, `false` otherwise\n *\n * @category guards\n * @since 2.0.0\n */\nexport var isRight = function (ma) { return ma._tag === 'Right'; };\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * Constructs a new `Either` holding a `Left` value. This usually represents a failure, due to the right-bias of this\n * structure\n *\n * @category constructors\n * @since 2.0.0\n */\nexport var left = function (e) { return ({ _tag: 'Left', left: e }); };\n/**\n * Constructs a new `Either` holding a `Right` value. This usually represents a successful value due to the right bias\n * of this structure\n *\n * @category constructors\n * @since 2.0.0\n */\nexport var right = function (a) { return ({ _tag: 'Right', right: a }); };\n// TODO: make lazy in v3\n/**\n * Takes a default and a nullable value, if the value is not nully, turn it into a `Right`, if the value is nully use\n * the provided default as a `Left`\n *\n * @example\n * import { fromNullable, left, right } from 'fp-ts/Either'\n *\n * const parse = fromNullable('nully')\n *\n * assert.deepStrictEqual(parse(1), right(1))\n * assert.deepStrictEqual(parse(null), left('nully'))\n *\n * @category constructors\n * @since 2.0.0\n */\nexport function fromNullable(e) {\n    return function (a) { return (a == null ? left(e) : right(a)); };\n}\n// TODO: `onError => Lazy<A> => Either` in v3\n/**\n * Constructs a new `Either` from a function that might throw\n *\n * @example\n * import { Either, left, right, tryCatch } from 'fp-ts/Either'\n *\n * const unsafeHead = <A>(as: Array<A>): A => {\n *   if (as.length > 0) {\n *     return as[0]\n *   } else {\n *     throw new Error('empty array')\n *   }\n * }\n *\n * const head = <A>(as: Array<A>): Either<Error, A> => {\n *   return tryCatch(() => unsafeHead(as), e => (e instanceof Error ? e : new Error('unknown error')))\n * }\n *\n * assert.deepStrictEqual(head([]), left(new Error('empty array')))\n * assert.deepStrictEqual(head([1, 2, 3]), right(1))\n *\n * @category constructors\n * @since 2.0.0\n */\nexport function tryCatch(f, onError) {\n    try {\n        return right(f());\n    }\n    catch (e) {\n        return left(onError(e));\n    }\n}\n// TODO curry in v3\n/**\n * Converts a JavaScript Object Notation (JSON) string into an object.\n *\n * @example\n * import { parseJSON, toError, right, left } from 'fp-ts/Either'\n *\n * assert.deepStrictEqual(parseJSON('{\"a\":1}', toError), right({ a: 1 }))\n * assert.deepStrictEqual(parseJSON('{\"a\":}', toError), left(new SyntaxError('Unexpected token } in JSON at position 5')))\n *\n * @category constructors\n * @since 2.0.0\n */\nexport function parseJSON(s, onError) {\n    return tryCatch(function () { return JSON.parse(s); }, onError);\n}\n// TODO curry in v3\n/**\n * Converts a JavaScript value to a JavaScript Object Notation (JSON) string.\n *\n * @example\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(E.stringifyJSON({ a: 1 }, E.toError), E.right('{\"a\":1}'))\n * const circular: any = { ref: null }\n * circular.ref = circular\n * assert.deepStrictEqual(\n *   pipe(\n *     E.stringifyJSON(circular, E.toError),\n *     E.mapLeft(e => e.message.includes('Converting circular structure to JSON'))\n *   ),\n *   E.left(true)\n * )\n *\n * @category constructors\n * @since 2.0.0\n */\nexport function stringifyJSON(u, onError) {\n    return tryCatch(function () { return JSON.stringify(u); }, onError);\n}\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport var fromOption = function (onNone) { return function (ma) {\n    return ma._tag === 'None' ? left(onNone()) : right(ma.value);\n}; };\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport var fromPredicate = function (predicate, onFalse) { return function (a) { return (predicate(a) ? right(a) : left(onFalse(a))); }; };\n// -------------------------------------------------------------------------------------\n// destructors\n// -------------------------------------------------------------------------------------\n/**\n * Takes two functions and an `Either` value, if the value is a `Left` the inner value is applied to the first function,\n * if the value is a `Right` the inner value is applied to the second function.\n *\n * @example\n * import { fold, left, right } from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n *\n * function onLeft(errors: Array<string>): string {\n *   return `Errors: ${errors.join(', ')}`\n * }\n *\n * function onRight(value: number): string {\n *   return `Ok: ${value}`\n * }\n *\n * assert.strictEqual(\n *   pipe(\n *     right(1),\n *     fold(onLeft, onRight)\n *   ),\n *   'Ok: 1'\n * )\n * assert.strictEqual(\n *   pipe(\n *     left(['error 1', 'error 2']),\n *     fold(onLeft, onRight)\n *   ),\n *   'Errors: error 1, error 2'\n * )\n *\n * @category destructors\n * @since 2.0.0\n */\nexport function fold(onLeft, onRight) {\n    return function (ma) { return (isLeft(ma) ? onLeft(ma.left) : onRight(ma.right)); };\n}\n/**\n * Less strict version of [`getOrElse`](#getOrElse).\n *\n * @category destructors\n * @since 2.6.0\n */\nexport var getOrElseW = function (onLeft) { return function (ma) {\n    return isLeft(ma) ? onLeft(ma.left) : ma.right;\n}; };\n/**\n * @category destructors\n * @since 2.0.0\n */\nexport var getOrElse = getOrElseW;\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * @category combinators\n * @since 2.0.0\n */\nexport function swap(ma) {\n    return isLeft(ma) ? right(ma.left) : left(ma.right);\n}\n/**\n * @category combinators\n * @since 2.0.0\n */\nexport function orElse(onLeft) {\n    return function (ma) { return (isLeft(ma) ? onLeft(ma.left) : ma); };\n}\n/**\n * @category combinators\n * @since 2.0.0\n */\nexport var filterOrElse = function (predicate, onFalse) { return function (ma) {\n    return chain_(ma, function (a) { return (predicate(a) ? right(a) : left(onFalse(a))); });\n}; };\n// -------------------------------------------------------------------------------------\n// non-pipeables\n// -------------------------------------------------------------------------------------\nvar map_ = function (ma, f) { return (isLeft(ma) ? ma : right(f(ma.right))); };\nvar ap_ = function (mab, ma) {\n    return isLeft(mab) ? mab : isLeft(ma) ? ma : right(mab.right(ma.right));\n};\nvar chain_ = function (ma, f) {\n    return isLeft(ma) ? ma : f(ma.right);\n};\nvar reduce_ = function (fa, b, f) { return (isLeft(fa) ? b : f(b, fa.right)); };\nvar foldMap_ = function (M) { return function (fa, f) { return (isLeft(fa) ? M.empty : f(fa.right)); }; };\nvar reduceRight_ = function (fa, b, f) { return (isLeft(fa) ? b : f(fa.right, b)); };\nvar traverse_ = function (F) { return function (ma, f) {\n    return isLeft(ma) ? F.of(left(ma.left)) : F.map(f(ma.right), right);\n}; };\nvar bimap_ = function (fea, f, g) { return (isLeft(fea) ? left(f(fea.left)) : right(g(fea.right))); };\nvar mapLeft_ = function (fea, f) { return (isLeft(fea) ? left(f(fea.left)) : fea); };\nvar alt_ = function (fa, that) { return (isLeft(fa) ? that() : fa); };\nvar extend_ = function (wa, f) { return (isLeft(wa) ? wa : right(f(wa))); };\nvar chainRec_ = function (a, f) {\n    return tailRec(f(a), function (e) {\n        return isLeft(e) ? right(left(e.left)) : isLeft(e.right) ? left(f(e.right.left)) : right(right(e.right.right));\n    });\n};\n// -------------------------------------------------------------------------------------\n// pipeables\n// -------------------------------------------------------------------------------------\n/**\n * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types\n * use the type constructor `F` to represent some computational context.\n *\n * @category Functor\n * @since 2.0.0\n */\nexport var map = function (f) { return function (fa) { return map_(fa, f); }; };\n/**\n * Map a pair of functions over the two type arguments of the bifunctor.\n *\n * @category Bifunctor\n * @since 2.0.0\n */\nexport var bimap = function (f, g) { return function (fa) { return bimap_(fa, f, g); }; };\n/**\n * Map a function over the first type argument of a bifunctor.\n *\n * @category Bifunctor\n * @since 2.0.0\n */\nexport var mapLeft = function (f) { return function (fa) { return mapLeft_(fa, f); }; };\n/**\n * Less strict version of [`ap`](#ap).\n *\n * @category Apply\n * @since 2.8.0\n */\nexport var apW = function (fa) { return function (fab) {\n    return ap_(fab, fa);\n}; };\n/**\n * Apply a function to an argument under a type constructor.\n *\n * @category Apply\n * @since 2.0.0\n */\nexport var ap = apW;\n/**\n * Combine two effectful actions, keeping only the result of the first.\n *\n * @category Apply\n * @since 2.0.0\n */\nexport var apFirst = function (fb) { return function (fa) {\n    return ap_(map_(fa, function (a) { return function () { return a; }; }), fb);\n}; };\n/**\n * Combine two effectful actions, keeping only the result of the second.\n *\n * @category Apply\n * @since 2.0.0\n */\nexport var apSecond = function (fb) { return function (fa) {\n    return ap_(map_(fa, function () { return function (b) { return b; }; }), fb);\n}; };\n/**\n * @category Applicative\n * @since 2.7.0\n */\nexport var of = right;\n/**\n * Less strict version of [`chain`](#chain).\n *\n * @category Monad\n * @since 2.6.0\n */\nexport var chainW = function (f) { return function (ma) { return chain_(ma, f); }; };\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation.\n *\n * @category Monad\n * @since 2.0.0\n */\nexport var chain = chainW;\n/**\n * Less strict version of [`chainFirst`](#chainFirst)\n *\n * @category Monad\n * @since 2.8.0\n */\nexport var chainFirstW = function (f) { return function (ma) { return chain_(ma, function (a) { return map_(f(a), function () { return a; }); }); }; };\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @category Monad\n * @since 2.0.0\n */\nexport var chainFirst = chainFirstW;\n/**\n * @category Monad\n * @since 2.0.0\n */\nexport var flatten = function (mma) { return chain_(mma, identity); };\n/**\n * Identifies an associative operation on a type constructor. It is similar to `Semigroup`, except that it applies to\n * types of kind `* -> *`.\n *\n * @category Alt\n * @since 2.0.0\n */\nexport var alt = function (that) { return function (fa) {\n    return alt_(fa, that);\n}; };\n/**\n * @category Extend\n * @since 2.0.0\n */\nexport var duplicate = function (wa) { return extend_(wa, identity); };\n/**\n * @category Extend\n * @since 2.0.0\n */\nexport var extend = function (f) { return function (ma) {\n    return extend_(ma, f);\n}; };\n/**\n * @category Foldable\n * @since 2.0.0\n */\nexport var reduce = function (b, f) { return function (fa) {\n    return reduce_(fa, b, f);\n}; };\n/**\n * @category Foldable\n * @since 2.0.0\n */\nexport var foldMap = function (M) {\n    var foldMapM = foldMap_(M);\n    return function (f) { return function (fa) { return foldMapM(fa, f); }; };\n};\n/**\n * @category Foldable\n * @since 2.0.0\n */\nexport var reduceRight = function (b, f) { return function (fa) {\n    return reduceRight_(fa, b, f);\n}; };\n/**\n * @category Traversable\n * @since 2.6.3\n */\nexport var traverse = function (F) {\n    var traverseF = traverse_(F);\n    return function (f) { return function (fa) { return traverseF(fa, f); }; };\n};\n/**\n * @category Traversable\n * @since 2.6.3\n */\nexport var sequence = function (F) { return function (ma) {\n    return isLeft(ma) ? F.of(left(ma.left)) : F.map(ma.right, right);\n}; };\n/**\n * @category MonadThrow\n * @since 2.6.3\n */\nexport var throwError = left;\n// -------------------------------------------------------------------------------------\n// instances\n// -------------------------------------------------------------------------------------\n/**\n * @category instances\n * @since 2.0.0\n */\nexport var URI = 'Either';\n/**\n * @category instances\n * @since 2.0.0\n */\nexport function getShow(SE, SA) {\n    return {\n        show: function (ma) { return (isLeft(ma) ? \"left(\" + SE.show(ma.left) + \")\" : \"right(\" + SA.show(ma.right) + \")\"); }\n    };\n}\n/**\n * @category instances\n * @since 2.0.0\n */\nexport function getEq(EL, EA) {\n    return {\n        equals: function (x, y) {\n            return x === y || (isLeft(x) ? isLeft(y) && EL.equals(x.left, y.left) : isRight(y) && EA.equals(x.right, y.right));\n        }\n    };\n}\n/**\n * Semigroup returning the left-most non-`Left` value. If both operands are `Right`s then the inner values are\n * concatenated using the provided `Semigroup`\n *\n * @example\n * import { getSemigroup, left, right } from 'fp-ts/Either'\n * import { semigroupSum } from 'fp-ts/Semigroup'\n *\n * const S = getSemigroup<string, number>(semigroupSum)\n * assert.deepStrictEqual(S.concat(left('a'), left('b')), left('a'))\n * assert.deepStrictEqual(S.concat(left('a'), right(2)), right(2))\n * assert.deepStrictEqual(S.concat(right(1), left('b')), right(1))\n * assert.deepStrictEqual(S.concat(right(1), right(2)), right(3))\n *\n * @category instances\n * @since 2.0.0\n */\nexport function getSemigroup(S) {\n    return {\n        concat: function (x, y) { return (isLeft(y) ? x : isLeft(x) ? y : right(S.concat(x.right, y.right))); }\n    };\n}\n/**\n * Semigroup returning the left-most `Left` value. If both operands are `Right`s then the inner values\n * are concatenated using the provided `Semigroup`\n *\n * @example\n * import { getApplySemigroup, left, right } from 'fp-ts/Either'\n * import { semigroupSum } from 'fp-ts/Semigroup'\n *\n * const S = getApplySemigroup<string, number>(semigroupSum)\n * assert.deepStrictEqual(S.concat(left('a'), left('b')), left('a'))\n * assert.deepStrictEqual(S.concat(left('a'), right(2)), left('a'))\n * assert.deepStrictEqual(S.concat(right(1), left('b')), left('b'))\n * assert.deepStrictEqual(S.concat(right(1), right(2)), right(3))\n *\n * @category instances\n * @since 2.0.0\n */\nexport function getApplySemigroup(S) {\n    return {\n        concat: function (x, y) { return (isLeft(x) ? x : isLeft(y) ? y : right(S.concat(x.right, y.right))); }\n    };\n}\n/**\n * @category instances\n * @since 2.0.0\n */\nexport function getApplyMonoid(M) {\n    return {\n        concat: getApplySemigroup(M).concat,\n        empty: right(M.empty)\n    };\n}\n/**\n * Builds a `Filterable` instance for `Either` given `Monoid` for the left side\n *\n * @category instances\n * @since 3.0.0\n */\nexport function getFilterable(M) {\n    var empty = left(M.empty);\n    var compact = function (ma) {\n        return isLeft(ma) ? ma : ma.right._tag === 'None' ? empty : right(ma.right.value);\n    };\n    var separate = function (ma) {\n        return isLeft(ma)\n            ? { left: ma, right: ma }\n            : isLeft(ma.right)\n                ? { left: right(ma.right.left), right: empty }\n                : { left: empty, right: right(ma.right.right) };\n    };\n    var partitionMap = function (ma, f) {\n        if (isLeft(ma)) {\n            return { left: ma, right: ma };\n        }\n        var e = f(ma.right);\n        return isLeft(e) ? { left: right(e.left), right: empty } : { left: empty, right: right(e.right) };\n    };\n    var partition = function (ma, p) {\n        return isLeft(ma)\n            ? { left: ma, right: ma }\n            : p(ma.right)\n                ? { left: empty, right: right(ma.right) }\n                : { left: right(ma.right), right: empty };\n    };\n    var filterMap = function (ma, f) {\n        if (isLeft(ma)) {\n            return ma;\n        }\n        var ob = f(ma.right);\n        return ob._tag === 'None' ? empty : right(ob.value);\n    };\n    var filter = function (ma, predicate) {\n        return isLeft(ma) ? ma : predicate(ma.right) ? ma : empty;\n    };\n    return {\n        URI: URI,\n        _E: undefined,\n        map: map_,\n        compact: compact,\n        separate: separate,\n        filter: filter,\n        filterMap: filterMap,\n        partition: partition,\n        partitionMap: partitionMap\n    };\n}\n/**\n * Builds `Witherable` instance for `Either` given `Monoid` for the left side\n *\n * @category instances\n * @since 2.0.0\n */\nexport function getWitherable(M) {\n    var F_ = getFilterable(M);\n    var wither = function (F) {\n        var traverseF = traverse_(F);\n        return function (ma, f) { return F.map(traverseF(ma, f), F_.compact); };\n    };\n    var wilt = function (F) {\n        var traverseF = traverse_(F);\n        return function (ma, f) { return F.map(traverseF(ma, f), F_.separate); };\n    };\n    return {\n        URI: URI,\n        _E: undefined,\n        map: map_,\n        compact: F_.compact,\n        separate: F_.separate,\n        filter: F_.filter,\n        filterMap: F_.filterMap,\n        partition: F_.partition,\n        partitionMap: F_.partitionMap,\n        traverse: traverse_,\n        sequence: sequence,\n        reduce: reduce_,\n        foldMap: foldMap_,\n        reduceRight: reduceRight_,\n        wither: wither,\n        wilt: wilt\n    };\n}\n/**\n * @category instances\n * @since 2.7.0\n */\nexport function getApplicativeValidation(SE) {\n    return {\n        URI: URI,\n        _E: undefined,\n        map: map_,\n        ap: function (fab, fa) {\n            return isLeft(fab)\n                ? isLeft(fa)\n                    ? left(SE.concat(fab.left, fa.left))\n                    : fab\n                : isLeft(fa)\n                    ? fa\n                    : right(fab.right(fa.right));\n        },\n        of: of\n    };\n}\n/**\n * @category instances\n * @since 2.7.0\n */\nexport function getAltValidation(SE) {\n    return {\n        URI: URI,\n        _E: undefined,\n        map: map_,\n        alt: function (me, that) {\n            if (isRight(me)) {\n                return me;\n            }\n            var ea = that();\n            return isLeft(ea) ? left(SE.concat(me.left, ea.left)) : ea;\n        }\n    };\n}\n// TODO: remove in v3\n/**\n * @category instances\n * @since 2.0.0\n */\nexport function getValidation(SE) {\n    var applicativeValidation = getApplicativeValidation(SE);\n    var altValidation = getAltValidation(SE);\n    return {\n        URI: URI,\n        _E: undefined,\n        map: map_,\n        of: of,\n        chain: chain_,\n        bimap: bimap_,\n        mapLeft: mapLeft_,\n        reduce: reduce_,\n        foldMap: foldMap_,\n        reduceRight: reduceRight_,\n        extend: extend_,\n        traverse: traverse_,\n        sequence: sequence,\n        chainRec: chainRec_,\n        throwError: throwError,\n        ap: applicativeValidation.ap,\n        alt: altValidation.alt\n    };\n}\n/**\n * @category instances\n * @since 2.0.0\n */\nexport function getValidationSemigroup(SE, SA) {\n    return {\n        concat: function (x, y) {\n            return isLeft(x) ? (isLeft(y) ? left(SE.concat(x.left, y.left)) : x) : isLeft(y) ? y : right(SA.concat(x.right, y.right));\n        }\n    };\n}\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Functor = {\n    URI: URI,\n    map: map_\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Applicative = {\n    URI: URI,\n    map: map_,\n    ap: ap_,\n    of: of\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Monad = {\n    URI: URI,\n    map: map_,\n    ap: ap_,\n    of: of,\n    chain: chain_\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Foldable = {\n    URI: URI,\n    reduce: reduce_,\n    foldMap: foldMap_,\n    reduceRight: reduceRight_\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Traversable = {\n    URI: URI,\n    map: map_,\n    reduce: reduce_,\n    foldMap: foldMap_,\n    reduceRight: reduceRight_,\n    traverse: traverse_,\n    sequence: sequence\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Bifunctor = {\n    URI: URI,\n    bimap: bimap_,\n    mapLeft: mapLeft_\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Alt = {\n    URI: URI,\n    map: map_,\n    alt: alt_\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Extend = {\n    URI: URI,\n    map: map_,\n    extend: extend_\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var ChainRec = {\n    URI: URI,\n    map: map_,\n    ap: ap_,\n    chain: chain_,\n    chainRec: chainRec_\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var MonadThrow = {\n    URI: URI,\n    map: map_,\n    ap: ap_,\n    of: of,\n    chain: chain_,\n    throwError: throwError\n};\n/**\n * @category instances\n * @since 2.0.0\n */\nexport function getValidationMonoid(SE, SA) {\n    return {\n        concat: getValidationSemigroup(SE, SA).concat,\n        empty: right(SA.empty)\n    };\n}\n/**\n * @category instances\n * @since 2.0.0\n */\nexport var either = {\n    URI: URI,\n    map: map_,\n    of: of,\n    ap: ap_,\n    chain: chain_,\n    reduce: reduce_,\n    foldMap: foldMap_,\n    reduceRight: reduceRight_,\n    traverse: traverse_,\n    sequence: sequence,\n    bimap: bimap_,\n    mapLeft: mapLeft_,\n    alt: alt_,\n    extend: extend_,\n    chainRec: chainRec_,\n    throwError: throwError\n};\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * Default value for the `onError` argument of `tryCatch`\n *\n * @since 2.0.0\n */\nexport function toError(e) {\n    return e instanceof Error ? e : new Error(String(e));\n}\n/**\n * @since 2.0.0\n */\nexport function elem(E) {\n    return function (a, ma) { return (isLeft(ma) ? false : E.equals(a, ma.right)); };\n}\n/**\n * Returns `false` if `Left` or returns the result of the application of the given predicate to the `Right` value.\n *\n * @example\n * import { exists, left, right } from 'fp-ts/Either'\n *\n * const gt2 = exists((n: number) => n > 2)\n *\n * assert.strictEqual(gt2(left('a')), false)\n * assert.strictEqual(gt2(right(1)), false)\n * assert.strictEqual(gt2(right(3)), true)\n *\n * @since 2.0.0\n */\nexport function exists(predicate) {\n    return function (ma) { return (isLeft(ma) ? false : predicate(ma.right)); };\n}\n// -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n/**\n * @since 2.8.0\n */\nexport var bindTo = function (name) {\n    return map(bindTo_(name));\n};\n/**\n * @since 2.8.0\n */\nexport var bindW = function (name, f) {\n    return chainW(function (a) {\n        return pipe(f(a), map(function (b) { return bind_(a, name, b); }));\n    });\n};\n/**\n * @since 2.8.0\n */\nexport var bind = bindW;\n// -------------------------------------------------------------------------------------\n// pipeable sequence S\n// -------------------------------------------------------------------------------------\n/**\n * @since 2.8.0\n */\nexport var apSW = function (name, fb) {\n    return flow(map(function (a) { return function (b) { return bind_(a, name, b); }; }), apW(fb));\n};\n/**\n * @since 2.8.0\n */\nexport var apS = apSW;\n","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __spreadArrays = (this && this.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\n/**\n * @since 1.0.0\n */\nimport { isLeft, left, right } from 'fp-ts/es6/Either';\n/**\n * @category Model\n * @since 1.0.0\n */\nvar Type = /** @class */ (function () {\n    function Type(\n    /** a unique name for this codec */\n    name, \n    /** a custom type guard */\n    is, \n    /** succeeds if a value of type I can be decoded to a value of type A */\n    validate, \n    /** converts a value of type A to a value of type O */\n    encode) {\n        this.name = name;\n        this.is = is;\n        this.validate = validate;\n        this.encode = encode;\n        this.decode = this.decode.bind(this);\n    }\n    /**\n     * @since 1.0.0\n     */\n    Type.prototype.pipe = function (ab, name) {\n        var _this = this;\n        if (name === void 0) { name = \"pipe(\" + this.name + \", \" + ab.name + \")\"; }\n        return new Type(name, ab.is, function (i, c) {\n            var e = _this.validate(i, c);\n            if (isLeft(e)) {\n                return e;\n            }\n            return ab.validate(e.right, c);\n        }, this.encode === identity && ab.encode === identity ? identity : function (b) { return _this.encode(ab.encode(b)); });\n    };\n    /**\n     * @since 1.0.0\n     */\n    Type.prototype.asDecoder = function () {\n        return this;\n    };\n    /**\n     * @since 1.0.0\n     */\n    Type.prototype.asEncoder = function () {\n        return this;\n    };\n    /**\n     * a version of `validate` with a default context\n     * @since 1.0.0\n     */\n    Type.prototype.decode = function (i) {\n        return this.validate(i, [{ key: '', type: this, actual: i }]);\n    };\n    return Type;\n}());\nexport { Type };\n/**\n * @since 1.0.0\n */\nexport var identity = function (a) { return a; };\n/**\n * @since 1.0.0\n */\nexport var getFunctionName = function (f) {\n    return f.displayName || f.name || \"<function\" + f.length + \">\";\n};\n/**\n * @since 1.0.0\n */\nexport var getContextEntry = function (key, decoder) { return ({ key: key, type: decoder }); };\n/**\n * @since 1.0.0\n */\nexport var appendContext = function (c, key, decoder, actual) {\n    var len = c.length;\n    var r = Array(len + 1);\n    for (var i = 0; i < len; i++) {\n        r[i] = c[i];\n    }\n    r[len] = { key: key, type: decoder, actual: actual };\n    return r;\n};\n/**\n * @since 1.0.0\n */\nexport var failures = left;\n/**\n * @since 1.0.0\n */\nexport var failure = function (value, context, message) {\n    return failures([{ value: value, context: context, message: message }]);\n};\n/**\n * @since 1.0.0\n */\nexport var success = right;\nvar pushAll = function (xs, ys) {\n    var l = ys.length;\n    for (var i = 0; i < l; i++) {\n        xs.push(ys[i]);\n    }\n};\n// -------------------------------------------------------------------------------------\n// primitives\n// -------------------------------------------------------------------------------------\n/**\n * @since 1.0.0\n */\nvar NullType = /** @class */ (function (_super) {\n    __extends(NullType, _super);\n    function NullType() {\n        var _this = _super.call(this, 'null', function (u) { return u === null; }, function (u, c) { return (_this.is(u) ? success(u) : failure(u, c)); }, identity) || this;\n        /**\n         * @since 1.0.0\n         */\n        _this._tag = 'NullType';\n        return _this;\n    }\n    return NullType;\n}(Type));\nexport { NullType };\n/**\n * @category Primitives\n * @since 1.0.0\n */\nexport var nullType = new NullType();\n/**\n * @since 1.0.0\n */\nvar UndefinedType = /** @class */ (function (_super) {\n    __extends(UndefinedType, _super);\n    function UndefinedType() {\n        var _this = _super.call(this, 'undefined', function (u) { return u === void 0; }, function (u, c) { return (_this.is(u) ? success(u) : failure(u, c)); }, identity) || this;\n        /**\n         * @since 1.0.0\n         */\n        _this._tag = 'UndefinedType';\n        return _this;\n    }\n    return UndefinedType;\n}(Type));\nexport { UndefinedType };\nvar undefinedType = new UndefinedType();\n/**\n * @since 1.2.0\n */\nvar VoidType = /** @class */ (function (_super) {\n    __extends(VoidType, _super);\n    function VoidType() {\n        var _this = _super.call(this, 'void', undefinedType.is, undefinedType.validate, identity) || this;\n        /**\n         * @since 1.0.0\n         */\n        _this._tag = 'VoidType';\n        return _this;\n    }\n    return VoidType;\n}(Type));\nexport { VoidType };\n/**\n * @category Primitives\n * @since 1.2.0\n */\nexport var voidType = new VoidType();\n/**\n * @since 1.5.0\n */\nvar UnknownType = /** @class */ (function (_super) {\n    __extends(UnknownType, _super);\n    function UnknownType() {\n        var _this = _super.call(this, 'unknown', function (_) { return true; }, success, identity) || this;\n        /**\n         * @since 1.0.0\n         */\n        _this._tag = 'UnknownType';\n        return _this;\n    }\n    return UnknownType;\n}(Type));\nexport { UnknownType };\n/**\n * @category Primitives\n * @since 1.5.0\n */\nexport var unknown = new UnknownType();\n/**\n * @since 1.0.0\n */\nvar StringType = /** @class */ (function (_super) {\n    __extends(StringType, _super);\n    function StringType() {\n        var _this = _super.call(this, 'string', function (u) { return typeof u === 'string'; }, function (u, c) { return (_this.is(u) ? success(u) : failure(u, c)); }, identity) || this;\n        /**\n         * @since 1.0.0\n         */\n        _this._tag = 'StringType';\n        return _this;\n    }\n    return StringType;\n}(Type));\nexport { StringType };\n/**\n * @category Primitives\n * @since 1.0.0\n */\nexport var string = new StringType();\n/**\n * @since 1.0.0\n */\nvar NumberType = /** @class */ (function (_super) {\n    __extends(NumberType, _super);\n    function NumberType() {\n        var _this = _super.call(this, 'number', function (u) { return typeof u === 'number'; }, function (u, c) { return (_this.is(u) ? success(u) : failure(u, c)); }, identity) || this;\n        /**\n         * @since 1.0.0\n         */\n        _this._tag = 'NumberType';\n        return _this;\n    }\n    return NumberType;\n}(Type));\nexport { NumberType };\n/**\n * @category Primitives\n * @since 1.0.0\n */\nexport var number = new NumberType();\n/**\n * @since 2.1.0\n */\nvar BigIntType = /** @class */ (function (_super) {\n    __extends(BigIntType, _super);\n    function BigIntType() {\n        var _this = _super.call(this, 'bigint', \n        // tslint:disable-next-line: valid-typeof\n        function (u) { return typeof u === 'bigint'; }, function (u, c) { return (_this.is(u) ? success(u) : failure(u, c)); }, identity) || this;\n        /**\n         * @since 1.0.0\n         */\n        _this._tag = 'BigIntType';\n        return _this;\n    }\n    return BigIntType;\n}(Type));\nexport { BigIntType };\n/**\n * @category Primitives\n * @since 2.1.0\n */\nexport var bigint = new BigIntType();\n/**\n * @since 1.0.0\n */\nvar BooleanType = /** @class */ (function (_super) {\n    __extends(BooleanType, _super);\n    function BooleanType() {\n        var _this = _super.call(this, 'boolean', function (u) { return typeof u === 'boolean'; }, function (u, c) { return (_this.is(u) ? success(u) : failure(u, c)); }, identity) || this;\n        /**\n         * @since 1.0.0\n         */\n        _this._tag = 'BooleanType';\n        return _this;\n    }\n    return BooleanType;\n}(Type));\nexport { BooleanType };\n/**\n * @category Primitives\n * @since 1.0.0\n */\nexport var boolean = new BooleanType();\n/**\n * @since 1.0.0\n */\nvar AnyArrayType = /** @class */ (function (_super) {\n    __extends(AnyArrayType, _super);\n    function AnyArrayType() {\n        var _this = _super.call(this, 'UnknownArray', Array.isArray, function (u, c) { return (_this.is(u) ? success(u) : failure(u, c)); }, identity) || this;\n        /**\n         * @since 1.0.0\n         */\n        _this._tag = 'AnyArrayType';\n        return _this;\n    }\n    return AnyArrayType;\n}(Type));\nexport { AnyArrayType };\n/**\n * @category Primitives\n * @since 1.7.1\n */\nexport var UnknownArray = new AnyArrayType();\n/**\n * @since 1.0.0\n */\nvar AnyDictionaryType = /** @class */ (function (_super) {\n    __extends(AnyDictionaryType, _super);\n    function AnyDictionaryType() {\n        var _this = _super.call(this, 'UnknownRecord', function (u) {\n            var s = Object.prototype.toString.call(u);\n            return s === '[object Object]' || s === '[object Window]';\n        }, function (u, c) { return (_this.is(u) ? success(u) : failure(u, c)); }, identity) || this;\n        /**\n         * @since 1.0.0\n         */\n        _this._tag = 'AnyDictionaryType';\n        return _this;\n    }\n    return AnyDictionaryType;\n}(Type));\nexport { AnyDictionaryType };\n/**\n * @category Primitives\n * @since 1.7.1\n */\nexport var UnknownRecord = new AnyDictionaryType();\n/**\n * @category deprecated\n * @since 1.0.0\n * @deprecated\n */\nvar FunctionType = /** @class */ (function (_super) {\n    __extends(FunctionType, _super);\n    function FunctionType() {\n        var _this = _super.call(this, 'Function', \n        // tslint:disable-next-line:strict-type-predicates\n        function (u) { return typeof u === 'function'; }, function (u, c) { return (_this.is(u) ? success(u) : failure(u, c)); }, identity) || this;\n        /**\n         * @since 1.0.0\n         */\n        _this._tag = 'FunctionType';\n        return _this;\n    }\n    return FunctionType;\n}(Type));\nexport { FunctionType };\n/**\n * @category deprecated\n * @since 1.0.0\n * @deprecated\n */\n// tslint:disable-next-line: deprecation\nexport var Function = new FunctionType();\n/**\n * @since 1.0.0\n */\nvar RefinementType = /** @class */ (function (_super) {\n    __extends(RefinementType, _super);\n    function RefinementType(name, is, validate, encode, type, predicate) {\n        var _this = _super.call(this, name, is, validate, encode) || this;\n        _this.type = type;\n        _this.predicate = predicate;\n        /**\n         * @since 1.0.0\n         */\n        _this._tag = 'RefinementType';\n        return _this;\n    }\n    return RefinementType;\n}(Type));\nexport { RefinementType };\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * @category Combinators\n * @since 1.8.1\n */\nexport var brand = function (codec, predicate, name) {\n    // tslint:disable-next-line: deprecation\n    return refinement(codec, predicate, name);\n};\n/**\n * A branded codec representing an integer\n *\n * @category Primitives\n * @since 1.8.1\n */\nexport var Int = brand(number, function (n) { return Number.isInteger(n); }, 'Int');\n/**\n * @since 1.0.0\n */\nvar LiteralType = /** @class */ (function (_super) {\n    __extends(LiteralType, _super);\n    function LiteralType(name, is, validate, encode, value) {\n        var _this = _super.call(this, name, is, validate, encode) || this;\n        _this.value = value;\n        /**\n         * @since 1.0.0\n         */\n        _this._tag = 'LiteralType';\n        return _this;\n    }\n    return LiteralType;\n}(Type));\nexport { LiteralType };\n/**\n * @category Combinators\n * @since 1.0.0\n */\nexport var literal = function (value, name) {\n    if (name === void 0) { name = JSON.stringify(value); }\n    var is = function (u) { return u === value; };\n    return new LiteralType(name, is, function (u, c) { return (is(u) ? success(value) : failure(u, c)); }, identity, value);\n};\n/**\n * @since 1.0.0\n */\nvar KeyofType = /** @class */ (function (_super) {\n    __extends(KeyofType, _super);\n    function KeyofType(name, is, validate, encode, keys) {\n        var _this = _super.call(this, name, is, validate, encode) || this;\n        _this.keys = keys;\n        /**\n         * @since 1.0.0\n         */\n        _this._tag = 'KeyofType';\n        return _this;\n    }\n    return KeyofType;\n}(Type));\nexport { KeyofType };\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n/**\n * @category Combinators\n * @since 1.0.0\n */\nexport var keyof = function (keys, name) {\n    if (name === void 0) { name = Object.keys(keys)\n        .map(function (k) { return JSON.stringify(k); })\n        .join(' | '); }\n    var is = function (u) { return string.is(u) && hasOwnProperty.call(keys, u); };\n    return new KeyofType(name, is, function (u, c) { return (is(u) ? success(u) : failure(u, c)); }, identity, keys);\n};\n/**\n * @since 1.0.0\n */\nvar RecursiveType = /** @class */ (function (_super) {\n    __extends(RecursiveType, _super);\n    function RecursiveType(name, is, validate, encode, runDefinition) {\n        var _this = _super.call(this, name, is, validate, encode) || this;\n        _this.runDefinition = runDefinition;\n        /**\n         * @since 1.0.0\n         */\n        _this._tag = 'RecursiveType';\n        return _this;\n    }\n    return RecursiveType;\n}(Type));\nexport { RecursiveType };\nObject.defineProperty(RecursiveType.prototype, 'type', {\n    get: function () {\n        return this.runDefinition();\n    },\n    enumerable: true,\n    configurable: true\n});\n/**\n * @category Combinators\n * @since 1.0.0\n */\nexport var recursion = function (name, definition) {\n    var cache;\n    var runDefinition = function () {\n        if (!cache) {\n            cache = definition(Self);\n            cache.name = name;\n        }\n        return cache;\n    };\n    var Self = new RecursiveType(name, function (u) { return runDefinition().is(u); }, function (u, c) { return runDefinition().validate(u, c); }, function (a) { return runDefinition().encode(a); }, runDefinition);\n    return Self;\n};\n/**\n * @since 1.0.0\n */\nvar ArrayType = /** @class */ (function (_super) {\n    __extends(ArrayType, _super);\n    function ArrayType(name, is, validate, encode, type) {\n        var _this = _super.call(this, name, is, validate, encode) || this;\n        _this.type = type;\n        /**\n         * @since 1.0.0\n         */\n        _this._tag = 'ArrayType';\n        return _this;\n    }\n    return ArrayType;\n}(Type));\nexport { ArrayType };\n/**\n * @category Combinators\n * @since 1.0.0\n */\nexport var array = function (item, name) {\n    if (name === void 0) { name = \"Array<\" + item.name + \">\"; }\n    return new ArrayType(name, function (u) { return UnknownArray.is(u) && u.every(item.is); }, function (u, c) {\n        var e = UnknownArray.validate(u, c);\n        if (isLeft(e)) {\n            return e;\n        }\n        var us = e.right;\n        var len = us.length;\n        var as = us;\n        var errors = [];\n        for (var i = 0; i < len; i++) {\n            var ui = us[i];\n            var result = item.validate(ui, appendContext(c, String(i), item, ui));\n            if (isLeft(result)) {\n                pushAll(errors, result.left);\n            }\n            else {\n                var ai = result.right;\n                if (ai !== ui) {\n                    if (as === us) {\n                        as = us.slice();\n                    }\n                    as[i] = ai;\n                }\n            }\n        }\n        return errors.length > 0 ? failures(errors) : success(as);\n    }, item.encode === identity ? identity : function (a) { return a.map(item.encode); }, item);\n};\n/**\n * @since 1.0.0\n */\nvar InterfaceType = /** @class */ (function (_super) {\n    __extends(InterfaceType, _super);\n    function InterfaceType(name, is, validate, encode, props) {\n        var _this = _super.call(this, name, is, validate, encode) || this;\n        _this.props = props;\n        /**\n         * @since 1.0.0\n         */\n        _this._tag = 'InterfaceType';\n        return _this;\n    }\n    return InterfaceType;\n}(Type));\nexport { InterfaceType };\nvar getNameFromProps = function (props) {\n    return Object.keys(props)\n        .map(function (k) { return k + \": \" + props[k].name; })\n        .join(', ');\n};\nvar useIdentity = function (codecs) {\n    for (var i = 0; i < codecs.length; i++) {\n        if (codecs[i].encode !== identity) {\n            return false;\n        }\n    }\n    return true;\n};\nvar getInterfaceTypeName = function (props) {\n    return \"{ \" + getNameFromProps(props) + \" }\";\n};\n/**\n * @category Combinators\n * @since 1.0.0\n */\nexport var type = function (props, name) {\n    if (name === void 0) { name = getInterfaceTypeName(props); }\n    var keys = Object.keys(props);\n    var types = keys.map(function (key) { return props[key]; });\n    var len = keys.length;\n    return new InterfaceType(name, function (u) {\n        if (UnknownRecord.is(u)) {\n            for (var i = 0; i < len; i++) {\n                var k = keys[i];\n                var uk = u[k];\n                if ((uk === undefined && !hasOwnProperty.call(u, k)) || !types[i].is(uk)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        return false;\n    }, function (u, c) {\n        var e = UnknownRecord.validate(u, c);\n        if (isLeft(e)) {\n            return e;\n        }\n        var o = e.right;\n        var a = o;\n        var errors = [];\n        for (var i = 0; i < len; i++) {\n            var k = keys[i];\n            var ak = a[k];\n            var type_1 = types[i];\n            var result = type_1.validate(ak, appendContext(c, k, type_1, ak));\n            if (isLeft(result)) {\n                pushAll(errors, result.left);\n            }\n            else {\n                var vak = result.right;\n                if (vak !== ak || (vak === undefined && !hasOwnProperty.call(a, k))) {\n                    /* istanbul ignore next */\n                    if (a === o) {\n                        a = __assign({}, o);\n                    }\n                    a[k] = vak;\n                }\n            }\n        }\n        return errors.length > 0 ? failures(errors) : success(a);\n    }, useIdentity(types)\n        ? identity\n        : function (a) {\n            var s = __assign({}, a);\n            for (var i = 0; i < len; i++) {\n                var k = keys[i];\n                var encode = types[i].encode;\n                if (encode !== identity) {\n                    s[k] = encode(a[k]);\n                }\n            }\n            return s;\n        }, props);\n};\n/**\n * @since 1.0.0\n */\nvar PartialType = /** @class */ (function (_super) {\n    __extends(PartialType, _super);\n    function PartialType(name, is, validate, encode, props) {\n        var _this = _super.call(this, name, is, validate, encode) || this;\n        _this.props = props;\n        /**\n         * @since 1.0.0\n         */\n        _this._tag = 'PartialType';\n        return _this;\n    }\n    return PartialType;\n}(Type));\nexport { PartialType };\nvar getPartialTypeName = function (inner) {\n    return \"Partial<\" + inner + \">\";\n};\n/**\n * @category Combinators\n * @since 1.0.0\n */\nexport var partial = function (props, name) {\n    if (name === void 0) { name = getPartialTypeName(getInterfaceTypeName(props)); }\n    var keys = Object.keys(props);\n    var types = keys.map(function (key) { return props[key]; });\n    var len = keys.length;\n    return new PartialType(name, function (u) {\n        if (UnknownRecord.is(u)) {\n            for (var i = 0; i < len; i++) {\n                var k = keys[i];\n                var uk = u[k];\n                if (uk !== undefined && !props[k].is(uk)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        return false;\n    }, function (u, c) {\n        var e = UnknownRecord.validate(u, c);\n        if (isLeft(e)) {\n            return e;\n        }\n        var o = e.right;\n        var a = o;\n        var errors = [];\n        for (var i = 0; i < len; i++) {\n            var k = keys[i];\n            var ak = a[k];\n            var type_2 = props[k];\n            var result = type_2.validate(ak, appendContext(c, k, type_2, ak));\n            if (isLeft(result)) {\n                if (ak !== undefined) {\n                    pushAll(errors, result.left);\n                }\n            }\n            else {\n                var vak = result.right;\n                if (vak !== ak) {\n                    /* istanbul ignore next */\n                    if (a === o) {\n                        a = __assign({}, o);\n                    }\n                    a[k] = vak;\n                }\n            }\n        }\n        return errors.length > 0 ? failures(errors) : success(a);\n    }, useIdentity(types)\n        ? identity\n        : function (a) {\n            var s = __assign({}, a);\n            for (var i = 0; i < len; i++) {\n                var k = keys[i];\n                var ak = a[k];\n                if (ak !== undefined) {\n                    s[k] = types[i].encode(ak);\n                }\n            }\n            return s;\n        }, props);\n};\n/**\n * @since 1.0.0\n */\nvar DictionaryType = /** @class */ (function (_super) {\n    __extends(DictionaryType, _super);\n    function DictionaryType(name, is, validate, encode, domain, codomain) {\n        var _this = _super.call(this, name, is, validate, encode) || this;\n        _this.domain = domain;\n        _this.codomain = codomain;\n        /**\n         * @since 1.0.0\n         */\n        _this._tag = 'DictionaryType';\n        return _this;\n    }\n    return DictionaryType;\n}(Type));\nexport { DictionaryType };\nfunction enumerableRecord(keys, domain, codomain, name) {\n    if (name === void 0) { name = \"{ [K in \" + domain.name + \"]: \" + codomain.name + \" }\"; }\n    var len = keys.length;\n    return new DictionaryType(name, function (u) { return UnknownRecord.is(u) && keys.every(function (k) { return codomain.is(u[k]); }); }, function (u, c) {\n        var e = UnknownRecord.validate(u, c);\n        if (isLeft(e)) {\n            return e;\n        }\n        var o = e.right;\n        var a = {};\n        var errors = [];\n        var changed = false;\n        for (var i = 0; i < len; i++) {\n            var k = keys[i];\n            var ok = o[k];\n            var codomainResult = codomain.validate(ok, appendContext(c, k, codomain, ok));\n            if (isLeft(codomainResult)) {\n                pushAll(errors, codomainResult.left);\n            }\n            else {\n                var vok = codomainResult.right;\n                changed = changed || vok !== ok;\n                a[k] = vok;\n            }\n        }\n        return errors.length > 0 ? failures(errors) : success((changed || Object.keys(o).length !== len ? a : o));\n    }, codomain.encode === identity\n        ? identity\n        : function (a) {\n            var s = {};\n            for (var i = 0; i < len; i++) {\n                var k = keys[i];\n                s[k] = codomain.encode(a[k]);\n            }\n            return s;\n        }, domain, codomain);\n}\n/**\n * @internal\n */\nexport function getDomainKeys(domain) {\n    var _a;\n    if (isLiteralC(domain)) {\n        var literal_1 = domain.value;\n        if (string.is(literal_1)) {\n            return _a = {}, _a[literal_1] = null, _a;\n        }\n    }\n    else if (isKeyofC(domain)) {\n        return domain.keys;\n    }\n    else if (isUnionC(domain)) {\n        var keys = domain.types.map(function (type) { return getDomainKeys(type); });\n        return keys.some(undefinedType.is) ? undefined : Object.assign.apply(Object, __spreadArrays([{}], keys));\n    }\n    return undefined;\n}\nfunction nonEnumerableRecord(domain, codomain, name) {\n    if (name === void 0) { name = \"{ [K in \" + domain.name + \"]: \" + codomain.name + \" }\"; }\n    return new DictionaryType(name, function (u) {\n        if (UnknownRecord.is(u)) {\n            return Object.keys(u).every(function (k) { return domain.is(k) && codomain.is(u[k]); });\n        }\n        return isAnyC(codomain) && Array.isArray(u);\n    }, function (u, c) {\n        if (UnknownRecord.is(u)) {\n            var a = {};\n            var errors = [];\n            var keys = Object.keys(u);\n            var len = keys.length;\n            var changed = false;\n            for (var i = 0; i < len; i++) {\n                var k = keys[i];\n                var ok = u[k];\n                var domainResult = domain.validate(k, appendContext(c, k, domain, k));\n                if (isLeft(domainResult)) {\n                    pushAll(errors, domainResult.left);\n                }\n                else {\n                    var vk = domainResult.right;\n                    changed = changed || vk !== k;\n                    k = vk;\n                    var codomainResult = codomain.validate(ok, appendContext(c, k, codomain, ok));\n                    if (isLeft(codomainResult)) {\n                        pushAll(errors, codomainResult.left);\n                    }\n                    else {\n                        var vok = codomainResult.right;\n                        changed = changed || vok !== ok;\n                        a[k] = vok;\n                    }\n                }\n            }\n            return errors.length > 0 ? failures(errors) : success((changed ? a : u));\n        }\n        if (isAnyC(codomain) && Array.isArray(u)) {\n            return success(u);\n        }\n        return failure(u, c);\n    }, domain.encode === identity && codomain.encode === identity\n        ? identity\n        : function (a) {\n            var s = {};\n            var keys = Object.keys(a);\n            var len = keys.length;\n            for (var i = 0; i < len; i++) {\n                var k = keys[i];\n                s[String(domain.encode(k))] = codomain.encode(a[k]);\n            }\n            return s;\n        }, domain, codomain);\n}\n/**\n * @category Combinators\n * @since 1.7.1\n */\nexport function record(domain, codomain, name) {\n    var keys = getDomainKeys(domain);\n    return keys\n        ? enumerableRecord(Object.keys(keys), domain, codomain, name)\n        : nonEnumerableRecord(domain, codomain, name);\n}\n/**\n * @since 1.0.0\n */\nvar UnionType = /** @class */ (function (_super) {\n    __extends(UnionType, _super);\n    function UnionType(name, is, validate, encode, types) {\n        var _this = _super.call(this, name, is, validate, encode) || this;\n        _this.types = types;\n        /**\n         * @since 1.0.0\n         */\n        _this._tag = 'UnionType';\n        return _this;\n    }\n    return UnionType;\n}(Type));\nexport { UnionType };\nvar getUnionName = function (codecs) {\n    return '(' + codecs.map(function (type) { return type.name; }).join(' | ') + ')';\n};\n/**\n * @category Combinators\n * @since 1.0.0\n */\nexport var union = function (codecs, name) {\n    if (name === void 0) { name = getUnionName(codecs); }\n    var index = getIndex(codecs);\n    if (index !== undefined && codecs.length > 0) {\n        var tag_1 = index[0], groups_1 = index[1];\n        var len_1 = groups_1.length;\n        var find_1 = function (value) {\n            for (var i = 0; i < len_1; i++) {\n                if (groups_1[i].indexOf(value) !== -1) {\n                    return i;\n                }\n            }\n            return undefined;\n        };\n        // tslint:disable-next-line: deprecation\n        return new TaggedUnionType(name, function (u) {\n            if (UnknownRecord.is(u)) {\n                var i = find_1(u[tag_1]);\n                return i !== undefined ? codecs[i].is(u) : false;\n            }\n            return false;\n        }, function (u, c) {\n            var e = UnknownRecord.validate(u, c);\n            if (isLeft(e)) {\n                return e;\n            }\n            var r = e.right;\n            var i = find_1(r[tag_1]);\n            if (i === undefined) {\n                return failure(u, c);\n            }\n            var codec = codecs[i];\n            return codec.validate(r, appendContext(c, String(i), codec, r));\n        }, useIdentity(codecs)\n            ? identity\n            : function (a) {\n                var i = find_1(a[tag_1]);\n                if (i === undefined) {\n                    // https://github.com/gcanti/io-ts/pull/305\n                    throw new Error(\"no codec found to encode value in union codec \" + name);\n                }\n                else {\n                    return codecs[i].encode(a);\n                }\n            }, codecs, tag_1);\n    }\n    else {\n        return new UnionType(name, function (u) { return codecs.some(function (type) { return type.is(u); }); }, function (u, c) {\n            var errors = [];\n            for (var i = 0; i < codecs.length; i++) {\n                var codec = codecs[i];\n                var result = codec.validate(u, appendContext(c, String(i), codec, u));\n                if (isLeft(result)) {\n                    pushAll(errors, result.left);\n                }\n                else {\n                    return success(result.right);\n                }\n            }\n            return failures(errors);\n        }, useIdentity(codecs)\n            ? identity\n            : function (a) {\n                for (var _i = 0, codecs_1 = codecs; _i < codecs_1.length; _i++) {\n                    var codec = codecs_1[_i];\n                    if (codec.is(a)) {\n                        return codec.encode(a);\n                    }\n                }\n                // https://github.com/gcanti/io-ts/pull/305\n                throw new Error(\"no codec found to encode value in union type \" + name);\n            }, codecs);\n    }\n};\n/**\n * @since 1.0.0\n */\nvar IntersectionType = /** @class */ (function (_super) {\n    __extends(IntersectionType, _super);\n    function IntersectionType(name, is, validate, encode, types) {\n        var _this = _super.call(this, name, is, validate, encode) || this;\n        _this.types = types;\n        /**\n         * @since 1.0.0\n         */\n        _this._tag = 'IntersectionType';\n        return _this;\n    }\n    return IntersectionType;\n}(Type));\nexport { IntersectionType };\nvar mergeAll = function (base, us) {\n    var equal = true;\n    var primitive = true;\n    for (var _i = 0, us_1 = us; _i < us_1.length; _i++) {\n        var u = us_1[_i];\n        if (u !== base) {\n            equal = false;\n        }\n        if (UnknownRecord.is(u)) {\n            primitive = false;\n        }\n    }\n    if (equal) {\n        return base;\n    }\n    else if (primitive) {\n        return us[us.length - 1];\n    }\n    var r = {};\n    for (var _a = 0, us_2 = us; _a < us_2.length; _a++) {\n        var u = us_2[_a];\n        for (var k in u) {\n            if (u[k] !== base[k] || !r.hasOwnProperty(k)) {\n                r[k] = u[k];\n            }\n        }\n    }\n    return r;\n};\nexport function intersection(codecs, name) {\n    if (name === void 0) { name = \"(\" + codecs.map(function (type) { return type.name; }).join(' & ') + \")\"; }\n    var len = codecs.length;\n    return new IntersectionType(name, function (u) { return codecs.every(function (type) { return type.is(u); }); }, codecs.length === 0\n        ? success\n        : function (u, c) {\n            var us = [];\n            var errors = [];\n            for (var i = 0; i < len; i++) {\n                var codec = codecs[i];\n                var result = codec.validate(u, appendContext(c, String(i), codec, u));\n                if (isLeft(result)) {\n                    pushAll(errors, result.left);\n                }\n                else {\n                    us.push(result.right);\n                }\n            }\n            return errors.length > 0 ? failures(errors) : success(mergeAll(u, us));\n        }, codecs.length === 0\n        ? identity\n        : function (a) {\n            return mergeAll(a, codecs.map(function (codec) { return codec.encode(a); }));\n        }, codecs);\n}\n/**\n * @since 1.0.0\n */\nvar TupleType = /** @class */ (function (_super) {\n    __extends(TupleType, _super);\n    function TupleType(name, is, validate, encode, types) {\n        var _this = _super.call(this, name, is, validate, encode) || this;\n        _this.types = types;\n        /**\n         * @since 1.0.0\n         */\n        _this._tag = 'TupleType';\n        return _this;\n    }\n    return TupleType;\n}(Type));\nexport { TupleType };\nexport function tuple(codecs, name) {\n    if (name === void 0) { name = \"[\" + codecs.map(function (type) { return type.name; }).join(', ') + \"]\"; }\n    var len = codecs.length;\n    return new TupleType(name, function (u) { return UnknownArray.is(u) && u.length === len && codecs.every(function (type, i) { return type.is(u[i]); }); }, function (u, c) {\n        var e = UnknownArray.validate(u, c);\n        if (isLeft(e)) {\n            return e;\n        }\n        var us = e.right;\n        var as = us.length > len ? us.slice(0, len) : us; // strip additional components\n        var errors = [];\n        for (var i = 0; i < len; i++) {\n            var a = us[i];\n            var type_3 = codecs[i];\n            var result = type_3.validate(a, appendContext(c, String(i), type_3, a));\n            if (isLeft(result)) {\n                pushAll(errors, result.left);\n            }\n            else {\n                var va = result.right;\n                if (va !== a) {\n                    /* istanbul ignore next */\n                    if (as === us) {\n                        as = us.slice();\n                    }\n                    as[i] = va;\n                }\n            }\n        }\n        return errors.length > 0 ? failures(errors) : success(as);\n    }, useIdentity(codecs) ? identity : function (a) { return codecs.map(function (type, i) { return type.encode(a[i]); }); }, codecs);\n}\n/**\n * @since 1.0.0\n */\nvar ReadonlyType = /** @class */ (function (_super) {\n    __extends(ReadonlyType, _super);\n    function ReadonlyType(name, is, validate, encode, type) {\n        var _this = _super.call(this, name, is, validate, encode) || this;\n        _this.type = type;\n        /**\n         * @since 1.0.0\n         */\n        _this._tag = 'ReadonlyType';\n        return _this;\n    }\n    return ReadonlyType;\n}(Type));\nexport { ReadonlyType };\n/**\n * @category Combinators\n * @since 1.0.0\n */\nexport var readonly = function (codec, name) {\n    if (name === void 0) { name = \"Readonly<\" + codec.name + \">\"; }\n    return new ReadonlyType(name, codec.is, codec.validate, codec.encode, codec);\n};\n/**\n * @since 1.0.0\n */\nvar ReadonlyArrayType = /** @class */ (function (_super) {\n    __extends(ReadonlyArrayType, _super);\n    function ReadonlyArrayType(name, is, validate, encode, type) {\n        var _this = _super.call(this, name, is, validate, encode) || this;\n        _this.type = type;\n        /**\n         * @since 1.0.0\n         */\n        _this._tag = 'ReadonlyArrayType';\n        return _this;\n    }\n    return ReadonlyArrayType;\n}(Type));\nexport { ReadonlyArrayType };\n/**\n * @category Combinators\n * @since 1.0.0\n */\nexport var readonlyArray = function (item, name) {\n    if (name === void 0) { name = \"ReadonlyArray<\" + item.name + \">\"; }\n    var codec = array(item);\n    return new ReadonlyArrayType(name, codec.is, codec.validate, codec.encode, item);\n};\n/**\n * Strips additional properties\n *\n * @category Combinators\n * @since 1.0.0\n */\nexport var strict = function (props, name) {\n    return exact(type(props), name);\n};\n/**\n * @category deprecated\n * @since 1.3.0\n * @deprecated\n */\nvar TaggedUnionType = /** @class */ (function (_super) {\n    __extends(TaggedUnionType, _super);\n    function TaggedUnionType(name, \n    // tslint:disable-next-line: deprecation\n    is, \n    // tslint:disable-next-line: deprecation\n    validate, \n    // tslint:disable-next-line: deprecation\n    encode, codecs, tag) {\n        var _this = _super.call(this, name, is, validate, encode, codecs) /* istanbul ignore next */ // <= workaround for https://github.com/Microsoft/TypeScript/issues/13455\n         || this;\n        _this.tag = tag;\n        return _this;\n    }\n    return TaggedUnionType;\n}(UnionType));\nexport { TaggedUnionType };\n/**\n * Use `union` instead\n *\n * @category deprecated\n * @since 1.3.0\n * @deprecated\n */\nexport var taggedUnion = function (tag, codecs, name\n// tslint:disable-next-line: deprecation\n) {\n    if (name === void 0) { name = getUnionName(codecs); }\n    var U = union(codecs, name);\n    // tslint:disable-next-line: deprecation\n    if (U instanceof TaggedUnionType) {\n        return U;\n    }\n    else {\n        console.warn(\"[io-ts] Cannot build a tagged union for \" + name + \", returning a de-optimized union\");\n        // tslint:disable-next-line: deprecation\n        return new TaggedUnionType(name, U.is, U.validate, U.encode, codecs, tag);\n    }\n};\n/**\n * @since 1.1.0\n */\nvar ExactType = /** @class */ (function (_super) {\n    __extends(ExactType, _super);\n    function ExactType(name, is, validate, encode, type) {\n        var _this = _super.call(this, name, is, validate, encode) || this;\n        _this.type = type;\n        /**\n         * @since 1.0.0\n         */\n        _this._tag = 'ExactType';\n        return _this;\n    }\n    return ExactType;\n}(Type));\nexport { ExactType };\nvar getProps = function (codec) {\n    switch (codec._tag) {\n        case 'RefinementType':\n        case 'ReadonlyType':\n            return getProps(codec.type);\n        case 'InterfaceType':\n        case 'StrictType':\n        case 'PartialType':\n            return codec.props;\n        case 'IntersectionType':\n            return codec.types.reduce(function (props, type) { return Object.assign(props, getProps(type)); }, {});\n    }\n};\nvar stripKeys = function (o, props) {\n    var keys = Object.getOwnPropertyNames(o);\n    var shouldStrip = false;\n    var r = {};\n    for (var i = 0; i < keys.length; i++) {\n        var key = keys[i];\n        if (!hasOwnProperty.call(props, key)) {\n            shouldStrip = true;\n        }\n        else {\n            r[key] = o[key];\n        }\n    }\n    return shouldStrip ? r : o;\n};\nvar getExactTypeName = function (codec) {\n    if (isTypeC(codec)) {\n        return \"{| \" + getNameFromProps(codec.props) + \" |}\";\n    }\n    else if (isPartialC(codec)) {\n        return getPartialTypeName(\"{| \" + getNameFromProps(codec.props) + \" |}\");\n    }\n    return \"Exact<\" + codec.name + \">\";\n};\n/**\n * Strips additional properties\n * @since 1.1.0\n */\nexport var exact = function (codec, name) {\n    if (name === void 0) { name = getExactTypeName(codec); }\n    var props = getProps(codec);\n    return new ExactType(name, codec.is, function (u, c) {\n        var e = UnknownRecord.validate(u, c);\n        if (isLeft(e)) {\n            return e;\n        }\n        var ce = codec.validate(u, c);\n        if (isLeft(ce)) {\n            return ce;\n        }\n        return right(stripKeys(ce.right, props));\n    }, function (a) { return codec.encode(stripKeys(a, props)); }, codec);\n};\nexport { \n/**\n * @since 1.0.0\n */\nnullType as null };\nexport { \n/**\n * @since 1.0.0\n */\nundefinedType as undefined };\nexport { \n/**\n * Use `UnknownArray` instead\n *\n * @category deprecated\n * @deprecated\n * @since 1.0.0\n */\nUnknownArray as Array };\nexport { \n/**\n * Use `type` instead\n *\n * @category deprecated\n * @deprecated\n * @since 1.0.0\n */\ntype as interface };\nexport { \n/**\n * @since 1.0.0\n */\nvoidType as void };\n/**\n * @category deprecated\n * @since 1.0.0\n * @deprecated\n */\nexport var getValidationError /* istanbul ignore next */ = function (value, context) { return ({\n    value: value,\n    context: context\n}); };\n/**\n * @category deprecated\n * @since 1.0.0\n * @deprecated\n */\nexport var getDefaultContext /* istanbul ignore next */ = function (decoder) { return [\n    { key: '', type: decoder }\n]; };\n/**\n * @category deprecated\n * @since 1.0.0\n * @deprecated\n */\nvar NeverType = /** @class */ (function (_super) {\n    __extends(NeverType, _super);\n    function NeverType() {\n        var _this = _super.call(this, 'never', function (_) { return false; }, function (u, c) { return failure(u, c); }, \n        /* istanbul ignore next */\n        function () {\n            throw new Error('cannot encode never');\n        }) || this;\n        /**\n         * @since 1.0.0\n         */\n        _this._tag = 'NeverType';\n        return _this;\n    }\n    return NeverType;\n}(Type));\nexport { NeverType };\n/**\n * @category deprecated\n * @since 1.0.0\n * @deprecated\n */\n// tslint:disable-next-line: deprecation\nexport var never = new NeverType();\n/**\n * @category deprecated\n * @since 1.0.0\n * @deprecated\n */\nvar AnyType = /** @class */ (function (_super) {\n    __extends(AnyType, _super);\n    function AnyType() {\n        var _this = _super.call(this, 'any', function (_) { return true; }, success, identity) || this;\n        /**\n         * @since 1.0.0\n         */\n        _this._tag = 'AnyType';\n        return _this;\n    }\n    return AnyType;\n}(Type));\nexport { AnyType };\n/**\n * Use `unknown` instead\n *\n * @category deprecated\n * @since 1.0.0\n * @deprecated\n */\n// tslint:disable-next-line: deprecation\nexport var any = new AnyType();\n/**\n * Use `UnknownRecord` instead\n *\n * @category deprecated\n * @since 1.0.0\n * @deprecated\n */\nexport var Dictionary = UnknownRecord;\n/**\n * @category deprecated\n * @since 1.0.0\n * @deprecated\n */\nvar ObjectType = /** @class */ (function (_super) {\n    __extends(ObjectType, _super);\n    function ObjectType() {\n        var _this = _super.call(this, 'object', function (u) { return u !== null && typeof u === 'object'; }, function (u, c) { return (_this.is(u) ? success(u) : failure(u, c)); }, identity) || this;\n        /**\n         * @since 1.0.0\n         */\n        _this._tag = 'ObjectType';\n        return _this;\n    }\n    return ObjectType;\n}(Type));\nexport { ObjectType };\n/**\n * Use `UnknownRecord` instead\n *\n * @category deprecated\n * @since 1.0.0\n * @deprecated\n */\n// tslint:disable-next-line: deprecation\nexport var object = new ObjectType();\n/**\n * Use `brand` instead\n *\n * @category deprecated\n * @since 1.0.0\n * @deprecated\n */\nexport function refinement(codec, predicate, name) {\n    if (name === void 0) { name = \"(\" + codec.name + \" | \" + getFunctionName(predicate) + \")\"; }\n    return new RefinementType(name, function (u) { return codec.is(u) && predicate(u); }, function (i, c) {\n        var e = codec.validate(i, c);\n        if (isLeft(e)) {\n            return e;\n        }\n        var a = e.right;\n        return predicate(a) ? success(a) : failure(a, c);\n    }, codec.encode, codec, predicate);\n}\n/**\n * Use `Int` instead\n *\n * @category deprecated\n * @since 1.0.0\n * @deprecated\n */\n// tslint:disable-next-line: deprecation\nexport var Integer = refinement(number, Number.isInteger, 'Integer');\n/**\n * Use `record` instead\n *\n * @category deprecated\n * @since 1.0.0\n * @deprecated\n */\nexport var dictionary = record;\n/**\n * @category deprecated\n * @since 1.0.0\n * @deprecated\n */\nvar StrictType = /** @class */ (function (_super) {\n    __extends(StrictType, _super);\n    function StrictType(name, \n    // tslint:disable-next-line: deprecation\n    is, \n    // tslint:disable-next-line: deprecation\n    validate, \n    // tslint:disable-next-line: deprecation\n    encode, props) {\n        var _this = _super.call(this, name, is, validate, encode) || this;\n        _this.props = props;\n        /**\n         * @since 1.0.0\n         */\n        _this._tag = 'StrictType';\n        return _this;\n    }\n    return StrictType;\n}(Type));\nexport { StrictType };\n/**\n * Drops the codec \"kind\"\n *\n * @category deprecated\n * @since 1.1.0\n * @deprecated\n */\nexport function clean(codec) {\n    return codec;\n}\nexport function alias(codec) {\n    return function () { return codec; };\n}\nvar isNonEmpty = function (as) { return as.length > 0; };\n/**\n * @internal\n */\nexport var emptyTags = {};\nfunction intersect(a, b) {\n    var r = [];\n    for (var _i = 0, a_1 = a; _i < a_1.length; _i++) {\n        var v = a_1[_i];\n        if (b.indexOf(v) !== -1) {\n            r.push(v);\n        }\n    }\n    return r;\n}\nfunction mergeTags(a, b) {\n    if (a === emptyTags) {\n        return b;\n    }\n    if (b === emptyTags) {\n        return a;\n    }\n    var r = Object.assign({}, a);\n    for (var k in b) {\n        if (a.hasOwnProperty(k)) {\n            var intersection_1 = intersect(a[k], b[k]);\n            if (isNonEmpty(intersection_1)) {\n                r[k] = intersection_1;\n            }\n            else {\n                r = emptyTags;\n                break;\n            }\n        }\n        else {\n            r[k] = b[k];\n        }\n    }\n    return r;\n}\nfunction intersectTags(a, b) {\n    if (a === emptyTags || b === emptyTags) {\n        return emptyTags;\n    }\n    var r = emptyTags;\n    for (var k in a) {\n        if (b.hasOwnProperty(k)) {\n            var intersection_2 = intersect(a[k], b[k]);\n            if (intersection_2.length === 0) {\n                if (r === emptyTags) {\n                    r = {};\n                }\n                r[k] = a[k].concat(b[k]);\n            }\n        }\n    }\n    return r;\n}\n// tslint:disable-next-line: deprecation\nfunction isAnyC(codec) {\n    return codec._tag === 'AnyType';\n}\nfunction isLiteralC(codec) {\n    return codec._tag === 'LiteralType';\n}\nfunction isKeyofC(codec) {\n    return codec._tag === 'KeyofType';\n}\nfunction isTypeC(codec) {\n    return codec._tag === 'InterfaceType';\n}\nfunction isPartialC(codec) {\n    return codec._tag === 'PartialType';\n}\n// tslint:disable-next-line: deprecation\nfunction isStrictC(codec) {\n    return codec._tag === 'StrictType';\n}\nfunction isExactC(codec) {\n    return codec._tag === 'ExactType';\n}\n// tslint:disable-next-line: deprecation\nfunction isRefinementC(codec) {\n    return codec._tag === 'RefinementType';\n}\nfunction isIntersectionC(codec) {\n    return codec._tag === 'IntersectionType';\n}\nfunction isUnionC(codec) {\n    return codec._tag === 'UnionType';\n}\nfunction isRecursiveC(codec) {\n    return codec._tag === 'RecursiveType';\n}\nvar lazyCodecs = [];\n/**\n * @internal\n */\nexport function getTags(codec) {\n    if (lazyCodecs.indexOf(codec) !== -1) {\n        return emptyTags;\n    }\n    if (isTypeC(codec) || isStrictC(codec)) {\n        var index = emptyTags;\n        // tslint:disable-next-line: forin\n        for (var k in codec.props) {\n            var prop = codec.props[k];\n            if (isLiteralC(prop)) {\n                if (index === emptyTags) {\n                    index = {};\n                }\n                index[k] = [prop.value];\n            }\n        }\n        return index;\n    }\n    else if (isExactC(codec) || isRefinementC(codec)) {\n        return getTags(codec.type);\n    }\n    else if (isIntersectionC(codec)) {\n        return codec.types.reduce(function (tags, codec) { return mergeTags(tags, getTags(codec)); }, emptyTags);\n    }\n    else if (isUnionC(codec)) {\n        return codec.types.slice(1).reduce(function (tags, codec) { return intersectTags(tags, getTags(codec)); }, getTags(codec.types[0]));\n    }\n    else if (isRecursiveC(codec)) {\n        lazyCodecs.push(codec);\n        var tags = getTags(codec.type);\n        lazyCodecs.pop();\n        return tags;\n    }\n    return emptyTags;\n}\n/**\n * @internal\n */\nexport function getIndex(codecs) {\n    var tags = getTags(codecs[0]);\n    var keys = Object.keys(tags);\n    var len = codecs.length;\n    var _loop_1 = function (k) {\n        var all = tags[k].slice();\n        var index = [tags[k]];\n        for (var i = 1; i < len; i++) {\n            var codec = codecs[i];\n            var ctags = getTags(codec);\n            var values = ctags[k];\n            // tslint:disable-next-line: strict-type-predicates\n            if (values === undefined) {\n                return \"continue-keys\";\n            }\n            else {\n                if (values.some(function (v) { return all.indexOf(v) !== -1; })) {\n                    return \"continue-keys\";\n                }\n                else {\n                    all.push.apply(all, values);\n                    index.push(values);\n                }\n            }\n        }\n        return { value: [k, index] };\n    };\n    keys: for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {\n        var k = keys_1[_i];\n        var state_1 = _loop_1(k);\n        if (typeof state_1 === \"object\")\n            return state_1.value;\n        switch (state_1) {\n            case \"continue-keys\": continue keys;\n        }\n    }\n    return undefined;\n}\n","import * as t from 'io-ts';\n\nexport namespace Client {\n  export const StartBuildEvent = t.type({\n    event: t.literal('start_build'),\n    entrypoints: t.array(t.string),\n    generateSourceMap: t.union([t.literal('data-uri'), t.literal('none'), t.literal('string')]),\n  });\n  export type StartBuildEvent = t.TypeOf<typeof StartBuildEvent>;\n\n  export const FileCreateEvent = t.type({\n    event: t.literal('file_create'),\n    content: t.string,\n    href: t.string,\n  });\n  export type FileCreateEvent = t.TypeOf<typeof FileCreateEvent>;\n\n  export const FileRemoveEvent = t.type({\n    event: t.literal('file_remove'),\n    href: t.string,\n  });\n  export type FileRemoveEvent = t.TypeOf<typeof FileRemoveEvent>;\n\n  export const FileUpdateEvent = t.type({\n    event: t.literal('file_update'),\n    content: t.string,\n    href: t.string,\n  });\n  export type FileUpdateEvent = t.TypeOf<typeof FileUpdateEvent>;\n\n  export const FileEvent = t.union([FileCreateEvent, FileRemoveEvent, FileUpdateEvent]);\n  export type FileEvent = t.TypeOf<typeof FileEvent>;\n\n  export const Any = t.union([FileCreateEvent, FileRemoveEvent, FileUpdateEvent, StartBuildEvent]);\n  export type Any = t.TypeOf<typeof Any>;\n\n  // export const EditorEvents = t.array(EditorEvent);\n  // export type EditorEvents = t.TypeOf<typeof EditorEvents>;\n}\n\nexport namespace Server {\n  export const BuildProgress = t.type({\n    eventName: t.literal('build_progress'),\n    data: t.type({\n      pending: t.number,\n      completed: t.number,\n      start: t.number,\n    }),\n  });\n  export type BuildProgress = t.TypeOf<typeof BuildProgress>;\n\n  export const BuildComplete = t.type({\n    eventName: t.literal('build_complete'),\n    data: t.type({\n      code: t.string,\n      sourceMap: t.string,\n      start: t.number,\n      end: t.number,\n    }),\n  });\n  export type BuildComplete = t.TypeOf<typeof BuildComplete>;\n\n  export const BuildError = t.type({\n    eventName: t.literal('build_error'),\n    data: t.type({\n      error: t.string,\n      start: t.number,\n      end: t.number,\n    }),\n  });\n  export type BuildError = t.TypeOf<typeof BuildError>;\n\n  export const AnyEvent = t.union([BuildProgress, BuildComplete, BuildError]);\n  export type AnyEvent = t.TypeOf<typeof AnyEvent>;\n}\n","/* eslint-env webworker */\n\n///<reference lib=\"webworker\" />\n\nimport { VelcroBuilderServer } from './server';\nimport { wireBuilderStateChanges, wireWorkerEventsToServer } from './wireWorker';\n\nconst server = new VelcroBuilderServer();\n\nwireWorkerEventsToServer(globalThis, server);\nwireBuilderStateChanges(server, globalThis, { debounceInterval: 16 });\n","import { Event, IDisposable } from '@velcro/common';\nimport { isRight } from 'fp-ts/Either';\nimport { VelcroBuilder } from './builder';\nimport { Client, Server } from './messages';\n\nexport interface WorkerLike {\n  addEventListener(\n    type: 'message',\n    listener: (this: WorkerGlobalScope, ev: MessageEvent) => any\n  ): void;\n  removeEventListener(\n    type: string,\n\n    listener: (...args: any[]) => any\n  ): void;\n  postMessage(message: any): void;\n}\n\nfunction wireClientEvents(event: Event<unknown>, builder: VelcroBuilder) {\n  return event((msg) => {\n    const decoded = Client.Any.decode(msg);\n    if (!isRight(decoded)) return;\n\n    const event = decoded.right;\n\n    switch (event.event) {\n      case 'file_create':\n        builder.sendEvent('file_create', {\n          content: event.content,\n          href: event.href,\n        });\n        break;\n      case 'file_remove':\n        builder.sendEvent('file_remove', { href: event.href });\n        break;\n      case 'file_update':\n        builder.sendEvent('file_update', {\n          content: event.content,\n          href: event.href,\n        });\n        break;\n      case 'start_build':\n        builder.sendEvent('start_build', {\n          entrypoints: event.entrypoints,\n          generateSourceMap: event.generateSourceMap,\n        });\n        break;\n    }\n  });\n}\n\n/**\n * Wire a Worker's 'message' events up with a VelcroBuilder instance\n *\n * @param worker The worker on which to listen for client events\n * @param server The Velcro server instance to which those events will be delegated\n */\nexport function wireWorkerEventsToServer(worker: WorkerLike, server: VelcroBuilder): IDisposable {\n  return wireClientEvents(\n    Event.fromDOMEventEmitter(worker, 'message', (event) => event.data),\n    server\n  );\n}\n\n/**\n *\n * @param builder The Velcro server instance that is executing builds\n * @param worker The worker whose postMessage channel should be used for communicating back to the client\n * @param debounceInterval The minimum interval at which state changes will be passed back to the client\n */\nexport function wireBuilderStateChanges(\n  builder: VelcroBuilder,\n  worker: WorkerLike,\n  options: {\n    debounceInterval?: number;\n  } = {}\n): IDisposable {\n  const stateChangeEvent = options.debounceInterval\n    ? Event.debounce(builder.onStateChange, (_, e) => e, 16)\n    : builder.onStateChange;\n\n  return stateChangeEvent((state) => {\n    switch (state.stateName) {\n      case 'build_in_progress': {\n        return worker.postMessage(\n          Server.BuildProgress.encode({\n            eventName: 'build_progress',\n            data: state.data,\n          })\n        );\n      }\n      case 'build_complete': {\n        return worker.postMessage(\n          Server.BuildComplete.encode({\n            eventName: 'build_complete',\n            data: state.data,\n          })\n        );\n      }\n      case 'build_error': {\n        return worker.postMessage(\n          Server.BuildError.encode({\n            eventName: 'build_error',\n            data: state.data,\n          })\n        );\n      }\n    }\n  });\n}\n"],"sourceRoot":""}