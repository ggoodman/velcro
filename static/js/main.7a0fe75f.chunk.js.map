{"version":3,"sources":["../../@velcro/common/dist/dist-module/index.js","../../@velcro/strategy-memory/dist/dist-module/index.js","lib/EditorManager.ts","../../@velcro/bundler/dist/dist-module/index.js","playground/Editor.tsx","../../@velcro/plugin-css/dist/dist-module/index.js","../../@velcro/plugin-sucrase/dist/dist-module/index.js","../../@velcro/strategy-cdn/dist/dist-module/index.js","../../@velcro/strategy-compound/dist/dist-module/index.js","velcro/index.ts","playground/Preview.tsx","lib/hooks.ts","playground/Sidebar.tsx","playground/Playground.tsx","templates/react.ts","useServiceWorker.tsx","App.tsx","serviceWorker.ts","index.tsx","../../@velcro/resolver/dist/dist-module/index.js"],"names":["Base64","BaseError","arguments","name","constructor","Error","CanceledError","EntryExcludedError","uri","toString","EntryNotFoundError","DependencyNotFoundError","spec","parentUri","isCanceledError","err","all","values","token","shouldAwait","result","map","element","isThenable","checkCancellation","Promise","promise","a","isCancellationRequested","reject","object","then","done","next","pre","decode","global","data","from","atob","decodeURIComponent","escape","_data","encode","btoa","unescape","encodeURIComponent","Decoder","TextDecoder","this","decoder","Buffer","buf","str","charCodeAt","slice","MapSet","Map","key","value","get","Set","set","add","clear","ret","delete","size","has","entries","hasInvalidBrowserField","json","error","browser","hasInvalidRequiredStringField","field","hasInvalidOptionalStringField","undefined","hasInvalidDependenciesField","Object","keys","every","parseBufferAsPartialPackageJson","content","parseTextAsPartialPackageJson","message","parseBufferAsPackageJson","text","isValidPackageJson","parseTextAsPackageJson","JSON","parse","isValidPartialPackageJson","ErrorInvalidArgType","expected","actual","determiner","indexOf","replace","type","msg","code","validateString","isPosixPathSeparator","normalizeString","path","allowAboveRoot","separator","isPathSeparator","res","lastSegmentLength","lastSlash","dots","i","length","lastSlashIndex","lastIndexOf","posix","resolve","resolvedPath","resolvedAbsolute","process","cwd","normalize","isAbsolute","trailingSeparator","join","joined","arg","relative","to","fromEnd","fromLen","toLen","lastCommonSep","fromCode","out","toNamespacedPath","dirname","hasRoot","end","matchedSlash","basename","ext","start","extIdx","firstNonSlashEnd","extname","startDot","startPart","preDotState","format","sep","pathObject","dir","root","base","bind","delimiter","win32","_schemePattern","_singleSlashStart","_doubleSlashStart","_validateUri","_strict","scheme","authority","query","fragment","test","_schemeFix","_referenceResolution","_slash","_regexp","Uri","schemeOrData","change","_URI","skipEncoding","_asFormatted","uriToFsPath","trailingSlash","with","TRAILING_SLASH_RX","l","r","child","parent","childHref","parentHref","parentOffset","charAt","prefix","startsWith","thing","fsPath","match","exec","percentDecode","idx","substring","components","pathFragment","newPath","_formatted","external","_fsPath","_sep","_pathSepMarker","$mid","encodeTable","encodeURIComponentFast","uriComponent","allowSlash","nativeEncodePos","pos","substr","escaped","encodeURIComponentMinimal","keepDriveLetterCasing","toLowerCase","encoder","userinfo","String","fromCharCode","_rEncodedAsHex","decodeURIComponentGraceful","_a","FileEncoding","encodeText","TextEncoder","buffer","MemoryStrategy","files","rootUri","pathname","ensureTrailingSlash","ResolverStrategy","EntryKind","Directory","children","file","addFile","encoding","segments","Array","isArray","split","filter","Boolean","segment","UTF8","overwrite","filename","pop","entry","File","_ctx","urlPathname","basePathname","fsPathname","getEntryAtPath","joinPath","binSting","binArray","Uint8Array","prototype","forEach","call","_el","arr","AbstractResolverStrategyWithRoot","EditorManager","options","editor","disposableStore","DisposableStore","initialPath","viewState","WeakMap","onWillFocusModelEmitter","Emitter","onDidChangeEmitter","Monaco","typescript","typescriptDefaults","setEagerModelSync","setMaximumWorkerIdleTime","setCompilerOptions","allowJs","allowNonTsExtensions","allowSyntheticDefaultImports","baseUrl","checkJs","esModuleInterop","experimentalDecorators","inlineSourceMap","inlineSources","isolatedModules","jsx","JsxEmit","React","lib","module","ModuleKind","CommonJS","moduleResolution","ModuleResolutionKind","NodeJs","noEmit","outDir","resolveJsonModule","rootDir","sourceMap","target","ScriptTarget","ES2015","typeRoots","setDiagnosticsOptions","noSemanticValidation","noSyntaxValidation","createModel","language","inferLanguage","getModel","href","model","getModelByHref","focusModel","setModel","lineNumber","revealLineInCenter","ScrollType","Smooth","setPosition","column","columnNumber","markers","setModelMarkers","focus","getModelByPath","_","el","create","automaticLayout","minimap","enabled","showUnused","scrollBeyondLastLine","theme","wordWrap","wrappingIndent","onDidDispose","onDidChangeModel","e","newModelUrl","restoreViewState","onDidBlurEditorText","saveViewState","focusPath","dispose","event","EditorManagerContext","createContext","Editor","className","useRef","editorManager","useContext","useEffect","current","mount","ref","charToInteger","chars","mappings","decoded","line","j","shift","c","segmentify","push","integer","hasContinuationBit","shouldNegate","sourceFileIndex","sourceCodeLine","sourceCodeColumn","nameIndex","generatedCodeColumn","lineMappings","_i","line_1","segmentMappings","encodeInteger","num","clamped","SourceMap","input","sourceRoot","names","sources","sourcesContent","version","stringify","getSourceMappingUrlMatch","re","lastMatch","getSourceMappingUrl","updateSourceMappingUrl","url","index","decodeDataUriAsSourceMap","SourceModuleDependencyKind","Source","source","Link","tracedLine","traced","traceSegment","sourceIndex","tracedSegment","m","PluginManager","plugins","load","ctx","id","readReturn","resolver","readFileContent","readResult","visited","resolveDependency","dependency","fromSourceModule","resolveReturn","resolveResult","found","resolveEntrypoint","transform","createMagicString","endsWith","magicString","prepend","generateDecodedMap","plugin","loadReturn","loadResult","fromModule","kind","pluginCtx","assign","MagicString","sourceMapTree","sourceMapRef","sourceMapUri","baseSources","transformReturn","transformResult","SourceModuleDependency","locations","Entrypoint","exportName","GlobalObject","Require","RequireResolve","isArrowFunctionExpression","node","isFunctionDeclaration","isFunctionExpression","isIdentifier","isMemberExpression","isRestElement","isStringLiteral","isLiteral","traverse","ast","visit","enter","leave","_shouldSkip","shouldSkip","context","skipped","childKeys","sort","b","skip","parse$1","visitorCtx","unboundSymbols","locals","indentExclusionRanges","nodeEnv","replacedSymbols","requires","requireResolves","skipTransform","dependencies","parse$2","allowReturnOutsideFunction","sourceType","scopingAndRequiresVisitor","collectGlobalsVisitor","requiresBySpec","requireDependency","fromRequire","requireResolvesBySpec","fromRequireResolve","symbolName","shim","globalModules","fromGlobalObject","export","location","addSourcemapLocation","_parent","isVariableDeclaration","nextParent","isScope","isBlockScope","declarations","declarePattern","declareFunction","isFunction","isClassDeclaration","isTryStatement","handler","param","visitAndCaptureScoping","isIfStatement","isBinaryExpression","operator","left","right","memberExpressionMatches","rootObject","remove","consequent","alternate","visitAndSkipBranches","isCallExpression","callee","firstArg","console","warn","property","visitRequires","nextCheck","contentOnly","storeName","isPropertyOfMemberExpression","isProperty","isKeyOfProperty","isBindingIdentifier","foundBinding","declaresArguments","isThisExpression","declaresThis","params","isObjectPattern","properties","argument","isArrayPattern","elements","isAssignmentPattern","isProgram","isBlockStatement","pattern","memberParts","createRuntime","velcro","runtime","Module","importMap","exports","require","createRequire","imports","scopes","defs","modules","dependents","resolveSpecAgainstImportMap","moduleDefinition","factory","specParts","__filename","__dirname","_spec","invalidations","queue","dependent","scopesForId","mappedId","ChunkOutput","bundle","sourceModules","inputMap","includeContent","hires","sourceMapTreeMappings","sourceHref","sourceModule","sourceMapsTree","traceMappings","cachedCode","cachedSourceMap","generateSourceMap","cachedSourceMapString","cachedSourceMapDataUri","toDataUri","Chunk","edgesFrom","edgesTo","edges","edge","fromHref","fromUri","toHref","toUri","Bundle","moduleScopes","sourceModuleCode","clone","append","addSource","injectRuntime","Graph","DEFAULT_SHIM_GLOBALS","globalThis","SourceModule","visits","Build","disposer","errors","seen","pendingModuleOperations","onCompletedEmitter","onErrorEmitter","onProgressEmitter","onCompleted","graph","onError","tokenSource","CancellationTokenSource","catch","cancel","fn","fire","progress","completed","pending","GraphBuilder","edgesByDependency","edgesByInvalidation","sourceModulesByInvalidation","pluginManager","build","dep","runAsync","executeResolveDependency","createEdge","addEdge","loadEdge","hasSourceModule","existingSourceModule","addSourceModule","visitSourceModule","executeLoad","executeTransform","parseResult","toRootUri","executeResolveEntrypoint","fromEntrypoint","existingEdge","loadDependency","entrypoints","loadEntrypoint","isUri","deleteAll","invalidate","fromRootUri","sucrasePlugin","extensions","transforms","uriTestRx","RegExp","jsxPragmaRx","jsxFragmentPragmaRx","sucraseOptions","filePath","production","sourceMapOptions","compiledFilename","jsxPragma","jsxPragmaMatches","jsxFragmentPragma","jsxFragmentPragmaMatches","isValidEntry","isValidFile","isValidDirectory","specToString","JSDelivrCdn","specRx","protocol","host","mapChildEntry","matches","dataHost","UnpkgCdn","UNPKG_SPEC_RX","CdnStrategy","readUrlFn","cdn","urlForPackageFile","contentCache","locks","packageEntriesCache","packageJsonCache","isPrefixOf","unresolvedUri","resolveUri","_withRootUriCheck","unresolvedSpec","parseUrl","packageJsonReturn","runInChildContext","_readPackageJsonWithCache","packageJson","results","getResolveRoot","_readPackageEntriesWithCache","resolveRootUri","entriesReturn","canonicalizedSpec","traversalSegments","parentEntry","find","uriStr","cached","recordVisit","ResolverContext","VisitKind","wrappedReturn","debug","_withLock","packageEntriesCacheForModule","exactMatch","range","validRange","satisfies","_readPackageEntries","urlForPackageList","dataStr","normalizePackageListing","packageJsonCacheForModule","_readPackageJson","contentReturn","contentResult","manifest","canonicalHref","lockKey","lock","runCriticalSection","locked","CompoundStrategy","strategies","method","strategy","_delegateToStrategy","getUrlForBareModule","AbstractResolverStrategy","readUrl","fetch","arrayBuffer","VelcroMonaco","monaco","fsm","states","initial","onEvent","transitionTo","stateName","dirty","onEnter","eventName","graphBuilder","buildConfig","autoBuild","waiting","timerHandle","setTimeout","sendEvent","autoBuildWaitTimeout","stateDisposer","clearTimeout","timer_fired","building","Date","now","localStrategy","incremental","onProgress","build_complete","latency","build_error","build_progress","built","onStateChangeEmitter","npmStrategy","forJsDelivr","rootStrategy","mutableBuildState","pendingEvents","Resolver","packageMain","cssCode","BACKSLASH","SINGLE_QUOTE","NL","CR","prependRight","getModels","trackModel","onDidCreateModel","currentStateDef","state","nextStateConfig","fromState","onWillDispose","removeFile","handleChange","disposerReference","getValue","onDidChangeContent","PreviewProgress","props","total","Math","round","PreviewIframeWrap","PreviewWrap","PreviewMessageError","PreviewMessageErrorText","isInternal","PreviewMessages","PreviewMessageLine","PreviewMessage","lines","Preview","previewWrapRef","previewIframeRef","useState","buildState","setBuildState","setMessages","buildProgress","setBuildProgress","onMessage","contentWindow","log","window","addEventListener","removeEventListener","onStateChange","splitChunks","buildForStaticRuntime","codeWithStart","entrypoint","runtimeCode","sourceMapDataUri","codeBundleFile","markup","URL","createObjectURL","htmlUrl","iframe","document","createElement","style","display","src","appendChild","onLoad","once","Entry","modelFocused","color","cursor","backgroundColor","CreateEntry","SidebarFileDelete","Button","StyledTooltip","SidebarFile","activeModel","workbench","setActiveModel","disposable","trackEditor","onDidFocusEditorText","hasTextFocus","onDidCreateEditor","useActiveModel","tooltip","useTooltipState","gutter","onClick","TooltipReference","as","role","aria-label","Tooltip","Sidebar","sortEntries","models","initialEntries","reduce","modelUri","nestedPath","nextDirIdx","setEntries","onWillDisposeModel","findIndex","splice","useDirectory","prompt","onClickCreate","PlaygroundCmp","project","Provider","Playground","react","trim","ServiceWorkerContext","ServiceWorkerProvider","waitingServiceWorker","assetsUpdateReady","assetsCached","useMemo","updateAssets","reload","postMessage","PlaygroundWrapper","StatusBarItem","StatusBarStyles","AppWrapper","Title","Subtitle","Links","Header","globalCss","css","App","CssBaseline","styles","rel","hostname","navigator","serviceWorker","ready","registration","unregister","ReactDOM","render","getElementById","SPEC_RX","parseBareModuleSpec","bareModuleSpec","nameSpec","NODE_CORE_SHIMS","string_decoder","punycode","_uri","settings","overrides","setPrototypeOf","CACHE","Symbol","Visits","cmp","equals","toArray","mapResultWithVisits","cache","cacheInvalidations","debugMode","operationName","encodedOperation","encodePathNode","includes","formattedPath","decodePathNode","_wrapError","resetPath","concat","resetVisits","getCanonicalUrl","receiver","runWithCache","getSettings","invalidated","cacheKey","operationCache","listEntries","readParentPackageJson","contextFn","runInContext","forOperation","mappedResult","cacheEntries","cacheSegment","cacheResult","createStoreResultFn","args","apply","promiseRet","wrappedRet","repeat","parts","bothResolved","canonicalizationResult","resolveRootResult","settingsResult","rootUriWithoutTrailingSlash","resolveAsDirectory","resolveAsFile","readParentPackageJsonReturn","resolveAndPackageJson","readParentPackageJsonResult","parentPackageJson","parsedSpec","resolveBareModule","relativeUri","locatorName","locatorSpec","locatorPath","resolveRootReturn","nextUri","maxIterations","parentPackageJsonReturn","parentPackageJsonResult","directoryUri","devDependencies","peerDependencies","builtIn","bareModuleUriReturn","bareModuleUriResult","listEntriesReturn","listEntriesResult","mainPathname","packageJsonUri","packageJsonEntry","packageJsonContentReturn","packageJsonContentResult","fileUri","ignoreBrowserOverrides","TypeError","browserOverrides","readParentPackageJsonInternal","uriIsCanonicalized","browserMap","packageJsonDir","impliedUri","targetSpec","containingDirUri","entriesResult","entryDirectoryMap","entryFileMap","childFilename","getFirstPathSegmentAfterPrefix","hrefWithExtensionUri","hrefWithExtension","mapping","canonicalizationReturn","visitedDirs","hostRootHref","containingDirUrl","readPackageJsonOrRecurse","parentPackageJsonContentReturn","parentPackageJsonContentResult","parentDir","disposed","rootCtx","runInIsolatedContext"],"mappings":"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","file":"static/js/main.7a0fe75f.chunk.js","sourcesContent":["export { CancellationToken, CancellationTokenSource, DisposableStore, Emitter, Event } from 'ts-primitives';\n\nclass BaseError extends Error {\n    constructor() {\n        super(...arguments);\n        this.name = this.constructor.name;\n    }\n}\nclass AmbiguousModuleError extends BaseError {\n}\nclass CanceledError extends BaseError {\n}\nclass EntryExcludedError extends BaseError {\n    constructor(uri) {\n        super(`Entry was excluded by current configuration '${uri.toString()}'`);\n    }\n}\nclass EntryNotFoundError extends BaseError {\n    constructor(uri) {\n        super(`Unable to resolve '${uri.toString()}'`);\n    }\n}\nclass DependencyNotFoundError extends EntryNotFoundError {\n    constructor(spec, parentUri) {\n        super(`The dependency '${spec}' of '${parentUri.toString()}' was not found`);\n    }\n}\nclass NotResolvableError extends BaseError {\n}\nclass ParseError extends BaseError {\n    constructor(uri, message) {\n        super(`Parsing failed for '${uri.toString()}': ${message}`);\n        this.uri = uri;\n    }\n}\nfunction isCanceledError(err) {\n    return err instanceof CanceledError || (err && err.name === 'CanceledError');\n}\n\n// See: https://github.com/microsoft/TypeScript/pull/26063#issuecomment-461576933\nfunction all(values, token) {\n    let shouldAwait = false;\n    const result = values.map((element) => {\n        if (isThenable(element)) {\n            shouldAwait = true;\n            return checkCancellation(element, token);\n        }\n        return element;\n    });\n    if (shouldAwait) {\n        return Promise.all(result);\n    }\n    return values;\n}\nasync function checkCancellation(promise, token) {\n    try {\n        const result = await promise;\n        if (token.isCancellationRequested) {\n            return Promise.reject(new CanceledError());\n        }\n        return result;\n    }\n    catch (err) {\n        if (token.isCancellationRequested) {\n            return Promise.reject(new CanceledError());\n        }\n        throw err;\n    }\n}\nfunction isThenable(object) {\n    return (object &&\n        // Detection of 'normal' thenable\n        (typeof object.then === 'function' ||\n            // Detection for regenerator runtime state\n            (typeof object.done === 'boolean' &&\n                typeof object.next === 'number' &&\n                typeof object.pre === 'number')));\n}\n\nvar Base64;\n(function (Base64) {\n    Base64.decode = typeof global === 'object' && typeof global['Buffer'] === 'function'\n        ? (data) => global['Buffer'].from(data, 'base64').toString('utf-8')\n        : typeof atob === 'function'\n            ? (data) => decodeURIComponent(escape(atob(data)))\n            : (_data) => {\n                throw new Error('The environment has neither the Buffer nor btoa functions. Please consider polyfilling one of these apis.');\n            };\n    Base64.encode = typeof global === 'object' && typeof global['Buffer'] === 'function'\n        ? (data) => global['Buffer'].from(data).toString('base64')\n        : typeof btoa === 'function'\n            ? (data) => btoa(unescape(encodeURIComponent(data)))\n            : (_data) => {\n                throw new Error('The environment has neither the Buffer nor btoa functions. Please consider polyfilling one of these apis.');\n            };\n})(Base64 || (Base64 = {}));\n\nclass Decoder {\n    constructor() {\n        if (typeof TextDecoder !== 'undefined') {\n            this.decoder = new TextDecoder();\n        }\n        else if (typeof Buffer !== 'function' || typeof Buffer['from'] !== 'function') {\n            throw new Error('The environment supports neither the TextDecoder nor Buffer API. Please consider polyfilling one of these.');\n        }\n    }\n    decode(buf) {\n        const str = this.decoder\n            ? this.decoder.decode(buf)\n            : Buffer.from(buf).toString('utf-8');\n        return str.charCodeAt(0) === 0xfeff ? str.slice(1) : str;\n    }\n}\n\nclass MapSet {\n    constructor() {\n        this._data = new Map();\n    }\n    get size() {\n        return this._data.size;\n    }\n    add(key, value) {\n        let values = this._data.get(key);\n        if (!values) {\n            values = new Set();\n            this._data.set(key, values);\n        }\n        values.add(value);\n        return this;\n    }\n    clear() {\n        this._data.clear();\n    }\n    delete(key, value) {\n        const values = this._data.get(key);\n        if (values) {\n            const ret = values.delete(value);\n            if (!values.size) {\n                this._data.delete(key);\n            }\n            return ret;\n        }\n        return false;\n    }\n    deleteAll(key) {\n        return this._data.delete(key);\n    }\n    get(key) {\n        return this._data.get(key);\n    }\n    has(key) {\n        return this._data.has(key);\n    }\n    hasValue(key, value) {\n        const values = this._data.get(key);\n        return values ? values.has(value) : false;\n    }\n    *entries() {\n        for (const [key, values] of this._data.entries()) {\n            for (const value of values) {\n                yield [key, value];\n            }\n        }\n    }\n    *values() {\n        for (const values of this._data.values()) {\n            yield* values.values();\n        }\n    }\n}\n\nfunction isValidPartialPackageJson(json) {\n    return (typeof json === 'object' &&\n        json !== null &&\n        !hasInvalidOptionalStringField(json, 'name') &&\n        !hasInvalidOptionalStringField(json, 'version') &&\n        !hasInvalidBrowserField(json) &&\n        !hasInvalidOptionalStringField(json, 'main') &&\n        !hasInvalidOptionalStringField(json, 'module') &&\n        !hasInvalidOptionalStringField(json, 'jsnext:main') &&\n        !hasInvalidOptionalStringField(json, 'unpkg') &&\n        !hasInvalidDependenciesField(json, 'dependencies') &&\n        !hasInvalidDependenciesField(json, 'devDependencies') &&\n        !hasInvalidDependenciesField(json, 'peerDependencies'));\n}\nfunction isValidPackageJson(json) {\n    return (typeof json === 'object' &&\n        json !== null &&\n        !hasInvalidRequiredStringField(json, 'name') &&\n        !hasInvalidRequiredStringField(json, 'version') &&\n        !hasInvalidBrowserField(json) &&\n        !hasInvalidOptionalStringField(json, 'main') &&\n        !hasInvalidOptionalStringField(json, 'module') &&\n        !hasInvalidOptionalStringField(json, 'jsnext:main') &&\n        !hasInvalidOptionalStringField(json, 'unpkg') &&\n        !hasInvalidDependenciesField(json, 'dependencies') &&\n        !hasInvalidDependenciesField(json, 'devDependencies') &&\n        !hasInvalidDependenciesField(json, 'peerDependencies'));\n}\nfunction hasInvalidBrowserField(json) {\n    let error = '';\n    const browser = json.browser;\n    if (browser) {\n        if (typeof browser === 'object') {\n            for (const key in browser) {\n                if (typeof key !== 'string') {\n                    error = `The key ${key} of .browser must be a string`;\n                    break;\n                }\n                if (typeof browser[key] !== 'string' && browser[key] !== false) {\n                    error = `The value ${key} of .browser must be a string or false`;\n                    break;\n                }\n            }\n        }\n    }\n    return error;\n}\nfunction hasInvalidRequiredStringField(json, field) {\n    return typeof json[field] !== 'string';\n}\nfunction hasInvalidOptionalStringField(json, field) {\n    return json[field] !== undefined && typeof json[field] !== 'string';\n}\nfunction hasInvalidDependenciesField(json, field) {\n    return (json[field] !== undefined &&\n        typeof json[field] === 'object' &&\n        json[field] !== null &&\n        !Object.keys(json[field]).every((key) => typeof key === 'string' && typeof json[field][key] === 'string'));\n}\nfunction parseBufferAsPartialPackageJson(decoder, content, spec) {\n    try {\n        const text = decoder.decode(content);\n        return parseTextAsPartialPackageJson(text, spec);\n    }\n    catch (err) {\n        throw new Error(`Error decoding manifest buffer for package ${spec}: ${err.message}`);\n    }\n}\nfunction parseBufferAsPackageJson(decoder, content, spec) {\n    try {\n        const text = decoder.decode(content);\n        return parseTextAsPackageJson(text, spec);\n    }\n    catch (err) {\n        throw new Error(`Error decoding manifest buffer for package ${spec}: ${err.message}`);\n    }\n}\nfunction parseTextAsPartialPackageJson(text, spec) {\n    let json;\n    try {\n        json = JSON.parse(text);\n    }\n    catch (err) {\n        throw new Error(`Error parsing manifest as json for package ${spec}: ${err.message}`);\n    }\n    if (!isValidPartialPackageJson(json)) {\n        throw new Error(`Invalid manifest for the package ${spec}`);\n    }\n    return json;\n}\nfunction parseTextAsPackageJson(text, spec) {\n    const json = parseTextAsPartialPackageJson(text, spec);\n    if (!isValidPackageJson(json)) {\n        throw new Error(`Invalid manifest for the package ${spec}`);\n    }\n    return json;\n}\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n// NOTE: VSCode's copy of nodejs path library to be usable in common (non-node) namespace\n// Copied from: https://github.com/nodejs/node/blob/v12.8.1/lib/path.js\n/**\n * Copyright Joyent, Inc. and other Node contributors.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to permit\n * persons to whom the Software is furnished to do so, subject to the\n * following conditions:\n *\n * The above copyright notice and this permission notice shall be included\n * in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n * NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n * USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\nconst CHAR_DOT = 46; /* . */\nconst CHAR_FORWARD_SLASH = 47; /* / */\nclass ErrorInvalidArgType extends Error {\n    constructor(name, expected, actual) {\n        // determiner: 'must be' or 'must not be'\n        let determiner;\n        if (typeof expected === 'string' && expected.indexOf('not ') === 0) {\n            determiner = 'must not be';\n            expected = expected.replace(/^not /, '');\n        }\n        else {\n            determiner = 'must be';\n        }\n        const type = name.indexOf('.') !== -1 ? 'property' : 'argument';\n        let msg = `The \"${name}\" ${type} ${determiner} of type ${expected}`;\n        msg += `. Received type ${typeof actual}`;\n        super(msg);\n        this.code = 'ERR_INVALID_ARG_TYPE';\n    }\n}\nfunction validateString(value, name) {\n    if (typeof value !== 'string') {\n        throw new ErrorInvalidArgType(name, 'string', value);\n    }\n}\nfunction isPosixPathSeparator(code) {\n    return code === CHAR_FORWARD_SLASH;\n}\n// Resolves . and .. elements in a path with directory names\nfunction normalizeString(path, allowAboveRoot, separator, isPathSeparator) {\n    let res = '';\n    let lastSegmentLength = 0;\n    let lastSlash = -1;\n    let dots = 0;\n    let code = 0;\n    for (let i = 0; i <= path.length; ++i) {\n        if (i < path.length) {\n            code = path.charCodeAt(i);\n        }\n        else if (isPathSeparator(code)) {\n            break;\n        }\n        else {\n            code = CHAR_FORWARD_SLASH;\n        }\n        if (isPathSeparator(code)) {\n            if (lastSlash === i - 1 || dots === 1) ;\n            else if (dots === 2) {\n                if (res.length < 2 ||\n                    lastSegmentLength !== 2 ||\n                    res.charCodeAt(res.length - 1) !== CHAR_DOT ||\n                    res.charCodeAt(res.length - 2) !== CHAR_DOT) {\n                    if (res.length > 2) {\n                        const lastSlashIndex = res.lastIndexOf(separator);\n                        if (lastSlashIndex === -1) {\n                            res = '';\n                            lastSegmentLength = 0;\n                        }\n                        else {\n                            res = res.slice(0, lastSlashIndex);\n                            lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);\n                        }\n                        lastSlash = i;\n                        dots = 0;\n                        continue;\n                    }\n                    else if (res.length !== 0) {\n                        res = '';\n                        lastSegmentLength = 0;\n                        lastSlash = i;\n                        dots = 0;\n                        continue;\n                    }\n                }\n                if (allowAboveRoot) {\n                    res += res.length > 0 ? `${separator}..` : '..';\n                    lastSegmentLength = 2;\n                }\n            }\n            else {\n                if (res.length > 0) {\n                    res += `${separator}${path.slice(lastSlash + 1, i)}`;\n                }\n                else {\n                    res = path.slice(lastSlash + 1, i);\n                }\n                lastSegmentLength = i - lastSlash - 1;\n            }\n            lastSlash = i;\n            dots = 0;\n        }\n        else if (code === CHAR_DOT && dots !== -1) {\n            ++dots;\n        }\n        else {\n            dots = -1;\n        }\n    }\n    return res;\n}\nfunction _format(sep, pathObject) {\n    if (pathObject === null || typeof pathObject !== 'object') {\n        throw new ErrorInvalidArgType('pathObject', 'Object', pathObject);\n    }\n    const dir = pathObject.dir || pathObject.root;\n    const base = pathObject.base || `${pathObject.name || ''}${pathObject.ext || ''}`;\n    if (!dir) {\n        return base;\n    }\n    return dir === pathObject.root ? `${dir}${base}` : `${dir}${sep}${base}`;\n}\n// export const win32: IPath = {\n// \t// path.resolve([from ...], to)\n// \tresolve(...pathSegments: string[]): string {\n// \t\tlet resolvedDevice = '';\n// \t\tlet resolvedTail = '';\n// \t\tlet resolvedAbsolute = false;\n// \t\tfor (let i = pathSegments.length - 1; i >= -1; i--) {\n// \t\t\tlet path;\n// \t\t\tif (i >= 0) {\n// \t\t\t\tpath = pathSegments[i];\n// \t\t\t\tvalidateString(path, 'path');\n// \t\t\t\t// Skip empty entries\n// \t\t\t\tif (path.length === 0) {\n// \t\t\t\t\tcontinue;\n// \t\t\t\t}\n// \t\t\t} else if (resolvedDevice.length === 0) {\n// \t\t\t\tpath = process.cwd();\n// \t\t\t} else {\n// \t\t\t\t// Windows has the concept of drive-specific current working\n// \t\t\t\t// directories. If we've resolved a drive letter but not yet an\n// \t\t\t\t// absolute path, get cwd for that drive, or the process cwd if\n// \t\t\t\t// the drive cwd is not available. We're sure the device is not\n// \t\t\t\t// a UNC path at this points, because UNC paths are always absolute.\n// \t\t\t\tpath = (process.env as any)[`=${resolvedDevice}`] || process.cwd();\n// \t\t\t\t// Verify that a cwd was found and that it actually points\n// \t\t\t\t// to our drive. If not, default to the drive's root.\n// \t\t\t\tif (path === undefined ||\n// \t\t\t\t\tpath.slice(0, 2).toLowerCase() !== resolvedDevice.toLowerCase() &&\n// \t\t\t\t\tpath.charCodeAt(2) === CHAR_BACKWARD_SLASH) {\n// \t\t\t\t\tpath = `${resolvedDevice}\\\\`;\n// \t\t\t\t}\n// \t\t\t}\n// \t\t\tconst len = path.length;\n// \t\t\tlet rootEnd = 0;\n// \t\t\tlet device = '';\n// \t\t\tlet isAbsolute = false;\n// \t\t\tconst code = path.charCodeAt(0);\n// \t\t\t// Try to match a root\n// \t\t\tif (len === 1) {\n// \t\t\t\tif (isPathSeparator(code)) {\n// \t\t\t\t\t// `path` contains just a path separator\n// \t\t\t\t\trootEnd = 1;\n// \t\t\t\t\tisAbsolute = true;\n// \t\t\t\t}\n// \t\t\t} else if (isPathSeparator(code)) {\n// \t\t\t\t// Possible UNC root\n// \t\t\t\t// If we started with a separator, we know we at least have an\n// \t\t\t\t// absolute path of some kind (UNC or otherwise)\n// \t\t\t\tisAbsolute = true;\n// \t\t\t\tif (isPathSeparator(path.charCodeAt(1))) {\n// \t\t\t\t\t// Matched double path separator at beginning\n// \t\t\t\t\tlet j = 2;\n// \t\t\t\t\tlet last = j;\n// \t\t\t\t\t// Match 1 or more non-path separators\n// \t\t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n// \t\t\t\t\t\tj++;\n// \t\t\t\t\t}\n// \t\t\t\t\tif (j < len && j !== last) {\n// \t\t\t\t\t\tconst firstPart = path.slice(last, j);\n// \t\t\t\t\t\t// Matched!\n// \t\t\t\t\t\tlast = j;\n// \t\t\t\t\t\t// Match 1 or more path separators\n// \t\t\t\t\t\twhile (j < len && isPathSeparator(path.charCodeAt(j))) {\n// \t\t\t\t\t\t\tj++;\n// \t\t\t\t\t\t}\n// \t\t\t\t\t\tif (j < len && j !== last) {\n// \t\t\t\t\t\t\t// Matched!\n// \t\t\t\t\t\t\tlast = j;\n// \t\t\t\t\t\t\t// Match 1 or more non-path separators\n// \t\t\t\t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n// \t\t\t\t\t\t\t\tj++;\n// \t\t\t\t\t\t\t}\n// \t\t\t\t\t\t\tif (j === len || j !== last) {\n// \t\t\t\t\t\t\t\t// We matched a UNC root\n// \t\t\t\t\t\t\t\tdevice = `\\\\\\\\${firstPart}\\\\${path.slice(last, j)}`;\n// \t\t\t\t\t\t\t\trootEnd = j;\n// \t\t\t\t\t\t\t}\n// \t\t\t\t\t\t}\n// \t\t\t\t\t}\n// \t\t\t\t} else {\n// \t\t\t\t\trootEnd = 1;\n// \t\t\t\t}\n// \t\t\t} else if (isWindowsDeviceRoot(code) &&\n// \t\t\t\tpath.charCodeAt(1) === CHAR_COLON) {\n// \t\t\t\t// Possible device root\n// \t\t\t\tdevice = path.slice(0, 2);\n// \t\t\t\trootEnd = 2;\n// \t\t\t\tif (len > 2 && isPathSeparator(path.charCodeAt(2))) {\n// \t\t\t\t\t// Treat separator following drive name as an absolute path\n// \t\t\t\t\t// indicator\n// \t\t\t\t\tisAbsolute = true;\n// \t\t\t\t\trootEnd = 3;\n// \t\t\t\t}\n// \t\t\t}\n// \t\t\tif (device.length > 0) {\n// \t\t\t\tif (resolvedDevice.length > 0) {\n// \t\t\t\t\tif (device.toLowerCase() !== resolvedDevice.toLowerCase()) {\n// \t\t\t\t\t\t// This path points to another device so it is not applicable\n// \t\t\t\t\t\tcontinue;\n// \t\t\t\t\t}\n// \t\t\t\t} else {\n// \t\t\t\t\tresolvedDevice = device;\n// \t\t\t\t}\n// \t\t\t}\n// \t\t\tif (resolvedAbsolute) {\n// \t\t\t\tif (resolvedDevice.length > 0) {\n// \t\t\t\t\tbreak;\n// \t\t\t\t}\n// \t\t\t} else {\n// \t\t\t\tresolvedTail = `${path.slice(rootEnd)}\\\\${resolvedTail}`;\n// \t\t\t\tresolvedAbsolute = isAbsolute;\n// \t\t\t\tif (isAbsolute && resolvedDevice.length > 0) {\n// \t\t\t\t\tbreak;\n// \t\t\t\t}\n// \t\t\t}\n// \t\t}\n// \t\t// At this point the path should be resolved to a full absolute path,\n// \t\t// but handle relative paths to be safe (might happen when process.cwd()\n// \t\t// fails)\n// \t\t// Normalize the tail path\n// \t\tresolvedTail = normalizeString(resolvedTail, !resolvedAbsolute, '\\\\',\n// \t\t\tisPathSeparator);\n// \t\treturn resolvedAbsolute ?\n// \t\t\t`${resolvedDevice}\\\\${resolvedTail}` :\n// \t\t\t`${resolvedDevice}${resolvedTail}` || '.';\n// \t},\n// \tnormalize(path: string): string {\n// \t\tvalidateString(path, 'path');\n// \t\tconst len = path.length;\n// \t\tif (len === 0) {\n// \t\t\treturn '.';\n// \t\t}\n// \t\tlet rootEnd = 0;\n// \t\tlet device;\n// \t\tlet isAbsolute = false;\n// \t\tconst code = path.charCodeAt(0);\n// \t\t// Try to match a root\n// \t\tif (len === 1) {\n// \t\t\t// `path` contains just a single char, exit early to avoid\n// \t\t\t// unnecessary work\n// \t\t\treturn isPosixPathSeparator(code) ? '\\\\' : path;\n// \t\t}\n// \t\tif (isPathSeparator(code)) {\n// \t\t\t// Possible UNC root\n// \t\t\t// If we started with a separator, we know we at least have an absolute\n// \t\t\t// path of some kind (UNC or otherwise)\n// \t\t\tisAbsolute = true;\n// \t\t\tif (isPathSeparator(path.charCodeAt(1))) {\n// \t\t\t\t// Matched double path separator at beginning\n// \t\t\t\tlet j = 2;\n// \t\t\t\tlet last = j;\n// \t\t\t\t// Match 1 or more non-path separators\n// \t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n// \t\t\t\t\tj++;\n// \t\t\t\t}\n// \t\t\t\tif (j < len && j !== last) {\n// \t\t\t\t\tconst firstPart = path.slice(last, j);\n// \t\t\t\t\t// Matched!\n// \t\t\t\t\tlast = j;\n// \t\t\t\t\t// Match 1 or more path separators\n// \t\t\t\t\twhile (j < len && isPathSeparator(path.charCodeAt(j))) {\n// \t\t\t\t\t\tj++;\n// \t\t\t\t\t}\n// \t\t\t\t\tif (j < len && j !== last) {\n// \t\t\t\t\t\t// Matched!\n// \t\t\t\t\t\tlast = j;\n// \t\t\t\t\t\t// Match 1 or more non-path separators\n// \t\t\t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n// \t\t\t\t\t\t\tj++;\n// \t\t\t\t\t\t}\n// \t\t\t\t\t\tif (j === len) {\n// \t\t\t\t\t\t\t// We matched a UNC root only\n// \t\t\t\t\t\t\t// Return the normalized version of the UNC root since there\n// \t\t\t\t\t\t\t// is nothing left to process\n// \t\t\t\t\t\t\treturn `\\\\\\\\${firstPart}\\\\${path.slice(last)}\\\\`;\n// \t\t\t\t\t\t}\n// \t\t\t\t\t\tif (j !== last) {\n// \t\t\t\t\t\t\t// We matched a UNC root with leftovers\n// \t\t\t\t\t\t\tdevice = `\\\\\\\\${firstPart}\\\\${path.slice(last, j)}`;\n// \t\t\t\t\t\t\trootEnd = j;\n// \t\t\t\t\t\t}\n// \t\t\t\t\t}\n// \t\t\t\t}\n// \t\t\t} else {\n// \t\t\t\trootEnd = 1;\n// \t\t\t}\n// \t\t} else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {\n// \t\t\t// Possible device root\n// \t\t\tdevice = path.slice(0, 2);\n// \t\t\trootEnd = 2;\n// \t\t\tif (len > 2 && isPathSeparator(path.charCodeAt(2))) {\n// \t\t\t\t// Treat separator following drive name as an absolute path\n// \t\t\t\t// indicator\n// \t\t\t\tisAbsolute = true;\n// \t\t\t\trootEnd = 3;\n// \t\t\t}\n// \t\t}\n// \t\tlet tail = rootEnd < len ?\n// \t\t\tnormalizeString(path.slice(rootEnd), !isAbsolute, '\\\\', isPathSeparator) :\n// \t\t\t'';\n// \t\tif (tail.length === 0 && !isAbsolute) {\n// \t\t\ttail = '.';\n// \t\t}\n// \t\tif (tail.length > 0 && isPathSeparator(path.charCodeAt(len - 1))) {\n// \t\t\ttail += '\\\\';\n// \t\t}\n// \t\tif (device === undefined) {\n// \t\t\treturn isAbsolute ? `\\\\${tail}` : tail;\n// \t\t}\n// \t\treturn isAbsolute ? `${device}\\\\${tail}` : `${device}${tail}`;\n// \t},\n// \tisAbsolute(path: string): boolean {\n// \t\tvalidateString(path, 'path');\n// \t\tconst len = path.length;\n// \t\tif (len === 0) {\n// \t\t\treturn false;\n// \t\t}\n// \t\tconst code = path.charCodeAt(0);\n// \t\treturn isPathSeparator(code) ||\n// \t\t\t// Possible device root\n// \t\t\tlen > 2 &&\n// \t\t\tisWindowsDeviceRoot(code) &&\n// \t\t\tpath.charCodeAt(1) === CHAR_COLON &&\n// \t\t\tisPathSeparator(path.charCodeAt(2));\n// \t},\n// \tjoin(...paths: string[]): string {\n// \t\tif (paths.length === 0) {\n// \t\t\treturn '.';\n// \t\t}\n// \t\tlet joined;\n// \t\tlet firstPart: string | undefined;\n// \t\tfor (let i = 0; i < paths.length; ++i) {\n// \t\t\tconst arg = paths[i];\n// \t\t\tvalidateString(arg, 'path');\n// \t\t\tif (arg.length > 0) {\n// \t\t\t\tif (joined === undefined) {\n// \t\t\t\t\tjoined = firstPart = arg;\n// \t\t\t\t}\n// \t\t\t\telse {\n// \t\t\t\t\tjoined += `\\\\${arg}`;\n// \t\t\t\t}\n// \t\t\t}\n// \t\t}\n// \t\tif (joined === undefined) {\n// \t\t\treturn '.';\n// \t\t}\n// \t\t// Make sure that the joined path doesn't start with two slashes, because\n// \t\t// normalize() will mistake it for an UNC path then.\n// \t\t//\n// \t\t// This step is skipped when it is very clear that the user actually\n// \t\t// intended to point at an UNC path. This is assumed when the first\n// \t\t// non-empty string arguments starts with exactly two slashes followed by\n// \t\t// at least one more non-slash character.\n// \t\t//\n// \t\t// Note that for normalize() to treat a path as an UNC path it needs to\n// \t\t// have at least 2 components, so we don't filter for that here.\n// \t\t// This means that the user can use join to construct UNC paths from\n// \t\t// a server name and a share name; for example:\n// \t\t//   path.join('//server', 'share') -> '\\\\\\\\server\\\\share\\\\')\n// \t\tlet needsReplace = true;\n// \t\tlet slashCount = 0;\n// \t\tif (typeof firstPart === 'string' && isPathSeparator(firstPart.charCodeAt(0))) {\n// \t\t\t++slashCount;\n// \t\t\tconst firstLen = firstPart.length;\n// \t\t\tif (firstLen > 1 && isPathSeparator(firstPart.charCodeAt(1))) {\n// \t\t\t\t++slashCount;\n// \t\t\t\tif (firstLen > 2) {\n// \t\t\t\t\tif (isPathSeparator(firstPart.charCodeAt(2))) {\n// \t\t\t\t\t\t++slashCount;\n// \t\t\t\t\t} else {\n// \t\t\t\t\t\t// We matched a UNC path in the first part\n// \t\t\t\t\t\tneedsReplace = false;\n// \t\t\t\t\t}\n// \t\t\t\t}\n// \t\t\t}\n// \t\t}\n// \t\tif (needsReplace) {\n// \t\t\t// Find any more consecutive slashes we need to replace\n// \t\t\twhile (slashCount < joined.length &&\n// \t\t\t\tisPathSeparator(joined.charCodeAt(slashCount))) {\n// \t\t\t\tslashCount++;\n// \t\t\t}\n// \t\t\t// Replace the slashes if needed\n// \t\t\tif (slashCount >= 2) {\n// \t\t\t\tjoined = `\\\\${joined.slice(slashCount)}`;\n// \t\t\t}\n// \t\t}\n// \t\treturn win32.normalize(joined);\n// \t},\n// \t// It will solve the relative path from `from` to `to`, for instance:\n// \t//  from = 'C:\\\\orandea\\\\test\\\\aaa'\n// \t//  to = 'C:\\\\orandea\\\\impl\\\\bbb'\n// \t// The output of the function should be: '..\\\\..\\\\impl\\\\bbb'\n// \trelative(from: string, to: string): string {\n// \t\tvalidateString(from, 'from');\n// \t\tvalidateString(to, 'to');\n// \t\tif (from === to) {\n// \t\t\treturn '';\n// \t\t}\n// \t\tconst fromOrig = win32.resolve(from);\n// \t\tconst toOrig = win32.resolve(to);\n// \t\tif (fromOrig === toOrig) {\n// \t\t\treturn '';\n// \t\t}\n// \t\tfrom = fromOrig.toLowerCase();\n// \t\tto = toOrig.toLowerCase();\n// \t\tif (from === to) {\n// \t\t\treturn '';\n// \t\t}\n// \t\t// Trim any leading backslashes\n// \t\tlet fromStart = 0;\n// \t\twhile (fromStart < from.length &&\n// \t\t\tfrom.charCodeAt(fromStart) === CHAR_BACKWARD_SLASH) {\n// \t\t\tfromStart++;\n// \t\t}\n// \t\t// Trim trailing backslashes (applicable to UNC paths only)\n// \t\tlet fromEnd = from.length;\n// \t\twhile (fromEnd - 1 > fromStart &&\n// \t\t\tfrom.charCodeAt(fromEnd - 1) === CHAR_BACKWARD_SLASH) {\n// \t\t\tfromEnd--;\n// \t\t}\n// \t\tconst fromLen = fromEnd - fromStart;\n// \t\t// Trim any leading backslashes\n// \t\tlet toStart = 0;\n// \t\twhile (toStart < to.length &&\n// \t\t\tto.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {\n// \t\t\ttoStart++;\n// \t\t}\n// \t\t// Trim trailing backslashes (applicable to UNC paths only)\n// \t\tlet toEnd = to.length;\n// \t\twhile (toEnd - 1 > toStart &&\n// \t\t\tto.charCodeAt(toEnd - 1) === CHAR_BACKWARD_SLASH) {\n// \t\t\ttoEnd--;\n// \t\t}\n// \t\tconst toLen = toEnd - toStart;\n// \t\t// Compare paths to find the longest common path from root\n// \t\tconst length = fromLen < toLen ? fromLen : toLen;\n// \t\tlet lastCommonSep = -1;\n// \t\tlet i = 0;\n// \t\tfor (; i < length; i++) {\n// \t\t\tconst fromCode = from.charCodeAt(fromStart + i);\n// \t\t\tif (fromCode !== to.charCodeAt(toStart + i)) {\n// \t\t\t\tbreak;\n// \t\t\t} else if (fromCode === CHAR_BACKWARD_SLASH) {\n// \t\t\t\tlastCommonSep = i;\n// \t\t\t}\n// \t\t}\n// \t\t// We found a mismatch before the first common path separator was seen, so\n// \t\t// return the original `to`.\n// \t\tif (i !== length) {\n// \t\t\tif (lastCommonSep === -1) {\n// \t\t\t\treturn toOrig;\n// \t\t\t}\n// \t\t} else {\n// \t\t\tif (toLen > length) {\n// \t\t\t\tif (to.charCodeAt(toStart + i) === CHAR_BACKWARD_SLASH) {\n// \t\t\t\t\t// We get here if `from` is the exact base path for `to`.\n// \t\t\t\t\t// For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo\\\\bar\\\\baz'\n// \t\t\t\t\treturn toOrig.slice(toStart + i + 1);\n// \t\t\t\t}\n// \t\t\t\tif (i === 2) {\n// \t\t\t\t\t// We get here if `from` is the device root.\n// \t\t\t\t\t// For example: from='C:\\\\'; to='C:\\\\foo'\n// \t\t\t\t\treturn toOrig.slice(toStart + i);\n// \t\t\t\t}\n// \t\t\t}\n// \t\t\tif (fromLen > length) {\n// \t\t\t\tif (from.charCodeAt(fromStart + i) === CHAR_BACKWARD_SLASH) {\n// \t\t\t\t\t// We get here if `to` is the exact base path for `from`.\n// \t\t\t\t\t// For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo'\n// \t\t\t\t\tlastCommonSep = i;\n// \t\t\t\t} else if (i === 2) {\n// \t\t\t\t\t// We get here if `to` is the device root.\n// \t\t\t\t\t// For example: from='C:\\\\foo\\\\bar'; to='C:\\\\'\n// \t\t\t\t\tlastCommonSep = 3;\n// \t\t\t\t}\n// \t\t\t}\n// \t\t\tif (lastCommonSep === -1) {\n// \t\t\t\tlastCommonSep = 0;\n// \t\t\t}\n// \t\t}\n// \t\tlet out = '';\n// \t\t// Generate the relative path based on the path difference between `to` and\n// \t\t// `from`\n// \t\tfor (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n// \t\t\tif (i === fromEnd || from.charCodeAt(i) === CHAR_BACKWARD_SLASH) {\n// \t\t\t\tout += out.length === 0 ? '..' : '\\\\..';\n// \t\t\t}\n// \t\t}\n// \t\ttoStart += lastCommonSep;\n// \t\t// Lastly, append the rest of the destination (`to`) path that comes after\n// \t\t// the common path parts\n// \t\tif (out.length > 0) {\n// \t\t\treturn `${out}${toOrig.slice(toStart, toEnd)}`;\n// \t\t}\n// \t\tif (toOrig.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {\n// \t\t\t++toStart;\n// \t\t}\n// \t\treturn toOrig.slice(toStart, toEnd);\n// \t},\n// \ttoNamespacedPath(path: string): string {\n// \t\t// Note: this will *probably* throw somewhere.\n// \t\tif (typeof path !== 'string') {\n// \t\t\treturn path;\n// \t\t}\n// \t\tif (path.length === 0) {\n// \t\t\treturn '';\n// \t\t}\n// \t\tconst resolvedPath = win32.resolve(path);\n// \t\tif (resolvedPath.length <= 2) {\n// \t\t\treturn path;\n// \t\t}\n// \t\tif (resolvedPath.charCodeAt(0) === CHAR_BACKWARD_SLASH) {\n// \t\t\t// Possible UNC root\n// \t\t\tif (resolvedPath.charCodeAt(1) === CHAR_BACKWARD_SLASH) {\n// \t\t\t\tconst code = resolvedPath.charCodeAt(2);\n// \t\t\t\tif (code !== CHAR_QUESTION_MARK && code !== CHAR_DOT) {\n// \t\t\t\t\t// Matched non-long UNC root, convert the path to a long UNC path\n// \t\t\t\t\treturn `\\\\\\\\?\\\\UNC\\\\${resolvedPath.slice(2)}`;\n// \t\t\t\t}\n// \t\t\t}\n// \t\t} else if (isWindowsDeviceRoot(resolvedPath.charCodeAt(0)) &&\n// \t\t\tresolvedPath.charCodeAt(1) === CHAR_COLON &&\n// \t\t\tresolvedPath.charCodeAt(2) === CHAR_BACKWARD_SLASH) {\n// \t\t\t// Matched device root, convert the path to a long UNC path\n// \t\t\treturn `\\\\\\\\?\\\\${resolvedPath}`;\n// \t\t}\n// \t\treturn path;\n// \t},\n// \tdirname(path: string): string {\n// \t\tvalidateString(path, 'path');\n// \t\tconst len = path.length;\n// \t\tif (len === 0) {\n// \t\t\treturn '.';\n// \t\t}\n// \t\tlet rootEnd = -1;\n// \t\tlet offset = 0;\n// \t\tconst code = path.charCodeAt(0);\n// \t\tif (len === 1) {\n// \t\t\t// `path` contains just a path separator, exit early to avoid\n// \t\t\t// unnecessary work or a dot.\n// \t\t\treturn isPathSeparator(code) ? path : '.';\n// \t\t}\n// \t\t// Try to match a root\n// \t\tif (isPathSeparator(code)) {\n// \t\t\t// Possible UNC root\n// \t\t\trootEnd = offset = 1;\n// \t\t\tif (isPathSeparator(path.charCodeAt(1))) {\n// \t\t\t\t// Matched double path separator at beginning\n// \t\t\t\tlet j = 2;\n// \t\t\t\tlet last = j;\n// \t\t\t\t// Match 1 or more non-path separators\n// \t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n// \t\t\t\t\tj++;\n// \t\t\t\t}\n// \t\t\t\tif (j < len && j !== last) {\n// \t\t\t\t\t// Matched!\n// \t\t\t\t\tlast = j;\n// \t\t\t\t\t// Match 1 or more path separators\n// \t\t\t\t\twhile (j < len && isPathSeparator(path.charCodeAt(j))) {\n// \t\t\t\t\t\tj++;\n// \t\t\t\t\t}\n// \t\t\t\t\tif (j < len && j !== last) {\n// \t\t\t\t\t\t// Matched!\n// \t\t\t\t\t\tlast = j;\n// \t\t\t\t\t\t// Match 1 or more non-path separators\n// \t\t\t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n// \t\t\t\t\t\t\tj++;\n// \t\t\t\t\t\t}\n// \t\t\t\t\t\tif (j === len) {\n// \t\t\t\t\t\t\t// We matched a UNC root only\n// \t\t\t\t\t\t\treturn path;\n// \t\t\t\t\t\t}\n// \t\t\t\t\t\tif (j !== last) {\n// \t\t\t\t\t\t\t// We matched a UNC root with leftovers\n// \t\t\t\t\t\t\t// Offset by 1 to include the separator after the UNC root to\n// \t\t\t\t\t\t\t// treat it as a \"normal root\" on top of a (UNC) root\n// \t\t\t\t\t\t\trootEnd = offset = j + 1;\n// \t\t\t\t\t\t}\n// \t\t\t\t\t}\n// \t\t\t\t}\n// \t\t\t}\n// \t\t\t// Possible device root\n// \t\t} else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {\n// \t\t\trootEnd = len > 2 && isPathSeparator(path.charCodeAt(2)) ? 3 : 2;\n// \t\t\toffset = rootEnd;\n// \t\t}\n// \t\tlet end = -1;\n// \t\tlet matchedSlash = true;\n// \t\tfor (let i = len - 1; i >= offset; --i) {\n// \t\t\tif (isPathSeparator(path.charCodeAt(i))) {\n// \t\t\t\tif (!matchedSlash) {\n// \t\t\t\t\tend = i;\n// \t\t\t\t\tbreak;\n// \t\t\t\t}\n// \t\t\t} else {\n// \t\t\t\t// We saw the first non-path separator\n// \t\t\t\tmatchedSlash = false;\n// \t\t\t}\n// \t\t}\n// \t\tif (end === -1) {\n// \t\t\tif (rootEnd === -1) {\n// \t\t\t\treturn '.';\n// \t\t\t}\n// \t\t\tend = rootEnd;\n// \t\t}\n// \t\treturn path.slice(0, end);\n// \t},\n// \tbasename(path: string, ext?: string): string {\n// \t\tif (ext !== undefined) {\n// \t\t\tvalidateString(ext, 'ext');\n// \t\t}\n// \t\tvalidateString(path, 'path');\n// \t\tlet start = 0;\n// \t\tlet end = -1;\n// \t\tlet matchedSlash = true;\n// \t\tlet i;\n// \t\t// Check for a drive letter prefix so as not to mistake the following\n// \t\t// path separator as an extra separator at the end of the path that can be\n// \t\t// disregarded\n// \t\tif (path.length >= 2 &&\n// \t\t\tisWindowsDeviceRoot(path.charCodeAt(0)) &&\n// \t\t\tpath.charCodeAt(1) === CHAR_COLON) {\n// \t\t\tstart = 2;\n// \t\t}\n// \t\tif (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n// \t\t\tif (ext === path) {\n// \t\t\t\treturn '';\n// \t\t\t}\n// \t\t\tlet extIdx = ext.length - 1;\n// \t\t\tlet firstNonSlashEnd = -1;\n// \t\t\tfor (i = path.length - 1; i >= start; --i) {\n// \t\t\t\tconst code = path.charCodeAt(i);\n// \t\t\t\tif (isPathSeparator(code)) {\n// \t\t\t\t\t// If we reached a path separator that was not part of a set of path\n// \t\t\t\t\t// separators at the end of the string, stop now\n// \t\t\t\t\tif (!matchedSlash) {\n// \t\t\t\t\t\tstart = i + 1;\n// \t\t\t\t\t\tbreak;\n// \t\t\t\t\t}\n// \t\t\t\t} else {\n// \t\t\t\t\tif (firstNonSlashEnd === -1) {\n// \t\t\t\t\t\t// We saw the first non-path separator, remember this index in case\n// \t\t\t\t\t\t// we need it if the extension ends up not matching\n// \t\t\t\t\t\tmatchedSlash = false;\n// \t\t\t\t\t\tfirstNonSlashEnd = i + 1;\n// \t\t\t\t\t}\n// \t\t\t\t\tif (extIdx >= 0) {\n// \t\t\t\t\t\t// Try to match the explicit extension\n// \t\t\t\t\t\tif (code === ext.charCodeAt(extIdx)) {\n// \t\t\t\t\t\t\tif (--extIdx === -1) {\n// \t\t\t\t\t\t\t\t// We matched the extension, so mark this as the end of our path\n// \t\t\t\t\t\t\t\t// component\n// \t\t\t\t\t\t\t\tend = i;\n// \t\t\t\t\t\t\t}\n// \t\t\t\t\t\t} else {\n// \t\t\t\t\t\t\t// Extension does not match, so our result is the entire path\n// \t\t\t\t\t\t\t// component\n// \t\t\t\t\t\t\textIdx = -1;\n// \t\t\t\t\t\t\tend = firstNonSlashEnd;\n// \t\t\t\t\t\t}\n// \t\t\t\t\t}\n// \t\t\t\t}\n// \t\t\t}\n// \t\t\tif (start === end) {\n// \t\t\t\tend = firstNonSlashEnd;\n// \t\t\t} else if (end === -1) {\n// \t\t\t\tend = path.length;\n// \t\t\t}\n// \t\t\treturn path.slice(start, end);\n// \t\t}\n// \t\tfor (i = path.length - 1; i >= start; --i) {\n// \t\t\tif (isPathSeparator(path.charCodeAt(i))) {\n// \t\t\t\t// If we reached a path separator that was not part of a set of path\n// \t\t\t\t// separators at the end of the string, stop now\n// \t\t\t\tif (!matchedSlash) {\n// \t\t\t\t\tstart = i + 1;\n// \t\t\t\t\tbreak;\n// \t\t\t\t}\n// \t\t\t} else if (end === -1) {\n// \t\t\t\t// We saw the first non-path separator, mark this as the end of our\n// \t\t\t\t// path component\n// \t\t\t\tmatchedSlash = false;\n// \t\t\t\tend = i + 1;\n// \t\t\t}\n// \t\t}\n// \t\tif (end === -1) {\n// \t\t\treturn '';\n// \t\t}\n// \t\treturn path.slice(start, end);\n// \t},\n// \textname(path: string): string {\n// \t\tvalidateString(path, 'path');\n// \t\tlet start = 0;\n// \t\tlet startDot = -1;\n// \t\tlet startPart = 0;\n// \t\tlet end = -1;\n// \t\tlet matchedSlash = true;\n// \t\t// Track the state of characters (if any) we see before our first dot and\n// \t\t// after any path separator we find\n// \t\tlet preDotState = 0;\n// \t\t// Check for a drive letter prefix so as not to mistake the following\n// \t\t// path separator as an extra separator at the end of the path that can be\n// \t\t// disregarded\n// \t\tif (path.length >= 2 &&\n// \t\t\tpath.charCodeAt(1) === CHAR_COLON &&\n// \t\t\tisWindowsDeviceRoot(path.charCodeAt(0))) {\n// \t\t\tstart = startPart = 2;\n// \t\t}\n// \t\tfor (let i = path.length - 1; i >= start; --i) {\n// \t\t\tconst code = path.charCodeAt(i);\n// \t\t\tif (isPathSeparator(code)) {\n// \t\t\t\t// If we reached a path separator that was not part of a set of path\n// \t\t\t\t// separators at the end of the string, stop now\n// \t\t\t\tif (!matchedSlash) {\n// \t\t\t\t\tstartPart = i + 1;\n// \t\t\t\t\tbreak;\n// \t\t\t\t}\n// \t\t\t\tcontinue;\n// \t\t\t}\n// \t\t\tif (end === -1) {\n// \t\t\t\t// We saw the first non-path separator, mark this as the end of our\n// \t\t\t\t// extension\n// \t\t\t\tmatchedSlash = false;\n// \t\t\t\tend = i + 1;\n// \t\t\t}\n// \t\t\tif (code === CHAR_DOT) {\n// \t\t\t\t// If this is our first dot, mark it as the start of our extension\n// \t\t\t\tif (startDot === -1) {\n// \t\t\t\t\tstartDot = i;\n// \t\t\t\t}\n// \t\t\t\telse if (preDotState !== 1) {\n// \t\t\t\t\tpreDotState = 1;\n// \t\t\t\t}\n// \t\t\t} else if (startDot !== -1) {\n// \t\t\t\t// We saw a non-dot and non-path separator before our dot, so we should\n// \t\t\t\t// have a good chance at having a non-empty extension\n// \t\t\t\tpreDotState = -1;\n// \t\t\t}\n// \t\t}\n// \t\tif (startDot === -1 ||\n// \t\t\tend === -1 ||\n// \t\t\t// We saw a non-dot character immediately before the dot\n// \t\t\tpreDotState === 0 ||\n// \t\t\t// The (right-most) trimmed path component is exactly '..'\n// \t\t\t(preDotState === 1 &&\n// \t\t\t\tstartDot === end - 1 &&\n// \t\t\t\tstartDot === startPart + 1)) {\n// \t\t\treturn '';\n// \t\t}\n// \t\treturn path.slice(startDot, end);\n// \t},\n// \tformat: _format.bind(null, '\\\\'),\n// \tparse(path) {\n// \t\tvalidateString(path, 'path');\n// \t\tconst ret = { root: '', dir: '', base: '', ext: '', name: '' };\n// \t\tif (path.length === 0) {\n// \t\t\treturn ret;\n// \t\t}\n// \t\tconst len = path.length;\n// \t\tlet rootEnd = 0;\n// \t\tlet code = path.charCodeAt(0);\n// \t\tif (len === 1) {\n// \t\t\tif (isPathSeparator(code)) {\n// \t\t\t\t// `path` contains just a path separator, exit early to avoid\n// \t\t\t\t// unnecessary work\n// \t\t\t\tret.root = ret.dir = path;\n// \t\t\t\treturn ret;\n// \t\t\t}\n// \t\t\tret.base = ret.name = path;\n// \t\t\treturn ret;\n// \t\t}\n// \t\t// Try to match a root\n// \t\tif (isPathSeparator(code)) {\n// \t\t\t// Possible UNC root\n// \t\t\trootEnd = 1;\n// \t\t\tif (isPathSeparator(path.charCodeAt(1))) {\n// \t\t\t\t// Matched double path separator at beginning\n// \t\t\t\tlet j = 2;\n// \t\t\t\tlet last = j;\n// \t\t\t\t// Match 1 or more non-path separators\n// \t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n// \t\t\t\t\tj++;\n// \t\t\t\t}\n// \t\t\t\tif (j < len && j !== last) {\n// \t\t\t\t\t// Matched!\n// \t\t\t\t\tlast = j;\n// \t\t\t\t\t// Match 1 or more path separators\n// \t\t\t\t\twhile (j < len && isPathSeparator(path.charCodeAt(j))) {\n// \t\t\t\t\t\tj++;\n// \t\t\t\t\t}\n// \t\t\t\t\tif (j < len && j !== last) {\n// \t\t\t\t\t\t// Matched!\n// \t\t\t\t\t\tlast = j;\n// \t\t\t\t\t\t// Match 1 or more non-path separators\n// \t\t\t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n// \t\t\t\t\t\t\tj++;\n// \t\t\t\t\t\t}\n// \t\t\t\t\t\tif (j === len) {\n// \t\t\t\t\t\t\t// We matched a UNC root only\n// \t\t\t\t\t\t\trootEnd = j;\n// \t\t\t\t\t\t} else if (j !== last) {\n// \t\t\t\t\t\t\t// We matched a UNC root with leftovers\n// \t\t\t\t\t\t\trootEnd = j + 1;\n// \t\t\t\t\t\t}\n// \t\t\t\t\t}\n// \t\t\t\t}\n// \t\t\t}\n// \t\t} else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {\n// \t\t\t// Possible device root\n// \t\t\tif (len <= 2) {\n// \t\t\t\t// `path` contains just a drive root, exit early to avoid\n// \t\t\t\t// unnecessary work\n// \t\t\t\tret.root = ret.dir = path;\n// \t\t\t\treturn ret;\n// \t\t\t}\n// \t\t\trootEnd = 2;\n// \t\t\tif (isPathSeparator(path.charCodeAt(2))) {\n// \t\t\t\tif (len === 3) {\n// \t\t\t\t\t// `path` contains just a drive root, exit early to avoid\n// \t\t\t\t\t// unnecessary work\n// \t\t\t\t\tret.root = ret.dir = path;\n// \t\t\t\t\treturn ret;\n// \t\t\t\t}\n// \t\t\t\trootEnd = 3;\n// \t\t\t}\n// \t\t}\n// \t\tif (rootEnd > 0) {\n// \t\t\tret.root = path.slice(0, rootEnd);\n// \t\t}\n// \t\tlet startDot = -1;\n// \t\tlet startPart = rootEnd;\n// \t\tlet end = -1;\n// \t\tlet matchedSlash = true;\n// \t\tlet i = path.length - 1;\n// \t\t// Track the state of characters (if any) we see before our first dot and\n// \t\t// after any path separator we find\n// \t\tlet preDotState = 0;\n// \t\t// Get non-dir info\n// \t\tfor (; i >= rootEnd; --i) {\n// \t\t\tcode = path.charCodeAt(i);\n// \t\t\tif (isPathSeparator(code)) {\n// \t\t\t\t// If we reached a path separator that was not part of a set of path\n// \t\t\t\t// separators at the end of the string, stop now\n// \t\t\t\tif (!matchedSlash) {\n// \t\t\t\t\tstartPart = i + 1;\n// \t\t\t\t\tbreak;\n// \t\t\t\t}\n// \t\t\t\tcontinue;\n// \t\t\t}\n// \t\t\tif (end === -1) {\n// \t\t\t\t// We saw the first non-path separator, mark this as the end of our\n// \t\t\t\t// extension\n// \t\t\t\tmatchedSlash = false;\n// \t\t\t\tend = i + 1;\n// \t\t\t}\n// \t\t\tif (code === CHAR_DOT) {\n// \t\t\t\t// If this is our first dot, mark it as the start of our extension\n// \t\t\t\tif (startDot === -1) {\n// \t\t\t\t\tstartDot = i;\n// \t\t\t\t} else if (preDotState !== 1) {\n// \t\t\t\t\tpreDotState = 1;\n// \t\t\t\t}\n// \t\t\t} else if (startDot !== -1) {\n// \t\t\t\t// We saw a non-dot and non-path separator before our dot, so we should\n// \t\t\t\t// have a good chance at having a non-empty extension\n// \t\t\t\tpreDotState = -1;\n// \t\t\t}\n// \t\t}\n// \t\tif (end !== -1) {\n// \t\t\tif (startDot === -1 ||\n// \t\t\t\t// We saw a non-dot character immediately before the dot\n// \t\t\t\tpreDotState === 0 ||\n// \t\t\t\t// The (right-most) trimmed path component is exactly '..'\n// \t\t\t\t(preDotState === 1 &&\n// \t\t\t\t\tstartDot === end - 1 &&\n// \t\t\t\t\tstartDot === startPart + 1)) {\n// \t\t\t\tret.base = ret.name = path.slice(startPart, end);\n// \t\t\t} else {\n// \t\t\t\tret.name = path.slice(startPart, startDot);\n// \t\t\t\tret.base = path.slice(startPart, end);\n// \t\t\t\tret.ext = path.slice(startDot, end);\n// \t\t\t}\n// \t\t}\n// \t\t// If the directory is the root, use the entire root as the `dir` including\n// \t\t// the trailing slash if any (`C:\\abc` -> `C:\\`). Otherwise, strip out the\n// \t\t// trailing slash (`C:\\abc\\def` -> `C:\\abc`).\n// \t\tif (startPart > 0 && startPart !== rootEnd) {\n// \t\t\tret.dir = path.slice(0, startPart - 1);\n// \t\t} else {\n// \t\t\tret.dir = ret.root;\n// \t\t}\n// \t\treturn ret;\n// \t},\n// \tsep: '\\\\',\n// \tdelimiter: ';',\n// \twin32: null,\n// \tposix: null\n// };\nconst posix = {\n    // path.resolve([from ...], to)\n    resolve(...pathSegments) {\n        let resolvedPath = '';\n        let resolvedAbsolute = false;\n        for (let i = pathSegments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n            const path = i >= 0 ? pathSegments[i] : process.cwd();\n            validateString(path, 'path');\n            // Skip empty entries\n            if (path.length === 0) {\n                continue;\n            }\n            resolvedPath = `${path}/${resolvedPath}`;\n            resolvedAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n        }\n        // At this point the path should be resolved to a full absolute path, but\n        // handle relative paths to be safe (might happen when process.cwd() fails)\n        // Normalize the path\n        resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute, '/', isPosixPathSeparator);\n        if (resolvedAbsolute) {\n            return `/${resolvedPath}`;\n        }\n        return resolvedPath.length > 0 ? resolvedPath : '.';\n    },\n    normalize(path) {\n        validateString(path, 'path');\n        if (path.length === 0) {\n            return '.';\n        }\n        const isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n        const trailingSeparator = path.charCodeAt(path.length - 1) === CHAR_FORWARD_SLASH;\n        // Normalize the path\n        path = normalizeString(path, !isAbsolute, '/', isPosixPathSeparator);\n        if (path.length === 0) {\n            if (isAbsolute) {\n                return '/';\n            }\n            return trailingSeparator ? './' : '.';\n        }\n        if (trailingSeparator) {\n            path += '/';\n        }\n        return isAbsolute ? `/${path}` : path;\n    },\n    isAbsolute(path) {\n        validateString(path, 'path');\n        return path.length > 0 && path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n    },\n    join(...paths) {\n        if (paths.length === 0) {\n            return '.';\n        }\n        let joined;\n        for (let i = 0; i < paths.length; ++i) {\n            const arg = paths[i];\n            validateString(arg, 'path');\n            if (arg.length > 0) {\n                if (joined === undefined) {\n                    joined = arg;\n                }\n                else {\n                    joined += `/${arg}`;\n                }\n            }\n        }\n        if (joined === undefined) {\n            return '.';\n        }\n        return posix.normalize(joined);\n    },\n    relative(from, to) {\n        validateString(from, 'from');\n        validateString(to, 'to');\n        if (from === to) {\n            return '';\n        }\n        // Trim leading forward slashes.\n        from = posix.resolve(from);\n        to = posix.resolve(to);\n        if (from === to) {\n            return '';\n        }\n        const fromStart = 1;\n        const fromEnd = from.length;\n        const fromLen = fromEnd - fromStart;\n        const toStart = 1;\n        const toLen = to.length - toStart;\n        // Compare paths to find the longest common path from root\n        const length = fromLen < toLen ? fromLen : toLen;\n        let lastCommonSep = -1;\n        let i = 0;\n        for (; i < length; i++) {\n            const fromCode = from.charCodeAt(fromStart + i);\n            if (fromCode !== to.charCodeAt(toStart + i)) {\n                break;\n            }\n            else if (fromCode === CHAR_FORWARD_SLASH) {\n                lastCommonSep = i;\n            }\n        }\n        if (i === length) {\n            if (toLen > length) {\n                if (to.charCodeAt(toStart + i) === CHAR_FORWARD_SLASH) {\n                    // We get here if `from` is the exact base path for `to`.\n                    // For example: from='/foo/bar'; to='/foo/bar/baz'\n                    return to.slice(toStart + i + 1);\n                }\n                if (i === 0) {\n                    // We get here if `from` is the root\n                    // For example: from='/'; to='/foo'\n                    return to.slice(toStart + i);\n                }\n            }\n            else if (fromLen > length) {\n                if (from.charCodeAt(fromStart + i) === CHAR_FORWARD_SLASH) {\n                    // We get here if `to` is the exact base path for `from`.\n                    // For example: from='/foo/bar/baz'; to='/foo/bar'\n                    lastCommonSep = i;\n                }\n                else if (i === 0) {\n                    // We get here if `to` is the root.\n                    // For example: from='/foo/bar'; to='/'\n                    lastCommonSep = 0;\n                }\n            }\n        }\n        let out = '';\n        // Generate the relative path based on the path difference between `to`\n        // and `from`.\n        for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n            if (i === fromEnd || from.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n                out += out.length === 0 ? '..' : '/..';\n            }\n        }\n        // Lastly, append the rest of the destination (`to`) path that comes after\n        // the common path parts.\n        return `${out}${to.slice(toStart + lastCommonSep)}`;\n    },\n    toNamespacedPath(path) {\n        // Non-op on posix systems\n        return path;\n    },\n    dirname(path) {\n        validateString(path, 'path');\n        if (path.length === 0) {\n            return '.';\n        }\n        const hasRoot = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n        let end = -1;\n        let matchedSlash = true;\n        for (let i = path.length - 1; i >= 1; --i) {\n            if (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n                if (!matchedSlash) {\n                    end = i;\n                    break;\n                }\n            }\n            else {\n                // We saw the first non-path separator\n                matchedSlash = false;\n            }\n        }\n        if (end === -1) {\n            return hasRoot ? '/' : '.';\n        }\n        if (hasRoot && end === 1) {\n            return '//';\n        }\n        return path.slice(0, end);\n    },\n    basename(path, ext) {\n        if (ext !== undefined) {\n            validateString(ext, 'ext');\n        }\n        validateString(path, 'path');\n        let start = 0;\n        let end = -1;\n        let matchedSlash = true;\n        let i;\n        if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n            if (ext === path) {\n                return '';\n            }\n            let extIdx = ext.length - 1;\n            let firstNonSlashEnd = -1;\n            for (i = path.length - 1; i >= 0; --i) {\n                const code = path.charCodeAt(i);\n                if (code === CHAR_FORWARD_SLASH) {\n                    // If we reached a path separator that was not part of a set of path\n                    // separators at the end of the string, stop now\n                    if (!matchedSlash) {\n                        start = i + 1;\n                        break;\n                    }\n                }\n                else {\n                    if (firstNonSlashEnd === -1) {\n                        // We saw the first non-path separator, remember this index in case\n                        // we need it if the extension ends up not matching\n                        matchedSlash = false;\n                        firstNonSlashEnd = i + 1;\n                    }\n                    if (extIdx >= 0) {\n                        // Try to match the explicit extension\n                        if (code === ext.charCodeAt(extIdx)) {\n                            if (--extIdx === -1) {\n                                // We matched the extension, so mark this as the end of our path\n                                // component\n                                end = i;\n                            }\n                        }\n                        else {\n                            // Extension does not match, so our result is the entire path\n                            // component\n                            extIdx = -1;\n                            end = firstNonSlashEnd;\n                        }\n                    }\n                }\n            }\n            if (start === end) {\n                end = firstNonSlashEnd;\n            }\n            else if (end === -1) {\n                end = path.length;\n            }\n            return path.slice(start, end);\n        }\n        for (i = path.length - 1; i >= 0; --i) {\n            if (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n                // If we reached a path separator that was not part of a set of path\n                // separators at the end of the string, stop now\n                if (!matchedSlash) {\n                    start = i + 1;\n                    break;\n                }\n            }\n            else if (end === -1) {\n                // We saw the first non-path separator, mark this as the end of our\n                // path component\n                matchedSlash = false;\n                end = i + 1;\n            }\n        }\n        if (end === -1) {\n            return '';\n        }\n        return path.slice(start, end);\n    },\n    extname(path) {\n        validateString(path, 'path');\n        let startDot = -1;\n        let startPart = 0;\n        let end = -1;\n        let matchedSlash = true;\n        // Track the state of characters (if any) we see before our first dot and\n        // after any path separator we find\n        let preDotState = 0;\n        for (let i = path.length - 1; i >= 0; --i) {\n            const code = path.charCodeAt(i);\n            if (code === CHAR_FORWARD_SLASH) {\n                // If we reached a path separator that was not part of a set of path\n                // separators at the end of the string, stop now\n                if (!matchedSlash) {\n                    startPart = i + 1;\n                    break;\n                }\n                continue;\n            }\n            if (end === -1) {\n                // We saw the first non-path separator, mark this as the end of our\n                // extension\n                matchedSlash = false;\n                end = i + 1;\n            }\n            if (code === CHAR_DOT) {\n                // If this is our first dot, mark it as the start of our extension\n                if (startDot === -1) {\n                    startDot = i;\n                }\n                else if (preDotState !== 1) {\n                    preDotState = 1;\n                }\n            }\n            else if (startDot !== -1) {\n                // We saw a non-dot and non-path separator before our dot, so we should\n                // have a good chance at having a non-empty extension\n                preDotState = -1;\n            }\n        }\n        if (startDot === -1 ||\n            end === -1 ||\n            // We saw a non-dot character immediately before the dot\n            preDotState === 0 ||\n            // The (right-most) trimmed path component is exactly '..'\n            (preDotState === 1 && startDot === end - 1 && startDot === startPart + 1)) {\n            return '';\n        }\n        return path.slice(startDot, end);\n    },\n    format: _format.bind(null, '/'),\n    parse(path) {\n        validateString(path, 'path');\n        const ret = { root: '', dir: '', base: '', ext: '', name: '' };\n        if (path.length === 0) {\n            return ret;\n        }\n        const isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n        let start;\n        if (isAbsolute) {\n            ret.root = '/';\n            start = 1;\n        }\n        else {\n            start = 0;\n        }\n        let startDot = -1;\n        let startPart = 0;\n        let end = -1;\n        let matchedSlash = true;\n        let i = path.length - 1;\n        // Track the state of characters (if any) we see before our first dot and\n        // after any path separator we find\n        let preDotState = 0;\n        // Get non-dir info\n        for (; i >= start; --i) {\n            const code = path.charCodeAt(i);\n            if (code === CHAR_FORWARD_SLASH) {\n                // If we reached a path separator that was not part of a set of path\n                // separators at the end of the string, stop now\n                if (!matchedSlash) {\n                    startPart = i + 1;\n                    break;\n                }\n                continue;\n            }\n            if (end === -1) {\n                // We saw the first non-path separator, mark this as the end of our\n                // extension\n                matchedSlash = false;\n                end = i + 1;\n            }\n            if (code === CHAR_DOT) {\n                // If this is our first dot, mark it as the start of our extension\n                if (startDot === -1) {\n                    startDot = i;\n                }\n                else if (preDotState !== 1) {\n                    preDotState = 1;\n                }\n            }\n            else if (startDot !== -1) {\n                // We saw a non-dot and non-path separator before our dot, so we should\n                // have a good chance at having a non-empty extension\n                preDotState = -1;\n            }\n        }\n        if (end !== -1) {\n            const start = startPart === 0 && isAbsolute ? 1 : startPart;\n            if (startDot === -1 ||\n                // We saw a non-dot character immediately before the dot\n                preDotState === 0 ||\n                // The (right-most) trimmed path component is exactly '..'\n                (preDotState === 1 && startDot === end - 1 && startDot === startPart + 1)) {\n                ret.base = ret.name = path.slice(start, end);\n            }\n            else {\n                ret.name = path.slice(start, startDot);\n                ret.base = path.slice(start, end);\n                ret.ext = path.slice(startDot, end);\n            }\n        }\n        if (startPart > 0) {\n            ret.dir = path.slice(0, startPart - 1);\n        }\n        else if (isAbsolute) {\n            ret.dir = '/';\n        }\n        return ret;\n    },\n    sep: '/',\n    delimiter: ':',\n    win32: null,\n    posix: null,\n};\nconst normalize = posix.normalize;\nconst isAbsolute = posix.isAbsolute;\nconst join = posix.join;\nconst resolve = posix.resolve;\nconst relative = posix.relative;\nconst dirname = posix.dirname;\nconst basename = posix.basename;\nconst extname = posix.extname;\nconst format = posix.format;\nconst parse = posix.parse;\nconst toNamespacedPath = posix.toNamespacedPath;\nconst sep = posix.sep;\nconst delimiter = posix.delimiter;\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nconst _schemePattern = /^\\w[\\w\\d+.-]*$/;\nconst _singleSlashStart = /^\\//;\nconst _doubleSlashStart = /^\\/\\//;\nfunction _validateUri(ret, _strict) {\n    // scheme, must be set\n    if (!ret.scheme && _strict) {\n        throw new Error(`[UriError]: Scheme is missing: {scheme: \"\", authority: \"${ret.authority}\", path: \"${ret.path}\", query: \"${ret.query}\", fragment: \"${ret.fragment}\"}`);\n    }\n    // scheme, https://tools.ietf.org/html/rfc3986#section-3.1\n    // ALPHA *( ALPHA / DIGIT / \"+\" / \"-\" / \".\" )\n    if (ret.scheme && !_schemePattern.test(ret.scheme)) {\n        throw new Error('[UriError]: Scheme contains illegal characters.');\n    }\n    // path, http://tools.ietf.org/html/rfc3986#section-3.3\n    // If a URI contains an authority component, then the path component\n    // must either be empty or begin with a slash (\"/\") character.  If a URI\n    // does not contain an authority component, then the path cannot begin\n    // with two slash characters (\"//\").\n    if (ret.path) {\n        if (ret.authority) {\n            if (!_singleSlashStart.test(ret.path)) {\n                throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash (\"/\") character');\n            }\n        }\n        else {\n            if (_doubleSlashStart.test(ret.path)) {\n                throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters (\"//\")');\n            }\n        }\n    }\n}\n// for a while we allowed uris *without* schemes and this is the migration\n// for them, e.g. an uri without scheme and without strict-mode warns and falls\n// back to the file-scheme. that should cause the least carnage and still be a\n// clear warning\nfunction _schemeFix(scheme, _strict) {\n    if (!scheme && !_strict) {\n        return 'file';\n    }\n    return scheme;\n}\n// implements a bit of https://tools.ietf.org/html/rfc3986#section-5\nfunction _referenceResolution(scheme, path) {\n    // the slash-character is our 'default base' as we don't\n    // support constructing URIs relative to other URIs. This\n    // see https://tools.ietf.org/html/rfc3986#section-5.1.4\n    switch (scheme) {\n        case 'https':\n        case 'http':\n        case 'file':\n            if (!path) {\n                path = _slash;\n            }\n            else if (path[0] !== _slash) {\n                path = _slash + path;\n            }\n            break;\n    }\n    return path;\n}\nconst _empty = '';\nconst _slash = '/';\nconst _regexp = /^(([^:/?#]+?):)?(\\/\\/([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?/;\n/**\n * Uniform Resource Identifier (URI) http://tools.ietf.org/html/rfc3986.\n * This class is a simple parser which creates the basic component parts\n * (http://tools.ietf.org/html/rfc3986#section-3) with minimal validation\n * and encoding.\n *\n * ```txt\n *       foo://example.com:8042/over/there?name=ferret#nose\n *       \\_/   \\______________/\\_________/ \\_________/ \\__/\n *        |           |            |            |        |\n *     scheme     authority       path        query   fragment\n *        |   _____________________|__\n *       / \\ /                        \\\n *       urn:example:animal:ferret:nose\n * ```\n */\nclass Uri {\n    /**\n     * @internal\n     */\n    constructor(schemeOrData, authority, path, query, fragment, _strict = false) {\n        if (typeof schemeOrData === 'object') {\n            this.scheme = schemeOrData.scheme || _empty;\n            this.authority = schemeOrData.authority || _empty;\n            this.path = schemeOrData.path || _empty;\n            this.query = schemeOrData.query || _empty;\n            this.fragment = schemeOrData.fragment || _empty;\n            // no validation because it's this URI\n            // that creates uri components.\n            // _validateUri(this);\n        }\n        else {\n            this.scheme = _schemeFix(schemeOrData, _strict);\n            this.authority = authority || _empty;\n            this.path = _referenceResolution(this.scheme, path || _empty);\n            this.query = query || _empty;\n            this.fragment = fragment || _empty;\n            _validateUri(this, _strict);\n        }\n    }\n    static ensureTrailingSlash(uri, trailingSlash = '/') {\n        return uri.with({\n            path: uri.path.replace(TRAILING_SLASH_RX, trailingSlash),\n        });\n    }\n    static equals(l, r) {\n        return (l.authority === r.authority &&\n            l.fragment === r.fragment &&\n            l.path === r.path &&\n            l.query === r.query &&\n            l.scheme === r.scheme);\n    }\n    static getFirstPathSegmentAfterPrefix(child, parent) {\n        const childHref = child.path;\n        const parentHref = parent.path;\n        const parentOffset = parentHref.charAt(parentHref.length - 1) === '/' ? -1 : 0;\n        for (let i = 0; i <= childHref.length; i++) {\n            if (i < parentHref.length) {\n                if (childHref.charAt(i) !== parentHref.charAt(i)) {\n                    throw new Error(`The child entry ${child.toString()} does not have the pathname of ${parent.toString()} as a prefix`);\n                }\n            }\n            else if (i === parentHref.length + parentOffset) {\n                if (childHref.charAt(i) !== '/') {\n                    throw new Error(`The child entry ${child.toString()} does not have the pathname of ${parent.toString()} as a prefix`);\n                }\n            }\n            else if (childHref.charAt(i) === '/') {\n                return childHref.slice(parentHref.length + 1 + parentOffset, i);\n            }\n        }\n        return childHref.slice(parentHref.length + 1 + parentOffset);\n    }\n    static isPrefixOf(prefix, uri) {\n        return (prefix.authority === uri.authority &&\n            prefix.fragment === uri.fragment &&\n            prefix.query === uri.query &&\n            prefix.scheme === uri.scheme &&\n            uri.path.startsWith(prefix.path));\n    }\n    static isUri(thing) {\n        if (thing instanceof Uri) {\n            return true;\n        }\n        if (!thing) {\n            return false;\n        }\n        return (typeof thing.authority === 'string' &&\n            typeof thing.fragment === 'string' &&\n            typeof thing.path === 'string' &&\n            typeof thing.query === 'string' &&\n            typeof thing.scheme === 'string' &&\n            typeof thing.fsPath === 'function' &&\n            typeof thing.with === 'function' &&\n            typeof thing.toString === 'function');\n    }\n    // ---- filesystem path -----------------------\n    /**\n       * Returns a string representing the corresponding file system path of this URI.\n       * platform specific path separator.\n       *\n       * * Will *not* validate the path for invalid characters and semantics.\n       * * Will *not* look at the scheme of this URI.\n       * * The result shall *not* be used for display purposes but for accessing a file on disk.\n       *\n       *\n       * The *difference* to `URI#path` is the use of the platform specific separator and the handling\n       *\n       * ```ts\n          const u = URI.parse('file://server/c$/folder/file.txt')\n          u.authority === 'server'\n          u.path === '/shares/c$/file.txt'\n          u.fsPath === '\\\\server\\c$\\folder\\file.txt'\n      ```\n       *\n       * Using `URI#path` to read a file (using fs-apis) would not be enough because parts of the path,\n       * namely the server name, would be missing. Therefore `URI#fsPath` exists - it's sugar to ease working\n       * with URIs that represent files on disk (`file` scheme).\n       */\n    get fsPath() {\n        // if (this.scheme !== 'file') {\n        // \tconsole.warn(`[UriError] calling fsPath with scheme ${this.scheme}`);\n        // }\n        return uriToFsPath(this, false);\n    }\n    // ---- modify to new -------------------------\n    with(change) {\n        if (!change) {\n            return this;\n        }\n        let { scheme, authority, path, query, fragment } = change;\n        if (scheme === undefined) {\n            scheme = this.scheme;\n        }\n        else if (scheme === null) {\n            scheme = _empty;\n        }\n        if (authority === undefined) {\n            authority = this.authority;\n        }\n        else if (authority === null) {\n            authority = _empty;\n        }\n        if (path === undefined) {\n            path = this.path;\n        }\n        else if (path === null) {\n            path = _empty;\n        }\n        if (query === undefined) {\n            query = this.query;\n        }\n        else if (query === null) {\n            query = _empty;\n        }\n        if (fragment === undefined) {\n            fragment = this.fragment;\n        }\n        else if (fragment === null) {\n            fragment = _empty;\n        }\n        if (scheme === this.scheme &&\n            authority === this.authority &&\n            path === this.path &&\n            query === this.query &&\n            fragment === this.fragment) {\n            return this;\n        }\n        return new _URI(scheme, authority, path, query, fragment);\n    }\n    // ---- parse & validate ------------------------\n    /**\n     * Creates a new URI from a string, e.g. `http://www.msft.com/some/path`,\n     * `file:///usr/home`, or `scheme:with/path`.\n     *\n     * @param value A string which represents an URI (see `URI#toString`).\n     */\n    static parse(value, _strict = false) {\n        const match = _regexp.exec(value);\n        if (!match) {\n            return new _URI(_empty, _empty, _empty, _empty, _empty);\n        }\n        return new _URI(match[2] || _empty, percentDecode(match[4] || _empty), percentDecode(match[5] || _empty), percentDecode(match[7] || _empty), percentDecode(match[9] || _empty), _strict);\n    }\n    /**\n       * Creates a new URI from a file system path, e.g. `c:\\my\\files`,\n       * `/usr/home`, or `\\\\server\\share\\some\\path`.\n       *\n       * The *difference* between `URI#parse` and `URI#file` is that the latter treats the argument\n       * as path, not as stringified-uri. E.g. `URI.file(path)` is **not the same as**\n       * `URI.parse('file://' + path)` because the path might contain characters that are\n       * interpreted (# and ?). See the following sample:\n       * ```ts\n      const good = URI.file('/coding/c#/project1');\n      good.scheme === 'file';\n      good.path === '/coding/c#/project1';\n      good.fragment === '';\n      const bad = URI.parse('file://' + '/coding/c#/project1');\n      bad.scheme === 'file';\n      bad.path === '/coding/c'; // path is now broken\n      bad.fragment === '/project1';\n      ```\n       *\n       * @param path A file system path (see `URI#fsPath`)\n       */\n    static file(path) {\n        let authority = _empty;\n        // check for authority as used in UNC shares\n        // or use the path as given\n        if (path[0] === _slash && path[1] === _slash) {\n            const idx = path.indexOf(_slash, 2);\n            if (idx === -1) {\n                authority = path.substring(2);\n                path = _slash;\n            }\n            else {\n                authority = path.substring(2, idx);\n                path = path.substring(idx) || _slash;\n            }\n        }\n        return new _URI('file', authority, path, _empty, _empty);\n    }\n    static from(components) {\n        return new _URI(components.scheme, components.authority, components.path, components.query, components.fragment);\n    }\n    /**\n     * Join a URI path with path fragments and normalizes the resulting path.\n     *\n     * @param uri The input URI.\n     * @param pathFragment The path fragment to add to the URI path.\n     * @returns The resulting URI.\n     */\n    static joinPath(uri, ...pathFragment) {\n        if (!uri.path) {\n            throw new Error(`[UriError]: cannot call joinPaths on URI without path`);\n        }\n        const newPath = join(uri.path, ...pathFragment);\n        return uri.with({ path: newPath });\n    }\n    // ---- printing/externalize ---------------------------\n    /**\n     * Creates a string representation for this URI. It's guaranteed that calling\n     * `URI.parse` with the result of this function creates an URI which is equal\n     * to this URI.\n     *\n     * * The result shall *not* be used for display purposes but for externalization or transport.\n     * * The result will be encoded using the percentage encoding and encoding happens mostly\n     * ignore the scheme-specific encoding rules.\n     *\n     * @param skipEncoding Do not encode the result, default is `false`\n     */\n    toString(skipEncoding = true) {\n        return _asFormatted(this, skipEncoding);\n    }\n    toJSON() {\n        return this;\n    }\n    static revive(data) {\n        if (!data) {\n            return data;\n        }\n        else if (data instanceof Uri) {\n            return data;\n        }\n        else {\n            const result = new _URI(data);\n            result._formatted = data.external;\n            result._fsPath = data._sep === _pathSepMarker ? data.fsPath : null;\n            return result;\n        }\n    }\n}\nconst _pathSepMarker = undefined;\n// eslint-disable-next-line @typescript-eslint/naming-convention\nclass _URI extends Uri {\n    constructor() {\n        super(...arguments);\n        this._formatted = null;\n        this._fsPath = null;\n    }\n    get fsPath() {\n        if (!this._fsPath) {\n            this._fsPath = uriToFsPath(this, false);\n        }\n        return this._fsPath;\n    }\n    toString(skipEncoding = true) {\n        if (!skipEncoding) {\n            // we don't cache that\n            return _asFormatted(this, false);\n        }\n        else {\n            if (!this._formatted) {\n                this._formatted = _asFormatted(this, true);\n            }\n            return this._formatted;\n        }\n    }\n    toJSON() {\n        const res = {\n            $mid: 1,\n        };\n        // cached state\n        if (this._fsPath) {\n            res.fsPath = this._fsPath;\n            res._sep = _pathSepMarker;\n        }\n        if (this._formatted) {\n            res.external = this._formatted;\n        }\n        // uri components\n        if (this.path) {\n            res.path = this.path;\n        }\n        if (this.scheme) {\n            res.scheme = this.scheme;\n        }\n        if (this.authority) {\n            res.authority = this.authority;\n        }\n        if (this.query) {\n            res.query = this.query;\n        }\n        if (this.fragment) {\n            res.fragment = this.fragment;\n        }\n        return res;\n    }\n}\n// reserved characters: https://tools.ietf.org/html/rfc3986#section-2.2\nconst encodeTable = {\n    [58 /* Colon */]: '%3A',\n    [47 /* Slash */]: '%2F',\n    [63 /* QuestionMark */]: '%3F',\n    [35 /* Hash */]: '%23',\n    [91 /* OpenSquareBracket */]: '%5B',\n    [93 /* CloseSquareBracket */]: '%5D',\n    [64 /* AtSign */]: '%40',\n    [33 /* ExclamationMark */]: '%21',\n    [36 /* DollarSign */]: '%24',\n    [38 /* Ampersand */]: '%26',\n    [39 /* SingleQuote */]: '%27',\n    [40 /* OpenParen */]: '%28',\n    [41 /* CloseParen */]: '%29',\n    [42 /* Asterisk */]: '%2A',\n    [43 /* Plus */]: '%2B',\n    [44 /* Comma */]: '%2C',\n    [59 /* Semicolon */]: '%3B',\n    [61 /* Equals */]: '%3D',\n    [32 /* Space */]: '%20',\n};\nfunction encodeURIComponentFast(uriComponent, allowSlash) {\n    let res = undefined;\n    let nativeEncodePos = -1;\n    for (let pos = 0; pos < uriComponent.length; pos++) {\n        const code = uriComponent.charCodeAt(pos);\n        // unreserved characters: https://tools.ietf.org/html/rfc3986#section-2.3\n        if ((code >= 97 /* a */ && code <= 122 /* z */) ||\n            (code >= 65 /* A */ && code <= 90 /* Z */) ||\n            (code >= 48 /* Digit0 */ && code <= 57 /* Digit9 */) ||\n            code === 45 /* Dash */ ||\n            code === 46 /* Period */ ||\n            code === 95 /* Underline */ ||\n            code === 126 /* Tilde */ ||\n            (allowSlash && code === 47 /* Slash */)) {\n            // check if we are delaying native encode\n            if (nativeEncodePos !== -1) {\n                res += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));\n                nativeEncodePos = -1;\n            }\n            // check if we write into a new string (by default we try to return the param)\n            if (res !== undefined) {\n                res += uriComponent.charAt(pos);\n            }\n        }\n        else {\n            // encoding needed, we need to allocate a new string\n            if (res === undefined) {\n                res = uriComponent.substr(0, pos);\n            }\n            // check with default table first\n            const escaped = encodeTable[code];\n            if (escaped !== undefined) {\n                // check if we are delaying native encode\n                if (nativeEncodePos !== -1) {\n                    res += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));\n                    nativeEncodePos = -1;\n                }\n                // append escaped variant to result\n                res += escaped;\n            }\n            else if (nativeEncodePos === -1) {\n                // use native encode only when needed\n                nativeEncodePos = pos;\n            }\n        }\n    }\n    if (nativeEncodePos !== -1) {\n        res += encodeURIComponent(uriComponent.substring(nativeEncodePos));\n    }\n    return res !== undefined ? res : uriComponent;\n}\nfunction encodeURIComponentMinimal(path) {\n    let res = undefined;\n    for (let pos = 0; pos < path.length; pos++) {\n        const code = path.charCodeAt(pos);\n        if (code === 35 /* Hash */ || code === 63 /* QuestionMark */) {\n            if (res === undefined) {\n                res = path.substr(0, pos);\n            }\n            res += encodeTable[code];\n        }\n        else {\n            if (res !== undefined) {\n                res += path[pos];\n            }\n        }\n    }\n    return res !== undefined ? res : path;\n}\n/**\n * Compute `fsPath` for the given uri\n */\nfunction uriToFsPath(uri, keepDriveLetterCasing) {\n    let value;\n    if (uri.authority && uri.path.length > 1 && uri.scheme === 'file') {\n        // unc path: file://shares/c$/far/boo\n        value = `//${uri.authority}${uri.path}`;\n    }\n    else if (uri.path.charCodeAt(0) === 47 /* Slash */ &&\n        ((uri.path.charCodeAt(1) >= 65 /* A */ && uri.path.charCodeAt(1) <= 90 /* Z */) ||\n            (uri.path.charCodeAt(1) >= 97 /* a */ && uri.path.charCodeAt(1) <= 122 /* z */)) &&\n        uri.path.charCodeAt(2) === 58 /* Colon */) {\n        if (!keepDriveLetterCasing) {\n            // windows drive letter: file:///c:/far/boo\n            value = uri.path[1].toLowerCase() + uri.path.substr(2);\n        }\n        else {\n            value = uri.path.substr(1);\n        }\n    }\n    else {\n        // other path\n        value = uri.path;\n    }\n    return value;\n}\n/**\n * Create the external version of a uri\n */\nfunction _asFormatted(uri, skipEncoding) {\n    const encoder = !skipEncoding ? encodeURIComponentFast : encodeURIComponentMinimal;\n    let res = '';\n    let { scheme, authority, path, query, fragment } = uri;\n    if (scheme) {\n        res += scheme;\n        res += ':';\n    }\n    if (authority || scheme === 'file') {\n        res += _slash;\n        res += _slash;\n    }\n    if (authority) {\n        let idx = authority.indexOf('@');\n        if (idx !== -1) {\n            // <user>@<auth>\n            const userinfo = authority.substr(0, idx);\n            authority = authority.substr(idx + 1);\n            idx = userinfo.indexOf(':');\n            if (idx === -1) {\n                res += encoder(userinfo, false);\n            }\n            else {\n                // <user>:<pass>@<auth>\n                res += encoder(userinfo.substr(0, idx), false);\n                res += ':';\n                res += encoder(userinfo.substr(idx + 1), false);\n            }\n            res += '@';\n        }\n        authority = authority.toLowerCase();\n        idx = authority.indexOf(':');\n        if (idx === -1) {\n            res += encoder(authority, false);\n        }\n        else {\n            // <auth>:<port>\n            res += encoder(authority.substr(0, idx), false);\n            res += authority.substr(idx);\n        }\n    }\n    if (path) {\n        // lower-case windows drive letters in /C:/fff or C:/fff\n        if (path.length >= 3 &&\n            path.charCodeAt(0) === 47 /* Slash */ &&\n            path.charCodeAt(2) === 58 /* Colon */) {\n            const code = path.charCodeAt(1);\n            if (code >= 65 /* A */ && code <= 90 /* Z */) {\n                path = `/${String.fromCharCode(code + 32)}:${path.substr(3)}`; // \"/c:\".length === 3\n            }\n        }\n        else if (path.length >= 2 && path.charCodeAt(1) === 58 /* Colon */) {\n            const code = path.charCodeAt(0);\n            if (code >= 65 /* A */ && code <= 90 /* Z */) {\n                path = `${String.fromCharCode(code + 32)}:${path.substr(2)}`; // \"/c:\".length === 3\n            }\n        }\n        // encode the rest of the path\n        res += encoder(path, true);\n    }\n    if (query) {\n        res += '?';\n        res += encoder(query, false);\n    }\n    if (fragment) {\n        res += '#';\n        res += !skipEncoding ? encodeURIComponentFast(fragment, false) : fragment;\n    }\n    return res;\n}\n// --- decode\nfunction decodeURIComponentGraceful(str) {\n    try {\n        return decodeURIComponent(str);\n    }\n    catch (_a) {\n        if (str.length > 3) {\n            return str.substr(0, 3) + decodeURIComponentGraceful(str.substr(3));\n        }\n        else {\n            return str;\n        }\n    }\n}\nconst _rEncodedAsHex = /(%[0-9A-Za-z][0-9A-Za-z])+/g;\nfunction percentDecode(str) {\n    if (!str.match(_rEncodedAsHex)) {\n        return str;\n    }\n    return str.replace(_rEncodedAsHex, (match) => decodeURIComponentGraceful(match));\n}\nconst TRAILING_SLASH_RX = /\\/?$/;\n\nconst version = '0.45.1';\n\nexport { AmbiguousModuleError, Base64, CanceledError, Decoder, DependencyNotFoundError, EntryExcludedError, EntryNotFoundError, MapSet, NotResolvableError, ParseError, Uri, all, basename, checkCancellation, delimiter, dirname, extname, format, isAbsolute, isCanceledError, isThenable, isValidPackageJson, isValidPartialPackageJson, join, normalize, parse, parseBufferAsPackageJson, parseBufferAsPartialPackageJson, posix, relative, resolve, sep, toNamespacedPath, uriToFsPath, version };\n//# sourceMappingURL=index.js.map\n","import { Uri } from '@velcro/common';\nimport { AbstractResolverStrategyWithRoot, ResolverStrategy } from '@velcro/resolver';\n\nvar FileEncoding;\n(function (FileEncoding) {\n    FileEncoding[\"Base64\"] = \"base64\";\n    FileEncoding[\"UTF8\"] = \"utf-8\";\n})(FileEncoding || (FileEncoding = {}));\nconst encodeText = typeof TextEncoder === 'function'\n    ? (function () {\n        const encoder = new TextEncoder();\n        return function encodeText(data) {\n            return encoder.encode(data).buffer;\n        };\n    })()\n    : typeof Buffer === 'function'\n        ? function encodeText(data) {\n            return Buffer.from(data);\n        }\n        : function encodeText(_data) {\n            throw new Error('The environment provides neither TextEncoder nor Buffer. Please consider polyfilling one of these APIs.');\n        };\nclass MemoryStrategy extends AbstractResolverStrategyWithRoot {\n    constructor(files, rootUri = Uri.parse('memory:/')) {\n        super(Uri.ensureTrailingSlash(rootUri));\n        this.root = {\n            type: ResolverStrategy.EntryKind.Directory,\n            children: {},\n        };\n        for (const pathname in files) {\n            const file = files[pathname];\n            if (typeof file === 'string') {\n                this.addFile(pathname, file);\n            }\n            else {\n                this.addFile(pathname, file.content, { encoding: file.encoding });\n            }\n        }\n    }\n    getEntryAtPath(pathname) {\n        const segments = Array.isArray(pathname)\n            ? pathname.slice()\n            : pathname.split('/').filter(Boolean);\n        let parent = this.root;\n        for (const segment of segments) {\n            if (!parent || parent.type !== ResolverStrategy.EntryKind.Directory) {\n                throw new Error(`Failed to add ${pathname}`);\n            }\n            parent = parent.children[segment];\n        }\n        return parent;\n    }\n    addFile(pathname, content, { encoding = FileEncoding.UTF8, overwrite = false, } = {}) {\n        const segments = pathname.split('/').filter(Boolean);\n        const filename = segments.pop();\n        if (!filename) {\n            throw new Error(`Unable to add a file without a filename '${pathname}'`);\n        }\n        let parent = this.root;\n        for (const segment of segments) {\n            if (!parent || parent.type !== ResolverStrategy.EntryKind.Directory) {\n                throw new Error(`Failed to add ${pathname}`);\n            }\n            let dir = parent.children[segment];\n            if (!dir) {\n                dir = {\n                    type: ResolverStrategy.EntryKind.Directory,\n                    children: {},\n                };\n                parent.children[segment] = dir;\n            }\n            parent = dir;\n        }\n        if (parent.type !== ResolverStrategy.EntryKind.Directory) {\n            throw new Error(`Cannot add file to a non directory entry ${pathname}`);\n        }\n        if (parent.children[filename] && !overwrite) {\n            throw new Error(`Entry already exists at ${pathname}`);\n        }\n        const entry = {\n            type: ResolverStrategy.EntryKind.File,\n            content,\n            encoding,\n        };\n        parent.children[filename] = entry;\n        return entry;\n    }\n    removeFile(pathname) {\n        const segments = pathname.split('/').filter(Boolean);\n        const filename = segments.pop();\n        if (!filename) {\n            return false;\n        }\n        let parent = this.root;\n        for (const segment of segments) {\n            if (!parent || parent.type !== ResolverStrategy.EntryKind.Directory) {\n                return false;\n            }\n            parent = parent.children[segment];\n        }\n        if (!parent || parent.type !== ResolverStrategy.EntryKind.Directory) {\n            return false;\n        }\n        return delete parent.children[filename];\n    }\n    getResolveRoot() {\n        return {\n            uri: this.rootUri,\n        };\n    }\n    listEntries(_ctx, uri) {\n        const urlPathname = Uri.ensureTrailingSlash(uri).fsPath;\n        const basePathname = this.rootUri.fsPath;\n        const fsPathname = urlPathname.startsWith(basePathname)\n            ? urlPathname.slice(basePathname.length - 1)\n            : urlPathname;\n        const parent = this.getEntryAtPath(fsPathname);\n        if (!parent) {\n            throw new Error(`No such directory ${uri.toString()}`);\n        }\n        if (parent.type !== ResolverStrategy.EntryKind.Directory) {\n            throw new Error(`Cannot list entries under a file at ${uri.toString()}`);\n        }\n        const entries = Object.keys(parent.children).map((filename) => {\n            const entry = parent.children[filename];\n            return {\n                uri: Uri.joinPath(this.rootUri, fsPathname, filename),\n                type: entry.type,\n            };\n        });\n        return {\n            entries,\n        };\n    }\n    readFileContent(_ctx, uri) {\n        const urlPathname = Uri.ensureTrailingSlash(uri).fsPath;\n        const basePathname = this.rootUri.fsPath;\n        const fsPathname = urlPathname.startsWith(basePathname)\n            ? urlPathname.slice(basePathname.length - 1)\n            : urlPathname;\n        const entry = this.getEntryAtPath(fsPathname);\n        if (!entry) {\n            throw new Error(`No such file ${uri.toString()}`);\n        }\n        if (entry.type !== 'file') {\n            throw new Error(`Cannot read content of a non-file at ${uri.toString()}`);\n        }\n        switch (entry.encoding) {\n            case FileEncoding.Base64: {\n                const binSting = atob(entry.content);\n                const binArray = new Uint8Array(binSting.length);\n                Array.prototype.forEach.call(binArray, function (_el, idx, arr) {\n                    arr[idx] = binSting.charCodeAt(idx);\n                });\n                return {\n                    content: binArray.buffer,\n                };\n            }\n            case FileEncoding.UTF8: {\n                return {\n                    content: encodeText(entry.content),\n                };\n            }\n            default:\n                throw new Error(`Unsupported encoding for ${uri.toString()}: ${entry.encoding}`);\n        }\n    }\n    uriForPath(pathname) {\n        return Uri.joinPath(this.rootUri, pathname);\n    }\n}\n\nconst version = '0.45.1';\n\nexport { MemoryStrategy, version };\n//# sourceMappingURL=index.js.map\n","import { DisposableStore, Emitter, IDisposable } from '@velcro/common';\nimport * as Monaco from 'monaco-editor';\nimport { createContext, useContext, useEffect, useState } from 'react';\n\nexport class EditorManager implements IDisposable {\n  editor: Monaco.editor.IStandaloneCodeEditor | null = null;\n\n  private readonly disposableStore = new DisposableStore();\n  private readonly initialPath: string | undefined;\n  private readonly viewState = new WeakMap<\n    Monaco.editor.ITextModel,\n    Monaco.editor.ICodeEditorViewState\n  >();\n\n  private readonly onWillFocusModelEmitter = new Emitter<Monaco.editor.ITextModel>();\n  private readonly onDidChangeEmitter = new Emitter<{ model: Monaco.editor.ITextModel }>();\n\n  constructor(options: { files?: Record<string, string>; initialPath?: string } = {}) {\n    this.disposableStore.add(this.onWillFocusModelEmitter);\n    this.disposableStore.add(this.onDidChangeEmitter);\n\n    Monaco.languages.typescript.typescriptDefaults.setEagerModelSync(true);\n    Monaco.languages.typescript.typescriptDefaults.setMaximumWorkerIdleTime(-1);\n    Monaco.languages.typescript.typescriptDefaults.setCompilerOptions({\n      allowJs: true,\n      allowNonTsExtensions: true,\n      allowSyntheticDefaultImports: true,\n      baseUrl: '.',\n      checkJs: true,\n      esModuleInterop: true,\n      experimentalDecorators: true,\n      inlineSourceMap: true,\n      inlineSources: true,\n      isolatedModules: false,\n      jsx: Monaco.languages.typescript.JsxEmit.React,\n      lib: ['dom'],\n      module: Monaco.languages.typescript.ModuleKind.CommonJS,\n      moduleResolution: Monaco.languages.typescript.ModuleResolutionKind.NodeJs,\n      noEmit: false,\n      outDir: `dist`,\n      resolveJsonModule: true,\n      rootDir: '/',\n      sourceMap: true,\n      target: Monaco.languages.typescript.ScriptTarget.ES2015,\n      typeRoots: ['node_modules/@types'],\n    });\n    Monaco.languages.typescript.typescriptDefaults.setDiagnosticsOptions({\n      noSemanticValidation: true,\n      noSyntaxValidation: false,\n    });\n\n    if (options.files) {\n      for (const pathname in options.files) {\n        const content = options.files[pathname];\n\n        this.createModel(pathname, content);\n      }\n    }\n\n    this.initialPath = options.initialPath;\n  }\n\n  get dispose() {\n    return this.disposableStore.dispose;\n  }\n\n  get onDidChange() {\n    return this.onDidChangeEmitter.event;\n  }\n\n  get onWillFocusModel() {\n    return this.onWillFocusModelEmitter.event;\n  }\n\n  createModel(pathname: string, content = '') {\n    const language = this.inferLanguage(pathname);\n\n    let uri: Monaco.Uri;\n\n    try {\n      uri = Monaco.Uri.file(pathname);\n    } catch (err) {\n      throw new Error(`Invalid path '${pathname}': ${err && err.message}`);\n    }\n\n    if (Monaco.editor.getModel(uri)) {\n      throw new Error(`Cannot create file because it exists '${pathname}'`);\n    }\n\n    return Monaco.editor.createModel(content, language, uri);\n  }\n\n  focusHref(\n    href: string,\n    options: {\n      lineNumber?: number;\n      columnNumber?: number;\n      markers?: Monaco.editor.IMarkerData[];\n    } = {}\n  ) {\n    const model = this.getModelByHref(href);\n\n    if (model) {\n      this.focusModel(model, options);\n    }\n  }\n\n  focusModel(\n    model: Monaco.editor.ITextModel,\n    options: {\n      lineNumber?: number;\n      columnNumber?: number;\n      markers?: Monaco.editor.IMarkerData[];\n    } = {}\n  ) {\n    if (this.editor) {\n      this.editor.setModel(model);\n      if (options.lineNumber) {\n        this.editor.revealLineInCenter(options.lineNumber, Monaco.editor.ScrollType.Smooth);\n        this.editor.setPosition({\n          column: options.columnNumber || 0,\n          lineNumber: options.lineNumber,\n        });\n      }\n      if (options.markers) {\n        Monaco.editor.setModelMarkers(model, 'editorManager', options.markers);\n      }\n      this.editor.focus();\n    }\n  }\n\n  focusPath(\n    path: string,\n    options: {\n      lineNumber?: number;\n      columnNumber?: number;\n      markers?: Monaco.editor.IMarkerData[];\n    } = {}\n  ) {\n    const model = this.getModelByPath(path);\n\n    if (model) {\n      this.focusModel(model, options);\n    }\n  }\n\n  getModelByHref(href: string) {\n    try {\n      const uri = Monaco.Uri.parse(href);\n      return Monaco.editor.getModel(uri);\n    } catch (_) {\n      return null;\n    }\n  }\n\n  getModelByPath(path: string) {\n    return Monaco.editor.getModel(Monaco.Uri.file(path));\n  }\n\n  mount(el: HTMLElement) {\n    if (this.editor) {\n      throw new Error('Invariant violation: Editor already mounted');\n    }\n\n    this.editor = Monaco.editor.create(el, {\n      model: null,\n      automaticLayout: true,\n      minimap: {\n        enabled: false,\n      },\n      showUnused: true,\n      scrollBeyondLastLine: false,\n      theme: 'vs',\n      wordWrap: 'bounded',\n      wrappingIndent: 'same',\n    });\n\n    this.editor.onDidDispose(() => {\n      this.editor = null;\n    });\n\n    this.editor.onDidChangeModel((e) => {\n      if (e.newModelUrl && this.editor) {\n        const model = Monaco.editor.getModel(e.newModelUrl)!;\n        const viewState = this.viewState.get(model);\n\n        if (viewState) {\n          this.editor.restoreViewState(viewState);\n        }\n      }\n    });\n\n    this.editor.onDidBlurEditorText(() => {\n      if (this.editor) {\n        const model = this.editor.getModel();\n        const viewState = this.editor.saveViewState();\n\n        if (model && viewState) {\n          this.viewState.set(model, viewState);\n        }\n      }\n    });\n\n    this.disposableStore.add(this.editor);\n\n    if (this.initialPath) {\n      this.focusPath(this.initialPath);\n    }\n\n    return this.editor;\n  }\n\n  inferLanguage(pathname: string) {\n    return pathname.match(/\\.(?:tsx?|jsx?)$/) ? 'typescript' : undefined;\n  }\n}\n\nexport const EditorManagerContext = createContext<EditorManager>(undefined as any);\n\nexport function useActiveModel() {\n  const workbench = useContext(EditorManagerContext);\n  const [activeModel, setActiveModel] = useState<Monaco.editor.ITextModel | null>(\n    workbench.editor ? workbench.editor.getModel() : null\n  );\n\n  useEffect(() => {\n    const disposable = new DisposableStore();\n\n    const trackEditor = (editor: Monaco.editor.ICodeEditor) => {\n      editor.onDidChangeModel((e) => {\n        const model = e.newModelUrl ? Monaco.editor.getModel(e.newModelUrl) : null;\n\n        setActiveModel(model);\n      });\n\n      disposable.add(\n        editor.onDidBlurEditorText(() => {\n          setActiveModel(null);\n        })\n      );\n\n      disposable.add(\n        editor.onDidFocusEditorText(() => {\n          setActiveModel(editor.getModel());\n        })\n      );\n\n      if (editor.hasTextFocus()) {\n        setActiveModel(editor.getModel());\n      }\n    };\n\n    disposable.add(Monaco.editor.onDidCreateEditor(trackEditor));\n    if (workbench.editor) {\n      trackEditor(workbench.editor);\n    }\n\n    return () => disposable.dispose();\n  }, [workbench.editor, activeModel]);\n\n  return activeModel;\n}\n","import { Base64, Uri, isThenable, checkCancellation, DependencyNotFoundError, EntryExcludedError, EntryNotFoundError, MapSet, DisposableStore, Emitter, CancellationTokenSource, isCanceledError } from '@velcro/common';\nimport MagicString, { Bundle } from 'magic-string';\nimport { parse as parse$2 } from 'acorn';\n\nclass BaseError extends Error {\n    constructor() {\n        super(...arguments);\n        this.name = this.constructor.name;\n    }\n}\nclass GraphBuildError extends BaseError {\n    constructor(errors) {\n        super(`Graph building failed with errors:\\n${errors.map((err) => `  ${err.message}`).join('\\n')}`);\n        this.errors = errors;\n    }\n}\n\nvar charToInteger = {};\nvar chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\nfor (var i = 0; i < chars.length; i++) {\n    charToInteger[chars.charCodeAt(i)] = i;\n}\nfunction decode(mappings) {\n    var decoded = [];\n    var line = [];\n    var segment = [\n        0,\n        0,\n        0,\n        0,\n        0,\n    ];\n    var j = 0;\n    for (var i = 0, shift = 0, value = 0; i < mappings.length; i++) {\n        var c = mappings.charCodeAt(i);\n        if (c === 44) { // \",\"\n            segmentify(line, segment, j);\n            j = 0;\n        }\n        else if (c === 59) { // \";\"\n            segmentify(line, segment, j);\n            j = 0;\n            decoded.push(line);\n            line = [];\n            segment[0] = 0;\n        }\n        else {\n            var integer = charToInteger[c];\n            if (integer === undefined) {\n                throw new Error('Invalid character (' + String.fromCharCode(c) + ')');\n            }\n            var hasContinuationBit = integer & 32;\n            integer &= 31;\n            value += integer << shift;\n            if (hasContinuationBit) {\n                shift += 5;\n            }\n            else {\n                var shouldNegate = value & 1;\n                value >>>= 1;\n                if (shouldNegate) {\n                    value = value === 0 ? -0x80000000 : -value;\n                }\n                segment[j] += value;\n                j++;\n                value = shift = 0; // reset\n            }\n        }\n    }\n    segmentify(line, segment, j);\n    decoded.push(line);\n    return decoded;\n}\nfunction segmentify(line, segment, j) {\n    // This looks ugly, but we're creating specialized arrays with a specific\n    // length. This is much faster than creating a new array (which v8 expands to\n    // a capacity of 17 after pushing the first item), or slicing out a subarray\n    // (which is slow). Length 4 is assumed to be the most frequent, followed by\n    // length 5 (since not everything will have an associated name), followed by\n    // length 1 (it's probably rare for a source substring to not have an\n    // associated segment data).\n    if (j === 4)\n        line.push([segment[0], segment[1], segment[2], segment[3]]);\n    else if (j === 5)\n        line.push([segment[0], segment[1], segment[2], segment[3], segment[4]]);\n    else if (j === 1)\n        line.push([segment[0]]);\n}\nfunction encode(decoded) {\n    var sourceFileIndex = 0; // second field\n    var sourceCodeLine = 0; // third field\n    var sourceCodeColumn = 0; // fourth field\n    var nameIndex = 0; // fifth field\n    var mappings = '';\n    for (var i = 0; i < decoded.length; i++) {\n        var line = decoded[i];\n        if (i > 0)\n            mappings += ';';\n        if (line.length === 0)\n            continue;\n        var generatedCodeColumn = 0; // first field\n        var lineMappings = [];\n        for (var _i = 0, line_1 = line; _i < line_1.length; _i++) {\n            var segment = line_1[_i];\n            var segmentMappings = encodeInteger(segment[0] - generatedCodeColumn);\n            generatedCodeColumn = segment[0];\n            if (segment.length > 1) {\n                segmentMappings +=\n                    encodeInteger(segment[1] - sourceFileIndex) +\n                        encodeInteger(segment[2] - sourceCodeLine) +\n                        encodeInteger(segment[3] - sourceCodeColumn);\n                sourceFileIndex = segment[1];\n                sourceCodeLine = segment[2];\n                sourceCodeColumn = segment[3];\n            }\n            if (segment.length === 5) {\n                segmentMappings += encodeInteger(segment[4] - nameIndex);\n                nameIndex = segment[4];\n            }\n            lineMappings.push(segmentMappings);\n        }\n        mappings += lineMappings.join(',');\n    }\n    return mappings;\n}\nfunction encodeInteger(num) {\n    var result = '';\n    num = num < 0 ? (-num << 1) | 1 : num << 1;\n    do {\n        var clamped = num & 31;\n        num >>>= 5;\n        if (num > 0) {\n            clamped |= 32;\n        }\n        result += chars[clamped];\n    } while (num > 0);\n    return result;\n}\n\nclass SourceMap {\n    constructor(input) {\n        this.file = input.file;\n        this.mappings = input.mappings;\n        this.sourceRoot = input.sourceRoot;\n        this.names = input.names;\n        this.sources = input.sources;\n        this.sourcesContent = input.sourcesContent;\n        this.version = input.version;\n    }\n    toString() {\n        return JSON.stringify(this);\n    }\n    toDataUri() {\n        return `data:application/json;charset=utf-8;base64,${Base64.encode(this.toString())}`;\n    }\n}\nfunction getSourceMappingUrlMatch(str) {\n    const re = /(?:(?:\\/\\/|\\/\\*)[@#][\\s]*(?:source)MappingURL=([^\\s'\"]+)[\\s]*$)|(?:\\/\\*[@#][\\s]*(?:source)MappingURL=([^\\s*'\"]+)[\\s]*(?:\\*\\/)[\\s]*$)/gm;\n    // Keep executing the search to find the *last* sourceMappingURL to avoid\n    // picking up sourceMappingURLs from comments, strings, etc.\n    let lastMatch = null;\n    let match;\n    while ((match = re.exec(str)))\n        lastMatch = match;\n    return lastMatch;\n}\nfunction getSourceMappingUrl(str) {\n    const lastMatch = getSourceMappingUrlMatch(str);\n    if (!lastMatch)\n        return '';\n    return lastMatch[1];\n}\nfunction updateSourceMappingUrl(str, url) {\n    const lastMatch = getSourceMappingUrlMatch(str);\n    if (!lastMatch)\n        return str;\n    return str.slice(0, lastMatch.index) + str.slice(lastMatch.index).replace(lastMatch[1], url);\n}\nfunction decodeDataUriAsSourceMap(href) {\n    const match = href.match(/^data:application\\/json;(?:charset=([^;]+);)?base64,(.*)$/);\n    if (match) {\n        if (match[1] && match[1] !== 'utf-8') {\n            return null;\n        }\n        try {\n            const decoded = JSON.parse(Base64.decode(match[2]));\n            if (decoded.mappings === '') {\n                return {\n                    file: '',\n                    mappings: [],\n                    names: [],\n                    sources: [],\n                    sourcesContent: [],\n                };\n            }\n            if (typeof decoded.mappings === 'string') {\n                decoded.mappings = decode(decoded.mappings);\n            }\n            return decoded;\n        }\n        catch (err) {\n            return null;\n        }\n    }\n    return null;\n}\n\n/**\n * Copyright (c) Rollup 2020 authors: https://github.com/rollup/rollup/graphs/contributors)\n *\n * Copied with light modifications from:\n * https://github.com/rollup/rollup/blob/36a4527473ea1fe678ed866c9f8dfd3c2542cd22/src/utils/collapseSourcemaps.ts\n */\nclass Source {\n    constructor(filename, content) {\n        this.filename = filename;\n        this.content = content;\n    }\n    traceSegment(line, column, name) {\n        return { line, column, name, source: this };\n    }\n}\nclass Link {\n    constructor(map, sources) {\n        this.sources = sources;\n        this.names = map.names;\n        this.mappings = typeof map.mappings === 'string' ? decode(map.mappings) : map.mappings;\n    }\n    traceMappings() {\n        const sources = [];\n        const sourcesContent = [];\n        const names = [];\n        const mappings = [];\n        for (const line of this.mappings) {\n            const tracedLine = [];\n            for (const segment of line) {\n                if (segment.length == 1)\n                    continue;\n                const source = this.sources[segment[1]];\n                if (!source)\n                    continue;\n                const traced = source.traceSegment(segment[2], segment[3], segment.length === 5 ? this.names[segment[4]] : '');\n                if (traced) {\n                    // newer sources are more likely to be used, so search backwards.\n                    let sourceIndex = sources.lastIndexOf(traced.source.filename);\n                    if (sourceIndex === -1) {\n                        sourceIndex = sources.length;\n                        sources.push(traced.source.filename);\n                        sourcesContent[sourceIndex] = traced.source.content;\n                    }\n                    else if (sourcesContent[sourceIndex] == null) {\n                        sourcesContent[sourceIndex] = traced.source.content;\n                    }\n                    else if (traced.source.content != null &&\n                        sourcesContent[sourceIndex] !== traced.source.content) {\n                        return new Error(`Multiple conflicting contents for sourcemap source ${traced.source.filename}`);\n                    }\n                    const tracedSegment = [\n                        segment[0],\n                        sourceIndex,\n                        traced.line,\n                        traced.column,\n                    ];\n                    if (traced.name) {\n                        let nameIndex = names.indexOf(traced.name);\n                        if (nameIndex === -1) {\n                            nameIndex = names.length;\n                            names.push(traced.name);\n                        }\n                        tracedSegment[4] = nameIndex;\n                    }\n                    tracedLine.push(tracedSegment);\n                }\n            }\n            mappings.push(tracedLine);\n        }\n        return { sources, sourcesContent, names, mappings };\n    }\n    traceSegment(line, column, name) {\n        const segments = this.mappings[line];\n        if (!segments)\n            return null;\n        // binary search through segments for the given column\n        let i = 0;\n        let j = segments.length - 1;\n        while (i <= j) {\n            const m = (i + j) >> 1;\n            const segment = segments[m];\n            if (segment[0] === column) {\n                if (segment.length == 1)\n                    return null;\n                const source = this.sources[segment[1]];\n                if (!source)\n                    return null;\n                return source.traceSegment(segment[2], segment[3], segment.length === 5 ? this.names[segment[4]] : name);\n            }\n            if (segment[0] > column) {\n                j = m - 1;\n            }\n            else {\n                i = m + 1;\n            }\n        }\n        return null;\n    }\n}\n/**\n * This function attempts to compensate for the loss of precision when lower\n * layers of source maps have higher precision than upper layers, leading to\n * a loss of fidelity.\n *\n * The code was lifted from [Alec Larson](https://github.com/aleclarson)'s\n * [fork of sorcery](https://github.com/aleclarson/sorcery/blob/3934a3f38a6d8604fc9dbaa576cbb6e4d733040f/src/blend.js).\n *\n * NOTE: This function mutates the given node.\n *\n * @copyright [Alec Larson](https://github.com/aleclarson) 2018\n */\n// function blend(node: Link) {\n//   let mappings: SourceMapSegment[][] = []; // traced lines\n//   let sources: (Link | Source)[] = []; // traced sources\n//   let names: string[] = []; // traced symbols\n//   // Precompute which source/line/column triples are mapped by the given node.\n//   // These references are useful when interweaving old segments.\n//   const refs: number[][][] = Object.keys(node.sources).map(() => []);\n//   for (const segments of node.mappings) {\n//     let segment: SourceMapSegment;\n//     let lines: number[][];\n//     let columns: number[];\n//     for (let i = 0; i < segments.length; i++) {\n//       segment = segments[i];\n//       if (segment.length === 4 || segment.length === 5) {\n//         lines = refs[segment[1]];\n//         if (!lines) refs[segment[1]] = lines = [];\n//         columns = lines[segment[2]];\n//         if (columns) {\n//           uniqueAscendingInsert(columns, segment[3]);\n//         } else {\n//           lines[segment[2]] = [segment[3]];\n//         }\n//       }\n//     }\n//   }\n//   let traced: SourceMapSegment[] | undefined = undefined; // the traced line mapping\n//   let untraced: SourceMapSegment[] | undefined = undefined; // the untraced line mapping\n//   function addSegment(\n//     segment: SourceMapSegment,\n//     source?: { names: string[]; sources: (Link | Source)[] }\n//   ) {\n//     if (source) {\n//       segment[1] = uniq<Link | Source>(sources, source.sources[segment[1]!]);\n//       if (segment.length === 5) {\n//         segment[4] = uniq(names, source.names[segment[4]]);\n//       }\n//     } else if (segment.length === 5) {\n//       segment[4] = uniq(names, node.names[segment[4]]);\n//     }\n//     traced!.push(segment);\n//   }\n//   let tracedLine: number; // the last traced line\n//   let generatedLine = -1; // the current line\n//   let sourceIndex: number | undefined = -1; // source of last traced segment\n//   let sourceLine: number | undefined = undefined; // source line of last traced segment\n//   // Find the next line with segments.\n//   function nextLine() {\n//     tracedLine = generatedLine;\n//     while (++generatedLine < node.mappings.length) {\n//       untraced = node.mappings[generatedLine];\n//       if (untraced.length) return true;\n//     }\n//   }\n//   // Provide mappings for lines between the\n//   // last traced line and the current line.\n//   function fillSkippedLines() {\n//     const skipped = generatedLine - (tracedLine + 1);\n//     if (skipped !== 0) {\n//       let line = tracedLine;\n//       // Take line mappings from the current source.\n//       if (sourceIndex !== -1) {\n//         const source = node.sources[sourceIndex!];\n//         if (source instanceof Link) {\n//           while (line < generatedLine - 1) {\n//             if (++sourceLine! !== source.mappings.length) {\n//               mappings[++line] = traced = [];\n//               // Check referenced columns to avoid duplicate segments.\n//               const columns = refs[sourceIndex!][sourceLine!] || [];\n//               let prevColumn = -1;\n//               // Interweave old segments from the current source.\n//               const segments = source.mappings[sourceLine!];\n//               for (let i = 0; i < segments.length; i++) {\n//                 const segment = segments[i];\n//                 if (!hasValueBetween(columns, prevColumn, segment[0] + 1)) {\n//                   addSegment([...segment] as SourceMapSegment, source);\n//                   prevColumn = segment[0];\n//                 } else break;\n//               }\n//             } else {\n//               // End of source file.\n//               sourceIndex = -1;\n//               break;\n//             }\n//           }\n//         }\n//       }\n//       // Default to empty arrays for unmapped lines.\n//       while (++line < generatedLine) {\n//         mappings[line] = [];\n//       }\n//     }\n//   }\n//   while (nextLine()) {\n//     fillSkippedLines();\n//     // Trace the segments of this generated line.\n//     mappings[generatedLine] = traced = [];\n//     // Interweave old segments before the first mapped column of each line.\n//     const sourceColumn = untraced![0][3];\n//     if (sourceIndex !== -1 && sourceColumn !== 0) {\n//       const source = node.sources[sourceIndex];\n//       if (source instanceof Link) {\n//         const segments =\n//           sourceLine! < source.mappings.length - 1 ? source.mappings[++sourceLine!] : [];\n//         for (let i = 0; i < segments.length; i++) {\n//           const segment = segments[i];\n//           if (segment[0] < sourceColumn!) {\n//             addSegment(segment.slice(0) as SourceMapSegment, source);\n//           } else break;\n//         }\n//       }\n//     }\n//     const last = untraced!.length - 1;\n//     untraced!.forEach((curr: SourceMapSegment | null, i) => {\n//       [, sourceIndex, sourceLine] = curr!;\n//       const source = node.sources[sourceIndex!];\n//       if (source === null) {\n//         curr![1] = uniq(sources, null);\n//         return addSegment(curr!);\n//       }\n//       if (!(source instanceof Link)) {\n//         curr![1] = uniq(sources, source);\n//         return addSegment(curr!);\n//       }\n//       const next = i !== last ? untraced![i + 1] : null;\n//       const sourceColumn = curr![3];\n//       const generatedColumn = curr![0];\n//       // Find the first segment with a greater column.\n//       const segments = source.mappings[sourceLine!] || [];\n//       let j = findGreaterColumn(segments, sourceColumn!);\n//       // A \"base segment\" is required for tracing to a grand-parent.\n//       let base;\n//       if (--j !== -1) {\n//         base = segments[j];\n//         curr![1] = uniq(sources, source.sources[base[1]!]);\n//         curr![2] = base[2];\n//         curr![3] = base[3]! + sourceColumn! - base[0];\n//         if (base.length === 5) {\n//           // Inherit the names of aligned base segments.\n//           if (base[0] === sourceColumn) {\n//             curr![4] = uniq(names, source.names[base[4]!]);\n//           }\n//         } else if (curr!.length === 5) {\n//           // When our segment is named and the base segment is not,\n//           // assume this segment cannot be traced to its original source.\n//           if (base[0] !== sourceColumn) curr = null;\n//         }\n//       } else {\n//         curr![1] = uniq(sources, null);\n//       }\n//       curr && addSegment(curr);\n//       // Check referenced columns to avoid duplicate segments.\n//       const columns = refs[sourceIndex!][sourceLine!] || [];\n//       let baseColumn = base ? base[0] : -1;\n//       // Interweave old segments between our current and next segments.\n//       const nextColumn = next ? next[0] : 1 / 0;\n//       while (++j < segments.length) {\n//         let segment = segments[j];\n//         // The generated column is shifted to fit into the root source map.\n//         const column = segment[0] + generatedColumn - sourceColumn!;\n//         if (column >= nextColumn) break;\n//         // Avoid duplicates by checking if this segment goes elsewhere.\n//         if (!hasValueBetween(columns, baseColumn, segment[0] + 1)) {\n//           baseColumn = segment[0];\n//           segment = segment.slice(0) as SourceMapSegment;\n//           segment[0] = column;\n//           addSegment(segment, source);\n//         } else break;\n//       }\n//     });\n//   }\n//   fillSkippedLines();\n//   node.mappings = mappings;\n//   node.sources = sources;\n//   node.names = names;\n//   return node;\n// }\n// // Check if a value exists before pushing it to an array.\n// // Return the new or existing index of the value.\n// function uniq<T>(arr: T[], val: T): number {\n//   const i = arr.indexOf(val);\n//   return ~i ? i : arr.push(val) - 1;\n// }\n// // Get the first segment with a greater column.\n// function findGreaterColumn(segments: SourceMapSegment[], column: number) {\n//   let low = 0,\n//     high = segments.length;\n//   while (low < high) {\n//     const mid = (low + high) >>> 1;\n//     segments[mid][0] <= column ? (low = mid + 1) : (high = mid);\n//   }\n//   return low;\n// }\n// // The range is exclusive.\n// function hasValueBetween(arr: number[], start: number, end: number) {\n//   let low = 0,\n//     high = arr.length;\n//   while (low < high) {\n//     const mid = (low + high) >>> 1;\n//     const val = arr[mid];\n//     if (val <= start) {\n//       low = mid + 1;\n//     } else if (val >= end) {\n//       high = mid;\n//     } else {\n//       return true;\n//     }\n//   }\n//   return false;\n// }\n// // Insert unique values in ascending order.\n// function uniqueAscendingInsert(arr: number[], val: number) {\n//   let low = 0,\n//     high = arr.length;\n//   while (low < high) {\n//     const mid = (low + high) >>> 1;\n//     const x = arr[mid];\n//     if (x === val) return;\n//     if (x < val) {\n//       low = mid + 1;\n//     } else {\n//       high = mid;\n//     }\n//   }\n//   arr.splice(low, 0, val);\n// }\n\nclass PluginManager {\n    constructor(plugins) {\n        this.plugins = plugins;\n        this.plugins.push({\n            name: 'builtIn',\n            load: async (ctx, id) => {\n                const uri = Uri.parse(id);\n                const readReturn = ctx.resolver.readFileContent(uri);\n                const readResult = isThenable(readReturn)\n                    ? await checkCancellation(readReturn, ctx.token)\n                    : readReturn;\n                return {\n                    code: ctx.resolver.decode(readResult.content),\n                    visited: readResult.visited,\n                };\n            },\n            resolveDependency: async (ctx, dependency, fromSourceModule) => {\n                const resolveReturn = ctx.resolver.resolve(dependency.spec, fromSourceModule.uri);\n                const resolveResult = isThenable(resolveReturn)\n                    ? await checkCancellation(resolveReturn, ctx.token)\n                    : resolveReturn;\n                if (!resolveResult.found) {\n                    throw new DependencyNotFoundError(dependency.spec, fromSourceModule);\n                }\n                if (!resolveResult.uri) {\n                    // TODO: Inject empty module\n                    throw new EntryExcludedError(dependency.spec);\n                }\n                return {\n                    uri: resolveResult.uri,\n                    rootUri: resolveResult.rootUri,\n                    visited: resolveResult.visited,\n                };\n            },\n            resolveEntrypoint: async (ctx, uri) => {\n                const resolveResult = await ctx.resolver.resolve(uri);\n                if (!resolveResult.found) {\n                    throw new EntryNotFoundError(`Entry point not found: ${uri}`);\n                }\n                if (!resolveResult.uri) {\n                    throw new EntryExcludedError(uri);\n                }\n                return resolveResult;\n            },\n            transform: async ({ createMagicString }, id) => {\n                if (id.path.endsWith('.json')) {\n                    const magicString = createMagicString();\n                    magicString.prepend('module.exports = ');\n                    return {\n                        code: magicString.toString(),\n                        sourceMap: magicString.generateDecodedMap(),\n                    };\n                }\n            },\n        });\n    }\n    async executeLoad(ctx, uri) {\n        for (const plugin of this.plugins) {\n            if (typeof plugin.load === 'function') {\n                const loadReturn = plugin.load(ctx, uri.toString());\n                const loadResult = isThenable(loadReturn)\n                    ? await checkCancellation(loadReturn, ctx.token)\n                    : loadReturn;\n                if (!loadResult) {\n                    continue;\n                }\n                return {\n                    code: loadResult.code,\n                    visited: loadResult.visited || [],\n                };\n            }\n        }\n        throw new Error(`No plugin was found that was able to load the uri ${uri.toString()}`);\n    }\n    async executeResolveDependency(ctx, dependency, fromModule) {\n        for (const plugin of this.plugins) {\n            if (typeof plugin.resolveDependency === 'function') {\n                const loadReturn = plugin.resolveDependency(ctx, dependency, fromModule);\n                const loadResult = isThenable(loadReturn)\n                    ? await checkCancellation(loadReturn, ctx.token)\n                    : loadReturn;\n                if (!loadResult) {\n                    continue;\n                }\n                return {\n                    uri: loadResult.uri,\n                    rootUri: loadResult.rootUri,\n                    visited: loadResult.visited || [],\n                };\n            }\n        }\n        throw new Error(`No plugin was able to resolve the '${dependency.kind}' dependency, '${dependency.spec}' from '${fromModule.href}'`);\n    }\n    async executeResolveEntrypoint(ctx, uri) {\n        for (const plugin of this.plugins) {\n            if (typeof plugin.resolveEntrypoint === 'function') {\n                const loadReturn = plugin.resolveEntrypoint(ctx, uri);\n                const loadResult = isThenable(loadReturn)\n                    ? await checkCancellation(loadReturn, ctx.token)\n                    : loadReturn;\n                if (!loadResult) {\n                    continue;\n                }\n                return {\n                    uri: loadResult.uri,\n                    rootUri: loadResult.rootUri,\n                    visited: loadResult.visited || [],\n                };\n            }\n        }\n        throw new Error(`No plugin was able to resolve the entrypoint '${uri.toString()}'`);\n    }\n    async executeTransform(ctx, uri, code) {\n        if (typeof code !== 'string') {\n            code = ctx.resolver.decode(code);\n        }\n        const pluginCtx = Object.assign(ctx, {\n            createMagicString() {\n                return new MagicString(code);\n            },\n        });\n        let sourceMapTree = new Source(uri.toString(), code);\n        // Figure out if our original code, itself has a sourcemap.\n        // For now, we will not recurse beyond that depth.\n        const sourceMapRef = getSourceMappingUrl(code);\n        if (sourceMapRef) {\n            let sourceMap = decodeDataUriAsSourceMap(sourceMapRef);\n            if (!sourceMap) {\n                const sourceMapUri = Uri.joinPath(uri, `../${sourceMapRef}`);\n                code = updateSourceMappingUrl(code, sourceMapUri.toString());\n            }\n            if (sourceMap) {\n                const sources = sourceMap.sources;\n                const sourcesContent = sourceMap.sourcesContent || [];\n                const baseSources = [];\n                for (const idx in sources) {\n                    if (sources[idx] && sourcesContent[idx]) {\n                        baseSources.push(new Source(sources[idx], sourcesContent[idx]));\n                    }\n                }\n                sourceMapTree = new Link(sourceMap, baseSources);\n            }\n        }\n        const visited = [];\n        for (const plugin of this.plugins) {\n            if (typeof plugin.transform === 'function') {\n                const transformReturn = plugin.transform(pluginCtx, uri, code);\n                const transformResult = isThenable(transformReturn)\n                    ? await checkCancellation(transformReturn, ctx.token)\n                    : transformReturn;\n                if (transformResult === null || transformResult === undefined) {\n                    continue;\n                }\n                if (transformResult.sourceMap) {\n                    sourceMapTree = new Link(transformResult.sourceMap, [sourceMapTree]);\n                }\n                code = transformResult.code;\n                if (transformResult.visited) {\n                    visited.push(...transformResult.visited);\n                }\n            }\n        }\n        return {\n            code,\n            sourceMapTree,\n            visited,\n        };\n    }\n}\n\nvar SourceModuleDependencyKind;\n(function (SourceModuleDependencyKind) {\n    SourceModuleDependencyKind[\"Entrypoint\"] = \"Entrypoint\";\n    SourceModuleDependencyKind[\"Require\"] = \"Require\";\n    SourceModuleDependencyKind[\"RequireResolve\"] = \"RequireResolve\";\n    SourceModuleDependencyKind[\"GlobalObject\"] = \"GlobalObject\";\n})(SourceModuleDependencyKind || (SourceModuleDependencyKind = {}));\nclass SourceModuleDependency {\n    constructor(kind, spec, locations, options = {}) {\n        this.kind = kind;\n        this.spec = spec;\n        this.locations = locations;\n        this.options = options;\n    }\n    static areIdentical(l, r) {\n        return l.kind === r.kind && l.spec === r.spec;\n    }\n    static fromEntrypoint(uri) {\n        return new SourceModuleDependency(SourceModuleDependencyKind.Entrypoint, uri.toString(), []);\n    }\n    static fromGlobalObject(spec, locations, exportName) {\n        return new SourceModuleDependency(SourceModuleDependencyKind.GlobalObject, spec, locations, {\n            exportName,\n        });\n    }\n    static fromRequire(spec, locations) {\n        return new SourceModuleDependency(SourceModuleDependencyKind.Require, spec, locations);\n    }\n    static fromRequireResolve(spec, locations) {\n        return new SourceModuleDependency(SourceModuleDependencyKind.RequireResolve, spec, locations);\n    }\n}\n\nfunction isArrowFunctionExpression(node) {\n    return node.type === 'ArrowFunctionExpression';\n}\nfunction isArrayPattern(node) {\n    return node.type === 'ArrayPattern';\n}\nfunction isAssignmentPattern(node) {\n    return node.type === 'AssignmentPattern';\n}\nfunction isBinaryExpression(node) {\n    return node.type === 'BinaryExpression';\n}\nfunction isBlockStatement(node) {\n    return node.type === 'BlockStatement';\n}\nfunction isCallExpression(node) {\n    return node.type === 'CallExpression';\n}\nfunction isClassDeclaration(node) {\n    return node.type === 'ClassDeclaration';\n}\nfunction isFunctionDeclaration(node) {\n    return node.type === 'FunctionDeclaration';\n}\nfunction isFunctionExpression(node) {\n    return node.type === 'FunctionExpression';\n}\nfunction isIdentifier(node) {\n    return node.type === 'Identifier';\n}\nfunction isIfStatement(node) {\n    return node.type === 'IfStatement';\n}\nfunction isLiteral(node) {\n    return node.type === 'Literal';\n}\nfunction isMemberExpression(node) {\n    return node.type === 'MemberExpression';\n}\nfunction isObjectPattern(node) {\n    return node.type === 'ObjectPattern';\n}\nfunction isProperty(node) {\n    return node.type === 'Property';\n}\nfunction isRestElement(node) {\n    return node.type === 'RestElement';\n}\nfunction isProgram(node) {\n    return node.type === 'Program';\n}\nfunction isThisExpression(node) {\n    return node.type === 'ThisExpression';\n}\nfunction isTryStatement(node) {\n    return node.type === 'TryStatement';\n}\nfunction isVariableDeclaration(node) {\n    return node.type === 'VariableDeclaration';\n}\n// Refinements or groups\nfunction isFunction(node) {\n    return (isFunctionDeclaration(node) || isFunctionExpression(node) || isArrowFunctionExpression(node));\n}\nfunction isStringLiteral(node) {\n    return isLiteral(node) && typeof node.value === 'string';\n}\nfunction parse(code, options) {\n    return parse$2(code, {\n        ...options,\n        allowReturnOutsideFunction: true,\n        sourceType: 'script',\n    });\n}\n\nfunction traverse(ast, ctx, { enter, leave }) {\n    visit(ast, null, ctx, enter, leave);\n}\nlet shouldSkip = false;\nconst context = { skip: () => (shouldSkip = true) };\nconst childKeys = {};\nfunction visit(node, parent, ctx, enter, leave\n// prop?: string,\n// index?: number\n) {\n    if (!node)\n        return;\n    node.parent = parent;\n    if (enter) {\n        const _shouldSkip = shouldSkip;\n        shouldSkip = false;\n        enter.call(context, node, parent, ctx);\n        const skipped = shouldSkip;\n        shouldSkip = _shouldSkip;\n        if (skipped)\n            return;\n    }\n    const keys = childKeys[node.type] ||\n        (childKeys[node.type] = Object.keys(node).filter((key) => key !== 'parent' && typeof node[key] === 'object'));\n    const children = [];\n    for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        const value = node[key];\n        if (Array.isArray(value)) {\n            children.push(...value);\n            // for (let j = 0; j < value.length; j++) {\n            //   visit(value[j], node, ctx, enter, leave);\n            // }\n        }\n        else if (value && value.type) {\n            children.push(value);\n        }\n    }\n    children.sort((a, b) => a.start - b.start);\n    for (const child of children) {\n        visit(child, node, ctx, enter, leave);\n    }\n    if (leave) {\n        leave(node, parent, ctx);\n    }\n}\n\nconst parse$1 = function parseJavaScript(uri, code, options) {\n    const visitorCtx = {\n        unboundSymbols: new Map(),\n        locals: new Map(),\n        magicString: new MagicString(code, { filename: uri.toString(), indentExclusionRanges: [] }),\n        nodeEnv: options.nodeEnv,\n        replacedSymbols: new Set(),\n        requires: [],\n        requireResolves: [],\n        skip: new Set(),\n        skipTransform: new Set(),\n    };\n    const dependencies = [];\n    try {\n        // let lastToken: Token | undefined;\n        const ast = parse(code, {\n        // onComment: (_isBlock, _test, start, end) => {\n        //   result.changes.push({ type: 'remove', start, end });\n        // },\n        // onInsertedSemicolon(lastTokEnd) {\n        //   result.changes.push({ type: 'appendRight', position: lastTokEnd, value: ';' });\n        // },\n        // onToken: (token) => {\n        //   const start = lastToken ? lastToken.end + 1 : 0;\n        //   const end = token.start;\n        //   if (end > start) {\n        //     result.changes.push({ type: 'remove', start, end });\n        //   }\n        //   lastToken = token;\n        // },\n        });\n        traverse(ast, visitorCtx, scopingAndRequiresVisitor);\n        traverse(ast, visitorCtx, collectGlobalsVisitor);\n    }\n    catch (err) {\n        // console.log(code);\n        throw new Error(`Error parsing ${uri}: ${err.message}`);\n    }\n    // Handle explicit requires\n    const requiresBySpec = new Map();\n    for (const requireDependency of visitorCtx.requires) {\n        let locations = requiresBySpec.get(requireDependency.spec.value);\n        if (!locations) {\n            locations = [];\n            requiresBySpec.set(requireDependency.spec.value, locations);\n        }\n        locations.push({ start: requireDependency.spec.start, end: requireDependency.spec.end });\n    }\n    for (const [spec, locations] of requiresBySpec) {\n        dependencies.push(SourceModuleDependency.fromRequire(spec, locations));\n    }\n    // Handle require.resolve\n    const requireResolvesBySpec = new Map();\n    for (const requireDependency of visitorCtx.requireResolves) {\n        let locations = requiresBySpec.get(requireDependency.spec.value);\n        if (!locations) {\n            locations = [];\n            requiresBySpec.set(requireDependency.spec.value, locations);\n        }\n        locations.push({ start: requireDependency.spec.start, end: requireDependency.spec.end });\n    }\n    for (const [spec, locations] of requireResolvesBySpec) {\n        dependencies.push(SourceModuleDependency.fromRequireResolve(spec, locations));\n    }\n    for (const [symbolName, locations] of visitorCtx.unboundSymbols) {\n        const shim = options.globalModules[symbolName];\n        if (shim) {\n            dependencies.push(SourceModuleDependency.fromGlobalObject(shim.spec, locations, shim.export));\n            for (const location of locations) {\n                visitorCtx.magicString.overwrite(location.start, location.end, `require(${JSON.stringify(`${shim.spec}`)})`);\n            }\n        }\n    }\n    return {\n        code: visitorCtx.magicString,\n        dependencies,\n    };\n};\nconst scopingAndRequiresVisitor = {\n    enter(node, parent, ctx) {\n        // Get AST-node level locations in the source map\n        ctx.magicString.addSourcemapLocation(node.start);\n        ctx.magicString.addSourcemapLocation(node.end);\n        if (ctx.skip.has(node)) {\n            return this.skip();\n        }\n        visitAndCaptureScoping(node, parent, ctx);\n        visitAndSkipBranches(node, parent, ctx);\n        visitRequires(node, parent, ctx);\n    },\n    leave(node, _parent, ctx) {\n        let skipped = false;\n        let nextCheck = node;\n        while (nextCheck) {\n            if (ctx.skipTransform.has(nextCheck)) {\n                skipped = true;\n                break;\n            }\n            nextCheck = nextCheck.parent;\n        }\n        if (!skipped &&\n            isMemberExpression(node) &&\n            memberExpressionMatches(node, 'process.env.NODE_ENV')) {\n            ctx.magicString.overwrite(node.start, node.end, JSON.stringify(ctx.nodeEnv), {\n                contentOnly: true,\n                storeName: true,\n            });\n            ctx.skip.add(node);\n            ctx.skipTransform.add(node);\n        }\n    },\n};\nconst collectGlobalsVisitor = {\n    enter(node, _parent, ctx) {\n        if (ctx.skip.has(node)) {\n            return this.skip();\n        }\n        if (isBindingIdentifier(node) && isIdentifier(node)) {\n            var name = node.name;\n            if (name === 'undefined')\n                return;\n            if (ctx.replacedSymbols.has(node)) {\n                return;\n            }\n            let foundBinding = false;\n            let nextParent = node.parent;\n            while (nextParent) {\n                if (name === 'arguments' && declaresArguments(nextParent)) {\n                    foundBinding = true;\n                    break;\n                }\n                const locals = ctx.locals.get(nextParent);\n                if (locals && locals[name]) {\n                    foundBinding = true;\n                    break;\n                }\n                nextParent = nextParent.parent;\n            }\n            if (!foundBinding) {\n                let unboundSymbols = ctx.unboundSymbols.get(name);\n                if (!unboundSymbols) {\n                    unboundSymbols = [];\n                    ctx.unboundSymbols.set(name, unboundSymbols);\n                }\n                unboundSymbols.push(node);\n            }\n        }\n        else if (isThisExpression(node)) {\n            let foundBinding = false;\n            let nextParent = node.parent;\n            while (nextParent) {\n                if (declaresThis(nextParent)) {\n                    foundBinding = true;\n                    break;\n                }\n                nextParent = nextParent.parent;\n            }\n            if (!foundBinding) {\n                let unboundSymbols = ctx.unboundSymbols.get('this');\n                if (!unboundSymbols) {\n                    unboundSymbols = [];\n                    ctx.unboundSymbols.set('this', unboundSymbols);\n                }\n                unboundSymbols.push(node);\n            }\n        }\n    },\n};\nfunction visitAndCaptureScoping(node, _parent, ctx) {\n    if (isVariableDeclaration(node)) {\n        let parent;\n        let nextParent = node.parent;\n        while (nextParent) {\n            if (node.kind === 'var' ? isScope(nextParent) : isBlockScope(nextParent)) {\n                parent = nextParent;\n                break;\n            }\n            nextParent = nextParent.parent;\n        }\n        if (!parent) {\n            throw new Error(`Invariant violation: Failed to find a parent`);\n        }\n        let locals = ctx.locals.get(parent);\n        if (!locals) {\n            locals = {};\n            ctx.locals.set(parent, locals);\n        }\n        for (const declaration of node.declarations) {\n            declarePattern(declaration.id, locals);\n        }\n    }\n    else if (isFunctionDeclaration(node)) {\n        let parent;\n        let nextParent = node.parent;\n        if (nextParent && nextParent.parent) {\n            nextParent = nextParent.parent;\n        }\n        while (nextParent) {\n            if (isScope(nextParent)) {\n                parent = nextParent;\n                break;\n            }\n            nextParent = nextParent.parent;\n        }\n        if (!parent) {\n            throw new Error(`Invariant violation: Failed to find a parent`);\n        }\n        let locals = ctx.locals.get(parent);\n        if (!locals) {\n            locals = {};\n            ctx.locals.set(parent, locals);\n        }\n        declareFunction(node, locals);\n    }\n    else if (isFunction(node)) {\n        let locals = ctx.locals.get(node);\n        if (!locals) {\n            locals = {};\n            ctx.locals.set(node, locals);\n        }\n        declareFunction(node, locals);\n    }\n    else if (isClassDeclaration(node) && node.id) {\n        let parent;\n        let nextParent = node.parent;\n        if (nextParent && nextParent.parent) {\n            nextParent = nextParent.parent;\n        }\n        while (nextParent) {\n            if (isScope(nextParent)) {\n                parent = nextParent;\n                break;\n            }\n            nextParent = nextParent.parent;\n        }\n        if (!parent) {\n            throw new Error(`Invariant violation: Failed to find a parent`);\n        }\n        let locals = ctx.locals.get(parent);\n        if (!locals) {\n            locals = {};\n            ctx.locals.set(parent, locals);\n        }\n        locals[node.id.name] = true;\n    }\n    else if (isTryStatement(node)) {\n        if (node.handler) {\n            let locals = ctx.locals.get(node.handler);\n            if (!locals) {\n                locals = {};\n                ctx.locals.set(node.handler, locals);\n            }\n            if (node.handler.param) {\n                declarePattern(node.handler.param, locals);\n            }\n        }\n    }\n}\nfunction visitAndSkipBranches(node, _parent, ctx) {\n    if (isIfStatement(node) && isBinaryExpression(node.test)) {\n        const tests = {\n            '!=': (l, r) => l != r,\n            '!==': (l, r) => l !== r,\n            '==': (l, r) => l == r,\n            '===': (l, r) => l === r,\n        };\n        const test = tests[node.test.operator];\n        if (test) {\n            if (isStringLiteral(node.test.left) &&\n                isMemberExpression(node.test.right) &&\n                memberExpressionMatches(node.test.right, 'process.env.NODE_ENV')) {\n                let rootObject = node.test.right;\n                while (isMemberExpression(rootObject.object)) {\n                    rootObject = rootObject.object;\n                }\n                if (isIdentifier(rootObject.object)) {\n                    ctx.replacedSymbols.add(rootObject.object);\n                }\n                ctx.skipTransform.add(node.test.right);\n                // if ('development' === process.env.NODE_ENV) {}\n                if (!test(node.test.left.value, ctx.nodeEnv)) {\n                    ctx.skip.add(node.consequent);\n                    // We can blow away the consequent\n                    ctx.magicString.remove(node.start, node.alternate ? node.alternate.start : node.consequent.end);\n                }\n                else {\n                    // We can blow away the test\n                    ctx.magicString.remove(node.start, node.consequent.start - 1);\n                    if (node.alternate) {\n                        ctx.skip.add(node.alternate);\n                        // We can blow away the alternate but we need to start and the end of the consequent + 1 char\n                        ctx.magicString.remove(node.consequent.end + 1, node.alternate.end);\n                    }\n                }\n            }\n            else if (isStringLiteral(node.test.right) &&\n                isMemberExpression(node.test.left) &&\n                memberExpressionMatches(node.test.left, 'process.env.NODE_ENV')) {\n                let rootObject = node.test.left;\n                while (isMemberExpression(rootObject.object)) {\n                    rootObject = rootObject.object;\n                }\n                if (isIdentifier(rootObject.object)) {\n                    ctx.replacedSymbols.add(rootObject.object);\n                }\n                ctx.skipTransform.add(node.test.left);\n                // if (process.env.NODE_ENV === 'development') {}\n                if (!test(node.test.right.value, ctx.nodeEnv)) {\n                    ctx.skip.add(node.consequent);\n                    // We can blow away the consequent\n                    ctx.magicString.remove(node.start, node.alternate ? node.alternate.start : node.consequent.end);\n                }\n                else {\n                    // We can blow away the test and the alternate\n                    ctx.magicString.remove(node.start, node.consequent.start - 1);\n                    if (node.alternate) {\n                        ctx.skip.add(node.alternate);\n                        // We can blow away the alternate but we need to start and the end of the consequent + 1 char\n                        ctx.magicString.remove(node.consequent.end + 1, node.alternate.end);\n                    }\n                }\n            }\n        }\n    }\n}\nfunction visitRequires(node, _parent, ctx) {\n    if (isCallExpression(node)) {\n        const callee = node.callee;\n        if (isIdentifier(callee) && callee.name === 'require') {\n            const firstArg = node.arguments[0];\n            if (isStringLiteral(firstArg)) {\n                ctx.requires.push({\n                    spec: { start: firstArg.start, end: firstArg.end, value: firstArg.value },\n                    callee: { start: callee.start, end: callee.end },\n                });\n            }\n            else {\n                console.warn('Non string-literal first arg to require', firstArg);\n            }\n        }\n        else if (isMemberExpression(callee) &&\n            isIdentifier(callee.object) &&\n            callee.object.name === 'require' &&\n            isIdentifier(callee.property) &&\n            callee.property.name === 'resolve') {\n            const firstArg = node.arguments[0];\n            if (isStringLiteral(firstArg)) {\n                ctx.requireResolves.push({\n                    spec: { start: firstArg.start, end: firstArg.end, value: firstArg.value },\n                    callee: { start: callee.start, end: callee.end },\n                });\n            }\n            else {\n                console.warn('Non string-literal first arg to require.resolve', firstArg);\n            }\n        }\n    }\n}\nfunction declareFunction(node, locals) {\n    node.params.forEach(function (node) {\n        declarePattern(node, locals);\n    });\n    if (node.id) {\n        locals[node.id.name] = true;\n    }\n}\nfunction declarePattern(node, locals) {\n    if (isIdentifier(node)) {\n        locals[node.name] = true;\n    }\n    else if (isObjectPattern(node)) {\n        node.properties.forEach((node) => isRestElement(node)\n            ? declarePattern(node.argument, locals)\n            : declarePattern(node.value, locals));\n    }\n    else if (isArrayPattern(node)) {\n        node.elements.forEach((node) => node && declarePattern(node, locals));\n    }\n    else if (isRestElement(node)) {\n        declarePattern(node.argument, locals);\n    }\n    else if (isAssignmentPattern(node)) {\n        declarePattern(node.left, locals);\n    }\n    else {\n        throw new Error(`Invariant violation: Unexpected pattern type: ${node.type}`);\n    }\n}\nfunction isBindingIdentifier(node) {\n    return isIdentifier(node) && !isPropertyOfMemberExpression(node) && !isKeyOfProperty(node);\n}\nfunction isKeyOfProperty(node) {\n    return node.parent && isProperty(node.parent) && node.parent.key === node;\n}\nfunction isPropertyOfMemberExpression(node) {\n    return node.parent && isMemberExpression(node.parent) && node.parent.object !== node;\n}\nfunction isScope(node) {\n    return (isFunctionDeclaration(node) ||\n        isFunctionExpression(node) ||\n        isArrowFunctionExpression(node) ||\n        isProgram(node));\n}\nfunction isBlockScope(node) {\n    return isBlockStatement(node) || isScope(node);\n}\nfunction declaresArguments(node) {\n    return isFunctionDeclaration(node) || isFunctionExpression(node);\n}\nfunction declaresThis(node) {\n    return isFunctionDeclaration(node) || isFunctionExpression(node);\n}\nfunction memberExpressionMatches(node, pattern) {\n    const memberParts = pattern.split('.');\n    if (memberParts.length < 2) {\n        return false;\n    }\n    const object = memberParts.shift();\n    const property = memberParts.shift();\n    for (let i = memberParts.length - 1; i >= 0; i--) {\n        if (!isIdentifier(node.property) || node.property.name !== memberParts[i]) {\n            return false;\n        }\n        if (!isMemberExpression(node.object)) {\n            return false;\n        }\n        node = node.object;\n    }\n    if (!isIdentifier(node.object) || !isIdentifier(node.property)) {\n        return false;\n    }\n    return node.object.name === object && node.property.name === property;\n}\n\n//@ts-check\n/**\n * @param {import('./types').VelcroStaticRuntime} velcro\n * @returns {import('./runtimeInterface').VelcroRuntime}\n */\nfunction createRuntime(velcro) {\n    if (velcro.runtime)\n        return velcro.runtime;\n    class Module {\n        /**\n         * @param {Runtime} runtime\n         * @param {string} id\n         * @param {import('./types').VelcroImportMap} importMap\n         */\n        constructor(runtime, id, importMap) {\n            this.runtime = runtime;\n            this.id = id;\n            this.importMap = importMap;\n            this.module = { exports: {} };\n            this.require = runtime.createRequire(this);\n        }\n    }\n    class Runtime {\n        /**\n         *\n         * @param {import('./types').VelcroStaticRuntime} velcro\n         */\n        constructor(velcro) {\n            /** @type {Required<import('./types').VelcroImportMap>} */\n            this.importMap = { imports: {}, scopes: {} };\n            this.defs = velcro.defs;\n            /** @type {Record<string, Module | undefined>} */\n            this.modules = Object.create(null);\n            this.root = new Module(this, 'velcro:/root', {});\n            this.require = this.createRequire(this.root);\n            /** @type {Record<string, Module[] | undefined>} */\n            this.dependents = Object.create(null);\n        }\n        /**\n         *\n         * @param {Module} fromModule\n         */\n        createRequire(fromModule) {\n            var runtime = this;\n            /**\n             *\n             * @param {string} spec\n             */\n            function require(spec) {\n                var id = runtime.resolveSpecAgainstImportMap(spec, fromModule);\n                var module = runtime.modules[id];\n                if (!module) {\n                    var moduleDefinition = runtime.defs[id];\n                    if (!moduleDefinition) {\n                        throw new Error(`Unable to locate module '${id}' from '${fromModule.id}`);\n                    }\n                    var [factory, importMap] = moduleDefinition;\n                    module = new Module(runtime, id, importMap);\n                    runtime.modules[id] = module;\n                    var specParts = id.split('/');\n                    var __filename = specParts.pop() || spec;\n                    var __dirname = specParts.join('/');\n                    factory.call(module.module.exports, module.module, module.module.exports, module.require.bind(module), __dirname, __filename);\n                }\n                (runtime.dependents[id] = runtime.dependents[id] || []).push(fromModule);\n                return module.module.exports;\n            }\n            /**\n             *\n             * @param {string} _spec\n             */\n            function resolve(_spec) {\n                return '';\n            }\n            return Object.assign(require, {\n                resolve,\n            });\n        }\n        /**\n         * Inject a pre-existing module\n         *\n         * @template T\n         * @param {string} id Identifier of module\n         * @param {T} exports Value that represents the exported interface of the module\n         */\n        inject(id, exports) {\n            var module = new Module(this, id, Object.create(null));\n            module.module.exports = exports;\n            this.modules[id] = module;\n            return module;\n        }\n        /**\n         *\n         * @param {string[]} invalidations\n         */\n        invalidate(invalidations) {\n            var queue = invalidations.slice();\n            while (queue.length) {\n                var id = queue.shift();\n                //@ts-expect-error\n                var deleted = delete this.modules[id];\n                /** @type {Module[] | undefined} */\n                //@ts-expect-error\n                var dependents = this.dependents[id];\n                if (!Array.isArray(dependents))\n                    continue;\n                dependents.forEach((dependent) => {\n                    queue.push(dependent.id);\n                });\n            }\n        }\n        /**\n         *\n         * @param {string} spec\n         * @param {Module} module\n         * @private\n         */\n        resolveSpecAgainstImportMap(spec, module) {\n            var importMap = module.importMap;\n            if (!importMap.scopes) {\n                return spec;\n            }\n            var scopesForId = importMap.scopes[module.id];\n            if (!scopesForId) {\n                return spec;\n            }\n            var mappedId = scopesForId[spec];\n            if (mappedId) {\n                return mappedId;\n            }\n            return spec;\n        }\n    }\n    var runtime = new Runtime(velcro);\n    velcro.runtime = runtime;\n    return runtime;\n}\n\nclass ChunkOutput {\n    constructor(bundle, sourceModules, uri) {\n        this.bundle = bundle;\n        this.sourceModules = sourceModules;\n        this.uri = uri;\n    }\n    get code() {\n        if (typeof this.cachedCode === 'undefined') {\n            this.cachedCode = this.bundle.toString();\n        }\n        return this.cachedCode;\n    }\n    get href() {\n        return this.uri.toString();\n    }\n    get sourceMap() {\n        if (typeof this.cachedSourceMap === 'undefined') {\n            this.cachedSourceMap = this.generateSourceMap();\n        }\n        return this.cachedSourceMap;\n    }\n    get sourceMapString() {\n        if (typeof this.cachedSourceMapString === 'undefined') {\n            this.cachedSourceMapString = this.sourceMap.toString();\n        }\n        return this.cachedSourceMapString;\n    }\n    get sourceMapDataUri() {\n        if (typeof this.cachedSourceMapDataUri === 'undefined') {\n            this.cachedSourceMapDataUri = this.sourceMap.toDataUri();\n        }\n        return this.cachedSourceMapDataUri;\n    }\n    generateSourceMap() {\n        const inputMap = this.bundle.generateDecodedMap({\n            includeContent: false,\n            hires: true,\n            source: this.href,\n        });\n        const sourceMapTree = new Link(inputMap, inputMap.sources.map((sourceHref) => {\n            const sourceModule = this.sourceModules.get(sourceHref);\n            if (!sourceModule) {\n                return new Source(sourceHref, 'SOURCEMAP ERROR');\n            }\n            // All of the transformations included in the source module's magicString\n            // were baked into the bundle already. We just need to map these into any\n            // earlier sources.\n            return sourceModule.sourceMapsTree;\n        }));\n        const sourceMapTreeMappings = sourceMapTree.traceMappings();\n        if (sourceMapTreeMappings instanceof Error) {\n            return new SourceMap({\n                file: inputMap.file,\n                mappings: '',\n                names: [],\n                sources: [],\n                version: 3,\n                sourcesContent: [],\n            });\n        }\n        // Loop through generated mappings, removing mappings that are character-by-character increments\n        // from the previous mapping. Since we generated a hires bundle, this will shrink the resolution\n        // back down to something not unnecessarily large.\n        // for (const line of sourceMapTreeMappings.mappings) {\n        //   let lastSegment: SourceMapSegment | null = null;\n        //   const shrinkedLine: SourceMapSegment[] = [];\n        //   for (const segment of line) {\n        //     if (lastSegment && lastSegment.length >= 4 && lastSegment.length === segment.length) {\n        //       // We will only push the segment if it is not, effectively a direct cursor move of the\n        //       // last one.\n        //       // For example:\n        //       //   lastSegment = [1, 0, 0, 1] // Generated column 1, original column 1 of the 0th file, 0th line\n        //       //   segment = [2, 0, 0, 2] // Generated column 2, original column 2 of the 0th file, 0th line\n        //       // Given that, we can see that this segment is not adding any _new_ information so we can skip it.\n        //       if (\n        //         lastSegment.length >= 4 &&\n        //         (lastSegment[0] + 1 !== segment[0] ||\n        //           lastSegment[1] !== segment[1] ||\n        //           lastSegment[2] !== segment[2] ||\n        //           lastSegment[3]! + 1 !== segment[3] ||\n        //           lastSegment[4] !== segment[4])\n        //       ) {\n        //         shrinkedLine.push(segment);\n        //       }\n        //     } else {\n        //       shrinkedLine.push(segment);\n        //     }\n        //     lastSegment = segment;\n        //   }\n        //   // line.splice(0, line.length, ...shrinkedLine);\n        // }\n        const sourceMap = new SourceMap({\n            file: this.href,\n            mappings: encode(sourceMapTreeMappings.mappings),\n            names: sourceMapTreeMappings.names,\n            sources: sourceMapTreeMappings.sources,\n            version: 3,\n            sourcesContent: sourceMapTreeMappings.sourcesContent,\n        });\n        return sourceMap;\n    }\n}\n\nclass Chunk {\n    constructor(options) {\n        this.edgesFrom = new MapSet();\n        this.edgesTo = new MapSet();\n        this.sourceModules = new Map();\n        this.rootUri = options.rootUri;\n        for (const sourceModule of options.sourceModules) {\n            this.sourceModules.set(sourceModule.href, sourceModule);\n        }\n        for (const edge of options.edges) {\n            const fromHref = edge.fromUri.toString();\n            const toHref = edge.toUri.toString();\n            this.edgesFrom.add(fromHref, edge);\n            this.edgesTo.add(toHref, edge);\n        }\n    }\n    buildForStaticRuntime(options) {\n        // const velcroModuleFactoryParts = velcroModuleFactory\n        //   .toString()\n        //   .split(velcroModuleFactory.splitString);\n        // const velcroChunkWrapperParts = velcroChunkWrapper\n        //   .toString()\n        //   .split(velcroChunkWrapper.splitString);\n        const bundle = new Bundle({\n            separator: '\\n',\n        });\n        for (const sourceModule of this.sourceModules.values()) {\n            const moduleScopes = {};\n            const scopes = {\n                [sourceModule.href]: moduleScopes,\n            };\n            const importMap = { scopes };\n            const edgesFrom = this.edgesFrom.get(sourceModule.href);\n            if (edgesFrom) {\n                for (const edge of edgesFrom) {\n                    moduleScopes[edge.dependency.spec] = edge.toUri.toString();\n                }\n            }\n            const sourceModuleCode = sourceModule.source.clone();\n            sourceModuleCode.prepend(`velcro.defs[${JSON.stringify(sourceModule.uri.toString())}] = [function(module,exports,require,__dirname,__filename){\\n`);\n            sourceModuleCode.append(`\\n},${JSON.stringify(importMap)}];`);\n            bundle.addSource(sourceModuleCode);\n        }\n        const velcroStaticRuntime = { defs: {} };\n        bundle.prepend(`(function(velcro){\\n`);\n        bundle.prepend(`if (typeof Velcro === 'undefined') Velcro = Object.create(null);\\nif (typeof Velcro.registry === 'undefined') Velcro.registry = ${JSON.stringify(velcroStaticRuntime)};\\n`);\n        bundle.append(`\\n})(Velcro.registry);\\n`);\n        if (options && options.injectRuntime) {\n            bundle.append(`\\nVelcro.runtime = ${createRuntime.toString()}(Velcro.registry);\\n`);\n        }\n        if (options && options.invalidations) {\n            if (!options.injectRuntime) {\n                throw new Error('Setting injectRuntime to true is required when calling buildForStaticRuntime and specifying invalidations');\n            }\n            bundle.append(`\\nVelcro.runtime.invalidate(${JSON.stringify(options.invalidations)});\\n`);\n        }\n        return new ChunkOutput(bundle, this.sourceModules, this.rootUri);\n    }\n}\n\nclass Graph {\n    constructor(options) {\n        this.edgesFrom = new MapSet();\n        this.edgesTo = new MapSet();\n        this.sourceModules = new Map();\n        this.rootUri = options.rootUri;\n        for (const sourceModule of options.sourceModules) {\n            this.sourceModules.set(sourceModule.href, sourceModule);\n        }\n        for (const edge of options.edges) {\n            const fromHref = edge.fromUri.toString();\n            const toHref = edge.toUri.toString();\n            this.edgesFrom.add(fromHref, edge);\n            this.edgesTo.add(toHref, edge);\n        }\n    }\n    splitChunks() {\n        return [\n            new Chunk({\n                edges: this.edgesFrom.values(),\n                rootUri: Uri.joinPath(this.rootUri, './chunk/0.js'),\n                sourceModules: this.sourceModules.values(),\n            }),\n        ];\n    }\n}\n\nvar version = \"0.45.0\";\n\nconst DEFAULT_SHIM_GLOBALS = Object.assign(Object.create(null), {\n    Buffer: {\n        spec: `@velcro/node-libs@${version}/lib/buffer.js`,\n        export: 'Buffer',\n    },\n    global: {\n        spec: `@velcro/node-libs@${version}/lib/global.js`,\n    },\n    globalThis: {\n        spec: `@velcro/node-libs@${version}/lib/global.js`,\n    },\n    process: {\n        spec: `@velcro/node-libs@${version}/lib/process.js`,\n    },\n});\n\nclass SourceModule {\n    constructor(uri, rootUri, source, dependencies, sourceMapsTree, visits) {\n        this.uri = uri;\n        this.rootUri = rootUri;\n        this.source = source;\n        this.dependencies = dependencies;\n        this.sourceMapsTree = sourceMapsTree;\n        this.visits = visits;\n    }\n    get href() {\n        return this.uri.toString();\n    }\n    get rootHref() {\n        return this.rootUri.toString();\n    }\n}\n\nclass Build {\n    constructor(rootUri, options = {}) {\n        this.rootUri = rootUri;\n        this.disposer = new DisposableStore();\n        this.edges = new Set();\n        this.errors = [];\n        this.seen = new Set();\n        this.sourceModules = new Map();\n        this.pendingModuleOperations = new MapSet();\n        this.onCompletedEmitter = new Emitter();\n        this.onErrorEmitter = new Emitter();\n        this.onProgressEmitter = new Emitter();\n        this.done = new Promise((resolve, reject) => {\n            this.disposer.add(this.onCompleted(({ graph }) => resolve(graph)));\n            this.disposer.add(this.onError(({ error }) => reject(error)));\n        });\n        this.tokenSource = new CancellationTokenSource(options.token);\n        this.disposer.add(this.tokenSource);\n        this.done.catch(() => {\n            // Prevent uncaught rejection\n        });\n    }\n    get onCompleted() {\n        return this.onCompletedEmitter.event;\n    }\n    get onError() {\n        return this.onErrorEmitter.event;\n    }\n    get onProgress() {\n        return this.onProgressEmitter.event;\n    }\n    get token() {\n        return this.tokenSource.token;\n    }\n    addEdge(edge) {\n        this.edges.add(edge);\n    }\n    addSourceModule(sourceModule) {\n        this.sourceModules.set(sourceModule.href, sourceModule);\n    }\n    cancel() {\n        this.tokenSource.cancel();\n    }\n    dispose() {\n        this.cancel();\n        this.disposer.dispose();\n    }\n    hasSourceModule(href) {\n        return this.sourceModules.has(href);\n    }\n    runAsync(key, fn) {\n        if (this.token.isCancellationRequested) {\n            return;\n        }\n        const onError = (err) => {\n            if (ret) {\n                this.pendingModuleOperations.delete(key, ret);\n            }\n            this.cancel();\n            if (!isCanceledError(err)) {\n                this.errors.push(err);\n                this.onErrorEmitter.fire({ error: err });\n            }\n        };\n        const onSuccess = () => {\n            this.pendingModuleOperations.delete(key, ret);\n            if (!this.pendingModuleOperations.size) {\n                this.onCompletedEmitter.fire({\n                    graph: new Graph({\n                        edges: this.edges,\n                        rootUri: this.rootUri,\n                        sourceModules: this.sourceModules.values(),\n                    }),\n                });\n            }\n            else {\n                this.onProgressEmitter.fire({\n                    progress: {\n                        completed: this.sourceModules.size,\n                        pending: this.pendingModuleOperations.size,\n                    },\n                });\n            }\n        };\n        let ret;\n        try {\n            ret = fn().then(onSuccess, onError);\n            this.pendingModuleOperations.add(key, ret);\n        }\n        catch (err) {\n            onError(err);\n        }\n    }\n}\nclass GraphBuilder {\n    constructor(options) {\n        this.edgesByDependency = new WeakMap();\n        this.edgesByInvalidation = new MapSet();\n        this.sourceModules = new Map();\n        this.sourceModulesByInvalidation = new MapSet();\n        this.resolver = options.resolver;\n        this.external = options.external;\n        this.nodeEnv = options.nodeEnv || 'development';\n        this.pluginManager = new PluginManager(options.plugins || []);\n    }\n    loadDependency(build, sourceModule, dep) {\n        if (build.seen.has(dep))\n            return;\n        build.seen.add(dep);\n        if (this.external && this.external(dep, sourceModule)) {\n            return;\n        }\n        // console.debug('loadDependency(%s, %s)', sourceModule.href, dep.spec);\n        build.runAsync(`${sourceModule.href}|${dep.spec}`, async () => {\n            const result = await this.pluginManager.executeResolveDependency({\n                nodeEnv: this.nodeEnv,\n                resolver: this.resolver,\n                token: build.token,\n            }, dep, sourceModule);\n            const edge = this.createEdge(sourceModule.uri, sourceModule.rootUri, result.uri, result.rootUri, result.visited, dep);\n            build.addEdge(edge);\n            this.loadEdge(build, edge);\n        });\n    }\n    loadEdge(build, edge) {\n        const href = edge.toUri.toString();\n        if (build.hasSourceModule(href))\n            return;\n        const existingSourceModule = this.sourceModules.get(href);\n        if (existingSourceModule) {\n            build.addSourceModule(existingSourceModule);\n            return this.visitSourceModule(build, existingSourceModule);\n        }\n        // console.debug(\n        //   'loadEdge(%s, %s, %s)',\n        //   edge.fromUri.toString(),\n        //   edge.dependency.spec,\n        //   edge.toUri.toString()\n        // );\n        build.runAsync(href, async () => {\n            // We need to check again in case another 'thread' already produced this\n            // sourceModule\n            if (build.hasSourceModule(href))\n                return;\n            const loadResult = await this.pluginManager.executeLoad({\n                nodeEnv: this.nodeEnv,\n                resolver: this.resolver,\n                token: build.token,\n            }, edge.toUri);\n            // We need to check again in case another 'thread' already produced this\n            // sourceModule\n            if (build.hasSourceModule(href))\n                return;\n            const transformResult = await this.pluginManager.executeTransform({\n                nodeEnv: this.nodeEnv,\n                resolver: this.resolver,\n                token: build.token,\n            }, edge.toUri, loadResult.code);\n            // We need to check again in case another 'thread' already produced this\n            // sourceModule\n            if (build.hasSourceModule(href))\n                return;\n            const parseResult = parse$1(edge.toUri, transformResult.code, {\n                globalModules: DEFAULT_SHIM_GLOBALS,\n                nodeEnv: this.nodeEnv,\n            });\n            const sourceModule = new SourceModule(edge.toUri, edge.toRootUri, parseResult.code, new Set(parseResult.dependencies), transformResult.sourceMapTree, [...transformResult.visited, ...loadResult.visited]);\n            build.addSourceModule(sourceModule);\n            this.sourceModules.set(sourceModule.href, sourceModule);\n            for (const visit of sourceModule.visits) {\n                this.sourceModulesByInvalidation.add(visit.uri.toString(), sourceModule);\n            }\n            this.sourceModulesByInvalidation.add(sourceModule.href, sourceModule);\n            this.visitSourceModule(build, sourceModule);\n        });\n    }\n    loadEntrypoint(build, uri) {\n        const href = uri.toString();\n        // console.debug('loadEntrypoint(%s)', href);\n        build.runAsync(href, async () => {\n            const result = await this.pluginManager.executeResolveEntrypoint({\n                nodeEnv: this.nodeEnv,\n                resolver: this.resolver,\n                token: build.token,\n            }, uri);\n            const edge = this.createEdge(build.rootUri, build.rootUri, result.uri, result.rootUri, result.visited, SourceModuleDependency.fromEntrypoint(uri));\n            this.loadEdge(build, edge);\n        });\n    }\n    visitSourceModule(build, sourceModule) {\n        if (build.seen.has(sourceModule))\n            return;\n        build.seen.add(sourceModule);\n        // console.debug('visitSourceModule(%s)', sourceModule.href);\n        for (const dep of sourceModule.dependencies) {\n            const existingEdge = this.edgesByDependency.get(dep);\n            if (existingEdge) {\n                build.addEdge(existingEdge);\n                this.loadEdge(build, existingEdge);\n            }\n            else {\n                this.loadDependency(build, sourceModule, dep);\n            }\n        }\n    }\n    build(entrypoints, options = {}) {\n        const rootUri = Uri.parse('velcro:/');\n        const build = new Build(rootUri, { token: options.token });\n        for (const uri of entrypoints) {\n            this.loadEntrypoint(build, Uri.isUri(uri) ? uri : Uri.parse(uri));\n        }\n        return build;\n    }\n    invalidate(uri) {\n        const href = Uri.isUri(uri) ? uri.toString() : uri;\n        const sourceModules = this.sourceModulesByInvalidation.get(href);\n        if (sourceModules) {\n            for (const sourceModule of sourceModules) {\n                this.sourceModules.delete(sourceModule.href);\n            }\n            this.sourceModulesByInvalidation.deleteAll(href);\n        }\n        this.sourceModules.delete(href);\n        const edges = this.edgesByInvalidation.get(href);\n        if (edges) {\n            for (const edge of edges) {\n                this.edgesByDependency.delete(edge.dependency);\n            }\n            this.edgesByInvalidation.deleteAll(href);\n        }\n        this.resolver.invalidate(uri);\n    }\n    createEdge(fromUri, fromRootUri, toUri, toRootUri, visited, dependency) {\n        const edge = { dependency, fromUri, fromRootUri, toUri, toRootUri, visited };\n        this.edgesByDependency.set(dependency, edge);\n        this.edgesByInvalidation.add(toUri.toString(), edge);\n        for (const visit of visited) {\n            this.edgesByInvalidation.add(visit.uri.toString(), edge);\n        }\n        return edge;\n    }\n}\n\nconst version$1 = '0.45.1';\n\nexport { Build, GraphBuildError, GraphBuilder, version$1 as version };\n//# sourceMappingURL=index.js.map\n","import styled from '@emotion/styled/macro';\nimport React, { useRef, useEffect, useContext } from 'react';\nimport { EditorManagerContext } from '../lib/EditorManager';\n\nconst Editor: React.FC<{\n  className?: string;\n}> = ({ className }) => {\n  const el = useRef<HTMLDivElement | null>(null);\n  const editorManager = useContext(EditorManagerContext);\n\n  useEffect(() => {\n    if (!el.current) {\n      return;\n    }\n\n    const editor = editorManager.mount(el.current);\n\n    return () => {\n      editor.dispose();\n    };\n  }, [editorManager, el]);\n\n  return (\n    <div className={className} ref={el}>\n      <div></div>\n    </div>\n  );\n};\n\nexport default styled(Editor)``;\n","function cssPlugin() {\n    return {\n        name: 'cssPlugin',\n        transform(ctx, uri, code) {\n            if (!uri.path.endsWith('.css')) {\n                return;\n            }\n            const cssCode = code;\n            const magicString = ctx.createMagicString();\n            const BACKSLASH = '\\\\'.charCodeAt(0);\n            const SINGLE_QUOTE = \"'\".charCodeAt(0);\n            const NL = '\\n'.charCodeAt(0);\n            const CR = '\\r'.charCodeAt(0);\n            for (let i = 0; i < cssCode.length; i++) {\n                const char = cssCode.charCodeAt(i);\n                // Escape certain characters (if not already escaped)\n                switch (char) {\n                    case CR:\n                    case NL:\n                        // Break the resulting JavaScript string across new lines\n                        // so that original css lines have a 1:1 with JavaScript lines.\n                        // This allows the resulting source-map to correct show the\n                        // original source whereas if the source had been collapsed to\n                        // a JavaScript string on a single line, all the detail is lost.\n                        magicString.overwrite(i, i + 1, \"\\\\n'\\n+'\");\n                        break;\n                    case BACKSLASH:\n                    case SINGLE_QUOTE:\n                        magicString.prependRight(i, '\\\\');\n                        break;\n                }\n            }\n            magicString.prepend(`\n        function reload(){\n          var styleTag = document.createElement(\"style\");\n          styleTag.type = \"text/css\";\n          styleTag.innerHTML = '`);\n            magicString.append(`';\n          document.head.appendChild(styleTag);\n          return {\n            dispose: function() {    \n              if (styleTag && styleTag.parentElement) {\n                styleTag.parentElement.removeChild(styleTag);\n              }\n            },\n            element: styleTag\n          };\n        };\n        var result = reload();\n        module.exports = result.element;\n        if (module.hot && module.hot.dispose) {\n          module.hot.dispose(function() {\n            result.dispose();\n          });\n        }\n      `);\n            return {\n                code: magicString.toString(),\n                sourceMap: magicString.generateDecodedMap(),\n            };\n        },\n    };\n}\n\nconst version = '0.45.1';\n\nexport { cssPlugin, version };\n//# sourceMappingURL=index.js.map\n","import { transform } from 'sucrase';\n\nfunction sucrasePlugin(options = {}) {\n    const extensions = ['js'];\n    if (options.transforms) {\n        for (const transform of options.transforms) {\n            switch (transform) {\n                case 'jsx':\n                    extensions.push('jsx');\n                    break;\n                case 'typescript':\n                    extensions.push('ts', 'tsx');\n                    break;\n            }\n        }\n    }\n    const uriTestRx = new RegExp(`\\.(?:${extensions.join('|')})$`, 'i');\n    const jsxPragmaRx = /\\/\\*\\*\\s*@jsx\\s+(\\S+)\\s*\\*+\\//;\n    const jsxFragmentPragmaRx = /\\/\\*\\*\\s*@jsxFragment\\s+(\\S+)\\s*\\*+\\//;\n    return {\n        name: 'sucrasePlugin',\n        transform(ctx, uri, code) {\n            if (!uriTestRx.test(uri.path)) {\n                return;\n            }\n            const sucraseOptions = {\n                transforms: ['imports', ...(options.transforms || [])],\n                filePath: uri.toString(),\n                production: ctx.nodeEnv === 'production',\n                sourceMapOptions: {\n                    compiledFilename: uri.toString(),\n                },\n            };\n            if (!options.jsxPragma) {\n                // If not specified try to detect the pragma\n                const jsxPragmaMatches = code.match(jsxPragmaRx);\n                if (jsxPragmaMatches) {\n                    sucraseOptions.jsxPragma = jsxPragmaMatches[1];\n                }\n            }\n            if (!options.jsxFragmentPragma) {\n                // If not specified try to detect the pragma\n                const jsxFragmentPragmaMatches = code.match(jsxFragmentPragmaRx);\n                if (jsxFragmentPragmaMatches) {\n                    sucraseOptions.jsxFragmentPragma = jsxFragmentPragmaMatches[1];\n                }\n            }\n            const result = transform(code, sucraseOptions);\n            return {\n                code: result.code,\n                sourceMap: result.sourceMap,\n            };\n        },\n    };\n}\n\nconst version = '0.45.1';\n\nexport { sucrasePlugin, version };\n//# sourceMappingURL=index.js.map\n","import { Uri, isThenable, all, EntryNotFoundError, basename, checkCancellation, parseBufferAsPackageJson } from '@velcro/common';\nimport { AbstractResolverStrategyWithRoot, ResolverStrategy, ResolverContext } from '@velcro/resolver';\nimport { validRange, satisfies } from 'semver';\n\nfunction isValidEntry(entry) {\n    if (!entry || typeof entry !== 'object')\n        return false;\n    return isValidFile(entry) || isValidDirectory(entry);\n}\nfunction isValidDirectory(entry) {\n    return (typeof entry === 'object' &&\n        entry &&\n        entry.type === ResolverStrategy.EntryKind.Directory &&\n        typeof entry.path === 'string' &&\n        entry.path &&\n        (typeof entry.files === 'undefined' ||\n            (Array.isArray(entry.files) && entry.files.every(isValidEntry))));\n}\nfunction isValidFile(entry) {\n    return (typeof entry === 'object' &&\n        entry &&\n        entry.type === ResolverStrategy.EntryKind.File &&\n        typeof entry.path === 'string' &&\n        entry.path);\n}\nfunction specToString(spec) {\n    return `${spec.spec}${spec.pathname}`;\n}\nclass JSDelivrCdn {\n    constructor() {\n        this.name = 'jsdelivr';\n        this.specRx = /^\\/((@[^/]+\\/[^/@]+|[^/@]+)(?:@([^/]+))?)(.*)?$/;\n    }\n    isValidUrl(url) {\n        return url.scheme === JSDelivrCdn.protocol || url.authority === JSDelivrCdn.host;\n    }\n    normalizePackageListing(result) {\n        if (!result || typeof result !== 'object') {\n            throw new Error(`Unexpected package listing contents`);\n        }\n        const files = result.files;\n        if (!Array.isArray(files)) {\n            throw new Error(`Unexpected package listing contents`);\n        }\n        const mapChildEntry = (parent, child) => {\n            if (!child || typeof child !== 'object') {\n                throw new Error(`Unexpected entry in package listing contents`);\n            }\n            const name = child.name;\n            if (typeof name !== 'string') {\n                throw new Error(`Unexpected entry in package listing contents`);\n            }\n            const path = `${parent}/${name}`;\n            if (child.type === ResolverStrategy.EntryKind.Directory) {\n                const files = child.files;\n                if (!Array.isArray(files)) {\n                    throw new Error(`Unexpected entry in package listing contents`);\n                }\n                return {\n                    type: ResolverStrategy.EntryKind.Directory,\n                    path,\n                    files: files.map((file) => mapChildEntry(path, file)),\n                };\n            }\n            else if (child.type === ResolverStrategy.EntryKind.File) {\n                return {\n                    type: ResolverStrategy.EntryKind.File,\n                    path,\n                };\n            }\n            throw new Error(`Error mapping child entry in package file listing`);\n        };\n        return {\n            type: ResolverStrategy.EntryKind.Directory,\n            path: '/',\n            files: files.map((file) => mapChildEntry('', file)),\n        };\n    }\n    parseUrl(url) {\n        if (Uri.isUri(url)) {\n            url = url.path;\n        }\n        const prefix = `/npm`;\n        if (!url.startsWith(prefix)) {\n            throw new Error(`Unable to parse unexpected ${this.name} url: ${url}`);\n        }\n        url = url.slice(prefix.length);\n        /**\n         * 1: scope + name + version\n         * 2: scope + name\n         * 3: version?\n         * 4: pathname\n         */\n        const matches = url.match(this.specRx);\n        if (!matches) {\n            throw new Error(`Unable to parse unexpected unpkg url: ${url}`);\n        }\n        return {\n            spec: matches[1],\n            name: matches[2],\n            version: matches[3] || '',\n            pathname: matches[4] || '',\n        };\n    }\n    urlForPackageFile(spec, pathname) {\n        return Uri.from({\n            scheme: JSDelivrCdn.protocol,\n            authority: JSDelivrCdn.host,\n            path: `/npm/${spec}${pathname}`,\n        });\n    }\n    urlForPackageList(spec) {\n        return Uri.from({\n            scheme: JSDelivrCdn.protocol,\n            authority: JSDelivrCdn.dataHost,\n            path: `/v1/package/npm/${spec}/tree`,\n        });\n    }\n}\nJSDelivrCdn.protocol = 'https';\nJSDelivrCdn.host = 'cdn.jsdelivr.net';\nJSDelivrCdn.dataHost = 'data.jsdelivr.com';\nclass UnpkgCdn {\n    constructor() {\n        this.name = 'unpkg';\n        this.UNPKG_SPEC_RX = /^\\/((@[^/]+\\/[^/@]+|[^/@]+)(?:@([^/]+))?)(.*)?$/;\n    }\n    isValidUrl(url) {\n        return url.scheme === UnpkgCdn.protocol || url.authority === UnpkgCdn.host;\n    }\n    normalizePackageListing(result) {\n        if (!isValidDirectory(result)) {\n            throw new Error(`Error normalizing directory listing`);\n        }\n        return result;\n    }\n    parseUrl(url) {\n        if (Uri.isUri(url)) {\n            url = url.path;\n        }\n        /**\n         * 1: scope + name + version\n         * 2: scope + name\n         * 3: version?\n         * 4: pathname\n         */\n        const matches = url.match(this.UNPKG_SPEC_RX);\n        if (!matches) {\n            throw new Error(`Unable to parse unexpected unpkg url: ${url}`);\n        }\n        return {\n            spec: matches[1],\n            name: matches[2],\n            version: matches[3] || '',\n            pathname: matches[4] || '',\n        };\n    }\n    urlForPackageFile(spec, pathname) {\n        return Uri.from({\n            scheme: UnpkgCdn.protocol,\n            authority: UnpkgCdn.host,\n            path: `/${spec}${pathname}`,\n        });\n    }\n    urlForPackageList(spec) {\n        return Uri.from({\n            scheme: UnpkgCdn.protocol,\n            authority: UnpkgCdn.host,\n            path: `/${spec}/`,\n            query: 'meta',\n        });\n    }\n}\nUnpkgCdn.protocol = 'https';\nUnpkgCdn.host = 'unpkg.com';\nclass CdnStrategy extends AbstractResolverStrategyWithRoot {\n    constructor(readUrlFn, cdn) {\n        super(cdn.urlForPackageFile('', ''));\n        this.contentCache = new Map();\n        this.locks = new Map();\n        this.packageEntriesCache = new Map();\n        this.packageJsonCache = new Map();\n        this.cdn = cdn;\n        this.readUrlFn = readUrlFn;\n    }\n    _withRootUriCheck(uri, fn) {\n        if (!Uri.isPrefixOf(this.rootUri, uri)) {\n            throw new Error(`This strategy is only able to handle URIs under '${this.rootUri.toString()}' and is unable to handle '${uri.toString()}'`);\n        }\n        return fn(this.rootUri);\n    }\n    async getUrlForBareModule(ctx, name, spec, path) {\n        const unresolvedUri = this.cdn.urlForPackageFile(`${name}@${spec}`, path);\n        const resolveReturn = await ctx.resolveUri(unresolvedUri);\n        return resolveReturn;\n    }\n    getCanonicalUrl(ctx, uri) {\n        return this._withRootUriCheck(uri, async () => {\n            const unresolvedSpec = this.cdn.parseUrl(uri);\n            const packageJsonReturn = ctx.runInChildContext('CdnStrategy._readPackageJsonWithCache', specToString(unresolvedSpec), (ctx) => this._readPackageJsonWithCache(ctx, unresolvedSpec));\n            const packageJson = isThenable(packageJsonReturn)\n                ? await packageJsonReturn\n                : packageJsonReturn;\n            return {\n                uri: this.cdn.urlForPackageFile(`${packageJson.name}@${packageJson.version}`, unresolvedSpec.pathname),\n            };\n        });\n        // const results = all([ctx.getRootUrl(uri), ctx.getResolveRoot(uri)], ctx.token);\n        // const [rootUriResult, resolveRootResult] = isThenable(results) ? await results : results;\n    }\n    getResolveRoot(ctx, uri) {\n        return this._withRootUriCheck(uri, async () => {\n            const unresolvedSpec = this.cdn.parseUrl(uri);\n            const packageJsonReturn = this._readPackageJsonWithCache(ctx, unresolvedSpec);\n            const packageJson = isThenable(packageJsonReturn)\n                ? await packageJsonReturn\n                : packageJsonReturn;\n            return {\n                uri: this.cdn.urlForPackageFile(`${packageJson.name}@${packageJson.version}`, '/'),\n            };\n        });\n    }\n    getRootUrl() {\n        return {\n            uri: this.cdn.urlForPackageFile('', ''),\n        };\n    }\n    listEntries(ctx, uri) {\n        return this._withRootUriCheck(uri, async () => {\n            const unresolvedSpec = this.cdn.parseUrl(uri);\n            const results = all([\n                ctx.getResolveRoot(uri),\n                this._readPackageJsonWithCache(ctx, unresolvedSpec),\n                this._readPackageEntriesWithCache(ctx, unresolvedSpec),\n            ], ctx.token);\n            const [{ uri: resolveRootUri }, packageJson, entriesReturn] = isThenable(results)\n                ? await results\n                : results;\n            const canonicalizedSpec = {\n                name: packageJson.name,\n                pathname: unresolvedSpec.pathname,\n                spec: `${packageJson.name}@${packageJson.version}`,\n                version: packageJson.version,\n            };\n            // Proactively cache the canonicalized package entries\n            this.packageEntriesCache.get(packageJson.name).set(packageJson.version, entriesReturn);\n            const traversalSegments = canonicalizedSpec.pathname.split('/').filter(Boolean);\n            let parentEntry = entriesReturn;\n            while (parentEntry && traversalSegments.length) {\n                const segment = traversalSegments.shift();\n                if (parentEntry.type !== ResolverStrategy.EntryKind.Directory || !parentEntry.files) {\n                    throw new EntryNotFoundError(uri);\n                }\n                parentEntry = parentEntry.files.find((file) => file.type === ResolverStrategy.EntryKind.Directory && basename(file.path) === segment);\n            }\n            if (!parentEntry) {\n                throw new EntryNotFoundError(uri);\n            }\n            if (!parentEntry.files) {\n                return {\n                    entries: [],\n                };\n            }\n            return {\n                entries: parentEntry.files.map((entry) => {\n                    return {\n                        type: entry.type,\n                        uri: Uri.joinPath(resolveRootUri, `.${entry.path}`),\n                    };\n                }),\n            };\n        });\n    }\n    readFileContent(ctx, uri) {\n        return this._withRootUriCheck(uri, () => {\n            const uriStr = uri.toString();\n            const cached = this.contentCache.get(uriStr);\n            if (cached === null) {\n                return Promise.reject(new EntryNotFoundError(uri));\n            }\n            if (cached) {\n                return cached;\n            }\n            ctx.recordVisit(uri, ResolverContext.VisitKind.File);\n            const readReturn = this.readUrlFn(uriStr, ctx.token);\n            if (readReturn === null) {\n                this.contentCache.set(uriStr, null);\n                return Promise.reject(new EntryNotFoundError(uri));\n            }\n            if (isThenable(readReturn)) {\n                const wrappedReturn = readReturn.then((data) => {\n                    if (data === null) {\n                        this.contentCache.delete(uriStr);\n                        return Promise.reject(new EntryNotFoundError(uri));\n                    }\n                    const entry = { content: data };\n                    this.contentCache.set(uriStr, entry);\n                    return entry;\n                });\n                this.contentCache.set(uriStr, wrappedReturn);\n                return wrappedReturn;\n            }\n            const entry = { content: readReturn };\n            this.contentCache.set(uriStr, entry);\n            return entry;\n        });\n    }\n    _readPackageEntriesWithCache(ctx, spec) {\n        ctx.debug('%s._readPackageEntriesWithCache(%s)', this.constructor.name, specToString(spec));\n        return this._withLock(`packageEntries:${spec.name}`, () => {\n            let packageEntriesCacheForModule = this.packageEntriesCache.get(spec.name);\n            if (packageEntriesCacheForModule) {\n                const exactMatch = packageEntriesCacheForModule.get(spec.version);\n                if (exactMatch) {\n                    // console.log('[HIT-EXACT] readPackageJsonWithCache(%s)', spec.spec);\n                    return exactMatch;\n                }\n                const range = validRange(spec.version);\n                if (range) {\n                    for (const [version, entries] of packageEntriesCacheForModule) {\n                        if (satisfies(version, range)) {\n                            return entries;\n                        }\n                    }\n                }\n            }\n            else {\n                packageEntriesCacheForModule = new Map();\n                this.packageEntriesCache.set(spec.name, packageEntriesCacheForModule);\n            }\n            return this._readPackageEntries(ctx, spec).then((rootDir) => {\n                packageEntriesCacheForModule.set(spec.version, rootDir);\n                return rootDir;\n            });\n        });\n    }\n    async _readPackageEntries(ctx, spec) {\n        ctx.debug('%s._readPackageEntries(%s)', this.constructor.name, specToString(spec));\n        const uri = this.cdn.urlForPackageList(spec.spec);\n        const href = uri.toString();\n        ctx.recordVisit(uri, ResolverContext.VisitKind.Directory);\n        const data = await checkCancellation(this.readUrlFn(href, ctx.token), ctx.token);\n        if (data === null) {\n            throw new EntryNotFoundError(spec);\n        }\n        const dataStr = ctx.decoder.decode(data);\n        return this.cdn.normalizePackageListing(JSON.parse(dataStr));\n    }\n    _readPackageJsonWithCache(ctx, spec) {\n        return this._withLock(`packageJson:${spec.name}`, () => {\n            let packageJsonCacheForModule = this.packageJsonCache.get(spec.name);\n            if (packageJsonCacheForModule) {\n                const exactMatch = packageJsonCacheForModule.get(spec.version);\n                if (exactMatch) {\n                    // console.log('[HIT-EXACT] readPackageJsonWithCache(%s)', spec.spec);\n                    for (const visit of exactMatch.visited) {\n                        ctx.recordVisit(visit.uri, visit.type);\n                    }\n                    return exactMatch.packageJson;\n                }\n                const range = validRange(spec.version);\n                if (range) {\n                    for (const [version, entry] of packageJsonCacheForModule) {\n                        if (satisfies(version, range)) {\n                            // console.log('[HIT] readPackageJsonWithCache(%s)', spec.spec);\n                            for (const visit of entry.visited) {\n                                ctx.recordVisit(visit.uri, visit.type);\n                            }\n                            return entry.packageJson;\n                        }\n                    }\n                }\n            }\n            else {\n                packageJsonCacheForModule = new Map();\n                this.packageJsonCache.set(spec.name, packageJsonCacheForModule);\n            }\n            return this._readPackageJson(spec, ctx).then((packageJson) => {\n                packageJsonCacheForModule.set(packageJson.version, { packageJson, visited: ctx.visited });\n                return packageJson;\n            });\n        });\n    }\n    async _readPackageJson(spec, ctx) {\n        ctx.debug('%s._readPackageJson(%s)', this.constructor.name, specToString(spec));\n        const uri = this.cdn.urlForPackageFile(spec.spec, '/package.json');\n        const contentReturn = ctx.readFileContent(uri);\n        const contentResult = isThenable(contentReturn) ? await contentReturn : contentReturn;\n        let manifest;\n        try {\n            manifest = parseBufferAsPackageJson(ctx.decoder, contentResult.content, spec.spec);\n        }\n        catch (err) {\n            throw new Error(`Error parsing manifest as json for package ${spec}: ${err.message}`);\n        }\n        // Since we know what the canonicalized version is now (we didn't until the promise resolved)\n        // and the package.json was parsed), we can proactively seed the content cache for the\n        // canonical url.\n        const canonicalHref = this.cdn\n            .urlForPackageFile(`${manifest.name}@${manifest.version}`, '/package.json')\n            .toString();\n        this.contentCache.set(canonicalHref, contentResult);\n        return manifest;\n    }\n    _withLock(lockKey, fn) {\n        const lock = this.locks.get(lockKey);\n        const runCriticalSection = () => {\n            const ret = fn();\n            if (isThenable(ret)) {\n                const locked = ret.then((result) => {\n                    this.locks.delete(lockKey);\n                    return result;\n                }, (err) => {\n                    this.locks.delete(lockKey);\n                    return Promise.reject(err);\n                });\n                this.locks.set(lockKey, locked);\n                return ret;\n            }\n            // No need to lock in non-promise\n            return ret;\n        };\n        if (isThenable(lock)) {\n            return lock.then(runCriticalSection);\n        }\n        return runCriticalSection();\n    }\n    static forJsDelivr(readUrlFn) {\n        return new CdnStrategy(readUrlFn, new JSDelivrCdn());\n    }\n    static forUnpkg(readUrlFn) {\n        return new CdnStrategy(readUrlFn, new UnpkgCdn());\n    }\n}\n\nconst version = '0.45.1';\n\nexport { CdnStrategy, version };\n//# sourceMappingURL=index.js.map\n","import { AbstractResolverStrategy } from '@velcro/resolver';\nimport { Uri } from '@velcro/common';\n\nclass CompoundStrategy extends AbstractResolverStrategy {\n    constructor(options) {\n        super();\n        this.strategies = new Set(options.strategies);\n    }\n    _delegateToStrategy(method, ctx, uri) {\n        for (const strategy of this.strategies) {\n            if (Uri.isPrefixOf(strategy.rootUri, uri)) {\n                return strategy[method](ctx, uri);\n            }\n        }\n        return Promise.reject(new Error(`No strategy found whose root is a prefix of ${uri}`));\n    }\n    getCanonicalUrl(ctx, uri) {\n        return this._delegateToStrategy('getCanonicalUrl', ctx, uri);\n    }\n    getResolveRoot(ctx, uri) {\n        return this._delegateToStrategy('getResolveRoot', ctx, uri);\n    }\n    getUrlForBareModule(ctx, name, spec, path) {\n        for (const strategy of this.strategies) {\n            if (strategy.getUrlForBareModule) {\n                return strategy.getUrlForBareModule(ctx, name, spec, path);\n            }\n        }\n        return {\n            found: false,\n            uri: null,\n        };\n    }\n    listEntries(ctx, uri) {\n        return this._delegateToStrategy('listEntries', ctx, uri);\n    }\n    readFileContent(ctx, uri) {\n        return this._delegateToStrategy('readFileContent', ctx, uri);\n    }\n}\n\nconst version = '0.45.1';\n\nexport { CompoundStrategy, version };\n//# sourceMappingURL=index.js.map\n","import { Graph, GraphBuilder } from '@velcro/bundler';\nimport { CancellationTokenSource, DisposableStore, Emitter, Event, Uri } from '@velcro/common';\nimport { cssPlugin } from '@velcro/plugin-css';\nimport { sucrasePlugin } from '@velcro/plugin-sucrase';\nimport { Resolver } from '@velcro/resolver';\nimport { CdnStrategy } from '@velcro/strategy-cdn';\nimport { CompoundStrategy } from '@velcro/strategy-compound';\nimport { MemoryStrategy } from '@velcro/strategy-memory';\nimport * as Monaco from 'monaco-editor';\n\nconst readUrl = (href: string) => fetch(href).then((res) => res.arrayBuffer());\n\ntype DefineEvent<TEventName extends string, TData = never> = {\n  eventName: TEventName;\n  data: TData;\n};\ntype AnyEvent = DefineEvent<string, unknown>;\ntype EventWithData<TEvent extends AnyEvent> = TEvent extends AnyEvent\n  ? [TEvent['data']] extends [never]\n    ? never\n    : TEvent\n  : never;\ntype EventWithoutData<TEvent extends AnyEvent> = Exclude<TEvent, EventWithData<TEvent>>;\n\ntype DefineState<TStateName extends string, TData = never> = TStateName extends string\n  ? [TData] extends [never]\n    ? {\n        stateName: TStateName;\n      }\n    : {\n        stateName: TStateName;\n        data: TData;\n      }\n  : never;\ntype AnyState = DefineState<string, unknown>;\n\ntype BuilderState =\n  | DefineState<'initial'>\n  | DefineState<'dirty'>\n  | DefineState<'waiting'>\n  | DefineState<'building', { pending: number; completed: number }>\n  | DefineState<'built', { graph: Graph; latency: number }>\n  | DefineState<'error', { error: Error; latency: number }>;\n\ntype BuilderEvent =\n  | DefineEvent<'build'>\n  | DefineEvent<'change', { uri: Uri }>\n  | DefineEvent<'timer_fired'>\n  | DefineEvent<'build_error', { error: Error; start: number }>\n  | DefineEvent<'build_progress', { pending: number; completed: number }>\n  | DefineEvent<'build_complete', { graph: Graph; start: number }>;\n\nexport class VelcroMonaco {\n  private readonly disposer = new DisposableStore();\n  private readonly fsm: {\n    states: {\n      [TStateName in BuilderState['stateName']]: {\n        onEnter?(ctx: {\n          event: BuilderEvent;\n          state: Extract<BuilderState, { stateName: TStateName }>;\n        }): void;\n        onEvent?: {\n          [TEventName in BuilderEvent['eventName']]?: (ctx: {\n            event: Extract<BuilderEvent, { eventName: TEventName }>;\n            state: Extract<BuilderState, { stateName: TStateName }>;\n          }) => void;\n        };\n        onExit?(ctx: {\n          event: BuilderEvent;\n          state: Extract<BuilderState, { stateName: TStateName }>;\n        }): void;\n      };\n    };\n  } = {\n    states: {\n      initial: {\n        onEvent: {\n          build: ({ event }) =>\n            this.transitionTo({ stateName: 'building', data: { pending: 0, completed: 0 } }, event),\n          change: ({ event }) => this.transitionTo({ stateName: 'dirty' }, event),\n        },\n      },\n      dirty: {\n        onEnter: ({ event }) => {\n          if (event.eventName === 'change') {\n            // Mark the uri as invalidated so that any source files or dependencies\n            // that relied on that uri are also invalidated.\n            this.graphBuilder.invalidate(event.data.uri);\n\n            // Also invalidate the containing directory in case some resolutions\n            // might have relied on the contents of that directory. We don't need\n            // to walk up the tree though, since only the contents of the immediate\n            // parent might have changed.\n            // const parentUri = Uri.joinPath(event.data.uri, '..');\n            // if (!Uri.equals(event.data.uri, parentUri)) {\n            //   this.graphBuilder.invalidate(Uri.ensureTrailingSlash(parentUri));\n            // }\n          }\n\n          if (this.buildConfig.autoBuild) {\n            this.transitionTo({ stateName: 'waiting' }, event);\n          }\n        },\n        onEvent: {\n          build: ({ event }) =>\n            this.transitionTo({ stateName: 'building', data: { completed: 0, pending: 0 } }, event),\n        },\n      },\n      waiting: {\n        onEnter: () => {\n          const timerHandle = setTimeout(() => {\n            this.sendEvent('timer_fired');\n          }, this.buildConfig.autoBuildWaitTimeout);\n\n          this.stateDisposer.add({\n            dispose: () => {\n              clearTimeout(timerHandle);\n            },\n          });\n        },\n        onEvent: {\n          build: ({ event }) =>\n            this.transitionTo({ stateName: 'building', data: { completed: 0, pending: 0 } }, event),\n          change: ({ event }) => this.transitionTo({ stateName: 'dirty' }, event),\n          timer_fired: ({ event }) =>\n            this.transitionTo({ stateName: 'building', data: { completed: 0, pending: 0 } }, event),\n        },\n      },\n      building: {\n        onEnter: () => {\n          const tokenSource = new CancellationTokenSource();\n          const start = Date.now();\n          const build = this.graphBuilder.build([this.localStrategy.rootUri], {\n            incremental: false,\n            token: tokenSource.token,\n          });\n\n          this.stateDisposer.add({\n            dispose() {\n              tokenSource.dispose(true);\n            },\n          });\n          this.stateDisposer.add(\n            build.onCompleted(({ graph }) => this.sendEvent('build_complete', { graph, start }))\n          );\n          this.stateDisposer.add(\n            build.onProgress(({ progress }) => this.sendEvent('build_progress', progress))\n          );\n          this.stateDisposer.add(\n            build.onError(({ error }) => {\n              return this.sendEvent('build_error', { error, start });\n            })\n          );\n\n          this.graphBuilder.build([this.localStrategy.rootUri], {\n            incremental: false,\n            token: tokenSource.token,\n          });\n        },\n        onEvent: {\n          build_complete: ({ event }) =>\n            this.transitionTo(\n              {\n                stateName: 'built',\n                data: { graph: event.data.graph, latency: Date.now() - event.data.start },\n              },\n              event\n            ),\n          build_error: ({ event }) =>\n            this.transitionTo(\n              {\n                stateName: 'error',\n                data: { error: event.data.error, latency: Date.now() - event.data.start },\n              },\n              event\n            ),\n          build_progress: ({ event }) =>\n            this.transitionTo(\n              {\n                stateName: 'building',\n                data: { completed: event.data.completed, pending: event.data.pending },\n              },\n              event\n            ),\n          change: ({ event }) => this.transitionTo({ stateName: 'dirty' }, event),\n        },\n      },\n      built: {\n        onEvent: {\n          build: ({ event }) =>\n            this.transitionTo({ stateName: 'building', data: { completed: 0, pending: 0 } }, event),\n          change: ({ event }) => this.transitionTo({ stateName: 'dirty' }, event),\n        },\n      },\n      error: {\n        onEvent: {\n          build: ({ event }) =>\n            this.transitionTo({ stateName: 'building', data: { completed: 0, pending: 0 } }, event),\n          change: ({ event }) => this.transitionTo({ stateName: 'dirty' }, event),\n        },\n      },\n    },\n  };\n\n  private readonly onStateChangeEmitter = new Emitter<Readonly<BuilderState>>();\n\n  private readonly localStrategy = new MemoryStrategy({}, Uri.file('/'));\n  private readonly npmStrategy = CdnStrategy.forJsDelivr(readUrl);\n  private readonly rootStrategy = new CompoundStrategy({\n    strategies: [this.localStrategy, this.npmStrategy],\n  });\n  private readonly resolver: Resolver;\n  private readonly graphBuilder: GraphBuilder;\n\n  private mutableBuildState: BuilderState = { stateName: 'initial' };\n\n  public readonly buildConfig = {\n    autoBuild: false,\n    autoBuildWaitTimeout: 500,\n  };\n\n  private pendingEvents: BuilderEvent[] = [];\n\n  sendEvent<TSentEvent extends EventWithoutData<BuilderEvent>>(\n    event: TSentEvent['eventName']\n  ): void;\n  sendEvent<TSentEvent extends EventWithData<BuilderEvent>>(\n    event: TSentEvent['eventName'],\n    data: TSentEvent['data']\n  ): void;\n  sendEvent<TSentEvent extends BuilderEvent>(\n    eventName: TSentEvent['eventName'],\n    data?: TSentEvent['data']\n  ): void {\n    // console.group();\n    // console.log('sendEvent(%s, %s)', this.state.stateName, eventName, data);\n    this.pendingEvents.push({ eventName, data } as BuilderEvent);\n\n    while (this.pendingEvents.length) {\n      const event = this.pendingEvents.shift()!;\n      const currentStateDef = this.fsm.states[this.mutableBuildState.stateName];\n\n      // console.group();\n      // console.log('sendEvent(%s, %s) handle(%s)', this.state.stateName, eventName, event.eventName);\n\n      if (currentStateDef.onEvent) {\n        const handler = currentStateDef.onEvent[event.eventName];\n        const state = this.state;\n\n        if (handler) {\n          handler({ event, state } as any);\n        }\n      }\n      // console.groupEnd();\n    }\n    // console.groupEnd();\n  }\n\n  private readonly stateDisposer = new DisposableStore();\n\n  transitionTo<TTargetState extends BuilderState, TTriggeringEvent extends BuilderEvent>(\n    state: TTargetState,\n    event: TTriggeringEvent\n  ) {\n    // console.log('transitionTo(%s, %s, %s)', this.state.stateName, state.stateName, event.eventName);\n    // console.group();\n    const nextStateConfig = this.fsm.states[state.stateName];\n    const fromState = { ...this.mutableBuildState };\n\n    this.mutableBuildState = { ...state };\n    this.onStateChangeEmitter.fire(this.state);\n\n    if (state.stateName !== fromState.stateName) {\n      this.stateDisposer.clear();\n\n      if (nextStateConfig.onEnter) {\n        // console.log('onEnter(%s, %s)', this.state.stateName, event.eventName);\n        // console.group();\n        nextStateConfig.onEnter({ event, state } as any);\n        // console.groupEnd();\n      }\n    }\n    // console.groupEnd();\n  }\n\n  constructor(\n    monaco: typeof import('monaco-editor'),\n    options: { autoBuild?: boolean; autoBuildWaitTimeout?: number } = {}\n  ) {\n    if (options.autoBuild) {\n      this.buildConfig.autoBuild = options.autoBuild;\n    }\n    if (options.autoBuildWaitTimeout) {\n      this.buildConfig.autoBuildWaitTimeout = options.autoBuildWaitTimeout;\n    }\n\n    this.resolver = new Resolver(this.rootStrategy, {\n      debug: false,\n      extensions: ['.js', '.jsx', '.json', '.ts', '.tsx', '.mjs', '.cjs'],\n      packageMain: ['browser', 'main'],\n    });\n    this.graphBuilder = new GraphBuilder({\n      resolver: this.resolver,\n      nodeEnv: 'development',\n      plugins: [cssPlugin(), sucrasePlugin({ transforms: ['imports', 'jsx', 'typescript'] })],\n    });\n\n    this.disposer.add(this.resolver);\n    // this.disposer.add(this.graphBuilder);\n\n    // Track existing models\n    for (const model of monaco.editor.getModels()) {\n      if (!Uri.isPrefixOf(this.localStrategy.rootUri, model.uri)) {\n        continue;\n      }\n\n      this.trackModel(model);\n    }\n\n    // And future models\n    monaco.editor.onDidCreateModel((model) => {\n      if (!Uri.isPrefixOf(this.localStrategy.rootUri, model.uri)) {\n        return;\n      }\n\n      this.trackModel(model);\n    });\n  }\n\n  get onStateChange(): Event<Readonly<BuilderState>> {\n    return this.onStateChangeEmitter.event;\n  }\n\n  get state(): Readonly<BuilderState> {\n    return this.mutableBuildState;\n  }\n\n  dispose() {\n    this.disposer.dispose();\n  }\n\n  startBuild() {\n    this.sendEvent('build');\n  }\n\n  private handleChange(uri: Uri) {\n    this.sendEvent('change', { uri });\n  }\n\n  private trackModel(model: Monaco.editor.ITextModel) {\n    model.onWillDispose(() => {\n      this.localStrategy.removeFile(model.uri.fsPath);\n      this.handleChange(Uri.from(model.uri));\n      disposerReference.dispose();\n    });\n\n    this.localStrategy.addFile(model.uri.fsPath, model.getValue());\n\n    const disposerReference = this.disposer.add(\n      model.onDidChangeContent(() => {\n        this.localStrategy.addFile(model.uri.fsPath, model.getValue(), {\n          overwrite: true,\n        });\n        this.handleChange(Uri.from(model.uri));\n      })\n    );\n\n    this.handleChange(Uri.from(model.uri));\n  }\n}\n","import styled from '@emotion/styled/macro';\nimport { Uri } from '@velcro/common';\nimport * as Monaco from 'monaco-editor';\nimport React, { useContext, useEffect, useRef, useState } from 'react';\nimport { EditorManagerContext } from '../lib/EditorManager';\nimport { VelcroMonaco } from '../velcro';\n\nexport interface DeferredExecutionModuleRecord {\n  code: string;\n  dependencies: Record<string, string>;\n}\n\nexport interface DeferredExecutionManifest {\n  aliases: Record<string, string>;\n  entrypoints: Record<string, string>;\n  modules: Record<string, DeferredExecutionModuleRecord>;\n}\n\ninterface MessageLine {\n  isInternal: boolean;\n  text: string;\n}\ninterface Message {\n  lines: MessageLine[];\n}\n\nconst PreviewProgress = styled.div<{ completed: number; total: number }>`\n  z-index: 1;\n  position: absolute;\n  top: 0;\n  width: ${(props) => (props.total ? `${Math.round((100 * props.completed) / props.total)}%` : 0)};\n  left: 0;\n  height: ${(props) => (props.total ? '2px' : '0')};\n  background-color: #008cba;\n  transition: width 0.5s 0s cubic-bezier(0.455, 0.03, 0.515, 0.955);\n`;\nconst PreviewIframeWrap = styled.div`\n  position: relative;\n  overflow: hidden;\n\n  & > iframe {\n    position: absolute;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n    border: none;\n    width: 100%;\n    height: 100%;\n  }\n`;\nconst PreviewWrap = styled.div`\n  position: relative;\n  background: white;\n\n  ${PreviewIframeWrap} {\n    position: absolute;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n  }\n`;\nconst PreviewMessageError = styled.ul`\n  margin: 0;\n  padding: 1em 2em;\n  font-family: monospace;\n  font-size: 16px;\n  background-color: rgba(255, 0, 0, 0.5);\n  backdrop-filter: brightness(50%);\n  color: white;\n  list-style: none;\n`;\nconst PreviewMessageErrorText = styled.li<{ isInternal: boolean }>`\n  white-space: pre-wrap;\n  opacity: ${(props) => (props.isInternal ? 0.7 : 1.0)};\n`;\nconst PreviewMessages = styled.div`\n  z-index: 1;\n  position: absolute;\n  bottom: 0;\n  right: 0;\n  left: 0;\n  display: flex;\n  flex-direction: column-reverse;\n`;\nconst PreviewMessageLine: React.FC<{ line: MessageLine }> = ({ line }) => {\n  return (\n    <PreviewMessageErrorText isInternal={line.isInternal}>{line.text}</PreviewMessageErrorText>\n  );\n};\nconst PreviewMessage: React.FC<{ message: Message }> = ({ message }) => {\n  return message.lines.length ? (\n    <PreviewMessageError>\n      {message.lines.map((line, i) => (\n        <PreviewMessageLine key={i} line={line}></PreviewMessageLine>\n      ))}\n    </PreviewMessageError>\n  ) : null;\n};\n\nconst Preview: React.FC<{ className?: string }> = (props) => {\n  const editorManager = useContext(EditorManagerContext);\n  const previewWrapRef = useRef<HTMLDivElement | null>(null);\n  const previewIframeRef = useRef<HTMLIFrameElement | null>(null);\n  const [buildState, setBuildState] = useState<VelcroMonaco['state']>({ stateName: 'initial' });\n  const [messages, setMessages] = useState([] as Message[]);\n  const [buildProgress, setBuildProgress] = useState({ completed: 0, total: 0 });\n\n  useEffect(() => {\n    const onMessage = (e: MessageEvent) => {\n      if (\n        previewIframeRef.current &&\n        previewIframeRef.current.contentWindow === e.source &&\n        e.data.event === 'click_error'\n      ) {\n        console.log(e);\n        editorManager.focusPath(Uri.parse(e.data.entry.file).fsPath, {\n          columnNumber: e.data.entry.column,\n          lineNumber: e.data.entry.line,\n        });\n      }\n    };\n\n    window.addEventListener('message', onMessage);\n\n    return () => window.removeEventListener('message', onMessage);\n  });\n\n  useEffect(() => {\n    const velcro = new VelcroMonaco(Monaco, {\n      autoBuild: true,\n      autoBuildWaitTimeout: 500,\n    });\n\n    velcro.onStateChange((state) => {\n      setBuildState(state);\n\n      switch (state.stateName) {\n        case 'building': {\n          setBuildProgress({\n            completed: state.data.completed,\n            total: state.data.completed + state.data.pending,\n          });\n          break;\n        }\n        case 'built': {\n          const graph = state.data.graph;\n          const [chunk] = graph.splitChunks();\n          const build = chunk.buildForStaticRuntime({\n            injectRuntime: true,\n          });\n          const codeWithStart = `${build.code}\\n\\n${[Uri.file('/index.jsx')]\n            .map(\n              (entrypoint) => `Velcro.runtime.require(${JSON.stringify(entrypoint.toString())});`\n            )\n            .join('\\n')}\\n`;\n          const runtimeCode = `${codeWithStart}\\n//# sourceMappingURL=${build.sourceMapDataUri}`;\n          const codeBundleFile = new File([runtimeCode], Uri.file('/index.jsx').toString(), {\n            type: 'text/javascript',\n          });\n\n          const markup = new File(\n            [\n              `\n    <!DOCTYPE html>\n    <html lang=\"en\">\n    <head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n    <script src=\"https://cdn.jsdelivr.net/npm/panic-overlay/build/panic-overlay.browser.js\"></script>\n    <title>Document</title>\n    </head>\n    <body>\n    <div id=\"root\"></div>\n    <script src=\"${URL.createObjectURL(codeBundleFile)}\"></script>\n    <script>\n      panic.configure ({\n        stackEntryClicked (entry) {\n          if (window.parent) {\n            window.parent.postMessage({\n              event: 'click_error',\n              entry: {\n                column: entry.column,\n                file: entry.file,\n                line: entry.line,\n              }\n            });\n          }\n        }\n      })\n    </script>\n    </body>\n    </html>`,\n            ],\n            Uri.file('/index.html').toString(),\n            {\n              type: 'text/html',\n            }\n          );\n          const htmlUrl = URL.createObjectURL(markup);\n          const iframe = document.createElement('iframe');\n          iframe.style.display = 'none';\n          iframe.src = htmlUrl;\n\n          if (previewWrapRef.current) {\n            previewWrapRef.current.appendChild(iframe);\n          }\n\n          const onLoad = () => {\n            iframe.removeEventListener('error', onError);\n            iframe.style.display = '';\n\n            if (previewIframeRef.current) {\n              previewIframeRef.current.remove();\n            }\n\n            previewIframeRef.current = iframe;\n          };\n          const onError = () => {\n            iframe.removeEventListener('load', onLoad);\n            iframe.remove();\n          };\n\n          iframe.addEventListener('load', onLoad, { once: true });\n          iframe.addEventListener('error', onError, { once: true });\n\n          break;\n        }\n        case 'error': {\n          setMessages([{ lines: [{ isInternal: true, text: state.data.error.message }] }]);\n          break;\n        }\n      }\n    });\n\n    return () => velcro.dispose();\n  }, [setBuildProgress, setBuildState]);\n\n  return (\n    <PreviewWrap className={props.className}>\n      {buildState.stateName === 'building' ? (\n        <PreviewProgress\n          completed={buildProgress.completed}\n          total={buildProgress.total}\n        ></PreviewProgress>\n      ) : null}\n      <PreviewIframeWrap ref={previewWrapRef}></PreviewIframeWrap>\n      <PreviewMessages>\n        {buildState.stateName === 'error' ? (\n          <PreviewMessage\n            message={{ lines: [{ isInternal: true, text: buildState.data.error.message }] }}\n          ></PreviewMessage>\n        ) : null}\n      </PreviewMessages>\n    </PreviewWrap>\n  );\n};\n\nexport default styled(Preview)``;\n","import { DisposableStore } from '@velcro/common';\nimport * as Monaco from 'monaco-editor';\nimport { useEffect, useState } from 'react';\n\n// import { EditorContext } from './context';\n\nexport enum EntryKind {\n  Directory = 'directory',\n  File = 'file',\n}\n\nexport interface IDirectory {\n  type: EntryKind.Directory;\n  uri: Monaco.Uri;\n}\nexport interface IFile {\n  type: EntryKind.File;\n  uri: Monaco.Uri;\n  model: Monaco.editor.ITextModel;\n}\n\nexport type DirectoryEntry = IDirectory | IFile;\n\nexport function useDirectory(uri: Monaco.Uri) {\n  // Make sure the URI always ends with a trailing slash\n  const prefix = uri.toString(true).replace(/\\/?$/, '/');\n  const sortEntries = (models: DirectoryEntry[]) => {\n    return [...models].sort((a, b) => (a.uri.fsPath > b.uri.fsPath ? 1 : -1));\n  };\n\n  const initialEntries = sortEntries(\n    Monaco.editor.getModels().reduce((entries, model) => {\n      const modelUri = model.uri.toString(true);\n\n      if (modelUri.startsWith(prefix)) {\n        const nestedPath = modelUri.slice(prefix.length);\n        const nextDirIdx = nestedPath.indexOf('/');\n\n        if (nextDirIdx === 0) {\n          throw new Error('Invariant error: WAT?');\n        }\n\n        if (nextDirIdx > 0) {\n          // This is an intermediate directory\n          const uri = Monaco.Uri.parse(`${prefix}${nestedPath.slice(0, nextDirIdx + 1)}`);\n\n          entries.push({\n            type: EntryKind.Directory,\n            uri,\n          });\n        } else {\n          entries.push({\n            type: EntryKind.File,\n            uri: model.uri,\n            model,\n          });\n        }\n      }\n\n      return entries;\n    }, [] as DirectoryEntry[])\n  );\n  const [entries, setEntries] = useState(initialEntries);\n\n  useEffect(() => {\n    const disposable = new DisposableStore();\n    const prefix = uri.toString(true).replace(/\\/?$/, '/');\n\n    disposable.add(\n      Monaco.editor.onDidCreateModel((model: Monaco.editor.ITextModel) => {\n        const modelUri = model.uri.toString(true);\n\n        if (modelUri.startsWith(prefix)) {\n          const nestedPath = modelUri.slice(prefix.length);\n          const nextDirIdx = nestedPath.indexOf('/');\n\n          if (nextDirIdx === 0) {\n            throw new Error('Invariant error: WAT?');\n          }\n\n          if (nextDirIdx > 0) {\n            // This is an intermediate directory\n            const uri = Monaco.Uri.parse(`${prefix}${nestedPath.slice(0, nextDirIdx)}`);\n\n            // It is possible that we already have this directory\n            const entry = entries.find((entry) => entry.uri.toString(true) === uri.toString(true));\n\n            if (entry) {\n              if (entry.type !== EntryKind.Directory) {\n                throw new Error(\n                  `Invariant violation: A file in '${prefix}' conflicts with the path of the new file '${modelUri}'`\n                );\n              }\n\n              return;\n            }\n\n            entries.push({ type: EntryKind.Directory, uri });\n\n            return setEntries(sortEntries(entries));\n          }\n\n          if (\n            !entries.find(\n              (entry) =>\n                entry.type === EntryKind.File &&\n                entry.uri.toString(true) === model.uri.toString(true)\n            )\n          ) {\n            entries.push({ type: EntryKind.File, uri: model.uri, model });\n\n            setEntries(sortEntries(entries));\n          }\n        }\n      })\n    );\n\n    disposable.add(\n      Monaco.editor.onWillDisposeModel((model) => {\n        const idx = entries.findIndex(\n          (entry) => entry.type === EntryKind.File && entry.model === model\n        );\n\n        if (idx === -1) {\n          throw new Error(\n            `Invariant violation: Removing an untracked model: '${model.uri.fsPath}'`\n          );\n        }\n\n        entries.splice(idx, 1);\n\n        setEntries(sortEntries(entries));\n      })\n    );\n\n    return () => disposable.dispose();\n  }, [entries, uri]);\n\n  return entries;\n}\n","import styled from '@emotion/styled/macro';\nimport * as Monaco from 'monaco-editor';\nimport React, { useContext, useRef } from 'react';\nimport { Button } from 'reakit/Button';\nimport { Tooltip, TooltipReference, useTooltipState } from 'reakit/Tooltip';\nimport { useDirectory, EntryKind } from '../lib/hooks';\nimport { useActiveModel, EditorManagerContext } from '../lib/EditorManager';\n\nconst Entry = styled.div<{ modelFocused: boolean }>`\n  background-color: ${props => (props.modelFocused ? '#008cba' : 'inherit')};\n  text-decoration: none;\n  color: ${props => (props.modelFocused ? '#fff' : '#262626')};\n\n  height: 25px;\n  padding: 0 0 0 8px;\n  display: flex;\n  flex-direction: row;\n  align-items: center;\n\n  & > span {\n    flex: 1;\n  }\n\n  & > button {\n    display: none;\n  }\n\n  &:hover > button {\n    display: block;\n  }\n\n  ${props =>\n    props.modelFocused\n      ? {\n          ':hover': {\n            color: '#f5f5f5',\n            cursor: 'pointer',\n          },\n        }\n      : {\n          ':hover': {\n            backgroundColor: '#eee',\n            color: '#262626',\n            cursor: 'pointer',\n          },\n        }}\n`;\n\nconst CreateEntry = styled.div`\n  text-decoration: none;\n  color: '#262626';\n\n  height: 25px;\n  padding: 0 0 0 8px;\n  display: flex;\n  align-items: center;\n\n  :hover {\n    background-color: #eee;\n    cursor: pointer;\n  }\n`;\n\nconst SidebarFileDelete = styled(Button)`\n  border: none;\n  background: none;\n\n  :hover {\n    cursor: pointer;\n  }\n`;\n\nconst StyledTooltip = styled.div`\n  font-family: Open Sans, Helvetica Neue, Helvetica, Arial, sans-serif;\n  font-size: 14px;\n  line-height: 1.4;\n  background-color: #333;\n  color: #fff;\n  border-radius: 4px;\n  opacity: 0.9;\n  padding: 0.2em 0.4em;\n`;\n\nconst SidebarFile: React.FC<{ className?: string; model: Monaco.editor.ITextModel }> = ({ className, model }) => {\n  const activeModel = useActiveModel();\n  const editorManager = useContext(EditorManagerContext);\n  const tooltip = useTooltipState({ gutter: 0 });\n\n  const onClickDelete = () => {\n    model.dispose();\n  };\n\n  return (\n    <Entry className={className} modelFocused={model === activeModel}>\n      <span onClick={() => editorManager.focusModel(model)}>{model.uri.fsPath.slice(1)}</span>\n      <TooltipReference {...tooltip} as={SidebarFileDelete} onClick={() => onClickDelete()}>\n        <span role=\"img\" aria-label=\"Delete file\">\n          ❌\n        </span>\n      </TooltipReference>\n      <Tooltip {...tooltip} as={StyledTooltip}>\n        Delete file\n      </Tooltip>\n    </Entry>\n  );\n};\n\nconst Sidebar: React.FC<{ className?: string }> = props => {\n  const rootDir = useRef(Monaco.Uri.file('/'));\n  const entries = useDirectory(rootDir.current);\n  const editorManager = useContext(EditorManagerContext);\n\n  const onClickCreate = () => {\n    const filename = prompt('Filename?');\n\n    if (filename) {\n      editorManager.createModel(filename);\n    }\n  };\n\n  return (\n    <div className={props.className}>\n      {entries.map(entry =>\n        entry.type === EntryKind.Directory ? (\n          <div>{entry.uri.fsPath.slice(1)}</div>\n        ) : (\n          <SidebarFile key={entry.uri.toString(true)} model={entry.model}></SidebarFile>\n        )\n      )}\n      <CreateEntry onClick={() => onClickCreate()}>Create...</CreateEntry>\n    </div>\n  );\n};\n\nexport default styled(Sidebar)`\n  display: flex;\n  flex-direction: column;\n`;\n","import styled from '@emotion/styled/macro';\nimport React from 'react';\n\nimport Editor from './Editor';\nimport Preview from './Preview';\nimport Sidebar from './Sidebar';\nimport { EditorManager, EditorManagerContext } from '../lib/EditorManager';\n\nconst PlaygroundCmp: React.FC<{\n  className?: string;\n  initialPath: string;\n  project: Record<string, string>;\n}> = ({ className, initialPath, project }) => {\n  const editorManager = new EditorManager({ files: project, initialPath: initialPath });\n\n  return (\n    <div className={className}>\n      <EditorManagerContext.Provider value={editorManager}>\n        <Sidebar></Sidebar>\n        <Editor></Editor>\n        <Preview></Preview>\n      </EditorManagerContext.Provider>\n    </div>\n  );\n};\n\nexport const Playground = styled(PlaygroundCmp)`\n  display: flex;\n  flex-direction: row;\n\n  font-family: Open Sans, Helvetica Neue, Helvetica, Arial, sans-serif;\n  font-size: 14px;\n  line-height: 1.4;\n\n  color: #222;\n\n  ${Sidebar} {\n    flex: 1 1 100px;\n    min-width: 100px;\n    max-width: 400px;\n    border-right: 1px solid #ccc;\n  }\n\n  ${Editor} {\n    border-right: 1px solid #ccc;\n  }\n\n  ${Editor}, ${Preview} {\n    flex: 10;\n  }\n`;\n","export const files: Record<string, string> = {\n  'package.json':\n    JSON.stringify(\n      {\n        name: 'react-template',\n        version: '0.0.0',\n        dependencies: {\n          'github-markdown-css': '^3.0.1',\n          react: '^16.9.0',\n          'react-dom': '^16.9.0',\n        },\n      },\n      null,\n      2\n    ) + '\\n',\n  'app.jsx': `\nimport React, { Component } from 'react';\nimport 'github-markdown-css';\n\nimport { Explanation } from './explanation';\nimport { name } from './name';\nimport './style.css';\n\nclass Hello extends Component {\n  render() {\n    return <div className=\"markdown-body\">\n      <h1>Hello {name}</h1>\n      <blockquote>There is no <del>spoon</del> server</blockquote>\n      <Explanation/>\n    </div>;\n  }\n}\n\nexport default Hello\n  `.trim(),\n  'explanation.jsx':\n    `\nimport React from 'react';\n\nexport const Explanation = () => <>\n  <section>\n    <h2>What is this?</h2>\n    <p>\n      This is a demo of bundling and serving a browser-based sandbox fully from the browser. <strong>There are <em>no</em> servers involved</strong> except the static server hosting this demo and <a href=\"https://unpkg.com\" target=\"_blank\" rel=\"noopener\">unpkg.com</a>. All module resolution, transpilation and bundling is happening in the browser.\n    </p>\n    <p>\n      Try it. Go offline, and reload...\n    </p>\n    <p>\n      <strong>I dare you.</strong>\n    </p>\n  </section>\n  <section>\n    <h2>Features</h2>\n    <ul>\n      <li>Full offline support. Once your cache is seeded, you can cut the cord.</li>\n      <li>Fully browser-based bundling.</li>\n      <li>Add (almost) any node module and no server is involved.</li>\n      <li>If you want to add another module, make sure to add it to <code>package.json</code> first.</li>\n      <li>Automatic type acquisition for full typings support in the browser, in JavaScript!</li>\n      <li>Resolve source locations in stack traces</li>\n      <li>Hot module reloading</li>\n    </ul>\n  </section>\n</>;\n    `.trim() + '\\n',\n  'index.jsx':\n    `\nimport React, { Component } from 'react';\nimport ReactDOM from 'react-dom';\n\nimport App from './app';\n  \nReactDOM.render(\n  <App/>,\n  document.getElementById('root')\n);\n      `.trim() + '\\n',\n  'name.js':\n    `\nexport const name = 'Velcro';\n    `.trim() + '\\n',\n  'style.css':\n    `\n.markdown-body {\n  box-sizing: border-box;\n  min-width: 200px;\n  max-width: 980px;\n  margin: 0 auto;\n  padding: 45px;\n}\n\n@media (max-width: 767px) {\n  .markdown-body {\n    padding: 15px;\n  }\n}\n    `.trim() + '\\n',\n};\n","import React from 'react';\n\n// import * as serviceWorker from './serviceWorker';\n\ninterface ServiceWorkerEvent extends Event {\n  target: (Partial<ServiceWorker> & EventTarget) | null;\n}\n\ninterface ServiceWorkerContextValue {\n  assetsUpdateReady: boolean;\n  assetsCached: boolean;\n  updateAssets(): void;\n}\n\nconst ServiceWorkerContext = React.createContext<ServiceWorkerContextValue | undefined>(undefined);\n\nexport function ServiceWorkerProvider(props: React.PropsWithChildren<{}>) {\n  const [waitingServiceWorker, setWaitingServiceWorker] = React.useState<ServiceWorker | null>(\n    null\n  );\n  const [assetsUpdateReady, setAssetsUpdateReady] = React.useState(false);\n  const [assetsCached, setAssetsCached] = React.useState(false);\n\n  const value = React.useMemo(() => {\n    return {\n      assetsUpdateReady,\n      assetsCached,\n      // Call when the user confirm update of application and reload page\n      updateAssets: () => {\n        if (waitingServiceWorker) {\n          waitingServiceWorker.addEventListener('statechange', (event: ServiceWorkerEvent) => {\n            if (event.target && event.target.state === 'activated') {\n              window.location.reload();\n            }\n          });\n\n          waitingServiceWorker.postMessage({ type: 'SKIP_WAITING' });\n        }\n      },\n    };\n  }, [assetsUpdateReady, assetsCached, waitingServiceWorker]);\n\n  // Once on component mounted subscribe to Update and Succes events in\n  // CRA's service worker wrapper\n  // React.useEffect(() => {\n  //   serviceWorker.register({\n  //     onUpdate: (registration) => {\n  //       setWaitingServiceWorker(registration.waiting);\n  //     },\n  //     onUpdateAvailable: () => {\n  //       setAssetsUpdateReady(true);\n  //     },\n  //     onSuccess: (registration) => {\n  //       setAssetsCached(true);\n  //       setAssetsUpdateReady(false);\n\n  //       if (registration.active) {\n  //         registration.active.addEventListener('statechange', (event: ServiceWorkerEvent) => {\n  //           if (!navigator.serviceWorker.controller) {\n  //             setAssetsCached(false);\n  //           }\n  //         });\n  //       }\n  //     },\n  //   });\n  // }, []);\n\n  return <ServiceWorkerContext.Provider value={value} {...props} />;\n}\n\nexport function useServiceWorker() {\n  const context = React.useContext(ServiceWorkerContext);\n\n  if (!context) {\n    throw new Error('useServiceWorker must be used within a ServiceWorkerProvider');\n  }\n\n  return context;\n}\n","//@ts-nocheck\nimport { Global, css } from '@emotion/core';\nimport styled from '@emotion/styled/macro';\nimport CssBaseline from '@material-ui/core/CssBaseline';\nimport { OfflineBolt, Update } from '@material-ui/icons';\nimport React from 'react';\nimport { Tooltip, TooltipReference, useTooltipState } from 'reakit/Tooltip';\n\nimport { Playground } from './playground';\nimport { files } from './templates/react';\nimport { useServiceWorker, ServiceWorkerProvider } from './useServiceWorker';\nimport { Button } from 'reakit/Button';\n\nconst PlaygroundWrapper = styled.div`\n  background: white;\n  color: #666;\n  display: flex;\n  flex-direction: column;\n\n  ${Playground} {\n    border-bottom: 1px solid #ccc;\n    flex: 1;\n  }\n`;\n\nconst StatusBarItem = styled.span`\n  display: inline-flex;\n  flex-direction: row;\n  align-items: center;\n`;\n\nconst ReloadButton = styled(Button)`\n  border: 0;\n  background: #008cba;\n  margin: 0 0.5em;\n  color: white;\n  border-radius: 2px;\n  font-weight: 600;\n\n  :hover {\n    cursor: pointer;\n    text-decoration: underline;\n  }\n`;\n\nconst StyledTooltip = styled.div`\n  font-family: Open Sans, Helvetica Neue, Helvetica, Arial, sans-serif;\n  font-size: 14px;\n  line-height: 1.4;\n  background-color: #333;\n  color: #fff;\n  border-radius: 4px;\n  opacity: 0.9;\n  padding: 0.2em 0.4em;\n`;\n\nconst StatusBar: React.FC = () => {\n  const serviceWorker = useServiceWorker();\n  const offlineTooltip = useTooltipState({ gutter: 0 });\n  const reloadTooltip = useTooltipState({ gutter: 0 });\n\n  return (\n    <StatusBarStyles>\n      {serviceWorker.assetsCached ? (\n        <TooltipReference {...offlineTooltip} as={StatusBarItem}>\n          <OfflineBolt color=\"inherit\" fontSize=\"small\" />\n          &nbsp;Offline ready\n        </TooltipReference>\n      ) : null}\n      <Tooltip {...offlineTooltip} as={StyledTooltip}>\n        This application has been fully cached and can now be used offline.\n      </Tooltip>\n\n      {serviceWorker.assetsUpdateReady ? (\n        <TooltipReference {...reloadTooltip} as={StatusBarItem}>\n          <Update color=\"inherit\" fontSize=\"small\" />\n          &nbsp;Update ready:\n          <ReloadButton onClick={() => serviceWorker.updateAssets()}>Reload</ReloadButton>\n        </TooltipReference>\n      ) : null}\n      <Tooltip {...reloadTooltip} as={StyledTooltip}>\n        There is an update of this application ready to install. Click install reload to install the\n        update and reload the page.\n      </Tooltip>\n    </StatusBarStyles>\n  );\n};\n\nconst StatusBarStyles = styled.div`\n  display: flex;\n  flex-direction: row;\n\n  font-size: 90%;\n\n  height: 24px;\n  padding: 0 0.5em;\n\n  ${StatusBarItem} {\n    margin-left: 0.5em;\n    margin-right: 0.5em;\n  }\n`;\n\nconst AppWrapper = styled.div`\n  width: 100%;\n  min-width: 200px;\n  max-width: 80vw;\n  margin: 0 auto;\n  padding: 0 0 45px 0;\n\n  @media (max-width: 960px) {\n    padding: 0 15px 15px 15px;\n    max-width: initial;\n  }\n\n  display: flex;\n  flex-direction: column;\n\n  ${PlaygroundWrapper} {\n    flex: 1;\n    background: #f5f5f5;\n    border-radius: 2px;\n    box-shadow: 0 10px 20px rgba(0, 0, 0, 0.19), 0 6px 6px rgba(0, 0, 0, 0.23);\n\n    ${StatusBarStyles} {\n    }\n  }\n`;\n\nconst Title = styled.div`\n  font-family: 'Raleway', sans-serif;\n  font-size: 250%;\n  font-weight: 800;\n  font-variant: small-caps;\n  font-variant-caps: small-caps;\n  color: #00bfff;\n`;\n\nconst Subtitle = styled.div`\n  color: #ddd;\n  font-size: 120%;\n  font-weight: 400;\n`;\n\nconst Link = styled.a`\n  color: white;\n  text-decoration: none;\n\n  :hover {\n    text-decoration: underline;\n  }\n`;\n\nconst Links = styled.div`\n  display: flex;\n  flex-direction: row;\n\n  & > *:not(:last-child):after {\n    padding: 0 0.5em;\n    content: '｜';\n    color: #aaa;\n    text-decoration: none;\n  }\n\n  ${Link} {\n    color: #ccc;\n  }\n`;\n\nconst Header = styled.div`\n  display: flex;\n  flex-direction: row;\n  align-items: baseline;\n  padding: 0.8em 0 0.3em 0;\n  text-shadow: #000 1px 1px 5px;\n\n  ${Title} {\n    margin-right: 0.5em;\n  }\n\n  ${Subtitle} {\n    margin-right: 0.5em;\n  }\n\n  ${Links} {\n    flex: 1;\n    justify-content: flex-end;\n  }\n`;\n\nconst globalCss = css`\n  @import url('https://fonts.googleapis.com/css?family=Raleway:900&display=swap');\n\n  *,\n  *::before,\n  *::after {\n    box-sizing: border-box;\n  }\n\n  html,\n  body {\n    margin: 0;\n    padding: 0;\n    min-height: 100vh;\n\n    font-family: Open Sans, Helvetica Neue, Helvetica, Arial, sans-serif;\n    font-size: 14px;\n    line-height: 1.4;\n\n    background: #333;\n    color: #fff;\n\n    display: flex;\n    flex-direction: column;\n\n    #root {\n      flex: 1;\n      display: flex;\n      flex-direction: column;\n\n      ${AppWrapper} {\n        flex: 1;\n      }\n    }\n  }\n`;\n\nexport const App: React.FC = () => {\n  return (\n    <ServiceWorkerProvider>\n      <CssBaseline />\n      <AppWrapper>\n        <Global styles={globalCss}></Global>\n        <Header>\n          <Title>Velcro</Title>\n          <Subtitle>The client-side bundler and playground</Subtitle>\n          <Links>\n            <div>\n              <Link href=\"https://twitter.com/filearts\" target=\"_blank\" rel=\"nofollow noreferrer\">\n                @filearts\n              </Link>\n            </div>\n            <div>\n              <Link\n                href=\"https://github.com/ggoodman/velcro\"\n                target=\"_blank\"\n                rel=\"nofollow noreferrer\"\n              >\n                View on GitHub\n              </Link>\n            </div>\n          </Links>\n        </Header>\n        <PlaygroundWrapper>\n          <Playground project={files} initialPath=\"index.jsx\"></Playground>\n        </PlaygroundWrapper>\n      </AppWrapper>\n    </ServiceWorkerProvider>\n  );\n};\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://cra.link/PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(/^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/)\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://cra.link/PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://cra.link/PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch((error) => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log('No internet connection found. App is running in offline mode.');\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then((registration) => {\n        registration.unregister();\n      })\n      .catch((error) => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\n\nimport { App } from './App';\nimport * as serviceWorker from './serviceWorker';\n\nserviceWorker.unregister();\n\nReactDOM.render(<App />, document.getElementById('root'));\n","import { CancellationTokenSource, MapSet, Decoder, Uri, isThenable, all, checkCancellation, dirname, DependencyNotFoundError, EntryExcludedError, parseBufferAsPartialPackageJson, basename, EntryNotFoundError, parseBufferAsPackageJson, CanceledError } from '@velcro/common';\n\nconst SPEC_RX = /^((@[^/]+\\/[^/@]+|[^./@][^/@]*)(?:@([^/]+))?)(.*)?$/;\nfunction parseBareModuleSpec(bareModuleSpec) {\n    const matches = bareModuleSpec.match(SPEC_RX);\n    if (matches) {\n        const [, nameSpec, name, spec, path = ''] = matches;\n        return {\n            nameSpec,\n            name,\n            spec,\n            path,\n        };\n    }\n    return null;\n}\n\nvar version = \"0.45.0\";\n\nconst NODE_CORE_SHIMS = Object.assign(Object.create(null), {\n    string_decoder: parseBareModuleSpec('string_decoder@1.2.0'),\n    punycode: parseBareModuleSpec('punycode@2.1.1'),\n});\nfor (const name of [\n    'assert',\n    'buffer',\n    'constants',\n    'crypto',\n    'events',\n    'fs',\n    'http',\n    'https',\n    'net',\n    'os',\n    'path',\n    'process',\n    'querystring',\n    'stream',\n    'tls',\n    'url',\n    'util',\n    'vm',\n    'zlib',\n]) {\n    NODE_CORE_SHIMS[name] = parseBareModuleSpec(`@velcro/node-libs@${version}/lib/${name}.js`);\n}\n\nvar ResolverStrategy;\n(function (ResolverStrategy) {\n    let EntryKind;\n    (function (EntryKind) {\n        EntryKind[\"File\"] = \"file\";\n        EntryKind[\"Directory\"] = \"directory\";\n    })(EntryKind = ResolverStrategy.EntryKind || (ResolverStrategy.EntryKind = {}));\n})(ResolverStrategy || (ResolverStrategy = {}));\nclass AbstractResolverStrategy {\n    getCanonicalUrl(_ctx, uri) {\n        return {\n            uri,\n        };\n    }\n    getSettings(ctx, _uri) {\n        return {\n            settings: ctx.settings,\n        };\n    }\n    /**\n     * Create a new ResolverStrategy having one or more methods overridden.\n     *\n     * You might use this if you want to override specific behaviour of another strategy without\n     * wanting to re-implement the whole strategy.\n     *\n     * If you need to invoke an overridden method, the overridden strategy will be available\n     * on `this.parent`.\n     *\n     * @param overrides A map of ResolverStrategy methods that you would like to override\n     */\n    withOverrides(overrides) {\n        const strategy = { ...overrides, parent: this };\n        return Object.setPrototypeOf(Object.assign(Object.create(null), strategy), this);\n    }\n}\nclass AbstractResolverStrategyWithRoot extends AbstractResolverStrategy {\n    constructor(rootUri) {\n        super();\n        this.rootUri = rootUri;\n    }\n}\n\n// type UncachedReturnType<T> = { [K in keyof T] : K extends typeof CACHE ? never : T[K] };\n// type UncachedReturn<\n//   T extends (...any: any[]) => any,\n//   TReturn = ReturnType<T>\n// > = TReturn extends Thenable<infer U>\n//   ? Thenable<UncachedReturnType<U>>\n//   : UncachedReturnType<TReturn>;\nconst CACHE = Symbol('Context.cache');\nclass Visits {\n    constructor(uri, parent) {\n        this.uri = uri;\n        this.visits = [];\n        this.parent = parent;\n    }\n    child(uri) {\n        return new Visits(uri, this);\n    }\n    push(visit) {\n        if (!this.visits.find((cmp) => cmp.type == visit.type && Uri.equals(cmp.uri, visit.uri))) {\n            this.visits.push(visit);\n            if (this.parent) {\n                this.parent.push(visit);\n            }\n        }\n    }\n    toArray() {\n        return this.parent ? this.parent.toArray() : this.visits.slice();\n    }\n}\nclass ResolverContext {\n    constructor(options) {\n        this.mapResultWithVisits = (result) => Object.assign(result, { visited: this.visits.toArray() });\n        this.cache = options.cache;\n        this.cacheInvalidations = options.cacheInvalidations;\n        this.debugMode = options.debug;\n        this.decoder = options.decoder;\n        this.path = options.path;\n        this.resolver = options.resolver;\n        this.settings = options.settings;\n        this.strategy = options.strategy;\n        this.tokenSource = new CancellationTokenSource(options.token);\n        this.visits = options.visits;\n    }\n    static create(resolver, strategy, settings, token, options = {}) {\n        return new ResolverContext({\n            cache: new Map(),\n            cacheInvalidations: new MapSet(),\n            debug: !!options.debug,\n            decoder: new Decoder(),\n            path: [],\n            resolver,\n            settings,\n            strategy,\n            token,\n            visits: new Visits(Uri.parse('velcro:/root')),\n        });\n    }\n    get token() {\n        return this.tokenSource.token;\n    }\n    get visited() {\n        return this.visits.toArray();\n    }\n    dispose() {\n        this.tokenSource.dispose(true);\n    }\n    forOperation(operationName, uri, options = {}) {\n        const encodedOperation = encodePathNode(operationName, uri);\n        if (this.path.includes(encodedOperation)) {\n            const formattedPath = this.path\n                .map((segment) => {\n                const { operationName, uri } = decodePathNode(segment);\n                return `${operationName}(${uri.toString()})`;\n            })\n                .join(' -> ');\n            throw this._wrapError(new Error(`Detected a recursive call to the operation '${operationName}' for '${uri.toString()}' at path '${formattedPath}'`));\n        }\n        return new ResolverContext({\n            cache: this.cache,\n            cacheInvalidations: this.cacheInvalidations,\n            debug: this.debugMode,\n            decoder: this.decoder,\n            path: options.resetPath ? [] : this.path.concat(encodedOperation),\n            resolver: this.resolver,\n            settings: this.settings,\n            strategy: this.strategy,\n            token: this.tokenSource.token,\n            visits: options.resetVisits ? new Visits(uri) : this.visits.child(uri),\n        });\n    }\n    getCanonicalUrl(uri) {\n        const method = this.strategy.getCanonicalUrl;\n        const receiver = this.strategy;\n        const operationName = `${this.strategy.constructor.name}.${method.name}`;\n        const href = uri.toString();\n        return this.runInChildContext(operationName, uri, (ctx) => ctx.runWithCache(operationName, href, method, receiver, ctx, uri));\n    }\n    getResolveRoot(uri) {\n        const method = this.strategy.getResolveRoot;\n        const receiver = this.strategy;\n        const operationName = `${this.strategy.constructor.name}.${method.name}`;\n        const href = uri.toString();\n        return this.runInChildContext(operationName, uri, (ctx) => ctx.runWithCache(operationName, href, method, receiver, ctx, uri));\n    }\n    getSettings(uri) {\n        const method = this.strategy.getSettings;\n        const receiver = this.strategy;\n        const operationName = `${this.strategy.constructor.name}.${method.name}`;\n        const href = uri.toString();\n        return this.runInChildContext(operationName, uri, (ctx) => ctx.runWithCache(operationName, href, method, receiver, ctx, uri));\n    }\n    getUrlForBareModule(name, spec, path) {\n        const method = this.strategy.getUrlForBareModule;\n        if (!method) {\n            return Promise.reject(new Error(`Unable to resolve bare module spec '${name}@${spec}${path}' because no strategy was found that supports resolving bare modules`));\n        }\n        const receiver = this.strategy;\n        const operationName = `${this.strategy.constructor.name}.${method.name}`;\n        const href = `${name}@${spec}${path}`;\n        return this.runInChildContext(operationName, href, (ctx) => ctx.runWithCache(operationName, href, method, receiver, ctx, name, spec, path));\n    }\n    invalidate(uri) {\n        const href = uri.toString();\n        const invalidations = this.cacheInvalidations.get(href);\n        let invalidated = false;\n        if (invalidations) {\n            for (const { cacheKey, operationCache } of invalidations) {\n                invalidated = operationCache.delete(cacheKey) || invalidated;\n            }\n        }\n        this.cacheInvalidations.deleteAll(href);\n        return invalidated;\n    }\n    listEntries(uri) {\n        const method = this.strategy.listEntries;\n        const receiver = this.strategy;\n        const operationName = `${this.strategy.constructor.name}.${method.name}`;\n        const href = uri.toString();\n        return this.runInChildContext(operationName, uri, (ctx) => ctx.runWithCache(operationName, href, method, receiver, ctx, uri));\n    }\n    readFileContent(uri) {\n        const method = this.strategy.readFileContent;\n        const receiver = this.strategy;\n        const operationName = `${this.strategy.constructor.name}.${method.name}`;\n        const href = uri.toString();\n        this.recordVisit(uri, ResolverContext.VisitKind.File);\n        return this.runInChildContext(operationName, uri, (ctx) => ctx.runWithCache(operationName, href, method, receiver, ctx, uri));\n    }\n    readParentPackageJson(uri) {\n        return this.runWithCache('readParentPackageJson', uri.toString(), readParentPackageJson, null, this, uri);\n    }\n    recordVisit(uri, type = ResolverContext.VisitKind.File) {\n        this.visits.push({ type, uri });\n    }\n    resolve(spec, fromUri) {\n        const method = resolveDependency;\n        const receiver = null;\n        const operationName = method.name;\n        const href = `${fromUri}|${spec}`;\n        return this.runInChildContext(operationName, href, (ctx) => ctx.runWithCache(operationName, href, method, receiver, ctx, fromUri, spec));\n    }\n    resolveUri(uri) {\n        const method = resolve;\n        const receiver = null;\n        const operationName = method.name;\n        const href = uri.toString();\n        return this.runInChildContext(operationName, uri, (ctx) => ctx.runWithCache(operationName, href, method, receiver, ctx, uri));\n    }\n    runInChildContext(operationName, uri, contextFn) {\n        return this.runInContext(operationName, uri, { resetPath: false, resetVisits: false }, contextFn);\n    }\n    runInIsolatedContext(operationName, uri, contextFn) {\n        return this.runInContext(operationName, uri, { resetPath: true, resetVisits: true }, contextFn);\n    }\n    runInContext(operationName, uri, options, contextFn) {\n        const ctx = this.forOperation(operationName, uri, options);\n        ctx.debug('%s(%s)', operationName, uri.toString());\n        return contextFn(ctx);\n    }\n    createStoreResultFn(operationCache, cacheKey) {\n        return (result) => {\n            const mappedResult = this.mapResultWithVisits(result);\n            const visited = mappedResult.visited;\n            if (mappedResult[CACHE]) {\n                const cacheEntries = mappedResult[CACHE];\n                delete mappedResult[CACHE];\n                for (const [cacheKey, value] of cacheEntries) {\n                    operationCache.set(cacheKey, value);\n                    for (const visit of visited) {\n                        this.cacheInvalidations.add(visit.uri.toString(), { cacheKey, operationCache });\n                    }\n                }\n            }\n            // Override the pending value with the resolved value\n            operationCache.set(cacheKey, mappedResult);\n            for (const visit of visited) {\n                this.cacheInvalidations.add(visit.uri.toString(), { cacheKey, operationCache });\n            }\n            return mappedResult;\n        };\n    }\n    runWithCache(cacheSegment, cacheKey, fn, target, ...args) {\n        let operationCache = this.cache.get(cacheSegment);\n        if (!operationCache) {\n            operationCache = new Map();\n            this.cache.set(cacheSegment, operationCache);\n        }\n        const cached = operationCache.get(cacheKey);\n        if (cached) {\n            this.debug('%s(%s) [HIT]', cacheSegment, cacheKey);\n            // We either have a cached result or a cached promise for a result. Either way, the value\n            // is suitable as a return.\n            return cached;\n        }\n        const cacheResult = this.createStoreResultFn(operationCache, cacheKey);\n        this.debug('%s(%s) [MISS]', cacheSegment, cacheKey);\n        // Nothing is cached\n        const ret = fn.apply(target, args);\n        if (isThenable(ret)) {\n            const promiseRet = ret;\n            // Produce a promise that will only be settled once the cache has been updated accordingly.\n            const wrappedRet = promiseRet.then(cacheResult, (err) => {\n                // Delete the entry from the cache in case it was a transient failure\n                operationCache.delete(cacheKey);\n                return Promise.reject(err);\n            });\n            // Set the pending value in the cache for now\n            operationCache.set(cacheKey, wrappedRet);\n            return wrappedRet;\n        }\n        return cacheResult(ret);\n    }\n    _wrapError(err) {\n        return Object.assign(err, {\n            path: this.path.map(decodePathNode),\n        });\n    }\n    debug(...args) {\n        if (this.debugMode) {\n            if (typeof args[0] === 'string') {\n                args[0] = ' '.repeat(this.path.length) + args[0];\n            }\n            console.warn(...args);\n        }\n    }\n}\nfunction encodePathNode(operationName, uri) {\n    return `${operationName}:${uri.toString()}`;\n}\nfunction decodePathNode(node) {\n    const parts = node.split(':', 2);\n    if (parts.length !== 2) {\n        console.log('WTF', { node, parts });\n        throw new Error(`Invariant violation: Unexpected path node: '${node}'`);\n    }\n    return {\n        operationName: parts[0],\n        uri: parts[1].includes(':') ? Uri.parse(parts[1]) : parts[1],\n    };\n}\nasync function resolve(ctx, uri) {\n    const bothResolved = all([ctx.getCanonicalUrl(uri), ctx.getResolveRoot(uri), ctx.getSettings(uri)], ctx.token);\n    const [canonicalizationResult, resolveRootResult, settingsResult] = isThenable(bothResolved)\n        ? await checkCancellation(bothResolved, ctx.token)\n        : bothResolved;\n    const rootUri = resolveRootResult.uri;\n    const rootUriWithoutTrailingSlash = Uri.ensureTrailingSlash(rootUri, '');\n    if (!Uri.isPrefixOf(rootUriWithoutTrailingSlash, canonicalizationResult.uri)) {\n        throw new Error(`Unable to resolve a module whose path ${canonicalizationResult.uri.toString(true)} is above the host's root ${rootUri.toString()}`);\n    }\n    const resolveReturn = Uri.equals(rootUriWithoutTrailingSlash, canonicalizationResult.uri) ||\n        Uri.equals(rootUri, canonicalizationResult.uri)\n        ? ctx.runInChildContext('resolveAsDirectory', canonicalizationResult.uri, (ctx) => resolveAsDirectory(ctx, Uri.ensureTrailingSlash(canonicalizationResult.uri), resolveRootResult.uri, settingsResult.settings))\n        : ctx.runInChildContext('resolveAsFile', canonicalizationResult.uri, (ctx) => resolveAsFile(ctx, canonicalizationResult.uri, resolveRootResult.uri, settingsResult.settings, null));\n    const readParentPackageJsonReturn = ctx.readParentPackageJson(uri);\n    const resolveAndPackageJson = all([resolveReturn, readParentPackageJsonReturn], ctx.token);\n    const [resolveResult, readParentPackageJsonResult] = isThenable(resolveAndPackageJson)\n        ? await resolveAndPackageJson\n        : resolveAndPackageJson;\n    return {\n        ...resolveResult,\n        parentPackageJson: readParentPackageJsonResult.found\n            ? {\n                packageJson: readParentPackageJsonResult.packageJson,\n                uri: readParentPackageJsonResult.uri,\n            }\n            : undefined,\n    };\n}\nasync function resolveDependency(ctx, fromUri, spec) {\n    const parsedSpec = parseBareModuleSpec(spec);\n    if (parsedSpec) {\n        return ctx.runInChildContext('resolveBareModule', fromUri, (ctx) => resolveBareModule(ctx, fromUri, parsedSpec));\n    }\n    const relativeUri = Uri.joinPath(Uri.from({\n        ...fromUri,\n        path: dirname(fromUri.path),\n    }), spec);\n    return ctx.runInChildContext('resolveUri', relativeUri, (ctx) => resolve(ctx, relativeUri));\n}\nasync function resolveBareModule(ctx, uri, parsedSpec) {\n    let locatorName = parsedSpec.name;\n    let locatorSpec = parsedSpec.spec;\n    let locatorPath = parsedSpec.path;\n    if (!locatorSpec) {\n        const resolveRootReturn = ctx.getResolveRoot(uri);\n        const resolveRootResult = isThenable(resolveRootReturn)\n            ? await checkCancellation(resolveRootReturn, ctx.token)\n            : resolveRootReturn;\n        let nextUri = uri;\n        let maxIterations = 10;\n        while (Uri.isPrefixOf(resolveRootResult.uri, nextUri)) {\n            if (--maxIterations <= 0) {\n                throw new Error('Max iterations reached');\n            }\n            const parentPackageJsonReturn = ctx.readParentPackageJson(uri);\n            const parentPackageJsonResult = isThenable(parentPackageJsonReturn)\n                ? await checkCancellation(parentPackageJsonReturn, ctx.token)\n                : parentPackageJsonReturn;\n            if (!parentPackageJsonResult.found) {\n                throw new DependencyNotFoundError(parsedSpec.nameSpec, uri);\n            }\n            ctx.recordVisit(parentPackageJsonResult.uri, ResolverContext.VisitKind.File);\n            if (parentPackageJsonResult.packageJson.name === parsedSpec.name) {\n                // We found a parent directory that *IS* the module we're looking for\n                const directoryUri = Uri.ensureTrailingSlash(Uri.joinPath(parentPackageJsonResult.uri, '../'));\n                return ctx.runInChildContext('resolveAsDirectory', directoryUri, (ctx) => resolveAsDirectory(ctx, directoryUri, resolveRootResult.uri, ctx.settings));\n            }\n            const dependencies = {\n                ...(parentPackageJsonResult.packageJson.devDependencies || {}),\n                ...(parentPackageJsonResult.packageJson.peerDependencies || {}),\n                ...(parentPackageJsonResult.packageJson.dependencies || {}),\n            };\n            locatorSpec = dependencies[parsedSpec.name];\n            if (locatorSpec) {\n                break;\n            }\n            nextUri = Uri.joinPath(parentPackageJsonResult.uri, '..');\n            if (Uri.equals(nextUri, resolveRootResult.uri)) {\n                break;\n            }\n        }\n    }\n    if (!locatorSpec) {\n        const builtIn = NODE_CORE_SHIMS[parsedSpec.name];\n        if (builtIn) {\n            locatorName = builtIn.name;\n            locatorSpec = builtIn.spec;\n            locatorPath = builtIn.path;\n        }\n    }\n    if (!locatorSpec) {\n        throw new DependencyNotFoundError(parsedSpec.nameSpec, uri);\n    }\n    const bareModuleUriReturn = ctx.getUrlForBareModule(locatorName, locatorSpec, locatorPath);\n    const bareModuleUriResult = isThenable(bareModuleUriReturn)\n        ? await checkCancellation(bareModuleUriReturn, ctx.token)\n        : bareModuleUriReturn;\n    if (!bareModuleUriResult.found) {\n        throw new DependencyNotFoundError(parsedSpec.nameSpec, uri);\n    }\n    if (!bareModuleUriResult.uri) {\n        // TODO: Inject empty module\n        throw new EntryExcludedError(parsedSpec.nameSpec);\n    }\n    const resolveReturn = ctx.resolveUri(bareModuleUriResult.uri);\n    const resolveResult = isThenable(resolveReturn)\n        ? await checkCancellation(resolveReturn, ctx.token)\n        : resolveReturn;\n    return resolveResult;\n}\n(function (ResolverContext) {\n    let VisitKind;\n    (function (VisitKind) {\n        VisitKind[\"Directory\"] = \"Directory\";\n        VisitKind[\"File\"] = \"File\";\n    })(VisitKind = ResolverContext.VisitKind || (ResolverContext.VisitKind = {}));\n})(ResolverContext || (ResolverContext = {}));\nasync function resolveAsDirectory(ctx, uri, rootUri, settings) {\n    ctx.recordVisit(uri, ResolverContext.VisitKind.Directory);\n    const listEntriesReturn = ctx.listEntries(uri);\n    const listEntriesResult = isThenable(listEntriesReturn)\n        ? await checkCancellation(listEntriesReturn, ctx.token)\n        : listEntriesReturn;\n    let mainPathname = 'index';\n    // Step 1: Look for a package.json with an main field\n    const packageJsonUri = Uri.joinPath(uri, './package.json');\n    ctx.recordVisit(packageJsonUri, ResolverContext.VisitKind.File);\n    const packageJsonEntry = listEntriesResult.entries.find((entry) => entry.type === ResolverStrategy.EntryKind.File && Uri.equals(packageJsonUri, entry.uri));\n    let packageJson = null;\n    if (packageJsonEntry) {\n        const packageJsonContentReturn = ctx.readFileContent(packageJsonUri);\n        const packageJsonContentResult = isThenable(packageJsonContentReturn)\n            ? await checkCancellation(packageJsonContentReturn, ctx.token)\n            : packageJsonContentReturn;\n        packageJson = parseBufferAsPartialPackageJson(ctx.decoder, packageJsonContentResult.content, uri.toString());\n        for (const packageMain of settings.packageMain) {\n            const pathname = packageJson[packageMain];\n            if (typeof pathname === 'string') {\n                mainPathname = pathname;\n                break;\n            }\n        }\n    }\n    const fileUri = Uri.joinPath(uri, mainPathname);\n    return ctx.runInChildContext('resolveAsFile', uri, (ctx) => resolveAsFile(ctx, fileUri, rootUri, settings, packageJson));\n}\nasync function resolveAsFile(ctx, uri, rootUri, settings, packageJson, ignoreBrowserOverrides = false) {\n    if (uri.path === '' || uri.path === '/') {\n        throw new TypeError(`Unable to resolve the root as a file: ${uri.toString()}`);\n    }\n    ctx.recordVisit(uri, ResolverContext.VisitKind.File);\n    const browserOverrides = new Map();\n    if (packageJson === null) {\n        // The parent package.json is only interesting if we are going to look at the `browser`\n        // field and then consider browser mapping overrides in there.\n        const parentPackageJsonResult = settings.packageMain.includes('browser') && !ignoreBrowserOverrides\n            ? await checkCancellation(ctx.runInChildContext('readParentPackageJsonInternal', uri, (ctx) => readParentPackageJsonInternal(ctx, uri, rootUri, { uriIsCanonicalized: true })), ctx.token)\n            : undefined;\n        if (parentPackageJsonResult && parentPackageJsonResult.found) {\n            ctx.recordVisit(parentPackageJsonResult.uri, ResolverContext.VisitKind.File);\n            packageJson = parentPackageJsonResult.packageJson;\n            if (parentPackageJsonResult.packageJson.browser &&\n                typeof parentPackageJsonResult.packageJson.browser === 'object') {\n                const browserMap = parentPackageJsonResult.packageJson.browser;\n                const packageJsonDir = Uri.joinPath(parentPackageJsonResult.uri, '..');\n                for (const entry in browserMap) {\n                    const impliedUri = Uri.joinPath(packageJsonDir, entry);\n                    const targetSpec = browserMap[entry];\n                    const target = targetSpec === false ? false : Uri.joinPath(packageJsonDir, targetSpec);\n                    if (Uri.equals(impliedUri, uri)) {\n                        if (target === false) {\n                            return {\n                                found: false,\n                                uri: null,\n                            };\n                        }\n                        // console.warn('REMAPPED %s to %s', url, target);\n                        // We found an exact match so let's make sure we resolve the re-mapped file but\n                        // also that we don't go through the browser overrides rodeo again.\n                        return ctx.runInChildContext('resolveAsFile', target, (ctx) => resolveAsFile(ctx, target, rootUri, settings, packageJson, true));\n                    }\n                    browserOverrides.set(impliedUri.toString(), target);\n                }\n            }\n        }\n    }\n    const containingDirUri = Uri.ensureTrailingSlash(Uri.joinPath(uri, '..'));\n    const filename = basename(uri.path);\n    const entriesReturn = ctx.listEntries(containingDirUri);\n    const entriesResult = isThenable(entriesReturn)\n        ? await checkCancellation(entriesReturn, ctx.token)\n        : entriesReturn;\n    const entryDirectoryMap = new Map();\n    const entryFileMap = new Map();\n    for (const entry of entriesResult.entries) {\n        if (Uri.equals(entry.uri, uri) && entry.type == ResolverStrategy.EntryKind.File) {\n            // Found an exact match\n            return {\n                found: true,\n                rootUri,\n                uri,\n            };\n        }\n        if (entry.type === ResolverStrategy.EntryKind.Directory) {\n            const childFilename = Uri.getFirstPathSegmentAfterPrefix(entry.uri, containingDirUri);\n            entryDirectoryMap.set(childFilename, entry);\n        }\n        else if (entry.type === ResolverStrategy.EntryKind.File) {\n            const childFilename = basename(entry.uri.path);\n            entryFileMap.set(childFilename, entry);\n        }\n    }\n    // Look for browser overrides\n    for (const ext of settings.extensions) {\n        const hrefWithExtensionUri = uri.with({ path: `${uri.path}${ext}` });\n        const hrefWithExtension = hrefWithExtensionUri.toString();\n        const mapping = browserOverrides.get(hrefWithExtension);\n        ctx.recordVisit(hrefWithExtensionUri, ResolverContext.VisitKind.File);\n        if (mapping === false) {\n            // console.warn('REMAPPED %s to undefined', url);\n            return {\n                found: true,\n                rootUri,\n                uri: null,\n            };\n        }\n        else if (mapping) {\n            // console.warn('REMAPPED %s to %s', url, mapping);\n            return ctx.runInChildContext('resolveAsFile', mapping, (ctx) => resolveAsFile(ctx, mapping, rootUri, settings, packageJson, true));\n        }\n        const match = entryFileMap.get(`${filename}${ext}`);\n        if (match) {\n            if (match.type !== ResolverStrategy.EntryKind.File) {\n                continue;\n            }\n            return {\n                found: true,\n                rootUri,\n                uri: match.uri,\n            };\n        }\n    }\n    // First, attempt to find a matching file or directory\n    const match = entryDirectoryMap.get(filename);\n    if (match) {\n        if (match.type !== ResolverStrategy.EntryKind.Directory) {\n            throw new Error(`Invariant violation ${match.type} is unexpected`);\n        }\n        return ctx.runInChildContext('resolveAsDirectory', match.uri, (ctx) => resolveAsDirectory(ctx, Uri.ensureTrailingSlash(match.uri), rootUri, settings));\n    }\n    throw new EntryNotFoundError(uri);\n}\nasync function readParentPackageJson(ctx, uri) {\n    const canonicalizationReturn = ctx.getCanonicalUrl(uri);\n    const resolveRootReturn = ctx.getResolveRoot(uri);\n    const bothResolved = all([canonicalizationReturn, resolveRootReturn], ctx.token);\n    const [canonicalizationResult, resolveRootResult] = isThenable(bothResolved)\n        ? await checkCancellation(bothResolved, ctx.token)\n        : bothResolved;\n    const readReturn = ctx.runInChildContext('readParentPackageJsonInternal', canonicalizationResult.uri, (ctx) => readParentPackageJsonInternal(ctx, canonicalizationResult.uri, resolveRootResult.uri, {\n        uriIsCanonicalized: true,\n    }));\n    const readResult = isThenable(readReturn) ? await readReturn : readReturn;\n    if (readResult.found && readResult.visitedDirs) {\n        const visitedDirs = readResult.visitedDirs;\n        delete readResult.visitedDirs;\n        readResult[CACHE] = visitedDirs.map((uri) => [uri.toString(), { ...readResult, uri }]);\n    }\n    return readResult;\n}\nasync function readParentPackageJsonInternal(ctx, uri, rootUri, options) {\n    if (!options.uriIsCanonicalized) {\n        const canonicalizationReturn = ctx.getCanonicalUrl(uri);\n        const canonicalizationResult = isThenable(canonicalizationReturn)\n            ? await checkCancellation(canonicalizationReturn, ctx.token)\n            : canonicalizationReturn;\n        uri = canonicalizationResult.uri;\n    }\n    const hostRootHref = Uri.ensureTrailingSlash(rootUri);\n    const containingDirUrl = Uri.ensureTrailingSlash(Uri.joinPath(uri, '..'));\n    const visitedDirs = [];\n    const readPackageJsonOrRecurse = async (ctx, dir) => {\n        if (!Uri.isPrefixOf(hostRootHref, dir)) {\n            // Terminal condition for recursion\n            return {\n                found: false,\n                packageJson: null,\n                uri: null,\n            };\n        }\n        ctx.recordVisit(dir, ResolverContext.VisitKind.Directory);\n        const entriesReturn = ctx.listEntries(dir);\n        const entriesResult = isThenable(entriesReturn)\n            ? await checkCancellation(entriesReturn, ctx.token)\n            : entriesReturn;\n        const packageJsonUri = Uri.joinPath(dir, 'package.json');\n        const packageJsonEntry = entriesResult.entries.find((entry) => entry.type === ResolverStrategy.EntryKind.File && Uri.equals(entry.uri, packageJsonUri));\n        ctx.recordVisit(packageJsonUri, ResolverContext.VisitKind.File);\n        if (packageJsonEntry) {\n            // Found! Let's try to parse\n            try {\n                const parentPackageJsonContentReturn = ctx.readFileContent(packageJsonUri);\n                const parentPackageJsonContentResult = isThenable(parentPackageJsonContentReturn)\n                    ? await checkCancellation(parentPackageJsonContentReturn, ctx.token)\n                    : parentPackageJsonContentReturn;\n                const packageJson = parseBufferAsPackageJson(ctx.decoder, parentPackageJsonContentResult.content, packageJsonUri.toString());\n                return { found: true, packageJson, uri: packageJsonUri, visitedDirs };\n            }\n            catch (err) {\n                if (err instanceof CanceledError || (err && err.name === 'CanceledError')) {\n                    throw err;\n                }\n                // TODO: Maybe issue some warning?\n            }\n        }\n        // Not found here, let's try one up\n        const parentDir = Uri.ensureTrailingSlash(Uri.joinPath(dir, '..'));\n        // Skip infinite recursion\n        if (Uri.equals(dir, parentDir) || Uri.isPrefixOf(dir, parentDir)) {\n            return {\n                found: false,\n                packageJson: null,\n                uri: null,\n            };\n        }\n        visitedDirs.push(dir);\n        return ctx.runInChildContext('readPackageJsonOrRecurse', parentDir, (ctx) => readPackageJsonOrRecurse(ctx, parentDir));\n    };\n    if (Uri.equals(uri, containingDirUrl) || Uri.isPrefixOf(uri, containingDirUrl)) {\n        return {\n            found: false,\n            packageJson: null,\n            uri: null,\n        };\n    }\n    return ctx.runInChildContext('readPackageJsonOrRecurse', containingDirUrl, (ctx) => readPackageJsonOrRecurse(ctx, containingDirUrl));\n}\n\nclass Resolver {\n    constructor(strategy, settings) {\n        this.disposed = false;\n        this.tokenSource = new CancellationTokenSource();\n        this.settings = settings;\n        this.strategy = strategy;\n        this.rootCtx = ResolverContext.create(this, this.strategy, this.settings, this.tokenSource.token, { debug: settings.debug });\n    }\n    decode(buf) {\n        if (typeof buf === 'string') {\n            return buf;\n        }\n        return this.rootCtx.decoder.decode(buf);\n    }\n    dispose() {\n        this.disposed = true;\n        return this.rootCtx.dispose();\n    }\n    getCanonicalUrl(uri) {\n        if (this.disposed) {\n            throw new Error('Resolver has been disposed');\n        }\n        return this.rootCtx.runInIsolatedContext('Resolver.getCanonicalUrl', uri, (ctx) => ctx.getCanonicalUrl(typeof uri === 'string' ? Uri.parse(uri) : uri));\n    }\n    getResolveRoot(uri) {\n        if (this.disposed) {\n            throw new Error('Resolver has been disposed');\n        }\n        return this.rootCtx.runInIsolatedContext('Resolver.getResolveRoot', uri, (ctx) => ctx.getResolveRoot(typeof uri === 'string' ? Uri.parse(uri) : uri));\n    }\n    getSettings(uri) {\n        if (this.disposed) {\n            throw new Error('Resolver has been disposed');\n        }\n        return this.rootCtx.runInIsolatedContext('Resolver.getSettings', uri, (ctx) => ctx.getSettings(typeof uri === 'string' ? Uri.parse(uri) : uri));\n    }\n    getUrlForBareModule(name, spec, path) {\n        if (this.disposed) {\n            throw new Error('Resolver has been disposed');\n        }\n        return this.rootCtx.runInIsolatedContext('Resolver.getUrlForBareModule', `${name}|${spec}|${path}`, (ctx) => ctx.getUrlForBareModule(name, spec, path));\n    }\n    invalidate(uri) {\n        if (this.disposed) {\n            throw new Error('Resolver has been disposed');\n        }\n        return this.rootCtx.runInIsolatedContext('Resolver.invalidate', uri, (ctx) => ctx.invalidate(typeof uri === 'string' ? Uri.parse(uri) : uri));\n    }\n    listEntries(uri) {\n        if (this.disposed) {\n            throw new Error('Resolver has been disposed');\n        }\n        return this.rootCtx.runInIsolatedContext('Resolver.listEntries', uri, (ctx) => ctx.listEntries(typeof uri === 'string' ? Uri.parse(uri) : uri));\n    }\n    readFileContent(uri) {\n        if (this.disposed) {\n            throw new Error('Resolver has been disposed');\n        }\n        return this.rootCtx.runInIsolatedContext('Resolver.readFileContent', uri, (ctx) => ctx.readFileContent(typeof uri === 'string' ? Uri.parse(uri) : uri));\n    }\n    readParentPackageJson(uri) {\n        if (this.disposed) {\n            throw new Error('Resolver has been disposed');\n        }\n        return this.rootCtx.runInIsolatedContext('Resolver.readParentPackageJson', uri, (ctx) => ctx.readParentPackageJson(typeof uri === 'string' ? Uri.parse(uri) : uri));\n    }\n    resolve(spec, fromUri) {\n        if (this.disposed) {\n            throw new Error('Resolver has been disposed');\n        }\n        if (Uri.isUri(spec)) {\n            return this.rootCtx.runInIsolatedContext('Resolver.resolveUri', spec, (ctx) => ctx.resolveUri(spec));\n        }\n        if (!fromUri) {\n            throw new Error('When calling Resolver.resolve with a string spec, a second \"fromUri\" argument is required');\n        }\n        return this.rootCtx.runInIsolatedContext('Resolver.resolve', `${fromUri ? fromUri.toString() : ''}|${spec}`, (ctx) => ctx.resolve(spec, fromUri));\n    }\n}\n\nconst version$1 = '0.45.1';\n\nexport { AbstractResolverStrategy, AbstractResolverStrategyWithRoot, Resolver, ResolverContext, ResolverStrategy, version$1 as version };\n//# sourceMappingURL=index.js.map\n"],"sourceRoot":""}