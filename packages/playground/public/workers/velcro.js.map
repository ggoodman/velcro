{
  "version": 3,
  "sources": ["packages/@velcro/worker/node_modules/zod/lib/src/helpers/util.js", "packages/@velcro/worker/node_modules/zod/lib/src/ZodError.js", "packages/@velcro/worker/node_modules/zod/lib/src/defaultErrorMap.js", "packages/@velcro/worker/node_modules/zod/lib/src/parser.js", "packages/@velcro/worker/node_modules/zod/lib/src/types/base.js", "packages/@velcro/worker/node_modules/zod/lib/src/helpers/errorUtil.js", "packages/@velcro/worker/node_modules/zod/lib/src/types/string.js", "packages/@velcro/worker/node_modules/zod/lib/src/types/number.js", "packages/@velcro/worker/node_modules/zod/lib/src/types/bigint.js", "packages/@velcro/worker/node_modules/zod/lib/src/types/boolean.js", "packages/@velcro/worker/node_modules/zod/lib/src/types/date.js", "packages/@velcro/worker/node_modules/zod/lib/src/types/undefined.js", "packages/@velcro/worker/node_modules/zod/lib/src/types/null.js", "packages/@velcro/worker/node_modules/zod/lib/src/types/any.js", "packages/@velcro/worker/node_modules/zod/lib/src/types/unknown.js", "packages/@velcro/worker/node_modules/zod/lib/src/types/void.js", "packages/@velcro/worker/node_modules/zod/lib/src/types/array.js", "packages/@velcro/worker/node_modules/zod/lib/src/types/intersection.js", "packages/@velcro/worker/node_modules/zod/lib/src/helpers/objectUtil.js", "packages/@velcro/worker/node_modules/zod/lib/src/types/object.js", "packages/@velcro/worker/node_modules/zod/lib/src/types/union.js", "packages/@velcro/worker/node_modules/zod/lib/src/types/tuple.js", "packages/@velcro/worker/node_modules/zod/lib/src/types/record.js", "packages/@velcro/worker/node_modules/zod/lib/src/types/function.js", "packages/@velcro/worker/node_modules/zod/lib/src/types/lazy.js", "packages/@velcro/worker/node_modules/zod/lib/src/types/literal.js", "packages/@velcro/worker/node_modules/zod/lib/src/types/enum.js", "packages/@velcro/worker/node_modules/zod/lib/src/types/promise.js", "packages/@velcro/worker/node_modules/zod/lib/src/codegen.js", "packages/@velcro/worker/node_modules/zod/lib/src/index.js", "packages/@velcro/node-libs/package.json", "packages/@velcro/plugin-sucrase/node_modules/ts-interface-checker/dist/util.js", "packages/@velcro/plugin-sucrase/node_modules/ts-interface-checker/dist/types.js", "packages/@velcro/plugin-sucrase/node_modules/ts-interface-checker/dist/index.js", "packages/@velcro/strategy-cdn/node_modules/semver/internal/constants.js", "packages/@velcro/strategy-cdn/node_modules/semver/internal/debug.js", "packages/@velcro/strategy-cdn/node_modules/semver/internal/re.js", "packages/@velcro/strategy-cdn/node_modules/semver/internal/identifiers.js", "packages/@velcro/strategy-cdn/node_modules/semver/classes/semver.js", "packages/@velcro/strategy-cdn/node_modules/semver/functions/parse.js", "packages/@velcro/strategy-cdn/node_modules/semver/functions/valid.js", "packages/@velcro/strategy-cdn/node_modules/semver/functions/clean.js", "packages/@velcro/strategy-cdn/node_modules/semver/functions/inc.js", "packages/@velcro/strategy-cdn/node_modules/semver/functions/compare.js", "packages/@velcro/strategy-cdn/node_modules/semver/functions/eq.js", "packages/@velcro/strategy-cdn/node_modules/semver/functions/diff.js", "packages/@velcro/strategy-cdn/node_modules/semver/functions/major.js", "packages/@velcro/strategy-cdn/node_modules/semver/functions/minor.js", "packages/@velcro/strategy-cdn/node_modules/semver/functions/patch.js", "packages/@velcro/strategy-cdn/node_modules/semver/functions/prerelease.js", "packages/@velcro/strategy-cdn/node_modules/semver/functions/rcompare.js", "packages/@velcro/strategy-cdn/node_modules/semver/functions/compare-loose.js", "packages/@velcro/strategy-cdn/node_modules/semver/functions/compare-build.js", "packages/@velcro/strategy-cdn/node_modules/semver/functions/sort.js", "packages/@velcro/strategy-cdn/node_modules/semver/functions/rsort.js", "packages/@velcro/strategy-cdn/node_modules/semver/functions/gt.js", "packages/@velcro/strategy-cdn/node_modules/semver/functions/lt.js", "packages/@velcro/strategy-cdn/node_modules/semver/functions/neq.js", "packages/@velcro/strategy-cdn/node_modules/semver/functions/gte.js", "packages/@velcro/strategy-cdn/node_modules/semver/functions/lte.js", "packages/@velcro/strategy-cdn/node_modules/semver/functions/cmp.js", "packages/@velcro/strategy-cdn/node_modules/semver/functions/coerce.js", "packages/@velcro/strategy-cdn/node_modules/semver/classes/range.js", "packages/@velcro/strategy-cdn/node_modules/semver/classes/comparator.js", "packages/@velcro/strategy-cdn/node_modules/semver/functions/satisfies.js", "packages/@velcro/strategy-cdn/node_modules/semver/ranges/to-comparators.js", "packages/@velcro/strategy-cdn/node_modules/semver/ranges/max-satisfying.js", "packages/@velcro/strategy-cdn/node_modules/semver/ranges/min-satisfying.js", "packages/@velcro/strategy-cdn/node_modules/semver/ranges/min-version.js", "packages/@velcro/strategy-cdn/node_modules/semver/ranges/valid.js", "packages/@velcro/strategy-cdn/node_modules/semver/ranges/outside.js", "packages/@velcro/strategy-cdn/node_modules/semver/ranges/gtr.js", "packages/@velcro/strategy-cdn/node_modules/semver/ranges/ltr.js", "packages/@velcro/strategy-cdn/node_modules/semver/ranges/intersects.js", "packages/@velcro/strategy-cdn/node_modules/semver/ranges/simplify.js", "packages/@velcro/strategy-cdn/node_modules/semver/ranges/subset.js", "packages/@velcro/strategy-cdn/node_modules/semver/index.js", "packages/@velcro/worker/node_modules/svelte/compiler.js", "packages/@velcro/worker/src/index.ts", "packages/@velcro/worker/src/types.ts", "packages/@velcro/bundler/src/graph/errors.ts", "packages/@velcro/common/src/error.ts", "packages/@velcro/common/src/async.ts", "packages/@velcro/common/src/base64.ts", "packages/@velcro/common/node_modules/ts-primitives/dist/index.esm.js", "packages/@velcro/common/src/cancellation.ts", "packages/@velcro/common/src/decoder.ts", "packages/@velcro/common/src/event.ts", "packages/@velcro/common/src/lifecycle.ts", "packages/@velcro/common/src/mapSet.ts", "packages/@velcro/common/src/packageJson.ts", "packages/@velcro/common/src/path.ts", "packages/@velcro/common/src/charCode.ts", "packages/@velcro/common/src/uri.ts", "packages/@velcro/common/src/index.ts", "packages/@velcro/bundler/src/plugins/plugin.ts", "packages/@velcro/bundler/node_modules/sourcemap-codec/dist/sourcemap-codec.es.js", "packages/@velcro/bundler/node_modules/magic-string/dist/magic-string.es.js", "packages/@velcro/bundler/src/build/sourceMap.ts", "packages/@velcro/bundler/src/build/sourceMapTree.ts", "packages/@velcro/bundler/src/plugins/pluginManager.ts", "packages/@velcro/bundler/src/plugins/index.ts", "packages/@velcro/bundler/src/graph/sourceModuleDependency.ts", "packages/@velcro/bundler/node_modules/acorn/dist/acorn.mjs", "packages/@velcro/bundler/src/graph/commonjs/ast.ts", "packages/@velcro/bundler/src/graph/commonjs/traverse.ts", "packages/@velcro/bundler/src/graph/commonjs/parser.ts", "packages/@velcro/bundler/src/graph/commonjs/index.ts", "packages/@velcro/bundler/src/runtime/runtime.js", "packages/@velcro/bundler/src/build/chunkOutput.ts", "packages/@velcro/bundler/src/build/chunk.ts", "packages/@velcro/bundler/src/graph/graph.ts", "packages/@velcro/bundler/src/graph/shims.ts", "packages/@velcro/bundler/src/graph/sourceModule.ts", "packages/@velcro/bundler/src/graph/graphBuilder.ts", "packages/@velcro/bundler/src/graph/index.ts", "packages/@velcro/bundler/src/index.ts", "packages/@velcro/plugin-css/src/css.ts", "packages/@velcro/plugin-css/src/index.ts", "packages/@velcro/plugin-sucrase/node_modules/sucrase/dist/parser/tokenizer/keywords.mjs", "packages/@velcro/plugin-sucrase/node_modules/sucrase/dist/parser/tokenizer/types.mjs", "packages/@velcro/plugin-sucrase/node_modules/sucrase/dist/parser/tokenizer/state.mjs", "packages/@velcro/plugin-sucrase/node_modules/sucrase/dist/parser/util/charcodes.mjs", "packages/@velcro/plugin-sucrase/node_modules/sucrase/dist/parser/traverser/base.mjs", "packages/@velcro/plugin-sucrase/node_modules/sucrase/dist/parser/traverser/util.mjs", "packages/@velcro/plugin-sucrase/node_modules/sucrase/dist/parser/util/whitespace.mjs", "packages/@velcro/plugin-sucrase/node_modules/sucrase/dist/parser/util/identifier.mjs", "packages/@velcro/plugin-sucrase/node_modules/sucrase/dist/parser/tokenizer/readWordTree.mjs", "packages/@velcro/plugin-sucrase/node_modules/sucrase/dist/parser/tokenizer/readWord.mjs", "packages/@velcro/plugin-sucrase/node_modules/sucrase/dist/parser/tokenizer/index.mjs", "packages/@velcro/plugin-sucrase/node_modules/sucrase/dist/parser/plugins/jsx/xhtml.mjs", "packages/@velcro/plugin-sucrase/node_modules/sucrase/dist/util/getJSXPragmaInfo.mjs", "packages/@velcro/plugin-sucrase/node_modules/sucrase/dist/transformers/Transformer.mjs", "packages/@velcro/plugin-sucrase/node_modules/sucrase/dist/transformers/JSXTransformer.mjs", "packages/@velcro/plugin-sucrase/node_modules/sucrase/dist/util/getNonTypeIdentifiers.mjs", "packages/@velcro/plugin-sucrase/node_modules/sucrase/dist/CJSImportProcessor.mjs", "packages/@velcro/plugin-sucrase/node_modules/sucrase/dist/computeSourceMap.mjs", "packages/@velcro/plugin-sucrase/node_modules/sucrase/dist/HelperManager.mjs", "packages/@velcro/plugin-sucrase/node_modules/sucrase/dist/identifyShadowedGlobals.mjs", "packages/@velcro/plugin-sucrase/node_modules/sucrase/dist/util/getIdentifierNames.mjs", "packages/@velcro/plugin-sucrase/node_modules/sucrase/dist/NameManager.mjs", "packages/@velcro/plugin-sucrase/node_modules/sucrase/dist/Options-gen-types.mjs", "packages/@velcro/plugin-sucrase/node_modules/sucrase/dist/Options.mjs", "packages/@velcro/plugin-sucrase/node_modules/sucrase/dist/parser/traverser/lval.mjs", "packages/@velcro/plugin-sucrase/node_modules/sucrase/dist/parser/plugins/typescript.mjs", "packages/@velcro/plugin-sucrase/node_modules/sucrase/dist/parser/plugins/jsx/index.mjs", "packages/@velcro/plugin-sucrase/node_modules/sucrase/dist/parser/plugins/types.mjs", "packages/@velcro/plugin-sucrase/node_modules/sucrase/dist/parser/traverser/expression.mjs", "packages/@velcro/plugin-sucrase/node_modules/sucrase/dist/parser/plugins/flow.mjs", "packages/@velcro/plugin-sucrase/node_modules/sucrase/dist/parser/traverser/statement.mjs", "packages/@velcro/plugin-sucrase/node_modules/sucrase/dist/parser/traverser/index.mjs", "packages/@velcro/plugin-sucrase/node_modules/sucrase/dist/parser/index.mjs", "packages/@velcro/plugin-sucrase/node_modules/sucrase/dist/util/isAsyncOperation.mjs", "packages/@velcro/plugin-sucrase/node_modules/sucrase/dist/TokenProcessor.mjs", "packages/@velcro/plugin-sucrase/node_modules/sucrase/dist/util/getClassInfo.mjs", "packages/@velcro/plugin-sucrase/node_modules/sucrase/dist/util/elideImportEquals.mjs", "packages/@velcro/plugin-sucrase/node_modules/sucrase/dist/util/getDeclarationInfo.mjs", "packages/@velcro/plugin-sucrase/node_modules/sucrase/dist/util/shouldElideDefaultExport.mjs", "packages/@velcro/plugin-sucrase/node_modules/sucrase/dist/transformers/CJSImportTransformer.mjs", "packages/@velcro/plugin-sucrase/node_modules/sucrase/dist/transformers/ESMImportTransformer.mjs", "packages/@velcro/plugin-sucrase/node_modules/sucrase/dist/transformers/FlowTransformer.mjs", "packages/@velcro/plugin-sucrase/node_modules/sucrase/dist/transformers/NumericSeparatorTransformer.mjs", "packages/@velcro/plugin-sucrase/node_modules/sucrase/dist/transformers/OptionalCatchBindingTransformer.mjs", "packages/@velcro/plugin-sucrase/node_modules/sucrase/dist/transformers/OptionalChainingNullishTransformer.mjs", "packages/@velcro/plugin-sucrase/node_modules/sucrase/dist/transformers/ReactDisplayNameTransformer.mjs", "packages/@velcro/plugin-sucrase/node_modules/sucrase/dist/transformers/ReactHotLoaderTransformer.mjs", "packages/@velcro/plugin-sucrase/node_modules/sucrase/dist/util/isIdentifier.mjs", "packages/@velcro/plugin-sucrase/node_modules/sucrase/dist/transformers/TypeScriptTransformer.mjs", "packages/@velcro/plugin-sucrase/node_modules/sucrase/dist/transformers/RootTransformer.mjs", "packages/@velcro/plugin-sucrase/node_modules/lines-and-columns/dist/index.mjs", "packages/@velcro/plugin-sucrase/node_modules/sucrase/dist/util/formatTokens.mjs", "packages/@velcro/plugin-sucrase/node_modules/sucrase/dist/util/getTSImportedNames.mjs", "packages/@velcro/plugin-sucrase/node_modules/sucrase/dist/index.mjs", "packages/@velcro/plugin-sucrase/src/sucrase.ts", "packages/@velcro/plugin-sucrase/src/index.ts", "packages/@velcro/resolver/src/bareModules.ts", "packages/@velcro/resolver/src/shims.ts", "packages/@velcro/resolver/src/strategy.ts", "packages/@velcro/resolver/src/context.ts", "packages/@velcro/resolver/src/resolver.ts", "packages/@velcro/resolver/src/index.ts", "packages/@velcro/strategy-cdn/src/cdnStrategy.ts", "packages/@velcro/strategy-cdn/src/index.ts", "packages/@velcro/strategy-compound/src/compoundStrategy.ts", "packages/@velcro/strategy-compound/src/index.ts", "packages/@velcro/strategy-memory/src/memoryStrategy.ts", "packages/@velcro/strategy-memory/src/index.ts", "packages/@velcro/worker/src/fsm.ts", "packages/@velcro/worker/src/worker.ts"],
  "sourcesContent": ["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar util;\n(function (util) {\n    function assertNever(_x) {\n        throw new Error();\n    }\n    util.assertNever = assertNever;\n    util.arrayToEnum = function (items) {\n        var obj = {};\n        for (var _i = 0, items_1 = items; _i < items_1.length; _i++) {\n            var item = items_1[_i];\n            obj[item] = item;\n        }\n        return obj;\n    };\n})(util = exports.util || (exports.util = {}));\n//# sourceMappingURL=util.js.map", "\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar util_1 = require(\"./helpers/util\");\nexports.ZodErrorCode = util_1.util.arrayToEnum([\n    'invalid_type',\n    'nonempty_array_is_empty',\n    'custom_error',\n    'invalid_union',\n    'invalid_literal_value',\n    'invalid_enum_value',\n    'unrecognized_keys',\n    'invalid_arguments',\n    'invalid_return_type',\n    'invalid_date',\n    'invalid_string',\n    'too_small',\n    'too_big',\n]);\nexports.quotelessJson = function (obj) {\n    var json = JSON.stringify(obj, null, 2); // {\"name\":\"John Smith\"}\n    return json.replace(/\"([^\"]+)\":/g, '$1:');\n};\nvar ZodError = /** @class */ (function (_super) {\n    __extends(ZodError, _super);\n    function ZodError(errors) {\n        var _newTarget = this.constructor;\n        var _this = _super.call(this) || this;\n        _this.errors = [];\n        _this.addError = function (sub) {\n            _this.errors = _this.errors.concat([sub]);\n        };\n        _this.addErrors = function (subs) {\n            if (subs === void 0) { subs = []; }\n            _this.errors = _this.errors.concat(subs);\n        };\n        // restore prototype chain\n        var actualProto = _newTarget.prototype;\n        Object.setPrototypeOf(_this, actualProto);\n        _this.errors = errors;\n        return _this;\n    }\n    Object.defineProperty(ZodError.prototype, \"message\", {\n        get: function () {\n            var errorMessage = [this.errors.length + \" validation issue(s)\", ''];\n            for (var _i = 0, _a = this.errors; _i < _a.length; _i++) {\n                var err = _a[_i];\n                errorMessage.push(\"  Issue #\" + this.errors.indexOf(err) + \": \" + err.code + \" at \" + err.path.join('.'));\n                errorMessage.push(\"  \" + err.message);\n                errorMessage.push('');\n            }\n            return errorMessage.join('\\n');\n            // return quotelessJson(this);\n            // .map(({ path, message }) => {\n            //   return path.length ? `${path.join('.')}: ${message}` : `${message}`;\n            // })\n            // .join('\\n');\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ZodError.prototype, \"isEmpty\", {\n        get: function () {\n            return this.errors.length === 0;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ZodError.prototype, \"formErrors\", {\n        get: function () {\n            var fieldErrors = {};\n            var formErrors = [];\n            for (var _i = 0, _a = this.errors; _i < _a.length; _i++) {\n                var sub = _a[_i];\n                if (sub.path.length > 0) {\n                    fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];\n                    fieldErrors[sub.path[0]].push(sub.message);\n                }\n                else {\n                    formErrors.push(sub.message);\n                }\n            }\n            return { formErrors: formErrors, fieldErrors: fieldErrors };\n        },\n        enumerable: true,\n        configurable: true\n    });\n    ZodError.create = function (errors) {\n        var error = new ZodError(errors);\n        return error;\n    };\n    return ZodError;\n}(Error));\nexports.ZodError = ZodError;\n//# sourceMappingURL=ZodError.js.map", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ZodError_1 = require(\"./ZodError\");\nvar util_1 = require(\"./helpers/util\");\nexports.defaultErrorMap = function (error, _ctx) {\n    var message;\n    switch (error.code) {\n        case ZodError_1.ZodErrorCode.invalid_type:\n            if (error.received === 'undefined') {\n                message = 'Required';\n            }\n            else {\n                message = \"Expected \" + error.expected + \", received \" + error.received;\n            }\n            break;\n        case ZodError_1.ZodErrorCode.nonempty_array_is_empty:\n            message = \"List must contain at least one item\";\n            break;\n        case ZodError_1.ZodErrorCode.unrecognized_keys:\n            message = \"Unrecognized key(s) in object: \" + error.keys.map(function (k) { return \"'\" + k + \"'\"; }).join(', ');\n            break;\n        case ZodError_1.ZodErrorCode.invalid_union:\n            message = \"Invalid input\";\n            break;\n        // case ZodErrorCode.invalid_tuple_length:\n        //   message = `Expected list of ${error.expected} items, received ${error.received} items`;\n        //   break;\n        case ZodError_1.ZodErrorCode.invalid_literal_value:\n            message = \"Input must be \\\"\" + error.expected + \"\\\"\";\n            break;\n        case ZodError_1.ZodErrorCode.invalid_enum_value:\n            message = \"Input must be one of these values: \" + error.options.join(', ');\n            break;\n        case ZodError_1.ZodErrorCode.invalid_arguments:\n            message = \"Invalid function arguments\";\n            break;\n        case ZodError_1.ZodErrorCode.invalid_return_type:\n            message = \"Invalid function return type\";\n            break;\n        case ZodError_1.ZodErrorCode.invalid_date:\n            message = \"Invalid date\";\n            break;\n        // case ZodErrorCode.too_small:\n        //   const tooShortNoun = _ctx.data === 'string' ? 'characters' : 'items';\n        //   message = `Too short, should be at least ${error.minimum} ${tooShortNoun}`;\n        //   break;\n        // case ZodErrorCode.too_big:\n        //   const tooLongNoun = _ctx.data === 'string' ? 'characters' : 'items';\n        //   message = `Too short, should be at most ${error.maximum} ${tooLongNoun}`;\n        //   break;\n        case ZodError_1.ZodErrorCode.invalid_string:\n            message = \"Invalid \" + error.validation;\n            break;\n        // case ZodErrorCode.invalid_url:\n        //   message = 'Invalid URL.';\n        //   break;\n        // case ZodErrorCode.invalid_uuid:\n        //   message = 'Invalid UUID.';\n        //   break;\n        case ZodError_1.ZodErrorCode.too_small:\n            if (error.type === 'array')\n                message = \"Should have \" + (error.inclusive ? \"at least\" : \"more than\") + \" \" + error.minimum + \" items\";\n            else if (error.type === 'string')\n                message = \"Should be \" + (error.inclusive ? \"at least\" : \"over\") + \" \" + error.minimum + \" characters\";\n            else if (error.type === 'number')\n                message = \"Value should be greater than \" + (error.inclusive ? \"or equal to \" : \"\") + error.minimum;\n            else\n                message = 'Invalid input';\n            break;\n        case ZodError_1.ZodErrorCode.too_big:\n            if (error.type === 'array')\n                message = \"Should have \" + (error.inclusive ? \"at most\" : \"less than\") + \" \" + error.maximum + \" items\";\n            else if (error.type === 'string')\n                message = \"Should be \" + (error.inclusive ? \"at most\" : \"under\") + \" \" + error.maximum + \" characters long\";\n            else if (error.type === 'number')\n                message = \"Value should be less than \" + (error.inclusive ? \"or equal to \" : \"\") + error.maximum;\n            else\n                message = 'Invalid input';\n            break;\n        case ZodError_1.ZodErrorCode.custom_error:\n            message = \"Invalid input.\";\n            break;\n        default:\n            message = \"Invalid input.\";\n            util_1.util.assertNever(error);\n    }\n    return { message: message };\n    // return `Invalid input.`;\n};\n//# sourceMappingURL=defaultErrorMap.js.map", "\"use strict\";\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\n            t[p[i]] = s[p[i]];\n    return t;\n};\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n};\nvar _this = this;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar z = __importStar(require(\"./types/base\"));\nvar ZodError_1 = require(\"./ZodError\");\nvar util_1 = require(\"./helpers/util\");\nvar defaultErrorMap_1 = require(\"./defaultErrorMap\");\nexports.getParsedType = function (data) {\n    if (typeof data === 'string')\n        return 'string';\n    if (typeof data === 'number') {\n        if (Number.isNaN(data))\n            return 'nan';\n        return 'number';\n    }\n    if (typeof data === 'boolean')\n        return 'boolean';\n    if (typeof data === 'bigint')\n        return 'bigint';\n    if (typeof data === 'symbol')\n        return 'symbol';\n    if (data instanceof Date)\n        return 'date';\n    if (typeof data === 'function')\n        return 'function';\n    if (data === undefined)\n        return 'undefined';\n    if (data === null)\n        return 'null';\n    if (typeof data === 'undefined')\n        return 'undefined';\n    if (typeof data === 'object') {\n        if (Array.isArray(data))\n            return 'array';\n        if (data.then && typeof data.then === 'function' && data.catch && typeof data.catch === 'function') {\n            return 'promise';\n        }\n        return 'object';\n    }\n    return 'unknown';\n};\nexports.ZodParsedType = util_1.util.arrayToEnum([\n    'string',\n    'nan',\n    'number',\n    'integer',\n    'boolean',\n    'date',\n    'bigint',\n    'symbol',\n    'function',\n    'undefined',\n    'null',\n    'array',\n    'object',\n    'unknown',\n    'promise',\n    'void',\n]);\nexports.ZodParser = function (schemaDef) { return function (obj, baseParams) {\n    if (baseParams === void 0) { baseParams = { seen: [], errorMap: defaultErrorMap_1.defaultErrorMap, path: [] }; }\n    var params = {\n        seen: baseParams.seen || [],\n        path: baseParams.path || [],\n        errorMap: baseParams.errorMap || defaultErrorMap_1.defaultErrorMap,\n    };\n    var makeError = function (errorData) {\n        var errorArg = __assign({}, errorData, { path: params.path });\n        var ctxArg = { data: obj };\n        var defaultError = defaultErrorMap_1.defaultErrorMap === params.errorMap\n            ? { message: \"Invalid value.\" }\n            : defaultErrorMap_1.defaultErrorMap(errorArg, __assign({}, ctxArg, { defaultError: \"Invalid value.\" }));\n        return __assign({}, errorData, { path: params.path.concat((errorData.path || [])), message: errorData.message || params.errorMap(errorArg, __assign({}, ctxArg, { defaultError: defaultError.message })).message });\n    };\n    var def = schemaDef;\n    var schemaSeen = params.seen.find(function (x) { return x.schema === schemaDef; });\n    if (schemaSeen) {\n        if (schemaSeen.objects.indexOf(obj) !== -1) {\n            return obj;\n        }\n        else {\n            schemaSeen.objects.push(obj);\n        }\n    }\n    else {\n        params.seen.push({ schema: schemaDef, objects: [obj] });\n    }\n    // }\n    var error = new ZodError_1.ZodError([]);\n    var returnValue = obj;\n    var parsedType = exports.getParsedType(obj);\n    switch (def.t) {\n        case z.ZodTypes.string:\n            if (parsedType !== exports.ZodParsedType.string) {\n                error.addError(makeError({ code: ZodError_1.ZodErrorCode.invalid_type, expected: exports.ZodParsedType.string, received: parsedType }));\n                throw error;\n            }\n            break;\n        case z.ZodTypes.number:\n            if (parsedType !== exports.ZodParsedType.number) {\n                error.addError(makeError({ code: ZodError_1.ZodErrorCode.invalid_type, expected: exports.ZodParsedType.number, received: parsedType }));\n                throw error;\n            }\n            if (Number.isNaN(obj)) {\n                error.addError(makeError({ code: ZodError_1.ZodErrorCode.invalid_type, expected: exports.ZodParsedType.number, received: exports.ZodParsedType.nan }));\n                throw error;\n            }\n            break;\n        case z.ZodTypes.bigint:\n            if (parsedType !== exports.ZodParsedType.bigint) {\n                error.addError(makeError({ code: ZodError_1.ZodErrorCode.invalid_type, expected: exports.ZodParsedType.number, received: parsedType }));\n                throw error;\n            }\n            break;\n        case z.ZodTypes.boolean:\n            if (parsedType !== exports.ZodParsedType.boolean) {\n                error.addError(makeError({ code: ZodError_1.ZodErrorCode.invalid_type, expected: exports.ZodParsedType.boolean, received: parsedType }));\n                throw error;\n            }\n            break;\n        case z.ZodTypes.undefined:\n            if (parsedType !== exports.ZodParsedType.undefined) {\n                error.addError(makeError({ code: ZodError_1.ZodErrorCode.invalid_type, expected: exports.ZodParsedType.undefined, received: parsedType }));\n                throw error;\n            }\n            break;\n        case z.ZodTypes.null:\n            if (parsedType !== exports.ZodParsedType.null) {\n                error.addError(makeError({ code: ZodError_1.ZodErrorCode.invalid_type, expected: exports.ZodParsedType.null, received: parsedType }));\n                throw error;\n            }\n            break;\n        case z.ZodTypes.any:\n            break;\n        case z.ZodTypes.unknown:\n            break;\n        case z.ZodTypes.void:\n            if (parsedType !== exports.ZodParsedType.undefined && parsedType !== exports.ZodParsedType.null) {\n                error.addError(makeError({ code: ZodError_1.ZodErrorCode.invalid_type, expected: exports.ZodParsedType.void, received: parsedType }));\n                throw error;\n            }\n            break;\n        case z.ZodTypes.array:\n            if (parsedType !== exports.ZodParsedType.array) {\n                error.addError(makeError({ code: ZodError_1.ZodErrorCode.invalid_type, expected: exports.ZodParsedType.array, received: parsedType }));\n                throw error;\n            }\n            var data = obj;\n            if (def.nonempty === true && obj.length === 0) {\n                error.addError(makeError({ code: ZodError_1.ZodErrorCode.nonempty_array_is_empty }));\n                throw error;\n            }\n            data.map(function (item, i) {\n                try {\n                    var parsedItem = def.type.parse(item, __assign({}, params, { path: params.path.concat([i]) }));\n                    return parsedItem;\n                }\n                catch (err) {\n                    var zerr = err;\n                    error.addErrors(zerr.errors);\n                }\n            });\n            if (!error.isEmpty) {\n                throw error;\n            }\n            break;\n        case z.ZodTypes.object:\n            if (parsedType !== exports.ZodParsedType.object) {\n                error.addError(makeError({ code: ZodError_1.ZodErrorCode.invalid_type, expected: exports.ZodParsedType.object, received: parsedType }));\n                throw error;\n            }\n            var shape = def.shape();\n            if (def.params.strict) {\n                var shapeKeys_1 = Object.keys(shape);\n                var objKeys = Object.keys(obj);\n                var extraKeys = objKeys.filter(function (k) { return shapeKeys_1.indexOf(k) === -1; });\n                if (extraKeys.length) {\n                    error.addError(makeError({ code: ZodError_1.ZodErrorCode.unrecognized_keys, keys: extraKeys }));\n                }\n            }\n            for (var key in shape) {\n                try {\n                    def.shape()[key].parse(obj[key], __assign({}, params, { path: params.path.concat([key]) }));\n                }\n                catch (err) {\n                    var zerr = err;\n                    error.addErrors(zerr.errors);\n                }\n            }\n            break;\n        case z.ZodTypes.union:\n            var isValid = false;\n            var unionErrors = [];\n            for (var _i = 0, _a = def.options; _i < _a.length; _i++) {\n                var option = _a[_i];\n                try {\n                    option.parse(obj, params);\n                    isValid = true;\n                }\n                catch (err) {\n                    unionErrors.push(err);\n                }\n            }\n            if (!isValid) {\n                var filteredErrors = unionErrors.filter(function (err) {\n                    return err.errors[0].code !== 'invalid_type';\n                });\n                if (filteredErrors.length === 1) {\n                    error.addErrors(filteredErrors[0].errors);\n                }\n                else {\n                    error.addError(makeError({\n                        code: ZodError_1.ZodErrorCode.invalid_union,\n                        unionErrors: unionErrors,\n                    }));\n                }\n            }\n            break;\n        case z.ZodTypes.intersection:\n            try {\n                def.left.parse(obj, params);\n            }\n            catch (err) {\n                error.addErrors(err.errors);\n            }\n            try {\n                def.right.parse(obj, params);\n            }\n            catch (err) {\n                error.addErrors(err.errors);\n            }\n            break;\n        case z.ZodTypes.tuple:\n            if (parsedType !== exports.ZodParsedType.array) {\n                error.addError(makeError({ code: ZodError_1.ZodErrorCode.invalid_type, expected: exports.ZodParsedType.array, received: parsedType }));\n                throw error;\n            }\n            if (obj.length > def.items.length) {\n                error.addError(makeError({ code: ZodError_1.ZodErrorCode.too_big, maximum: def.items.length, inclusive: true, type: 'array' }));\n            }\n            else if (obj.length < def.items.length) {\n                error.addError(makeError({ code: ZodError_1.ZodErrorCode.too_small, minimum: def.items.length, inclusive: true, type: 'array' }));\n            }\n            var parsedTuple = [];\n            var tupleData = obj;\n            for (var index in tupleData) {\n                var item = tupleData[index];\n                var itemParser = def.items[index];\n                try {\n                    parsedTuple.push(itemParser.parse(item, __assign({}, params, { path: params.path.concat([index]) })));\n                }\n                catch (err) {\n                    error.addErrors(err.errors);\n                }\n            }\n            break;\n        case z.ZodTypes.lazy:\n            var lazySchema = def.getter();\n            lazySchema.parse(obj, params);\n            break;\n        case z.ZodTypes.literal:\n            if (obj !== def.value) {\n                error.addError(makeError({ code: ZodError_1.ZodErrorCode.invalid_literal_value, expected: def.value }));\n            }\n            break;\n        case z.ZodTypes.enum:\n            if (def.values.indexOf(obj) === -1) {\n                error.addError(makeError({\n                    code: ZodError_1.ZodErrorCode.invalid_enum_value,\n                    options: def.values,\n                }));\n            }\n            break;\n        case z.ZodTypes.function:\n            if (parsedType !== exports.ZodParsedType.function) {\n                error.addError(makeError({\n                    code: ZodError_1.ZodErrorCode.invalid_type,\n                    expected: exports.ZodParsedType.function,\n                    received: parsedType,\n                }));\n                throw error;\n            }\n            var validatedFunc = function () {\n                var args = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    args[_i] = arguments[_i];\n                }\n                try {\n                    def.args.parse(args);\n                }\n                catch (err) {\n                    if (err instanceof ZodError_1.ZodError) {\n                        var argsError = new ZodError_1.ZodError([]);\n                        argsError.addError(makeError({\n                            code: ZodError_1.ZodErrorCode.invalid_arguments,\n                            argumentsError: err,\n                        }));\n                        throw argsError;\n                    }\n                    throw err;\n                }\n                var result = obj.apply(void 0, args);\n                try {\n                    return def.returns.parse(result);\n                }\n                catch (err) {\n                    if (err instanceof ZodError_1.ZodError) {\n                        var returnsError = new ZodError_1.ZodError([]);\n                        returnsError.addError(makeError({\n                            code: ZodError_1.ZodErrorCode.invalid_return_type,\n                            returnTypeError: err,\n                        }));\n                        throw returnsError;\n                    }\n                    throw err;\n                }\n            };\n            return validatedFunc;\n        case z.ZodTypes.record:\n            if (parsedType !== exports.ZodParsedType.object) {\n                error.addError(makeError({\n                    code: ZodError_1.ZodErrorCode.invalid_type,\n                    expected: exports.ZodParsedType.object,\n                    received: parsedType,\n                }));\n                throw error;\n            }\n            for (var key in obj) {\n                try {\n                    def.valueType.parse(obj[key], __assign({}, params, { path: params.path.concat([key]) }));\n                }\n                catch (err) {\n                    error.addErrors(err.errors);\n                }\n            }\n            break;\n        case z.ZodTypes.date:\n            if (!(obj instanceof Date)) {\n                error.addError(makeError({\n                    code: ZodError_1.ZodErrorCode.invalid_type,\n                    expected: exports.ZodParsedType.date,\n                    received: parsedType,\n                }));\n                throw error;\n            }\n            if (isNaN(obj.getTime())) {\n                console.log('NAN');\n                error.addError(makeError({\n                    code: ZodError_1.ZodErrorCode.invalid_date,\n                }));\n                throw error;\n            }\n            break;\n        case z.ZodTypes.promise:\n            if (parsedType !== exports.ZodParsedType.promise) {\n                error.addError(makeError({\n                    code: ZodError_1.ZodErrorCode.invalid_type,\n                    expected: exports.ZodParsedType.promise,\n                    received: parsedType,\n                }));\n                throw error;\n            }\n            return new Promise(function (res, rej) { return __awaiter(_this, void 0, void 0, function () {\n                var objValue, parsed;\n                return __generator(this, function (_a) {\n                    switch (_a.label) {\n                        case 0: return [4 /*yield*/, obj];\n                        case 1:\n                            objValue = _a.sent();\n                            try {\n                                parsed = def.type.parse(objValue, params);\n                                res(parsed);\n                            }\n                            catch (err) {\n                                rej(err);\n                            }\n                            return [2 /*return*/];\n                    }\n                });\n            }); });\n        default:\n            util_1.util.assertNever(def);\n    }\n    var customChecks = def.checks || [];\n    for (var _b = 0, customChecks_1 = customChecks; _b < customChecks_1.length; _b++) {\n        var check = customChecks_1[_b];\n        if (!check.check(returnValue)) {\n            var checkMethod = check.check, noMethodCheck = __rest(check, [\"check\"]);\n            error.addError(makeError(noMethodCheck));\n        }\n    }\n    if (!error.isEmpty) {\n        throw error;\n    }\n    return returnValue;\n}; };\n//# sourceMappingURL=parser.js.map", "\"use strict\";\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar parser_1 = require(\"../parser\");\nvar __1 = require(\"..\");\nvar ZodTypes;\n(function (ZodTypes) {\n    ZodTypes[\"string\"] = \"string\";\n    ZodTypes[\"number\"] = \"number\";\n    ZodTypes[\"bigint\"] = \"bigint\";\n    ZodTypes[\"boolean\"] = \"boolean\";\n    ZodTypes[\"date\"] = \"date\";\n    ZodTypes[\"undefined\"] = \"undefined\";\n    ZodTypes[\"null\"] = \"null\";\n    ZodTypes[\"array\"] = \"array\";\n    ZodTypes[\"object\"] = \"object\";\n    ZodTypes[\"union\"] = \"union\";\n    ZodTypes[\"intersection\"] = \"intersection\";\n    ZodTypes[\"tuple\"] = \"tuple\";\n    ZodTypes[\"record\"] = \"record\";\n    ZodTypes[\"function\"] = \"function\";\n    ZodTypes[\"lazy\"] = \"lazy\";\n    ZodTypes[\"literal\"] = \"literal\";\n    ZodTypes[\"enum\"] = \"enum\";\n    ZodTypes[\"promise\"] = \"promise\";\n    ZodTypes[\"any\"] = \"any\";\n    ZodTypes[\"unknown\"] = \"unknown\";\n    ZodTypes[\"void\"] = \"void\";\n})(ZodTypes = exports.ZodTypes || (exports.ZodTypes = {}));\nvar ZodType = /** @class */ (function () {\n    function ZodType(def) {\n        var _this = this;\n        this.parseAsync = function (value) {\n            return new Promise(function (res, rej) {\n                try {\n                    var parsed = _this.parse(value);\n                    return res(parsed);\n                }\n                catch (err) {\n                    return rej(err);\n                }\n            });\n        };\n        this.refine = function (check, message) {\n            if (message === void 0) { message = 'Invalid value.'; }\n            if (typeof message === 'string') {\n                return _this.refinement({ check: check, message: message });\n            }\n            return _this.refinement(__assign({ check: check }, message));\n        };\n        this.refinement = function (refinement) {\n            return _this._refinement(__assign({ code: __1.ZodErrorCode.custom_error }, refinement));\n        };\n        this._refinement = function (refinement) {\n            return new _this.constructor(__assign({}, _this._def, { checks: (_this._def.checks || []).concat([refinement]) }));\n        };\n        //  abstract // opt optional: () => any;\n        this.optional = function () { return __1.ZodUnion.create([_this, __1.ZodUndefined.create()]); };\n        this.nullable = function () { return __1.ZodUnion.create([_this, __1.ZodNull.create()]); };\n        this.array = function () { return __1.ZodArray.create(_this); };\n        this.or = function (arg) {\n            return __1.ZodUnion.create([_this, arg]);\n        };\n        this.parse = parser_1.ZodParser(def);\n        this._def = def;\n    }\n    ZodType.prototype.is = function (u) {\n        try {\n            this.parse(u);\n            return true;\n        }\n        catch (err) {\n            return false;\n        }\n    };\n    ZodType.prototype.check = function (u) {\n        try {\n            this.parse(u);\n            return true;\n        }\n        catch (err) {\n            return false;\n        }\n    };\n    return ZodType;\n}());\nexports.ZodType = ZodType;\n//# sourceMappingURL=base.js.map", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar errorUtil;\n(function (errorUtil) {\n    errorUtil.errToObj = function (message) { return (typeof message === 'string' ? { message: message } : message || {}); };\n})(errorUtil = exports.errorUtil || (exports.errorUtil = {}));\n//# sourceMappingURL=errorUtil.js.map", "\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar z = __importStar(require(\"./base\"));\n// import { ZodUndefined } from './undefined';\n// import { ZodNull } from './null';\n// import { ZodUnion } from './union';\nvar __1 = require(\"..\");\nvar errorUtil_1 = require(\"../helpers/errorUtil\");\nvar emailRegex = /^((([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+(\\.([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+)*)|((\\x22)((((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(([\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x7f]|\\x21|[\\x23-\\x5b]|[\\x5d-\\x7e]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(\\\\([\\x01-\\x09\\x0b\\x0c\\x0d-\\x7f]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]))))*(((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(\\x22)))@((([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.)+(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))$/i;\nvar urlRegex = /^((https?|ftp):)?\\/\\/(((([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:)*@)?(((\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5]))|((([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.)+(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.?)(:\\d*)?)(\\/((([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:|@)+(\\/(([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:|@)*)*)?)?(\\?((([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:|@)|[\\uE000-\\uF8FF]|\\/|\\?)*)?(\\#((([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:|@)|\\/|\\?)*)?$/i;\nvar uuidRegex = /([a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}){1}/i;\nvar ZodString = /** @class */ (function (_super) {\n    __extends(ZodString, _super);\n    function ZodString() {\n        // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);\n        _this.toJSON = function () { return _this._def; };\n        _this.min = function (minLength, message) {\n            return _this._refinement(__assign({ check: function (data) { return data.length >= minLength; }, code: __1.ZodErrorCode.too_small, minimum: minLength, type: 'string', inclusive: true }, errorUtil_1.errorUtil.errToObj(message)));\n        };\n        _this.max = function (maxLength, message) {\n            return _this._refinement(__assign({ check: function (data) { return data.length <= maxLength; }, code: __1.ZodErrorCode.too_big, maximum: maxLength, type: 'string', inclusive: true }, errorUtil_1.errorUtil.errToObj(message)));\n        };\n        _this.email = function (message) {\n            return _this._refinement(__assign({ check: function (data) { return emailRegex.test(data); }, code: __1.ZodErrorCode.invalid_string, validation: 'email' }, errorUtil_1.errorUtil.errToObj(message)));\n        };\n        _this.url = function (message) {\n            return _this._refinement(__assign({ check: function (data) { return urlRegex.test(data); }, code: __1.ZodErrorCode.invalid_string, validation: 'url' }, errorUtil_1.errorUtil.errToObj(message)));\n        };\n        _this.uuid = function (message) {\n            return _this._refinement(__assign({ check: function (data) { return uuidRegex.test(data); }, code: __1.ZodErrorCode.invalid_string, validation: 'uuid' }, errorUtil_1.errorUtil.errToObj(message)));\n        };\n        _this.nonempty = function (message) { return _this.min(1, errorUtil_1.errorUtil.errToObj(message)); };\n        return _this;\n    }\n    ZodString.prototype.length = function (len, message) {\n        return this.min(len, message).max(len, message);\n    };\n    ZodString.create = function () {\n        return new ZodString({\n            t: z.ZodTypes.string,\n            validation: {},\n        });\n    };\n    return ZodString;\n}(z.ZodType));\nexports.ZodString = ZodString;\n//# sourceMappingURL=string.js.map", "\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar z = __importStar(require(\"./base\"));\n// import { ZodUndefined } from './undefined';\n// import { ZodNull } from './null';\n// import { ZodUnion } from './union';\nvar __1 = require(\"..\");\nvar errorUtil_1 = require(\"../helpers/errorUtil\");\nvar ZodNumber = /** @class */ (function (_super) {\n    __extends(ZodNumber, _super);\n    function ZodNumber() {\n        // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);\n        _this.toJSON = function () { return _this._def; };\n        _this.min = function (minimum, message) {\n            return _this._refinement(__assign({ check: function (data) { return data >= minimum; }, code: __1.ZodErrorCode.too_small, minimum: minimum, type: 'number', inclusive: true }, errorUtil_1.errorUtil.errToObj(message)));\n        };\n        _this.max = function (maximum, message) {\n            return _this._refinement(__assign({ check: function (data) { return data <= maximum; }, code: __1.ZodErrorCode.too_big, maximum: maximum, type: 'number', inclusive: true }, errorUtil_1.errorUtil.errToObj(message)));\n        };\n        _this.int = function (message) {\n            return _this._refinement(__assign({ check: function (data) { return Number.isInteger(data); }, code: __1.ZodErrorCode.invalid_type, expected: 'integer', received: 'number' }, errorUtil_1.errorUtil.errToObj(message)));\n        };\n        _this.positive = function (message) {\n            return _this._refinement(__assign({ check: function (data) { return data > 0; }, code: __1.ZodErrorCode.too_small, minimum: 0, type: 'number', inclusive: false }, errorUtil_1.errorUtil.errToObj(message)));\n        };\n        _this.negative = function (message) {\n            return _this._refinement(__assign({ check: function (data) { return data < 0; }, code: __1.ZodErrorCode.too_big, maximum: 0, type: 'number', inclusive: false }, errorUtil_1.errorUtil.errToObj(message)));\n        };\n        _this.nonpositive = function (message) {\n            return _this._refinement(__assign({ check: function (data) { return data <= 0; }, code: __1.ZodErrorCode.too_big, maximum: 0, type: 'number', inclusive: true }, errorUtil_1.errorUtil.errToObj(message)));\n        };\n        _this.nonnegative = function (message) {\n            return _this._refinement(__assign({ check: function (data) { return data >= 0; }, code: __1.ZodErrorCode.too_small, minimum: 0, type: 'number', inclusive: true }, errorUtil_1.errorUtil.errToObj(message)));\n        };\n        return _this;\n    }\n    ZodNumber.create = function () {\n        return new ZodNumber({\n            t: z.ZodTypes.number,\n        });\n    };\n    return ZodNumber;\n}(z.ZodType));\nexports.ZodNumber = ZodNumber;\n//# sourceMappingURL=number.js.map", "\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar z = __importStar(require(\"./base\"));\nvar ZodBigInt = /** @class */ (function (_super) {\n    __extends(ZodBigInt, _super);\n    function ZodBigInt() {\n        // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);\n        _this.toJSON = function () { return _this._def; };\n        return _this;\n    }\n    ZodBigInt.create = function () {\n        return new ZodBigInt({\n            t: z.ZodTypes.bigint,\n        });\n    };\n    return ZodBigInt;\n}(z.ZodType));\nexports.ZodBigInt = ZodBigInt;\n//# sourceMappingURL=bigint.js.map", "\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar z = __importStar(require(\"./base\"));\nvar ZodBoolean = /** @class */ (function (_super) {\n    __extends(ZodBoolean, _super);\n    function ZodBoolean() {\n        // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);\n        _this.toJSON = function () { return _this._def; };\n        return _this;\n    }\n    ZodBoolean.create = function () {\n        return new ZodBoolean({\n            t: z.ZodTypes.boolean,\n        });\n    };\n    return ZodBoolean;\n}(z.ZodType));\nexports.ZodBoolean = ZodBoolean;\n//# sourceMappingURL=boolean.js.map", "\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar z = __importStar(require(\"./base\"));\nvar ZodDate = /** @class */ (function (_super) {\n    __extends(ZodDate, _super);\n    function ZodDate() {\n        // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);\n        _this.toJSON = function () { return _this._def; };\n        return _this;\n    }\n    ZodDate.create = function () {\n        return new ZodDate({\n            t: z.ZodTypes.date,\n        });\n    };\n    return ZodDate;\n}(z.ZodType));\nexports.ZodDate = ZodDate;\n//# sourceMappingURL=date.js.map", "\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar z = __importStar(require(\"./base\"));\nvar ZodUndefined = /** @class */ (function (_super) {\n    __extends(ZodUndefined, _super);\n    function ZodUndefined() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.toJSON = function () { return _this._def; };\n        return _this;\n    }\n    // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);\n    // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);\n    ZodUndefined.create = function () {\n        return new ZodUndefined({\n            t: z.ZodTypes.undefined,\n        });\n    };\n    return ZodUndefined;\n}(z.ZodType));\nexports.ZodUndefined = ZodUndefined;\n//# sourceMappingURL=undefined.js.map", "\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar z = __importStar(require(\"./base\"));\nvar ZodNull = /** @class */ (function (_super) {\n    __extends(ZodNull, _super);\n    function ZodNull() {\n        // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);\n        _this.toJSON = function () { return _this._def; };\n        return _this;\n    }\n    ZodNull.create = function () {\n        return new ZodNull({\n            t: z.ZodTypes.null,\n        });\n    };\n    return ZodNull;\n}(z.ZodType));\nexports.ZodNull = ZodNull;\n//# sourceMappingURL=null.js.map", "\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar z = __importStar(require(\"./base\"));\nvar ZodAny = /** @class */ (function (_super) {\n    __extends(ZodAny, _super);\n    function ZodAny() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);\n        // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);\n        _this.toJSON = function () { return _this._def; };\n        return _this;\n    }\n    ZodAny.create = function () {\n        return new ZodAny({\n            t: z.ZodTypes.any,\n        });\n    };\n    return ZodAny;\n}(z.ZodType));\nexports.ZodAny = ZodAny;\n//# sourceMappingURL=any.js.map", "\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar z = __importStar(require(\"./base\"));\nvar ZodUnknown = /** @class */ (function (_super) {\n    __extends(ZodUnknown, _super);\n    function ZodUnknown() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);\n        // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);\n        _this.toJSON = function () { return _this._def; };\n        return _this;\n    }\n    ZodUnknown.create = function () {\n        return new ZodUnknown({\n            t: z.ZodTypes.unknown,\n        });\n    };\n    return ZodUnknown;\n}(z.ZodType));\nexports.ZodUnknown = ZodUnknown;\n//# sourceMappingURL=unknown.js.map", "\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar z = __importStar(require(\"./base\"));\nvar ZodVoid = /** @class */ (function (_super) {\n    __extends(ZodVoid, _super);\n    function ZodVoid() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);\n        // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);\n        _this.toJSON = function () { return _this._def; };\n        return _this;\n    }\n    ZodVoid.create = function () {\n        return new ZodVoid({\n            t: z.ZodTypes.void,\n        });\n    };\n    return ZodVoid;\n}(z.ZodType));\nexports.ZodVoid = ZodVoid;\n//# sourceMappingURL=void.js.map", "\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar z = __importStar(require(\"./base\"));\n// import { ZodUndefined } from './undefined';\n// import { ZodNull } from './null';\n// import { ZodUnion } from './union';\nvar __1 = require(\"..\");\nvar ZodArray = /** @class */ (function (_super) {\n    __extends(ZodArray, _super);\n    function ZodArray() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.toJSON = function () {\n            return {\n                t: _this._def.t,\n                nonempty: _this._def.nonempty,\n                type: _this._def.type.toJSON(),\n            };\n        };\n        // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);\n        // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);\n        _this.min = function (minLength, message) {\n            return _this._refinement(__assign({ check: function (data) { return data.length >= minLength; }, code: __1.ZodErrorCode.too_small, type: 'array', inclusive: true, minimum: minLength }, (typeof message === 'string' ? { message: message } : message)));\n        };\n        _this.max = function (maxLength, message) {\n            return _this._refinement(__assign({ check: function (data) { return data.length <= maxLength; }, code: __1.ZodErrorCode.too_big, type: 'array', inclusive: true, maximum: maxLength }, (typeof message === 'string' ? { message: message } : message)));\n        };\n        _this.length = function (len, message) { return _this.min(len, { message: message }).max(len, { message: message }); };\n        _this.nonempty = function () {\n            return new ZodNonEmptyArray(__assign({}, _this._def, { nonempty: true }));\n        };\n        return _this;\n    }\n    Object.defineProperty(ZodArray.prototype, \"element\", {\n        get: function () {\n            return this._def.type;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    ZodArray.create = function (schema) {\n        return new ZodArray({\n            t: z.ZodTypes.array,\n            type: schema,\n            nonempty: false,\n        });\n    };\n    return ZodArray;\n}(z.ZodType));\nexports.ZodArray = ZodArray;\nvar ZodNonEmptyArray = /** @class */ (function (_super) {\n    __extends(ZodNonEmptyArray, _super);\n    function ZodNonEmptyArray() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.toJSON = function () {\n            return {\n                t: _this._def.t,\n                type: _this._def.type.toJSON(),\n            };\n        };\n        // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);\n        // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);\n        _this.min = function (minLength, message) {\n            return _this._refinement(__assign({ check: function (data) { return data.length >= minLength; }, code: __1.ZodErrorCode.too_small, minimum: minLength, type: 'array', inclusive: true }, (typeof message === 'string' ? { message: message } : message)));\n        };\n        _this.max = function (maxLength, message) {\n            return _this._refinement(__assign({ check: function (data) { return data.length >= maxLength; }, code: __1.ZodErrorCode.too_big, maximum: maxLength, type: 'array', inclusive: true }, (typeof message === 'string' ? { message: message } : message)));\n        };\n        _this.length = function (len, message) { return _this.min(len, { message: message }).max(len, { message: message }); };\n        return _this;\n    }\n    return ZodNonEmptyArray;\n}(z.ZodType));\nexports.ZodNonEmptyArray = ZodNonEmptyArray;\n//# sourceMappingURL=array.js.map", "\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar z = __importStar(require(\"./base\"));\nvar ZodIntersection = /** @class */ (function (_super) {\n    __extends(ZodIntersection, _super);\n    function ZodIntersection() {\n        // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);\n        _this.toJSON = function () { return ({\n            t: _this._def.t,\n            left: _this._def.left.toJSON(),\n            right: _this._def.right.toJSON(),\n        }); };\n        return _this;\n    }\n    ZodIntersection.create = function (left, right) {\n        return new ZodIntersection({\n            t: z.ZodTypes.intersection,\n            left: left,\n            right: right,\n        });\n    };\n    return ZodIntersection;\n}(z.ZodType));\nexports.ZodIntersection = ZodIntersection;\n//# sourceMappingURL=intersection.js.map", "\"use strict\";\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar base_1 = require(\"../types/base\");\nvar intersection_1 = require(\"../types/intersection\");\nvar object_1 = require(\"../types/object\");\nvar objectUtil;\n(function (objectUtil) {\n    objectUtil.mergeShapes = function (first, second) {\n        var firstKeys = Object.keys(first);\n        var secondKeys = Object.keys(second);\n        var sharedKeys = firstKeys.filter(function (k) { return secondKeys.indexOf(k) !== -1; });\n        var sharedShape = {};\n        for (var _i = 0, sharedKeys_1 = sharedKeys; _i < sharedKeys_1.length; _i++) {\n            var k = sharedKeys_1[_i];\n            sharedShape[k] = intersection_1.ZodIntersection.create(first[k], second[k]);\n        }\n        return __assign({}, first, second, sharedShape);\n    };\n    objectUtil.mergeObjects = function (first) { return function (second) {\n        var mergedShape = objectUtil.mergeShapes(first._def.shape(), second._def.shape());\n        var merged = new object_1.ZodObject({\n            t: base_1.ZodTypes.object,\n            checks: (first._def.checks || []).concat((second._def.checks || [])),\n            params: {\n                strict: first.params.strict && second.params.strict,\n            },\n            shape: function () { return mergedShape; },\n        });\n        return merged;\n    }; };\n})(objectUtil = exports.objectUtil || (exports.objectUtil = {}));\n//# sourceMappingURL=objectUtil.js.map", "\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar z = __importStar(require(\"./base\"));\nvar objectUtil_1 = require(\"../helpers/objectUtil\");\nvar AugmentFactory = function (def) { return function (augmentation) {\n    return new ZodObject(__assign({}, def, { shape: function () { return (__assign({}, def.shape(), augmentation)); } }));\n}; };\nvar objectDefToJson = function (def) { return ({\n    t: def.t,\n    shape: Object.assign({}, Object.keys(def.shape()).map(function (k) {\n        var _a;\n        return (_a = {},\n            _a[k] = def.shape()[k].toJSON(),\n            _a);\n    })),\n}); };\nvar ZodObject = /** @class */ (function (_super) {\n    __extends(ZodObject, _super);\n    function ZodObject() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.toJSON = function () { return objectDefToJson(_this._def); };\n        _this.nonstrict = function () {\n            return new ZodObject({\n                shape: _this._def.shape,\n                t: z.ZodTypes.object,\n                params: __assign({}, _this._params, { strict: false }),\n            });\n        };\n        // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);\n        // nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);\n        _this.augment = AugmentFactory(_this._def);\n        _this.extend = AugmentFactory(_this._def);\n        /**\n         * Prior to zod@1.0.12 there was a bug in the\n         * inferred type of merged objects. Please\n         * upgrade if you are experiencing issues.\n         */\n        _this.merge = objectUtil_1.objectUtil.mergeObjects(_this);\n        _this.pick = function (mask) {\n            var shape = {};\n            Object.keys(mask).map(function (key) {\n                shape[key] = _this.shape[key];\n            });\n            return new ZodObject(__assign({}, _this._def, { shape: function () { return shape; } }));\n        };\n        _this.omit = function (mask) {\n            var shape = {};\n            Object.keys(_this.shape).map(function (key) {\n                if (!Object.keys(mask).includes(key)) {\n                    shape[key] = _this.shape[key];\n                }\n            });\n            return new ZodObject(__assign({}, _this._def, { shape: function () { return shape; } }));\n        };\n        _this.partial = function () {\n            var newShape = {};\n            for (var key in _this.shape) {\n                newShape[key] = _this.shape[key].optional();\n            }\n            return new ZodObject(__assign({}, _this._def, { shape: function () { return newShape; } }));\n        };\n        _this.deepPartial = function () {\n            var newShape = {};\n            for (var key in _this.shape) {\n                var fieldSchema = _this.shape[key];\n                if (fieldSchema instanceof ZodObject) {\n                    newShape[key] = fieldSchema.deepPartial().optional();\n                }\n                else {\n                    newShape[key] = _this.shape[key].optional();\n                }\n            }\n            return new ZodObject(__assign({}, _this._def, { shape: function () { return newShape; } }));\n        };\n        return _this;\n    }\n    Object.defineProperty(ZodObject.prototype, \"shape\", {\n        get: function () {\n            return this._def.shape();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ZodObject.prototype, \"params\", {\n        get: function () {\n            return this._def.params;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    ZodObject.create = function (shape) {\n        return new ZodObject({\n            t: z.ZodTypes.object,\n            shape: function () { return shape; },\n            params: {\n                strict: true,\n            },\n        });\n    };\n    ZodObject.lazycreate = function (shape) {\n        return new ZodObject({\n            t: z.ZodTypes.object,\n            shape: shape,\n            params: {\n                strict: true,\n            },\n        });\n    };\n    return ZodObject;\n}(z.ZodType));\nexports.ZodObject = ZodObject;\n//# sourceMappingURL=object.js.map", "\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar z = __importStar(require(\"./base\"));\nvar ZodUnion = /** @class */ (function (_super) {\n    __extends(ZodUnion, _super);\n    function ZodUnion() {\n        // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);\n        _this.toJSON = function () { return ({\n            t: _this._def.t,\n            options: _this._def.options.map(function (x) { return x.toJSON(); }),\n        }); };\n        return _this;\n    }\n    // distribute = <F extends (arg: T[number]) => z.ZodTypeAny>(f: F): ZodUnion<{ [k in keyof T]: ReturnType<F> }> => {\n    //   return ZodUnion.create(this._def.options.map(f) as any);\n    // };\n    ZodUnion.create = function (types) {\n        return new ZodUnion({\n            t: z.ZodTypes.union,\n            options: types,\n        });\n    };\n    return ZodUnion;\n}(z.ZodType));\nexports.ZodUnion = ZodUnion;\n//# sourceMappingURL=union.js.map", "\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar z = __importStar(require(\"./base\"));\nvar ZodTuple = /** @class */ (function (_super) {\n    __extends(ZodTuple, _super);\n    function ZodTuple() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.toJSON = function () { return ({\n            t: _this._def.t,\n            items: _this._def.items.map(function (item) { return item.toJSON(); }),\n        }); };\n        return _this;\n    }\n    // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);\n    // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);\n    ZodTuple.create = function (schemas) {\n        return new ZodTuple({\n            t: z.ZodTypes.tuple,\n            items: schemas,\n        });\n    };\n    return ZodTuple;\n}(z.ZodType));\nexports.ZodTuple = ZodTuple;\n//# sourceMappingURL=tuple.js.map", "\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar z = __importStar(require(\"./base\"));\nvar ZodRecord = /** @class */ (function (_super) {\n    __extends(ZodRecord, _super);\n    function ZodRecord() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.toJSON = function () { return ({\n            t: _this._def.t,\n            valueType: _this._def.valueType.toJSON(),\n        }); };\n        return _this;\n    }\n    // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);\n    // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);\n    ZodRecord.create = function (valueType) {\n        return new ZodRecord({\n            t: z.ZodTypes.record,\n            valueType: valueType,\n        });\n    };\n    return ZodRecord;\n}(z.ZodType));\nexports.ZodRecord = ZodRecord;\n//# sourceMappingURL=record.js.map", "\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar z = __importStar(require(\"./base\"));\nvar tuple_1 = require(\"./tuple\");\n// import { ZodUndefined } from './undefined';\n// import { ZodNull } from './null';\n// import { ZodUnion } from './union';\nvar void_1 = require(\"./void\");\nvar ZodFunction = /** @class */ (function (_super) {\n    __extends(ZodFunction, _super);\n    function ZodFunction() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.args = function () {\n            var items = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                items[_i] = arguments[_i];\n            }\n            return new ZodFunction(__assign({}, _this._def, { args: tuple_1.ZodTuple.create(items) }));\n        };\n        _this.returns = function (returnType) {\n            return new ZodFunction(__assign({}, _this._def, { returns: returnType }));\n        };\n        _this.implement = function (func) {\n            var validatedFunc = _this.parse(func);\n            return validatedFunc;\n        };\n        _this.validate = _this.implement;\n        // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);\n        // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);\n        _this.toJSON = function () {\n            return {\n                t: _this._def.t,\n                args: _this._def.args.toJSON(),\n                returns: _this._def.returns.toJSON(),\n            };\n        };\n        return _this;\n    }\n    ZodFunction.create = function (args, returns) {\n        return new ZodFunction({\n            t: z.ZodTypes.function,\n            args: args || tuple_1.ZodTuple.create([]),\n            returns: returns || void_1.ZodVoid.create(),\n        });\n    };\n    return ZodFunction;\n}(z.ZodType));\nexports.ZodFunction = ZodFunction;\n//# sourceMappingURL=function.js.map", "\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar z = __importStar(require(\"./base\"));\nvar ZodLazy = /** @class */ (function (_super) {\n    __extends(ZodLazy, _super);\n    function ZodLazy() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);\n        // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);\n        _this.toJSON = function () {\n            throw new Error(\"Can't JSONify recursive structure\");\n        };\n        return _this;\n    }\n    Object.defineProperty(ZodLazy.prototype, \"schema\", {\n        get: function () {\n            return this._def.getter();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    ZodLazy.create = function (getter) {\n        return new ZodLazy({\n            t: z.ZodTypes.lazy,\n            getter: getter,\n        });\n    };\n    return ZodLazy;\n}(z.ZodType));\nexports.ZodLazy = ZodLazy;\n//# sourceMappingURL=lazy.js.map", "\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar z = __importStar(require(\"./base\"));\nvar ZodLiteral = /** @class */ (function (_super) {\n    __extends(ZodLiteral, _super);\n    function ZodLiteral() {\n        // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);\n        _this.toJSON = function () { return _this._def; };\n        return _this;\n    }\n    ZodLiteral.create = function (value) {\n        return new ZodLiteral({\n            t: z.ZodTypes.literal,\n            value: value,\n        });\n    };\n    return ZodLiteral;\n}(z.ZodType));\nexports.ZodLiteral = ZodLiteral;\n//# sourceMappingURL=literal.js.map", "\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar z = __importStar(require(\"./base\"));\nvar ZodEnum = /** @class */ (function (_super) {\n    __extends(ZodEnum, _super);\n    function ZodEnum() {\n        // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);\n        _this.toJSON = function () { return _this._def; };\n        return _this;\n    }\n    Object.defineProperty(ZodEnum.prototype, \"options\", {\n        get: function () {\n            return this._def.values;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ZodEnum.prototype, \"enum\", {\n        get: function () {\n            var enumValues = {};\n            for (var _i = 0, _a = this._def.values; _i < _a.length; _i++) {\n                var val = _a[_i];\n                enumValues[val] = val;\n            }\n            return enumValues;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ZodEnum.prototype, \"Values\", {\n        get: function () {\n            var enumValues = {};\n            for (var _i = 0, _a = this._def.values; _i < _a.length; _i++) {\n                var val = _a[_i];\n                enumValues[val] = val;\n            }\n            return enumValues;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ZodEnum.prototype, \"Enum\", {\n        get: function () {\n            var enumValues = {};\n            for (var _i = 0, _a = this._def.values; _i < _a.length; _i++) {\n                var val = _a[_i];\n                enumValues[val] = val;\n            }\n            return enumValues;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    ZodEnum.create = function (values) {\n        return new ZodEnum({\n            t: z.ZodTypes.enum,\n            values: values,\n        });\n    };\n    return ZodEnum;\n}(z.ZodType));\nexports.ZodEnum = ZodEnum;\n//# sourceMappingURL=enum.js.map", "\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar z = __importStar(require(\"./base\"));\nvar ZodPromise = /** @class */ (function (_super) {\n    __extends(ZodPromise, _super);\n    function ZodPromise() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.toJSON = function () {\n            return {\n                t: _this._def.t,\n                type: _this._def.type.toJSON(),\n            };\n        };\n        return _this;\n    }\n    // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);\n    // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);\n    ZodPromise.create = function (schema) {\n        return new ZodPromise({\n            t: z.ZodTypes.promise,\n            type: schema,\n        });\n    };\n    return ZodPromise;\n}(z.ZodType));\nexports.ZodPromise = ZodPromise;\n//# sourceMappingURL=promise.js.map", "\"use strict\";\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar z = __importStar(require(\".\"));\nvar util_1 = require(\"./helpers/util\");\nvar isOptional = function (schema) {\n    var def = schema._def;\n    if (def.t === z.ZodTypes.undefined)\n        return true;\n    else if (def.t === z.ZodTypes.intersection) {\n        return isOptional(def.right) && isOptional(def.left);\n    }\n    else if (def.t === z.ZodTypes.union) {\n        return def.options.map(isOptional).some(function (x) { return x === true; });\n    }\n    return false;\n};\nvar ZodCodeGenerator = /** @class */ (function () {\n    function ZodCodeGenerator() {\n        var _this = this;\n        this.seen = [];\n        this.serial = 0;\n        this.randomId = function () {\n            return \"IZod\" + _this.serial++;\n        };\n        this.findBySchema = function (schema) {\n            return _this.seen.find(function (s) { return s.schema === schema; });\n        };\n        this.findById = function (id) {\n            var found = _this.seen.find(function (s) { return s.id === id; });\n            if (!found)\n                throw new Error(\"Unfound ID: \" + id);\n            return found;\n        };\n        this.dump = function () {\n            return \"\\ntype Identity<T> = T;\\n\\n\" + _this.seen.map(function (item) { return \"type \" + item.id + \" = Identity<\" + item.type + \">;\"; }).join('\\n\\n') + \"\\n\";\n        };\n        this.setType = function (id, type) {\n            var found = _this.findById(id);\n            found.type = type;\n            return found;\n        };\n        this.generate = function (schema) {\n            var found = _this.findBySchema(schema);\n            if (found)\n                return found;\n            var def = schema._def;\n            var id = _this.randomId();\n            var ty = {\n                schema: schema,\n                id: id,\n                type: \"__INCOMPLETE__\",\n            };\n            _this.seen.push(ty);\n            switch (def.t) {\n                case z.ZodTypes.string:\n                    return _this.setType(id, \"string\");\n                case z.ZodTypes.number:\n                    return _this.setType(id, \"number\");\n                case z.ZodTypes.bigint:\n                    return _this.setType(id, \"bigint\");\n                case z.ZodTypes.boolean:\n                    return _this.setType(id, \"boolean\");\n                case z.ZodTypes.date:\n                    return _this.setType(id, \"Date\");\n                case z.ZodTypes.undefined:\n                    return _this.setType(id, \"undefined\");\n                case z.ZodTypes.null:\n                    return _this.setType(id, \"null\");\n                case z.ZodTypes.any:\n                    return _this.setType(id, \"any\");\n                case z.ZodTypes.unknown:\n                    return _this.setType(id, \"unknown\");\n                case z.ZodTypes.void:\n                    return _this.setType(id, \"void\");\n                case z.ZodTypes.literal:\n                    var val = def.value;\n                    var literalType = typeof val === 'string' ? \"\\\"\" + val + \"\\\"\" : \"\" + val;\n                    return _this.setType(id, literalType);\n                case z.ZodTypes.enum:\n                    return _this.setType(id, def.values.map(function (v) { return \"\\\"\" + v + \"\\\"\"; }).join(' | '));\n                case z.ZodTypes.object:\n                    var objectLines = [];\n                    var shape = def.shape();\n                    for (var key in shape) {\n                        var childSchema = shape[key];\n                        var childType = _this.generate(childSchema);\n                        var OPTKEY = isOptional(childSchema) ? '?' : '';\n                        objectLines.push(\"\" + key + OPTKEY + \": \" + childType.id);\n                    }\n                    var baseStruct = \"{\\n\" + objectLines.map(function (line) { return \"  \" + line + \";\"; }).join('\\n') + \"\\n}\";\n                    _this.setType(id, \"\" + baseStruct);\n                    break;\n                case z.ZodTypes.tuple:\n                    var tupleLines = [];\n                    for (var _i = 0, _a = def.items; _i < _a.length; _i++) {\n                        var elSchema = _a[_i];\n                        var elType = _this.generate(elSchema);\n                        tupleLines.push(elType.id);\n                    }\n                    var baseTuple = \"[\\n\" + tupleLines.map(function (line) { return \"  \" + line + \",\"; }).join('\\n') + \"\\n]\";\n                    return _this.setType(id, \"\" + baseTuple);\n                case z.ZodTypes.array:\n                    return _this.setType(id, _this.generate(def.type).id + \"[]\");\n                case z.ZodTypes.function:\n                    var args = _this.generate(def.args);\n                    var returns = _this.generate(def.returns);\n                    return _this.setType(id, \"(...args: \" + args.id + \")=>\" + returns.id);\n                case z.ZodTypes.promise:\n                    var promValue = _this.generate(def.type);\n                    return _this.setType(id, \"Promise<\" + promValue.id + \">\");\n                case z.ZodTypes.union:\n                    var unionLines = [];\n                    for (var _b = 0, _c = def.options; _b < _c.length; _b++) {\n                        var elSchema = _c[_b];\n                        var elType = _this.generate(elSchema);\n                        unionLines.push(elType.id);\n                    }\n                    return _this.setType(id, unionLines.join(\" | \"));\n                case z.ZodTypes.intersection:\n                    return _this.setType(id, _this.generate(def.left).id + \" & \" + _this.generate(def.right).id);\n                case z.ZodTypes.record:\n                    return _this.setType(id, \"{[k:string]: \" + _this.generate(def.valueType).id + \"}\");\n                case z.ZodTypes.lazy:\n                    var lazyType = def.getter();\n                    return _this.setType(id, _this.generate(lazyType).id);\n                default:\n                    util_1.util.assertNever(def);\n            }\n            return _this.findById(id);\n        };\n    }\n    ZodCodeGenerator.create = function () { return new ZodCodeGenerator(); };\n    return ZodCodeGenerator;\n}());\nexports.ZodCodeGenerator = ZodCodeGenerator;\n//# sourceMappingURL=codegen.js.map", "\"use strict\";\n/* ZOD */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar string_1 = require(\"./types/string\");\nexports.ZodString = string_1.ZodString;\nvar number_1 = require(\"./types/number\");\nexports.ZodNumber = number_1.ZodNumber;\nvar bigint_1 = require(\"./types/bigint\");\nexports.ZodBigInt = bigint_1.ZodBigInt;\nvar boolean_1 = require(\"./types/boolean\");\nexports.ZodBoolean = boolean_1.ZodBoolean;\nvar date_1 = require(\"./types/date\");\nexports.ZodDate = date_1.ZodDate;\nvar undefined_1 = require(\"./types/undefined\");\nexports.ZodUndefined = undefined_1.ZodUndefined;\nvar null_1 = require(\"./types/null\");\nexports.ZodNull = null_1.ZodNull;\nvar any_1 = require(\"./types/any\");\nexports.ZodAny = any_1.ZodAny;\nvar unknown_1 = require(\"./types/unknown\");\nexports.ZodUnknown = unknown_1.ZodUnknown;\nvar void_1 = require(\"./types/void\");\nexports.ZodVoid = void_1.ZodVoid;\nvar array_1 = require(\"./types/array\");\nexports.ZodArray = array_1.ZodArray;\nvar object_1 = require(\"./types/object\");\nexports.ZodObject = object_1.ZodObject;\nvar union_1 = require(\"./types/union\");\nexports.ZodUnion = union_1.ZodUnion;\nvar intersection_1 = require(\"./types/intersection\");\nexports.ZodIntersection = intersection_1.ZodIntersection;\nvar tuple_1 = require(\"./types/tuple\");\nexports.ZodTuple = tuple_1.ZodTuple;\nvar record_1 = require(\"./types/record\");\nexports.ZodRecord = record_1.ZodRecord;\nvar function_1 = require(\"./types/function\");\nexports.ZodFunction = function_1.ZodFunction;\nvar lazy_1 = require(\"./types/lazy\");\nexports.ZodLazy = lazy_1.ZodLazy;\nvar literal_1 = require(\"./types/literal\");\nexports.ZodLiteral = literal_1.ZodLiteral;\nvar enum_1 = require(\"./types/enum\");\nexports.ZodEnum = enum_1.ZodEnum;\nvar promise_1 = require(\"./types/promise\");\nexports.ZodPromise = promise_1.ZodPromise;\nvar base_1 = require(\"./types/base\");\nexports.ZodType = base_1.ZodType;\nexports.Schema = base_1.ZodType;\nexports.ZodSchema = base_1.ZodType;\nexports.ZodTypes = base_1.ZodTypes;\nvar ZodError_1 = require(\"./ZodError\");\nexports.ZodError = ZodError_1.ZodError;\nexports.ZodErrorCode = ZodError_1.ZodErrorCode;\nvar parser_1 = require(\"./parser\");\nexports.ZodParsedType = parser_1.ZodParsedType;\nvar codegen_1 = require(\"./codegen\");\nexports.ZodCodeGenerator = codegen_1.ZodCodeGenerator;\nvar stringType = string_1.ZodString.create;\nexports.string = stringType;\nvar numberType = number_1.ZodNumber.create;\nexports.number = numberType;\nvar bigIntType = bigint_1.ZodBigInt.create;\nexports.bigint = bigIntType;\nvar booleanType = boolean_1.ZodBoolean.create;\nexports.boolean = booleanType;\nvar dateType = date_1.ZodDate.create;\nexports.date = dateType;\nvar undefinedType = undefined_1.ZodUndefined.create;\nexports.undefined = undefinedType;\nvar nullType = null_1.ZodNull.create;\nexports.null = nullType;\nvar anyType = any_1.ZodAny.create;\nexports.any = anyType;\nvar unknownType = unknown_1.ZodUnknown.create;\nexports.unknown = unknownType;\nvar voidType = void_1.ZodVoid.create;\nexports.void = voidType;\nvar arrayType = array_1.ZodArray.create;\nexports.array = arrayType;\nvar objectType = object_1.ZodObject.create;\nexports.object = objectType;\nvar unionType = union_1.ZodUnion.create;\nexports.union = unionType;\nvar intersectionType = intersection_1.ZodIntersection.create;\nexports.intersection = intersectionType;\nvar tupleType = tuple_1.ZodTuple.create;\nexports.tuple = tupleType;\nvar recordType = record_1.ZodRecord.create;\nexports.record = recordType;\nvar functionType = function_1.ZodFunction.create;\nexports.function = functionType;\nvar lazyType = lazy_1.ZodLazy.create;\nexports.lazy = lazyType;\nvar literalType = literal_1.ZodLiteral.create;\nexports.literal = literalType;\nvar enumType = enum_1.ZodEnum.create;\nexports.enum = enumType;\nvar promiseType = promise_1.ZodPromise.create;\nexports.promise = promiseType;\nvar ostring = function () { return stringType().optional(); };\nexports.ostring = ostring;\nvar onumber = function () { return numberType().optional(); };\nexports.onumber = onumber;\nvar oboolean = function () { return booleanType().optional(); };\nexports.oboolean = oboolean;\nvar codegen = codegen_1.ZodCodeGenerator.create;\nexports.codegen = codegen;\nvar custom = function (check, params) {\n    return anyType().refine(check, params);\n};\nvar instanceOfType = function (cls, params) {\n    if (params === void 0) { params = { message: \"Input not instance of \" + cls.name }; }\n    return custom(function (data) { return data instanceof cls; }, params);\n};\nexports.instanceof = instanceOfType;\nexports.late = {\n    object: object_1.ZodObject.lazycreate,\n};\n//# sourceMappingURL=index.js.map", "{\n  \"name\": \"@velcro/node-libs\",\n  \"version\": \"0.46.0\",\n  \"description\": \"A curated collection of browser-compatible shims for node core modules\",\n  \"keywords\": [\n    \"node\",\n    \"core\",\n    \"libs\",\n    \"shim\",\n    \"browser\",\n    \"webpack\",\n    \"browserify\"\n  ],\n  \"author\": \"Geoff Goodman <ggoodman@gmail.com>\",\n  \"homepage\": \"https://github.com/ggoodman/velcro\",\n  \"license\": \"MIT\",\n  \"main\": \"lib/index.js\",\n  \"files\": [\n    \"lib\"\n  ],\n  \"publishConfig\": {\n    \"access\": \"public\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git@github.com:ggoodman/velcro.git\"\n  },\n  \"scripts\": {\n    \"build\": \"echo Nothing to build\",\n    \"test\": \"echo Nothing to test\"\n  },\n  \"dependencies\": {\n    \"@types/hapi__code\": \"^5.3.0\",\n    \"@wessberg/rollup-plugin-ts\": \"^1.2.27\",\n    \"assert\": \"1.4.1\",\n    \"browserify-zlib\": \"^0.2.0\",\n    \"buffer\": \"5.2.1\",\n    \"crypto-browserify\": \"3.12.0\",\n    \"events\": \"3.0.0\",\n    \"memfs\": \"^2.15.5\",\n    \"node-libs-browser\": \"^2.2.0\",\n    \"os-browserify\": \"^0.3.0\",\n    \"querystring\": \"^0.2.0\",\n    \"readable-stream\": \"^3.3.0\",\n    \"stream-http\": \"^3.0.0\",\n    \"string_decoder\": \"^1.2.0\",\n    \"url-parse\": \"^1.4.6\",\n    \"util\": \"^0.11.1\",\n    \"vmdom\": \"^0.0.23\"\n  },\n  \"devDependencies\": {\n    \"@microsoft/api-documenter\": \"^7.8.1\",\n    \"@microsoft/api-extractor\": \"^7.8.1\",\n    \"@rollup/plugin-alias\": \"^3.1.0\",\n    \"@rollup/plugin-replace\": \"^2.3.2\",\n    \"@types/node\": \"^11.11.3\",\n    \"@wessberg/rollup-plugin-ts\": \"^1.2.27\",\n    \"eslint\": \"^5.16.0\"\n  },\n  \"prettier\": {\n    \"printWidth\": 120,\n    \"singleQuote\": true,\n    \"tabWidth\": 2,\n    \"trailingComma\": \"es5\"\n  },\n  \"gitHead\": \"f63b45ad688f2fe9768349afeaf449c016bf33ef\"\n}\n", "\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Error thrown by validation. Besides an informative message, it includes the path to the\n * property which triggered the failure.\n */\nvar VError = /** @class */ (function (_super) {\n    __extends(VError, _super);\n    function VError(path, message) {\n        var _this = _super.call(this, message) || this;\n        _this.path = path;\n        return _this;\n    }\n    return VError;\n}(Error));\nexports.VError = VError;\n/**\n * Fast implementation of IContext used for first-pass validation. If that fails, we can validate\n * using DetailContext to collect error messages. That's faster for the common case when messages\n * normally pass validation.\n */\nvar NoopContext = /** @class */ (function () {\n    function NoopContext() {\n    }\n    NoopContext.prototype.fail = function (relPath, message, score) {\n        return false;\n    };\n    NoopContext.prototype.unionResolver = function () { return this; };\n    NoopContext.prototype.createContext = function () { return this; };\n    NoopContext.prototype.resolveUnion = function (ur) { };\n    return NoopContext;\n}());\nexports.NoopContext = NoopContext;\n/**\n * Complete implementation of IContext that collects meaningfull errors.\n */\nvar DetailContext = /** @class */ (function () {\n    function DetailContext() {\n        // Stack of property names and associated messages for reporting helpful error messages.\n        this._propNames = [\"\"];\n        this._messages = [null];\n        // Score is used to choose the best union member whose DetailContext to use for reporting.\n        // Higher score means better match (or rather less severe mismatch).\n        this._score = 0;\n    }\n    DetailContext.prototype.fail = function (relPath, message, score) {\n        this._propNames.push(relPath);\n        this._messages.push(message);\n        this._score += score;\n        return false;\n    };\n    DetailContext.prototype.unionResolver = function () {\n        return new DetailUnionResolver();\n    };\n    DetailContext.prototype.resolveUnion = function (unionResolver) {\n        var _a, _b;\n        var u = unionResolver;\n        var best = null;\n        for (var _i = 0, _c = u.contexts; _i < _c.length; _i++) {\n            var ctx = _c[_i];\n            if (!best || ctx._score >= best._score) {\n                best = ctx;\n            }\n        }\n        if (best && best._score > 0) {\n            (_a = this._propNames).push.apply(_a, best._propNames);\n            (_b = this._messages).push.apply(_b, best._messages);\n        }\n    };\n    DetailContext.prototype.getError = function (path) {\n        var msgParts = [];\n        for (var i = this._propNames.length - 1; i >= 0; i--) {\n            var p = this._propNames[i];\n            path += (typeof p === \"number\") ? \"[\" + p + \"]\" : (p ? \".\" + p : \"\");\n            var m = this._messages[i];\n            if (m) {\n                msgParts.push(path + \" \" + m);\n            }\n        }\n        return new VError(path, msgParts.join(\"; \"));\n    };\n    DetailContext.prototype.getErrorDetail = function (path) {\n        var details = [];\n        for (var i = this._propNames.length - 1; i >= 0; i--) {\n            var p = this._propNames[i];\n            path += (typeof p === \"number\") ? \"[\" + p + \"]\" : (p ? \".\" + p : \"\");\n            var message = this._messages[i];\n            if (message) {\n                details.push({ path: path, message: message });\n            }\n        }\n        var detail = null;\n        for (var i = details.length - 1; i >= 0; i--) {\n            if (detail) {\n                details[i].nested = [detail];\n            }\n            detail = details[i];\n        }\n        return detail;\n    };\n    return DetailContext;\n}());\nexports.DetailContext = DetailContext;\nvar DetailUnionResolver = /** @class */ (function () {\n    function DetailUnionResolver() {\n        this.contexts = [];\n    }\n    DetailUnionResolver.prototype.createContext = function () {\n        var ctx = new DetailContext();\n        this.contexts.push(ctx);\n        return ctx;\n    };\n    return DetailUnionResolver;\n}());\n", "\"use strict\";\n/**\n * This module defines nodes used to define types and validations for objects and interfaces.\n */\n// tslint:disable:no-shadowed-variable prefer-for-of\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar util_1 = require(\"./util\");\n/** Node that represents a type. */\nvar TType = /** @class */ (function () {\n    function TType() {\n    }\n    return TType;\n}());\nexports.TType = TType;\n/** Parses a type spec into a TType node. */\nfunction parseSpec(typeSpec) {\n    return typeof typeSpec === \"string\" ? name(typeSpec) : typeSpec;\n}\nfunction getNamedType(suite, name) {\n    var ttype = suite[name];\n    if (!ttype) {\n        throw new Error(\"Unknown type \" + name);\n    }\n    return ttype;\n}\n/**\n * Defines a type name, either built-in, or defined in this suite. It can typically be included in\n * the specs as just a plain string.\n */\nfunction name(value) { return new TName(value); }\nexports.name = name;\nvar TName = /** @class */ (function (_super) {\n    __extends(TName, _super);\n    function TName(name) {\n        var _this = _super.call(this) || this;\n        _this.name = name;\n        _this._failMsg = \"is not a \" + name;\n        return _this;\n    }\n    TName.prototype.getChecker = function (suite, strict, allowedProps) {\n        var _this = this;\n        var ttype = getNamedType(suite, this.name);\n        var checker = ttype.getChecker(suite, strict, allowedProps);\n        if (ttype instanceof BasicType || ttype instanceof TName) {\n            return checker;\n        }\n        // For complex types, add an additional \"is not a <Type>\" message on failure.\n        return function (value, ctx) { return checker(value, ctx) ? true : ctx.fail(null, _this._failMsg, 0); };\n    };\n    return TName;\n}(TType));\nexports.TName = TName;\n/**\n * Defines a literal value, e.g. lit('hello') or lit(123).\n */\nfunction lit(value) { return new TLiteral(value); }\nexports.lit = lit;\nvar TLiteral = /** @class */ (function (_super) {\n    __extends(TLiteral, _super);\n    function TLiteral(value) {\n        var _this = _super.call(this) || this;\n        _this.value = value;\n        _this.name = JSON.stringify(value);\n        _this._failMsg = \"is not \" + _this.name;\n        return _this;\n    }\n    TLiteral.prototype.getChecker = function (suite, strict) {\n        var _this = this;\n        return function (value, ctx) { return (value === _this.value) ? true : ctx.fail(null, _this._failMsg, -1); };\n    };\n    return TLiteral;\n}(TType));\nexports.TLiteral = TLiteral;\n/**\n * Defines an array type, e.g. array('number').\n */\nfunction array(typeSpec) { return new TArray(parseSpec(typeSpec)); }\nexports.array = array;\nvar TArray = /** @class */ (function (_super) {\n    __extends(TArray, _super);\n    function TArray(ttype) {\n        var _this = _super.call(this) || this;\n        _this.ttype = ttype;\n        return _this;\n    }\n    TArray.prototype.getChecker = function (suite, strict) {\n        var itemChecker = this.ttype.getChecker(suite, strict);\n        return function (value, ctx) {\n            if (!Array.isArray(value)) {\n                return ctx.fail(null, \"is not an array\", 0);\n            }\n            for (var i = 0; i < value.length; i++) {\n                var ok = itemChecker(value[i], ctx);\n                if (!ok) {\n                    return ctx.fail(i, null, 1);\n                }\n            }\n            return true;\n        };\n    };\n    return TArray;\n}(TType));\nexports.TArray = TArray;\n/**\n * Defines a tuple type, e.g. tuple('string', 'number').\n */\nfunction tuple() {\n    var typeSpec = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        typeSpec[_i] = arguments[_i];\n    }\n    return new TTuple(typeSpec.map(function (t) { return parseSpec(t); }));\n}\nexports.tuple = tuple;\nvar TTuple = /** @class */ (function (_super) {\n    __extends(TTuple, _super);\n    function TTuple(ttypes) {\n        var _this = _super.call(this) || this;\n        _this.ttypes = ttypes;\n        return _this;\n    }\n    TTuple.prototype.getChecker = function (suite, strict) {\n        var itemCheckers = this.ttypes.map(function (t) { return t.getChecker(suite, strict); });\n        var checker = function (value, ctx) {\n            if (!Array.isArray(value)) {\n                return ctx.fail(null, \"is not an array\", 0);\n            }\n            for (var i = 0; i < itemCheckers.length; i++) {\n                var ok = itemCheckers[i](value[i], ctx);\n                if (!ok) {\n                    return ctx.fail(i, null, 1);\n                }\n            }\n            return true;\n        };\n        if (!strict) {\n            return checker;\n        }\n        return function (value, ctx) {\n            if (!checker(value, ctx)) {\n                return false;\n            }\n            return value.length <= itemCheckers.length ? true :\n                ctx.fail(itemCheckers.length, \"is extraneous\", 2);\n        };\n    };\n    return TTuple;\n}(TType));\nexports.TTuple = TTuple;\n/**\n * Defines a union type, e.g. union('number', 'null').\n */\nfunction union() {\n    var typeSpec = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        typeSpec[_i] = arguments[_i];\n    }\n    return new TUnion(typeSpec.map(function (t) { return parseSpec(t); }));\n}\nexports.union = union;\nvar TUnion = /** @class */ (function (_super) {\n    __extends(TUnion, _super);\n    function TUnion(ttypes) {\n        var _this = _super.call(this) || this;\n        _this.ttypes = ttypes;\n        var names = ttypes.map(function (t) { return t instanceof TName || t instanceof TLiteral ? t.name : null; })\n            .filter(function (n) { return n; });\n        var otherTypes = ttypes.length - names.length;\n        if (names.length) {\n            if (otherTypes > 0) {\n                names.push(otherTypes + \" more\");\n            }\n            _this._failMsg = \"is none of \" + names.join(\", \");\n        }\n        else {\n            _this._failMsg = \"is none of \" + otherTypes + \" types\";\n        }\n        return _this;\n    }\n    TUnion.prototype.getChecker = function (suite, strict) {\n        var _this = this;\n        var itemCheckers = this.ttypes.map(function (t) { return t.getChecker(suite, strict); });\n        return function (value, ctx) {\n            var ur = ctx.unionResolver();\n            for (var i = 0; i < itemCheckers.length; i++) {\n                var ok = itemCheckers[i](value, ur.createContext());\n                if (ok) {\n                    return true;\n                }\n            }\n            ctx.resolveUnion(ur);\n            return ctx.fail(null, _this._failMsg, 0);\n        };\n    };\n    return TUnion;\n}(TType));\nexports.TUnion = TUnion;\n/**\n * Defines an intersection type, e.g. intersection('number', 'null').\n */\nfunction intersection() {\n    var typeSpec = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        typeSpec[_i] = arguments[_i];\n    }\n    return new TIntersection(typeSpec.map(function (t) { return parseSpec(t); }));\n}\nexports.intersection = intersection;\nvar TIntersection = /** @class */ (function (_super) {\n    __extends(TIntersection, _super);\n    function TIntersection(ttypes) {\n        var _this = _super.call(this) || this;\n        _this.ttypes = ttypes;\n        return _this;\n    }\n    TIntersection.prototype.getChecker = function (suite, strict) {\n        var allowedProps = new Set();\n        var itemCheckers = this.ttypes.map(function (t) { return t.getChecker(suite, strict, allowedProps); });\n        return function (value, ctx) {\n            var ok = itemCheckers.every(function (checker) { return checker(value, ctx); });\n            if (ok) {\n                return true;\n            }\n            return ctx.fail(null, null, 0);\n        };\n    };\n    return TIntersection;\n}(TType));\nexports.TIntersection = TIntersection;\n/**\n * Defines an enum type, e.g. enum({'A': 1, 'B': 2}).\n */\nfunction enumtype(values) {\n    return new TEnumType(values);\n}\nexports.enumtype = enumtype;\nvar TEnumType = /** @class */ (function (_super) {\n    __extends(TEnumType, _super);\n    function TEnumType(members) {\n        var _this = _super.call(this) || this;\n        _this.members = members;\n        _this.validValues = new Set();\n        _this._failMsg = \"is not a valid enum value\";\n        _this.validValues = new Set(Object.keys(members).map(function (name) { return members[name]; }));\n        return _this;\n    }\n    TEnumType.prototype.getChecker = function (suite, strict) {\n        var _this = this;\n        return function (value, ctx) {\n            return (_this.validValues.has(value) ? true : ctx.fail(null, _this._failMsg, 0));\n        };\n    };\n    return TEnumType;\n}(TType));\nexports.TEnumType = TEnumType;\n/**\n * Defines a literal enum value, such as Direction.Up, specified as enumlit(\"Direction\", \"Up\").\n */\nfunction enumlit(name, prop) {\n    return new TEnumLiteral(name, prop);\n}\nexports.enumlit = enumlit;\nvar TEnumLiteral = /** @class */ (function (_super) {\n    __extends(TEnumLiteral, _super);\n    function TEnumLiteral(enumName, prop) {\n        var _this = _super.call(this) || this;\n        _this.enumName = enumName;\n        _this.prop = prop;\n        _this._failMsg = \"is not \" + enumName + \".\" + prop;\n        return _this;\n    }\n    TEnumLiteral.prototype.getChecker = function (suite, strict) {\n        var _this = this;\n        var ttype = getNamedType(suite, this.enumName);\n        if (!(ttype instanceof TEnumType)) {\n            throw new Error(\"Type \" + this.enumName + \" used in enumlit is not an enum type\");\n        }\n        var val = ttype.members[this.prop];\n        if (!ttype.members.hasOwnProperty(this.prop)) {\n            throw new Error(\"Unknown value \" + this.enumName + \".\" + this.prop + \" used in enumlit\");\n        }\n        return function (value, ctx) { return (value === val) ? true : ctx.fail(null, _this._failMsg, -1); };\n    };\n    return TEnumLiteral;\n}(TType));\nexports.TEnumLiteral = TEnumLiteral;\nfunction makeIfaceProps(props) {\n    return Object.keys(props).map(function (name) { return makeIfaceProp(name, props[name]); });\n}\nfunction makeIfaceProp(name, prop) {\n    return prop instanceof TOptional ?\n        new TProp(name, prop.ttype, true) :\n        new TProp(name, parseSpec(prop), false);\n}\n/**\n * Defines an interface. The first argument is an array of interfaces that it extends, and the\n * second is an array of properties.\n */\nfunction iface(bases, props) {\n    return new TIface(bases, makeIfaceProps(props));\n}\nexports.iface = iface;\nvar TIface = /** @class */ (function (_super) {\n    __extends(TIface, _super);\n    function TIface(bases, props) {\n        var _this = _super.call(this) || this;\n        _this.bases = bases;\n        _this.props = props;\n        _this.propSet = new Set(props.map(function (p) { return p.name; }));\n        return _this;\n    }\n    TIface.prototype.getChecker = function (suite, strict, allowedProps) {\n        var _this = this;\n        var baseCheckers = this.bases.map(function (b) { return getNamedType(suite, b).getChecker(suite, strict); });\n        var propCheckers = this.props.map(function (prop) { return prop.ttype.getChecker(suite, strict); });\n        var testCtx = new util_1.NoopContext();\n        // Consider a prop required if it's not optional AND does not allow for undefined as a value.\n        var isPropRequired = this.props.map(function (prop, i) {\n            return !prop.isOpt && !propCheckers[i](undefined, testCtx);\n        });\n        var checker = function (value, ctx) {\n            if (typeof value !== \"object\" || value === null) {\n                return ctx.fail(null, \"is not an object\", 0);\n            }\n            for (var i = 0; i < baseCheckers.length; i++) {\n                if (!baseCheckers[i](value, ctx)) {\n                    return false;\n                }\n            }\n            for (var i = 0; i < propCheckers.length; i++) {\n                var name_1 = _this.props[i].name;\n                var v = value[name_1];\n                if (v === undefined) {\n                    if (isPropRequired[i]) {\n                        return ctx.fail(name_1, \"is missing\", 1);\n                    }\n                }\n                else {\n                    var ok = propCheckers[i](v, ctx);\n                    if (!ok) {\n                        return ctx.fail(name_1, null, 1);\n                    }\n                }\n            }\n            return true;\n        };\n        if (!strict) {\n            return checker;\n        }\n        var propSet = this.propSet;\n        if (allowedProps) {\n            this.propSet.forEach(function (prop) { return allowedProps.add(prop); });\n            propSet = allowedProps;\n        }\n        // In strict mode, check also for unknown enumerable properties.\n        return function (value, ctx) {\n            if (!checker(value, ctx)) {\n                return false;\n            }\n            for (var prop in value) {\n                if (!propSet.has(prop)) {\n                    return ctx.fail(prop, \"is extraneous\", 2);\n                }\n            }\n            return true;\n        };\n    };\n    return TIface;\n}(TType));\nexports.TIface = TIface;\n/**\n * Defines an optional property on an interface.\n */\nfunction opt(typeSpec) { return new TOptional(parseSpec(typeSpec)); }\nexports.opt = opt;\nvar TOptional = /** @class */ (function (_super) {\n    __extends(TOptional, _super);\n    function TOptional(ttype) {\n        var _this = _super.call(this) || this;\n        _this.ttype = ttype;\n        return _this;\n    }\n    TOptional.prototype.getChecker = function (suite, strict) {\n        var itemChecker = this.ttype.getChecker(suite, strict);\n        return function (value, ctx) {\n            return value === undefined || itemChecker(value, ctx);\n        };\n    };\n    return TOptional;\n}(TType));\nexports.TOptional = TOptional;\n/**\n * Defines a property in an interface.\n */\nvar TProp = /** @class */ (function () {\n    function TProp(name, ttype, isOpt) {\n        this.name = name;\n        this.ttype = ttype;\n        this.isOpt = isOpt;\n    }\n    return TProp;\n}());\nexports.TProp = TProp;\n/**\n * Defines a function. The first argument declares the function's return type, the rest declare\n * its parameters.\n */\nfunction func(resultSpec) {\n    var params = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        params[_i - 1] = arguments[_i];\n    }\n    return new TFunc(new TParamList(params), parseSpec(resultSpec));\n}\nexports.func = func;\nvar TFunc = /** @class */ (function (_super) {\n    __extends(TFunc, _super);\n    function TFunc(paramList, result) {\n        var _this = _super.call(this) || this;\n        _this.paramList = paramList;\n        _this.result = result;\n        return _this;\n    }\n    TFunc.prototype.getChecker = function (suite, strict) {\n        return function (value, ctx) {\n            return typeof value === \"function\" ? true : ctx.fail(null, \"is not a function\", 0);\n        };\n    };\n    return TFunc;\n}(TType));\nexports.TFunc = TFunc;\n/**\n * Defines a function parameter.\n */\nfunction param(name, typeSpec, isOpt) {\n    return new TParam(name, parseSpec(typeSpec), Boolean(isOpt));\n}\nexports.param = param;\nvar TParam = /** @class */ (function () {\n    function TParam(name, ttype, isOpt) {\n        this.name = name;\n        this.ttype = ttype;\n        this.isOpt = isOpt;\n    }\n    return TParam;\n}());\nexports.TParam = TParam;\n/**\n * Defines a function parameter list.\n */\nvar TParamList = /** @class */ (function (_super) {\n    __extends(TParamList, _super);\n    function TParamList(params) {\n        var _this = _super.call(this) || this;\n        _this.params = params;\n        return _this;\n    }\n    TParamList.prototype.getChecker = function (suite, strict) {\n        var _this = this;\n        var itemCheckers = this.params.map(function (t) { return t.ttype.getChecker(suite, strict); });\n        var testCtx = new util_1.NoopContext();\n        var isParamRequired = this.params.map(function (param, i) {\n            return !param.isOpt && !itemCheckers[i](undefined, testCtx);\n        });\n        var checker = function (value, ctx) {\n            if (!Array.isArray(value)) {\n                return ctx.fail(null, \"is not an array\", 0);\n            }\n            for (var i = 0; i < itemCheckers.length; i++) {\n                var p = _this.params[i];\n                if (value[i] === undefined) {\n                    if (isParamRequired[i]) {\n                        return ctx.fail(p.name, \"is missing\", 1);\n                    }\n                }\n                else {\n                    var ok = itemCheckers[i](value[i], ctx);\n                    if (!ok) {\n                        return ctx.fail(p.name, null, 1);\n                    }\n                }\n            }\n            return true;\n        };\n        if (!strict) {\n            return checker;\n        }\n        return function (value, ctx) {\n            if (!checker(value, ctx)) {\n                return false;\n            }\n            return value.length <= itemCheckers.length ? true :\n                ctx.fail(itemCheckers.length, \"is extraneous\", 2);\n        };\n    };\n    return TParamList;\n}(TType));\nexports.TParamList = TParamList;\n/**\n * Single TType implementation for all basic built-in types.\n */\nvar BasicType = /** @class */ (function (_super) {\n    __extends(BasicType, _super);\n    function BasicType(validator, message) {\n        var _this = _super.call(this) || this;\n        _this.validator = validator;\n        _this.message = message;\n        return _this;\n    }\n    BasicType.prototype.getChecker = function (suite, strict) {\n        var _this = this;\n        return function (value, ctx) { return _this.validator(value) ? true : ctx.fail(null, _this.message, 0); };\n    };\n    return BasicType;\n}(TType));\nexports.BasicType = BasicType;\n/**\n * Defines the suite of basic types.\n */\nexports.basicTypes = {\n    any: new BasicType(function (v) { return true; }, \"is invalid\"),\n    number: new BasicType(function (v) { return (typeof v === \"number\"); }, \"is not a number\"),\n    object: new BasicType(function (v) { return (typeof v === \"object\" && v); }, \"is not an object\"),\n    boolean: new BasicType(function (v) { return (typeof v === \"boolean\"); }, \"is not a boolean\"),\n    string: new BasicType(function (v) { return (typeof v === \"string\"); }, \"is not a string\"),\n    symbol: new BasicType(function (v) { return (typeof v === \"symbol\"); }, \"is not a symbol\"),\n    void: new BasicType(function (v) { return (v == null); }, \"is not void\"),\n    undefined: new BasicType(function (v) { return (v === undefined); }, \"is not undefined\"),\n    null: new BasicType(function (v) { return (v === null); }, \"is not null\"),\n    never: new BasicType(function (v) { return false; }, \"is unexpected\"),\n    Date: new BasicType(getIsNativeChecker(\"[object Date]\"), \"is not a Date\"),\n    RegExp: new BasicType(getIsNativeChecker(\"[object RegExp]\"), \"is not a RegExp\"),\n};\n// This approach for checking native object types mirrors that of lodash. Its advantage over\n// `isinstance` is that it can still return true for native objects created in different JS\n// execution environments.\nvar nativeToString = Object.prototype.toString;\nfunction getIsNativeChecker(tag) {\n    return function (v) { return typeof v === \"object\" && v && nativeToString.call(v) === tag; };\n}\nif (typeof Buffer !== \"undefined\") {\n    exports.basicTypes.Buffer = new BasicType(function (v) { return Buffer.isBuffer(v); }, \"is not a Buffer\");\n}\nvar _loop_1 = function (array_1) {\n    exports.basicTypes[array_1.name] = new BasicType(function (v) { return (v instanceof array_1); }, \"is not a \" + array_1.name);\n};\n// Support typed arrays of various flavors\nfor (var _i = 0, _a = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array,\n    Int32Array, Uint32Array, Float32Array, Float64Array, ArrayBuffer]; _i < _a.length; _i++) {\n    var array_1 = _a[_i];\n    _loop_1(array_1);\n}\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar types_1 = require(\"./types\");\nvar util_1 = require(\"./util\");\n/**\n * Export functions used to define interfaces.\n */\nvar types_2 = require(\"./types\");\nexports.TArray = types_2.TArray;\nexports.TEnumType = types_2.TEnumType;\nexports.TEnumLiteral = types_2.TEnumLiteral;\nexports.TFunc = types_2.TFunc;\nexports.TIface = types_2.TIface;\nexports.TLiteral = types_2.TLiteral;\nexports.TName = types_2.TName;\nexports.TOptional = types_2.TOptional;\nexports.TParam = types_2.TParam;\nexports.TParamList = types_2.TParamList;\nexports.TProp = types_2.TProp;\nexports.TTuple = types_2.TTuple;\nexports.TType = types_2.TType;\nexports.TUnion = types_2.TUnion;\nexports.TIntersection = types_2.TIntersection;\nexports.array = types_2.array;\nexports.enumlit = types_2.enumlit;\nexports.enumtype = types_2.enumtype;\nexports.func = types_2.func;\nexports.iface = types_2.iface;\nexports.lit = types_2.lit;\nexports.name = types_2.name;\nexports.opt = types_2.opt;\nexports.param = types_2.param;\nexports.tuple = types_2.tuple;\nexports.union = types_2.union;\nexports.intersection = types_2.intersection;\nexports.BasicType = types_2.BasicType;\n/**\n * Takes one of more type suites (e.g. a module generated by `ts-interface-builder`), and combines\n * them into a suite of interface checkers. If a type is used by name, that name should be present\n * among the passed-in type suites.\n *\n * The returned object maps type names to Checker objects.\n */\nfunction createCheckers() {\n    var typeSuite = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        typeSuite[_i] = arguments[_i];\n    }\n    var fullSuite = Object.assign.apply(Object, [{}, types_1.basicTypes].concat(typeSuite));\n    var checkers = {};\n    for (var _a = 0, typeSuite_1 = typeSuite; _a < typeSuite_1.length; _a++) {\n        var suite_1 = typeSuite_1[_a];\n        for (var _b = 0, _c = Object.keys(suite_1); _b < _c.length; _b++) {\n            var name = _c[_b];\n            checkers[name] = new Checker(fullSuite, suite_1[name]);\n        }\n    }\n    return checkers;\n}\nexports.createCheckers = createCheckers;\n/**\n * Checker implements validation of objects, and also includes accessors to validate method calls.\n * Checkers should be created using `createCheckers()`.\n */\nvar Checker = /** @class */ (function () {\n    // Create checkers by using `createCheckers()` function.\n    function Checker(suite, ttype, _path) {\n        if (_path === void 0) { _path = 'value'; }\n        this.suite = suite;\n        this.ttype = ttype;\n        this._path = _path;\n        this.props = new Map();\n        if (ttype instanceof types_1.TIface) {\n            for (var _i = 0, _a = ttype.props; _i < _a.length; _i++) {\n                var p = _a[_i];\n                this.props.set(p.name, p.ttype);\n            }\n        }\n        this.checkerPlain = this.ttype.getChecker(suite, false);\n        this.checkerStrict = this.ttype.getChecker(suite, true);\n    }\n    /**\n     * Set the path to report in errors, instead of the default \"value\". (E.g. if the Checker is for\n     * a \"person\" interface, set path to \"person\" to report e.g. \"person.name is not a string\".)\n     */\n    Checker.prototype.setReportedPath = function (path) {\n        this._path = path;\n    };\n    /**\n     * Check that the given value satisfies this checker's type, or throw Error.\n     */\n    Checker.prototype.check = function (value) { return this._doCheck(this.checkerPlain, value); };\n    /**\n     * A fast check for whether or not the given value satisfies this Checker's type. This returns\n     * true or false, does not produce an error message, and is fast both on success and on failure.\n     */\n    Checker.prototype.test = function (value) {\n        return this.checkerPlain(value, new util_1.NoopContext());\n    };\n    /**\n     * Returns an error object describing the errors if the given value does not satisfy this\n     * Checker's type, or null if it does.\n     */\n    Checker.prototype.validate = function (value) {\n        return this._doValidate(this.checkerPlain, value);\n    };\n    /**\n     * Check that the given value satisfies this checker's type strictly. This checks that objects\n     * and tuples have no extra members. Note that this prevents backward compatibility, so usually\n     * a plain check() is more appropriate.\n     */\n    Checker.prototype.strictCheck = function (value) { return this._doCheck(this.checkerStrict, value); };\n    /**\n     * A fast strict check for whether or not the given value satisfies this Checker's type. Returns\n     * true or false, does not produce an error message, and is fast both on success and on failure.\n     */\n    Checker.prototype.strictTest = function (value) {\n        return this.checkerStrict(value, new util_1.NoopContext());\n    };\n    /**\n     * Returns an error object describing the errors if the given value does not satisfy this\n     * Checker's type strictly, or null if it does.\n     */\n    Checker.prototype.strictValidate = function (value) {\n        return this._doValidate(this.checkerStrict, value);\n    };\n    /**\n     * If this checker is for an interface, returns a Checker for the type required for the given\n     * property of this interface.\n     */\n    Checker.prototype.getProp = function (prop) {\n        var ttype = this.props.get(prop);\n        if (!ttype) {\n            throw new Error(\"Type has no property \" + prop);\n        }\n        return new Checker(this.suite, ttype, this._path + \".\" + prop);\n    };\n    /**\n     * If this checker is for an interface, returns a Checker for the argument-list required to call\n     * the given method of this interface. E.g. if this Checker is for the interface:\n     *    interface Foo {\n     *      find(s: string, pos?: number): number;\n     *    }\n     * Then methodArgs(\"find\").check(...) will succeed for [\"foo\"] and [\"foo\", 3], but not for [17].\n     */\n    Checker.prototype.methodArgs = function (methodName) {\n        var tfunc = this._getMethod(methodName);\n        return new Checker(this.suite, tfunc.paramList);\n    };\n    /**\n     * If this checker is for an interface, returns a Checker for the return value of the given\n     * method of this interface.\n     */\n    Checker.prototype.methodResult = function (methodName) {\n        var tfunc = this._getMethod(methodName);\n        return new Checker(this.suite, tfunc.result);\n    };\n    /**\n     * If this checker is for a function, returns a Checker for its argument-list.\n     */\n    Checker.prototype.getArgs = function () {\n        if (!(this.ttype instanceof types_1.TFunc)) {\n            throw new Error(\"getArgs() applied to non-function\");\n        }\n        return new Checker(this.suite, this.ttype.paramList);\n    };\n    /**\n     * If this checker is for a function, returns a Checker for its result.\n     */\n    Checker.prototype.getResult = function () {\n        if (!(this.ttype instanceof types_1.TFunc)) {\n            throw new Error(\"getResult() applied to non-function\");\n        }\n        return new Checker(this.suite, this.ttype.result);\n    };\n    /**\n     * Return the type for which this is a checker.\n     */\n    Checker.prototype.getType = function () {\n        return this.ttype;\n    };\n    /**\n     * Actual implementation of check() and strictCheck().\n     */\n    Checker.prototype._doCheck = function (checkerFunc, value) {\n        var noopCtx = new util_1.NoopContext();\n        if (!checkerFunc(value, noopCtx)) {\n            var detailCtx = new util_1.DetailContext();\n            checkerFunc(value, detailCtx);\n            throw detailCtx.getError(this._path);\n        }\n    };\n    Checker.prototype._doValidate = function (checkerFunc, value) {\n        var noopCtx = new util_1.NoopContext();\n        if (checkerFunc(value, noopCtx)) {\n            return null;\n        }\n        var detailCtx = new util_1.DetailContext();\n        checkerFunc(value, detailCtx);\n        return detailCtx.getErrorDetail(this._path);\n    };\n    Checker.prototype._getMethod = function (methodName) {\n        var ttype = this.props.get(methodName);\n        if (!ttype) {\n            throw new Error(\"Type has no property \" + methodName);\n        }\n        if (!(ttype instanceof types_1.TFunc)) {\n            throw new Error(\"Property \" + methodName + \" is not a method\");\n        }\n        return ttype;\n    };\n    return Checker;\n}());\nexports.Checker = Checker;\n", "// Note: this is the semver.org version of the spec that it implements\n// Not necessarily the package version of this code.\nconst SEMVER_SPEC_VERSION = '2.0.0'\n\nconst MAX_LENGTH = 256\nconst MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER ||\n  /* istanbul ignore next */ 9007199254740991\n\n// Max safe segment length for coercion.\nconst MAX_SAFE_COMPONENT_LENGTH = 16\n\nmodule.exports = {\n  SEMVER_SPEC_VERSION,\n  MAX_LENGTH,\n  MAX_SAFE_INTEGER,\n  MAX_SAFE_COMPONENT_LENGTH\n}\n", "const debug = (\n  typeof process === 'object' &&\n  process.env &&\n  process.env.NODE_DEBUG &&\n  /\\bsemver\\b/i.test(process.env.NODE_DEBUG)\n) ? (...args) => console.error('SEMVER', ...args)\n  : () => {}\n\nmodule.exports = debug\n", "const { MAX_SAFE_COMPONENT_LENGTH } = require('./constants')\nconst debug = require('./debug')\nexports = module.exports = {}\n\n// The actual regexps go on exports.re\nconst re = exports.re = []\nconst src = exports.src = []\nconst t = exports.t = {}\nlet R = 0\n\nconst createToken = (name, value, isGlobal) => {\n  const index = R++\n  debug(index, value)\n  t[name] = index\n  src[index] = value\n  re[index] = new RegExp(value, isGlobal ? 'g' : undefined)\n}\n\n// The following Regular Expressions can be used for tokenizing,\n// validating, and parsing SemVer version strings.\n\n// ## Numeric Identifier\n// A single `0`, or a non-zero digit followed by zero or more digits.\n\ncreateToken('NUMERICIDENTIFIER', '0|[1-9]\\\\d*')\ncreateToken('NUMERICIDENTIFIERLOOSE', '[0-9]+')\n\n// ## Non-numeric Identifier\n// Zero or more digits, followed by a letter or hyphen, and then zero or\n// more letters, digits, or hyphens.\n\ncreateToken('NONNUMERICIDENTIFIER', '\\\\d*[a-zA-Z-][a-zA-Z0-9-]*')\n\n// ## Main Version\n// Three dot-separated numeric identifiers.\n\ncreateToken('MAINVERSION', `(${src[t.NUMERICIDENTIFIER]})\\\\.` +\n                   `(${src[t.NUMERICIDENTIFIER]})\\\\.` +\n                   `(${src[t.NUMERICIDENTIFIER]})`)\n\ncreateToken('MAINVERSIONLOOSE', `(${src[t.NUMERICIDENTIFIERLOOSE]})\\\\.` +\n                        `(${src[t.NUMERICIDENTIFIERLOOSE]})\\\\.` +\n                        `(${src[t.NUMERICIDENTIFIERLOOSE]})`)\n\n// ## Pre-release Version Identifier\n// A numeric identifier, or a non-numeric identifier.\n\ncreateToken('PRERELEASEIDENTIFIER', `(?:${src[t.NUMERICIDENTIFIER]\n}|${src[t.NONNUMERICIDENTIFIER]})`)\n\ncreateToken('PRERELEASEIDENTIFIERLOOSE', `(?:${src[t.NUMERICIDENTIFIERLOOSE]\n}|${src[t.NONNUMERICIDENTIFIER]})`)\n\n// ## Pre-release Version\n// Hyphen, followed by one or more dot-separated pre-release version\n// identifiers.\n\ncreateToken('PRERELEASE', `(?:-(${src[t.PRERELEASEIDENTIFIER]\n}(?:\\\\.${src[t.PRERELEASEIDENTIFIER]})*))`)\n\ncreateToken('PRERELEASELOOSE', `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]\n}(?:\\\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`)\n\n// ## Build Metadata Identifier\n// Any combination of digits, letters, or hyphens.\n\ncreateToken('BUILDIDENTIFIER', '[0-9A-Za-z-]+')\n\n// ## Build Metadata\n// Plus sign, followed by one or more period-separated build metadata\n// identifiers.\n\ncreateToken('BUILD', `(?:\\\\+(${src[t.BUILDIDENTIFIER]\n}(?:\\\\.${src[t.BUILDIDENTIFIER]})*))`)\n\n// ## Full Version String\n// A main version, followed optionally by a pre-release version and\n// build metadata.\n\n// Note that the only major, minor, patch, and pre-release sections of\n// the version string are capturing groups.  The build metadata is not a\n// capturing group, because it should not ever be used in version\n// comparison.\n\ncreateToken('FULLPLAIN', `v?${src[t.MAINVERSION]\n}${src[t.PRERELEASE]}?${\n  src[t.BUILD]}?`)\n\ncreateToken('FULL', `^${src[t.FULLPLAIN]}$`)\n\n// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.\n// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty\n// common in the npm registry.\ncreateToken('LOOSEPLAIN', `[v=\\\\s]*${src[t.MAINVERSIONLOOSE]\n}${src[t.PRERELEASELOOSE]}?${\n  src[t.BUILD]}?`)\n\ncreateToken('LOOSE', `^${src[t.LOOSEPLAIN]}$`)\n\ncreateToken('GTLT', '((?:<|>)?=?)')\n\n// Something like \"2.*\" or \"1.2.x\".\n// Note that \"x.x\" is a valid xRange identifer, meaning \"any version\"\n// Only the first item is strictly required.\ncreateToken('XRANGEIDENTIFIERLOOSE', `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\\\*`)\ncreateToken('XRANGEIDENTIFIER', `${src[t.NUMERICIDENTIFIER]}|x|X|\\\\*`)\n\ncreateToken('XRANGEPLAIN', `[v=\\\\s]*(${src[t.XRANGEIDENTIFIER]})` +\n                   `(?:\\\\.(${src[t.XRANGEIDENTIFIER]})` +\n                   `(?:\\\\.(${src[t.XRANGEIDENTIFIER]})` +\n                   `(?:${src[t.PRERELEASE]})?${\n                     src[t.BUILD]}?` +\n                   `)?)?`)\n\ncreateToken('XRANGEPLAINLOOSE', `[v=\\\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})` +\n                        `(?:\\\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +\n                        `(?:\\\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +\n                        `(?:${src[t.PRERELEASELOOSE]})?${\n                          src[t.BUILD]}?` +\n                        `)?)?`)\n\ncreateToken('XRANGE', `^${src[t.GTLT]}\\\\s*${src[t.XRANGEPLAIN]}$`)\ncreateToken('XRANGELOOSE', `^${src[t.GTLT]}\\\\s*${src[t.XRANGEPLAINLOOSE]}$`)\n\n// Coercion.\n// Extract anything that could conceivably be a part of a valid semver\ncreateToken('COERCE', `${'(^|[^\\\\d])' +\n              '(\\\\d{1,'}${MAX_SAFE_COMPONENT_LENGTH}})` +\n              `(?:\\\\.(\\\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` +\n              `(?:\\\\.(\\\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` +\n              `(?:$|[^\\\\d])`)\ncreateToken('COERCERTL', src[t.COERCE], true)\n\n// Tilde ranges.\n// Meaning is \"reasonably at or greater than\"\ncreateToken('LONETILDE', '(?:~>?)')\n\ncreateToken('TILDETRIM', `(\\\\s*)${src[t.LONETILDE]}\\\\s+`, true)\nexports.tildeTrimReplace = '$1~'\n\ncreateToken('TILDE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`)\ncreateToken('TILDELOOSE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`)\n\n// Caret ranges.\n// Meaning is \"at least and backwards compatible with\"\ncreateToken('LONECARET', '(?:\\\\^)')\n\ncreateToken('CARETTRIM', `(\\\\s*)${src[t.LONECARET]}\\\\s+`, true)\nexports.caretTrimReplace = '$1^'\n\ncreateToken('CARET', `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`)\ncreateToken('CARETLOOSE', `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`)\n\n// A simple gt/lt/eq thing, or just \"\" to indicate \"any version\"\ncreateToken('COMPARATORLOOSE', `^${src[t.GTLT]}\\\\s*(${src[t.LOOSEPLAIN]})$|^$`)\ncreateToken('COMPARATOR', `^${src[t.GTLT]}\\\\s*(${src[t.FULLPLAIN]})$|^$`)\n\n// An expression to strip any whitespace between the gtlt and the thing\n// it modifies, so that `> 1.2.3` ==> `>1.2.3`\ncreateToken('COMPARATORTRIM', `(\\\\s*)${src[t.GTLT]\n}\\\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true)\nexports.comparatorTrimReplace = '$1$2$3'\n\n// Something like `1.2.3 - 1.2.4`\n// Note that these all use the loose form, because they'll be\n// checked against either the strict or loose comparator form\n// later.\ncreateToken('HYPHENRANGE', `^\\\\s*(${src[t.XRANGEPLAIN]})` +\n                   `\\\\s+-\\\\s+` +\n                   `(${src[t.XRANGEPLAIN]})` +\n                   `\\\\s*$`)\n\ncreateToken('HYPHENRANGELOOSE', `^\\\\s*(${src[t.XRANGEPLAINLOOSE]})` +\n                        `\\\\s+-\\\\s+` +\n                        `(${src[t.XRANGEPLAINLOOSE]})` +\n                        `\\\\s*$`)\n\n// Star ranges basically just allow anything at all.\ncreateToken('STAR', '(<|>)?=?\\\\s*\\\\*')\n// >=0.0.0 is like a star\ncreateToken('GTE0', '^\\\\s*>=\\\\s*0\\.0\\.0\\\\s*$')\ncreateToken('GTE0PRE', '^\\\\s*>=\\\\s*0\\.0\\.0-0\\\\s*$')\n", "const numeric = /^[0-9]+$/\nconst compareIdentifiers = (a, b) => {\n  const anum = numeric.test(a)\n  const bnum = numeric.test(b)\n\n  if (anum && bnum) {\n    a = +a\n    b = +b\n  }\n\n  return a === b ? 0\n    : (anum && !bnum) ? -1\n    : (bnum && !anum) ? 1\n    : a < b ? -1\n    : 1\n}\n\nconst rcompareIdentifiers = (a, b) => compareIdentifiers(b, a)\n\nmodule.exports = {\n  compareIdentifiers,\n  rcompareIdentifiers\n}\n", "const debug = require('../internal/debug')\nconst { MAX_LENGTH, MAX_SAFE_INTEGER } = require('../internal/constants')\nconst { re, t } = require('../internal/re')\n\nconst { compareIdentifiers } = require('../internal/identifiers')\nclass SemVer {\n  constructor (version, options) {\n    if (!options || typeof options !== 'object') {\n      options = {\n        loose: !!options,\n        includePrerelease: false\n      }\n    }\n    if (version instanceof SemVer) {\n      if (version.loose === !!options.loose &&\n          version.includePrerelease === !!options.includePrerelease) {\n        return version\n      } else {\n        version = version.version\n      }\n    } else if (typeof version !== 'string') {\n      throw new TypeError(`Invalid Version: ${version}`)\n    }\n\n    if (version.length > MAX_LENGTH) {\n      throw new TypeError(\n        `version is longer than ${MAX_LENGTH} characters`\n      )\n    }\n\n    debug('SemVer', version, options)\n    this.options = options\n    this.loose = !!options.loose\n    // this isn't actually relevant for versions, but keep it so that we\n    // don't run into trouble passing this.options around.\n    this.includePrerelease = !!options.includePrerelease\n\n    const m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL])\n\n    if (!m) {\n      throw new TypeError(`Invalid Version: ${version}`)\n    }\n\n    this.raw = version\n\n    // these are actually numbers\n    this.major = +m[1]\n    this.minor = +m[2]\n    this.patch = +m[3]\n\n    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {\n      throw new TypeError('Invalid major version')\n    }\n\n    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {\n      throw new TypeError('Invalid minor version')\n    }\n\n    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {\n      throw new TypeError('Invalid patch version')\n    }\n\n    // numberify any prerelease numeric ids\n    if (!m[4]) {\n      this.prerelease = []\n    } else {\n      this.prerelease = m[4].split('.').map((id) => {\n        if (/^[0-9]+$/.test(id)) {\n          const num = +id\n          if (num >= 0 && num < MAX_SAFE_INTEGER) {\n            return num\n          }\n        }\n        return id\n      })\n    }\n\n    this.build = m[5] ? m[5].split('.') : []\n    this.format()\n  }\n\n  format () {\n    this.version = `${this.major}.${this.minor}.${this.patch}`\n    if (this.prerelease.length) {\n      this.version += `-${this.prerelease.join('.')}`\n    }\n    return this.version\n  }\n\n  toString () {\n    return this.version\n  }\n\n  compare (other) {\n    debug('SemVer.compare', this.version, this.options, other)\n    if (!(other instanceof SemVer)) {\n      if (typeof other === 'string' && other === this.version) {\n        return 0\n      }\n      other = new SemVer(other, this.options)\n    }\n\n    if (other.version === this.version) {\n      return 0\n    }\n\n    return this.compareMain(other) || this.comparePre(other)\n  }\n\n  compareMain (other) {\n    if (!(other instanceof SemVer)) {\n      other = new SemVer(other, this.options)\n    }\n\n    return (\n      compareIdentifiers(this.major, other.major) ||\n      compareIdentifiers(this.minor, other.minor) ||\n      compareIdentifiers(this.patch, other.patch)\n    )\n  }\n\n  comparePre (other) {\n    if (!(other instanceof SemVer)) {\n      other = new SemVer(other, this.options)\n    }\n\n    // NOT having a prerelease is > having one\n    if (this.prerelease.length && !other.prerelease.length) {\n      return -1\n    } else if (!this.prerelease.length && other.prerelease.length) {\n      return 1\n    } else if (!this.prerelease.length && !other.prerelease.length) {\n      return 0\n    }\n\n    let i = 0\n    do {\n      const a = this.prerelease[i]\n      const b = other.prerelease[i]\n      debug('prerelease compare', i, a, b)\n      if (a === undefined && b === undefined) {\n        return 0\n      } else if (b === undefined) {\n        return 1\n      } else if (a === undefined) {\n        return -1\n      } else if (a === b) {\n        continue\n      } else {\n        return compareIdentifiers(a, b)\n      }\n    } while (++i)\n  }\n\n  compareBuild (other) {\n    if (!(other instanceof SemVer)) {\n      other = new SemVer(other, this.options)\n    }\n\n    let i = 0\n    do {\n      const a = this.build[i]\n      const b = other.build[i]\n      debug('prerelease compare', i, a, b)\n      if (a === undefined && b === undefined) {\n        return 0\n      } else if (b === undefined) {\n        return 1\n      } else if (a === undefined) {\n        return -1\n      } else if (a === b) {\n        continue\n      } else {\n        return compareIdentifiers(a, b)\n      }\n    } while (++i)\n  }\n\n  // preminor will bump the version up to the next minor release, and immediately\n  // down to pre-release. premajor and prepatch work the same way.\n  inc (release, identifier) {\n    switch (release) {\n      case 'premajor':\n        this.prerelease.length = 0\n        this.patch = 0\n        this.minor = 0\n        this.major++\n        this.inc('pre', identifier)\n        break\n      case 'preminor':\n        this.prerelease.length = 0\n        this.patch = 0\n        this.minor++\n        this.inc('pre', identifier)\n        break\n      case 'prepatch':\n        // If this is already a prerelease, it will bump to the next version\n        // drop any prereleases that might already exist, since they are not\n        // relevant at this point.\n        this.prerelease.length = 0\n        this.inc('patch', identifier)\n        this.inc('pre', identifier)\n        break\n      // If the input is a non-prerelease version, this acts the same as\n      // prepatch.\n      case 'prerelease':\n        if (this.prerelease.length === 0) {\n          this.inc('patch', identifier)\n        }\n        this.inc('pre', identifier)\n        break\n\n      case 'major':\n        // If this is a pre-major version, bump up to the same major version.\n        // Otherwise increment major.\n        // 1.0.0-5 bumps to 1.0.0\n        // 1.1.0 bumps to 2.0.0\n        if (\n          this.minor !== 0 ||\n          this.patch !== 0 ||\n          this.prerelease.length === 0\n        ) {\n          this.major++\n        }\n        this.minor = 0\n        this.patch = 0\n        this.prerelease = []\n        break\n      case 'minor':\n        // If this is a pre-minor version, bump up to the same minor version.\n        // Otherwise increment minor.\n        // 1.2.0-5 bumps to 1.2.0\n        // 1.2.1 bumps to 1.3.0\n        if (this.patch !== 0 || this.prerelease.length === 0) {\n          this.minor++\n        }\n        this.patch = 0\n        this.prerelease = []\n        break\n      case 'patch':\n        // If this is not a pre-release version, it will increment the patch.\n        // If it is a pre-release it will bump up to the same patch version.\n        // 1.2.0-5 patches to 1.2.0\n        // 1.2.0 patches to 1.2.1\n        if (this.prerelease.length === 0) {\n          this.patch++\n        }\n        this.prerelease = []\n        break\n      // This probably shouldn't be used publicly.\n      // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.\n      case 'pre':\n        if (this.prerelease.length === 0) {\n          this.prerelease = [0]\n        } else {\n          let i = this.prerelease.length\n          while (--i >= 0) {\n            if (typeof this.prerelease[i] === 'number') {\n              this.prerelease[i]++\n              i = -2\n            }\n          }\n          if (i === -1) {\n            // didn't increment anything\n            this.prerelease.push(0)\n          }\n        }\n        if (identifier) {\n          // 1.2.0-beta.1 bumps to 1.2.0-beta.2,\n          // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0\n          if (this.prerelease[0] === identifier) {\n            if (isNaN(this.prerelease[1])) {\n              this.prerelease = [identifier, 0]\n            }\n          } else {\n            this.prerelease = [identifier, 0]\n          }\n        }\n        break\n\n      default:\n        throw new Error(`invalid increment argument: ${release}`)\n    }\n    this.format()\n    this.raw = this.version\n    return this\n  }\n}\n\nmodule.exports = SemVer\n", "const {MAX_LENGTH} = require('../internal/constants')\nconst { re, t } = require('../internal/re')\nconst SemVer = require('../classes/semver')\n\nconst parse = (version, options) => {\n  if (!options || typeof options !== 'object') {\n    options = {\n      loose: !!options,\n      includePrerelease: false\n    }\n  }\n\n  if (version instanceof SemVer) {\n    return version\n  }\n\n  if (typeof version !== 'string') {\n    return null\n  }\n\n  if (version.length > MAX_LENGTH) {\n    return null\n  }\n\n  const r = options.loose ? re[t.LOOSE] : re[t.FULL]\n  if (!r.test(version)) {\n    return null\n  }\n\n  try {\n    return new SemVer(version, options)\n  } catch (er) {\n    return null\n  }\n}\n\nmodule.exports = parse\n", "const parse = require('./parse')\nconst valid = (version, options) => {\n  const v = parse(version, options)\n  return v ? v.version : null\n}\nmodule.exports = valid\n", "const parse = require('./parse')\nconst clean = (version, options) => {\n  const s = parse(version.trim().replace(/^[=v]+/, ''), options)\n  return s ? s.version : null\n}\nmodule.exports = clean\n", "const SemVer = require('../classes/semver')\n\nconst inc = (version, release, options, identifier) => {\n  if (typeof (options) === 'string') {\n    identifier = options\n    options = undefined\n  }\n\n  try {\n    return new SemVer(version, options).inc(release, identifier).version\n  } catch (er) {\n    return null\n  }\n}\nmodule.exports = inc\n", "const SemVer = require('../classes/semver')\nconst compare = (a, b, loose) =>\n  new SemVer(a, loose).compare(new SemVer(b, loose))\n\nmodule.exports = compare\n", "const compare = require('./compare')\nconst eq = (a, b, loose) => compare(a, b, loose) === 0\nmodule.exports = eq\n", "const parse = require('./parse')\nconst eq = require('./eq')\n\nconst diff = (version1, version2) => {\n  if (eq(version1, version2)) {\n    return null\n  } else {\n    const v1 = parse(version1)\n    const v2 = parse(version2)\n    const hasPre = v1.prerelease.length || v2.prerelease.length\n    const prefix = hasPre ? 'pre' : ''\n    const defaultResult = hasPre ? 'prerelease' : ''\n    for (const key in v1) {\n      if (key === 'major' || key === 'minor' || key === 'patch') {\n        if (v1[key] !== v2[key]) {\n          return prefix + key\n        }\n      }\n    }\n    return defaultResult // may be undefined\n  }\n}\nmodule.exports = diff\n", "const SemVer = require('../classes/semver')\nconst major = (a, loose) => new SemVer(a, loose).major\nmodule.exports = major\n", "const SemVer = require('../classes/semver')\nconst minor = (a, loose) => new SemVer(a, loose).minor\nmodule.exports = minor\n", "const SemVer = require('../classes/semver')\nconst patch = (a, loose) => new SemVer(a, loose).patch\nmodule.exports = patch\n", "const parse = require('./parse')\nconst prerelease = (version, options) => {\n  const parsed = parse(version, options)\n  return (parsed && parsed.prerelease.length) ? parsed.prerelease : null\n}\nmodule.exports = prerelease\n", "const compare = require('./compare')\nconst rcompare = (a, b, loose) => compare(b, a, loose)\nmodule.exports = rcompare\n", "const compare = require('./compare')\nconst compareLoose = (a, b) => compare(a, b, true)\nmodule.exports = compareLoose\n", "const SemVer = require('../classes/semver')\nconst compareBuild = (a, b, loose) => {\n  const versionA = new SemVer(a, loose)\n  const versionB = new SemVer(b, loose)\n  return versionA.compare(versionB) || versionA.compareBuild(versionB)\n}\nmodule.exports = compareBuild\n", "const compareBuild = require('./compare-build')\nconst sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose))\nmodule.exports = sort\n", "const compareBuild = require('./compare-build')\nconst rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose))\nmodule.exports = rsort\n", "const compare = require('./compare')\nconst gt = (a, b, loose) => compare(a, b, loose) > 0\nmodule.exports = gt\n", "const compare = require('./compare')\nconst lt = (a, b, loose) => compare(a, b, loose) < 0\nmodule.exports = lt\n", "const compare = require('./compare')\nconst neq = (a, b, loose) => compare(a, b, loose) !== 0\nmodule.exports = neq\n", "const compare = require('./compare')\nconst gte = (a, b, loose) => compare(a, b, loose) >= 0\nmodule.exports = gte\n", "const compare = require('./compare')\nconst lte = (a, b, loose) => compare(a, b, loose) <= 0\nmodule.exports = lte\n", "const eq = require('./eq')\nconst neq = require('./neq')\nconst gt = require('./gt')\nconst gte = require('./gte')\nconst lt = require('./lt')\nconst lte = require('./lte')\n\nconst cmp = (a, op, b, loose) => {\n  switch (op) {\n    case '===':\n      if (typeof a === 'object')\n        a = a.version\n      if (typeof b === 'object')\n        b = b.version\n      return a === b\n\n    case '!==':\n      if (typeof a === 'object')\n        a = a.version\n      if (typeof b === 'object')\n        b = b.version\n      return a !== b\n\n    case '':\n    case '=':\n    case '==':\n      return eq(a, b, loose)\n\n    case '!=':\n      return neq(a, b, loose)\n\n    case '>':\n      return gt(a, b, loose)\n\n    case '>=':\n      return gte(a, b, loose)\n\n    case '<':\n      return lt(a, b, loose)\n\n    case '<=':\n      return lte(a, b, loose)\n\n    default:\n      throw new TypeError(`Invalid operator: ${op}`)\n  }\n}\nmodule.exports = cmp\n", "const SemVer = require('../classes/semver')\nconst parse = require('./parse')\nconst {re, t} = require('../internal/re')\n\nconst coerce = (version, options) => {\n  if (version instanceof SemVer) {\n    return version\n  }\n\n  if (typeof version === 'number') {\n    version = String(version)\n  }\n\n  if (typeof version !== 'string') {\n    return null\n  }\n\n  options = options || {}\n\n  let match = null\n  if (!options.rtl) {\n    match = version.match(re[t.COERCE])\n  } else {\n    // Find the right-most coercible string that does not share\n    // a terminus with a more left-ward coercible string.\n    // Eg, '1.2.3.4' wants to coerce '2.3.4', not '3.4' or '4'\n    //\n    // Walk through the string checking with a /g regexp\n    // Manually set the index so as to pick up overlapping matches.\n    // Stop when we get a match that ends at the string end, since no\n    // coercible string can be more right-ward without the same terminus.\n    let next\n    while ((next = re[t.COERCERTL].exec(version)) &&\n        (!match || match.index + match[0].length !== version.length)\n    ) {\n      if (!match ||\n            next.index + next[0].length !== match.index + match[0].length) {\n        match = next\n      }\n      re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length\n    }\n    // leave it in a clean state\n    re[t.COERCERTL].lastIndex = -1\n  }\n\n  if (match === null)\n    return null\n\n  return parse(`${match[2]}.${match[3] || '0'}.${match[4] || '0'}`, options)\n}\nmodule.exports = coerce\n", "// hoisted class for cyclic dependency\nclass Range {\n  constructor (range, options) {\n    if (!options || typeof options !== 'object') {\n      options = {\n        loose: !!options,\n        includePrerelease: false\n      }\n    }\n\n    if (range instanceof Range) {\n      if (\n        range.loose === !!options.loose &&\n        range.includePrerelease === !!options.includePrerelease\n      ) {\n        return range\n      } else {\n        return new Range(range.raw, options)\n      }\n    }\n\n    if (range instanceof Comparator) {\n      // just put it in the set and return\n      this.raw = range.value\n      this.set = [[range]]\n      this.format()\n      return this\n    }\n\n    this.options = options\n    this.loose = !!options.loose\n    this.includePrerelease = !!options.includePrerelease\n\n    // First, split based on boolean or ||\n    this.raw = range\n    this.set = range\n      .split(/\\s*\\|\\|\\s*/)\n      // map the range to a 2d array of comparators\n      .map(range => this.parseRange(range.trim()))\n      // throw out any comparator lists that are empty\n      // this generally means that it was not a valid range, which is allowed\n      // in loose mode, but will still throw if the WHOLE range is invalid.\n      .filter(c => c.length)\n\n    if (!this.set.length) {\n      throw new TypeError(`Invalid SemVer Range: ${range}`)\n    }\n\n    this.format()\n  }\n\n  format () {\n    this.range = this.set\n      .map((comps) => {\n        return comps.join(' ').trim()\n      })\n      .join('||')\n      .trim()\n    return this.range\n  }\n\n  toString () {\n    return this.range\n  }\n\n  parseRange (range) {\n    const loose = this.options.loose\n    range = range.trim()\n    // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`\n    const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE]\n    range = range.replace(hr, hyphenReplace(this.options.includePrerelease))\n    debug('hyphen replace', range)\n    // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`\n    range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace)\n    debug('comparator trim', range, re[t.COMPARATORTRIM])\n\n    // `~ 1.2.3` => `~1.2.3`\n    range = range.replace(re[t.TILDETRIM], tildeTrimReplace)\n\n    // `^ 1.2.3` => `^1.2.3`\n    range = range.replace(re[t.CARETTRIM], caretTrimReplace)\n\n    // normalize spaces\n    range = range.split(/\\s+/).join(' ')\n\n    // At this point, the range is completely trimmed and\n    // ready to be split into comparators.\n\n    const compRe = loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR]\n    return range\n      .split(' ')\n      .map(comp => parseComparator(comp, this.options))\n      .join(' ')\n      .split(/\\s+/)\n      .map(comp => replaceGTE0(comp, this.options))\n      // in loose mode, throw out any that are not valid comparators\n      .filter(this.options.loose ? comp => !!comp.match(compRe) : () => true)\n      .map(comp => new Comparator(comp, this.options))\n  }\n\n  intersects (range, options) {\n    if (!(range instanceof Range)) {\n      throw new TypeError('a Range is required')\n    }\n\n    return this.set.some((thisComparators) => {\n      return (\n        isSatisfiable(thisComparators, options) &&\n        range.set.some((rangeComparators) => {\n          return (\n            isSatisfiable(rangeComparators, options) &&\n            thisComparators.every((thisComparator) => {\n              return rangeComparators.every((rangeComparator) => {\n                return thisComparator.intersects(rangeComparator, options)\n              })\n            })\n          )\n        })\n      )\n    })\n  }\n\n  // if ANY of the sets match ALL of its comparators, then pass\n  test (version) {\n    if (!version) {\n      return false\n    }\n\n    if (typeof version === 'string') {\n      try {\n        version = new SemVer(version, this.options)\n      } catch (er) {\n        return false\n      }\n    }\n\n    for (let i = 0; i < this.set.length; i++) {\n      if (testSet(this.set[i], version, this.options)) {\n        return true\n      }\n    }\n    return false\n  }\n}\nmodule.exports = Range\n\nconst Comparator = require('./comparator')\nconst debug = require('../internal/debug')\nconst SemVer = require('./semver')\nconst {\n  re,\n  t,\n  comparatorTrimReplace,\n  tildeTrimReplace,\n  caretTrimReplace\n} = require('../internal/re')\n\n// take a set of comparators and determine whether there\n// exists a version which can satisfy it\nconst isSatisfiable = (comparators, options) => {\n  let result = true\n  const remainingComparators = comparators.slice()\n  let testComparator = remainingComparators.pop()\n\n  while (result && remainingComparators.length) {\n    result = remainingComparators.every((otherComparator) => {\n      return testComparator.intersects(otherComparator, options)\n    })\n\n    testComparator = remainingComparators.pop()\n  }\n\n  return result\n}\n\n// comprised of xranges, tildes, stars, and gtlt's at this point.\n// already replaced the hyphen ranges\n// turn into a set of JUST comparators.\nconst parseComparator = (comp, options) => {\n  debug('comp', comp, options)\n  comp = replaceCarets(comp, options)\n  debug('caret', comp)\n  comp = replaceTildes(comp, options)\n  debug('tildes', comp)\n  comp = replaceXRanges(comp, options)\n  debug('xrange', comp)\n  comp = replaceStars(comp, options)\n  debug('stars', comp)\n  return comp\n}\n\nconst isX = id => !id || id.toLowerCase() === 'x' || id === '*'\n\n// ~, ~> --> * (any, kinda silly)\n// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0-0\n// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0-0\n// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0-0\n// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0-0\n// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0-0\nconst replaceTildes = (comp, options) =>\n  comp.trim().split(/\\s+/).map((comp) => {\n    return replaceTilde(comp, options)\n  }).join(' ')\n\nconst replaceTilde = (comp, options) => {\n  const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE]\n  return comp.replace(r, (_, M, m, p, pr) => {\n    debug('tilde', comp, _, M, m, p, pr)\n    let ret\n\n    if (isX(M)) {\n      ret = ''\n    } else if (isX(m)) {\n      ret = `>=${M}.0.0 <${+M + 1}.0.0-0`\n    } else if (isX(p)) {\n      // ~1.2 == >=1.2.0 <1.3.0-0\n      ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`\n    } else if (pr) {\n      debug('replaceTilde pr', pr)\n      ret = `>=${M}.${m}.${p}-${pr\n      } <${M}.${+m + 1}.0-0`\n    } else {\n      // ~1.2.3 == >=1.2.3 <1.3.0-0\n      ret = `>=${M}.${m}.${p\n      } <${M}.${+m + 1}.0-0`\n    }\n\n    debug('tilde return', ret)\n    return ret\n  })\n}\n\n// ^ --> * (any, kinda silly)\n// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0-0\n// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0-0\n// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0-0\n// ^1.2.3 --> >=1.2.3 <2.0.0-0\n// ^1.2.0 --> >=1.2.0 <2.0.0-0\nconst replaceCarets = (comp, options) =>\n  comp.trim().split(/\\s+/).map((comp) => {\n    return replaceCaret(comp, options)\n  }).join(' ')\n\nconst replaceCaret = (comp, options) => {\n  debug('caret', comp, options)\n  const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET]\n  const z = options.includePrerelease ? '-0' : ''\n  return comp.replace(r, (_, M, m, p, pr) => {\n    debug('caret', comp, _, M, m, p, pr)\n    let ret\n\n    if (isX(M)) {\n      ret = ''\n    } else if (isX(m)) {\n      ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`\n    } else if (isX(p)) {\n      if (M === '0') {\n        ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`\n      } else {\n        ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`\n      }\n    } else if (pr) {\n      debug('replaceCaret pr', pr)\n      if (M === '0') {\n        if (m === '0') {\n          ret = `>=${M}.${m}.${p}-${pr\n          } <${M}.${m}.${+p + 1}-0`\n        } else {\n          ret = `>=${M}.${m}.${p}-${pr\n          } <${M}.${+m + 1}.0-0`\n        }\n      } else {\n        ret = `>=${M}.${m}.${p}-${pr\n        } <${+M + 1}.0.0-0`\n      }\n    } else {\n      debug('no pr')\n      if (M === '0') {\n        if (m === '0') {\n          ret = `>=${M}.${m}.${p\n          }${z} <${M}.${m}.${+p + 1}-0`\n        } else {\n          ret = `>=${M}.${m}.${p\n          }${z} <${M}.${+m + 1}.0-0`\n        }\n      } else {\n        ret = `>=${M}.${m}.${p\n        } <${+M + 1}.0.0-0`\n      }\n    }\n\n    debug('caret return', ret)\n    return ret\n  })\n}\n\nconst replaceXRanges = (comp, options) => {\n  debug('replaceXRanges', comp, options)\n  return comp.split(/\\s+/).map((comp) => {\n    return replaceXRange(comp, options)\n  }).join(' ')\n}\n\nconst replaceXRange = (comp, options) => {\n  comp = comp.trim()\n  const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE]\n  return comp.replace(r, (ret, gtlt, M, m, p, pr) => {\n    debug('xRange', comp, ret, gtlt, M, m, p, pr)\n    const xM = isX(M)\n    const xm = xM || isX(m)\n    const xp = xm || isX(p)\n    const anyX = xp\n\n    if (gtlt === '=' && anyX) {\n      gtlt = ''\n    }\n\n    // if we're including prereleases in the match, then we need\n    // to fix this to -0, the lowest possible prerelease value\n    pr = options.includePrerelease ? '-0' : ''\n\n    if (xM) {\n      if (gtlt === '>' || gtlt === '<') {\n        // nothing is allowed\n        ret = '<0.0.0-0'\n      } else {\n        // nothing is forbidden\n        ret = '*'\n      }\n    } else if (gtlt && anyX) {\n      // we know patch is an x, because we have any x at all.\n      // replace X with 0\n      if (xm) {\n        m = 0\n      }\n      p = 0\n\n      if (gtlt === '>') {\n        // >1 => >=2.0.0\n        // >1.2 => >=1.3.0\n        gtlt = '>='\n        if (xm) {\n          M = +M + 1\n          m = 0\n          p = 0\n        } else {\n          m = +m + 1\n          p = 0\n        }\n      } else if (gtlt === '<=') {\n        // <=0.7.x is actually <0.8.0, since any 0.7.x should\n        // pass.  Similarly, <=7.x is actually <8.0.0, etc.\n        gtlt = '<'\n        if (xm) {\n          M = +M + 1\n        } else {\n          m = +m + 1\n        }\n      }\n\n      if (gtlt === '<')\n        pr = '-0'\n\n      ret = `${gtlt + M}.${m}.${p}${pr}`\n    } else if (xm) {\n      ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`\n    } else if (xp) {\n      ret = `>=${M}.${m}.0${pr\n      } <${M}.${+m + 1}.0-0`\n    }\n\n    debug('xRange return', ret)\n\n    return ret\n  })\n}\n\n// Because * is AND-ed with everything else in the comparator,\n// and '' means \"any version\", just remove the *s entirely.\nconst replaceStars = (comp, options) => {\n  debug('replaceStars', comp, options)\n  // Looseness is ignored here.  star is always as loose as it gets!\n  return comp.trim().replace(re[t.STAR], '')\n}\n\nconst replaceGTE0 = (comp, options) => {\n  debug('replaceGTE0', comp, options)\n  return comp.trim()\n    .replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], '')\n}\n\n// This function is passed to string.replace(re[t.HYPHENRANGE])\n// M, m, patch, prerelease, build\n// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5\n// 1.2.3 - 3.4 => >=1.2.0 <3.5.0-0 Any 3.4.x will do\n// 1.2 - 3.4 => >=1.2.0 <3.5.0-0\nconst hyphenReplace = incPr => ($0,\n  from, fM, fm, fp, fpr, fb,\n  to, tM, tm, tp, tpr, tb) => {\n  if (isX(fM)) {\n    from = ''\n  } else if (isX(fm)) {\n    from = `>=${fM}.0.0${incPr ? '-0' : ''}`\n  } else if (isX(fp)) {\n    from = `>=${fM}.${fm}.0${incPr ? '-0' : ''}`\n  } else if (fpr) {\n    from = `>=${from}`\n  } else {\n    from = `>=${from}${incPr ? '-0' : ''}`\n  }\n\n  if (isX(tM)) {\n    to = ''\n  } else if (isX(tm)) {\n    to = `<${+tM + 1}.0.0-0`\n  } else if (isX(tp)) {\n    to = `<${tM}.${+tm + 1}.0-0`\n  } else if (tpr) {\n    to = `<=${tM}.${tm}.${tp}-${tpr}`\n  } else if (incPr) {\n    to = `<${tM}.${tm}.${+tp + 1}-0`\n  } else {\n    to = `<=${to}`\n  }\n\n  return (`${from} ${to}`).trim()\n}\n\nconst testSet = (set, version, options) => {\n  for (let i = 0; i < set.length; i++) {\n    if (!set[i].test(version)) {\n      return false\n    }\n  }\n\n  if (version.prerelease.length && !options.includePrerelease) {\n    // Find the set of versions that are allowed to have prereleases\n    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0\n    // That should allow `1.2.3-pr.2` to pass.\n    // However, `1.2.4-alpha.notready` should NOT be allowed,\n    // even though it's within the range set by the comparators.\n    for (let i = 0; i < set.length; i++) {\n      debug(set[i].semver)\n      if (set[i].semver === Comparator.ANY) {\n        continue\n      }\n\n      if (set[i].semver.prerelease.length > 0) {\n        const allowed = set[i].semver\n        if (allowed.major === version.major &&\n            allowed.minor === version.minor &&\n            allowed.patch === version.patch) {\n          return true\n        }\n      }\n    }\n\n    // Version has a -pre, but it's not one of the ones we like.\n    return false\n  }\n\n  return true\n}\n", "const ANY = Symbol('SemVer ANY')\n// hoisted class for cyclic dependency\nclass Comparator {\n  static get ANY () {\n    return ANY\n  }\n  constructor (comp, options) {\n    if (!options || typeof options !== 'object') {\n      options = {\n        loose: !!options,\n        includePrerelease: false\n      }\n    }\n\n    if (comp instanceof Comparator) {\n      if (comp.loose === !!options.loose) {\n        return comp\n      } else {\n        comp = comp.value\n      }\n    }\n\n    debug('comparator', comp, options)\n    this.options = options\n    this.loose = !!options.loose\n    this.parse(comp)\n\n    if (this.semver === ANY) {\n      this.value = ''\n    } else {\n      this.value = this.operator + this.semver.version\n    }\n\n    debug('comp', this)\n  }\n\n  parse (comp) {\n    const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR]\n    const m = comp.match(r)\n\n    if (!m) {\n      throw new TypeError(`Invalid comparator: ${comp}`)\n    }\n\n    this.operator = m[1] !== undefined ? m[1] : ''\n    if (this.operator === '=') {\n      this.operator = ''\n    }\n\n    // if it literally is just '>' or '' then allow anything.\n    if (!m[2]) {\n      this.semver = ANY\n    } else {\n      this.semver = new SemVer(m[2], this.options.loose)\n    }\n  }\n\n  toString () {\n    return this.value\n  }\n\n  test (version) {\n    debug('Comparator.test', version, this.options.loose)\n\n    if (this.semver === ANY || version === ANY) {\n      return true\n    }\n\n    if (typeof version === 'string') {\n      try {\n        version = new SemVer(version, this.options)\n      } catch (er) {\n        return false\n      }\n    }\n\n    return cmp(version, this.operator, this.semver, this.options)\n  }\n\n  intersects (comp, options) {\n    if (!(comp instanceof Comparator)) {\n      throw new TypeError('a Comparator is required')\n    }\n\n    if (!options || typeof options !== 'object') {\n      options = {\n        loose: !!options,\n        includePrerelease: false\n      }\n    }\n\n    if (this.operator === '') {\n      if (this.value === '') {\n        return true\n      }\n      return new Range(comp.value, options).test(this.value)\n    } else if (comp.operator === '') {\n      if (comp.value === '') {\n        return true\n      }\n      return new Range(this.value, options).test(comp.semver)\n    }\n\n    const sameDirectionIncreasing =\n      (this.operator === '>=' || this.operator === '>') &&\n      (comp.operator === '>=' || comp.operator === '>')\n    const sameDirectionDecreasing =\n      (this.operator === '<=' || this.operator === '<') &&\n      (comp.operator === '<=' || comp.operator === '<')\n    const sameSemVer = this.semver.version === comp.semver.version\n    const differentDirectionsInclusive =\n      (this.operator === '>=' || this.operator === '<=') &&\n      (comp.operator === '>=' || comp.operator === '<=')\n    const oppositeDirectionsLessThan =\n      cmp(this.semver, '<', comp.semver, options) &&\n      (this.operator === '>=' || this.operator === '>') &&\n        (comp.operator === '<=' || comp.operator === '<')\n    const oppositeDirectionsGreaterThan =\n      cmp(this.semver, '>', comp.semver, options) &&\n      (this.operator === '<=' || this.operator === '<') &&\n        (comp.operator === '>=' || comp.operator === '>')\n\n    return (\n      sameDirectionIncreasing ||\n      sameDirectionDecreasing ||\n      (sameSemVer && differentDirectionsInclusive) ||\n      oppositeDirectionsLessThan ||\n      oppositeDirectionsGreaterThan\n    )\n  }\n}\n\nmodule.exports = Comparator\n\nconst {re, t} = require('../internal/re')\nconst cmp = require('../functions/cmp')\nconst debug = require('../internal/debug')\nconst SemVer = require('./semver')\nconst Range = require('./range')\n", "const Range = require('../classes/range')\nconst satisfies = (version, range, options) => {\n  try {\n    range = new Range(range, options)\n  } catch (er) {\n    return false\n  }\n  return range.test(version)\n}\nmodule.exports = satisfies\n", "const Range = require('../classes/range')\n\n// Mostly just for testing and legacy API reasons\nconst toComparators = (range, options) =>\n  new Range(range, options).set\n    .map(comp => comp.map(c => c.value).join(' ').trim().split(' '))\n\nmodule.exports = toComparators\n", "const SemVer = require('../classes/semver')\nconst Range = require('../classes/range')\n\nconst maxSatisfying = (versions, range, options) => {\n  let max = null\n  let maxSV = null\n  let rangeObj = null\n  try {\n    rangeObj = new Range(range, options)\n  } catch (er) {\n    return null\n  }\n  versions.forEach((v) => {\n    if (rangeObj.test(v)) {\n      // satisfies(v, range, options)\n      if (!max || maxSV.compare(v) === -1) {\n        // compare(max, v, true)\n        max = v\n        maxSV = new SemVer(max, options)\n      }\n    }\n  })\n  return max\n}\nmodule.exports = maxSatisfying\n", "const SemVer = require('../classes/semver')\nconst Range = require('../classes/range')\nconst minSatisfying = (versions, range, options) => {\n  let min = null\n  let minSV = null\n  let rangeObj = null\n  try {\n    rangeObj = new Range(range, options)\n  } catch (er) {\n    return null\n  }\n  versions.forEach((v) => {\n    if (rangeObj.test(v)) {\n      // satisfies(v, range, options)\n      if (!min || minSV.compare(v) === 1) {\n        // compare(min, v, true)\n        min = v\n        minSV = new SemVer(min, options)\n      }\n    }\n  })\n  return min\n}\nmodule.exports = minSatisfying\n", "const SemVer = require('../classes/semver')\nconst Range = require('../classes/range')\nconst gt = require('../functions/gt')\n\nconst minVersion = (range, loose) => {\n  range = new Range(range, loose)\n\n  let minver = new SemVer('0.0.0')\n  if (range.test(minver)) {\n    return minver\n  }\n\n  minver = new SemVer('0.0.0-0')\n  if (range.test(minver)) {\n    return minver\n  }\n\n  minver = null\n  for (let i = 0; i < range.set.length; ++i) {\n    const comparators = range.set[i]\n\n    comparators.forEach((comparator) => {\n      // Clone to avoid manipulating the comparator's semver object.\n      const compver = new SemVer(comparator.semver.version)\n      switch (comparator.operator) {\n        case '>':\n          if (compver.prerelease.length === 0) {\n            compver.patch++\n          } else {\n            compver.prerelease.push(0)\n          }\n          compver.raw = compver.format()\n          /* fallthrough */\n        case '':\n        case '>=':\n          if (!minver || gt(minver, compver)) {\n            minver = compver\n          }\n          break\n        case '<':\n        case '<=':\n          /* Ignore maximum versions */\n          break\n        /* istanbul ignore next */\n        default:\n          throw new Error(`Unexpected operation: ${comparator.operator}`)\n      }\n    })\n  }\n\n  if (minver && range.test(minver)) {\n    return minver\n  }\n\n  return null\n}\nmodule.exports = minVersion\n", "const Range = require('../classes/range')\nconst validRange = (range, options) => {\n  try {\n    // Return '*' instead of '' so that truthiness works.\n    // This will throw if it's invalid anyway\n    return new Range(range, options).range || '*'\n  } catch (er) {\n    return null\n  }\n}\nmodule.exports = validRange\n", "const SemVer = require('../classes/semver')\nconst Comparator = require('../classes/comparator')\nconst {ANY} = Comparator\nconst Range = require('../classes/range')\nconst satisfies = require('../functions/satisfies')\nconst gt = require('../functions/gt')\nconst lt = require('../functions/lt')\nconst lte = require('../functions/lte')\nconst gte = require('../functions/gte')\n\nconst outside = (version, range, hilo, options) => {\n  version = new SemVer(version, options)\n  range = new Range(range, options)\n\n  let gtfn, ltefn, ltfn, comp, ecomp\n  switch (hilo) {\n    case '>':\n      gtfn = gt\n      ltefn = lte\n      ltfn = lt\n      comp = '>'\n      ecomp = '>='\n      break\n    case '<':\n      gtfn = lt\n      ltefn = gte\n      ltfn = gt\n      comp = '<'\n      ecomp = '<='\n      break\n    default:\n      throw new TypeError('Must provide a hilo val of \"<\" or \">\"')\n  }\n\n  // If it satisifes the range it is not outside\n  if (satisfies(version, range, options)) {\n    return false\n  }\n\n  // From now on, variable terms are as if we're in \"gtr\" mode.\n  // but note that everything is flipped for the \"ltr\" function.\n\n  for (let i = 0; i < range.set.length; ++i) {\n    const comparators = range.set[i]\n\n    let high = null\n    let low = null\n\n    comparators.forEach((comparator) => {\n      if (comparator.semver === ANY) {\n        comparator = new Comparator('>=0.0.0')\n      }\n      high = high || comparator\n      low = low || comparator\n      if (gtfn(comparator.semver, high.semver, options)) {\n        high = comparator\n      } else if (ltfn(comparator.semver, low.semver, options)) {\n        low = comparator\n      }\n    })\n\n    // If the edge version comparator has a operator then our version\n    // isn't outside it\n    if (high.operator === comp || high.operator === ecomp) {\n      return false\n    }\n\n    // If the lowest version comparator has an operator and our version\n    // is less than it then it isn't higher than the range\n    if ((!low.operator || low.operator === comp) &&\n        ltefn(version, low.semver)) {\n      return false\n    } else if (low.operator === ecomp && ltfn(version, low.semver)) {\n      return false\n    }\n  }\n  return true\n}\n\nmodule.exports = outside\n", "// Determine if version is greater than all the versions possible in the range.\nconst outside = require('./outside')\nconst gtr = (version, range, options) => outside(version, range, '>', options)\nmodule.exports = gtr\n", "const outside = require('./outside')\n// Determine if version is less than all the versions possible in the range\nconst ltr = (version, range, options) => outside(version, range, '<', options)\nmodule.exports = ltr\n", "const Range = require('../classes/range')\nconst intersects = (r1, r2, options) => {\n  r1 = new Range(r1, options)\n  r2 = new Range(r2, options)\n  return r1.intersects(r2)\n}\nmodule.exports = intersects\n", "// given a set of versions and a range, create a \"simplified\" range\n// that includes the same versions that the original range does\n// If the original range is shorter than the simplified one, return that.\nconst satisfies = require('../functions/satisfies.js')\nconst compare = require('../functions/compare.js')\nmodule.exports = (versions, range, options) => {\n  const set = []\n  let min = null\n  let prev = null\n  const v = versions.sort((a, b) => compare(a, b, options))\n  for (const version of v) {\n    const included = satisfies(version, range, options)\n    if (included) {\n      prev = version\n      if (!min)\n        min = version\n    } else {\n      if (prev) {\n        set.push([min, prev])\n      }\n      prev = null\n      min = null\n    }\n  }\n  if (min)\n    set.push([min, null])\n\n  const ranges = []\n  for (const [min, max] of set) {\n    if (min === max)\n      ranges.push(min)\n    else if (!max && min === v[0])\n      ranges.push('*')\n    else if (!max)\n      ranges.push(`>=${min}`)\n    else if (min === v[0])\n      ranges.push(`<=${max}`)\n    else\n      ranges.push(`${min} - ${max}`)\n  }\n  const simplified = ranges.join(' || ')\n  const original = typeof range.raw === 'string' ? range.raw : String(range)\n  return simplified.length < original.length ? simplified : range\n}\n", "const Range = require('../classes/range.js')\nconst { ANY } = require('../classes/comparator.js')\nconst satisfies = require('../functions/satisfies.js')\nconst compare = require('../functions/compare.js')\n\n// Complex range `r1 || r2 || ...` is a subset of `R1 || R2 || ...` iff:\n// - Every simple range `r1, r2, ...` is a subset of some `R1, R2, ...`\n//\n// Simple range `c1 c2 ...` is a subset of simple range `C1 C2 ...` iff:\n// - If c is only the ANY comparator\n//   - If C is only the ANY comparator, return true\n//   - Else return false\n// - Let EQ be the set of = comparators in c\n// - If EQ is more than one, return true (null set)\n// - Let GT be the highest > or >= comparator in c\n// - Let LT be the lowest < or <= comparator in c\n// - If GT and LT, and GT.semver > LT.semver, return true (null set)\n// - If EQ\n//   - If GT, and EQ does not satisfy GT, return true (null set)\n//   - If LT, and EQ does not satisfy LT, return true (null set)\n//   - If EQ satisfies every C, return true\n//   - Else return false\n// - If GT\n//   - If GT is lower than any > or >= comp in C, return false\n//   - If GT is >=, and GT.semver does not satisfy every C, return false\n// - If LT\n//   - If LT.semver is greater than that of any > comp in C, return false\n//   - If LT is <=, and LT.semver does not satisfy every C, return false\n// - If any C is a = range, and GT or LT are set, return false\n// - Else return true\n\nconst subset = (sub, dom, options) => {\n  sub = new Range(sub, options)\n  dom = new Range(dom, options)\n  let sawNonNull = false\n\n  OUTER: for (const simpleSub of sub.set) {\n    for (const simpleDom of dom.set) {\n      const isSub = simpleSubset(simpleSub, simpleDom, options)\n      sawNonNull = sawNonNull || isSub !== null\n      if (isSub)\n        continue OUTER\n    }\n    // the null set is a subset of everything, but null simple ranges in\n    // a complex range should be ignored.  so if we saw a non-null range,\n    // then we know this isn't a subset, but if EVERY simple range was null,\n    // then it is a subset.\n    if (sawNonNull)\n      return false\n  }\n  return true\n}\n\nconst simpleSubset = (sub, dom, options) => {\n  if (sub.length === 1 && sub[0].semver === ANY)\n    return dom.length === 1 && dom[0].semver === ANY\n\n  const eqSet = new Set()\n  let gt, lt\n  for (const c of sub) {\n    if (c.operator === '>' || c.operator === '>=')\n      gt = higherGT(gt, c, options)\n    else if (c.operator === '<' || c.operator === '<=')\n      lt = lowerLT(lt, c, options)\n    else\n      eqSet.add(c.semver)\n  }\n\n  if (eqSet.size > 1)\n    return null\n\n  let gtltComp\n  if (gt && lt) {\n    gtltComp = compare(gt.semver, lt.semver, options)\n    if (gtltComp > 0)\n      return null\n    else if (gtltComp === 0 && (gt.operator !== '>=' || lt.operator !== '<='))\n      return null\n  }\n\n  // will iterate one or zero times\n  for (const eq of eqSet) {\n    if (gt && !satisfies(eq, String(gt), options))\n      return null\n\n    if (lt && !satisfies(eq, String(lt), options))\n      return null\n\n    for (const c of dom) {\n      if (!satisfies(eq, String(c), options))\n        return false\n    }\n    return true\n  }\n\n  let higher, lower\n  let hasDomLT, hasDomGT\n  for (const c of dom) {\n    hasDomGT = hasDomGT || c.operator === '>' || c.operator === '>='\n    hasDomLT = hasDomLT || c.operator === '<' || c.operator === '<='\n    if (gt) {\n      if (c.operator === '>' || c.operator === '>=') {\n        higher = higherGT(gt, c, options)\n        if (higher === c)\n          return false\n      } else if (gt.operator === '>=' && !satisfies(gt.semver, String(c), options))\n        return false\n    }\n    if (lt) {\n      if (c.operator === '<' || c.operator === '<=') {\n        lower = lowerLT(lt, c, options)\n        if (lower === c)\n          return false\n      } else if (lt.operator === '<=' && !satisfies(lt.semver, String(c), options))\n        return false\n    }\n    if (!c.operator && (lt || gt) && gtltComp !== 0)\n      return false\n  }\n\n  // if there was a < or >, and nothing in the dom, then must be false\n  // UNLESS it was limited by another range in the other direction.\n  // Eg, >1.0.0 <1.0.1 is still a subset of <2.0.0\n  if (gt && hasDomLT && !lt && gtltComp !== 0)\n    return false\n\n  if (lt && hasDomGT && !gt && gtltComp !== 0)\n    return false\n\n  return true\n}\n\n// >=1.2.3 is lower than >1.2.3\nconst higherGT = (a, b, options) => {\n  if (!a)\n    return b\n  const comp = compare(a.semver, b.semver, options)\n  return comp > 0 ? a\n    : comp < 0 ? b\n    : b.operator === '>' && a.operator === '>=' ? b\n    : a\n}\n\n// <=1.2.3 is higher than <1.2.3\nconst lowerLT = (a, b, options) => {\n  if (!a)\n    return b\n  const comp = compare(a.semver, b.semver, options)\n  return comp < 0 ? a\n    : comp > 0 ? b\n    : b.operator === '<' && a.operator === '<=' ? b\n    : a\n}\n\nmodule.exports = subset\n", "// just pre-load all the stuff that index.js lazily exports\nconst internalRe = require('./internal/re')\nmodule.exports = {\n  re: internalRe.re,\n  src: internalRe.src,\n  tokens: internalRe.t,\n  SEMVER_SPEC_VERSION: require('./internal/constants').SEMVER_SPEC_VERSION,\n  SemVer: require('./classes/semver'),\n  compareIdentifiers: require('./internal/identifiers').compareIdentifiers,\n  rcompareIdentifiers: require('./internal/identifiers').rcompareIdentifiers,\n  parse: require('./functions/parse'),\n  valid: require('./functions/valid'),\n  clean: require('./functions/clean'),\n  inc: require('./functions/inc'),\n  diff: require('./functions/diff'),\n  major: require('./functions/major'),\n  minor: require('./functions/minor'),\n  patch: require('./functions/patch'),\n  prerelease: require('./functions/prerelease'),\n  compare: require('./functions/compare'),\n  rcompare: require('./functions/rcompare'),\n  compareLoose: require('./functions/compare-loose'),\n  compareBuild: require('./functions/compare-build'),\n  sort: require('./functions/sort'),\n  rsort: require('./functions/rsort'),\n  gt: require('./functions/gt'),\n  lt: require('./functions/lt'),\n  eq: require('./functions/eq'),\n  neq: require('./functions/neq'),\n  gte: require('./functions/gte'),\n  lte: require('./functions/lte'),\n  cmp: require('./functions/cmp'),\n  coerce: require('./functions/coerce'),\n  Comparator: require('./classes/comparator'),\n  Range: require('./classes/range'),\n  satisfies: require('./functions/satisfies'),\n  toComparators: require('./ranges/to-comparators'),\n  maxSatisfying: require('./ranges/max-satisfying'),\n  minSatisfying: require('./ranges/min-satisfying'),\n  minVersion: require('./ranges/min-version'),\n  validRange: require('./ranges/valid'),\n  outside: require('./ranges/outside'),\n  gtr: require('./ranges/gtr'),\n  ltr: require('./ranges/ltr'),\n  intersects: require('./ranges/intersects'),\n  simplifyRange: require('./ranges/simplify'),\n  subset: require('./ranges/subset'),\n}\n", "(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n\ttypeof define === 'function' && define.amd ? define(['exports'], factory) :\n\t(global = global || self, factory(global.svelte = {}));\n}(this, (function (exports) { 'use strict';\n\n\tfunction assign(tar, src) {\n\t    // @ts-ignore\n\t    for (const k in src)\n\t        tar[k] = src[k];\n\t    return tar;\n\t}\n\n\tconst now = (typeof process !== 'undefined' && process.hrtime)\n\t    ? () => {\n\t        const t = process.hrtime();\n\t        return t[0] * 1e3 + t[1] / 1e6;\n\t    }\n\t    : () => self.performance.now();\n\tfunction collapse_timings(timings) {\n\t    const result = {};\n\t    timings.forEach(timing => {\n\t        result[timing.label] = Object.assign({\n\t            total: timing.end - timing.start\n\t        }, timing.children && collapse_timings(timing.children));\n\t    });\n\t    return result;\n\t}\n\tclass Stats {\n\t    constructor() {\n\t        this.start_time = now();\n\t        this.stack = [];\n\t        this.current_children = this.timings = [];\n\t    }\n\t    start(label) {\n\t        const timing = {\n\t            label,\n\t            start: now(),\n\t            end: null,\n\t            children: []\n\t        };\n\t        this.current_children.push(timing);\n\t        this.stack.push(timing);\n\t        this.current_timing = timing;\n\t        this.current_children = timing.children;\n\t    }\n\t    stop(label) {\n\t        if (label !== this.current_timing.label) {\n\t            throw new Error(`Mismatched timing labels (expected ${this.current_timing.label}, got ${label})`);\n\t        }\n\t        this.current_timing.end = now();\n\t        this.stack.pop();\n\t        this.current_timing = this.stack[this.stack.length - 1];\n\t        this.current_children = this.current_timing ? this.current_timing.children : this.timings;\n\t    }\n\t    render() {\n\t        const timings = Object.assign({\n\t            total: now() - this.start_time\n\t        }, collapse_timings(this.timings));\n\t        return {\n\t            timings\n\t        };\n\t    }\n\t}\n\n\t// Reserved word lists for various dialects of the language\n\n\tvar reservedWords = {\n\t  3: \"abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile\",\n\t  5: \"class enum extends super const export import\",\n\t  6: \"enum\",\n\t  strict: \"implements interface let package private protected public static yield\",\n\t  strictBind: \"eval arguments\"\n\t};\n\n\t// And the keywords\n\n\tvar ecma5AndLessKeywords = \"break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this\";\n\n\tvar keywords = {\n\t  5: ecma5AndLessKeywords,\n\t  \"5module\": ecma5AndLessKeywords + \" export import\",\n\t  6: ecma5AndLessKeywords + \" const class extends export import super\"\n\t};\n\n\tvar keywordRelationalOperator = /^in(stanceof)?$/;\n\n\t// ## Character categories\n\n\t// Big ugly regular expressions that match characters in the\n\t// whitespace, identifier, and identifier-start categories. These\n\t// are only applied when a character is found to actually have a\n\t// code point above 128.\n\t// Generated by `bin/generate-identifier-regex.js`.\n\tvar nonASCIIidentifierStartChars = \"\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u037f\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u052f\\u0531-\\u0556\\u0559\\u0560-\\u0588\\u05d0-\\u05ea\\u05ef-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u0860-\\u086a\\u08a0-\\u08b4\\u08b6-\\u08c7\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u09fc\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0af9\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c39\\u0c3d\\u0c58-\\u0c5a\\u0c60\\u0c61\\u0c80\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d04-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d54-\\u0d56\\u0d5f-\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e86-\\u0e8a\\u0e8c-\\u0ea3\\u0ea5\\u0ea7-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f5\\u13f8-\\u13fd\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f8\\u1700-\\u170c\\u170e-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1878\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191e\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19b0-\\u19c9\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4b\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1c80-\\u1c88\\u1c90-\\u1cba\\u1cbd-\\u1cbf\\u1ce9-\\u1cec\\u1cee-\\u1cf3\\u1cf5\\u1cf6\\u1cfa\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2118-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309b-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312f\\u3131-\\u318e\\u31a0-\\u31bf\\u31f0-\\u31ff\\u3400-\\u4dbf\\u4e00-\\u9ffc\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua69d\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua7bf\\ua7c2-\\ua7ca\\ua7f5-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua8fd\\ua8fe\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\ua9e0-\\ua9e4\\ua9e6-\\ua9ef\\ua9fa-\\ua9fe\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa7e-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uab30-\\uab5a\\uab5c-\\uab69\\uab70-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc\";\n\tvar nonASCIIidentifierChars = \"\\u200c\\u200d\\xb7\\u0300-\\u036f\\u0387\\u0483-\\u0487\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u0669\\u0670\\u06d6-\\u06dc\\u06df-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u06f0-\\u06f9\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07c0-\\u07c9\\u07eb-\\u07f3\\u07fd\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0859-\\u085b\\u08d3-\\u08e1\\u08e3-\\u0903\\u093a-\\u093c\\u093e-\\u094f\\u0951-\\u0957\\u0962\\u0963\\u0966-\\u096f\\u0981-\\u0983\\u09bc\\u09be-\\u09c4\\u09c7\\u09c8\\u09cb-\\u09cd\\u09d7\\u09e2\\u09e3\\u09e6-\\u09ef\\u09fe\\u0a01-\\u0a03\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a66-\\u0a71\\u0a75\\u0a81-\\u0a83\\u0abc\\u0abe-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ae2\\u0ae3\\u0ae6-\\u0aef\\u0afa-\\u0aff\\u0b01-\\u0b03\\u0b3c\\u0b3e-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b55-\\u0b57\\u0b62\\u0b63\\u0b66-\\u0b6f\\u0b82\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd7\\u0be6-\\u0bef\\u0c00-\\u0c04\\u0c3e-\\u0c44\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0c66-\\u0c6f\\u0c81-\\u0c83\\u0cbc\\u0cbe-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0ce6-\\u0cef\\u0d00-\\u0d03\\u0d3b\\u0d3c\\u0d3e-\\u0d44\\u0d46-\\u0d48\\u0d4a-\\u0d4d\\u0d57\\u0d62\\u0d63\\u0d66-\\u0d6f\\u0d81-\\u0d83\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0de6-\\u0def\\u0df2\\u0df3\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0e50-\\u0e59\\u0eb1\\u0eb4-\\u0ebc\\u0ec8-\\u0ecd\\u0ed0-\\u0ed9\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f3e\\u0f3f\\u0f71-\\u0f84\\u0f86\\u0f87\\u0f8d-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102b-\\u103e\\u1040-\\u1049\\u1056-\\u1059\\u105e-\\u1060\\u1062-\\u1064\\u1067-\\u106d\\u1071-\\u1074\\u1082-\\u108d\\u108f-\\u109d\\u135d-\\u135f\\u1369-\\u1371\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b4-\\u17d3\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u1810-\\u1819\\u18a9\\u1920-\\u192b\\u1930-\\u193b\\u1946-\\u194f\\u19d0-\\u19da\\u1a17-\\u1a1b\\u1a55-\\u1a5e\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1ab0-\\u1abd\\u1abf\\u1ac0\\u1b00-\\u1b04\\u1b34-\\u1b44\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1b80-\\u1b82\\u1ba1-\\u1bad\\u1bb0-\\u1bb9\\u1be6-\\u1bf3\\u1c24-\\u1c37\\u1c40-\\u1c49\\u1c50-\\u1c59\\u1cd0-\\u1cd2\\u1cd4-\\u1ce8\\u1ced\\u1cf4\\u1cf7-\\u1cf9\\u1dc0-\\u1df9\\u1dfb-\\u1dff\\u203f\\u2040\\u2054\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2cef-\\u2cf1\\u2d7f\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua620-\\ua629\\ua66f\\ua674-\\ua67d\\ua69e\\ua69f\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua823-\\ua827\\ua82c\\ua880\\ua881\\ua8b4-\\ua8c5\\ua8d0-\\ua8d9\\ua8e0-\\ua8f1\\ua8ff-\\ua909\\ua926-\\ua92d\\ua947-\\ua953\\ua980-\\ua983\\ua9b3-\\ua9c0\\ua9d0-\\ua9d9\\ua9e5\\ua9f0-\\ua9f9\\uaa29-\\uaa36\\uaa43\\uaa4c\\uaa4d\\uaa50-\\uaa59\\uaa7b-\\uaa7d\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uaaeb-\\uaaef\\uaaf5\\uaaf6\\uabe3-\\uabea\\uabec\\uabed\\uabf0-\\uabf9\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe2f\\ufe33\\ufe34\\ufe4d-\\ufe4f\\uff10-\\uff19\\uff3f\";\n\n\tvar nonASCIIidentifierStart = new RegExp(\"[\" + nonASCIIidentifierStartChars + \"]\");\n\tvar nonASCIIidentifier = new RegExp(\"[\" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \"]\");\n\n\tnonASCIIidentifierStartChars = nonASCIIidentifierChars = null;\n\n\t// These are a run-length and offset encoded representation of the\n\t// >0xffff code points that are a valid part of identifiers. The\n\t// offset starts at 0x10000, and each pair of numbers represents an\n\t// offset to the next range, and then a size of the range. They were\n\t// generated by bin/generate-identifier-regex.js\n\n\t// eslint-disable-next-line comma-spacing\n\tvar astralIdentifierStartCodes = [0,11,2,25,2,18,2,1,2,14,3,13,35,122,70,52,268,28,4,48,48,31,14,29,6,37,11,29,3,35,5,7,2,4,43,157,19,35,5,35,5,39,9,51,157,310,10,21,11,7,153,5,3,0,2,43,2,1,4,0,3,22,11,22,10,30,66,18,2,1,11,21,11,25,71,55,7,1,65,0,16,3,2,2,2,28,43,28,4,28,36,7,2,27,28,53,11,21,11,18,14,17,111,72,56,50,14,50,14,35,349,41,7,1,79,28,11,0,9,21,107,20,28,22,13,52,76,44,33,24,27,35,30,0,3,0,9,34,4,0,13,47,15,3,22,0,2,0,36,17,2,24,85,6,2,0,2,3,2,14,2,9,8,46,39,7,3,1,3,21,2,6,2,1,2,4,4,0,19,0,13,4,159,52,19,3,21,2,31,47,21,1,2,0,185,46,42,3,37,47,21,0,60,42,14,0,72,26,230,43,117,63,32,7,3,0,3,7,2,1,2,23,16,0,2,0,95,7,3,38,17,0,2,0,29,0,11,39,8,0,22,0,12,45,20,0,35,56,264,8,2,36,18,0,50,29,113,6,2,1,2,37,22,0,26,5,2,1,2,31,15,0,328,18,190,0,80,921,103,110,18,195,2749,1070,4050,582,8634,568,8,30,114,29,19,47,17,3,32,20,6,18,689,63,129,74,6,0,67,12,65,1,2,0,29,6135,9,1237,43,8,8952,286,50,2,18,3,9,395,2309,106,6,12,4,8,8,9,5991,84,2,70,2,1,3,0,3,1,3,3,2,11,2,0,2,6,2,64,2,3,3,7,2,6,2,27,2,3,2,4,2,0,4,6,2,339,3,24,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,7,2357,44,11,6,17,0,370,43,1301,196,60,67,8,0,1205,3,2,26,2,1,2,0,3,0,2,9,2,3,2,0,2,0,7,0,5,0,2,0,2,0,2,2,2,1,2,0,3,0,2,0,2,0,2,0,2,0,2,1,2,0,3,3,2,6,2,3,2,3,2,0,2,9,2,16,6,2,2,4,2,16,4421,42717,35,4148,12,221,3,5761,15,7472,3104,541,1507,4938];\n\n\t// eslint-disable-next-line comma-spacing\n\tvar astralIdentifierCodes = [509,0,227,0,150,4,294,9,1368,2,2,1,6,3,41,2,5,0,166,1,574,3,9,9,370,1,154,10,176,2,54,14,32,9,16,3,46,10,54,9,7,2,37,13,2,9,6,1,45,0,13,2,49,13,9,3,2,11,83,11,7,0,161,11,6,9,7,3,56,1,2,6,3,1,3,2,10,0,11,1,3,6,4,4,193,17,10,9,5,0,82,19,13,9,214,6,3,8,28,1,83,16,16,9,82,12,9,9,84,14,5,9,243,14,166,9,71,5,2,1,3,3,2,0,2,1,13,9,120,6,3,6,4,0,29,9,41,6,2,3,9,0,10,10,47,15,406,7,2,7,17,9,57,21,2,13,123,5,4,0,2,1,2,6,2,0,9,9,49,4,2,1,2,4,9,9,330,3,19306,9,135,4,60,6,26,9,1014,0,2,54,8,3,82,0,12,1,19628,1,5319,4,4,5,9,7,3,6,31,3,149,2,1418,49,513,54,5,49,9,0,15,0,23,4,2,14,1361,6,2,16,3,6,2,1,2,4,262,6,10,9,419,13,1495,6,110,6,6,9,4759,9,787719,239];\n\n\t// This has a complexity linear to the value of the code. The\n\t// assumption is that looking up astral identifier characters is\n\t// rare.\n\tfunction isInAstralSet(code, set) {\n\t  var pos = 0x10000;\n\t  for (var i = 0; i < set.length; i += 2) {\n\t    pos += set[i];\n\t    if (pos > code) { return false }\n\t    pos += set[i + 1];\n\t    if (pos >= code) { return true }\n\t  }\n\t}\n\n\t// Test whether a given character code starts an identifier.\n\n\tfunction isIdentifierStart(code, astral) {\n\t  if (code < 65) { return code === 36 }\n\t  if (code < 91) { return true }\n\t  if (code < 97) { return code === 95 }\n\t  if (code < 123) { return true }\n\t  if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code)) }\n\t  if (astral === false) { return false }\n\t  return isInAstralSet(code, astralIdentifierStartCodes)\n\t}\n\n\t// Test whether a given character is part of an identifier.\n\n\tfunction isIdentifierChar(code, astral) {\n\t  if (code < 48) { return code === 36 }\n\t  if (code < 58) { return true }\n\t  if (code < 65) { return false }\n\t  if (code < 91) { return true }\n\t  if (code < 97) { return code === 95 }\n\t  if (code < 123) { return true }\n\t  if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code)) }\n\t  if (astral === false) { return false }\n\t  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes)\n\t}\n\n\t// ## Token types\n\n\t// The assignment of fine-grained, information-carrying type objects\n\t// allows the tokenizer to store the information it has about a\n\t// token in a way that is very cheap for the parser to look up.\n\n\t// All token type variables start with an underscore, to make them\n\t// easy to recognize.\n\n\t// The `beforeExpr` property is used to disambiguate between regular\n\t// expressions and divisions. It is set on all token types that can\n\t// be followed by an expression (thus, a slash after them would be a\n\t// regular expression).\n\t//\n\t// The `startsExpr` property is used to check if the token ends a\n\t// `yield` expression. It is set on all token types that either can\n\t// directly start an expression (like a quotation mark) or can\n\t// continue an expression (like the body of a string).\n\t//\n\t// `isLoop` marks a keyword as starting a loop, which is important\n\t// to know when parsing a label, in order to allow or disallow\n\t// continue jumps to that label.\n\n\tvar TokenType = function TokenType(label, conf) {\n\t  if ( conf === void 0 ) conf = {};\n\n\t  this.label = label;\n\t  this.keyword = conf.keyword;\n\t  this.beforeExpr = !!conf.beforeExpr;\n\t  this.startsExpr = !!conf.startsExpr;\n\t  this.isLoop = !!conf.isLoop;\n\t  this.isAssign = !!conf.isAssign;\n\t  this.prefix = !!conf.prefix;\n\t  this.postfix = !!conf.postfix;\n\t  this.binop = conf.binop || null;\n\t  this.updateContext = null;\n\t};\n\n\tfunction binop(name, prec) {\n\t  return new TokenType(name, {beforeExpr: true, binop: prec})\n\t}\n\tvar beforeExpr = {beforeExpr: true}, startsExpr = {startsExpr: true};\n\n\t// Map keyword names to token types.\n\n\tvar keywords$1 = {};\n\n\t// Succinct definitions of keyword token types\n\tfunction kw(name, options) {\n\t  if ( options === void 0 ) options = {};\n\n\t  options.keyword = name;\n\t  return keywords$1[name] = new TokenType(name, options)\n\t}\n\n\tvar types = {\n\t  num: new TokenType(\"num\", startsExpr),\n\t  regexp: new TokenType(\"regexp\", startsExpr),\n\t  string: new TokenType(\"string\", startsExpr),\n\t  name: new TokenType(\"name\", startsExpr),\n\t  eof: new TokenType(\"eof\"),\n\n\t  // Punctuation token types.\n\t  bracketL: new TokenType(\"[\", {beforeExpr: true, startsExpr: true}),\n\t  bracketR: new TokenType(\"]\"),\n\t  braceL: new TokenType(\"{\", {beforeExpr: true, startsExpr: true}),\n\t  braceR: new TokenType(\"}\"),\n\t  parenL: new TokenType(\"(\", {beforeExpr: true, startsExpr: true}),\n\t  parenR: new TokenType(\")\"),\n\t  comma: new TokenType(\",\", beforeExpr),\n\t  semi: new TokenType(\";\", beforeExpr),\n\t  colon: new TokenType(\":\", beforeExpr),\n\t  dot: new TokenType(\".\"),\n\t  question: new TokenType(\"?\", beforeExpr),\n\t  questionDot: new TokenType(\"?.\"),\n\t  arrow: new TokenType(\"=>\", beforeExpr),\n\t  template: new TokenType(\"template\"),\n\t  invalidTemplate: new TokenType(\"invalidTemplate\"),\n\t  ellipsis: new TokenType(\"...\", beforeExpr),\n\t  backQuote: new TokenType(\"`\", startsExpr),\n\t  dollarBraceL: new TokenType(\"${\", {beforeExpr: true, startsExpr: true}),\n\n\t  // Operators. These carry several kinds of properties to help the\n\t  // parser use them properly (the presence of these properties is\n\t  // what categorizes them as operators).\n\t  //\n\t  // `binop`, when present, specifies that this operator is a binary\n\t  // operator, and will refer to its precedence.\n\t  //\n\t  // `prefix` and `postfix` mark the operator as a prefix or postfix\n\t  // unary operator.\n\t  //\n\t  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as\n\t  // binary operators with a very low precedence, that should result\n\t  // in AssignmentExpression nodes.\n\n\t  eq: new TokenType(\"=\", {beforeExpr: true, isAssign: true}),\n\t  assign: new TokenType(\"_=\", {beforeExpr: true, isAssign: true}),\n\t  incDec: new TokenType(\"++/--\", {prefix: true, postfix: true, startsExpr: true}),\n\t  prefix: new TokenType(\"!/~\", {beforeExpr: true, prefix: true, startsExpr: true}),\n\t  logicalOR: binop(\"||\", 1),\n\t  logicalAND: binop(\"&&\", 2),\n\t  bitwiseOR: binop(\"|\", 3),\n\t  bitwiseXOR: binop(\"^\", 4),\n\t  bitwiseAND: binop(\"&\", 5),\n\t  equality: binop(\"==/!=/===/!==\", 6),\n\t  relational: binop(\"</>/<=/>=\", 7),\n\t  bitShift: binop(\"<</>>/>>>\", 8),\n\t  plusMin: new TokenType(\"+/-\", {beforeExpr: true, binop: 9, prefix: true, startsExpr: true}),\n\t  modulo: binop(\"%\", 10),\n\t  star: binop(\"*\", 10),\n\t  slash: binop(\"/\", 10),\n\t  starstar: new TokenType(\"**\", {beforeExpr: true}),\n\t  coalesce: binop(\"??\", 1),\n\n\t  // Keyword token types.\n\t  _break: kw(\"break\"),\n\t  _case: kw(\"case\", beforeExpr),\n\t  _catch: kw(\"catch\"),\n\t  _continue: kw(\"continue\"),\n\t  _debugger: kw(\"debugger\"),\n\t  _default: kw(\"default\", beforeExpr),\n\t  _do: kw(\"do\", {isLoop: true, beforeExpr: true}),\n\t  _else: kw(\"else\", beforeExpr),\n\t  _finally: kw(\"finally\"),\n\t  _for: kw(\"for\", {isLoop: true}),\n\t  _function: kw(\"function\", startsExpr),\n\t  _if: kw(\"if\"),\n\t  _return: kw(\"return\", beforeExpr),\n\t  _switch: kw(\"switch\"),\n\t  _throw: kw(\"throw\", beforeExpr),\n\t  _try: kw(\"try\"),\n\t  _var: kw(\"var\"),\n\t  _const: kw(\"const\"),\n\t  _while: kw(\"while\", {isLoop: true}),\n\t  _with: kw(\"with\"),\n\t  _new: kw(\"new\", {beforeExpr: true, startsExpr: true}),\n\t  _this: kw(\"this\", startsExpr),\n\t  _super: kw(\"super\", startsExpr),\n\t  _class: kw(\"class\", startsExpr),\n\t  _extends: kw(\"extends\", beforeExpr),\n\t  _export: kw(\"export\"),\n\t  _import: kw(\"import\", startsExpr),\n\t  _null: kw(\"null\", startsExpr),\n\t  _true: kw(\"true\", startsExpr),\n\t  _false: kw(\"false\", startsExpr),\n\t  _in: kw(\"in\", {beforeExpr: true, binop: 7}),\n\t  _instanceof: kw(\"instanceof\", {beforeExpr: true, binop: 7}),\n\t  _typeof: kw(\"typeof\", {beforeExpr: true, prefix: true, startsExpr: true}),\n\t  _void: kw(\"void\", {beforeExpr: true, prefix: true, startsExpr: true}),\n\t  _delete: kw(\"delete\", {beforeExpr: true, prefix: true, startsExpr: true})\n\t};\n\n\t// Matches a whole line break (where CRLF is considered a single\n\t// line break). Used to count lines.\n\n\tvar lineBreak = /\\r\\n?|\\n|\\u2028|\\u2029/;\n\tvar lineBreakG = new RegExp(lineBreak.source, \"g\");\n\n\tfunction isNewLine(code, ecma2019String) {\n\t  return code === 10 || code === 13 || (!ecma2019String && (code === 0x2028 || code === 0x2029))\n\t}\n\n\tvar nonASCIIwhitespace = /[\\u1680\\u2000-\\u200a\\u202f\\u205f\\u3000\\ufeff]/;\n\n\tvar skipWhiteSpace = /(?:\\s|\\/\\/.*|\\/\\*[^]*?\\*\\/)*/g;\n\n\tvar ref = Object.prototype;\n\tvar hasOwnProperty = ref.hasOwnProperty;\n\tvar toString = ref.toString;\n\n\t// Checks if an object has a property.\n\n\tfunction has(obj, propName) {\n\t  return hasOwnProperty.call(obj, propName)\n\t}\n\n\tvar isArray = Array.isArray || (function (obj) { return (\n\t  toString.call(obj) === \"[object Array]\"\n\t); });\n\n\tfunction wordsRegexp(words) {\n\t  return new RegExp(\"^(?:\" + words.replace(/ /g, \"|\") + \")$\")\n\t}\n\n\t// These are used when `options.locations` is on, for the\n\t// `startLoc` and `endLoc` properties.\n\n\tvar Position = function Position(line, col) {\n\t  this.line = line;\n\t  this.column = col;\n\t};\n\n\tPosition.prototype.offset = function offset (n) {\n\t  return new Position(this.line, this.column + n)\n\t};\n\n\tvar SourceLocation = function SourceLocation(p, start, end) {\n\t  this.start = start;\n\t  this.end = end;\n\t  if (p.sourceFile !== null) { this.source = p.sourceFile; }\n\t};\n\n\t// The `getLineInfo` function is mostly useful when the\n\t// `locations` option is off (for performance reasons) and you\n\t// want to find the line/column position for a given character\n\t// offset. `input` should be the code string that the offset refers\n\t// into.\n\n\tfunction getLineInfo(input, offset) {\n\t  for (var line = 1, cur = 0;;) {\n\t    lineBreakG.lastIndex = cur;\n\t    var match = lineBreakG.exec(input);\n\t    if (match && match.index < offset) {\n\t      ++line;\n\t      cur = match.index + match[0].length;\n\t    } else {\n\t      return new Position(line, offset - cur)\n\t    }\n\t  }\n\t}\n\n\t// A second optional argument can be given to further configure\n\t// the parser process. These options are recognized:\n\n\tvar defaultOptions = {\n\t  // `ecmaVersion` indicates the ECMAScript version to parse. Must be\n\t  // either 3, 5, 6 (2015), 7 (2016), 8 (2017), 9 (2018), or 10\n\t  // (2019). This influences support for strict mode, the set of\n\t  // reserved words, and support for new syntax features. The default\n\t  // is 10.\n\t  ecmaVersion: 10,\n\t  // `sourceType` indicates the mode the code should be parsed in.\n\t  // Can be either `\"script\"` or `\"module\"`. This influences global\n\t  // strict mode and parsing of `import` and `export` declarations.\n\t  sourceType: \"script\",\n\t  // `onInsertedSemicolon` can be a callback that will be called\n\t  // when a semicolon is automatically inserted. It will be passed\n\t  // the position of the comma as an offset, and if `locations` is\n\t  // enabled, it is given the location as a `{line, column}` object\n\t  // as second argument.\n\t  onInsertedSemicolon: null,\n\t  // `onTrailingComma` is similar to `onInsertedSemicolon`, but for\n\t  // trailing commas.\n\t  onTrailingComma: null,\n\t  // By default, reserved words are only enforced if ecmaVersion >= 5.\n\t  // Set `allowReserved` to a boolean value to explicitly turn this on\n\t  // an off. When this option has the value \"never\", reserved words\n\t  // and keywords can also not be used as property names.\n\t  allowReserved: null,\n\t  // When enabled, a return at the top level is not considered an\n\t  // error.\n\t  allowReturnOutsideFunction: false,\n\t  // When enabled, import/export statements are not constrained to\n\t  // appearing at the top of the program.\n\t  allowImportExportEverywhere: false,\n\t  // When enabled, await identifiers are allowed to appear at the top-level scope,\n\t  // but they are still not allowed in non-async functions.\n\t  allowAwaitOutsideFunction: false,\n\t  // When enabled, hashbang directive in the beginning of file\n\t  // is allowed and treated as a line comment.\n\t  allowHashBang: false,\n\t  // When `locations` is on, `loc` properties holding objects with\n\t  // `start` and `end` properties in `{line, column}` form (with\n\t  // line being 1-based and column 0-based) will be attached to the\n\t  // nodes.\n\t  locations: false,\n\t  // A function can be passed as `onToken` option, which will\n\t  // cause Acorn to call that function with object in the same\n\t  // format as tokens returned from `tokenizer().getToken()`. Note\n\t  // that you are not allowed to call the parser from the\n\t  // callback\u2014that will corrupt its internal state.\n\t  onToken: null,\n\t  // A function can be passed as `onComment` option, which will\n\t  // cause Acorn to call that function with `(block, text, start,\n\t  // end)` parameters whenever a comment is skipped. `block` is a\n\t  // boolean indicating whether this is a block (`/* */`) comment,\n\t  // `text` is the content of the comment, and `start` and `end` are\n\t  // character offsets that denote the start and end of the comment.\n\t  // When the `locations` option is on, two more parameters are\n\t  // passed, the full `{line, column}` locations of the start and\n\t  // end of the comments. Note that you are not allowed to call the\n\t  // parser from the callback\u2014that will corrupt its internal state.\n\t  onComment: null,\n\t  // Nodes have their start and end characters offsets recorded in\n\t  // `start` and `end` properties (directly on the node, rather than\n\t  // the `loc` object, which holds line/column data. To also add a\n\t  // [semi-standardized][range] `range` property holding a `[start,\n\t  // end]` array with the same numbers, set the `ranges` option to\n\t  // `true`.\n\t  //\n\t  // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678\n\t  ranges: false,\n\t  // It is possible to parse multiple files into a single AST by\n\t  // passing the tree produced by parsing the first file as\n\t  // `program` option in subsequent parses. This will add the\n\t  // toplevel forms of the parsed file to the `Program` (top) node\n\t  // of an existing parse tree.\n\t  program: null,\n\t  // When `locations` is on, you can pass this to record the source\n\t  // file in every node's `loc` object.\n\t  sourceFile: null,\n\t  // This value, if given, is stored in every node, whether\n\t  // `locations` is on or off.\n\t  directSourceFile: null,\n\t  // When enabled, parenthesized expressions are represented by\n\t  // (non-standard) ParenthesizedExpression nodes\n\t  preserveParens: false\n\t};\n\n\t// Interpret and default an options object\n\n\tfunction getOptions(opts) {\n\t  var options = {};\n\n\t  for (var opt in defaultOptions)\n\t    { options[opt] = opts && has(opts, opt) ? opts[opt] : defaultOptions[opt]; }\n\n\t  if (options.ecmaVersion >= 2015)\n\t    { options.ecmaVersion -= 2009; }\n\n\t  if (options.allowReserved == null)\n\t    { options.allowReserved = options.ecmaVersion < 5; }\n\n\t  if (isArray(options.onToken)) {\n\t    var tokens = options.onToken;\n\t    options.onToken = function (token) { return tokens.push(token); };\n\t  }\n\t  if (isArray(options.onComment))\n\t    { options.onComment = pushComment(options, options.onComment); }\n\n\t  return options\n\t}\n\n\tfunction pushComment(options, array) {\n\t  return function(block, text, start, end, startLoc, endLoc) {\n\t    var comment = {\n\t      type: block ? \"Block\" : \"Line\",\n\t      value: text,\n\t      start: start,\n\t      end: end\n\t    };\n\t    if (options.locations)\n\t      { comment.loc = new SourceLocation(this, startLoc, endLoc); }\n\t    if (options.ranges)\n\t      { comment.range = [start, end]; }\n\t    array.push(comment);\n\t  }\n\t}\n\n\t// Each scope gets a bitset that may contain these flags\n\tvar\n\t    SCOPE_TOP = 1,\n\t    SCOPE_FUNCTION = 2,\n\t    SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION,\n\t    SCOPE_ASYNC = 4,\n\t    SCOPE_GENERATOR = 8,\n\t    SCOPE_ARROW = 16,\n\t    SCOPE_SIMPLE_CATCH = 32,\n\t    SCOPE_SUPER = 64,\n\t    SCOPE_DIRECT_SUPER = 128;\n\n\tfunction functionFlags(async, generator) {\n\t  return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0)\n\t}\n\n\t// Used in checkLVal and declareName to determine the type of a binding\n\tvar\n\t    BIND_NONE = 0, // Not a binding\n\t    BIND_VAR = 1, // Var-style binding\n\t    BIND_LEXICAL = 2, // Let- or const-style binding\n\t    BIND_FUNCTION = 3, // Function declaration\n\t    BIND_SIMPLE_CATCH = 4, // Simple (identifier pattern) catch binding\n\t    BIND_OUTSIDE = 5; // Special case for function names as bound inside the function\n\n\tvar Parser = function Parser(options, input, startPos) {\n\t  this.options = options = getOptions(options);\n\t  this.sourceFile = options.sourceFile;\n\t  this.keywords = wordsRegexp(keywords[options.ecmaVersion >= 6 ? 6 : options.sourceType === \"module\" ? \"5module\" : 5]);\n\t  var reserved = \"\";\n\t  if (options.allowReserved !== true) {\n\t    for (var v = options.ecmaVersion;; v--)\n\t      { if (reserved = reservedWords[v]) { break } }\n\t    if (options.sourceType === \"module\") { reserved += \" await\"; }\n\t  }\n\t  this.reservedWords = wordsRegexp(reserved);\n\t  var reservedStrict = (reserved ? reserved + \" \" : \"\") + reservedWords.strict;\n\t  this.reservedWordsStrict = wordsRegexp(reservedStrict);\n\t  this.reservedWordsStrictBind = wordsRegexp(reservedStrict + \" \" + reservedWords.strictBind);\n\t  this.input = String(input);\n\n\t  // Used to signal to callers of `readWord1` whether the word\n\t  // contained any escape sequences. This is needed because words with\n\t  // escape sequences must not be interpreted as keywords.\n\t  this.containsEsc = false;\n\n\t  // Set up token state\n\n\t  // The current position of the tokenizer in the input.\n\t  if (startPos) {\n\t    this.pos = startPos;\n\t    this.lineStart = this.input.lastIndexOf(\"\\n\", startPos - 1) + 1;\n\t    this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;\n\t  } else {\n\t    this.pos = this.lineStart = 0;\n\t    this.curLine = 1;\n\t  }\n\n\t  // Properties of the current token:\n\t  // Its type\n\t  this.type = types.eof;\n\t  // For tokens that include more information than their type, the value\n\t  this.value = null;\n\t  // Its start and end offset\n\t  this.start = this.end = this.pos;\n\t  // And, if locations are used, the {line, column} object\n\t  // corresponding to those offsets\n\t  this.startLoc = this.endLoc = this.curPosition();\n\n\t  // Position information for the previous token\n\t  this.lastTokEndLoc = this.lastTokStartLoc = null;\n\t  this.lastTokStart = this.lastTokEnd = this.pos;\n\n\t  // The context stack is used to superficially track syntactic\n\t  // context to predict whether a regular expression is allowed in a\n\t  // given position.\n\t  this.context = this.initialContext();\n\t  this.exprAllowed = true;\n\n\t  // Figure out if it's a module code.\n\t  this.inModule = options.sourceType === \"module\";\n\t  this.strict = this.inModule || this.strictDirective(this.pos);\n\n\t  // Used to signify the start of a potential arrow function\n\t  this.potentialArrowAt = -1;\n\n\t  // Positions to delayed-check that yield/await does not exist in default parameters.\n\t  this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;\n\t  // Labels in scope.\n\t  this.labels = [];\n\t  // Thus-far undefined exports.\n\t  this.undefinedExports = {};\n\n\t  // If enabled, skip leading hashbang line.\n\t  if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === \"#!\")\n\t    { this.skipLineComment(2); }\n\n\t  // Scope tracking for duplicate variable names (see scope.js)\n\t  this.scopeStack = [];\n\t  this.enterScope(SCOPE_TOP);\n\n\t  // For RegExp validation\n\t  this.regexpState = null;\n\t};\n\n\tvar prototypeAccessors = { inFunction: { configurable: true },inGenerator: { configurable: true },inAsync: { configurable: true },allowSuper: { configurable: true },allowDirectSuper: { configurable: true },treatFunctionsAsVar: { configurable: true } };\n\n\tParser.prototype.parse = function parse () {\n\t  var node = this.options.program || this.startNode();\n\t  this.nextToken();\n\t  return this.parseTopLevel(node)\n\t};\n\n\tprototypeAccessors.inFunction.get = function () { return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0 };\n\tprototypeAccessors.inGenerator.get = function () { return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0 };\n\tprototypeAccessors.inAsync.get = function () { return (this.currentVarScope().flags & SCOPE_ASYNC) > 0 };\n\tprototypeAccessors.allowSuper.get = function () { return (this.currentThisScope().flags & SCOPE_SUPER) > 0 };\n\tprototypeAccessors.allowDirectSuper.get = function () { return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0 };\n\tprototypeAccessors.treatFunctionsAsVar.get = function () { return this.treatFunctionsAsVarInScope(this.currentScope()) };\n\n\t// Switch to a getter for 7.0.0.\n\tParser.prototype.inNonArrowFunction = function inNonArrowFunction () { return (this.currentThisScope().flags & SCOPE_FUNCTION) > 0 };\n\n\tParser.extend = function extend () {\n\t    var plugins = [], len = arguments.length;\n\t    while ( len-- ) plugins[ len ] = arguments[ len ];\n\n\t  var cls = this;\n\t  for (var i = 0; i < plugins.length; i++) { cls = plugins[i](cls); }\n\t  return cls\n\t};\n\n\tParser.parse = function parse (input, options) {\n\t  return new this(options, input).parse()\n\t};\n\n\tParser.parseExpressionAt = function parseExpressionAt (input, pos, options) {\n\t  var parser = new this(options, input, pos);\n\t  parser.nextToken();\n\t  return parser.parseExpression()\n\t};\n\n\tParser.tokenizer = function tokenizer (input, options) {\n\t  return new this(options, input)\n\t};\n\n\tObject.defineProperties( Parser.prototype, prototypeAccessors );\n\n\tvar pp = Parser.prototype;\n\n\t// ## Parser utilities\n\n\tvar literal = /^(?:'((?:\\\\.|[^'])*?)'|\"((?:\\\\.|[^\"])*?)\")/;\n\tpp.strictDirective = function(start) {\n\t  for (;;) {\n\t    // Try to find string literal.\n\t    skipWhiteSpace.lastIndex = start;\n\t    start += skipWhiteSpace.exec(this.input)[0].length;\n\t    var match = literal.exec(this.input.slice(start));\n\t    if (!match) { return false }\n\t    if ((match[1] || match[2]) === \"use strict\") {\n\t      skipWhiteSpace.lastIndex = start + match[0].length;\n\t      var spaceAfter = skipWhiteSpace.exec(this.input), end = spaceAfter.index + spaceAfter[0].length;\n\t      var next = this.input.charAt(end);\n\t      return next === \";\" || next === \"}\" ||\n\t        (lineBreak.test(spaceAfter[0]) &&\n\t         !(/[(`.[+\\-/*%<>=,?^&]/.test(next) || next === \"!\" && this.input.charAt(end + 1) === \"=\"))\n\t    }\n\t    start += match[0].length;\n\n\t    // Skip semicolon, if any.\n\t    skipWhiteSpace.lastIndex = start;\n\t    start += skipWhiteSpace.exec(this.input)[0].length;\n\t    if (this.input[start] === \";\")\n\t      { start++; }\n\t  }\n\t};\n\n\t// Predicate that tests whether the next token is of the given\n\t// type, and if yes, consumes it as a side effect.\n\n\tpp.eat = function(type) {\n\t  if (this.type === type) {\n\t    this.next();\n\t    return true\n\t  } else {\n\t    return false\n\t  }\n\t};\n\n\t// Tests whether parsed token is a contextual keyword.\n\n\tpp.isContextual = function(name) {\n\t  return this.type === types.name && this.value === name && !this.containsEsc\n\t};\n\n\t// Consumes contextual keyword if possible.\n\n\tpp.eatContextual = function(name) {\n\t  if (!this.isContextual(name)) { return false }\n\t  this.next();\n\t  return true\n\t};\n\n\t// Asserts that following token is given contextual keyword.\n\n\tpp.expectContextual = function(name) {\n\t  if (!this.eatContextual(name)) { this.unexpected(); }\n\t};\n\n\t// Test whether a semicolon can be inserted at the current position.\n\n\tpp.canInsertSemicolon = function() {\n\t  return this.type === types.eof ||\n\t    this.type === types.braceR ||\n\t    lineBreak.test(this.input.slice(this.lastTokEnd, this.start))\n\t};\n\n\tpp.insertSemicolon = function() {\n\t  if (this.canInsertSemicolon()) {\n\t    if (this.options.onInsertedSemicolon)\n\t      { this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc); }\n\t    return true\n\t  }\n\t};\n\n\t// Consume a semicolon, or, failing that, see if we are allowed to\n\t// pretend that there is a semicolon at this position.\n\n\tpp.semicolon = function() {\n\t  if (!this.eat(types.semi) && !this.insertSemicolon()) { this.unexpected(); }\n\t};\n\n\tpp.afterTrailingComma = function(tokType, notNext) {\n\t  if (this.type === tokType) {\n\t    if (this.options.onTrailingComma)\n\t      { this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc); }\n\t    if (!notNext)\n\t      { this.next(); }\n\t    return true\n\t  }\n\t};\n\n\t// Expect a token of a given type. If found, consume it, otherwise,\n\t// raise an unexpected token error.\n\n\tpp.expect = function(type) {\n\t  this.eat(type) || this.unexpected();\n\t};\n\n\t// Raise an unexpected token error.\n\n\tpp.unexpected = function(pos) {\n\t  this.raise(pos != null ? pos : this.start, \"Unexpected token\");\n\t};\n\n\tfunction DestructuringErrors() {\n\t  this.shorthandAssign =\n\t  this.trailingComma =\n\t  this.parenthesizedAssign =\n\t  this.parenthesizedBind =\n\t  this.doubleProto =\n\t    -1;\n\t}\n\n\tpp.checkPatternErrors = function(refDestructuringErrors, isAssign) {\n\t  if (!refDestructuringErrors) { return }\n\t  if (refDestructuringErrors.trailingComma > -1)\n\t    { this.raiseRecoverable(refDestructuringErrors.trailingComma, \"Comma is not permitted after the rest element\"); }\n\t  var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;\n\t  if (parens > -1) { this.raiseRecoverable(parens, \"Parenthesized pattern\"); }\n\t};\n\n\tpp.checkExpressionErrors = function(refDestructuringErrors, andThrow) {\n\t  if (!refDestructuringErrors) { return false }\n\t  var shorthandAssign = refDestructuringErrors.shorthandAssign;\n\t  var doubleProto = refDestructuringErrors.doubleProto;\n\t  if (!andThrow) { return shorthandAssign >= 0 || doubleProto >= 0 }\n\t  if (shorthandAssign >= 0)\n\t    { this.raise(shorthandAssign, \"Shorthand property assignments are valid only in destructuring patterns\"); }\n\t  if (doubleProto >= 0)\n\t    { this.raiseRecoverable(doubleProto, \"Redefinition of __proto__ property\"); }\n\t};\n\n\tpp.checkYieldAwaitInDefaultParams = function() {\n\t  if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos))\n\t    { this.raise(this.yieldPos, \"Yield expression cannot be a default value\"); }\n\t  if (this.awaitPos)\n\t    { this.raise(this.awaitPos, \"Await expression cannot be a default value\"); }\n\t};\n\n\tpp.isSimpleAssignTarget = function(expr) {\n\t  if (expr.type === \"ParenthesizedExpression\")\n\t    { return this.isSimpleAssignTarget(expr.expression) }\n\t  return expr.type === \"Identifier\" || expr.type === \"MemberExpression\"\n\t};\n\n\tvar pp$1 = Parser.prototype;\n\n\t// ### Statement parsing\n\n\t// Parse a program. Initializes the parser, reads any number of\n\t// statements, and wraps them in a Program node.  Optionally takes a\n\t// `program` argument.  If present, the statements will be appended\n\t// to its body instead of creating a new node.\n\n\tpp$1.parseTopLevel = function(node) {\n\t  var exports = {};\n\t  if (!node.body) { node.body = []; }\n\t  while (this.type !== types.eof) {\n\t    var stmt = this.parseStatement(null, true, exports);\n\t    node.body.push(stmt);\n\t  }\n\t  if (this.inModule)\n\t    { for (var i = 0, list = Object.keys(this.undefinedExports); i < list.length; i += 1)\n\t      {\n\t        var name = list[i];\n\n\t        this.raiseRecoverable(this.undefinedExports[name].start, (\"Export '\" + name + \"' is not defined\"));\n\t      } }\n\t  this.adaptDirectivePrologue(node.body);\n\t  this.next();\n\t  node.sourceType = this.options.sourceType;\n\t  return this.finishNode(node, \"Program\")\n\t};\n\n\tvar loopLabel = {kind: \"loop\"}, switchLabel = {kind: \"switch\"};\n\n\tpp$1.isLet = function(context) {\n\t  if (this.options.ecmaVersion < 6 || !this.isContextual(\"let\")) { return false }\n\t  skipWhiteSpace.lastIndex = this.pos;\n\t  var skip = skipWhiteSpace.exec(this.input);\n\t  var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);\n\t  // For ambiguous cases, determine if a LexicalDeclaration (or only a\n\t  // Statement) is allowed here. If context is not empty then only a Statement\n\t  // is allowed. However, `let [` is an explicit negative lookahead for\n\t  // ExpressionStatement, so special-case it first.\n\t  if (nextCh === 91) { return true } // '['\n\t  if (context) { return false }\n\n\t  if (nextCh === 123) { return true } // '{'\n\t  if (isIdentifierStart(nextCh, true)) {\n\t    var pos = next + 1;\n\t    while (isIdentifierChar(this.input.charCodeAt(pos), true)) { ++pos; }\n\t    var ident = this.input.slice(next, pos);\n\t    if (!keywordRelationalOperator.test(ident)) { return true }\n\t  }\n\t  return false\n\t};\n\n\t// check 'async [no LineTerminator here] function'\n\t// - 'async /*foo*/ function' is OK.\n\t// - 'async /*\\n*/ function' is invalid.\n\tpp$1.isAsyncFunction = function() {\n\t  if (this.options.ecmaVersion < 8 || !this.isContextual(\"async\"))\n\t    { return false }\n\n\t  skipWhiteSpace.lastIndex = this.pos;\n\t  var skip = skipWhiteSpace.exec(this.input);\n\t  var next = this.pos + skip[0].length;\n\t  return !lineBreak.test(this.input.slice(this.pos, next)) &&\n\t    this.input.slice(next, next + 8) === \"function\" &&\n\t    (next + 8 === this.input.length || !isIdentifierChar(this.input.charAt(next + 8)))\n\t};\n\n\t// Parse a single statement.\n\t//\n\t// If expecting a statement and finding a slash operator, parse a\n\t// regular expression literal. This is to handle cases like\n\t// `if (foo) /blah/.exec(foo)`, where looking at the previous token\n\t// does not help.\n\n\tpp$1.parseStatement = function(context, topLevel, exports) {\n\t  var starttype = this.type, node = this.startNode(), kind;\n\n\t  if (this.isLet(context)) {\n\t    starttype = types._var;\n\t    kind = \"let\";\n\t  }\n\n\t  // Most types of statements are recognized by the keyword they\n\t  // start with. Many are trivial to parse, some require a bit of\n\t  // complexity.\n\n\t  switch (starttype) {\n\t  case types._break: case types._continue: return this.parseBreakContinueStatement(node, starttype.keyword)\n\t  case types._debugger: return this.parseDebuggerStatement(node)\n\t  case types._do: return this.parseDoStatement(node)\n\t  case types._for: return this.parseForStatement(node)\n\t  case types._function:\n\t    // Function as sole body of either an if statement or a labeled statement\n\t    // works, but not when it is part of a labeled statement that is the sole\n\t    // body of an if statement.\n\t    if ((context && (this.strict || context !== \"if\" && context !== \"label\")) && this.options.ecmaVersion >= 6) { this.unexpected(); }\n\t    return this.parseFunctionStatement(node, false, !context)\n\t  case types._class:\n\t    if (context) { this.unexpected(); }\n\t    return this.parseClass(node, true)\n\t  case types._if: return this.parseIfStatement(node)\n\t  case types._return: return this.parseReturnStatement(node)\n\t  case types._switch: return this.parseSwitchStatement(node)\n\t  case types._throw: return this.parseThrowStatement(node)\n\t  case types._try: return this.parseTryStatement(node)\n\t  case types._const: case types._var:\n\t    kind = kind || this.value;\n\t    if (context && kind !== \"var\") { this.unexpected(); }\n\t    return this.parseVarStatement(node, kind)\n\t  case types._while: return this.parseWhileStatement(node)\n\t  case types._with: return this.parseWithStatement(node)\n\t  case types.braceL: return this.parseBlock(true, node)\n\t  case types.semi: return this.parseEmptyStatement(node)\n\t  case types._export:\n\t  case types._import:\n\t    if (this.options.ecmaVersion > 10 && starttype === types._import) {\n\t      skipWhiteSpace.lastIndex = this.pos;\n\t      var skip = skipWhiteSpace.exec(this.input);\n\t      var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);\n\t      if (nextCh === 40 || nextCh === 46) // '(' or '.'\n\t        { return this.parseExpressionStatement(node, this.parseExpression()) }\n\t    }\n\n\t    if (!this.options.allowImportExportEverywhere) {\n\t      if (!topLevel)\n\t        { this.raise(this.start, \"'import' and 'export' may only appear at the top level\"); }\n\t      if (!this.inModule)\n\t        { this.raise(this.start, \"'import' and 'export' may appear only with 'sourceType: module'\"); }\n\t    }\n\t    return starttype === types._import ? this.parseImport(node) : this.parseExport(node, exports)\n\n\t    // If the statement does not start with a statement keyword or a\n\t    // brace, it's an ExpressionStatement or LabeledStatement. We\n\t    // simply start parsing an expression, and afterwards, if the\n\t    // next token is a colon and the expression was a simple\n\t    // Identifier node, we switch to interpreting it as a label.\n\t  default:\n\t    if (this.isAsyncFunction()) {\n\t      if (context) { this.unexpected(); }\n\t      this.next();\n\t      return this.parseFunctionStatement(node, true, !context)\n\t    }\n\n\t    var maybeName = this.value, expr = this.parseExpression();\n\t    if (starttype === types.name && expr.type === \"Identifier\" && this.eat(types.colon))\n\t      { return this.parseLabeledStatement(node, maybeName, expr, context) }\n\t    else { return this.parseExpressionStatement(node, expr) }\n\t  }\n\t};\n\n\tpp$1.parseBreakContinueStatement = function(node, keyword) {\n\t  var isBreak = keyword === \"break\";\n\t  this.next();\n\t  if (this.eat(types.semi) || this.insertSemicolon()) { node.label = null; }\n\t  else if (this.type !== types.name) { this.unexpected(); }\n\t  else {\n\t    node.label = this.parseIdent();\n\t    this.semicolon();\n\t  }\n\n\t  // Verify that there is an actual destination to break or\n\t  // continue to.\n\t  var i = 0;\n\t  for (; i < this.labels.length; ++i) {\n\t    var lab = this.labels[i];\n\t    if (node.label == null || lab.name === node.label.name) {\n\t      if (lab.kind != null && (isBreak || lab.kind === \"loop\")) { break }\n\t      if (node.label && isBreak) { break }\n\t    }\n\t  }\n\t  if (i === this.labels.length) { this.raise(node.start, \"Unsyntactic \" + keyword); }\n\t  return this.finishNode(node, isBreak ? \"BreakStatement\" : \"ContinueStatement\")\n\t};\n\n\tpp$1.parseDebuggerStatement = function(node) {\n\t  this.next();\n\t  this.semicolon();\n\t  return this.finishNode(node, \"DebuggerStatement\")\n\t};\n\n\tpp$1.parseDoStatement = function(node) {\n\t  this.next();\n\t  this.labels.push(loopLabel);\n\t  node.body = this.parseStatement(\"do\");\n\t  this.labels.pop();\n\t  this.expect(types._while);\n\t  node.test = this.parseParenExpression();\n\t  if (this.options.ecmaVersion >= 6)\n\t    { this.eat(types.semi); }\n\t  else\n\t    { this.semicolon(); }\n\t  return this.finishNode(node, \"DoWhileStatement\")\n\t};\n\n\t// Disambiguating between a `for` and a `for`/`in` or `for`/`of`\n\t// loop is non-trivial. Basically, we have to parse the init `var`\n\t// statement or expression, disallowing the `in` operator (see\n\t// the second parameter to `parseExpression`), and then check\n\t// whether the next token is `in` or `of`. When there is no init\n\t// part (semicolon immediately after the opening parenthesis), it\n\t// is a regular `for` loop.\n\n\tpp$1.parseForStatement = function(node) {\n\t  this.next();\n\t  var awaitAt = (this.options.ecmaVersion >= 9 && (this.inAsync || (!this.inFunction && this.options.allowAwaitOutsideFunction)) && this.eatContextual(\"await\")) ? this.lastTokStart : -1;\n\t  this.labels.push(loopLabel);\n\t  this.enterScope(0);\n\t  this.expect(types.parenL);\n\t  if (this.type === types.semi) {\n\t    if (awaitAt > -1) { this.unexpected(awaitAt); }\n\t    return this.parseFor(node, null)\n\t  }\n\t  var isLet = this.isLet();\n\t  if (this.type === types._var || this.type === types._const || isLet) {\n\t    var init$1 = this.startNode(), kind = isLet ? \"let\" : this.value;\n\t    this.next();\n\t    this.parseVar(init$1, true, kind);\n\t    this.finishNode(init$1, \"VariableDeclaration\");\n\t    if ((this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual(\"of\"))) && init$1.declarations.length === 1) {\n\t      if (this.options.ecmaVersion >= 9) {\n\t        if (this.type === types._in) {\n\t          if (awaitAt > -1) { this.unexpected(awaitAt); }\n\t        } else { node.await = awaitAt > -1; }\n\t      }\n\t      return this.parseForIn(node, init$1)\n\t    }\n\t    if (awaitAt > -1) { this.unexpected(awaitAt); }\n\t    return this.parseFor(node, init$1)\n\t  }\n\t  var refDestructuringErrors = new DestructuringErrors;\n\t  var init = this.parseExpression(true, refDestructuringErrors);\n\t  if (this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual(\"of\"))) {\n\t    if (this.options.ecmaVersion >= 9) {\n\t      if (this.type === types._in) {\n\t        if (awaitAt > -1) { this.unexpected(awaitAt); }\n\t      } else { node.await = awaitAt > -1; }\n\t    }\n\t    this.toAssignable(init, false, refDestructuringErrors);\n\t    this.checkLVal(init);\n\t    return this.parseForIn(node, init)\n\t  } else {\n\t    this.checkExpressionErrors(refDestructuringErrors, true);\n\t  }\n\t  if (awaitAt > -1) { this.unexpected(awaitAt); }\n\t  return this.parseFor(node, init)\n\t};\n\n\tpp$1.parseFunctionStatement = function(node, isAsync, declarationPosition) {\n\t  this.next();\n\t  return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync)\n\t};\n\n\tpp$1.parseIfStatement = function(node) {\n\t  this.next();\n\t  node.test = this.parseParenExpression();\n\t  // allow function declarations in branches, but only in non-strict mode\n\t  node.consequent = this.parseStatement(\"if\");\n\t  node.alternate = this.eat(types._else) ? this.parseStatement(\"if\") : null;\n\t  return this.finishNode(node, \"IfStatement\")\n\t};\n\n\tpp$1.parseReturnStatement = function(node) {\n\t  if (!this.inFunction && !this.options.allowReturnOutsideFunction)\n\t    { this.raise(this.start, \"'return' outside of function\"); }\n\t  this.next();\n\n\t  // In `return` (and `break`/`continue`), the keywords with\n\t  // optional arguments, we eagerly look for a semicolon or the\n\t  // possibility to insert one.\n\n\t  if (this.eat(types.semi) || this.insertSemicolon()) { node.argument = null; }\n\t  else { node.argument = this.parseExpression(); this.semicolon(); }\n\t  return this.finishNode(node, \"ReturnStatement\")\n\t};\n\n\tpp$1.parseSwitchStatement = function(node) {\n\t  this.next();\n\t  node.discriminant = this.parseParenExpression();\n\t  node.cases = [];\n\t  this.expect(types.braceL);\n\t  this.labels.push(switchLabel);\n\t  this.enterScope(0);\n\n\t  // Statements under must be grouped (by label) in SwitchCase\n\t  // nodes. `cur` is used to keep the node that we are currently\n\t  // adding statements to.\n\n\t  var cur;\n\t  for (var sawDefault = false; this.type !== types.braceR;) {\n\t    if (this.type === types._case || this.type === types._default) {\n\t      var isCase = this.type === types._case;\n\t      if (cur) { this.finishNode(cur, \"SwitchCase\"); }\n\t      node.cases.push(cur = this.startNode());\n\t      cur.consequent = [];\n\t      this.next();\n\t      if (isCase) {\n\t        cur.test = this.parseExpression();\n\t      } else {\n\t        if (sawDefault) { this.raiseRecoverable(this.lastTokStart, \"Multiple default clauses\"); }\n\t        sawDefault = true;\n\t        cur.test = null;\n\t      }\n\t      this.expect(types.colon);\n\t    } else {\n\t      if (!cur) { this.unexpected(); }\n\t      cur.consequent.push(this.parseStatement(null));\n\t    }\n\t  }\n\t  this.exitScope();\n\t  if (cur) { this.finishNode(cur, \"SwitchCase\"); }\n\t  this.next(); // Closing brace\n\t  this.labels.pop();\n\t  return this.finishNode(node, \"SwitchStatement\")\n\t};\n\n\tpp$1.parseThrowStatement = function(node) {\n\t  this.next();\n\t  if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start)))\n\t    { this.raise(this.lastTokEnd, \"Illegal newline after throw\"); }\n\t  node.argument = this.parseExpression();\n\t  this.semicolon();\n\t  return this.finishNode(node, \"ThrowStatement\")\n\t};\n\n\t// Reused empty array added for node fields that are always empty.\n\n\tvar empty = [];\n\n\tpp$1.parseTryStatement = function(node) {\n\t  this.next();\n\t  node.block = this.parseBlock();\n\t  node.handler = null;\n\t  if (this.type === types._catch) {\n\t    var clause = this.startNode();\n\t    this.next();\n\t    if (this.eat(types.parenL)) {\n\t      clause.param = this.parseBindingAtom();\n\t      var simple = clause.param.type === \"Identifier\";\n\t      this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);\n\t      this.checkLVal(clause.param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);\n\t      this.expect(types.parenR);\n\t    } else {\n\t      if (this.options.ecmaVersion < 10) { this.unexpected(); }\n\t      clause.param = null;\n\t      this.enterScope(0);\n\t    }\n\t    clause.body = this.parseBlock(false);\n\t    this.exitScope();\n\t    node.handler = this.finishNode(clause, \"CatchClause\");\n\t  }\n\t  node.finalizer = this.eat(types._finally) ? this.parseBlock() : null;\n\t  if (!node.handler && !node.finalizer)\n\t    { this.raise(node.start, \"Missing catch or finally clause\"); }\n\t  return this.finishNode(node, \"TryStatement\")\n\t};\n\n\tpp$1.parseVarStatement = function(node, kind) {\n\t  this.next();\n\t  this.parseVar(node, false, kind);\n\t  this.semicolon();\n\t  return this.finishNode(node, \"VariableDeclaration\")\n\t};\n\n\tpp$1.parseWhileStatement = function(node) {\n\t  this.next();\n\t  node.test = this.parseParenExpression();\n\t  this.labels.push(loopLabel);\n\t  node.body = this.parseStatement(\"while\");\n\t  this.labels.pop();\n\t  return this.finishNode(node, \"WhileStatement\")\n\t};\n\n\tpp$1.parseWithStatement = function(node) {\n\t  if (this.strict) { this.raise(this.start, \"'with' in strict mode\"); }\n\t  this.next();\n\t  node.object = this.parseParenExpression();\n\t  node.body = this.parseStatement(\"with\");\n\t  return this.finishNode(node, \"WithStatement\")\n\t};\n\n\tpp$1.parseEmptyStatement = function(node) {\n\t  this.next();\n\t  return this.finishNode(node, \"EmptyStatement\")\n\t};\n\n\tpp$1.parseLabeledStatement = function(node, maybeName, expr, context) {\n\t  for (var i$1 = 0, list = this.labels; i$1 < list.length; i$1 += 1)\n\t    {\n\t    var label = list[i$1];\n\n\t    if (label.name === maybeName)\n\t      { this.raise(expr.start, \"Label '\" + maybeName + \"' is already declared\");\n\t  } }\n\t  var kind = this.type.isLoop ? \"loop\" : this.type === types._switch ? \"switch\" : null;\n\t  for (var i = this.labels.length - 1; i >= 0; i--) {\n\t    var label$1 = this.labels[i];\n\t    if (label$1.statementStart === node.start) {\n\t      // Update information about previous labels on this node\n\t      label$1.statementStart = this.start;\n\t      label$1.kind = kind;\n\t    } else { break }\n\t  }\n\t  this.labels.push({name: maybeName, kind: kind, statementStart: this.start});\n\t  node.body = this.parseStatement(context ? context.indexOf(\"label\") === -1 ? context + \"label\" : context : \"label\");\n\t  this.labels.pop();\n\t  node.label = expr;\n\t  return this.finishNode(node, \"LabeledStatement\")\n\t};\n\n\tpp$1.parseExpressionStatement = function(node, expr) {\n\t  node.expression = expr;\n\t  this.semicolon();\n\t  return this.finishNode(node, \"ExpressionStatement\")\n\t};\n\n\t// Parse a semicolon-enclosed block of statements, handling `\"use\n\t// strict\"` declarations when `allowStrict` is true (used for\n\t// function bodies).\n\n\tpp$1.parseBlock = function(createNewLexicalScope, node, exitStrict) {\n\t  if ( createNewLexicalScope === void 0 ) createNewLexicalScope = true;\n\t  if ( node === void 0 ) node = this.startNode();\n\n\t  node.body = [];\n\t  this.expect(types.braceL);\n\t  if (createNewLexicalScope) { this.enterScope(0); }\n\t  while (this.type !== types.braceR) {\n\t    var stmt = this.parseStatement(null);\n\t    node.body.push(stmt);\n\t  }\n\t  if (exitStrict) { this.strict = false; }\n\t  this.next();\n\t  if (createNewLexicalScope) { this.exitScope(); }\n\t  return this.finishNode(node, \"BlockStatement\")\n\t};\n\n\t// Parse a regular `for` loop. The disambiguation code in\n\t// `parseStatement` will already have parsed the init statement or\n\t// expression.\n\n\tpp$1.parseFor = function(node, init) {\n\t  node.init = init;\n\t  this.expect(types.semi);\n\t  node.test = this.type === types.semi ? null : this.parseExpression();\n\t  this.expect(types.semi);\n\t  node.update = this.type === types.parenR ? null : this.parseExpression();\n\t  this.expect(types.parenR);\n\t  node.body = this.parseStatement(\"for\");\n\t  this.exitScope();\n\t  this.labels.pop();\n\t  return this.finishNode(node, \"ForStatement\")\n\t};\n\n\t// Parse a `for`/`in` and `for`/`of` loop, which are almost\n\t// same from parser's perspective.\n\n\tpp$1.parseForIn = function(node, init) {\n\t  var isForIn = this.type === types._in;\n\t  this.next();\n\n\t  if (\n\t    init.type === \"VariableDeclaration\" &&\n\t    init.declarations[0].init != null &&\n\t    (\n\t      !isForIn ||\n\t      this.options.ecmaVersion < 8 ||\n\t      this.strict ||\n\t      init.kind !== \"var\" ||\n\t      init.declarations[0].id.type !== \"Identifier\"\n\t    )\n\t  ) {\n\t    this.raise(\n\t      init.start,\n\t      ((isForIn ? \"for-in\" : \"for-of\") + \" loop variable declaration may not have an initializer\")\n\t    );\n\t  } else if (init.type === \"AssignmentPattern\") {\n\t    this.raise(init.start, \"Invalid left-hand side in for-loop\");\n\t  }\n\t  node.left = init;\n\t  node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();\n\t  this.expect(types.parenR);\n\t  node.body = this.parseStatement(\"for\");\n\t  this.exitScope();\n\t  this.labels.pop();\n\t  return this.finishNode(node, isForIn ? \"ForInStatement\" : \"ForOfStatement\")\n\t};\n\n\t// Parse a list of variable declarations.\n\n\tpp$1.parseVar = function(node, isFor, kind) {\n\t  node.declarations = [];\n\t  node.kind = kind;\n\t  for (;;) {\n\t    var decl = this.startNode();\n\t    this.parseVarId(decl, kind);\n\t    if (this.eat(types.eq)) {\n\t      decl.init = this.parseMaybeAssign(isFor);\n\t    } else if (kind === \"const\" && !(this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual(\"of\")))) {\n\t      this.unexpected();\n\t    } else if (decl.id.type !== \"Identifier\" && !(isFor && (this.type === types._in || this.isContextual(\"of\")))) {\n\t      this.raise(this.lastTokEnd, \"Complex binding patterns require an initialization value\");\n\t    } else {\n\t      decl.init = null;\n\t    }\n\t    node.declarations.push(this.finishNode(decl, \"VariableDeclarator\"));\n\t    if (!this.eat(types.comma)) { break }\n\t  }\n\t  return node\n\t};\n\n\tpp$1.parseVarId = function(decl, kind) {\n\t  decl.id = this.parseBindingAtom();\n\t  this.checkLVal(decl.id, kind === \"var\" ? BIND_VAR : BIND_LEXICAL, false);\n\t};\n\n\tvar FUNC_STATEMENT = 1, FUNC_HANGING_STATEMENT = 2, FUNC_NULLABLE_ID = 4;\n\n\t// Parse a function declaration or literal (depending on the\n\t// `statement & FUNC_STATEMENT`).\n\n\t// Remove `allowExpressionBody` for 7.0.0, as it is only called with false\n\tpp$1.parseFunction = function(node, statement, allowExpressionBody, isAsync) {\n\t  this.initFunction(node);\n\t  if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {\n\t    if (this.type === types.star && (statement & FUNC_HANGING_STATEMENT))\n\t      { this.unexpected(); }\n\t    node.generator = this.eat(types.star);\n\t  }\n\t  if (this.options.ecmaVersion >= 8)\n\t    { node.async = !!isAsync; }\n\n\t  if (statement & FUNC_STATEMENT) {\n\t    node.id = (statement & FUNC_NULLABLE_ID) && this.type !== types.name ? null : this.parseIdent();\n\t    if (node.id && !(statement & FUNC_HANGING_STATEMENT))\n\t      // If it is a regular function declaration in sloppy mode, then it is\n\t      // subject to Annex B semantics (BIND_FUNCTION). Otherwise, the binding\n\t      // mode depends on properties of the current scope (see\n\t      // treatFunctionsAsVar).\n\t      { this.checkLVal(node.id, (this.strict || node.generator || node.async) ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION); }\n\t  }\n\n\t  var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\n\t  this.yieldPos = 0;\n\t  this.awaitPos = 0;\n\t  this.awaitIdentPos = 0;\n\t  this.enterScope(functionFlags(node.async, node.generator));\n\n\t  if (!(statement & FUNC_STATEMENT))\n\t    { node.id = this.type === types.name ? this.parseIdent() : null; }\n\n\t  this.parseFunctionParams(node);\n\t  this.parseFunctionBody(node, allowExpressionBody, false);\n\n\t  this.yieldPos = oldYieldPos;\n\t  this.awaitPos = oldAwaitPos;\n\t  this.awaitIdentPos = oldAwaitIdentPos;\n\t  return this.finishNode(node, (statement & FUNC_STATEMENT) ? \"FunctionDeclaration\" : \"FunctionExpression\")\n\t};\n\n\tpp$1.parseFunctionParams = function(node) {\n\t  this.expect(types.parenL);\n\t  node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);\n\t  this.checkYieldAwaitInDefaultParams();\n\t};\n\n\t// Parse a class declaration or literal (depending on the\n\t// `isStatement` parameter).\n\n\tpp$1.parseClass = function(node, isStatement) {\n\t  this.next();\n\n\t  // ecma-262 14.6 Class Definitions\n\t  // A class definition is always strict mode code.\n\t  var oldStrict = this.strict;\n\t  this.strict = true;\n\n\t  this.parseClassId(node, isStatement);\n\t  this.parseClassSuper(node);\n\t  var classBody = this.startNode();\n\t  var hadConstructor = false;\n\t  classBody.body = [];\n\t  this.expect(types.braceL);\n\t  while (this.type !== types.braceR) {\n\t    var element = this.parseClassElement(node.superClass !== null);\n\t    if (element) {\n\t      classBody.body.push(element);\n\t      if (element.type === \"MethodDefinition\" && element.kind === \"constructor\") {\n\t        if (hadConstructor) { this.raise(element.start, \"Duplicate constructor in the same class\"); }\n\t        hadConstructor = true;\n\t      }\n\t    }\n\t  }\n\t  this.strict = oldStrict;\n\t  this.next();\n\t  node.body = this.finishNode(classBody, \"ClassBody\");\n\t  return this.finishNode(node, isStatement ? \"ClassDeclaration\" : \"ClassExpression\")\n\t};\n\n\tpp$1.parseClassElement = function(constructorAllowsSuper) {\n\t  var this$1 = this;\n\n\t  if (this.eat(types.semi)) { return null }\n\n\t  var method = this.startNode();\n\t  var tryContextual = function (k, noLineBreak) {\n\t    if ( noLineBreak === void 0 ) noLineBreak = false;\n\n\t    var start = this$1.start, startLoc = this$1.startLoc;\n\t    if (!this$1.eatContextual(k)) { return false }\n\t    if (this$1.type !== types.parenL && (!noLineBreak || !this$1.canInsertSemicolon())) { return true }\n\t    if (method.key) { this$1.unexpected(); }\n\t    method.computed = false;\n\t    method.key = this$1.startNodeAt(start, startLoc);\n\t    method.key.name = k;\n\t    this$1.finishNode(method.key, \"Identifier\");\n\t    return false\n\t  };\n\n\t  method.kind = \"method\";\n\t  method.static = tryContextual(\"static\");\n\t  var isGenerator = this.eat(types.star);\n\t  var isAsync = false;\n\t  if (!isGenerator) {\n\t    if (this.options.ecmaVersion >= 8 && tryContextual(\"async\", true)) {\n\t      isAsync = true;\n\t      isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);\n\t    } else if (tryContextual(\"get\")) {\n\t      method.kind = \"get\";\n\t    } else if (tryContextual(\"set\")) {\n\t      method.kind = \"set\";\n\t    }\n\t  }\n\t  if (!method.key) { this.parsePropertyName(method); }\n\t  var key = method.key;\n\t  var allowsDirectSuper = false;\n\t  if (!method.computed && !method.static && (key.type === \"Identifier\" && key.name === \"constructor\" ||\n\t      key.type === \"Literal\" && key.value === \"constructor\")) {\n\t    if (method.kind !== \"method\") { this.raise(key.start, \"Constructor can't have get/set modifier\"); }\n\t    if (isGenerator) { this.raise(key.start, \"Constructor can't be a generator\"); }\n\t    if (isAsync) { this.raise(key.start, \"Constructor can't be an async method\"); }\n\t    method.kind = \"constructor\";\n\t    allowsDirectSuper = constructorAllowsSuper;\n\t  } else if (method.static && key.type === \"Identifier\" && key.name === \"prototype\") {\n\t    this.raise(key.start, \"Classes may not have a static property named prototype\");\n\t  }\n\t  this.parseClassMethod(method, isGenerator, isAsync, allowsDirectSuper);\n\t  if (method.kind === \"get\" && method.value.params.length !== 0)\n\t    { this.raiseRecoverable(method.value.start, \"getter should have no params\"); }\n\t  if (method.kind === \"set\" && method.value.params.length !== 1)\n\t    { this.raiseRecoverable(method.value.start, \"setter should have exactly one param\"); }\n\t  if (method.kind === \"set\" && method.value.params[0].type === \"RestElement\")\n\t    { this.raiseRecoverable(method.value.params[0].start, \"Setter cannot use rest params\"); }\n\t  return method\n\t};\n\n\tpp$1.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {\n\t  method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);\n\t  return this.finishNode(method, \"MethodDefinition\")\n\t};\n\n\tpp$1.parseClassId = function(node, isStatement) {\n\t  if (this.type === types.name) {\n\t    node.id = this.parseIdent();\n\t    if (isStatement)\n\t      { this.checkLVal(node.id, BIND_LEXICAL, false); }\n\t  } else {\n\t    if (isStatement === true)\n\t      { this.unexpected(); }\n\t    node.id = null;\n\t  }\n\t};\n\n\tpp$1.parseClassSuper = function(node) {\n\t  node.superClass = this.eat(types._extends) ? this.parseExprSubscripts() : null;\n\t};\n\n\t// Parses module export declaration.\n\n\tpp$1.parseExport = function(node, exports) {\n\t  this.next();\n\t  // export * from '...'\n\t  if (this.eat(types.star)) {\n\t    if (this.options.ecmaVersion >= 11) {\n\t      if (this.eatContextual(\"as\")) {\n\t        node.exported = this.parseIdent(true);\n\t        this.checkExport(exports, node.exported.name, this.lastTokStart);\n\t      } else {\n\t        node.exported = null;\n\t      }\n\t    }\n\t    this.expectContextual(\"from\");\n\t    if (this.type !== types.string) { this.unexpected(); }\n\t    node.source = this.parseExprAtom();\n\t    this.semicolon();\n\t    return this.finishNode(node, \"ExportAllDeclaration\")\n\t  }\n\t  if (this.eat(types._default)) { // export default ...\n\t    this.checkExport(exports, \"default\", this.lastTokStart);\n\t    var isAsync;\n\t    if (this.type === types._function || (isAsync = this.isAsyncFunction())) {\n\t      var fNode = this.startNode();\n\t      this.next();\n\t      if (isAsync) { this.next(); }\n\t      node.declaration = this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);\n\t    } else if (this.type === types._class) {\n\t      var cNode = this.startNode();\n\t      node.declaration = this.parseClass(cNode, \"nullableID\");\n\t    } else {\n\t      node.declaration = this.parseMaybeAssign();\n\t      this.semicolon();\n\t    }\n\t    return this.finishNode(node, \"ExportDefaultDeclaration\")\n\t  }\n\t  // export var|const|let|function|class ...\n\t  if (this.shouldParseExportStatement()) {\n\t    node.declaration = this.parseStatement(null);\n\t    if (node.declaration.type === \"VariableDeclaration\")\n\t      { this.checkVariableExport(exports, node.declaration.declarations); }\n\t    else\n\t      { this.checkExport(exports, node.declaration.id.name, node.declaration.id.start); }\n\t    node.specifiers = [];\n\t    node.source = null;\n\t  } else { // export { x, y as z } [from '...']\n\t    node.declaration = null;\n\t    node.specifiers = this.parseExportSpecifiers(exports);\n\t    if (this.eatContextual(\"from\")) {\n\t      if (this.type !== types.string) { this.unexpected(); }\n\t      node.source = this.parseExprAtom();\n\t    } else {\n\t      for (var i = 0, list = node.specifiers; i < list.length; i += 1) {\n\t        // check for keywords used as local names\n\t        var spec = list[i];\n\n\t        this.checkUnreserved(spec.local);\n\t        // check if export is defined\n\t        this.checkLocalExport(spec.local);\n\t      }\n\n\t      node.source = null;\n\t    }\n\t    this.semicolon();\n\t  }\n\t  return this.finishNode(node, \"ExportNamedDeclaration\")\n\t};\n\n\tpp$1.checkExport = function(exports, name, pos) {\n\t  if (!exports) { return }\n\t  if (has(exports, name))\n\t    { this.raiseRecoverable(pos, \"Duplicate export '\" + name + \"'\"); }\n\t  exports[name] = true;\n\t};\n\n\tpp$1.checkPatternExport = function(exports, pat) {\n\t  var type = pat.type;\n\t  if (type === \"Identifier\")\n\t    { this.checkExport(exports, pat.name, pat.start); }\n\t  else if (type === \"ObjectPattern\")\n\t    { for (var i = 0, list = pat.properties; i < list.length; i += 1)\n\t      {\n\t        var prop = list[i];\n\n\t        this.checkPatternExport(exports, prop);\n\t      } }\n\t  else if (type === \"ArrayPattern\")\n\t    { for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {\n\t      var elt = list$1[i$1];\n\n\t        if (elt) { this.checkPatternExport(exports, elt); }\n\t    } }\n\t  else if (type === \"Property\")\n\t    { this.checkPatternExport(exports, pat.value); }\n\t  else if (type === \"AssignmentPattern\")\n\t    { this.checkPatternExport(exports, pat.left); }\n\t  else if (type === \"RestElement\")\n\t    { this.checkPatternExport(exports, pat.argument); }\n\t  else if (type === \"ParenthesizedExpression\")\n\t    { this.checkPatternExport(exports, pat.expression); }\n\t};\n\n\tpp$1.checkVariableExport = function(exports, decls) {\n\t  if (!exports) { return }\n\t  for (var i = 0, list = decls; i < list.length; i += 1)\n\t    {\n\t    var decl = list[i];\n\n\t    this.checkPatternExport(exports, decl.id);\n\t  }\n\t};\n\n\tpp$1.shouldParseExportStatement = function() {\n\t  return this.type.keyword === \"var\" ||\n\t    this.type.keyword === \"const\" ||\n\t    this.type.keyword === \"class\" ||\n\t    this.type.keyword === \"function\" ||\n\t    this.isLet() ||\n\t    this.isAsyncFunction()\n\t};\n\n\t// Parses a comma-separated list of module exports.\n\n\tpp$1.parseExportSpecifiers = function(exports) {\n\t  var nodes = [], first = true;\n\t  // export { x, y as z } [from '...']\n\t  this.expect(types.braceL);\n\t  while (!this.eat(types.braceR)) {\n\t    if (!first) {\n\t      this.expect(types.comma);\n\t      if (this.afterTrailingComma(types.braceR)) { break }\n\t    } else { first = false; }\n\n\t    var node = this.startNode();\n\t    node.local = this.parseIdent(true);\n\t    node.exported = this.eatContextual(\"as\") ? this.parseIdent(true) : node.local;\n\t    this.checkExport(exports, node.exported.name, node.exported.start);\n\t    nodes.push(this.finishNode(node, \"ExportSpecifier\"));\n\t  }\n\t  return nodes\n\t};\n\n\t// Parses import declaration.\n\n\tpp$1.parseImport = function(node) {\n\t  this.next();\n\t  // import '...'\n\t  if (this.type === types.string) {\n\t    node.specifiers = empty;\n\t    node.source = this.parseExprAtom();\n\t  } else {\n\t    node.specifiers = this.parseImportSpecifiers();\n\t    this.expectContextual(\"from\");\n\t    node.source = this.type === types.string ? this.parseExprAtom() : this.unexpected();\n\t  }\n\t  this.semicolon();\n\t  return this.finishNode(node, \"ImportDeclaration\")\n\t};\n\n\t// Parses a comma-separated list of module imports.\n\n\tpp$1.parseImportSpecifiers = function() {\n\t  var nodes = [], first = true;\n\t  if (this.type === types.name) {\n\t    // import defaultObj, { x, y as z } from '...'\n\t    var node = this.startNode();\n\t    node.local = this.parseIdent();\n\t    this.checkLVal(node.local, BIND_LEXICAL);\n\t    nodes.push(this.finishNode(node, \"ImportDefaultSpecifier\"));\n\t    if (!this.eat(types.comma)) { return nodes }\n\t  }\n\t  if (this.type === types.star) {\n\t    var node$1 = this.startNode();\n\t    this.next();\n\t    this.expectContextual(\"as\");\n\t    node$1.local = this.parseIdent();\n\t    this.checkLVal(node$1.local, BIND_LEXICAL);\n\t    nodes.push(this.finishNode(node$1, \"ImportNamespaceSpecifier\"));\n\t    return nodes\n\t  }\n\t  this.expect(types.braceL);\n\t  while (!this.eat(types.braceR)) {\n\t    if (!first) {\n\t      this.expect(types.comma);\n\t      if (this.afterTrailingComma(types.braceR)) { break }\n\t    } else { first = false; }\n\n\t    var node$2 = this.startNode();\n\t    node$2.imported = this.parseIdent(true);\n\t    if (this.eatContextual(\"as\")) {\n\t      node$2.local = this.parseIdent();\n\t    } else {\n\t      this.checkUnreserved(node$2.imported);\n\t      node$2.local = node$2.imported;\n\t    }\n\t    this.checkLVal(node$2.local, BIND_LEXICAL);\n\t    nodes.push(this.finishNode(node$2, \"ImportSpecifier\"));\n\t  }\n\t  return nodes\n\t};\n\n\t// Set `ExpressionStatement#directive` property for directive prologues.\n\tpp$1.adaptDirectivePrologue = function(statements) {\n\t  for (var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i) {\n\t    statements[i].directive = statements[i].expression.raw.slice(1, -1);\n\t  }\n\t};\n\tpp$1.isDirectiveCandidate = function(statement) {\n\t  return (\n\t    statement.type === \"ExpressionStatement\" &&\n\t    statement.expression.type === \"Literal\" &&\n\t    typeof statement.expression.value === \"string\" &&\n\t    // Reject parenthesized strings.\n\t    (this.input[statement.start] === \"\\\"\" || this.input[statement.start] === \"'\")\n\t  )\n\t};\n\n\tvar pp$2 = Parser.prototype;\n\n\t// Convert existing expression atom to assignable pattern\n\t// if possible.\n\n\tpp$2.toAssignable = function(node, isBinding, refDestructuringErrors) {\n\t  if (this.options.ecmaVersion >= 6 && node) {\n\t    switch (node.type) {\n\t    case \"Identifier\":\n\t      if (this.inAsync && node.name === \"await\")\n\t        { this.raise(node.start, \"Cannot use 'await' as identifier inside an async function\"); }\n\t      break\n\n\t    case \"ObjectPattern\":\n\t    case \"ArrayPattern\":\n\t    case \"RestElement\":\n\t      break\n\n\t    case \"ObjectExpression\":\n\t      node.type = \"ObjectPattern\";\n\t      if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }\n\t      for (var i = 0, list = node.properties; i < list.length; i += 1) {\n\t        var prop = list[i];\n\n\t      this.toAssignable(prop, isBinding);\n\t        // Early error:\n\t        //   AssignmentRestProperty[Yield, Await] :\n\t        //     `...` DestructuringAssignmentTarget[Yield, Await]\n\t        //\n\t        //   It is a Syntax Error if |DestructuringAssignmentTarget| is an |ArrayLiteral| or an |ObjectLiteral|.\n\t        if (\n\t          prop.type === \"RestElement\" &&\n\t          (prop.argument.type === \"ArrayPattern\" || prop.argument.type === \"ObjectPattern\")\n\t        ) {\n\t          this.raise(prop.argument.start, \"Unexpected token\");\n\t        }\n\t      }\n\t      break\n\n\t    case \"Property\":\n\t      // AssignmentProperty has type === \"Property\"\n\t      if (node.kind !== \"init\") { this.raise(node.key.start, \"Object pattern can't contain getter or setter\"); }\n\t      this.toAssignable(node.value, isBinding);\n\t      break\n\n\t    case \"ArrayExpression\":\n\t      node.type = \"ArrayPattern\";\n\t      if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }\n\t      this.toAssignableList(node.elements, isBinding);\n\t      break\n\n\t    case \"SpreadElement\":\n\t      node.type = \"RestElement\";\n\t      this.toAssignable(node.argument, isBinding);\n\t      if (node.argument.type === \"AssignmentPattern\")\n\t        { this.raise(node.argument.start, \"Rest elements cannot have a default value\"); }\n\t      break\n\n\t    case \"AssignmentExpression\":\n\t      if (node.operator !== \"=\") { this.raise(node.left.end, \"Only '=' operator can be used for specifying default value.\"); }\n\t      node.type = \"AssignmentPattern\";\n\t      delete node.operator;\n\t      this.toAssignable(node.left, isBinding);\n\t      // falls through to AssignmentPattern\n\n\t    case \"AssignmentPattern\":\n\t      break\n\n\t    case \"ParenthesizedExpression\":\n\t      this.toAssignable(node.expression, isBinding, refDestructuringErrors);\n\t      break\n\n\t    case \"ChainExpression\":\n\t      this.raiseRecoverable(node.start, \"Optional chaining cannot appear in left-hand side\");\n\t      break\n\n\t    case \"MemberExpression\":\n\t      if (!isBinding) { break }\n\n\t    default:\n\t      this.raise(node.start, \"Assigning to rvalue\");\n\t    }\n\t  } else if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }\n\t  return node\n\t};\n\n\t// Convert list of expression atoms to binding list.\n\n\tpp$2.toAssignableList = function(exprList, isBinding) {\n\t  var end = exprList.length;\n\t  for (var i = 0; i < end; i++) {\n\t    var elt = exprList[i];\n\t    if (elt) { this.toAssignable(elt, isBinding); }\n\t  }\n\t  if (end) {\n\t    var last = exprList[end - 1];\n\t    if (this.options.ecmaVersion === 6 && isBinding && last && last.type === \"RestElement\" && last.argument.type !== \"Identifier\")\n\t      { this.unexpected(last.argument.start); }\n\t  }\n\t  return exprList\n\t};\n\n\t// Parses spread element.\n\n\tpp$2.parseSpread = function(refDestructuringErrors) {\n\t  var node = this.startNode();\n\t  this.next();\n\t  node.argument = this.parseMaybeAssign(false, refDestructuringErrors);\n\t  return this.finishNode(node, \"SpreadElement\")\n\t};\n\n\tpp$2.parseRestBinding = function() {\n\t  var node = this.startNode();\n\t  this.next();\n\n\t  // RestElement inside of a function parameter must be an identifier\n\t  if (this.options.ecmaVersion === 6 && this.type !== types.name)\n\t    { this.unexpected(); }\n\n\t  node.argument = this.parseBindingAtom();\n\n\t  return this.finishNode(node, \"RestElement\")\n\t};\n\n\t// Parses lvalue (assignable) atom.\n\n\tpp$2.parseBindingAtom = function() {\n\t  if (this.options.ecmaVersion >= 6) {\n\t    switch (this.type) {\n\t    case types.bracketL:\n\t      var node = this.startNode();\n\t      this.next();\n\t      node.elements = this.parseBindingList(types.bracketR, true, true);\n\t      return this.finishNode(node, \"ArrayPattern\")\n\n\t    case types.braceL:\n\t      return this.parseObj(true)\n\t    }\n\t  }\n\t  return this.parseIdent()\n\t};\n\n\tpp$2.parseBindingList = function(close, allowEmpty, allowTrailingComma) {\n\t  var elts = [], first = true;\n\t  while (!this.eat(close)) {\n\t    if (first) { first = false; }\n\t    else { this.expect(types.comma); }\n\t    if (allowEmpty && this.type === types.comma) {\n\t      elts.push(null);\n\t    } else if (allowTrailingComma && this.afterTrailingComma(close)) {\n\t      break\n\t    } else if (this.type === types.ellipsis) {\n\t      var rest = this.parseRestBinding();\n\t      this.parseBindingListItem(rest);\n\t      elts.push(rest);\n\t      if (this.type === types.comma) { this.raise(this.start, \"Comma is not permitted after the rest element\"); }\n\t      this.expect(close);\n\t      break\n\t    } else {\n\t      var elem = this.parseMaybeDefault(this.start, this.startLoc);\n\t      this.parseBindingListItem(elem);\n\t      elts.push(elem);\n\t    }\n\t  }\n\t  return elts\n\t};\n\n\tpp$2.parseBindingListItem = function(param) {\n\t  return param\n\t};\n\n\t// Parses assignment pattern around given atom if possible.\n\n\tpp$2.parseMaybeDefault = function(startPos, startLoc, left) {\n\t  left = left || this.parseBindingAtom();\n\t  if (this.options.ecmaVersion < 6 || !this.eat(types.eq)) { return left }\n\t  var node = this.startNodeAt(startPos, startLoc);\n\t  node.left = left;\n\t  node.right = this.parseMaybeAssign();\n\t  return this.finishNode(node, \"AssignmentPattern\")\n\t};\n\n\t// Verify that a node is an lval \u2014 something that can be assigned\n\t// to.\n\t// bindingType can be either:\n\t// 'var' indicating that the lval creates a 'var' binding\n\t// 'let' indicating that the lval creates a lexical ('let' or 'const') binding\n\t// 'none' indicating that the binding should be checked for illegal identifiers, but not for duplicate references\n\n\tpp$2.checkLVal = function(expr, bindingType, checkClashes) {\n\t  if ( bindingType === void 0 ) bindingType = BIND_NONE;\n\n\t  switch (expr.type) {\n\t  case \"Identifier\":\n\t    if (bindingType === BIND_LEXICAL && expr.name === \"let\")\n\t      { this.raiseRecoverable(expr.start, \"let is disallowed as a lexically bound name\"); }\n\t    if (this.strict && this.reservedWordsStrictBind.test(expr.name))\n\t      { this.raiseRecoverable(expr.start, (bindingType ? \"Binding \" : \"Assigning to \") + expr.name + \" in strict mode\"); }\n\t    if (checkClashes) {\n\t      if (has(checkClashes, expr.name))\n\t        { this.raiseRecoverable(expr.start, \"Argument name clash\"); }\n\t      checkClashes[expr.name] = true;\n\t    }\n\t    if (bindingType !== BIND_NONE && bindingType !== BIND_OUTSIDE) { this.declareName(expr.name, bindingType, expr.start); }\n\t    break\n\n\t  case \"ChainExpression\":\n\t    this.raiseRecoverable(expr.start, \"Optional chaining cannot appear in left-hand side\");\n\t    break\n\n\t  case \"MemberExpression\":\n\t    if (bindingType) { this.raiseRecoverable(expr.start, \"Binding member expression\"); }\n\t    break\n\n\t  case \"ObjectPattern\":\n\t    for (var i = 0, list = expr.properties; i < list.length; i += 1)\n\t      {\n\t    var prop = list[i];\n\n\t    this.checkLVal(prop, bindingType, checkClashes);\n\t  }\n\t    break\n\n\t  case \"Property\":\n\t    // AssignmentProperty has type === \"Property\"\n\t    this.checkLVal(expr.value, bindingType, checkClashes);\n\t    break\n\n\t  case \"ArrayPattern\":\n\t    for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {\n\t      var elem = list$1[i$1];\n\n\t    if (elem) { this.checkLVal(elem, bindingType, checkClashes); }\n\t    }\n\t    break\n\n\t  case \"AssignmentPattern\":\n\t    this.checkLVal(expr.left, bindingType, checkClashes);\n\t    break\n\n\t  case \"RestElement\":\n\t    this.checkLVal(expr.argument, bindingType, checkClashes);\n\t    break\n\n\t  case \"ParenthesizedExpression\":\n\t    this.checkLVal(expr.expression, bindingType, checkClashes);\n\t    break\n\n\t  default:\n\t    this.raise(expr.start, (bindingType ? \"Binding\" : \"Assigning to\") + \" rvalue\");\n\t  }\n\t};\n\n\t// A recursive descent parser operates by defining functions for all\n\n\tvar pp$3 = Parser.prototype;\n\n\t// Check if property name clashes with already added.\n\t// Object/class getters and setters are not allowed to clash \u2014\n\t// either with each other or with an init property \u2014 and in\n\t// strict mode, init properties are also not allowed to be repeated.\n\n\tpp$3.checkPropClash = function(prop, propHash, refDestructuringErrors) {\n\t  if (this.options.ecmaVersion >= 9 && prop.type === \"SpreadElement\")\n\t    { return }\n\t  if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand))\n\t    { return }\n\t  var key = prop.key;\n\t  var name;\n\t  switch (key.type) {\n\t  case \"Identifier\": name = key.name; break\n\t  case \"Literal\": name = String(key.value); break\n\t  default: return\n\t  }\n\t  var kind = prop.kind;\n\t  if (this.options.ecmaVersion >= 6) {\n\t    if (name === \"__proto__\" && kind === \"init\") {\n\t      if (propHash.proto) {\n\t        if (refDestructuringErrors) {\n\t          if (refDestructuringErrors.doubleProto < 0)\n\t            { refDestructuringErrors.doubleProto = key.start; }\n\t          // Backwards-compat kludge. Can be removed in version 6.0\n\t        } else { this.raiseRecoverable(key.start, \"Redefinition of __proto__ property\"); }\n\t      }\n\t      propHash.proto = true;\n\t    }\n\t    return\n\t  }\n\t  name = \"$\" + name;\n\t  var other = propHash[name];\n\t  if (other) {\n\t    var redefinition;\n\t    if (kind === \"init\") {\n\t      redefinition = this.strict && other.init || other.get || other.set;\n\t    } else {\n\t      redefinition = other.init || other[kind];\n\t    }\n\t    if (redefinition)\n\t      { this.raiseRecoverable(key.start, \"Redefinition of property\"); }\n\t  } else {\n\t    other = propHash[name] = {\n\t      init: false,\n\t      get: false,\n\t      set: false\n\t    };\n\t  }\n\t  other[kind] = true;\n\t};\n\n\t// ### Expression parsing\n\n\t// These nest, from the most general expression type at the top to\n\t// 'atomic', nondivisible expression types at the bottom. Most of\n\t// the functions will simply let the function(s) below them parse,\n\t// and, *if* the syntactic construct they handle is present, wrap\n\t// the AST node that the inner parser gave them in another node.\n\n\t// Parse a full expression. The optional arguments are used to\n\t// forbid the `in` operator (in for loops initalization expressions)\n\t// and provide reference for storing '=' operator inside shorthand\n\t// property assignment in contexts where both object expression\n\t// and object pattern might appear (so it's possible to raise\n\t// delayed syntax error at correct position).\n\n\tpp$3.parseExpression = function(noIn, refDestructuringErrors) {\n\t  var startPos = this.start, startLoc = this.startLoc;\n\t  var expr = this.parseMaybeAssign(noIn, refDestructuringErrors);\n\t  if (this.type === types.comma) {\n\t    var node = this.startNodeAt(startPos, startLoc);\n\t    node.expressions = [expr];\n\t    while (this.eat(types.comma)) { node.expressions.push(this.parseMaybeAssign(noIn, refDestructuringErrors)); }\n\t    return this.finishNode(node, \"SequenceExpression\")\n\t  }\n\t  return expr\n\t};\n\n\t// Parse an assignment expression. This includes applications of\n\t// operators like `+=`.\n\n\tpp$3.parseMaybeAssign = function(noIn, refDestructuringErrors, afterLeftParse) {\n\t  if (this.isContextual(\"yield\")) {\n\t    if (this.inGenerator) { return this.parseYield(noIn) }\n\t    // The tokenizer will assume an expression is allowed after\n\t    // `yield`, but this isn't that kind of yield\n\t    else { this.exprAllowed = false; }\n\t  }\n\n\t  var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1;\n\t  if (refDestructuringErrors) {\n\t    oldParenAssign = refDestructuringErrors.parenthesizedAssign;\n\t    oldTrailingComma = refDestructuringErrors.trailingComma;\n\t    refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;\n\t  } else {\n\t    refDestructuringErrors = new DestructuringErrors;\n\t    ownDestructuringErrors = true;\n\t  }\n\n\t  var startPos = this.start, startLoc = this.startLoc;\n\t  if (this.type === types.parenL || this.type === types.name)\n\t    { this.potentialArrowAt = this.start; }\n\t  var left = this.parseMaybeConditional(noIn, refDestructuringErrors);\n\t  if (afterLeftParse) { left = afterLeftParse.call(this, left, startPos, startLoc); }\n\t  if (this.type.isAssign) {\n\t    var node = this.startNodeAt(startPos, startLoc);\n\t    node.operator = this.value;\n\t    node.left = this.type === types.eq ? this.toAssignable(left, false, refDestructuringErrors) : left;\n\t    if (!ownDestructuringErrors) {\n\t      refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;\n\t    }\n\t    if (refDestructuringErrors.shorthandAssign >= node.left.start)\n\t      { refDestructuringErrors.shorthandAssign = -1; } // reset because shorthand default was used correctly\n\t    this.checkLVal(left);\n\t    this.next();\n\t    node.right = this.parseMaybeAssign(noIn);\n\t    return this.finishNode(node, \"AssignmentExpression\")\n\t  } else {\n\t    if (ownDestructuringErrors) { this.checkExpressionErrors(refDestructuringErrors, true); }\n\t  }\n\t  if (oldParenAssign > -1) { refDestructuringErrors.parenthesizedAssign = oldParenAssign; }\n\t  if (oldTrailingComma > -1) { refDestructuringErrors.trailingComma = oldTrailingComma; }\n\t  return left\n\t};\n\n\t// Parse a ternary conditional (`?:`) operator.\n\n\tpp$3.parseMaybeConditional = function(noIn, refDestructuringErrors) {\n\t  var startPos = this.start, startLoc = this.startLoc;\n\t  var expr = this.parseExprOps(noIn, refDestructuringErrors);\n\t  if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }\n\t  if (this.eat(types.question)) {\n\t    var node = this.startNodeAt(startPos, startLoc);\n\t    node.test = expr;\n\t    node.consequent = this.parseMaybeAssign();\n\t    this.expect(types.colon);\n\t    node.alternate = this.parseMaybeAssign(noIn);\n\t    return this.finishNode(node, \"ConditionalExpression\")\n\t  }\n\t  return expr\n\t};\n\n\t// Start the precedence parser.\n\n\tpp$3.parseExprOps = function(noIn, refDestructuringErrors) {\n\t  var startPos = this.start, startLoc = this.startLoc;\n\t  var expr = this.parseMaybeUnary(refDestructuringErrors, false);\n\t  if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }\n\t  return expr.start === startPos && expr.type === \"ArrowFunctionExpression\" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, noIn)\n\t};\n\n\t// Parse binary operators with the operator precedence parsing\n\t// algorithm. `left` is the left-hand side of the operator.\n\t// `minPrec` provides context that allows the function to stop and\n\t// defer further parser to one of its callers when it encounters an\n\t// operator that has a lower precedence than the set it is parsing.\n\n\tpp$3.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, noIn) {\n\t  var prec = this.type.binop;\n\t  if (prec != null && (!noIn || this.type !== types._in)) {\n\t    if (prec > minPrec) {\n\t      var logical = this.type === types.logicalOR || this.type === types.logicalAND;\n\t      var coalesce = this.type === types.coalesce;\n\t      if (coalesce) {\n\t        // Handle the precedence of `tt.coalesce` as equal to the range of logical expressions.\n\t        // In other words, `node.right` shouldn't contain logical expressions in order to check the mixed error.\n\t        prec = types.logicalAND.binop;\n\t      }\n\t      var op = this.value;\n\t      this.next();\n\t      var startPos = this.start, startLoc = this.startLoc;\n\t      var right = this.parseExprOp(this.parseMaybeUnary(null, false), startPos, startLoc, prec, noIn);\n\t      var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical || coalesce);\n\t      if ((logical && this.type === types.coalesce) || (coalesce && (this.type === types.logicalOR || this.type === types.logicalAND))) {\n\t        this.raiseRecoverable(this.start, \"Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses\");\n\t      }\n\t      return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn)\n\t    }\n\t  }\n\t  return left\n\t};\n\n\tpp$3.buildBinary = function(startPos, startLoc, left, right, op, logical) {\n\t  var node = this.startNodeAt(startPos, startLoc);\n\t  node.left = left;\n\t  node.operator = op;\n\t  node.right = right;\n\t  return this.finishNode(node, logical ? \"LogicalExpression\" : \"BinaryExpression\")\n\t};\n\n\t// Parse unary operators, both prefix and postfix.\n\n\tpp$3.parseMaybeUnary = function(refDestructuringErrors, sawUnary) {\n\t  var startPos = this.start, startLoc = this.startLoc, expr;\n\t  if (this.isContextual(\"await\") && (this.inAsync || (!this.inFunction && this.options.allowAwaitOutsideFunction))) {\n\t    expr = this.parseAwait();\n\t    sawUnary = true;\n\t  } else if (this.type.prefix) {\n\t    var node = this.startNode(), update = this.type === types.incDec;\n\t    node.operator = this.value;\n\t    node.prefix = true;\n\t    this.next();\n\t    node.argument = this.parseMaybeUnary(null, true);\n\t    this.checkExpressionErrors(refDestructuringErrors, true);\n\t    if (update) { this.checkLVal(node.argument); }\n\t    else if (this.strict && node.operator === \"delete\" &&\n\t             node.argument.type === \"Identifier\")\n\t      { this.raiseRecoverable(node.start, \"Deleting local variable in strict mode\"); }\n\t    else { sawUnary = true; }\n\t    expr = this.finishNode(node, update ? \"UpdateExpression\" : \"UnaryExpression\");\n\t  } else {\n\t    expr = this.parseExprSubscripts(refDestructuringErrors);\n\t    if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }\n\t    while (this.type.postfix && !this.canInsertSemicolon()) {\n\t      var node$1 = this.startNodeAt(startPos, startLoc);\n\t      node$1.operator = this.value;\n\t      node$1.prefix = false;\n\t      node$1.argument = expr;\n\t      this.checkLVal(expr);\n\t      this.next();\n\t      expr = this.finishNode(node$1, \"UpdateExpression\");\n\t    }\n\t  }\n\n\t  if (!sawUnary && this.eat(types.starstar))\n\t    { return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false), \"**\", false) }\n\t  else\n\t    { return expr }\n\t};\n\n\t// Parse call, dot, and `[]`-subscript expressions.\n\n\tpp$3.parseExprSubscripts = function(refDestructuringErrors) {\n\t  var startPos = this.start, startLoc = this.startLoc;\n\t  var expr = this.parseExprAtom(refDestructuringErrors);\n\t  if (expr.type === \"ArrowFunctionExpression\" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== \")\")\n\t    { return expr }\n\t  var result = this.parseSubscripts(expr, startPos, startLoc);\n\t  if (refDestructuringErrors && result.type === \"MemberExpression\") {\n\t    if (refDestructuringErrors.parenthesizedAssign >= result.start) { refDestructuringErrors.parenthesizedAssign = -1; }\n\t    if (refDestructuringErrors.parenthesizedBind >= result.start) { refDestructuringErrors.parenthesizedBind = -1; }\n\t  }\n\t  return result\n\t};\n\n\tpp$3.parseSubscripts = function(base, startPos, startLoc, noCalls) {\n\t  var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === \"Identifier\" && base.name === \"async\" &&\n\t      this.lastTokEnd === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 &&\n\t      this.potentialArrowAt === base.start;\n\t  var optionalChained = false;\n\n\t  while (true) {\n\t    var element = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained);\n\n\t    if (element.optional) { optionalChained = true; }\n\t    if (element === base || element.type === \"ArrowFunctionExpression\") {\n\t      if (optionalChained) {\n\t        var chainNode = this.startNodeAt(startPos, startLoc);\n\t        chainNode.expression = element;\n\t        element = this.finishNode(chainNode, \"ChainExpression\");\n\t      }\n\t      return element\n\t    }\n\n\t    base = element;\n\t  }\n\t};\n\n\tpp$3.parseSubscript = function(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained) {\n\t  var optionalSupported = this.options.ecmaVersion >= 11;\n\t  var optional = optionalSupported && this.eat(types.questionDot);\n\t  if (noCalls && optional) { this.raise(this.lastTokStart, \"Optional chaining cannot appear in the callee of new expressions\"); }\n\n\t  var computed = this.eat(types.bracketL);\n\t  if (computed || (optional && this.type !== types.parenL && this.type !== types.backQuote) || this.eat(types.dot)) {\n\t    var node = this.startNodeAt(startPos, startLoc);\n\t    node.object = base;\n\t    node.property = computed ? this.parseExpression() : this.parseIdent(this.options.allowReserved !== \"never\");\n\t    node.computed = !!computed;\n\t    if (computed) { this.expect(types.bracketR); }\n\t    if (optionalSupported) {\n\t      node.optional = optional;\n\t    }\n\t    base = this.finishNode(node, \"MemberExpression\");\n\t  } else if (!noCalls && this.eat(types.parenL)) {\n\t    var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\n\t    this.yieldPos = 0;\n\t    this.awaitPos = 0;\n\t    this.awaitIdentPos = 0;\n\t    var exprList = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);\n\t    if (maybeAsyncArrow && !optional && !this.canInsertSemicolon() && this.eat(types.arrow)) {\n\t      this.checkPatternErrors(refDestructuringErrors, false);\n\t      this.checkYieldAwaitInDefaultParams();\n\t      if (this.awaitIdentPos > 0)\n\t        { this.raise(this.awaitIdentPos, \"Cannot use 'await' as identifier inside an async function\"); }\n\t      this.yieldPos = oldYieldPos;\n\t      this.awaitPos = oldAwaitPos;\n\t      this.awaitIdentPos = oldAwaitIdentPos;\n\t      return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true)\n\t    }\n\t    this.checkExpressionErrors(refDestructuringErrors, true);\n\t    this.yieldPos = oldYieldPos || this.yieldPos;\n\t    this.awaitPos = oldAwaitPos || this.awaitPos;\n\t    this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;\n\t    var node$1 = this.startNodeAt(startPos, startLoc);\n\t    node$1.callee = base;\n\t    node$1.arguments = exprList;\n\t    if (optionalSupported) {\n\t      node$1.optional = optional;\n\t    }\n\t    base = this.finishNode(node$1, \"CallExpression\");\n\t  } else if (this.type === types.backQuote) {\n\t    if (optional || optionalChained) {\n\t      this.raise(this.start, \"Optional chaining cannot appear in the tag of tagged template expressions\");\n\t    }\n\t    var node$2 = this.startNodeAt(startPos, startLoc);\n\t    node$2.tag = base;\n\t    node$2.quasi = this.parseTemplate({isTagged: true});\n\t    base = this.finishNode(node$2, \"TaggedTemplateExpression\");\n\t  }\n\t  return base\n\t};\n\n\t// Parse an atomic expression \u2014 either a single token that is an\n\t// expression, an expression started by a keyword like `function` or\n\t// `new`, or an expression wrapped in punctuation like `()`, `[]`,\n\t// or `{}`.\n\n\tpp$3.parseExprAtom = function(refDestructuringErrors) {\n\t  // If a division operator appears in an expression position, the\n\t  // tokenizer got confused, and we force it to read a regexp instead.\n\t  if (this.type === types.slash) { this.readRegexp(); }\n\n\t  var node, canBeArrow = this.potentialArrowAt === this.start;\n\t  switch (this.type) {\n\t  case types._super:\n\t    if (!this.allowSuper)\n\t      { this.raise(this.start, \"'super' keyword outside a method\"); }\n\t    node = this.startNode();\n\t    this.next();\n\t    if (this.type === types.parenL && !this.allowDirectSuper)\n\t      { this.raise(node.start, \"super() call outside constructor of a subclass\"); }\n\t    // The `super` keyword can appear at below:\n\t    // SuperProperty:\n\t    //     super [ Expression ]\n\t    //     super . IdentifierName\n\t    // SuperCall:\n\t    //     super ( Arguments )\n\t    if (this.type !== types.dot && this.type !== types.bracketL && this.type !== types.parenL)\n\t      { this.unexpected(); }\n\t    return this.finishNode(node, \"Super\")\n\n\t  case types._this:\n\t    node = this.startNode();\n\t    this.next();\n\t    return this.finishNode(node, \"ThisExpression\")\n\n\t  case types.name:\n\t    var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;\n\t    var id = this.parseIdent(false);\n\t    if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === \"async\" && !this.canInsertSemicolon() && this.eat(types._function))\n\t      { return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true) }\n\t    if (canBeArrow && !this.canInsertSemicolon()) {\n\t      if (this.eat(types.arrow))\n\t        { return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false) }\n\t      if (this.options.ecmaVersion >= 8 && id.name === \"async\" && this.type === types.name && !containsEsc) {\n\t        id = this.parseIdent(false);\n\t        if (this.canInsertSemicolon() || !this.eat(types.arrow))\n\t          { this.unexpected(); }\n\t        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true)\n\t      }\n\t    }\n\t    return id\n\n\t  case types.regexp:\n\t    var value = this.value;\n\t    node = this.parseLiteral(value.value);\n\t    node.regex = {pattern: value.pattern, flags: value.flags};\n\t    return node\n\n\t  case types.num: case types.string:\n\t    return this.parseLiteral(this.value)\n\n\t  case types._null: case types._true: case types._false:\n\t    node = this.startNode();\n\t    node.value = this.type === types._null ? null : this.type === types._true;\n\t    node.raw = this.type.keyword;\n\t    this.next();\n\t    return this.finishNode(node, \"Literal\")\n\n\t  case types.parenL:\n\t    var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow);\n\t    if (refDestructuringErrors) {\n\t      if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr))\n\t        { refDestructuringErrors.parenthesizedAssign = start; }\n\t      if (refDestructuringErrors.parenthesizedBind < 0)\n\t        { refDestructuringErrors.parenthesizedBind = start; }\n\t    }\n\t    return expr\n\n\t  case types.bracketL:\n\t    node = this.startNode();\n\t    this.next();\n\t    node.elements = this.parseExprList(types.bracketR, true, true, refDestructuringErrors);\n\t    return this.finishNode(node, \"ArrayExpression\")\n\n\t  case types.braceL:\n\t    return this.parseObj(false, refDestructuringErrors)\n\n\t  case types._function:\n\t    node = this.startNode();\n\t    this.next();\n\t    return this.parseFunction(node, 0)\n\n\t  case types._class:\n\t    return this.parseClass(this.startNode(), false)\n\n\t  case types._new:\n\t    return this.parseNew()\n\n\t  case types.backQuote:\n\t    return this.parseTemplate()\n\n\t  case types._import:\n\t    if (this.options.ecmaVersion >= 11) {\n\t      return this.parseExprImport()\n\t    } else {\n\t      return this.unexpected()\n\t    }\n\n\t  default:\n\t    this.unexpected();\n\t  }\n\t};\n\n\tpp$3.parseExprImport = function() {\n\t  var node = this.startNode();\n\n\t  // Consume `import` as an identifier for `import.meta`.\n\t  // Because `this.parseIdent(true)` doesn't check escape sequences, it needs the check of `this.containsEsc`.\n\t  if (this.containsEsc) { this.raiseRecoverable(this.start, \"Escape sequence in keyword import\"); }\n\t  var meta = this.parseIdent(true);\n\n\t  switch (this.type) {\n\t  case types.parenL:\n\t    return this.parseDynamicImport(node)\n\t  case types.dot:\n\t    node.meta = meta;\n\t    return this.parseImportMeta(node)\n\t  default:\n\t    this.unexpected();\n\t  }\n\t};\n\n\tpp$3.parseDynamicImport = function(node) {\n\t  this.next(); // skip `(`\n\n\t  // Parse node.source.\n\t  node.source = this.parseMaybeAssign();\n\n\t  // Verify ending.\n\t  if (!this.eat(types.parenR)) {\n\t    var errorPos = this.start;\n\t    if (this.eat(types.comma) && this.eat(types.parenR)) {\n\t      this.raiseRecoverable(errorPos, \"Trailing comma is not allowed in import()\");\n\t    } else {\n\t      this.unexpected(errorPos);\n\t    }\n\t  }\n\n\t  return this.finishNode(node, \"ImportExpression\")\n\t};\n\n\tpp$3.parseImportMeta = function(node) {\n\t  this.next(); // skip `.`\n\n\t  var containsEsc = this.containsEsc;\n\t  node.property = this.parseIdent(true);\n\n\t  if (node.property.name !== \"meta\")\n\t    { this.raiseRecoverable(node.property.start, \"The only valid meta property for import is 'import.meta'\"); }\n\t  if (containsEsc)\n\t    { this.raiseRecoverable(node.start, \"'import.meta' must not contain escaped characters\"); }\n\t  if (this.options.sourceType !== \"module\")\n\t    { this.raiseRecoverable(node.start, \"Cannot use 'import.meta' outside a module\"); }\n\n\t  return this.finishNode(node, \"MetaProperty\")\n\t};\n\n\tpp$3.parseLiteral = function(value) {\n\t  var node = this.startNode();\n\t  node.value = value;\n\t  node.raw = this.input.slice(this.start, this.end);\n\t  if (node.raw.charCodeAt(node.raw.length - 1) === 110) { node.bigint = node.raw.slice(0, -1); }\n\t  this.next();\n\t  return this.finishNode(node, \"Literal\")\n\t};\n\n\tpp$3.parseParenExpression = function() {\n\t  this.expect(types.parenL);\n\t  var val = this.parseExpression();\n\t  this.expect(types.parenR);\n\t  return val\n\t};\n\n\tpp$3.parseParenAndDistinguishExpression = function(canBeArrow) {\n\t  var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;\n\t  if (this.options.ecmaVersion >= 6) {\n\t    this.next();\n\n\t    var innerStartPos = this.start, innerStartLoc = this.startLoc;\n\t    var exprList = [], first = true, lastIsComma = false;\n\t    var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;\n\t    this.yieldPos = 0;\n\t    this.awaitPos = 0;\n\t    // Do not save awaitIdentPos to allow checking awaits nested in parameters\n\t    while (this.type !== types.parenR) {\n\t      first ? first = false : this.expect(types.comma);\n\t      if (allowTrailingComma && this.afterTrailingComma(types.parenR, true)) {\n\t        lastIsComma = true;\n\t        break\n\t      } else if (this.type === types.ellipsis) {\n\t        spreadStart = this.start;\n\t        exprList.push(this.parseParenItem(this.parseRestBinding()));\n\t        if (this.type === types.comma) { this.raise(this.start, \"Comma is not permitted after the rest element\"); }\n\t        break\n\t      } else {\n\t        exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));\n\t      }\n\t    }\n\t    var innerEndPos = this.start, innerEndLoc = this.startLoc;\n\t    this.expect(types.parenR);\n\n\t    if (canBeArrow && !this.canInsertSemicolon() && this.eat(types.arrow)) {\n\t      this.checkPatternErrors(refDestructuringErrors, false);\n\t      this.checkYieldAwaitInDefaultParams();\n\t      this.yieldPos = oldYieldPos;\n\t      this.awaitPos = oldAwaitPos;\n\t      return this.parseParenArrowList(startPos, startLoc, exprList)\n\t    }\n\n\t    if (!exprList.length || lastIsComma) { this.unexpected(this.lastTokStart); }\n\t    if (spreadStart) { this.unexpected(spreadStart); }\n\t    this.checkExpressionErrors(refDestructuringErrors, true);\n\t    this.yieldPos = oldYieldPos || this.yieldPos;\n\t    this.awaitPos = oldAwaitPos || this.awaitPos;\n\n\t    if (exprList.length > 1) {\n\t      val = this.startNodeAt(innerStartPos, innerStartLoc);\n\t      val.expressions = exprList;\n\t      this.finishNodeAt(val, \"SequenceExpression\", innerEndPos, innerEndLoc);\n\t    } else {\n\t      val = exprList[0];\n\t    }\n\t  } else {\n\t    val = this.parseParenExpression();\n\t  }\n\n\t  if (this.options.preserveParens) {\n\t    var par = this.startNodeAt(startPos, startLoc);\n\t    par.expression = val;\n\t    return this.finishNode(par, \"ParenthesizedExpression\")\n\t  } else {\n\t    return val\n\t  }\n\t};\n\n\tpp$3.parseParenItem = function(item) {\n\t  return item\n\t};\n\n\tpp$3.parseParenArrowList = function(startPos, startLoc, exprList) {\n\t  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList)\n\t};\n\n\t// New's precedence is slightly tricky. It must allow its argument to\n\t// be a `[]` or dot subscript expression, but not a call \u2014 at least,\n\t// not without wrapping it in parentheses. Thus, it uses the noCalls\n\t// argument to parseSubscripts to prevent it from consuming the\n\t// argument list.\n\n\tvar empty$1 = [];\n\n\tpp$3.parseNew = function() {\n\t  if (this.containsEsc) { this.raiseRecoverable(this.start, \"Escape sequence in keyword new\"); }\n\t  var node = this.startNode();\n\t  var meta = this.parseIdent(true);\n\t  if (this.options.ecmaVersion >= 6 && this.eat(types.dot)) {\n\t    node.meta = meta;\n\t    var containsEsc = this.containsEsc;\n\t    node.property = this.parseIdent(true);\n\t    if (node.property.name !== \"target\")\n\t      { this.raiseRecoverable(node.property.start, \"The only valid meta property for new is 'new.target'\"); }\n\t    if (containsEsc)\n\t      { this.raiseRecoverable(node.start, \"'new.target' must not contain escaped characters\"); }\n\t    if (!this.inNonArrowFunction())\n\t      { this.raiseRecoverable(node.start, \"'new.target' can only be used in functions\"); }\n\t    return this.finishNode(node, \"MetaProperty\")\n\t  }\n\t  var startPos = this.start, startLoc = this.startLoc, isImport = this.type === types._import;\n\t  node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);\n\t  if (isImport && node.callee.type === \"ImportExpression\") {\n\t    this.raise(startPos, \"Cannot use new with import()\");\n\t  }\n\t  if (this.eat(types.parenL)) { node.arguments = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8, false); }\n\t  else { node.arguments = empty$1; }\n\t  return this.finishNode(node, \"NewExpression\")\n\t};\n\n\t// Parse template expression.\n\n\tpp$3.parseTemplateElement = function(ref) {\n\t  var isTagged = ref.isTagged;\n\n\t  var elem = this.startNode();\n\t  if (this.type === types.invalidTemplate) {\n\t    if (!isTagged) {\n\t      this.raiseRecoverable(this.start, \"Bad escape sequence in untagged template literal\");\n\t    }\n\t    elem.value = {\n\t      raw: this.value,\n\t      cooked: null\n\t    };\n\t  } else {\n\t    elem.value = {\n\t      raw: this.input.slice(this.start, this.end).replace(/\\r\\n?/g, \"\\n\"),\n\t      cooked: this.value\n\t    };\n\t  }\n\t  this.next();\n\t  elem.tail = this.type === types.backQuote;\n\t  return this.finishNode(elem, \"TemplateElement\")\n\t};\n\n\tpp$3.parseTemplate = function(ref) {\n\t  if ( ref === void 0 ) ref = {};\n\t  var isTagged = ref.isTagged; if ( isTagged === void 0 ) isTagged = false;\n\n\t  var node = this.startNode();\n\t  this.next();\n\t  node.expressions = [];\n\t  var curElt = this.parseTemplateElement({isTagged: isTagged});\n\t  node.quasis = [curElt];\n\t  while (!curElt.tail) {\n\t    if (this.type === types.eof) { this.raise(this.pos, \"Unterminated template literal\"); }\n\t    this.expect(types.dollarBraceL);\n\t    node.expressions.push(this.parseExpression());\n\t    this.expect(types.braceR);\n\t    node.quasis.push(curElt = this.parseTemplateElement({isTagged: isTagged}));\n\t  }\n\t  this.next();\n\t  return this.finishNode(node, \"TemplateLiteral\")\n\t};\n\n\tpp$3.isAsyncProp = function(prop) {\n\t  return !prop.computed && prop.key.type === \"Identifier\" && prop.key.name === \"async\" &&\n\t    (this.type === types.name || this.type === types.num || this.type === types.string || this.type === types.bracketL || this.type.keyword || (this.options.ecmaVersion >= 9 && this.type === types.star)) &&\n\t    !lineBreak.test(this.input.slice(this.lastTokEnd, this.start))\n\t};\n\n\t// Parse an object literal or binding pattern.\n\n\tpp$3.parseObj = function(isPattern, refDestructuringErrors) {\n\t  var node = this.startNode(), first = true, propHash = {};\n\t  node.properties = [];\n\t  this.next();\n\t  while (!this.eat(types.braceR)) {\n\t    if (!first) {\n\t      this.expect(types.comma);\n\t      if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types.braceR)) { break }\n\t    } else { first = false; }\n\n\t    var prop = this.parseProperty(isPattern, refDestructuringErrors);\n\t    if (!isPattern) { this.checkPropClash(prop, propHash, refDestructuringErrors); }\n\t    node.properties.push(prop);\n\t  }\n\t  return this.finishNode(node, isPattern ? \"ObjectPattern\" : \"ObjectExpression\")\n\t};\n\n\tpp$3.parseProperty = function(isPattern, refDestructuringErrors) {\n\t  var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;\n\t  if (this.options.ecmaVersion >= 9 && this.eat(types.ellipsis)) {\n\t    if (isPattern) {\n\t      prop.argument = this.parseIdent(false);\n\t      if (this.type === types.comma) {\n\t        this.raise(this.start, \"Comma is not permitted after the rest element\");\n\t      }\n\t      return this.finishNode(prop, \"RestElement\")\n\t    }\n\t    // To disallow parenthesized identifier via `this.toAssignable()`.\n\t    if (this.type === types.parenL && refDestructuringErrors) {\n\t      if (refDestructuringErrors.parenthesizedAssign < 0) {\n\t        refDestructuringErrors.parenthesizedAssign = this.start;\n\t      }\n\t      if (refDestructuringErrors.parenthesizedBind < 0) {\n\t        refDestructuringErrors.parenthesizedBind = this.start;\n\t      }\n\t    }\n\t    // Parse argument.\n\t    prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);\n\t    // To disallow trailing comma via `this.toAssignable()`.\n\t    if (this.type === types.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {\n\t      refDestructuringErrors.trailingComma = this.start;\n\t    }\n\t    // Finish\n\t    return this.finishNode(prop, \"SpreadElement\")\n\t  }\n\t  if (this.options.ecmaVersion >= 6) {\n\t    prop.method = false;\n\t    prop.shorthand = false;\n\t    if (isPattern || refDestructuringErrors) {\n\t      startPos = this.start;\n\t      startLoc = this.startLoc;\n\t    }\n\t    if (!isPattern)\n\t      { isGenerator = this.eat(types.star); }\n\t  }\n\t  var containsEsc = this.containsEsc;\n\t  this.parsePropertyName(prop);\n\t  if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {\n\t    isAsync = true;\n\t    isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);\n\t    this.parsePropertyName(prop, refDestructuringErrors);\n\t  } else {\n\t    isAsync = false;\n\t  }\n\t  this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);\n\t  return this.finishNode(prop, \"Property\")\n\t};\n\n\tpp$3.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {\n\t  if ((isGenerator || isAsync) && this.type === types.colon)\n\t    { this.unexpected(); }\n\n\t  if (this.eat(types.colon)) {\n\t    prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);\n\t    prop.kind = \"init\";\n\t  } else if (this.options.ecmaVersion >= 6 && this.type === types.parenL) {\n\t    if (isPattern) { this.unexpected(); }\n\t    prop.kind = \"init\";\n\t    prop.method = true;\n\t    prop.value = this.parseMethod(isGenerator, isAsync);\n\t  } else if (!isPattern && !containsEsc &&\n\t             this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === \"Identifier\" &&\n\t             (prop.key.name === \"get\" || prop.key.name === \"set\") &&\n\t             (this.type !== types.comma && this.type !== types.braceR && this.type !== types.eq)) {\n\t    if (isGenerator || isAsync) { this.unexpected(); }\n\t    prop.kind = prop.key.name;\n\t    this.parsePropertyName(prop);\n\t    prop.value = this.parseMethod(false);\n\t    var paramCount = prop.kind === \"get\" ? 0 : 1;\n\t    if (prop.value.params.length !== paramCount) {\n\t      var start = prop.value.start;\n\t      if (prop.kind === \"get\")\n\t        { this.raiseRecoverable(start, \"getter should have no params\"); }\n\t      else\n\t        { this.raiseRecoverable(start, \"setter should have exactly one param\"); }\n\t    } else {\n\t      if (prop.kind === \"set\" && prop.value.params[0].type === \"RestElement\")\n\t        { this.raiseRecoverable(prop.value.params[0].start, \"Setter cannot use rest params\"); }\n\t    }\n\t  } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === \"Identifier\") {\n\t    if (isGenerator || isAsync) { this.unexpected(); }\n\t    this.checkUnreserved(prop.key);\n\t    if (prop.key.name === \"await\" && !this.awaitIdentPos)\n\t      { this.awaitIdentPos = startPos; }\n\t    prop.kind = \"init\";\n\t    if (isPattern) {\n\t      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);\n\t    } else if (this.type === types.eq && refDestructuringErrors) {\n\t      if (refDestructuringErrors.shorthandAssign < 0)\n\t        { refDestructuringErrors.shorthandAssign = this.start; }\n\t      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);\n\t    } else {\n\t      prop.value = prop.key;\n\t    }\n\t    prop.shorthand = true;\n\t  } else { this.unexpected(); }\n\t};\n\n\tpp$3.parsePropertyName = function(prop) {\n\t  if (this.options.ecmaVersion >= 6) {\n\t    if (this.eat(types.bracketL)) {\n\t      prop.computed = true;\n\t      prop.key = this.parseMaybeAssign();\n\t      this.expect(types.bracketR);\n\t      return prop.key\n\t    } else {\n\t      prop.computed = false;\n\t    }\n\t  }\n\t  return prop.key = this.type === types.num || this.type === types.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== \"never\")\n\t};\n\n\t// Initialize empty function node.\n\n\tpp$3.initFunction = function(node) {\n\t  node.id = null;\n\t  if (this.options.ecmaVersion >= 6) { node.generator = node.expression = false; }\n\t  if (this.options.ecmaVersion >= 8) { node.async = false; }\n\t};\n\n\t// Parse object or class method.\n\n\tpp$3.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {\n\t  var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\n\n\t  this.initFunction(node);\n\t  if (this.options.ecmaVersion >= 6)\n\t    { node.generator = isGenerator; }\n\t  if (this.options.ecmaVersion >= 8)\n\t    { node.async = !!isAsync; }\n\n\t  this.yieldPos = 0;\n\t  this.awaitPos = 0;\n\t  this.awaitIdentPos = 0;\n\t  this.enterScope(functionFlags(isAsync, node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));\n\n\t  this.expect(types.parenL);\n\t  node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);\n\t  this.checkYieldAwaitInDefaultParams();\n\t  this.parseFunctionBody(node, false, true);\n\n\t  this.yieldPos = oldYieldPos;\n\t  this.awaitPos = oldAwaitPos;\n\t  this.awaitIdentPos = oldAwaitIdentPos;\n\t  return this.finishNode(node, \"FunctionExpression\")\n\t};\n\n\t// Parse arrow function expression with given parameters.\n\n\tpp$3.parseArrowExpression = function(node, params, isAsync) {\n\t  var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\n\n\t  this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);\n\t  this.initFunction(node);\n\t  if (this.options.ecmaVersion >= 8) { node.async = !!isAsync; }\n\n\t  this.yieldPos = 0;\n\t  this.awaitPos = 0;\n\t  this.awaitIdentPos = 0;\n\n\t  node.params = this.toAssignableList(params, true);\n\t  this.parseFunctionBody(node, true, false);\n\n\t  this.yieldPos = oldYieldPos;\n\t  this.awaitPos = oldAwaitPos;\n\t  this.awaitIdentPos = oldAwaitIdentPos;\n\t  return this.finishNode(node, \"ArrowFunctionExpression\")\n\t};\n\n\t// Parse function body and check parameters.\n\n\tpp$3.parseFunctionBody = function(node, isArrowFunction, isMethod) {\n\t  var isExpression = isArrowFunction && this.type !== types.braceL;\n\t  var oldStrict = this.strict, useStrict = false;\n\n\t  if (isExpression) {\n\t    node.body = this.parseMaybeAssign();\n\t    node.expression = true;\n\t    this.checkParams(node, false);\n\t  } else {\n\t    var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);\n\t    if (!oldStrict || nonSimple) {\n\t      useStrict = this.strictDirective(this.end);\n\t      // If this is a strict mode function, verify that argument names\n\t      // are not repeated, and it does not try to bind the words `eval`\n\t      // or `arguments`.\n\t      if (useStrict && nonSimple)\n\t        { this.raiseRecoverable(node.start, \"Illegal 'use strict' directive in function with non-simple parameter list\"); }\n\t    }\n\t    // Start a new scope with regard to labels and the `inFunction`\n\t    // flag (restore them to their old value afterwards).\n\t    var oldLabels = this.labels;\n\t    this.labels = [];\n\t    if (useStrict) { this.strict = true; }\n\n\t    // Add the params to varDeclaredNames to ensure that an error is thrown\n\t    // if a let/const declaration in the function clashes with one of the params.\n\t    this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node.params));\n\t    // Ensure the function name isn't a forbidden identifier in strict mode, e.g. 'eval'\n\t    if (this.strict && node.id) { this.checkLVal(node.id, BIND_OUTSIDE); }\n\t    node.body = this.parseBlock(false, undefined, useStrict && !oldStrict);\n\t    node.expression = false;\n\t    this.adaptDirectivePrologue(node.body.body);\n\t    this.labels = oldLabels;\n\t  }\n\t  this.exitScope();\n\t};\n\n\tpp$3.isSimpleParamList = function(params) {\n\t  for (var i = 0, list = params; i < list.length; i += 1)\n\t    {\n\t    var param = list[i];\n\n\t    if (param.type !== \"Identifier\") { return false\n\t  } }\n\t  return true\n\t};\n\n\t// Checks function params for various disallowed patterns such as using \"eval\"\n\t// or \"arguments\" and duplicate parameters.\n\n\tpp$3.checkParams = function(node, allowDuplicates) {\n\t  var nameHash = {};\n\t  for (var i = 0, list = node.params; i < list.length; i += 1)\n\t    {\n\t    var param = list[i];\n\n\t    this.checkLVal(param, BIND_VAR, allowDuplicates ? null : nameHash);\n\t  }\n\t};\n\n\t// Parses a comma-separated list of expressions, and returns them as\n\t// an array. `close` is the token type that ends the list, and\n\t// `allowEmpty` can be turned on to allow subsequent commas with\n\t// nothing in between them to be parsed as `null` (which is needed\n\t// for array literals).\n\n\tpp$3.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {\n\t  var elts = [], first = true;\n\t  while (!this.eat(close)) {\n\t    if (!first) {\n\t      this.expect(types.comma);\n\t      if (allowTrailingComma && this.afterTrailingComma(close)) { break }\n\t    } else { first = false; }\n\n\t    var elt = (void 0);\n\t    if (allowEmpty && this.type === types.comma)\n\t      { elt = null; }\n\t    else if (this.type === types.ellipsis) {\n\t      elt = this.parseSpread(refDestructuringErrors);\n\t      if (refDestructuringErrors && this.type === types.comma && refDestructuringErrors.trailingComma < 0)\n\t        { refDestructuringErrors.trailingComma = this.start; }\n\t    } else {\n\t      elt = this.parseMaybeAssign(false, refDestructuringErrors);\n\t    }\n\t    elts.push(elt);\n\t  }\n\t  return elts\n\t};\n\n\tpp$3.checkUnreserved = function(ref) {\n\t  var start = ref.start;\n\t  var end = ref.end;\n\t  var name = ref.name;\n\n\t  if (this.inGenerator && name === \"yield\")\n\t    { this.raiseRecoverable(start, \"Cannot use 'yield' as identifier inside a generator\"); }\n\t  if (this.inAsync && name === \"await\")\n\t    { this.raiseRecoverable(start, \"Cannot use 'await' as identifier inside an async function\"); }\n\t  if (this.keywords.test(name))\n\t    { this.raise(start, (\"Unexpected keyword '\" + name + \"'\")); }\n\t  if (this.options.ecmaVersion < 6 &&\n\t    this.input.slice(start, end).indexOf(\"\\\\\") !== -1) { return }\n\t  var re = this.strict ? this.reservedWordsStrict : this.reservedWords;\n\t  if (re.test(name)) {\n\t    if (!this.inAsync && name === \"await\")\n\t      { this.raiseRecoverable(start, \"Cannot use keyword 'await' outside an async function\"); }\n\t    this.raiseRecoverable(start, (\"The keyword '\" + name + \"' is reserved\"));\n\t  }\n\t};\n\n\t// Parse the next token as an identifier. If `liberal` is true (used\n\t// when parsing properties), it will also convert keywords into\n\t// identifiers.\n\n\tpp$3.parseIdent = function(liberal, isBinding) {\n\t  var node = this.startNode();\n\t  if (this.type === types.name) {\n\t    node.name = this.value;\n\t  } else if (this.type.keyword) {\n\t    node.name = this.type.keyword;\n\n\t    // To fix https://github.com/acornjs/acorn/issues/575\n\t    // `class` and `function` keywords push new context into this.context.\n\t    // But there is no chance to pop the context if the keyword is consumed as an identifier such as a property name.\n\t    // If the previous token is a dot, this does not apply because the context-managing code already ignored the keyword\n\t    if ((node.name === \"class\" || node.name === \"function\") &&\n\t        (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {\n\t      this.context.pop();\n\t    }\n\t  } else {\n\t    this.unexpected();\n\t  }\n\t  this.next(!!liberal);\n\t  this.finishNode(node, \"Identifier\");\n\t  if (!liberal) {\n\t    this.checkUnreserved(node);\n\t    if (node.name === \"await\" && !this.awaitIdentPos)\n\t      { this.awaitIdentPos = node.start; }\n\t  }\n\t  return node\n\t};\n\n\t// Parses yield expression inside generator.\n\n\tpp$3.parseYield = function(noIn) {\n\t  if (!this.yieldPos) { this.yieldPos = this.start; }\n\n\t  var node = this.startNode();\n\t  this.next();\n\t  if (this.type === types.semi || this.canInsertSemicolon() || (this.type !== types.star && !this.type.startsExpr)) {\n\t    node.delegate = false;\n\t    node.argument = null;\n\t  } else {\n\t    node.delegate = this.eat(types.star);\n\t    node.argument = this.parseMaybeAssign(noIn);\n\t  }\n\t  return this.finishNode(node, \"YieldExpression\")\n\t};\n\n\tpp$3.parseAwait = function() {\n\t  if (!this.awaitPos) { this.awaitPos = this.start; }\n\n\t  var node = this.startNode();\n\t  this.next();\n\t  node.argument = this.parseMaybeUnary(null, false);\n\t  return this.finishNode(node, \"AwaitExpression\")\n\t};\n\n\tvar pp$4 = Parser.prototype;\n\n\t// This function is used to raise exceptions on parse errors. It\n\t// takes an offset integer (into the current `input`) to indicate\n\t// the location of the error, attaches the position to the end\n\t// of the error message, and then raises a `SyntaxError` with that\n\t// message.\n\n\tpp$4.raise = function(pos, message) {\n\t  var loc = getLineInfo(this.input, pos);\n\t  message += \" (\" + loc.line + \":\" + loc.column + \")\";\n\t  var err = new SyntaxError(message);\n\t  err.pos = pos; err.loc = loc; err.raisedAt = this.pos;\n\t  throw err\n\t};\n\n\tpp$4.raiseRecoverable = pp$4.raise;\n\n\tpp$4.curPosition = function() {\n\t  if (this.options.locations) {\n\t    return new Position(this.curLine, this.pos - this.lineStart)\n\t  }\n\t};\n\n\tvar pp$5 = Parser.prototype;\n\n\tvar Scope = function Scope(flags) {\n\t  this.flags = flags;\n\t  // A list of var-declared names in the current lexical scope\n\t  this.var = [];\n\t  // A list of lexically-declared names in the current lexical scope\n\t  this.lexical = [];\n\t  // A list of lexically-declared FunctionDeclaration names in the current lexical scope\n\t  this.functions = [];\n\t};\n\n\t// The functions in this module keep track of declared variables in the current scope in order to detect duplicate variable names.\n\n\tpp$5.enterScope = function(flags) {\n\t  this.scopeStack.push(new Scope(flags));\n\t};\n\n\tpp$5.exitScope = function() {\n\t  this.scopeStack.pop();\n\t};\n\n\t// The spec says:\n\t// > At the top level of a function, or script, function declarations are\n\t// > treated like var declarations rather than like lexical declarations.\n\tpp$5.treatFunctionsAsVarInScope = function(scope) {\n\t  return (scope.flags & SCOPE_FUNCTION) || !this.inModule && (scope.flags & SCOPE_TOP)\n\t};\n\n\tpp$5.declareName = function(name, bindingType, pos) {\n\t  var redeclared = false;\n\t  if (bindingType === BIND_LEXICAL) {\n\t    var scope = this.currentScope();\n\t    redeclared = scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;\n\t    scope.lexical.push(name);\n\t    if (this.inModule && (scope.flags & SCOPE_TOP))\n\t      { delete this.undefinedExports[name]; }\n\t  } else if (bindingType === BIND_SIMPLE_CATCH) {\n\t    var scope$1 = this.currentScope();\n\t    scope$1.lexical.push(name);\n\t  } else if (bindingType === BIND_FUNCTION) {\n\t    var scope$2 = this.currentScope();\n\t    if (this.treatFunctionsAsVar)\n\t      { redeclared = scope$2.lexical.indexOf(name) > -1; }\n\t    else\n\t      { redeclared = scope$2.lexical.indexOf(name) > -1 || scope$2.var.indexOf(name) > -1; }\n\t    scope$2.functions.push(name);\n\t  } else {\n\t    for (var i = this.scopeStack.length - 1; i >= 0; --i) {\n\t      var scope$3 = this.scopeStack[i];\n\t      if (scope$3.lexical.indexOf(name) > -1 && !((scope$3.flags & SCOPE_SIMPLE_CATCH) && scope$3.lexical[0] === name) ||\n\t          !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {\n\t        redeclared = true;\n\t        break\n\t      }\n\t      scope$3.var.push(name);\n\t      if (this.inModule && (scope$3.flags & SCOPE_TOP))\n\t        { delete this.undefinedExports[name]; }\n\t      if (scope$3.flags & SCOPE_VAR) { break }\n\t    }\n\t  }\n\t  if (redeclared) { this.raiseRecoverable(pos, (\"Identifier '\" + name + \"' has already been declared\")); }\n\t};\n\n\tpp$5.checkLocalExport = function(id) {\n\t  // scope.functions must be empty as Module code is always strict.\n\t  if (this.scopeStack[0].lexical.indexOf(id.name) === -1 &&\n\t      this.scopeStack[0].var.indexOf(id.name) === -1) {\n\t    this.undefinedExports[id.name] = id;\n\t  }\n\t};\n\n\tpp$5.currentScope = function() {\n\t  return this.scopeStack[this.scopeStack.length - 1]\n\t};\n\n\tpp$5.currentVarScope = function() {\n\t  for (var i = this.scopeStack.length - 1;; i--) {\n\t    var scope = this.scopeStack[i];\n\t    if (scope.flags & SCOPE_VAR) { return scope }\n\t  }\n\t};\n\n\t// Could be useful for `this`, `new.target`, `super()`, `super.property`, and `super[property]`.\n\tpp$5.currentThisScope = function() {\n\t  for (var i = this.scopeStack.length - 1;; i--) {\n\t    var scope = this.scopeStack[i];\n\t    if (scope.flags & SCOPE_VAR && !(scope.flags & SCOPE_ARROW)) { return scope }\n\t  }\n\t};\n\n\tvar Node = function Node(parser, pos, loc) {\n\t  this.type = \"\";\n\t  this.start = pos;\n\t  this.end = 0;\n\t  if (parser.options.locations)\n\t    { this.loc = new SourceLocation(parser, loc); }\n\t  if (parser.options.directSourceFile)\n\t    { this.sourceFile = parser.options.directSourceFile; }\n\t  if (parser.options.ranges)\n\t    { this.range = [pos, 0]; }\n\t};\n\n\t// Start an AST node, attaching a start offset.\n\n\tvar pp$6 = Parser.prototype;\n\n\tpp$6.startNode = function() {\n\t  return new Node(this, this.start, this.startLoc)\n\t};\n\n\tpp$6.startNodeAt = function(pos, loc) {\n\t  return new Node(this, pos, loc)\n\t};\n\n\t// Finish an AST node, adding `type` and `end` properties.\n\n\tfunction finishNodeAt(node, type, pos, loc) {\n\t  node.type = type;\n\t  node.end = pos;\n\t  if (this.options.locations)\n\t    { node.loc.end = loc; }\n\t  if (this.options.ranges)\n\t    { node.range[1] = pos; }\n\t  return node\n\t}\n\n\tpp$6.finishNode = function(node, type) {\n\t  return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc)\n\t};\n\n\t// Finish node at given position\n\n\tpp$6.finishNodeAt = function(node, type, pos, loc) {\n\t  return finishNodeAt.call(this, node, type, pos, loc)\n\t};\n\n\t// The algorithm used to determine whether a regexp can appear at a\n\n\tvar TokContext = function TokContext(token, isExpr, preserveSpace, override, generator) {\n\t  this.token = token;\n\t  this.isExpr = !!isExpr;\n\t  this.preserveSpace = !!preserveSpace;\n\t  this.override = override;\n\t  this.generator = !!generator;\n\t};\n\n\tvar types$1 = {\n\t  b_stat: new TokContext(\"{\", false),\n\t  b_expr: new TokContext(\"{\", true),\n\t  b_tmpl: new TokContext(\"${\", false),\n\t  p_stat: new TokContext(\"(\", false),\n\t  p_expr: new TokContext(\"(\", true),\n\t  q_tmpl: new TokContext(\"`\", true, true, function (p) { return p.tryReadTemplateToken(); }),\n\t  f_stat: new TokContext(\"function\", false),\n\t  f_expr: new TokContext(\"function\", true),\n\t  f_expr_gen: new TokContext(\"function\", true, false, null, true),\n\t  f_gen: new TokContext(\"function\", false, false, null, true)\n\t};\n\n\tvar pp$7 = Parser.prototype;\n\n\tpp$7.initialContext = function() {\n\t  return [types$1.b_stat]\n\t};\n\n\tpp$7.braceIsBlock = function(prevType) {\n\t  var parent = this.curContext();\n\t  if (parent === types$1.f_expr || parent === types$1.f_stat)\n\t    { return true }\n\t  if (prevType === types.colon && (parent === types$1.b_stat || parent === types$1.b_expr))\n\t    { return !parent.isExpr }\n\n\t  // The check for `tt.name && exprAllowed` detects whether we are\n\t  // after a `yield` or `of` construct. See the `updateContext` for\n\t  // `tt.name`.\n\t  if (prevType === types._return || prevType === types.name && this.exprAllowed)\n\t    { return lineBreak.test(this.input.slice(this.lastTokEnd, this.start)) }\n\t  if (prevType === types._else || prevType === types.semi || prevType === types.eof || prevType === types.parenR || prevType === types.arrow)\n\t    { return true }\n\t  if (prevType === types.braceL)\n\t    { return parent === types$1.b_stat }\n\t  if (prevType === types._var || prevType === types._const || prevType === types.name)\n\t    { return false }\n\t  return !this.exprAllowed\n\t};\n\n\tpp$7.inGeneratorContext = function() {\n\t  for (var i = this.context.length - 1; i >= 1; i--) {\n\t    var context = this.context[i];\n\t    if (context.token === \"function\")\n\t      { return context.generator }\n\t  }\n\t  return false\n\t};\n\n\tpp$7.updateContext = function(prevType) {\n\t  var update, type = this.type;\n\t  if (type.keyword && prevType === types.dot)\n\t    { this.exprAllowed = false; }\n\t  else if (update = type.updateContext)\n\t    { update.call(this, prevType); }\n\t  else\n\t    { this.exprAllowed = type.beforeExpr; }\n\t};\n\n\t// Token-specific context update code\n\n\ttypes.parenR.updateContext = types.braceR.updateContext = function() {\n\t  if (this.context.length === 1) {\n\t    this.exprAllowed = true;\n\t    return\n\t  }\n\t  var out = this.context.pop();\n\t  if (out === types$1.b_stat && this.curContext().token === \"function\") {\n\t    out = this.context.pop();\n\t  }\n\t  this.exprAllowed = !out.isExpr;\n\t};\n\n\ttypes.braceL.updateContext = function(prevType) {\n\t  this.context.push(this.braceIsBlock(prevType) ? types$1.b_stat : types$1.b_expr);\n\t  this.exprAllowed = true;\n\t};\n\n\ttypes.dollarBraceL.updateContext = function() {\n\t  this.context.push(types$1.b_tmpl);\n\t  this.exprAllowed = true;\n\t};\n\n\ttypes.parenL.updateContext = function(prevType) {\n\t  var statementParens = prevType === types._if || prevType === types._for || prevType === types._with || prevType === types._while;\n\t  this.context.push(statementParens ? types$1.p_stat : types$1.p_expr);\n\t  this.exprAllowed = true;\n\t};\n\n\ttypes.incDec.updateContext = function() {\n\t  // tokExprAllowed stays unchanged\n\t};\n\n\ttypes._function.updateContext = types._class.updateContext = function(prevType) {\n\t  if (prevType.beforeExpr && prevType !== types.semi && prevType !== types._else &&\n\t      !(prevType === types._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) &&\n\t      !((prevType === types.colon || prevType === types.braceL) && this.curContext() === types$1.b_stat))\n\t    { this.context.push(types$1.f_expr); }\n\t  else\n\t    { this.context.push(types$1.f_stat); }\n\t  this.exprAllowed = false;\n\t};\n\n\ttypes.backQuote.updateContext = function() {\n\t  if (this.curContext() === types$1.q_tmpl)\n\t    { this.context.pop(); }\n\t  else\n\t    { this.context.push(types$1.q_tmpl); }\n\t  this.exprAllowed = false;\n\t};\n\n\ttypes.star.updateContext = function(prevType) {\n\t  if (prevType === types._function) {\n\t    var index = this.context.length - 1;\n\t    if (this.context[index] === types$1.f_expr)\n\t      { this.context[index] = types$1.f_expr_gen; }\n\t    else\n\t      { this.context[index] = types$1.f_gen; }\n\t  }\n\t  this.exprAllowed = true;\n\t};\n\n\ttypes.name.updateContext = function(prevType) {\n\t  var allowed = false;\n\t  if (this.options.ecmaVersion >= 6 && prevType !== types.dot) {\n\t    if (this.value === \"of\" && !this.exprAllowed ||\n\t        this.value === \"yield\" && this.inGeneratorContext())\n\t      { allowed = true; }\n\t  }\n\t  this.exprAllowed = allowed;\n\t};\n\n\t// This file contains Unicode properties extracted from the ECMAScript\n\t// specification. The lists are extracted like so:\n\t// $$('#table-binary-unicode-properties > figure > table > tbody > tr > td:nth-child(1) code').map(el => el.innerText)\n\n\t// #table-binary-unicode-properties\n\tvar ecma9BinaryProperties = \"ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS\";\n\tvar ecma10BinaryProperties = ecma9BinaryProperties + \" Extended_Pictographic\";\n\tvar ecma11BinaryProperties = ecma10BinaryProperties;\n\tvar unicodeBinaryProperties = {\n\t  9: ecma9BinaryProperties,\n\t  10: ecma10BinaryProperties,\n\t  11: ecma11BinaryProperties\n\t};\n\n\t// #table-unicode-general-category-values\n\tvar unicodeGeneralCategoryValues = \"Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu\";\n\n\t// #table-unicode-script-values\n\tvar ecma9ScriptValues = \"Adlam Adlm Ahom Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb\";\n\tvar ecma10ScriptValues = ecma9ScriptValues + \" Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd\";\n\tvar ecma11ScriptValues = ecma10ScriptValues + \" Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho\";\n\tvar unicodeScriptValues = {\n\t  9: ecma9ScriptValues,\n\t  10: ecma10ScriptValues,\n\t  11: ecma11ScriptValues\n\t};\n\n\tvar data = {};\n\tfunction buildUnicodeData(ecmaVersion) {\n\t  var d = data[ecmaVersion] = {\n\t    binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion] + \" \" + unicodeGeneralCategoryValues),\n\t    nonBinary: {\n\t      General_Category: wordsRegexp(unicodeGeneralCategoryValues),\n\t      Script: wordsRegexp(unicodeScriptValues[ecmaVersion])\n\t    }\n\t  };\n\t  d.nonBinary.Script_Extensions = d.nonBinary.Script;\n\n\t  d.nonBinary.gc = d.nonBinary.General_Category;\n\t  d.nonBinary.sc = d.nonBinary.Script;\n\t  d.nonBinary.scx = d.nonBinary.Script_Extensions;\n\t}\n\tbuildUnicodeData(9);\n\tbuildUnicodeData(10);\n\tbuildUnicodeData(11);\n\n\tvar pp$8 = Parser.prototype;\n\n\tvar RegExpValidationState = function RegExpValidationState(parser) {\n\t  this.parser = parser;\n\t  this.validFlags = \"gim\" + (parser.options.ecmaVersion >= 6 ? \"uy\" : \"\") + (parser.options.ecmaVersion >= 9 ? \"s\" : \"\");\n\t  this.unicodeProperties = data[parser.options.ecmaVersion >= 11 ? 11 : parser.options.ecmaVersion];\n\t  this.source = \"\";\n\t  this.flags = \"\";\n\t  this.start = 0;\n\t  this.switchU = false;\n\t  this.switchN = false;\n\t  this.pos = 0;\n\t  this.lastIntValue = 0;\n\t  this.lastStringValue = \"\";\n\t  this.lastAssertionIsQuantifiable = false;\n\t  this.numCapturingParens = 0;\n\t  this.maxBackReference = 0;\n\t  this.groupNames = [];\n\t  this.backReferenceNames = [];\n\t};\n\n\tRegExpValidationState.prototype.reset = function reset (start, pattern, flags) {\n\t  var unicode = flags.indexOf(\"u\") !== -1;\n\t  this.start = start | 0;\n\t  this.source = pattern + \"\";\n\t  this.flags = flags;\n\t  this.switchU = unicode && this.parser.options.ecmaVersion >= 6;\n\t  this.switchN = unicode && this.parser.options.ecmaVersion >= 9;\n\t};\n\n\tRegExpValidationState.prototype.raise = function raise (message) {\n\t  this.parser.raiseRecoverable(this.start, (\"Invalid regular expression: /\" + (this.source) + \"/: \" + message));\n\t};\n\n\t// If u flag is given, this returns the code point at the index (it combines a surrogate pair).\n\t// Otherwise, this returns the code unit of the index (can be a part of a surrogate pair).\n\tRegExpValidationState.prototype.at = function at (i, forceU) {\n\t    if ( forceU === void 0 ) forceU = false;\n\n\t  var s = this.source;\n\t  var l = s.length;\n\t  if (i >= l) {\n\t    return -1\n\t  }\n\t  var c = s.charCodeAt(i);\n\t  if (!(forceU || this.switchU) || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l) {\n\t    return c\n\t  }\n\t  var next = s.charCodeAt(i + 1);\n\t  return next >= 0xDC00 && next <= 0xDFFF ? (c << 10) + next - 0x35FDC00 : c\n\t};\n\n\tRegExpValidationState.prototype.nextIndex = function nextIndex (i, forceU) {\n\t    if ( forceU === void 0 ) forceU = false;\n\n\t  var s = this.source;\n\t  var l = s.length;\n\t  if (i >= l) {\n\t    return l\n\t  }\n\t  var c = s.charCodeAt(i), next;\n\t  if (!(forceU || this.switchU) || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l ||\n\t      (next = s.charCodeAt(i + 1)) < 0xDC00 || next > 0xDFFF) {\n\t    return i + 1\n\t  }\n\t  return i + 2\n\t};\n\n\tRegExpValidationState.prototype.current = function current (forceU) {\n\t    if ( forceU === void 0 ) forceU = false;\n\n\t  return this.at(this.pos, forceU)\n\t};\n\n\tRegExpValidationState.prototype.lookahead = function lookahead (forceU) {\n\t    if ( forceU === void 0 ) forceU = false;\n\n\t  return this.at(this.nextIndex(this.pos, forceU), forceU)\n\t};\n\n\tRegExpValidationState.prototype.advance = function advance (forceU) {\n\t    if ( forceU === void 0 ) forceU = false;\n\n\t  this.pos = this.nextIndex(this.pos, forceU);\n\t};\n\n\tRegExpValidationState.prototype.eat = function eat (ch, forceU) {\n\t    if ( forceU === void 0 ) forceU = false;\n\n\t  if (this.current(forceU) === ch) {\n\t    this.advance(forceU);\n\t    return true\n\t  }\n\t  return false\n\t};\n\n\tfunction codePointToString(ch) {\n\t  if (ch <= 0xFFFF) { return String.fromCharCode(ch) }\n\t  ch -= 0x10000;\n\t  return String.fromCharCode((ch >> 10) + 0xD800, (ch & 0x03FF) + 0xDC00)\n\t}\n\n\t/**\n\t * Validate the flags part of a given RegExpLiteral.\n\t *\n\t * @param {RegExpValidationState} state The state to validate RegExp.\n\t * @returns {void}\n\t */\n\tpp$8.validateRegExpFlags = function(state) {\n\t  var validFlags = state.validFlags;\n\t  var flags = state.flags;\n\n\t  for (var i = 0; i < flags.length; i++) {\n\t    var flag = flags.charAt(i);\n\t    if (validFlags.indexOf(flag) === -1) {\n\t      this.raise(state.start, \"Invalid regular expression flag\");\n\t    }\n\t    if (flags.indexOf(flag, i + 1) > -1) {\n\t      this.raise(state.start, \"Duplicate regular expression flag\");\n\t    }\n\t  }\n\t};\n\n\t/**\n\t * Validate the pattern part of a given RegExpLiteral.\n\t *\n\t * @param {RegExpValidationState} state The state to validate RegExp.\n\t * @returns {void}\n\t */\n\tpp$8.validateRegExpPattern = function(state) {\n\t  this.regexp_pattern(state);\n\n\t  // The goal symbol for the parse is |Pattern[~U, ~N]|. If the result of\n\t  // parsing contains a |GroupName|, reparse with the goal symbol\n\t  // |Pattern[~U, +N]| and use this result instead. Throw a *SyntaxError*\n\t  // exception if _P_ did not conform to the grammar, if any elements of _P_\n\t  // were not matched by the parse, or if any Early Error conditions exist.\n\t  if (!state.switchN && this.options.ecmaVersion >= 9 && state.groupNames.length > 0) {\n\t    state.switchN = true;\n\t    this.regexp_pattern(state);\n\t  }\n\t};\n\n\t// https://www.ecma-international.org/ecma-262/8.0/#prod-Pattern\n\tpp$8.regexp_pattern = function(state) {\n\t  state.pos = 0;\n\t  state.lastIntValue = 0;\n\t  state.lastStringValue = \"\";\n\t  state.lastAssertionIsQuantifiable = false;\n\t  state.numCapturingParens = 0;\n\t  state.maxBackReference = 0;\n\t  state.groupNames.length = 0;\n\t  state.backReferenceNames.length = 0;\n\n\t  this.regexp_disjunction(state);\n\n\t  if (state.pos !== state.source.length) {\n\t    // Make the same messages as V8.\n\t    if (state.eat(0x29 /* ) */)) {\n\t      state.raise(\"Unmatched ')'\");\n\t    }\n\t    if (state.eat(0x5D /* ] */) || state.eat(0x7D /* } */)) {\n\t      state.raise(\"Lone quantifier brackets\");\n\t    }\n\t  }\n\t  if (state.maxBackReference > state.numCapturingParens) {\n\t    state.raise(\"Invalid escape\");\n\t  }\n\t  for (var i = 0, list = state.backReferenceNames; i < list.length; i += 1) {\n\t    var name = list[i];\n\n\t    if (state.groupNames.indexOf(name) === -1) {\n\t      state.raise(\"Invalid named capture referenced\");\n\t    }\n\t  }\n\t};\n\n\t// https://www.ecma-international.org/ecma-262/8.0/#prod-Disjunction\n\tpp$8.regexp_disjunction = function(state) {\n\t  this.regexp_alternative(state);\n\t  while (state.eat(0x7C /* | */)) {\n\t    this.regexp_alternative(state);\n\t  }\n\n\t  // Make the same message as V8.\n\t  if (this.regexp_eatQuantifier(state, true)) {\n\t    state.raise(\"Nothing to repeat\");\n\t  }\n\t  if (state.eat(0x7B /* { */)) {\n\t    state.raise(\"Lone quantifier brackets\");\n\t  }\n\t};\n\n\t// https://www.ecma-international.org/ecma-262/8.0/#prod-Alternative\n\tpp$8.regexp_alternative = function(state) {\n\t  while (state.pos < state.source.length && this.regexp_eatTerm(state))\n\t    { }\n\t};\n\n\t// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Term\n\tpp$8.regexp_eatTerm = function(state) {\n\t  if (this.regexp_eatAssertion(state)) {\n\t    // Handle `QuantifiableAssertion Quantifier` alternative.\n\t    // `state.lastAssertionIsQuantifiable` is true if the last eaten Assertion\n\t    // is a QuantifiableAssertion.\n\t    if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {\n\t      // Make the same message as V8.\n\t      if (state.switchU) {\n\t        state.raise(\"Invalid quantifier\");\n\t      }\n\t    }\n\t    return true\n\t  }\n\n\t  if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {\n\t    this.regexp_eatQuantifier(state);\n\t    return true\n\t  }\n\n\t  return false\n\t};\n\n\t// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Assertion\n\tpp$8.regexp_eatAssertion = function(state) {\n\t  var start = state.pos;\n\t  state.lastAssertionIsQuantifiable = false;\n\n\t  // ^, $\n\t  if (state.eat(0x5E /* ^ */) || state.eat(0x24 /* $ */)) {\n\t    return true\n\t  }\n\n\t  // \\b \\B\n\t  if (state.eat(0x5C /* \\ */)) {\n\t    if (state.eat(0x42 /* B */) || state.eat(0x62 /* b */)) {\n\t      return true\n\t    }\n\t    state.pos = start;\n\t  }\n\n\t  // Lookahead / Lookbehind\n\t  if (state.eat(0x28 /* ( */) && state.eat(0x3F /* ? */)) {\n\t    var lookbehind = false;\n\t    if (this.options.ecmaVersion >= 9) {\n\t      lookbehind = state.eat(0x3C /* < */);\n\t    }\n\t    if (state.eat(0x3D /* = */) || state.eat(0x21 /* ! */)) {\n\t      this.regexp_disjunction(state);\n\t      if (!state.eat(0x29 /* ) */)) {\n\t        state.raise(\"Unterminated group\");\n\t      }\n\t      state.lastAssertionIsQuantifiable = !lookbehind;\n\t      return true\n\t    }\n\t  }\n\n\t  state.pos = start;\n\t  return false\n\t};\n\n\t// https://www.ecma-international.org/ecma-262/8.0/#prod-Quantifier\n\tpp$8.regexp_eatQuantifier = function(state, noError) {\n\t  if ( noError === void 0 ) noError = false;\n\n\t  if (this.regexp_eatQuantifierPrefix(state, noError)) {\n\t    state.eat(0x3F /* ? */);\n\t    return true\n\t  }\n\t  return false\n\t};\n\n\t// https://www.ecma-international.org/ecma-262/8.0/#prod-QuantifierPrefix\n\tpp$8.regexp_eatQuantifierPrefix = function(state, noError) {\n\t  return (\n\t    state.eat(0x2A /* * */) ||\n\t    state.eat(0x2B /* + */) ||\n\t    state.eat(0x3F /* ? */) ||\n\t    this.regexp_eatBracedQuantifier(state, noError)\n\t  )\n\t};\n\tpp$8.regexp_eatBracedQuantifier = function(state, noError) {\n\t  var start = state.pos;\n\t  if (state.eat(0x7B /* { */)) {\n\t    var min = 0, max = -1;\n\t    if (this.regexp_eatDecimalDigits(state)) {\n\t      min = state.lastIntValue;\n\t      if (state.eat(0x2C /* , */) && this.regexp_eatDecimalDigits(state)) {\n\t        max = state.lastIntValue;\n\t      }\n\t      if (state.eat(0x7D /* } */)) {\n\t        // SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-term\n\t        if (max !== -1 && max < min && !noError) {\n\t          state.raise(\"numbers out of order in {} quantifier\");\n\t        }\n\t        return true\n\t      }\n\t    }\n\t    if (state.switchU && !noError) {\n\t      state.raise(\"Incomplete quantifier\");\n\t    }\n\t    state.pos = start;\n\t  }\n\t  return false\n\t};\n\n\t// https://www.ecma-international.org/ecma-262/8.0/#prod-Atom\n\tpp$8.regexp_eatAtom = function(state) {\n\t  return (\n\t    this.regexp_eatPatternCharacters(state) ||\n\t    state.eat(0x2E /* . */) ||\n\t    this.regexp_eatReverseSolidusAtomEscape(state) ||\n\t    this.regexp_eatCharacterClass(state) ||\n\t    this.regexp_eatUncapturingGroup(state) ||\n\t    this.regexp_eatCapturingGroup(state)\n\t  )\n\t};\n\tpp$8.regexp_eatReverseSolidusAtomEscape = function(state) {\n\t  var start = state.pos;\n\t  if (state.eat(0x5C /* \\ */)) {\n\t    if (this.regexp_eatAtomEscape(state)) {\n\t      return true\n\t    }\n\t    state.pos = start;\n\t  }\n\t  return false\n\t};\n\tpp$8.regexp_eatUncapturingGroup = function(state) {\n\t  var start = state.pos;\n\t  if (state.eat(0x28 /* ( */)) {\n\t    if (state.eat(0x3F /* ? */) && state.eat(0x3A /* : */)) {\n\t      this.regexp_disjunction(state);\n\t      if (state.eat(0x29 /* ) */)) {\n\t        return true\n\t      }\n\t      state.raise(\"Unterminated group\");\n\t    }\n\t    state.pos = start;\n\t  }\n\t  return false\n\t};\n\tpp$8.regexp_eatCapturingGroup = function(state) {\n\t  if (state.eat(0x28 /* ( */)) {\n\t    if (this.options.ecmaVersion >= 9) {\n\t      this.regexp_groupSpecifier(state);\n\t    } else if (state.current() === 0x3F /* ? */) {\n\t      state.raise(\"Invalid group\");\n\t    }\n\t    this.regexp_disjunction(state);\n\t    if (state.eat(0x29 /* ) */)) {\n\t      state.numCapturingParens += 1;\n\t      return true\n\t    }\n\t    state.raise(\"Unterminated group\");\n\t  }\n\t  return false\n\t};\n\n\t// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedAtom\n\tpp$8.regexp_eatExtendedAtom = function(state) {\n\t  return (\n\t    state.eat(0x2E /* . */) ||\n\t    this.regexp_eatReverseSolidusAtomEscape(state) ||\n\t    this.regexp_eatCharacterClass(state) ||\n\t    this.regexp_eatUncapturingGroup(state) ||\n\t    this.regexp_eatCapturingGroup(state) ||\n\t    this.regexp_eatInvalidBracedQuantifier(state) ||\n\t    this.regexp_eatExtendedPatternCharacter(state)\n\t  )\n\t};\n\n\t// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-InvalidBracedQuantifier\n\tpp$8.regexp_eatInvalidBracedQuantifier = function(state) {\n\t  if (this.regexp_eatBracedQuantifier(state, true)) {\n\t    state.raise(\"Nothing to repeat\");\n\t  }\n\t  return false\n\t};\n\n\t// https://www.ecma-international.org/ecma-262/8.0/#prod-SyntaxCharacter\n\tpp$8.regexp_eatSyntaxCharacter = function(state) {\n\t  var ch = state.current();\n\t  if (isSyntaxCharacter(ch)) {\n\t    state.lastIntValue = ch;\n\t    state.advance();\n\t    return true\n\t  }\n\t  return false\n\t};\n\tfunction isSyntaxCharacter(ch) {\n\t  return (\n\t    ch === 0x24 /* $ */ ||\n\t    ch >= 0x28 /* ( */ && ch <= 0x2B /* + */ ||\n\t    ch === 0x2E /* . */ ||\n\t    ch === 0x3F /* ? */ ||\n\t    ch >= 0x5B /* [ */ && ch <= 0x5E /* ^ */ ||\n\t    ch >= 0x7B /* { */ && ch <= 0x7D /* } */\n\t  )\n\t}\n\n\t// https://www.ecma-international.org/ecma-262/8.0/#prod-PatternCharacter\n\t// But eat eager.\n\tpp$8.regexp_eatPatternCharacters = function(state) {\n\t  var start = state.pos;\n\t  var ch = 0;\n\t  while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) {\n\t    state.advance();\n\t  }\n\t  return state.pos !== start\n\t};\n\n\t// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedPatternCharacter\n\tpp$8.regexp_eatExtendedPatternCharacter = function(state) {\n\t  var ch = state.current();\n\t  if (\n\t    ch !== -1 &&\n\t    ch !== 0x24 /* $ */ &&\n\t    !(ch >= 0x28 /* ( */ && ch <= 0x2B /* + */) &&\n\t    ch !== 0x2E /* . */ &&\n\t    ch !== 0x3F /* ? */ &&\n\t    ch !== 0x5B /* [ */ &&\n\t    ch !== 0x5E /* ^ */ &&\n\t    ch !== 0x7C /* | */\n\t  ) {\n\t    state.advance();\n\t    return true\n\t  }\n\t  return false\n\t};\n\n\t// GroupSpecifier ::\n\t//   [empty]\n\t//   `?` GroupName\n\tpp$8.regexp_groupSpecifier = function(state) {\n\t  if (state.eat(0x3F /* ? */)) {\n\t    if (this.regexp_eatGroupName(state)) {\n\t      if (state.groupNames.indexOf(state.lastStringValue) !== -1) {\n\t        state.raise(\"Duplicate capture group name\");\n\t      }\n\t      state.groupNames.push(state.lastStringValue);\n\t      return\n\t    }\n\t    state.raise(\"Invalid group\");\n\t  }\n\t};\n\n\t// GroupName ::\n\t//   `<` RegExpIdentifierName `>`\n\t// Note: this updates `state.lastStringValue` property with the eaten name.\n\tpp$8.regexp_eatGroupName = function(state) {\n\t  state.lastStringValue = \"\";\n\t  if (state.eat(0x3C /* < */)) {\n\t    if (this.regexp_eatRegExpIdentifierName(state) && state.eat(0x3E /* > */)) {\n\t      return true\n\t    }\n\t    state.raise(\"Invalid capture group name\");\n\t  }\n\t  return false\n\t};\n\n\t// RegExpIdentifierName ::\n\t//   RegExpIdentifierStart\n\t//   RegExpIdentifierName RegExpIdentifierPart\n\t// Note: this updates `state.lastStringValue` property with the eaten name.\n\tpp$8.regexp_eatRegExpIdentifierName = function(state) {\n\t  state.lastStringValue = \"\";\n\t  if (this.regexp_eatRegExpIdentifierStart(state)) {\n\t    state.lastStringValue += codePointToString(state.lastIntValue);\n\t    while (this.regexp_eatRegExpIdentifierPart(state)) {\n\t      state.lastStringValue += codePointToString(state.lastIntValue);\n\t    }\n\t    return true\n\t  }\n\t  return false\n\t};\n\n\t// RegExpIdentifierStart ::\n\t//   UnicodeIDStart\n\t//   `$`\n\t//   `_`\n\t//   `\\` RegExpUnicodeEscapeSequence[+U]\n\tpp$8.regexp_eatRegExpIdentifierStart = function(state) {\n\t  var start = state.pos;\n\t  var forceU = this.options.ecmaVersion >= 11;\n\t  var ch = state.current(forceU);\n\t  state.advance(forceU);\n\n\t  if (ch === 0x5C /* \\ */ && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {\n\t    ch = state.lastIntValue;\n\t  }\n\t  if (isRegExpIdentifierStart(ch)) {\n\t    state.lastIntValue = ch;\n\t    return true\n\t  }\n\n\t  state.pos = start;\n\t  return false\n\t};\n\tfunction isRegExpIdentifierStart(ch) {\n\t  return isIdentifierStart(ch, true) || ch === 0x24 /* $ */ || ch === 0x5F /* _ */\n\t}\n\n\t// RegExpIdentifierPart ::\n\t//   UnicodeIDContinue\n\t//   `$`\n\t//   `_`\n\t//   `\\` RegExpUnicodeEscapeSequence[+U]\n\t//   <ZWNJ>\n\t//   <ZWJ>\n\tpp$8.regexp_eatRegExpIdentifierPart = function(state) {\n\t  var start = state.pos;\n\t  var forceU = this.options.ecmaVersion >= 11;\n\t  var ch = state.current(forceU);\n\t  state.advance(forceU);\n\n\t  if (ch === 0x5C /* \\ */ && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {\n\t    ch = state.lastIntValue;\n\t  }\n\t  if (isRegExpIdentifierPart(ch)) {\n\t    state.lastIntValue = ch;\n\t    return true\n\t  }\n\n\t  state.pos = start;\n\t  return false\n\t};\n\tfunction isRegExpIdentifierPart(ch) {\n\t  return isIdentifierChar(ch, true) || ch === 0x24 /* $ */ || ch === 0x5F /* _ */ || ch === 0x200C /* <ZWNJ> */ || ch === 0x200D /* <ZWJ> */\n\t}\n\n\t// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-AtomEscape\n\tpp$8.regexp_eatAtomEscape = function(state) {\n\t  if (\n\t    this.regexp_eatBackReference(state) ||\n\t    this.regexp_eatCharacterClassEscape(state) ||\n\t    this.regexp_eatCharacterEscape(state) ||\n\t    (state.switchN && this.regexp_eatKGroupName(state))\n\t  ) {\n\t    return true\n\t  }\n\t  if (state.switchU) {\n\t    // Make the same message as V8.\n\t    if (state.current() === 0x63 /* c */) {\n\t      state.raise(\"Invalid unicode escape\");\n\t    }\n\t    state.raise(\"Invalid escape\");\n\t  }\n\t  return false\n\t};\n\tpp$8.regexp_eatBackReference = function(state) {\n\t  var start = state.pos;\n\t  if (this.regexp_eatDecimalEscape(state)) {\n\t    var n = state.lastIntValue;\n\t    if (state.switchU) {\n\t      // For SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-atomescape\n\t      if (n > state.maxBackReference) {\n\t        state.maxBackReference = n;\n\t      }\n\t      return true\n\t    }\n\t    if (n <= state.numCapturingParens) {\n\t      return true\n\t    }\n\t    state.pos = start;\n\t  }\n\t  return false\n\t};\n\tpp$8.regexp_eatKGroupName = function(state) {\n\t  if (state.eat(0x6B /* k */)) {\n\t    if (this.regexp_eatGroupName(state)) {\n\t      state.backReferenceNames.push(state.lastStringValue);\n\t      return true\n\t    }\n\t    state.raise(\"Invalid named reference\");\n\t  }\n\t  return false\n\t};\n\n\t// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-CharacterEscape\n\tpp$8.regexp_eatCharacterEscape = function(state) {\n\t  return (\n\t    this.regexp_eatControlEscape(state) ||\n\t    this.regexp_eatCControlLetter(state) ||\n\t    this.regexp_eatZero(state) ||\n\t    this.regexp_eatHexEscapeSequence(state) ||\n\t    this.regexp_eatRegExpUnicodeEscapeSequence(state, false) ||\n\t    (!state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state)) ||\n\t    this.regexp_eatIdentityEscape(state)\n\t  )\n\t};\n\tpp$8.regexp_eatCControlLetter = function(state) {\n\t  var start = state.pos;\n\t  if (state.eat(0x63 /* c */)) {\n\t    if (this.regexp_eatControlLetter(state)) {\n\t      return true\n\t    }\n\t    state.pos = start;\n\t  }\n\t  return false\n\t};\n\tpp$8.regexp_eatZero = function(state) {\n\t  if (state.current() === 0x30 /* 0 */ && !isDecimalDigit(state.lookahead())) {\n\t    state.lastIntValue = 0;\n\t    state.advance();\n\t    return true\n\t  }\n\t  return false\n\t};\n\n\t// https://www.ecma-international.org/ecma-262/8.0/#prod-ControlEscape\n\tpp$8.regexp_eatControlEscape = function(state) {\n\t  var ch = state.current();\n\t  if (ch === 0x74 /* t */) {\n\t    state.lastIntValue = 0x09; /* \\t */\n\t    state.advance();\n\t    return true\n\t  }\n\t  if (ch === 0x6E /* n */) {\n\t    state.lastIntValue = 0x0A; /* \\n */\n\t    state.advance();\n\t    return true\n\t  }\n\t  if (ch === 0x76 /* v */) {\n\t    state.lastIntValue = 0x0B; /* \\v */\n\t    state.advance();\n\t    return true\n\t  }\n\t  if (ch === 0x66 /* f */) {\n\t    state.lastIntValue = 0x0C; /* \\f */\n\t    state.advance();\n\t    return true\n\t  }\n\t  if (ch === 0x72 /* r */) {\n\t    state.lastIntValue = 0x0D; /* \\r */\n\t    state.advance();\n\t    return true\n\t  }\n\t  return false\n\t};\n\n\t// https://www.ecma-international.org/ecma-262/8.0/#prod-ControlLetter\n\tpp$8.regexp_eatControlLetter = function(state) {\n\t  var ch = state.current();\n\t  if (isControlLetter(ch)) {\n\t    state.lastIntValue = ch % 0x20;\n\t    state.advance();\n\t    return true\n\t  }\n\t  return false\n\t};\n\tfunction isControlLetter(ch) {\n\t  return (\n\t    (ch >= 0x41 /* A */ && ch <= 0x5A /* Z */) ||\n\t    (ch >= 0x61 /* a */ && ch <= 0x7A /* z */)\n\t  )\n\t}\n\n\t// https://www.ecma-international.org/ecma-262/8.0/#prod-RegExpUnicodeEscapeSequence\n\tpp$8.regexp_eatRegExpUnicodeEscapeSequence = function(state, forceU) {\n\t  if ( forceU === void 0 ) forceU = false;\n\n\t  var start = state.pos;\n\t  var switchU = forceU || state.switchU;\n\n\t  if (state.eat(0x75 /* u */)) {\n\t    if (this.regexp_eatFixedHexDigits(state, 4)) {\n\t      var lead = state.lastIntValue;\n\t      if (switchU && lead >= 0xD800 && lead <= 0xDBFF) {\n\t        var leadSurrogateEnd = state.pos;\n\t        if (state.eat(0x5C /* \\ */) && state.eat(0x75 /* u */) && this.regexp_eatFixedHexDigits(state, 4)) {\n\t          var trail = state.lastIntValue;\n\t          if (trail >= 0xDC00 && trail <= 0xDFFF) {\n\t            state.lastIntValue = (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;\n\t            return true\n\t          }\n\t        }\n\t        state.pos = leadSurrogateEnd;\n\t        state.lastIntValue = lead;\n\t      }\n\t      return true\n\t    }\n\t    if (\n\t      switchU &&\n\t      state.eat(0x7B /* { */) &&\n\t      this.regexp_eatHexDigits(state) &&\n\t      state.eat(0x7D /* } */) &&\n\t      isValidUnicode(state.lastIntValue)\n\t    ) {\n\t      return true\n\t    }\n\t    if (switchU) {\n\t      state.raise(\"Invalid unicode escape\");\n\t    }\n\t    state.pos = start;\n\t  }\n\n\t  return false\n\t};\n\tfunction isValidUnicode(ch) {\n\t  return ch >= 0 && ch <= 0x10FFFF\n\t}\n\n\t// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-IdentityEscape\n\tpp$8.regexp_eatIdentityEscape = function(state) {\n\t  if (state.switchU) {\n\t    if (this.regexp_eatSyntaxCharacter(state)) {\n\t      return true\n\t    }\n\t    if (state.eat(0x2F /* / */)) {\n\t      state.lastIntValue = 0x2F; /* / */\n\t      return true\n\t    }\n\t    return false\n\t  }\n\n\t  var ch = state.current();\n\t  if (ch !== 0x63 /* c */ && (!state.switchN || ch !== 0x6B /* k */)) {\n\t    state.lastIntValue = ch;\n\t    state.advance();\n\t    return true\n\t  }\n\n\t  return false\n\t};\n\n\t// https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalEscape\n\tpp$8.regexp_eatDecimalEscape = function(state) {\n\t  state.lastIntValue = 0;\n\t  var ch = state.current();\n\t  if (ch >= 0x31 /* 1 */ && ch <= 0x39 /* 9 */) {\n\t    do {\n\t      state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */);\n\t      state.advance();\n\t    } while ((ch = state.current()) >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */)\n\t    return true\n\t  }\n\t  return false\n\t};\n\n\t// https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClassEscape\n\tpp$8.regexp_eatCharacterClassEscape = function(state) {\n\t  var ch = state.current();\n\n\t  if (isCharacterClassEscape(ch)) {\n\t    state.lastIntValue = -1;\n\t    state.advance();\n\t    return true\n\t  }\n\n\t  if (\n\t    state.switchU &&\n\t    this.options.ecmaVersion >= 9 &&\n\t    (ch === 0x50 /* P */ || ch === 0x70 /* p */)\n\t  ) {\n\t    state.lastIntValue = -1;\n\t    state.advance();\n\t    if (\n\t      state.eat(0x7B /* { */) &&\n\t      this.regexp_eatUnicodePropertyValueExpression(state) &&\n\t      state.eat(0x7D /* } */)\n\t    ) {\n\t      return true\n\t    }\n\t    state.raise(\"Invalid property name\");\n\t  }\n\n\t  return false\n\t};\n\tfunction isCharacterClassEscape(ch) {\n\t  return (\n\t    ch === 0x64 /* d */ ||\n\t    ch === 0x44 /* D */ ||\n\t    ch === 0x73 /* s */ ||\n\t    ch === 0x53 /* S */ ||\n\t    ch === 0x77 /* w */ ||\n\t    ch === 0x57 /* W */\n\t  )\n\t}\n\n\t// UnicodePropertyValueExpression ::\n\t//   UnicodePropertyName `=` UnicodePropertyValue\n\t//   LoneUnicodePropertyNameOrValue\n\tpp$8.regexp_eatUnicodePropertyValueExpression = function(state) {\n\t  var start = state.pos;\n\n\t  // UnicodePropertyName `=` UnicodePropertyValue\n\t  if (this.regexp_eatUnicodePropertyName(state) && state.eat(0x3D /* = */)) {\n\t    var name = state.lastStringValue;\n\t    if (this.regexp_eatUnicodePropertyValue(state)) {\n\t      var value = state.lastStringValue;\n\t      this.regexp_validateUnicodePropertyNameAndValue(state, name, value);\n\t      return true\n\t    }\n\t  }\n\t  state.pos = start;\n\n\t  // LoneUnicodePropertyNameOrValue\n\t  if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {\n\t    var nameOrValue = state.lastStringValue;\n\t    this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);\n\t    return true\n\t  }\n\t  return false\n\t};\n\tpp$8.regexp_validateUnicodePropertyNameAndValue = function(state, name, value) {\n\t  if (!has(state.unicodeProperties.nonBinary, name))\n\t    { state.raise(\"Invalid property name\"); }\n\t  if (!state.unicodeProperties.nonBinary[name].test(value))\n\t    { state.raise(\"Invalid property value\"); }\n\t};\n\tpp$8.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {\n\t  if (!state.unicodeProperties.binary.test(nameOrValue))\n\t    { state.raise(\"Invalid property name\"); }\n\t};\n\n\t// UnicodePropertyName ::\n\t//   UnicodePropertyNameCharacters\n\tpp$8.regexp_eatUnicodePropertyName = function(state) {\n\t  var ch = 0;\n\t  state.lastStringValue = \"\";\n\t  while (isUnicodePropertyNameCharacter(ch = state.current())) {\n\t    state.lastStringValue += codePointToString(ch);\n\t    state.advance();\n\t  }\n\t  return state.lastStringValue !== \"\"\n\t};\n\tfunction isUnicodePropertyNameCharacter(ch) {\n\t  return isControlLetter(ch) || ch === 0x5F /* _ */\n\t}\n\n\t// UnicodePropertyValue ::\n\t//   UnicodePropertyValueCharacters\n\tpp$8.regexp_eatUnicodePropertyValue = function(state) {\n\t  var ch = 0;\n\t  state.lastStringValue = \"\";\n\t  while (isUnicodePropertyValueCharacter(ch = state.current())) {\n\t    state.lastStringValue += codePointToString(ch);\n\t    state.advance();\n\t  }\n\t  return state.lastStringValue !== \"\"\n\t};\n\tfunction isUnicodePropertyValueCharacter(ch) {\n\t  return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch)\n\t}\n\n\t// LoneUnicodePropertyNameOrValue ::\n\t//   UnicodePropertyValueCharacters\n\tpp$8.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {\n\t  return this.regexp_eatUnicodePropertyValue(state)\n\t};\n\n\t// https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClass\n\tpp$8.regexp_eatCharacterClass = function(state) {\n\t  if (state.eat(0x5B /* [ */)) {\n\t    state.eat(0x5E /* ^ */);\n\t    this.regexp_classRanges(state);\n\t    if (state.eat(0x5D /* ] */)) {\n\t      return true\n\t    }\n\t    // Unreachable since it threw \"unterminated regular expression\" error before.\n\t    state.raise(\"Unterminated character class\");\n\t  }\n\t  return false\n\t};\n\n\t// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassRanges\n\t// https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRanges\n\t// https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRangesNoDash\n\tpp$8.regexp_classRanges = function(state) {\n\t  while (this.regexp_eatClassAtom(state)) {\n\t    var left = state.lastIntValue;\n\t    if (state.eat(0x2D /* - */) && this.regexp_eatClassAtom(state)) {\n\t      var right = state.lastIntValue;\n\t      if (state.switchU && (left === -1 || right === -1)) {\n\t        state.raise(\"Invalid character class\");\n\t      }\n\t      if (left !== -1 && right !== -1 && left > right) {\n\t        state.raise(\"Range out of order in character class\");\n\t      }\n\t    }\n\t  }\n\t};\n\n\t// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtom\n\t// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtomNoDash\n\tpp$8.regexp_eatClassAtom = function(state) {\n\t  var start = state.pos;\n\n\t  if (state.eat(0x5C /* \\ */)) {\n\t    if (this.regexp_eatClassEscape(state)) {\n\t      return true\n\t    }\n\t    if (state.switchU) {\n\t      // Make the same message as V8.\n\t      var ch$1 = state.current();\n\t      if (ch$1 === 0x63 /* c */ || isOctalDigit(ch$1)) {\n\t        state.raise(\"Invalid class escape\");\n\t      }\n\t      state.raise(\"Invalid escape\");\n\t    }\n\t    state.pos = start;\n\t  }\n\n\t  var ch = state.current();\n\t  if (ch !== 0x5D /* ] */) {\n\t    state.lastIntValue = ch;\n\t    state.advance();\n\t    return true\n\t  }\n\n\t  return false\n\t};\n\n\t// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassEscape\n\tpp$8.regexp_eatClassEscape = function(state) {\n\t  var start = state.pos;\n\n\t  if (state.eat(0x62 /* b */)) {\n\t    state.lastIntValue = 0x08; /* <BS> */\n\t    return true\n\t  }\n\n\t  if (state.switchU && state.eat(0x2D /* - */)) {\n\t    state.lastIntValue = 0x2D; /* - */\n\t    return true\n\t  }\n\n\t  if (!state.switchU && state.eat(0x63 /* c */)) {\n\t    if (this.regexp_eatClassControlLetter(state)) {\n\t      return true\n\t    }\n\t    state.pos = start;\n\t  }\n\n\t  return (\n\t    this.regexp_eatCharacterClassEscape(state) ||\n\t    this.regexp_eatCharacterEscape(state)\n\t  )\n\t};\n\n\t// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassControlLetter\n\tpp$8.regexp_eatClassControlLetter = function(state) {\n\t  var ch = state.current();\n\t  if (isDecimalDigit(ch) || ch === 0x5F /* _ */) {\n\t    state.lastIntValue = ch % 0x20;\n\t    state.advance();\n\t    return true\n\t  }\n\t  return false\n\t};\n\n\t// https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence\n\tpp$8.regexp_eatHexEscapeSequence = function(state) {\n\t  var start = state.pos;\n\t  if (state.eat(0x78 /* x */)) {\n\t    if (this.regexp_eatFixedHexDigits(state, 2)) {\n\t      return true\n\t    }\n\t    if (state.switchU) {\n\t      state.raise(\"Invalid escape\");\n\t    }\n\t    state.pos = start;\n\t  }\n\t  return false\n\t};\n\n\t// https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalDigits\n\tpp$8.regexp_eatDecimalDigits = function(state) {\n\t  var start = state.pos;\n\t  var ch = 0;\n\t  state.lastIntValue = 0;\n\t  while (isDecimalDigit(ch = state.current())) {\n\t    state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */);\n\t    state.advance();\n\t  }\n\t  return state.pos !== start\n\t};\n\tfunction isDecimalDigit(ch) {\n\t  return ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */\n\t}\n\n\t// https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigits\n\tpp$8.regexp_eatHexDigits = function(state) {\n\t  var start = state.pos;\n\t  var ch = 0;\n\t  state.lastIntValue = 0;\n\t  while (isHexDigit(ch = state.current())) {\n\t    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);\n\t    state.advance();\n\t  }\n\t  return state.pos !== start\n\t};\n\tfunction isHexDigit(ch) {\n\t  return (\n\t    (ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */) ||\n\t    (ch >= 0x41 /* A */ && ch <= 0x46 /* F */) ||\n\t    (ch >= 0x61 /* a */ && ch <= 0x66 /* f */)\n\t  )\n\t}\n\tfunction hexToInt(ch) {\n\t  if (ch >= 0x41 /* A */ && ch <= 0x46 /* F */) {\n\t    return 10 + (ch - 0x41 /* A */)\n\t  }\n\t  if (ch >= 0x61 /* a */ && ch <= 0x66 /* f */) {\n\t    return 10 + (ch - 0x61 /* a */)\n\t  }\n\t  return ch - 0x30 /* 0 */\n\t}\n\n\t// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-LegacyOctalEscapeSequence\n\t// Allows only 0-377(octal) i.e. 0-255(decimal).\n\tpp$8.regexp_eatLegacyOctalEscapeSequence = function(state) {\n\t  if (this.regexp_eatOctalDigit(state)) {\n\t    var n1 = state.lastIntValue;\n\t    if (this.regexp_eatOctalDigit(state)) {\n\t      var n2 = state.lastIntValue;\n\t      if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {\n\t        state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;\n\t      } else {\n\t        state.lastIntValue = n1 * 8 + n2;\n\t      }\n\t    } else {\n\t      state.lastIntValue = n1;\n\t    }\n\t    return true\n\t  }\n\t  return false\n\t};\n\n\t// https://www.ecma-international.org/ecma-262/8.0/#prod-OctalDigit\n\tpp$8.regexp_eatOctalDigit = function(state) {\n\t  var ch = state.current();\n\t  if (isOctalDigit(ch)) {\n\t    state.lastIntValue = ch - 0x30; /* 0 */\n\t    state.advance();\n\t    return true\n\t  }\n\t  state.lastIntValue = 0;\n\t  return false\n\t};\n\tfunction isOctalDigit(ch) {\n\t  return ch >= 0x30 /* 0 */ && ch <= 0x37 /* 7 */\n\t}\n\n\t// https://www.ecma-international.org/ecma-262/8.0/#prod-Hex4Digits\n\t// https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigit\n\t// And HexDigit HexDigit in https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence\n\tpp$8.regexp_eatFixedHexDigits = function(state, length) {\n\t  var start = state.pos;\n\t  state.lastIntValue = 0;\n\t  for (var i = 0; i < length; ++i) {\n\t    var ch = state.current();\n\t    if (!isHexDigit(ch)) {\n\t      state.pos = start;\n\t      return false\n\t    }\n\t    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);\n\t    state.advance();\n\t  }\n\t  return true\n\t};\n\n\t// Object type used to represent tokens. Note that normally, tokens\n\t// simply exist as properties on the parser object. This is only\n\t// used for the onToken callback and the external tokenizer.\n\n\tvar Token = function Token(p) {\n\t  this.type = p.type;\n\t  this.value = p.value;\n\t  this.start = p.start;\n\t  this.end = p.end;\n\t  if (p.options.locations)\n\t    { this.loc = new SourceLocation(p, p.startLoc, p.endLoc); }\n\t  if (p.options.ranges)\n\t    { this.range = [p.start, p.end]; }\n\t};\n\n\t// ## Tokenizer\n\n\tvar pp$9 = Parser.prototype;\n\n\t// Move to the next token\n\n\tpp$9.next = function(ignoreEscapeSequenceInKeyword) {\n\t  if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc)\n\t    { this.raiseRecoverable(this.start, \"Escape sequence in keyword \" + this.type.keyword); }\n\t  if (this.options.onToken)\n\t    { this.options.onToken(new Token(this)); }\n\n\t  this.lastTokEnd = this.end;\n\t  this.lastTokStart = this.start;\n\t  this.lastTokEndLoc = this.endLoc;\n\t  this.lastTokStartLoc = this.startLoc;\n\t  this.nextToken();\n\t};\n\n\tpp$9.getToken = function() {\n\t  this.next();\n\t  return new Token(this)\n\t};\n\n\t// If we're in an ES6 environment, make parsers iterable\n\tif (typeof Symbol !== \"undefined\")\n\t  { pp$9[Symbol.iterator] = function() {\n\t    var this$1 = this;\n\n\t    return {\n\t      next: function () {\n\t        var token = this$1.getToken();\n\t        return {\n\t          done: token.type === types.eof,\n\t          value: token\n\t        }\n\t      }\n\t    }\n\t  }; }\n\n\t// Toggle strict mode. Re-reads the next number or string to please\n\t// pedantic tests (`\"use strict\"; 010;` should fail).\n\n\tpp$9.curContext = function() {\n\t  return this.context[this.context.length - 1]\n\t};\n\n\t// Read a single token, updating the parser object's token-related\n\t// properties.\n\n\tpp$9.nextToken = function() {\n\t  var curContext = this.curContext();\n\t  if (!curContext || !curContext.preserveSpace) { this.skipSpace(); }\n\n\t  this.start = this.pos;\n\t  if (this.options.locations) { this.startLoc = this.curPosition(); }\n\t  if (this.pos >= this.input.length) { return this.finishToken(types.eof) }\n\n\t  if (curContext.override) { return curContext.override(this) }\n\t  else { this.readToken(this.fullCharCodeAtPos()); }\n\t};\n\n\tpp$9.readToken = function(code) {\n\t  // Identifier or keyword. '\\uXXXX' sequences are allowed in\n\t  // identifiers, so '\\' also dispatches to that.\n\t  if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92 /* '\\' */)\n\t    { return this.readWord() }\n\n\t  return this.getTokenFromCode(code)\n\t};\n\n\tpp$9.fullCharCodeAtPos = function() {\n\t  var code = this.input.charCodeAt(this.pos);\n\t  if (code <= 0xd7ff || code >= 0xe000) { return code }\n\t  var next = this.input.charCodeAt(this.pos + 1);\n\t  return (code << 10) + next - 0x35fdc00\n\t};\n\n\tpp$9.skipBlockComment = function() {\n\t  var startLoc = this.options.onComment && this.curPosition();\n\t  var start = this.pos, end = this.input.indexOf(\"*/\", this.pos += 2);\n\t  if (end === -1) { this.raise(this.pos - 2, \"Unterminated comment\"); }\n\t  this.pos = end + 2;\n\t  if (this.options.locations) {\n\t    lineBreakG.lastIndex = start;\n\t    var match;\n\t    while ((match = lineBreakG.exec(this.input)) && match.index < this.pos) {\n\t      ++this.curLine;\n\t      this.lineStart = match.index + match[0].length;\n\t    }\n\t  }\n\t  if (this.options.onComment)\n\t    { this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos,\n\t                           startLoc, this.curPosition()); }\n\t};\n\n\tpp$9.skipLineComment = function(startSkip) {\n\t  var start = this.pos;\n\t  var startLoc = this.options.onComment && this.curPosition();\n\t  var ch = this.input.charCodeAt(this.pos += startSkip);\n\t  while (this.pos < this.input.length && !isNewLine(ch)) {\n\t    ch = this.input.charCodeAt(++this.pos);\n\t  }\n\t  if (this.options.onComment)\n\t    { this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos,\n\t                           startLoc, this.curPosition()); }\n\t};\n\n\t// Called at the start of the parse and after every token. Skips\n\t// whitespace and comments, and.\n\n\tpp$9.skipSpace = function() {\n\t  loop: while (this.pos < this.input.length) {\n\t    var ch = this.input.charCodeAt(this.pos);\n\t    switch (ch) {\n\t    case 32: case 160: // ' '\n\t      ++this.pos;\n\t      break\n\t    case 13:\n\t      if (this.input.charCodeAt(this.pos + 1) === 10) {\n\t        ++this.pos;\n\t      }\n\t    case 10: case 8232: case 8233:\n\t      ++this.pos;\n\t      if (this.options.locations) {\n\t        ++this.curLine;\n\t        this.lineStart = this.pos;\n\t      }\n\t      break\n\t    case 47: // '/'\n\t      switch (this.input.charCodeAt(this.pos + 1)) {\n\t      case 42: // '*'\n\t        this.skipBlockComment();\n\t        break\n\t      case 47:\n\t        this.skipLineComment(2);\n\t        break\n\t      default:\n\t        break loop\n\t      }\n\t      break\n\t    default:\n\t      if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {\n\t        ++this.pos;\n\t      } else {\n\t        break loop\n\t      }\n\t    }\n\t  }\n\t};\n\n\t// Called at the end of every token. Sets `end`, `val`, and\n\t// maintains `context` and `exprAllowed`, and skips the space after\n\t// the token, so that the next one's `start` will point at the\n\t// right position.\n\n\tpp$9.finishToken = function(type, val) {\n\t  this.end = this.pos;\n\t  if (this.options.locations) { this.endLoc = this.curPosition(); }\n\t  var prevType = this.type;\n\t  this.type = type;\n\t  this.value = val;\n\n\t  this.updateContext(prevType);\n\t};\n\n\t// ### Token reading\n\n\t// This is the function that is called to fetch the next token. It\n\t// is somewhat obscure, because it works in character codes rather\n\t// than characters, and because operator parsing has been inlined\n\t// into it.\n\t//\n\t// All in the name of speed.\n\t//\n\tpp$9.readToken_dot = function() {\n\t  var next = this.input.charCodeAt(this.pos + 1);\n\t  if (next >= 48 && next <= 57) { return this.readNumber(true) }\n\t  var next2 = this.input.charCodeAt(this.pos + 2);\n\t  if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) { // 46 = dot '.'\n\t    this.pos += 3;\n\t    return this.finishToken(types.ellipsis)\n\t  } else {\n\t    ++this.pos;\n\t    return this.finishToken(types.dot)\n\t  }\n\t};\n\n\tpp$9.readToken_slash = function() { // '/'\n\t  var next = this.input.charCodeAt(this.pos + 1);\n\t  if (this.exprAllowed) { ++this.pos; return this.readRegexp() }\n\t  if (next === 61) { return this.finishOp(types.assign, 2) }\n\t  return this.finishOp(types.slash, 1)\n\t};\n\n\tpp$9.readToken_mult_modulo_exp = function(code) { // '%*'\n\t  var next = this.input.charCodeAt(this.pos + 1);\n\t  var size = 1;\n\t  var tokentype = code === 42 ? types.star : types.modulo;\n\n\t  // exponentiation operator ** and **=\n\t  if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {\n\t    ++size;\n\t    tokentype = types.starstar;\n\t    next = this.input.charCodeAt(this.pos + 2);\n\t  }\n\n\t  if (next === 61) { return this.finishOp(types.assign, size + 1) }\n\t  return this.finishOp(tokentype, size)\n\t};\n\n\tpp$9.readToken_pipe_amp = function(code) { // '|&'\n\t  var next = this.input.charCodeAt(this.pos + 1);\n\t  if (next === code) { return this.finishOp(code === 124 ? types.logicalOR : types.logicalAND, 2) }\n\t  if (next === 61) { return this.finishOp(types.assign, 2) }\n\t  return this.finishOp(code === 124 ? types.bitwiseOR : types.bitwiseAND, 1)\n\t};\n\n\tpp$9.readToken_caret = function() { // '^'\n\t  var next = this.input.charCodeAt(this.pos + 1);\n\t  if (next === 61) { return this.finishOp(types.assign, 2) }\n\t  return this.finishOp(types.bitwiseXOR, 1)\n\t};\n\n\tpp$9.readToken_plus_min = function(code) { // '+-'\n\t  var next = this.input.charCodeAt(this.pos + 1);\n\t  if (next === code) {\n\t    if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 &&\n\t        (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {\n\t      // A `-->` line comment\n\t      this.skipLineComment(3);\n\t      this.skipSpace();\n\t      return this.nextToken()\n\t    }\n\t    return this.finishOp(types.incDec, 2)\n\t  }\n\t  if (next === 61) { return this.finishOp(types.assign, 2) }\n\t  return this.finishOp(types.plusMin, 1)\n\t};\n\n\tpp$9.readToken_lt_gt = function(code) { // '<>'\n\t  var next = this.input.charCodeAt(this.pos + 1);\n\t  var size = 1;\n\t  if (next === code) {\n\t    size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;\n\t    if (this.input.charCodeAt(this.pos + size) === 61) { return this.finishOp(types.assign, size + 1) }\n\t    return this.finishOp(types.bitShift, size)\n\t  }\n\t  if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 &&\n\t      this.input.charCodeAt(this.pos + 3) === 45) {\n\t    // `<!--`, an XML-style comment that should be interpreted as a line comment\n\t    this.skipLineComment(4);\n\t    this.skipSpace();\n\t    return this.nextToken()\n\t  }\n\t  if (next === 61) { size = 2; }\n\t  return this.finishOp(types.relational, size)\n\t};\n\n\tpp$9.readToken_eq_excl = function(code) { // '=!'\n\t  var next = this.input.charCodeAt(this.pos + 1);\n\t  if (next === 61) { return this.finishOp(types.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2) }\n\t  if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) { // '=>'\n\t    this.pos += 2;\n\t    return this.finishToken(types.arrow)\n\t  }\n\t  return this.finishOp(code === 61 ? types.eq : types.prefix, 1)\n\t};\n\n\tpp$9.readToken_question = function() { // '?'\n\t  if (this.options.ecmaVersion >= 11) {\n\t    var next = this.input.charCodeAt(this.pos + 1);\n\t    if (next === 46) {\n\t      var next2 = this.input.charCodeAt(this.pos + 2);\n\t      if (next2 < 48 || next2 > 57) { return this.finishOp(types.questionDot, 2) }\n\t    }\n\t    if (next === 63) { return this.finishOp(types.coalesce, 2) }\n\t  }\n\t  return this.finishOp(types.question, 1)\n\t};\n\n\tpp$9.getTokenFromCode = function(code) {\n\t  switch (code) {\n\t  // The interpretation of a dot depends on whether it is followed\n\t  // by a digit or another two dots.\n\t  case 46: // '.'\n\t    return this.readToken_dot()\n\n\t  // Punctuation tokens.\n\t  case 40: ++this.pos; return this.finishToken(types.parenL)\n\t  case 41: ++this.pos; return this.finishToken(types.parenR)\n\t  case 59: ++this.pos; return this.finishToken(types.semi)\n\t  case 44: ++this.pos; return this.finishToken(types.comma)\n\t  case 91: ++this.pos; return this.finishToken(types.bracketL)\n\t  case 93: ++this.pos; return this.finishToken(types.bracketR)\n\t  case 123: ++this.pos; return this.finishToken(types.braceL)\n\t  case 125: ++this.pos; return this.finishToken(types.braceR)\n\t  case 58: ++this.pos; return this.finishToken(types.colon)\n\n\t  case 96: // '`'\n\t    if (this.options.ecmaVersion < 6) { break }\n\t    ++this.pos;\n\t    return this.finishToken(types.backQuote)\n\n\t  case 48: // '0'\n\t    var next = this.input.charCodeAt(this.pos + 1);\n\t    if (next === 120 || next === 88) { return this.readRadixNumber(16) } // '0x', '0X' - hex number\n\t    if (this.options.ecmaVersion >= 6) {\n\t      if (next === 111 || next === 79) { return this.readRadixNumber(8) } // '0o', '0O' - octal number\n\t      if (next === 98 || next === 66) { return this.readRadixNumber(2) } // '0b', '0B' - binary number\n\t    }\n\n\t  // Anything else beginning with a digit is an integer, octal\n\t  // number, or float.\n\t  case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: // 1-9\n\t    return this.readNumber(false)\n\n\t  // Quotes produce strings.\n\t  case 34: case 39: // '\"', \"'\"\n\t    return this.readString(code)\n\n\t  // Operators are parsed inline in tiny state machines. '=' (61) is\n\t  // often referred to. `finishOp` simply skips the amount of\n\t  // characters it is given as second argument, and returns a token\n\t  // of the type given by its first argument.\n\n\t  case 47: // '/'\n\t    return this.readToken_slash()\n\n\t  case 37: case 42: // '%*'\n\t    return this.readToken_mult_modulo_exp(code)\n\n\t  case 124: case 38: // '|&'\n\t    return this.readToken_pipe_amp(code)\n\n\t  case 94: // '^'\n\t    return this.readToken_caret()\n\n\t  case 43: case 45: // '+-'\n\t    return this.readToken_plus_min(code)\n\n\t  case 60: case 62: // '<>'\n\t    return this.readToken_lt_gt(code)\n\n\t  case 61: case 33: // '=!'\n\t    return this.readToken_eq_excl(code)\n\n\t  case 63: // '?'\n\t    return this.readToken_question()\n\n\t  case 126: // '~'\n\t    return this.finishOp(types.prefix, 1)\n\t  }\n\n\t  this.raise(this.pos, \"Unexpected character '\" + codePointToString$1(code) + \"'\");\n\t};\n\n\tpp$9.finishOp = function(type, size) {\n\t  var str = this.input.slice(this.pos, this.pos + size);\n\t  this.pos += size;\n\t  return this.finishToken(type, str)\n\t};\n\n\tpp$9.readRegexp = function() {\n\t  var escaped, inClass, start = this.pos;\n\t  for (;;) {\n\t    if (this.pos >= this.input.length) { this.raise(start, \"Unterminated regular expression\"); }\n\t    var ch = this.input.charAt(this.pos);\n\t    if (lineBreak.test(ch)) { this.raise(start, \"Unterminated regular expression\"); }\n\t    if (!escaped) {\n\t      if (ch === \"[\") { inClass = true; }\n\t      else if (ch === \"]\" && inClass) { inClass = false; }\n\t      else if (ch === \"/\" && !inClass) { break }\n\t      escaped = ch === \"\\\\\";\n\t    } else { escaped = false; }\n\t    ++this.pos;\n\t  }\n\t  var pattern = this.input.slice(start, this.pos);\n\t  ++this.pos;\n\t  var flagsStart = this.pos;\n\t  var flags = this.readWord1();\n\t  if (this.containsEsc) { this.unexpected(flagsStart); }\n\n\t  // Validate pattern\n\t  var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));\n\t  state.reset(start, pattern, flags);\n\t  this.validateRegExpFlags(state);\n\t  this.validateRegExpPattern(state);\n\n\t  // Create Literal#value property value.\n\t  var value = null;\n\t  try {\n\t    value = new RegExp(pattern, flags);\n\t  } catch (e) {\n\t    // ESTree requires null if it failed to instantiate RegExp object.\n\t    // https://github.com/estree/estree/blob/a27003adf4fd7bfad44de9cef372a2eacd527b1c/es5.md#regexpliteral\n\t  }\n\n\t  return this.finishToken(types.regexp, {pattern: pattern, flags: flags, value: value})\n\t};\n\n\t// Read an integer in the given radix. Return null if zero digits\n\t// were read, the integer value otherwise. When `len` is given, this\n\t// will return `null` unless the integer has exactly `len` digits.\n\n\tpp$9.readInt = function(radix, len) {\n\t  var start = this.pos, total = 0;\n\t  for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {\n\t    var code = this.input.charCodeAt(this.pos), val = (void 0);\n\t    if (code >= 97) { val = code - 97 + 10; } // a\n\t    else if (code >= 65) { val = code - 65 + 10; } // A\n\t    else if (code >= 48 && code <= 57) { val = code - 48; } // 0-9\n\t    else { val = Infinity; }\n\t    if (val >= radix) { break }\n\t    ++this.pos;\n\t    total = total * radix + val;\n\t  }\n\t  if (this.pos === start || len != null && this.pos - start !== len) { return null }\n\n\t  return total\n\t};\n\n\tpp$9.readRadixNumber = function(radix) {\n\t  var start = this.pos;\n\t  this.pos += 2; // 0x\n\t  var val = this.readInt(radix);\n\t  if (val == null) { this.raise(this.start + 2, \"Expected number in radix \" + radix); }\n\t  if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {\n\t    val = typeof BigInt !== \"undefined\" ? BigInt(this.input.slice(start, this.pos)) : null;\n\t    ++this.pos;\n\t  } else if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, \"Identifier directly after number\"); }\n\t  return this.finishToken(types.num, val)\n\t};\n\n\t// Read an integer, octal integer, or floating-point number.\n\n\tpp$9.readNumber = function(startsWithDot) {\n\t  var start = this.pos;\n\t  if (!startsWithDot && this.readInt(10) === null) { this.raise(start, \"Invalid number\"); }\n\t  var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;\n\t  if (octal && this.strict) { this.raise(start, \"Invalid number\"); }\n\t  var next = this.input.charCodeAt(this.pos);\n\t  if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {\n\t    var str$1 = this.input.slice(start, this.pos);\n\t    var val$1 = typeof BigInt !== \"undefined\" ? BigInt(str$1) : null;\n\t    ++this.pos;\n\t    if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, \"Identifier directly after number\"); }\n\t    return this.finishToken(types.num, val$1)\n\t  }\n\t  if (octal && /[89]/.test(this.input.slice(start, this.pos))) { octal = false; }\n\t  if (next === 46 && !octal) { // '.'\n\t    ++this.pos;\n\t    this.readInt(10);\n\t    next = this.input.charCodeAt(this.pos);\n\t  }\n\t  if ((next === 69 || next === 101) && !octal) { // 'eE'\n\t    next = this.input.charCodeAt(++this.pos);\n\t    if (next === 43 || next === 45) { ++this.pos; } // '+-'\n\t    if (this.readInt(10) === null) { this.raise(start, \"Invalid number\"); }\n\t  }\n\t  if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, \"Identifier directly after number\"); }\n\n\t  var str = this.input.slice(start, this.pos);\n\t  var val = octal ? parseInt(str, 8) : parseFloat(str);\n\t  return this.finishToken(types.num, val)\n\t};\n\n\t// Read a string value, interpreting backslash-escapes.\n\n\tpp$9.readCodePoint = function() {\n\t  var ch = this.input.charCodeAt(this.pos), code;\n\n\t  if (ch === 123) { // '{'\n\t    if (this.options.ecmaVersion < 6) { this.unexpected(); }\n\t    var codePos = ++this.pos;\n\t    code = this.readHexChar(this.input.indexOf(\"}\", this.pos) - this.pos);\n\t    ++this.pos;\n\t    if (code > 0x10FFFF) { this.invalidStringToken(codePos, \"Code point out of bounds\"); }\n\t  } else {\n\t    code = this.readHexChar(4);\n\t  }\n\t  return code\n\t};\n\n\tfunction codePointToString$1(code) {\n\t  // UTF-16 Decoding\n\t  if (code <= 0xFFFF) { return String.fromCharCode(code) }\n\t  code -= 0x10000;\n\t  return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00)\n\t}\n\n\tpp$9.readString = function(quote) {\n\t  var out = \"\", chunkStart = ++this.pos;\n\t  for (;;) {\n\t    if (this.pos >= this.input.length) { this.raise(this.start, \"Unterminated string constant\"); }\n\t    var ch = this.input.charCodeAt(this.pos);\n\t    if (ch === quote) { break }\n\t    if (ch === 92) { // '\\'\n\t      out += this.input.slice(chunkStart, this.pos);\n\t      out += this.readEscapedChar(false);\n\t      chunkStart = this.pos;\n\t    } else {\n\t      if (isNewLine(ch, this.options.ecmaVersion >= 10)) { this.raise(this.start, \"Unterminated string constant\"); }\n\t      ++this.pos;\n\t    }\n\t  }\n\t  out += this.input.slice(chunkStart, this.pos++);\n\t  return this.finishToken(types.string, out)\n\t};\n\n\t// Reads template string tokens.\n\n\tvar INVALID_TEMPLATE_ESCAPE_ERROR = {};\n\n\tpp$9.tryReadTemplateToken = function() {\n\t  this.inTemplateElement = true;\n\t  try {\n\t    this.readTmplToken();\n\t  } catch (err) {\n\t    if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {\n\t      this.readInvalidTemplateToken();\n\t    } else {\n\t      throw err\n\t    }\n\t  }\n\n\t  this.inTemplateElement = false;\n\t};\n\n\tpp$9.invalidStringToken = function(position, message) {\n\t  if (this.inTemplateElement && this.options.ecmaVersion >= 9) {\n\t    throw INVALID_TEMPLATE_ESCAPE_ERROR\n\t  } else {\n\t    this.raise(position, message);\n\t  }\n\t};\n\n\tpp$9.readTmplToken = function() {\n\t  var out = \"\", chunkStart = this.pos;\n\t  for (;;) {\n\t    if (this.pos >= this.input.length) { this.raise(this.start, \"Unterminated template\"); }\n\t    var ch = this.input.charCodeAt(this.pos);\n\t    if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) { // '`', '${'\n\t      if (this.pos === this.start && (this.type === types.template || this.type === types.invalidTemplate)) {\n\t        if (ch === 36) {\n\t          this.pos += 2;\n\t          return this.finishToken(types.dollarBraceL)\n\t        } else {\n\t          ++this.pos;\n\t          return this.finishToken(types.backQuote)\n\t        }\n\t      }\n\t      out += this.input.slice(chunkStart, this.pos);\n\t      return this.finishToken(types.template, out)\n\t    }\n\t    if (ch === 92) { // '\\'\n\t      out += this.input.slice(chunkStart, this.pos);\n\t      out += this.readEscapedChar(true);\n\t      chunkStart = this.pos;\n\t    } else if (isNewLine(ch)) {\n\t      out += this.input.slice(chunkStart, this.pos);\n\t      ++this.pos;\n\t      switch (ch) {\n\t      case 13:\n\t        if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; }\n\t      case 10:\n\t        out += \"\\n\";\n\t        break\n\t      default:\n\t        out += String.fromCharCode(ch);\n\t        break\n\t      }\n\t      if (this.options.locations) {\n\t        ++this.curLine;\n\t        this.lineStart = this.pos;\n\t      }\n\t      chunkStart = this.pos;\n\t    } else {\n\t      ++this.pos;\n\t    }\n\t  }\n\t};\n\n\t// Reads a template token to search for the end, without validating any escape sequences\n\tpp$9.readInvalidTemplateToken = function() {\n\t  for (; this.pos < this.input.length; this.pos++) {\n\t    switch (this.input[this.pos]) {\n\t    case \"\\\\\":\n\t      ++this.pos;\n\t      break\n\n\t    case \"$\":\n\t      if (this.input[this.pos + 1] !== \"{\") {\n\t        break\n\t      }\n\t    // falls through\n\n\t    case \"`\":\n\t      return this.finishToken(types.invalidTemplate, this.input.slice(this.start, this.pos))\n\n\t    // no default\n\t    }\n\t  }\n\t  this.raise(this.start, \"Unterminated template\");\n\t};\n\n\t// Used to read escaped characters\n\n\tpp$9.readEscapedChar = function(inTemplate) {\n\t  var ch = this.input.charCodeAt(++this.pos);\n\t  ++this.pos;\n\t  switch (ch) {\n\t  case 110: return \"\\n\" // 'n' -> '\\n'\n\t  case 114: return \"\\r\" // 'r' -> '\\r'\n\t  case 120: return String.fromCharCode(this.readHexChar(2)) // 'x'\n\t  case 117: return codePointToString$1(this.readCodePoint()) // 'u'\n\t  case 116: return \"\\t\" // 't' -> '\\t'\n\t  case 98: return \"\\b\" // 'b' -> '\\b'\n\t  case 118: return \"\\u000b\" // 'v' -> '\\u000b'\n\t  case 102: return \"\\f\" // 'f' -> '\\f'\n\t  case 13: if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; } // '\\r\\n'\n\t  case 10: // ' \\n'\n\t    if (this.options.locations) { this.lineStart = this.pos; ++this.curLine; }\n\t    return \"\"\n\t  case 56:\n\t  case 57:\n\t    if (inTemplate) {\n\t      var codePos = this.pos - 1;\n\n\t      this.invalidStringToken(\n\t        codePos,\n\t        \"Invalid escape sequence in template string\"\n\t      );\n\n\t      return null\n\t    }\n\t  default:\n\t    if (ch >= 48 && ch <= 55) {\n\t      var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];\n\t      var octal = parseInt(octalStr, 8);\n\t      if (octal > 255) {\n\t        octalStr = octalStr.slice(0, -1);\n\t        octal = parseInt(octalStr, 8);\n\t      }\n\t      this.pos += octalStr.length - 1;\n\t      ch = this.input.charCodeAt(this.pos);\n\t      if ((octalStr !== \"0\" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {\n\t        this.invalidStringToken(\n\t          this.pos - 1 - octalStr.length,\n\t          inTemplate\n\t            ? \"Octal literal in template string\"\n\t            : \"Octal literal in strict mode\"\n\t        );\n\t      }\n\t      return String.fromCharCode(octal)\n\t    }\n\t    if (isNewLine(ch)) {\n\t      // Unicode new line characters after \\ get removed from output in both\n\t      // template literals and strings\n\t      return \"\"\n\t    }\n\t    return String.fromCharCode(ch)\n\t  }\n\t};\n\n\t// Used to read character escape sequences ('\\x', '\\u', '\\U').\n\n\tpp$9.readHexChar = function(len) {\n\t  var codePos = this.pos;\n\t  var n = this.readInt(16, len);\n\t  if (n === null) { this.invalidStringToken(codePos, \"Bad character escape sequence\"); }\n\t  return n\n\t};\n\n\t// Read an identifier, and return it as a string. Sets `this.containsEsc`\n\t// to whether the word contained a '\\u' escape.\n\t//\n\t// Incrementally adds only escaped chars, adding other chunks as-is\n\t// as a micro-optimization.\n\n\tpp$9.readWord1 = function() {\n\t  this.containsEsc = false;\n\t  var word = \"\", first = true, chunkStart = this.pos;\n\t  var astral = this.options.ecmaVersion >= 6;\n\t  while (this.pos < this.input.length) {\n\t    var ch = this.fullCharCodeAtPos();\n\t    if (isIdentifierChar(ch, astral)) {\n\t      this.pos += ch <= 0xffff ? 1 : 2;\n\t    } else if (ch === 92) { // \"\\\"\n\t      this.containsEsc = true;\n\t      word += this.input.slice(chunkStart, this.pos);\n\t      var escStart = this.pos;\n\t      if (this.input.charCodeAt(++this.pos) !== 117) // \"u\"\n\t        { this.invalidStringToken(this.pos, \"Expecting Unicode escape sequence \\\\uXXXX\"); }\n\t      ++this.pos;\n\t      var esc = this.readCodePoint();\n\t      if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral))\n\t        { this.invalidStringToken(escStart, \"Invalid Unicode escape\"); }\n\t      word += codePointToString$1(esc);\n\t      chunkStart = this.pos;\n\t    } else {\n\t      break\n\t    }\n\t    first = false;\n\t  }\n\t  return word + this.input.slice(chunkStart, this.pos)\n\t};\n\n\t// Read an identifier or keyword token. Will check for reserved\n\t// words when necessary.\n\n\tpp$9.readWord = function() {\n\t  var word = this.readWord1();\n\t  var type = types.name;\n\t  if (this.keywords.test(word)) {\n\t    type = keywords$1[word];\n\t  }\n\t  return this.finishToken(type, word)\n\t};\n\n\t// Acorn is a tiny, fast JavaScript parser written in JavaScript.\n\n\tvar version = \"7.3.1\";\n\n\tParser.acorn = {\n\t  Parser: Parser,\n\t  version: version,\n\t  defaultOptions: defaultOptions,\n\t  Position: Position,\n\t  SourceLocation: SourceLocation,\n\t  getLineInfo: getLineInfo,\n\t  Node: Node,\n\t  TokenType: TokenType,\n\t  tokTypes: types,\n\t  keywordTypes: keywords$1,\n\t  TokContext: TokContext,\n\t  tokContexts: types$1,\n\t  isIdentifierChar: isIdentifierChar,\n\t  isIdentifierStart: isIdentifierStart,\n\t  Token: Token,\n\t  isNewLine: isNewLine,\n\t  lineBreak: lineBreak,\n\t  lineBreakG: lineBreakG,\n\t  nonASCIIwhitespace: nonASCIIwhitespace\n\t};\n\n\t// The main exported interface (under `self.acorn` when in the\n\t// browser) is a `parse` function that takes a code string and\n\t// returns an abstract syntax tree as specified by [Mozilla parser\n\t// API][api].\n\t//\n\t// [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API\n\n\tfunction parse(input, options) {\n\t  return Parser.parse(input, options)\n\t}\n\n\t// This function tries to parse a single expression at a given\n\t// offset in a string. Useful for parsing mixed-language formats\n\t// that embed JavaScript expressions.\n\n\tfunction parseExpressionAt(input, pos, options) {\n\t  return Parser.parseExpressionAt(input, pos, options)\n\t}\n\n\tfunction walk(ast, { enter, leave }) {\n\t\treturn visit(ast, null, enter, leave);\n\t}\n\n\tlet should_skip = false;\n\tlet should_remove = false;\n\tlet replacement = null;\n\tconst context = {\n\t\tskip: () => should_skip = true,\n\t\tremove: () => should_remove = true,\n\t\treplace: (node) => replacement = node\n\t};\n\n\tfunction replace(parent, prop, index, node) {\n\t\tif (parent) {\n\t\t\tif (index !== null) {\n\t\t\t\tparent[prop][index] = node;\n\t\t\t} else {\n\t\t\t\tparent[prop] = node;\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction remove(parent, prop, index) {\n\t\tif (parent) {\n\t\t\tif (index !== null) {\n\t\t\t\tparent[prop].splice(index, 1);\n\t\t\t} else {\n\t\t\t\tdelete parent[prop];\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction visit(\n\t\tnode,\n\t\tparent,\n\t\tenter,\n\t\tleave,\n\t\tprop,\n\t\tindex\n\t) {\n\t\tif (node) {\n\t\t\tif (enter) {\n\t\t\t\tconst _should_skip = should_skip;\n\t\t\t\tconst _should_remove = should_remove;\n\t\t\t\tconst _replacement = replacement;\n\t\t\t\tshould_skip = false;\n\t\t\t\tshould_remove = false;\n\t\t\t\treplacement = null;\n\n\t\t\t\tenter.call(context, node, parent, prop, index);\n\n\t\t\t\tif (replacement) {\n\t\t\t\t\tnode = replacement;\n\t\t\t\t\treplace(parent, prop, index, node);\n\t\t\t\t}\n\n\t\t\t\tif (should_remove) {\n\t\t\t\t\tremove(parent, prop, index);\n\t\t\t\t}\n\n\t\t\t\tconst skipped = should_skip;\n\t\t\t\tconst removed = should_remove;\n\n\t\t\t\tshould_skip = _should_skip;\n\t\t\t\tshould_remove = _should_remove;\n\t\t\t\treplacement = _replacement;\n\n\t\t\t\tif (skipped) return node;\n\t\t\t\tif (removed) return null;\n\t\t\t}\n\n\t\t\tfor (const key in node) {\n\t\t\t\tconst value = (node )[key];\n\n\t\t\t\tif (typeof value !== 'object') {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\telse if (Array.isArray(value)) {\n\t\t\t\t\tfor (let j = 0, k = 0; j < value.length; j += 1, k += 1) {\n\t\t\t\t\t\tif (value[j] !== null && typeof value[j].type === 'string') {\n\t\t\t\t\t\t\tif (!visit(value[j], node, enter, leave, key, k)) {\n\t\t\t\t\t\t\t\t// removed\n\t\t\t\t\t\t\t\tj--;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\telse if (value !== null && typeof value.type === 'string') {\n\t\t\t\t\tvisit(value, node, enter, leave, key, null);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (leave) {\n\t\t\t\tconst _replacement = replacement;\n\t\t\t\tconst _should_remove = should_remove;\n\t\t\t\treplacement = null;\n\t\t\t\tshould_remove = false;\n\n\t\t\t\tleave.call(context, node, parent, prop, index);\n\n\t\t\t\tif (replacement) {\n\t\t\t\t\tnode = replacement;\n\t\t\t\t\treplace(parent, prop, index, node);\n\t\t\t\t}\n\n\t\t\t\tif (should_remove) {\n\t\t\t\t\tremove(parent, prop, index);\n\t\t\t\t}\n\n\t\t\t\tconst removed = should_remove;\n\n\t\t\t\treplacement = _replacement;\n\t\t\t\tshould_remove = _should_remove;\n\n\t\t\t\tif (removed) return null;\n\t\t\t}\n\t\t}\n\n\t\treturn node;\n\t}\n\n\tfunction isReference(node, parent) {\n\t    if (node.type === 'MemberExpression') {\n\t        return !node.computed && isReference(node.object, node);\n\t    }\n\t    if (node.type === 'Identifier') {\n\t        if (!parent)\n\t            return true;\n\t        switch (parent.type) {\n\t            // disregard `bar` in `foo.bar`\n\t            case 'MemberExpression': return parent.computed || node === parent.object;\n\t            // disregard the `foo` in `class {foo(){}}` but keep it in `class {[foo](){}}`\n\t            case 'MethodDefinition': return parent.computed;\n\t            // disregard the `foo` in `class {foo=bar}` but keep it in `class {[foo]=bar}` and `class {bar=foo}`\n\t            case 'FieldDefinition': return parent.computed || node === parent.value;\n\t            // disregard the `bar` in `{ bar: foo }`, but keep it in `{ [bar]: foo }`\n\t            case 'Property': return parent.computed || node === parent.value;\n\t            // disregard the `bar` in `export { foo as bar }` or\n\t            // the foo in `import { foo as bar }`\n\t            case 'ExportSpecifier':\n\t            case 'ImportSpecifier': return node === parent.local;\n\t            // disregard the `foo` in `foo: while (...) { ... break foo; ... continue foo;}`\n\t            case 'LabeledStatement':\n\t            case 'BreakStatement':\n\t            case 'ContinueStatement': return false;\n\t            default: return true;\n\t        }\n\t    }\n\t    return false;\n\t}\n\n\tfunction analyze(expression) {\n\t\tconst map = new WeakMap();\n\n\t\tlet scope = new Scope$1(null, false);\n\n\t\twalk(expression, {\n\t\t\tenter(node, parent) {\n\t\t\t\tif (node.type === 'ImportDeclaration') {\n\t\t\t\t\tnode.specifiers.forEach((specifier) => {\n\t\t\t\t\t\tscope.declarations.set(specifier.local.name, specifier);\n\t\t\t\t\t});\n\t\t\t\t} else if (/(Function(Declaration|Expression)|ArrowFunctionExpression)/.test(node.type)) {\n\t\t\t\t\tif (node.type === 'FunctionDeclaration') {\n\t\t\t\t\t\tscope.declarations.set(node.id.name, node);\n\t\t\t\t\t\tmap.set(node, scope = new Scope$1(scope, false));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmap.set(node, scope = new Scope$1(scope, false));\n\t\t\t\t\t\tif (node.type === 'FunctionExpression' && node.id) scope.declarations.set(node.id.name, node);\n\t\t\t\t\t}\n\n\t\t\t\t\tnode.params.forEach((param) => {\n\t\t\t\t\t\textract_names(param).forEach(name => {\n\t\t\t\t\t\t\tscope.declarations.set(name, node);\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t} else if (/For(?:In|Of)?Statement/.test(node.type)) {\n\t\t\t\t\tmap.set(node, scope = new Scope$1(scope, true));\n\t\t\t\t} else if (node.type === 'BlockStatement') {\n\t\t\t\t\tmap.set(node, scope = new Scope$1(scope, true));\n\t\t\t\t} else if (/(Class|Variable)Declaration/.test(node.type)) {\n\t\t\t\t\tscope.add_declaration(node);\n\t\t\t\t} else if (node.type === 'CatchClause') {\n\t\t\t\t\tmap.set(node, scope = new Scope$1(scope, true));\n\n\t\t\t\t\tif (node.param) {\n\t\t\t\t\t\textract_names(node.param).forEach(name => {\n\t\t\t\t\t\t\tscope.declarations.set(name, node.param);\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tleave(node) {\n\t\t\t\tif (map.has(node)) {\n\t\t\t\t\tscope = scope.parent;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tconst globals = new Map();\n\n\t\twalk(expression, {\n\t\t\tenter(node, parent) {\n\t\t\t\tif (map.has(node)) scope = map.get(node);\n\n\t\t\t\tif (node.type === 'Identifier' && isReference(node, parent)) {\n\t\t\t\t\tconst owner = scope.find_owner(node.name);\n\t\t\t\t\tif (!owner) globals.set(node.name, node);\n\n\t\t\t\t\tadd_reference(scope, node.name);\n\t\t\t\t}\n\t\t\t},\n\t\t\tleave(node) {\n\t\t\t\tif (map.has(node)) {\n\t\t\t\t\tscope = scope.parent;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn { map, scope, globals };\n\t}\n\n\tfunction add_reference(scope, name) {\n\t\tscope.references.add(name);\n\t\tif (scope.parent) add_reference(scope.parent, name);\n\t}\n\n\tclass Scope$1 {\n\t\t\n\t\t\n\t\t__init() {this.declarations = new Map();}\n\t\t__init2() {this.initialised_declarations = new Set();}\n\t\t__init3() {this.references = new Set();}\n\n\t\tconstructor(parent, block) {Scope$1.prototype.__init.call(this);Scope$1.prototype.__init2.call(this);Scope$1.prototype.__init3.call(this);\n\t\t\tthis.parent = parent;\n\t\t\tthis.block = block;\n\t\t}\n\n\n\t\tadd_declaration(node) {\n\t\t\tif (node.type === 'VariableDeclaration') {\n\t\t\t\tif (node.kind === 'var' && this.block && this.parent) {\n\t\t\t\t\tthis.parent.add_declaration(node);\n\t\t\t\t} else if (node.type === 'VariableDeclaration') {\n\t\t\t\t\tnode.declarations.forEach((declarator) => {\n\t\t\t\t\t\textract_names(declarator.id).forEach(name => {\n\t\t\t\t\t\t\tthis.declarations.set(name, node);\n\t\t\t\t\t\t\tif (declarator.init) this.initialised_declarations.add(name);\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.declarations.set(node.id.name, node);\n\t\t\t}\n\t\t}\n\n\t\tfind_owner(name) {\n\t\t\tif (this.declarations.has(name)) return this;\n\t\t\treturn this.parent && this.parent.find_owner(name);\n\t\t}\n\n\t\thas(name) {\n\t\t\treturn (\n\t\t\t\tthis.declarations.has(name) || (this.parent && this.parent.has(name))\n\t\t\t);\n\t\t}\n\t}\n\n\tfunction extract_names(param) {\n\t\treturn extract_identifiers(param).map(node => node.name);\n\t}\n\n\tfunction extract_identifiers(param) {\n\t\tconst nodes = [];\n\t\textractors[param.type] && extractors[param.type](nodes, param);\n\t\treturn nodes;\n\t}\n\n\tconst extractors = {\n\t\tIdentifier(nodes, param) {\n\t\t\tnodes.push(param);\n\t\t},\n\n\t\tMemberExpression(nodes, param) {\n\t\t\tlet object = param;\n\t\t\twhile (object.type === 'MemberExpression') object = object.object;\n\t\t\tnodes.push(object);\n\t\t},\n\n\t\tObjectPattern(nodes, param) {\n\t\t\tparam.properties.forEach((prop) => {\n\t\t\t\tif (prop.type === 'RestElement') {\n\t\t\t\t\tnodes.push(prop.argument);\n\t\t\t\t} else {\n\t\t\t\t\textractors[prop.value.type](nodes, prop.value);\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\t\tArrayPattern(nodes, param) {\n\t\t\tparam.elements.forEach((element) => {\n\t\t\t\tif (element) extractors[element.type](nodes, element);\n\t\t\t});\n\t\t},\n\n\t\tRestElement(nodes, param) {\n\t\t\textractors[param.argument.type](nodes, param.argument);\n\t\t},\n\n\t\tAssignmentPattern(nodes, param) {\n\t\t\textractors[param.left.type](nodes, param.left);\n\t\t}\n\t};\n\n\tvar chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n\tfunction encode(decoded) {\n\t    var sourceFileIndex = 0; // second field\n\t    var sourceCodeLine = 0; // third field\n\t    var sourceCodeColumn = 0; // fourth field\n\t    var nameIndex = 0; // fifth field\n\t    var mappings = '';\n\t    for (var i = 0; i < decoded.length; i++) {\n\t        var line = decoded[i];\n\t        if (i > 0)\n\t            mappings += ';';\n\t        if (line.length === 0)\n\t            continue;\n\t        var generatedCodeColumn = 0; // first field\n\t        var lineMappings = [];\n\t        for (var _i = 0, line_1 = line; _i < line_1.length; _i++) {\n\t            var segment = line_1[_i];\n\t            var segmentMappings = encodeInteger(segment[0] - generatedCodeColumn);\n\t            generatedCodeColumn = segment[0];\n\t            if (segment.length > 1) {\n\t                segmentMappings +=\n\t                    encodeInteger(segment[1] - sourceFileIndex) +\n\t                        encodeInteger(segment[2] - sourceCodeLine) +\n\t                        encodeInteger(segment[3] - sourceCodeColumn);\n\t                sourceFileIndex = segment[1];\n\t                sourceCodeLine = segment[2];\n\t                sourceCodeColumn = segment[3];\n\t            }\n\t            if (segment.length === 5) {\n\t                segmentMappings += encodeInteger(segment[4] - nameIndex);\n\t                nameIndex = segment[4];\n\t            }\n\t            lineMappings.push(segmentMappings);\n\t        }\n\t        mappings += lineMappings.join(',');\n\t    }\n\t    return mappings;\n\t}\n\tfunction encodeInteger(num) {\n\t    var result = '';\n\t    num = num < 0 ? (-num << 1) | 1 : num << 1;\n\t    do {\n\t        var clamped = num & 31;\n\t        num >>>= 5;\n\t        if (num > 0) {\n\t            clamped |= 32;\n\t        }\n\t        result += chars[clamped];\n\t    } while (num > 0);\n\t    return result;\n\t}\n\n\t// generate an ID that is, to all intents and purposes, unique\n\tconst id = (Math.round(Math.random() * 1e20)).toString(36);\n\tconst re = new RegExp(`_${id}_(?:(\\\\d+)|(AT)|(HASH))_(\\\\w+)?`, 'g');\n\n\tconst get_comment_handlers = (comments, raw) => ({\n\n\t\t// pass to acorn options\n\t\tonComment: (block, value, start, end) => {\n\t\t\tif (block && /\\n/.test(value)) {\n\t\t\t\tlet a = start;\n\t\t\t\twhile (a > 0 && raw[a - 1] !== '\\n') a -= 1;\n\n\t\t\t\tlet b = a;\n\t\t\t\twhile (/[ \\t]/.test(raw[b])) b += 1;\n\n\t\t\t\tconst indentation = raw.slice(a, b);\n\t\t\t\tvalue = value.replace(new RegExp(`^${indentation}`, 'gm'), '');\n\t\t\t}\n\n\t\t\tcomments.push({ type: block ? 'Block' : 'Line', value, start, end });\n\t\t},\n\n\t\t// pass to estree-walker options\n\t\tenter(node) {\n\t\t\tlet comment;\n\n\t\t\twhile (comments[0] && comments[0].start < (node ).start) {\n\t\t\t\tcomment = comments.shift();\n\n\t\t\t\tcomment.value = comment.value.replace(re, (match, id, at, hash, value) => {\n\t\t\t\t\tif (hash) return `#${value}`;\n\t\t\t\t\tif (at) return `@${value}`;\n\n\t\t\t\t\treturn match;\n\t\t\t\t});\n\n\t\t\t\tconst next = comments[0] || node;\n\t\t\t\t(comment ).has_trailing_newline = (\n\t\t\t\t\tcomment.type === 'Line' ||\n\t\t\t\t\t/\\n/.test(raw.slice(comment.end, (next ).start))\n\t\t\t\t);\n\n\t\t\t\t(node.leadingComments || (node.leadingComments = [])).push(comment);\n\t\t\t}\n\t\t},\n\t\tleave(node) {\n\t\t\tif (comments[0]) {\n\t\t\t\tconst slice = raw.slice((node ).end, comments[0].start);\n\n\t\t\t\tif (/^[,) \\t]*$/.test(slice)) {\n\t\t\t\t\tnode.trailingComments = [comments.shift()];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t});\n\n\tfunction handle(node, state) {\n\t\tconst handler = handlers[node.type];\n\n\t\tif (!handler) {\n\t\t\tthrow new Error(`Not implemented ${node.type}`);\n\t\t}\n\n\t\tconst result = handler(node, state);\n\n\t\tif (node.leadingComments) {\n\t\t\tresult.unshift(c(node.leadingComments.map(comment => comment.type === 'Block'\n\t\t\t\t? `/*${comment.value}*/${(comment ).has_trailing_newline ? `\\n${state.indent}` : ` `}`\n\t\t\t\t: `//${comment.value}${(comment ).has_trailing_newline ? `\\n${state.indent}` : ` `}`).join(``)));\n\t\t}\n\n\t\tif (node.trailingComments) {\n\t\t\tstate.comments.push(node.trailingComments[0]); // there is only ever one\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tfunction c(content, node) {\n\t\treturn {\n\t\t\tcontent,\n\t\t\tloc: node && node.loc,\n\t\t\thas_newline: /\\n/.test(content)\n\t\t};\n\t}\n\n\tconst OPERATOR_PRECEDENCE = {\n\t\t'||': 2,\n\t\t'&&': 3,\n\t\t'??': 4,\n\t\t'|': 5,\n\t\t'^': 6,\n\t\t'&': 7,\n\t\t'==': 8,\n\t\t'!=': 8,\n\t\t'===': 8,\n\t\t'!==': 8,\n\t\t'<': 9,\n\t\t'>': 9,\n\t\t'<=': 9,\n\t\t'>=': 9,\n\t\tin: 9,\n\t\tinstanceof: 9,\n\t\t'<<': 10,\n\t\t'>>': 10,\n\t\t'>>>': 10,\n\t\t'+': 11,\n\t\t'-': 11,\n\t\t'*': 12,\n\t\t'%': 12,\n\t\t'/': 12,\n\t\t'**': 13,\n\t};\n\n\tconst EXPRESSIONS_PRECEDENCE = {\n\t\tArrayExpression: 20,\n\t\tTaggedTemplateExpression: 20,\n\t\tThisExpression: 20,\n\t\tIdentifier: 20,\n\t\tLiteral: 18,\n\t\tTemplateLiteral: 20,\n\t\tSuper: 20,\n\t\tSequenceExpression: 20,\n\t\tMemberExpression: 19,\n\t\tCallExpression: 19,\n\t\tNewExpression: 19,\n\t\tAwaitExpression: 17,\n\t\tClassExpression: 17,\n\t\tFunctionExpression: 17,\n\t\tObjectExpression: 17,\n\t\tUpdateExpression: 16,\n\t\tUnaryExpression: 15,\n\t\tBinaryExpression: 14,\n\t\tLogicalExpression: 13,\n\t\tConditionalExpression: 4,\n\t\tArrowFunctionExpression: 3,\n\t\tAssignmentExpression: 3,\n\t\tYieldExpression: 2,\n\t\tRestElement: 1\n\t};\n\n\tfunction needs_parens(node, parent, is_right) {\n\t\tconst precedence = EXPRESSIONS_PRECEDENCE[node.type];\n\t\tconst parent_precedence = EXPRESSIONS_PRECEDENCE[parent.type];\n\n\t\tif (precedence !== parent_precedence) {\n\t\t\t// Different node types\n\t\t\treturn (\n\t\t\t\t(!is_right &&\n\t\t\t\t\tprecedence === 15 &&\n\t\t\t\t\tparent_precedence === 14 &&\n\t\t\t\t\tparent.operator === '**') ||\n\t\t\t\tprecedence < parent_precedence\n\t\t\t);\n\t\t}\n\n\t\tif (precedence !== 13 && precedence !== 14) {\n\t\t\t// Not a `LogicalExpression` or `BinaryExpression`\n\t\t\treturn false;\n\t\t}\n\n\t\tif ((node ).operator === '**' && parent.operator === '**') {\n\t\t\t// Exponentiation operator has right-to-left associativity\n\t\t\treturn !is_right;\n\t\t}\n\n\t\tif (is_right) {\n\t\t\t// Parenthesis are used if both operators have the same precedence\n\t\t\treturn (\n\t\t\t\tOPERATOR_PRECEDENCE[(node ).operator] <=\n\t\t\t\tOPERATOR_PRECEDENCE[parent.operator]\n\t\t\t);\n\t\t}\n\n\t\treturn (\n\t\t\tOPERATOR_PRECEDENCE[(node ).operator] <\n\t\t\tOPERATOR_PRECEDENCE[parent.operator]\n\t\t);\n\t}\n\n\tfunction has_call_expression(node) {\n\t\twhile (node) {\n\t\t\tif (node.type[0] === 'CallExpression') {\n\t\t\t\treturn true;\n\t\t\t} else if (node.type === 'MemberExpression') {\n\t\t\t\tnode = node.object;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\tconst has_newline = (chunks) => {\n\t\tfor (let i = 0; i < chunks.length; i += 1) {\n\t\t\tif (chunks[i].has_newline) return true;\n\t\t}\n\t\treturn false;\n\t};\n\n\tconst get_length = (chunks) => {\n\t\tlet total = 0;\n\t\tfor (let i = 0; i < chunks.length; i += 1) {\n\t\t\ttotal += chunks[i].content.length;\n\t\t}\n\t\treturn total;\n\t};\n\n\tconst sum = (a, b) => a + b;\n\n\tconst join = (nodes, separator) => {\n\t\tif (nodes.length === 0) return [];\n\t\tconst joined = [...nodes[0]];\n\t\tfor (let i = 1; i < nodes.length; i += 1) {\n\t\t\tjoined.push(separator, ...nodes[i] );\n\t\t}\n\t\treturn joined;\n\t};\n\n\tconst scoped = (fn) => {\n\t\treturn (node, state) => {\n\t\t\treturn fn(node, {\n\t\t\t\t...state,\n\t\t\t\tscope: state.scope_map.get(node)\n\t\t\t});\n\t\t};\n\t};\n\n\tconst deconflict = (name, names) => {\n\t\tconst original = name;\n\t\tlet i = 1;\n\n\t\twhile (names.has(name)) {\n\t\t\tname = `${original}$${i++}`;\n\t\t}\n\n\t\treturn name;\n\t};\n\n\tconst handle_body = (nodes, state) => {\n\t\tconst chunks = [];\n\n\t\tconst body = nodes.map(statement => {\n\t\t\tconst chunks = handle(statement, {\n\t\t\t\t...state,\n\t\t\t\tindent: state.indent\n\t\t\t});\n\n\t\t\tlet add_newline = false;\n\n\t\t\twhile (state.comments.length) {\n\t\t\t\tconst comment = state.comments.shift();\n\t\t\t\tconst prefix = add_newline ? `\\n${state.indent}` : ` `;\n\n\t\t\t\tchunks.push(c(comment.type === 'Block'\n\t\t\t\t\t? `${prefix}/*${comment.value}*/`\n\t\t\t\t\t: `${prefix}//${comment.value}`));\n\n\t\t\t\tadd_newline = (comment.type === 'Line');\n\t\t\t}\n\n\t\t\treturn chunks;\n\t\t});\n\n\t\tlet needed_padding = false;\n\n\t\tfor (let i = 0; i < body.length; i += 1) {\n\t\t\tconst needs_padding = has_newline(body[i]);\n\n\t\t\tif (i > 0) {\n\t\t\t\tchunks.push(\n\t\t\t\t\tc(needs_padding || needed_padding ? `\\n\\n${state.indent}` : `\\n${state.indent}`)\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tchunks.push(\n\t\t\t\t...body[i]\n\t\t\t);\n\n\t\t\tneeded_padding = needs_padding;\n\t\t}\n\n\t\treturn chunks;\n\t};\n\n\tconst handle_var_declaration = (node, state) => {\n\t\tconst chunks = [c(`${node.kind} `)];\n\n\t\tconst declarators = node.declarations.map(d => handle(d, {\n\t\t\t...state,\n\t\t\tindent: state.indent + (node.declarations.length === 1 ? '' : '\\t')\n\t\t}));\n\n\t\tconst multiple_lines = (\n\t\t\tdeclarators.some(has_newline) ||\n\t\t\t(declarators.map(get_length).reduce(sum, 0) + (state.indent.length + declarators.length - 1) * 2) > 80\n\t\t);\n\n\t\tconst separator = c(multiple_lines ? `,\\n${state.indent}\\t` : ', ');\n\n\t\tif (multiple_lines) {\n\t\t\tchunks.push(...join(declarators, separator));\n\t\t} else {\n\t\t\tchunks.push(\n\t\t\t\t...join(declarators, separator)\n\t\t\t);\n\t\t}\n\n\t\treturn chunks;\n\t};\n\n\tconst handlers = {\n\t\tProgram(node, state) {\n\t\t\treturn handle_body(node.body, state);\n\t\t},\n\n\t\tBlockStatement: scoped((node, state) => {\n\t\t\treturn [\n\t\t\t\tc(`{\\n${state.indent}\\t`),\n\t\t\t\t...handle_body(node.body, { ...state, indent: state.indent + '\\t' }),\n\t\t\t\tc(`\\n${state.indent}}`)\n\t\t\t];\n\t\t}),\n\n\t\tEmptyStatement(node, state) {\n\t\t\treturn [];\n\t\t},\n\n\t\tParenthesizedExpression(node, state) {\n\t\t\treturn handle(node.expression, state);\n\t\t},\n\n\t\tExpressionStatement(node, state) {\n\t\t\tif (\n\t\t\t\tnode.expression.type === 'AssignmentExpression' &&\n\t\t\t\tnode.expression.left.type === 'ObjectPattern'\n\t\t\t) {\n\t\t\t\t// is an AssignmentExpression to an ObjectPattern\n\t\t\t\treturn [\n\t\t\t\t\tc('('),\n\t\t\t\t\t...handle(node.expression, state),\n\t\t\t\t\tc(');')\n\t\t\t\t];\n\t\t\t}\n\n\t\t\treturn [\n\t\t\t\t...handle(node.expression, state),\n\t\t\t\tc(';')\n\t\t\t];\n\t\t},\n\n\t\tIfStatement(node, state) {\n\t\t\tconst chunks = [\n\t\t\t\tc('if ('),\n\t\t\t\t...handle(node.test, state),\n\t\t\t\tc(') '),\n\t\t\t\t...handle(node.consequent, state)\n\t\t\t];\n\n\t\t\tif (node.alternate) {\n\t\t\t\tchunks.push(\n\t\t\t\t\tc(' else '),\n\t\t\t\t\t...handle(node.alternate, state)\n\t\t\t\t);\n\t\t\t}\n\n\t\t\treturn chunks;\n\t\t},\n\n\t\tLabeledStatement(node, state) {\n\t\t\treturn [\n\t\t\t\t...handle(node.label, state),\n\t\t\t\tc(': '),\n\t\t\t\t...handle(node.body, state)\n\t\t\t];\n\t\t},\n\n\t\tBreakStatement(node, state) {\n\t\t\treturn node.label\n\t\t\t\t? [c('break '), ...handle(node.label, state), c(';')]\n\t\t\t\t: [c('break;')];\n\t\t},\n\n\t\tContinueStatement(node, state) {\n\t\t\treturn node.label\n\t\t\t\t? [c('continue '), ...handle(node.label, state), c(';')]\n\t\t\t\t: [c('continue;')];\n\t\t},\n\n\t\tWithStatement(node, state) {\n\t\t\treturn [\n\t\t\t\tc('with ('),\n\t\t\t\t...handle(node.object, state),\n\t\t\t\tc(') '),\n\t\t\t\t...handle(node.body, state)\n\t\t\t];\n\t\t},\n\n\t\tSwitchStatement(node, state) {\n\t\t\tconst chunks = [\n\t\t\t\tc('switch ('),\n\t\t\t\t...handle(node.discriminant, state),\n\t\t\t\tc(') {')\n\t\t\t];\n\n\t\t\tnode.cases.forEach(block => {\n\t\t\t\tif (block.test) {\n\t\t\t\t\tchunks.push(\n\t\t\t\t\t\tc(`\\n${state.indent}\\tcase `),\n\t\t\t\t\t\t...handle(block.test, { ...state, indent: `${state.indent}\\t` }),\n\t\t\t\t\t\tc(':')\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tchunks.push(c(`\\n${state.indent}\\tdefault:`));\n\t\t\t\t}\n\n\t\t\t\tblock.consequent.forEach(statement => {\n\t\t\t\t\tchunks.push(\n\t\t\t\t\t\tc(`\\n${state.indent}\\t\\t`),\n\t\t\t\t\t\t...handle(statement, { ...state, indent: `${state.indent}\\t\\t` })\n\t\t\t\t\t);\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tchunks.push(c(`\\n${state.indent}}`));\n\n\t\t\treturn chunks;\n\t\t},\n\n\t\tReturnStatement(node, state) {\n\t\t\tif (node.argument) {\n\t\t\t\treturn [\n\t\t\t\t\tc('return '),\n\t\t\t\t\t...handle(node.argument, state),\n\t\t\t\t\tc(';')\n\t\t\t\t];\n\t\t\t} else {\n\t\t\t\treturn [c('return;')];\n\t\t\t}\n\t\t},\n\n\t\tThrowStatement(node, state) {\n\t\t\treturn [\n\t\t\t\tc('throw '),\n\t\t\t\t...handle(node.argument, state),\n\t\t\t\tc(';')\n\t\t\t];\n\t\t},\n\n\t\tTryStatement(node, state) {\n\t\t\tconst chunks = [\n\t\t\t\tc('try '),\n\t\t\t\t...handle(node.block, state)\n\t\t\t];\n\n\t\t\tif (node.handler) {\n\t\t\t\tif (node.handler.param) {\n\t\t\t\t\tchunks.push(\n\t\t\t\t\t\tc(' catch('),\n\t\t\t\t\t\t...handle(node.handler.param, state),\n\t\t\t\t\t\tc(') ')\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tchunks.push(c(' catch '));\n\t\t\t\t}\n\n\t\t\t\tchunks.push(...handle(node.handler.body, state));\n\t\t\t}\n\n\t\t\tif (node.finalizer) {\n\t\t\t\tchunks.push(c(' finally '), ...handle(node.finalizer, state));\n\t\t\t}\n\n\t\t\treturn chunks;\n\t\t},\n\n\t\tWhileStatement(node, state) {\n\t\t\treturn [\n\t\t\t\tc('while ('),\n\t\t\t\t...handle(node.test, state),\n\t\t\t\tc(') '),\n\t\t\t\t...handle(node.body, state)\n\t\t\t];\n\t\t},\n\n\t\tDoWhileStatement(node, state) {\n\t\t\treturn [\n\t\t\t\tc('do '),\n\t\t\t\t...handle(node.body, state),\n\t\t\t\tc(' while ('),\n\t\t\t\t...handle(node.test, state),\n\t\t\t\tc(');')\n\t\t\t];\n\t\t},\n\n\t\tForStatement: scoped((node, state) => {\n\t\t\tconst chunks = [c('for (')];\n\n\t\t\tif (node.init) {\n\t\t\t\tif ((node.init ).type === 'VariableDeclaration') {\n\t\t\t\t\tchunks.push(...handle_var_declaration(node.init , state));\n\t\t\t\t} else {\n\t\t\t\t\tchunks.push(...handle(node.init, state));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tchunks.push(c('; '));\n\t\t\tif (node.test) chunks.push(...handle(node.test, state));\n\t\t\tchunks.push(c('; '));\n\t\t\tif (node.update) chunks.push(...handle(node.update, state));\n\n\t\t\tchunks.push(\n\t\t\t\tc(') '),\n\t\t\t\t...handle(node.body, state)\n\t\t\t);\n\n\t\t\treturn chunks;\n\t\t}),\n\n\t\tForInStatement: scoped((node, state) => {\n\t\t\tconst chunks = [\n\t\t\t\tc(`for ${(node ).await ? 'await ' : ''}(`)\n\t\t\t];\n\n\t\t\tif ((node.left ).type === 'VariableDeclaration') {\n\t\t\t\tchunks.push(...handle_var_declaration(node.left , state));\n\t\t\t} else {\n\t\t\t\tchunks.push(...handle(node.left, state));\n\t\t\t}\n\n\t\t\tchunks.push(\n\t\t\t\tc(node.type === 'ForInStatement' ? ` in ` : ` of `),\n\t\t\t\t...handle(node.right, state),\n\t\t\t\tc(') '),\n\t\t\t\t...handle(node.body, state)\n\t\t\t);\n\n\t\t\treturn chunks;\n\t\t}),\n\n\t\tDebuggerStatement(node, state) {\n\t\t\treturn [c('debugger', node), c(';')];\n\t\t},\n\n\t\tFunctionDeclaration: scoped((node, state) => {\n\t\t\tconst chunks = [];\n\n\t\t\tif (node.async) chunks.push(c('async '));\n\t\t\tchunks.push(c(node.generator ? 'function* ' : 'function '));\n\t\t\tif (node.id) chunks.push(...handle(node.id, state));\n\t\t\tchunks.push(c('('));\n\n\t\t\tconst params = node.params.map(p => handle(p, {\n\t\t\t\t...state,\n\t\t\t\tindent: state.indent + '\\t'\n\t\t\t}));\n\n\t\t\tconst multiple_lines = (\n\t\t\t\tparams.some(has_newline) ||\n\t\t\t\t(params.map(get_length).reduce(sum, 0) + (state.indent.length + params.length - 1) * 2) > 80\n\t\t\t);\n\n\t\t\tconst separator = c(multiple_lines ? `,\\n${state.indent}` : ', ');\n\n\t\t\tif (multiple_lines) {\n\t\t\t\tchunks.push(\n\t\t\t\t\tc(`\\n${state.indent}\\t`),\n\t\t\t\t\t...join(params, separator),\n\t\t\t\t\tc(`\\n${state.indent}`)\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tchunks.push(\n\t\t\t\t\t...join(params, separator)\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tchunks.push(\n\t\t\t\tc(') '),\n\t\t\t\t...handle(node.body, state)\n\t\t\t);\n\n\t\t\treturn chunks;\n\t\t}),\n\n\t\tVariableDeclaration(node, state) {\n\t\t\treturn handle_var_declaration(node, state).concat(c(';'));\n\t\t},\n\n\t\tVariableDeclarator(node, state) {\n\t\t\tif (node.init) {\n\t\t\t\treturn [\n\t\t\t\t\t...handle(node.id, state),\n\t\t\t\t\tc(' = '),\n\t\t\t\t\t...handle(node.init, state)\n\t\t\t\t];\n\t\t\t} else {\n\t\t\t\treturn handle(node.id, state);\n\t\t\t}\n\t\t},\n\n\t\tClassDeclaration(node, state) {\n\t\t\tconst chunks = [c('class ')];\n\n\t\t\tif (node.id) chunks.push(...handle(node.id, state), c(' '));\n\n\t\t\tif (node.superClass) {\n\t\t\t\tchunks.push(\n\t\t\t\t\tc('extends '),\n\t\t\t\t\t...handle(node.superClass, state),\n\t\t\t\t\tc(' ')\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tchunks.push(...handle(node.body, state));\n\n\t\t\treturn chunks;\n\t\t},\n\n\t\tImportDeclaration(node, state) {\n\t\t\tconst chunks = [c('import ')];\n\n\t\t\tconst { length } = node.specifiers;\n\t\t\tconst source = handle(node.source, state);\n\n\t\t\tif (length > 0) {\n\t\t\t\tlet i = 0;\n\n\t\t\t\twhile (i < length) {\n\t\t\t\t\tif (i > 0) {\n\t\t\t\t\t\tchunks.push(c(', '));\n\t\t\t\t\t}\n\n\t\t\t\t\tconst specifier = node.specifiers[i];\n\n\t\t\t\t\tif (specifier.type === 'ImportDefaultSpecifier') {\n\t\t\t\t\t\tchunks.push(c(specifier.local.name, specifier));\n\t\t\t\t\t\ti += 1;\n\t\t\t\t\t} else if (specifier.type === 'ImportNamespaceSpecifier') {\n\t\t\t\t\t\tchunks.push(c('* as ' + specifier.local.name, specifier));\n\t\t\t\t\t\ti += 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (i < length) {\n\t\t\t\t\t// we have named specifiers\n\t\t\t\t\tconst specifiers = node.specifiers.slice(i).map((specifier) => {\n\t\t\t\t\t\tconst name = handle(specifier.imported, state)[0];\n\t\t\t\t\t\tconst as = handle(specifier.local, state)[0];\n\n\t\t\t\t\t\tif (name.content === as.content) {\n\t\t\t\t\t\t\treturn [as];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn [name, c(' as '), as];\n\t\t\t\t\t});\n\n\t\t\t\t\tconst width = get_length(chunks) + specifiers.map(get_length).reduce(sum, 0) + (2 * specifiers.length) + 6 + get_length(source);\n\n\t\t\t\t\tif (width > 80) {\n\t\t\t\t\t\tchunks.push(\n\t\t\t\t\t\t\tc(`{\\n\\t`),\n\t\t\t\t\t\t\t...join(specifiers, c(',\\n\\t')),\n\t\t\t\t\t\t\tc('\\n}')\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tchunks.push(\n\t\t\t\t\t\t\tc(`{ `),\n\t\t\t\t\t\t\t...join(specifiers, c(', ')),\n\t\t\t\t\t\t\tc(' }')\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tchunks.push(c(' from '));\n\t\t\t}\n\n\t\t\tchunks.push(\n\t\t\t\t...source,\n\t\t\t\tc(';')\n\t\t\t);\n\n\t\t\treturn chunks;\n\t\t},\n\n\t\tImportExpression(node, state) {\n\t\t\treturn [c('import('), ...handle(node.source, state), c(')')];\n\t\t},\n\n\t\tExportDefaultDeclaration(node, state) {\n\t\t\tconst chunks = [\n\t\t\t\tc(`export default `),\n\t\t\t\t...handle(node.declaration, state)\n\t\t\t];\n\n\t\t\tif (node.declaration.type !== 'FunctionDeclaration') {\n\t\t\t\tchunks.push(c(';'));\n\t\t\t}\n\n\t\t\treturn chunks;\n\t\t},\n\n\t\tExportNamedDeclaration(node, state) {\n\t\t\tconst chunks = [c('export ')];\n\n\t\t\tif (node.declaration) {\n\t\t\t\tchunks.push(...handle(node.declaration, state));\n\t\t\t} else {\n\t\t\t\tconst specifiers = node.specifiers.map(specifier => {\n\t\t\t\t\tconst name = handle(specifier.local, state)[0];\n\t\t\t\t\tconst as = handle(specifier.exported, state)[0];\n\n\t\t\t\t\tif (name.content === as.content) {\n\t\t\t\t\t\treturn [name];\n\t\t\t\t\t}\n\n\t\t\t\t\treturn [name, c(' as '), as];\n\t\t\t\t});\n\n\t\t\t\tconst width = 7 + specifiers.map(get_length).reduce(sum, 0) + 2 * specifiers.length;\n\n\t\t\t\tif (width > 80) {\n\t\t\t\t\tchunks.push(\n\t\t\t\t\t\tc('{\\n\\t'),\n\t\t\t\t\t\t...join(specifiers, c(',\\n\\t')),\n\t\t\t\t\t\tc('\\n}')\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tchunks.push(\n\t\t\t\t\t\tc('{ '),\n\t\t\t\t\t\t...join(specifiers, c(', ')),\n\t\t\t\t\t\tc(' }')\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tif (node.source) {\n\t\t\t\t\tchunks.push(\n\t\t\t\t\t\tc(' from '),\n\t\t\t\t\t\t...handle(node.source, state)\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tchunks.push(c(';'));\n\n\t\t\treturn chunks;\n\t\t},\n\n\t\tExportAllDeclaration(node, state) {\n\t\t\treturn [\n\t\t\t\tc(`export * from `),\n\t\t\t\t...handle(node.source, state),\n\t\t\t\tc(`;`)\n\t\t\t];\n\t\t},\n\n\t\tMethodDefinition(node, state) {\n\t\t\tconst chunks = [];\n\n\t\t\tif (node.static) {\n\t\t\t\tchunks.push(c('static '));\n\t\t\t}\n\n\t\t\tif (node.kind === 'get' || node.kind === 'set') {\n\t\t\t\t// Getter or setter\n\t\t\t\tchunks.push(c(node.kind + ' '));\n\t\t\t}\n\n\t\t\tif (node.value.async) {\n\t\t\t\tchunks.push(c('async '));\n\t\t\t}\n\n\t\t\tif (node.value.generator) {\n\t\t\t\tchunks.push(c('*'));\n\t\t\t}\n\n\t\t\tif (node.computed) {\n\t\t\t\tchunks.push(\n\t\t\t\t\tc('['),\n\t\t\t\t\t...handle(node.key, state),\n\t\t\t\t\tc(']')\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tchunks.push(...handle(node.key, state));\n\t\t\t}\n\n\t\t\tchunks.push(c('('));\n\n\t\t\tconst { params } = node.value;\n\t\t\tfor (let i = 0; i < params.length; i += 1) {\n\t\t\t\tchunks.push(...handle(params[i], state));\n\t\t\t\tif (i < params.length - 1) chunks.push(c(', '));\n\t\t\t}\n\n\t\t\tchunks.push(\n\t\t\t\tc(') '),\n\t\t\t\t...handle(node.value.body, state)\n\t\t\t);\n\n\t\t\treturn chunks;\n\t\t},\n\n\t\tArrowFunctionExpression: scoped((node, state) => {\n\t\t\tconst chunks = [];\n\n\t\t\tif (node.async) chunks.push(c('async '));\n\n\t\t\tif (node.params.length === 1 && node.params[0].type === 'Identifier') {\n\t\t\t\tchunks.push(...handle(node.params[0], state));\n\t\t\t} else {\n\t\t\t\tconst params = node.params.map(param => handle(param, {\n\t\t\t\t\t...state,\n\t\t\t\t\tindent: state.indent + '\\t'\n\t\t\t\t}));\n\n\t\t\t\tchunks.push(\n\t\t\t\t\tc('('),\n\t\t\t\t\t...join(params, c(', ')),\n\t\t\t\t\tc(')')\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tchunks.push(c(' => '));\n\n\t\t\tif (node.body.type === 'ObjectExpression') {\n\t\t\t\tchunks.push(\n\t\t\t\t\tc('('),\n\t\t\t\t\t...handle(node.body, state),\n\t\t\t\t\tc(')')\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tchunks.push(...handle(node.body, state));\n\t\t\t}\n\n\t\t\treturn chunks;\n\t\t}),\n\n\t\tThisExpression(node, state) {\n\t\t\treturn [c('this', node)];\n\t\t},\n\n\t\tSuper(node, state) {\n\t\t\treturn [c('super', node)];\n\t\t},\n\n\t\tRestElement(node, state) {\n\t\t\treturn [c('...'), ...handle(node.argument, state)];\n\t\t},\n\n\t\tYieldExpression(node, state) {\n\t\t\tif (node.argument) {\n\t\t\t\treturn [c(node.delegate ? `yield* ` : `yield `), ...handle(node.argument, state)];\n\t\t\t}\n\n\t\t\treturn [c(node.delegate ? `yield*` : `yield`)];\n\t\t},\n\n\t\tAwaitExpression(node, state) {\n\t\t\tif (node.argument) {\n\t\t\t\tconst precedence = EXPRESSIONS_PRECEDENCE[node.argument.type];\n\n\t\t\t\tif (precedence && (precedence < EXPRESSIONS_PRECEDENCE.AwaitExpression)) {\n\t\t\t\t\treturn [c('await ('), ...handle(node.argument, state), c(')')];\n\t\t\t\t} else {\n\t\t\t\t\treturn [c('await '), ...handle(node.argument, state)];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn [c('await')];\n\t\t},\n\n\t\tTemplateLiteral(node, state) {\n\t\t\tconst chunks = [c('`')];\n\n\t\t\tconst { quasis, expressions } = node;\n\n\t\t\tfor (let i = 0; i < expressions.length; i++) {\n\t\t\t\tchunks.push(\n\t\t\t\t\tc(quasis[i].value.raw),\n\t\t\t\t\tc('${'),\n\t\t\t\t\t...handle(expressions[i], state),\n\t\t\t\t\tc('}')\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tchunks.push(\n\t\t\t\tc(quasis[quasis.length - 1].value.raw),\n\t\t\t\tc('`')\n\t\t\t);\n\n\t\t\treturn chunks;\n\t\t},\n\n\t\tTaggedTemplateExpression(node, state) {\n\t\t\treturn handle(node.tag, state).concat(handle(node.quasi, state));\n\t\t},\n\n\t\tArrayExpression(node, state) {\n\t\t\tconst chunks = [c('[')];\n\n\t\t\tconst elements = [];\n\t\t\tlet sparse_commas = [];\n\n\t\t\tfor (let i = 0; i < node.elements.length; i += 1) {\n\t\t\t\t// can't use map/forEach because of sparse arrays\n\t\t\t\tconst element = node.elements[i];\n\t\t\t\tif (element) {\n\t\t\t\t\telements.push([...sparse_commas, ...handle(element, {\n\t\t\t\t\t\t...state,\n\t\t\t\t\t\tindent: state.indent + '\\t'\n\t\t\t\t\t})]);\n\t\t\t\t\tsparse_commas = [];\n\t\t\t\t} else {\n\t\t\t\t\tsparse_commas.push(c(','));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst multiple_lines = (\n\t\t\t\telements.some(has_newline) ||\n\t\t\t\t(elements.map(get_length).reduce(sum, 0) + (state.indent.length + elements.length - 1) * 2) > 80\n\t\t\t);\n\n\t\t\tif (multiple_lines) {\n\t\t\t\tchunks.push(\n\t\t\t\t\tc(`\\n${state.indent}\\t`),\n\t\t\t\t\t...join(elements, c(`,\\n${state.indent}\\t`)),\n\t\t\t\t\tc(`\\n${state.indent}`),\n\t\t\t\t\t...sparse_commas\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tchunks.push(...join(elements, c(', ')), ...sparse_commas);\n\t\t\t}\n\n\t\t\tchunks.push(c(']'));\n\n\t\t\treturn chunks;\n\t\t},\n\n\t\tObjectExpression(node, state) {\n\t\t\tif (node.properties.length === 0) {\n\t\t\t\treturn [c('{}')];\n\t\t\t}\n\n\t\t\tlet has_inline_comment = false;\n\n\t\t\tconst chunks = [];\n\t\t\tconst separator = c(', ');\n\n\t\t\tnode.properties.forEach((p, i) => {\n\t\t\t\tchunks.push(...handle(p, {\n\t\t\t\t\t...state,\n\t\t\t\t\tindent: state.indent + '\\t'\n\t\t\t\t}));\n\n\t\t\t\tif (state.comments.length) {\n\t\t\t\t\t// TODO generalise this, so it works with ArrayExpressions and other things.\n\t\t\t\t\t// At present, stuff will just get appended to the closest statement/declaration\n\t\t\t\t\tchunks.push(c(', '));\n\n\t\t\t\t\twhile (state.comments.length) {\n\t\t\t\t\t\tconst comment = state.comments.shift();\n\n\t\t\t\t\t\tchunks.push(c(comment.type === 'Block'\n\t\t\t\t\t\t\t? `/*${comment.value}*/\\n${state.indent}\\t`\n\t\t\t\t\t\t\t: `//${comment.value}\\n${state.indent}\\t`));\n\n\t\t\t\t\t\tif (comment.type === 'Line') {\n\t\t\t\t\t\t\thas_inline_comment = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (i < node.properties.length - 1) {\n\t\t\t\t\t\tchunks.push(separator);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tconst multiple_lines = (\n\t\t\t\thas_inline_comment ||\n\t\t\t\thas_newline(chunks) ||\n\t\t\t\tget_length(chunks) > 40\n\t\t\t);\n\n\t\t\tif (multiple_lines) {\n\t\t\t\tseparator.content = `,\\n${state.indent}\\t`;\n\t\t\t}\n\n\t\t\treturn [\n\t\t\t\tc(multiple_lines ? `{\\n${state.indent}\\t` : `{ `),\n\t\t\t\t...chunks,\n\t\t\t\tc(multiple_lines ? `\\n${state.indent}}` : ` }`)\n\t\t\t];\n\t\t},\n\n\t\tProperty(node, state) {\n\t\t\tconst value = handle(node.value, state);\n\n\t\t\tif (node.key === node.value) {\n\t\t\t\treturn value;\n\t\t\t}\n\n\t\t\t// special case\n\t\t\tif (\n\t\t\t\t!node.computed &&\n\t\t\t\tnode.value.type === 'AssignmentPattern' &&\n\t\t\t\tnode.value.left.type === 'Identifier' &&\n\t\t\t\tnode.value.left.name === (node.key ).name\n\t\t\t) {\n\t\t\t\treturn value;\n\t\t\t}\n\n\t\t\tif (node.value.type === 'Identifier' && (\n\t\t\t\t(node.key.type === 'Identifier' && node.key.name === value[0].content) ||\n\t\t\t\t(node.key.type === 'Literal' && node.key.value === value[0].content)\n\t\t\t)) {\n\t\t\t\treturn value;\n\t\t\t}\n\n\t\t\tconst key = handle(node.key, state);\n\n\t\t\tif (node.value.type === 'FunctionExpression' && !node.value.id) {\n\t\t\t\tstate = {\n\t\t\t\t\t...state,\n\t\t\t\t\tscope: state.scope_map.get(node.value)\n\t\t\t\t};\n\n\t\t\t\tconst chunks = node.kind !== 'init'\n\t\t\t\t\t? [c(`${node.kind} `)]\n\t\t\t\t\t: [];\n\n\t\t\t\tif (node.value.async) {\n\t\t\t\t\tchunks.push(c('async '));\n\t\t\t\t}\n\t\t\t\tif (node.value.generator) {\n\t\t\t\t\tchunks.push(c('*'));\n\t\t\t\t}\n\n\t\t\t\tchunks.push(\n\t\t\t\t\t...(node.computed ? [c('['), ...key, c(']')] : key),\n\t\t\t\t\tc('('),\n\t\t\t\t\t...join((node.value ).params.map(param => handle(param, state)), c(', ')),\n\t\t\t\t\tc(') '),\n\t\t\t\t\t...handle((node.value ).body, state)\n\t\t\t\t);\n\n\t\t\t\treturn chunks;\n\t\t\t}\n\n\t\t\tif (node.computed) {\n\t\t\t\treturn [\n\t\t\t\t\tc('['),\n\t\t\t\t\t...key,\n\t\t\t\t\tc(']: '),\n\t\t\t\t\t...value\n\t\t\t\t];\n\t\t\t}\n\n\t\t\treturn [\n\t\t\t\t...key,\n\t\t\t\tc(': '),\n\t\t\t\t...value\n\t\t\t];\n\t\t},\n\n\t\tObjectPattern(node, state) {\n\t\t\tconst chunks = [c('{ ')];\n\n\t\t\tfor (let i = 0; i < node.properties.length; i += 1) {\n\t\t\t\tchunks.push(...handle(node.properties[i], state));\n\t\t\t\tif (i < node.properties.length - 1) chunks.push(c(', '));\n\t\t\t}\n\n\t\t\tchunks.push(c(' }'));\n\n\t\t\treturn chunks;\n\t\t},\n\n\t\tSequenceExpression(node, state) {\n\t\t\tconst expressions = node.expressions.map(e => handle(e, state));\n\n\t\t\treturn [\n\t\t\t\tc('('),\n\t\t\t\t...join(expressions, c(', ')),\n\t\t\t\tc(')')\n\t\t\t];\n\t\t},\n\n\t\tUnaryExpression(node, state) {\n\t\t\tconst chunks = [c(node.operator)];\n\n\t\t\tif (node.operator.length > 1) {\n\t\t\t\tchunks.push(c(' '));\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\tEXPRESSIONS_PRECEDENCE[node.argument.type] <\n\t\t\t\tEXPRESSIONS_PRECEDENCE.UnaryExpression\n\t\t\t) {\n\t\t\t\tchunks.push(\n\t\t\t\t\tc('('),\n\t\t\t\t\t...handle(node.argument, state),\n\t\t\t\t\tc(')')\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tchunks.push(...handle(node.argument, state));\n\t\t\t}\n\n\t\t\treturn chunks;\n\t\t},\n\n\t\tUpdateExpression(node, state) {\n\t\t\treturn node.prefix\n\t\t\t\t? [c(node.operator), ...handle(node.argument, state)]\n\t\t\t\t: [...handle(node.argument, state), c(node.operator)];\n\t\t},\n\n\t\tAssignmentExpression(node, state) {\n\t\t\treturn [\n\t\t\t\t...handle(node.left, state),\n\t\t\t\tc(` ${node.operator || '='} `),\n\t\t\t\t...handle(node.right, state)\n\t\t\t];\n\t\t},\n\n\t\tBinaryExpression(node, state) {\n\t\t\tconst chunks = [];\n\n\t\t\t// TODO\n\t\t\t// const is_in = node.operator === 'in';\n\t\t\t// if (is_in) {\n\t\t\t// \t// Avoids confusion in `for` loops initializers\n\t\t\t// \tchunks.push(c('('));\n\t\t\t// }\n\n\t\t\tif (needs_parens(node.left, node, false)) {\n\t\t\t\tchunks.push(\n\t\t\t\t\tc('('),\n\t\t\t\t\t...handle(node.left, state),\n\t\t\t\t\tc(')')\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tchunks.push(...handle(node.left, state));\n\t\t\t}\n\n\t\t\tchunks.push(c(` ${node.operator} `));\n\n\t\t\tif (needs_parens(node.right, node, true)) {\n\t\t\t\tchunks.push(\n\t\t\t\t\tc('('),\n\t\t\t\t\t...handle(node.right, state),\n\t\t\t\t\tc(')')\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tchunks.push(...handle(node.right, state));\n\t\t\t}\n\n\t\t\treturn chunks;\n\t\t},\n\n\t\tConditionalExpression(node, state) {\n\t\t\tconst chunks = [];\n\n\t\t\tif (\n\t\t\t\tEXPRESSIONS_PRECEDENCE[node.test.type] >\n\t\t\t\tEXPRESSIONS_PRECEDENCE.ConditionalExpression\n\t\t\t) {\n\t\t\t\tchunks.push(...handle(node.test, state));\n\t\t\t} else {\n\t\t\t\tchunks.push(\n\t\t\t\t\tc('('),\n\t\t\t\t\t...handle(node.test, state),\n\t\t\t\t\tc(')')\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tconst child_state = { ...state, indent: state.indent + '\\t' };\n\n\t\t\tconst consequent = handle(node.consequent, child_state);\n\t\t\tconst alternate = handle(node.alternate, child_state);\n\n\t\t\tconst multiple_lines = (\n\t\t\t\thas_newline(consequent) || has_newline(alternate) ||\n\t\t\t\tget_length(chunks) + get_length(consequent) + get_length(alternate) > 50\n\t\t\t);\n\n\t\t\tif (multiple_lines) {\n\t\t\t\tchunks.push(\n\t\t\t\t\tc(`\\n${state.indent}? `),\n\t\t\t\t\t...consequent,\n\t\t\t\t\tc(`\\n${state.indent}: `),\n\t\t\t\t\t...alternate\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tchunks.push(\n\t\t\t\t\tc(` ? `),\n\t\t\t\t\t...consequent,\n\t\t\t\t\tc(` : `),\n\t\t\t\t\t...alternate\n\t\t\t\t);\n\t\t\t}\n\n\t\t\treturn chunks;\n\t\t},\n\n\t\tNewExpression(node, state) {\n\t\t\tconst chunks = [c('new ')];\n\n\t\t\tif (\n\t\t\t\tEXPRESSIONS_PRECEDENCE[node.callee.type] <\n\t\t\t\tEXPRESSIONS_PRECEDENCE.CallExpression || has_call_expression(node.callee)\n\t\t\t) {\n\t\t\t\tchunks.push(\n\t\t\t\t\tc('('),\n\t\t\t\t\t...handle(node.callee, state),\n\t\t\t\t\tc(')')\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tchunks.push(...handle(node.callee, state));\n\t\t\t}\n\n\t\t\t// TODO this is copied from CallExpression \u2014 DRY it out\n\t\t\tconst args = node.arguments.map(arg => handle(arg, {\n\t\t\t\t...state,\n\t\t\t\tindent: state.indent + '\\t'\n\t\t\t}));\n\n\t\t\tconst separator = args.some(has_newline) // TODO or length exceeds 80\n\t\t\t\t? c(',\\n' + state.indent)\n\t\t\t\t: c(', ');\n\n\t\t\tchunks.push(\n\t\t\t\tc('('),\n\t\t\t\t...join(args, separator) ,\n\t\t\t\tc(')')\n\t\t\t);\n\n\t\t\treturn chunks;\n\t\t},\n\n\t\tChainExpression(node, state) {\n\t\t\treturn handle(node.expression, state);\n\t\t},\n\n\t\tCallExpression(node, state) {\n\t\t\tconst chunks = [];\n\n\t\t\tif (\n\t\t\t\tEXPRESSIONS_PRECEDENCE[node.callee.type] <\n\t\t\t\tEXPRESSIONS_PRECEDENCE.CallExpression\n\t\t\t) {\n\t\t\t\tchunks.push(\n\t\t\t\t\tc('('),\n\t\t\t\t\t...handle(node.callee, state),\n\t\t\t\t\tc(')')\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tchunks.push(...handle(node.callee, state));\n\t\t\t}\n\n\t\t\tif ((node ).optional) {\n\t\t\t\tchunks.push(c('?.'));\n\t\t\t}\n\n\t\t\tconst args = node.arguments.map(arg => handle(arg, state));\n\n\t\t\tconst multiple_lines = args.slice(0, -1).some(has_newline); // TODO or length exceeds 80\n\n\t\t\tif (multiple_lines) {\n\t\t\t\t// need to handle args again. TODO find alternative approach?\n\t\t\t\tconst args = node.arguments.map(arg => handle(arg, {\n\t\t\t\t\t...state,\n\t\t\t\t\tindent: `${state.indent}\\t`\n\t\t\t\t}));\n\n\t\t\t\tchunks.push(\n\t\t\t\t\tc(`(\\n${state.indent}\\t`),\n\t\t\t\t\t...join(args, c(`,\\n${state.indent}\\t`)),\n\t\t\t\t\tc(`\\n${state.indent})`)\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tchunks.push(\n\t\t\t\t\tc('('),\n\t\t\t\t\t...join(args, c(', ')),\n\t\t\t\t\tc(')')\n\t\t\t\t);\n\t\t\t}\n\n\t\t\treturn chunks;\n\t\t},\n\n\t\tMemberExpression(node, state) {\n\t\t\tconst chunks = [];\n\n\t\t\tif (EXPRESSIONS_PRECEDENCE[node.object.type] < EXPRESSIONS_PRECEDENCE.MemberExpression) {\n\t\t\t\tchunks.push(\n\t\t\t\t\tc('('),\n\t\t\t\t\t...handle(node.object, state),\n\t\t\t\t\tc(')')\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tchunks.push(...handle(node.object, state));\n\t\t\t}\n\n\t\t\tif (node.computed) {\n\t\t\t\tif (node.optional) {\n\t\t\t\t\tchunks.push(c('?.'));\n\t\t\t\t}\n\t\t\t\tchunks.push(\n\t\t\t\t\tc('['),\n\t\t\t\t\t...handle(node.property, state),\n\t\t\t\t\tc(']')\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tchunks.push(\n\t\t\t\t\tc(node.optional ? '?.' : '.'),\n\t\t\t\t\t...handle(node.property, state)\n\t\t\t\t);\n\t\t\t}\n\n\t\t\treturn chunks;\n\t\t},\n\n\t\tMetaProperty(node, state) {\n\t\t\treturn [...handle(node.meta, state), c('.'), ...handle(node.property, state)];\n\t\t},\n\n\t\tIdentifier(node, state) {\n\t\t\tlet name = node.name;\n\n\t\t\tif (name[0] === '@') {\n\t\t\t\tname = state.getName(name.slice(1));\n\t\t\t} else if (node.name[0] === '#') {\n\t\t\t\tconst owner = state.scope.find_owner(node.name);\n\n\t\t\t\tif (!owner) {\n\t\t\t\t\tthrow new Error(`Could not find owner for node`);\n\t\t\t\t}\n\n\t\t\t\tif (!state.deconflicted.has(owner)) {\n\t\t\t\t\tstate.deconflicted.set(owner, new Map());\n\t\t\t\t}\n\n\t\t\t\tconst deconflict_map = state.deconflicted.get(owner);\n\n\t\t\t\tif (!deconflict_map.has(node.name)) {\n\t\t\t\t\tdeconflict_map.set(node.name, deconflict(node.name.slice(1), owner.references));\n\t\t\t\t}\n\n\t\t\t\tname = deconflict_map.get(node.name);\n\t\t\t}\n\n\t\t\treturn [c(name, node)];\n\t\t},\n\n\t\tLiteral(node, state) {\n\t\t\tif (typeof node.value === 'string') {\n\t\t\t\treturn [\n\t\t\t\t\t// TODO do we need to handle weird unicode characters somehow?\n\t\t\t\t\t// str.replace(/\\\\u(\\d{4})/g, (m, n) => String.fromCharCode(+n))\n\t\t\t\t\tc(JSON.stringify(node.value).replace(re, (_m, _i, at, hash, name) => {\n\t\t\t\t\t\tif (at)\treturn '@' + name;\n\t\t\t\t\t\tif (hash) return '#' + name;\n\t\t\t\t\t\tthrow new Error(`this shouldn't happen`);\n\t\t\t\t\t}), node)\n\t\t\t\t];\n\t\t\t}\n\n\t\t\tconst { regex } = node ; // TODO is this right?\n\t\t\tif (regex) {\n\t\t\t\treturn [c(`/${regex.pattern}/${regex.flags}`, node)];\n\t\t\t}\n\n\t\t\treturn [c(String(node.value), node)];\n\t\t}\n\t};\n\n\thandlers.ForOfStatement = handlers.ForInStatement;\n\thandlers.FunctionExpression = handlers.FunctionDeclaration;\n\thandlers.ClassExpression = handlers.ClassDeclaration;\n\thandlers.ClassBody = handlers.BlockStatement;\n\thandlers.SpreadElement = handlers.RestElement;\n\thandlers.ArrayPattern = handlers.ArrayExpression;\n\thandlers.LogicalExpression = handlers.BinaryExpression;\n\thandlers.AssignmentPattern = handlers.AssignmentExpression;\n\n\tlet btoa = () => {\n\t\tthrow new Error('Unsupported environment: `window.btoa` or `Buffer` should be supported.');\n\t};\n\tif (typeof window !== 'undefined' && typeof window.btoa === 'function') {\n\t\tbtoa = (str) => window.btoa(unescape(encodeURIComponent(str)));\n\t} else if (typeof Buffer === 'function') {\n\t\tbtoa = (str) => Buffer.from(str, 'utf-8').toString('base64');\n\t}\n\n\n\n\n\n\n\n\n\tfunction print(node, opts = {}) {\n\t\tif (Array.isArray(node)) {\n\t\t\treturn print({\n\t\t\t\ttype: 'Program',\n\t\t\t\tbody: node\n\t\t\t} , opts);\n\t\t}\n\n\t\tconst {\n\t\t\tgetName = (x) => {\n\t\t\t\tthrow new Error(`Unhandled sigil @${x}`);\n\t\t\t}\n\t\t} = opts;\n\n\t\tlet { map: scope_map, scope } = analyze(node);\n\t\tconst deconflicted = new WeakMap();\n\n\t\tconst chunks = handle(node, {\n\t\t\tindent: '',\n\t\t\tgetName,\n\t\t\tscope,\n\t\t\tscope_map,\n\t\t\tdeconflicted,\n\t\t\tcomments: []\n\t\t});\n\n\t\t\n\n\t\tlet code = '';\n\t\tlet mappings = [];\n\t\tlet current_line = [];\n\t\tlet current_column = 0;\n\n\t\tfor (let i = 0; i < chunks.length; i += 1) {\n\t\t\tconst chunk = chunks[i];\n\n\t\t\tcode += chunk.content;\n\n\t\t\tif (chunk.loc) {\n\t\t\t\tcurrent_line.push([\n\t\t\t\t\tcurrent_column,\n\t\t\t\t\t0, // source index is always zero\n\t\t\t\t\tchunk.loc.start.line - 1,\n\t\t\t\t\tchunk.loc.start.column,\n\t\t\t\t]);\n\t\t\t}\n\n\t\t\tfor (let i = 0; i < chunk.content.length; i += 1) {\n\t\t\t\tif (chunk.content[i] === '\\n') {\n\t\t\t\t\tmappings.push(current_line);\n\t\t\t\t\tcurrent_line = [];\n\t\t\t\t\tcurrent_column = 0;\n\t\t\t\t} else {\n\t\t\t\t\tcurrent_column += 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (chunk.loc) {\n\t\t\t\tcurrent_line.push([\n\t\t\t\t\tcurrent_column,\n\t\t\t\t\t0, // source index is always zero\n\t\t\t\t\tchunk.loc.end.line - 1,\n\t\t\t\t\tchunk.loc.end.column,\n\t\t\t\t]);\n\t\t\t}\n\t\t}\n\n\t\tmappings.push(current_line);\n\n\t\tconst map = {\n\t\t\tversion: 3,\n\t\t\tnames: [] ,\n\t\t\tsources: [opts.sourceMapSource || null],\n\t\t\tsourcesContent: [opts.sourceMapContent || null],\n\t\t\tmappings: encode(mappings)\n\t\t};\n\n\t\tObject.defineProperties(map, {\n\t\t\ttoString: {\n\t\t\t\tenumerable: false,\n\t\t\t\tvalue: function toString() {\n\t\t\t\t\treturn JSON.stringify(this);\n\t\t\t\t}\n\t\t\t},\n\t\t\ttoUrl: {\n\t\t\t\tenumerable: false,\n\t\t\t\tvalue: function toUrl() {\n\t\t\t\t\treturn 'data:application/json;charset=utf-8;base64,' + btoa(this.toString());\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn {\n\t\t\tcode,\n\t\t\tmap\n\t\t};\n\t}\n\n\tconst sigils = {\n\t\t'@': 'AT',\n\t\t'#': 'HASH'\n\t};\n\n\tconst join$1 = (strings) => {\n\t\tlet str = strings[0];\n\t\tfor (let i = 1; i < strings.length; i += 1) {\n\t\t\tstr += `_${id}_${i - 1}_${strings[i]}`;\n\t\t}\n\t\treturn str.replace(/([@#])(\\w+)/g, (_m, sigil, name) => `_${id}_${sigils[sigil]}_${name}`);\n\t};\n\n\tconst flatten_body = (array, target) => {\n\t\tfor (let i = 0; i < array.length; i += 1) {\n\t\t\tconst statement = array[i];\n\t\t\tif (Array.isArray(statement)) {\n\t\t\t\tflatten_body(statement, target);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (statement.type === 'ExpressionStatement') {\n\t\t\t\tif (statement.expression === EMPTY) continue;\n\n\t\t\t\tif (Array.isArray(statement.expression)) {\n\t\t\t\t\t// TODO this is hacktacular\n\t\t\t\t\tlet node = statement.expression[0];\n\t\t\t\t\twhile (Array.isArray(node)) node = node[0];\n\t\t\t\t\tif (node) node.leadingComments = statement.leadingComments;\n\n\t\t\t\t\tflatten_body(statement.expression, target);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (/(Expression|Literal)$/.test(statement.expression.type)) {\n\t\t\t\t\ttarget.push(statement);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (statement.leadingComments) statement.expression.leadingComments = statement.leadingComments;\n\t\t\t\tif (statement.trailingComments) statement.expression.trailingComments = statement.trailingComments;\n\n\t\t\t\ttarget.push(statement.expression);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\ttarget.push(statement);\n\t\t}\n\n\t\treturn target;\n\t};\n\n\tconst flatten_properties = (array, target) => {\n\t\tfor (let i = 0; i < array.length; i += 1) {\n\t\t\tconst property = array[i];\n\n\t\t\tif (property.value === EMPTY) continue;\n\n\t\t\tif (property.key === property.value && Array.isArray(property.key)) {\n\t\t\t\tflatten_properties(property.key, target);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\ttarget.push(property);\n\t\t}\n\n\t\treturn target;\n\t};\n\n\tconst flatten = (nodes, target) => {\n\t\tfor (let i = 0; i < nodes.length; i += 1) {\n\t\t\tconst node = nodes[i];\n\n\t\t\tif (node === EMPTY) continue;\n\n\t\t\tif (Array.isArray(node)) {\n\t\t\t\tflatten(node, target);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\ttarget.push(node);\n\t\t}\n\n\t\treturn target;\n\t};\n\n\tconst EMPTY = { type: 'Empty' };\n\n\tconst acorn_opts = (comments, raw) => {\n\t\tconst { onComment } = get_comment_handlers(comments, raw);\n\t\treturn {\n\t\t\tecmaVersion: 2020,\n\t\t\tsourceType: 'module',\n\t\t\tallowAwaitOutsideFunction: true,\n\t\t\tallowImportExportEverywhere: true,\n\t\t\tallowReturnOutsideFunction: true,\n\t\t\tonComment\n\t\t} ;\n\t};\n\n\tconst inject = (raw, node, values, comments) => {\n\t\tcomments.forEach(comment => {\n\t\t\tcomment.value = comment.value.replace(re, (m, i) => +i in values ? values[+i] : m);\n\t\t});\n\n\t\tconst { enter, leave } = get_comment_handlers(comments, raw);\n\n\t\twalk(node, {\n\t\t\tenter,\n\n\t\t\tleave(node, parent, key, index) {\n\t\t\t\tif (node.type === 'Identifier') {\n\t\t\t\t\tre.lastIndex = 0;\n\t\t\t\t\tconst match = re.exec(node.name);\n\n\t\t\t\t\tif (match) {\n\t\t\t\t\t\tif (match[1]) {\n\t\t\t\t\t\t\tif (+match[1] in values) {\n\t\t\t\t\t\t\t\tlet value = values[+match[1]];\n\n\t\t\t\t\t\t\t\tif (typeof value === 'string') {\n\t\t\t\t\t\t\t\t\tvalue = { type: 'Identifier', name: value, leadingComments: node.leadingComments, trailingComments: node.trailingComments };\n\t\t\t\t\t\t\t\t} else if (typeof value === 'number') {\n\t\t\t\t\t\t\t\t\tvalue = { type: 'Literal', value, leadingComments: node.leadingComments, trailingComments: node.trailingComments };\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tthis.replace(value || EMPTY);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tnode.name = `${match[2] ? `@` : `#`}${match[4]}`;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (node.type === 'Literal') {\n\t\t\t\t\tif (typeof node.value === 'string') {\n\t\t\t\t\t\tre.lastIndex = 0;\n\t\t\t\t\t\tnode.value = node.value.replace(re, (m, i) => +i in values ? values[+i] : m);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (node.type === 'TemplateElement') {\n\t\t\t\t\tre.lastIndex = 0;\n\t\t\t\t\tnode.value.raw = (node.value.raw ).replace(re, (m, i) => +i in values ? values[+i] : m);\n\t\t\t\t}\n\n\t\t\t\tif (node.type === 'Program' || node.type === 'BlockStatement') {\n\t\t\t\t\tnode.body = flatten_body(node.body, []);\n\t\t\t\t}\n\n\t\t\t\tif (node.type === 'ObjectExpression' || node.type === 'ObjectPattern') {\n\t\t\t\t\tnode.properties = flatten_properties(node.properties, []);\n\t\t\t\t}\n\n\t\t\t\tif (node.type === 'ArrayExpression' || node.type === 'ArrayPattern') {\n\t\t\t\t\tnode.elements = flatten(node.elements, []);\n\t\t\t\t}\n\n\t\t\t\tif (node.type === 'FunctionExpression' || node.type === 'FunctionDeclaration' || node.type === 'ArrowFunctionExpression') {\n\t\t\t\t\tnode.params = flatten(node.params, []);\n\t\t\t\t}\n\n\t\t\t\tif (node.type === 'CallExpression' || node.type === 'NewExpression') {\n\t\t\t\t\tnode.arguments = flatten(node.arguments, []);\n\t\t\t\t}\n\n\t\t\t\tif (node.type === 'ImportDeclaration' || node.type === 'ExportNamedDeclaration') {\n\t\t\t\t\tnode.specifiers = flatten(node.specifiers, []);\n\t\t\t\t}\n\n\t\t\t\tif (node.type === 'ForStatement') {\n\t\t\t\t\tnode.init = node.init === EMPTY ? null : node.init;\n\t\t\t\t\tnode.test = node.test === EMPTY ? null : node.test;\n\t\t\t\t\tnode.update = node.update === EMPTY ? null : node.update;\n\t\t\t\t}\n\n\t\t\t\tleave(node);\n\t\t\t}\n\t\t});\n\t};\n\n\tfunction b(strings, ...values) {\n\t\tconst str = join$1(strings);\n\t\tconst comments = [];\n\n\t\ttry {\n\t\t\tconst ast = parse(str,  acorn_opts(comments, str));\n\n\t\t\tinject(str, ast, values, comments);\n\n\t\t\treturn ast.body;\n\t\t} catch (err) {\n\t\t\thandle_error(str, err);\n\t\t}\n\t}\n\n\tfunction x(strings, ...values) {\n\t\tconst str = join$1(strings);\n\t\tconst comments = [];\n\n\t\ttry {\n\t\t\tconst expression = parseExpressionAt(str, 0, acorn_opts(comments, str)) ;\n\t\t\tconst match = /\\S+/.exec(str.slice((expression ).end));\n\t\t\tif (match) {\n\t\t\t\tthrow new Error(`Unexpected token '${match[0]}'`);\n\t\t\t}\n\n\t\t\tinject(str, expression, values, comments);\n\n\t\t\treturn expression;\n\t\t} catch (err) {\n\t\t\thandle_error(str, err);\n\t\t}\n\t}\n\n\tfunction p(strings, ...values) {\n\t\tconst str = `{${join$1(strings)}}`;\n\t\tconst comments = [];\n\n\t\ttry {\n\t\t\tconst expression = parseExpressionAt(str, 0, acorn_opts(comments, str)) ;\n\n\t\t\tinject(str, expression, values, comments);\n\n\t\t\treturn expression.properties[0];\n\t\t} catch (err) {\n\t\t\thandle_error(str, err);\n\t\t}\n\t}\n\n\tfunction handle_error(str, err) {\n\t\t// TODO location/code frame\n\n\t\tre.lastIndex = 0;\n\n\t\tstr = str.replace(re, (m, i, at, hash, name) => {\n\t\t\tif (at) return `@${name}`;\n\t\t\tif (hash) return `#${name}`;\n\n\t\t\treturn '${...}';\n\t\t});\n\n\t\tconsole.log(`failed to parse:\\n${str}`);\n\t\tthrow err;\n\t}\n\n\tconst parse$1 = (source, opts) => {\n\t\tconst comments = [];\n\t\tconst { onComment, enter, leave } = get_comment_handlers(comments, source);\n\t\tconst ast = parse(source, { onComment, ...opts });\n\t\twalk(ast , { enter, leave });\n\t\treturn ast;\n\t};\n\n\tconst parseExpressionAt$1 = (source, index, opts) => {\n\t\tconst comments = [];\n\t\tconst { onComment, enter, leave } = get_comment_handlers(comments, source);\n\t\tconst ast = parseExpressionAt(source, index, { onComment, ...opts });\n\t\twalk(ast , { enter, leave });\n\t\treturn ast;\n\t};\n\n\tconst parse$2 = (source) => parse$1(source, {\n\t    sourceType: 'module',\n\t    ecmaVersion: 11,\n\t    locations: true\n\t});\n\tconst parse_expression_at = (source, index) => parseExpressionAt$1(source, index, {\n\t    ecmaVersion: 11,\n\t    locations: true\n\t});\n\n\tconst whitespace = /[ \\t\\r\\n]/;\n\tconst dimensions = /^(?:offset|client)(?:Width|Height)$/;\n\n\tfunction read_expression(parser) {\n\t    try {\n\t        const node = parse_expression_at(parser.template, parser.index);\n\t        let num_parens = 0;\n\t        for (let i = parser.index; i < node.start; i += 1) {\n\t            if (parser.template[i] === '(')\n\t                num_parens += 1;\n\t        }\n\t        let index = node.end;\n\t        while (num_parens > 0) {\n\t            const char = parser.template[index];\n\t            if (char === ')') {\n\t                num_parens -= 1;\n\t            }\n\t            else if (!whitespace.test(char)) {\n\t                parser.error({\n\t                    code: 'unexpected-token',\n\t                    message: 'Expected )'\n\t                }, index);\n\t            }\n\t            index += 1;\n\t        }\n\t        parser.index = index;\n\t        return node;\n\t    }\n\t    catch (err) {\n\t        parser.acorn_error(err);\n\t    }\n\t}\n\n\tconst script_closing_tag = '</script>';\n\tfunction get_context(parser, attributes, start) {\n\t    const context = attributes.find(attribute => attribute.name === 'context');\n\t    if (!context)\n\t        return 'default';\n\t    if (context.value.length !== 1 || context.value[0].type !== 'Text') {\n\t        parser.error({\n\t            code: 'invalid-script',\n\t            message: `context attribute must be static`\n\t        }, start);\n\t    }\n\t    const value = context.value[0].data;\n\t    if (value !== 'module') {\n\t        parser.error({\n\t            code: `invalid-script`,\n\t            message: `If the context attribute is supplied, its value must be \"module\"`\n\t        }, context.start);\n\t    }\n\t    return value;\n\t}\n\tfunction read_script(parser, start, attributes) {\n\t    const script_start = parser.index;\n\t    const script_end = parser.template.indexOf(script_closing_tag, script_start);\n\t    if (script_end === -1)\n\t        parser.error({\n\t            code: `unclosed-script`,\n\t            message: `<script> must have a closing tag`\n\t        });\n\t    const source = parser.template.slice(0, script_start).replace(/[^\\n]/g, ' ') +\n\t        parser.template.slice(script_start, script_end);\n\t    parser.index = script_end + script_closing_tag.length;\n\t    let ast;\n\t    try {\n\t        ast = parse$2(source);\n\t    }\n\t    catch (err) {\n\t        parser.acorn_error(err);\n\t    }\n\t    // TODO is this necessary?\n\t    ast.start = script_start;\n\t    return {\n\t        type: 'Script',\n\t        start,\n\t        end: parser.index,\n\t        context: get_context(parser, attributes, start),\n\t        content: ast,\n\t    };\n\t}\n\n\tvar MAX_LINE_LENGTH = 100;\n\tvar OFFSET_CORRECTION = 60;\n\tvar TAB_REPLACEMENT = '    ';\n\n\tfunction sourceFragment(error, extraLines) {\n\t    function processLines(start, end) {\n\t        return lines.slice(start, end).map(function(line, idx) {\n\t            var num = String(start + idx + 1);\n\n\t            while (num.length < maxNumLength) {\n\t                num = ' ' + num;\n\t            }\n\n\t            return num + ' |' + line;\n\t        }).join('\\n');\n\t    }\n\n\t    var lines = error.source.split(/\\n|\\r\\n?|\\f/);\n\t    var line = error.line;\n\t    var column = error.column;\n\t    var startLine = Math.max(1, line - extraLines) - 1;\n\t    var endLine = Math.min(line + extraLines, lines.length + 1);\n\t    var maxNumLength = Math.max(4, String(endLine).length) + 1;\n\t    var cutLeft = 0;\n\n\t    // correct column according to replaced tab before column\n\t    column += (TAB_REPLACEMENT.length - 1) * (lines[line - 1].substr(0, column - 1).match(/\\t/g) || []).length;\n\n\t    if (column > MAX_LINE_LENGTH) {\n\t        cutLeft = column - OFFSET_CORRECTION + 3;\n\t        column = OFFSET_CORRECTION - 2;\n\t    }\n\n\t    for (var i = startLine; i <= endLine; i++) {\n\t        if (i >= 0 && i < lines.length) {\n\t            lines[i] = lines[i].replace(/\\t/g, TAB_REPLACEMENT);\n\t            lines[i] =\n\t                (cutLeft > 0 && lines[i].length > cutLeft ? '\\u2026' : '') +\n\t                lines[i].substr(cutLeft, MAX_LINE_LENGTH - 2) +\n\t                (lines[i].length > cutLeft + MAX_LINE_LENGTH - 1 ? '\\u2026' : '');\n\t        }\n\t    }\n\n\t    return [\n\t        processLines(startLine, line),\n\t        new Array(column + maxNumLength + 2).join('-') + '^',\n\t        processLines(line, endLine)\n\t    ].join('\\n');\n\t}\n\n\tvar CssSyntaxError = function(message, source, offset, line, column) {\n\t    // some VMs prevent setting line/column otherwise (iOS Safari 10 even throw an exception)\n\t    var error = Object.create(SyntaxError.prototype);\n\n\t    error.name = 'CssSyntaxError';\n\t    error.message = message;\n\t    error.stack = (new Error().stack || '').replace(/^.+\\n/, error.name + ': ' + error.message + '\\n');\n\t    error.source = source;\n\t    error.offset = offset;\n\t    error.line = line;\n\t    error.column = column;\n\n\t    error.sourceFragment = function(extraLines) {\n\t        return sourceFragment(error, isNaN(extraLines) ? 0 : extraLines);\n\t    };\n\t    Object.defineProperty(error, 'formattedMessage', {\n\t        get: function() {\n\t            return (\n\t                'Parse error: ' + error.message + '\\n' +\n\t                sourceFragment(error, 2)\n\t            );\n\t        }\n\t    });\n\n\t    // for backward capability\n\t    error.parseError = {\n\t        offset: offset,\n\t        line: line,\n\t        column: column\n\t    };\n\n\t    return error;\n\t};\n\n\tvar error = CssSyntaxError;\n\n\t// token types (note: value shouldn't intersect with used char codes)\n\tvar WHITESPACE = 1;\n\tvar IDENTIFIER = 2;\n\tvar NUMBER = 3;\n\tvar STRING = 4;\n\tvar COMMENT = 5;\n\tvar PUNCTUATOR = 6;\n\tvar CDO = 7;\n\tvar CDC = 8;\n\tvar ATRULE = 14;\n\tvar FUNCTION = 15;\n\tvar URL = 16;\n\tvar RAW = 17;\n\n\tvar TAB = 9;\n\tvar N = 10;\n\tvar F = 12;\n\tvar R = 13;\n\tvar SPACE = 32;\n\n\tvar TYPE = {\n\t    WhiteSpace:   WHITESPACE,\n\t    Identifier:   IDENTIFIER,\n\t    Number:           NUMBER,\n\t    String:           STRING,\n\t    Comment:         COMMENT,\n\t    Punctuator:   PUNCTUATOR,\n\t    CDO:                 CDO,\n\t    CDC:                 CDC,\n\t    Atrule:           ATRULE,\n\t    Function:       FUNCTION,\n\t    Url:                 URL,\n\t    Raw:                 RAW,\n\n\t    ExclamationMark:      33,  // !\n\t    QuotationMark:        34,  // \"\n\t    NumberSign:           35,  // #\n\t    DollarSign:           36,  // $\n\t    PercentSign:          37,  // %\n\t    Ampersand:            38,  // &\n\t    Apostrophe:           39,  // '\n\t    LeftParenthesis:      40,  // (\n\t    RightParenthesis:     41,  // )\n\t    Asterisk:             42,  // *\n\t    PlusSign:             43,  // +\n\t    Comma:                44,  // ,\n\t    HyphenMinus:          45,  // -\n\t    FullStop:             46,  // .\n\t    Solidus:              47,  // /\n\t    Colon:                58,  // :\n\t    Semicolon:            59,  // ;\n\t    LessThanSign:         60,  // <\n\t    EqualsSign:           61,  // =\n\t    GreaterThanSign:      62,  // >\n\t    QuestionMark:         63,  // ?\n\t    CommercialAt:         64,  // @\n\t    LeftSquareBracket:    91,  // [\n\t    Backslash:            92,  // \\\n\t    RightSquareBracket:   93,  // ]\n\t    CircumflexAccent:     94,  // ^\n\t    LowLine:              95,  // _\n\t    GraveAccent:          96,  // `\n\t    LeftCurlyBracket:    123,  // {\n\t    VerticalLine:        124,  // |\n\t    RightCurlyBracket:   125,  // }\n\t    Tilde:               126   // ~\n\t};\n\n\tvar NAME = Object.keys(TYPE).reduce(function(result, key) {\n\t    result[TYPE[key]] = key;\n\t    return result;\n\t}, {});\n\n\t// https://drafts.csswg.org/css-syntax/#tokenizer-definitions\n\t// > non-ASCII code point\n\t// >   A code point with a value equal to or greater than U+0080 <control>\n\t// > name-start code point\n\t// >   A letter, a non-ASCII code point, or U+005F LOW LINE (_).\n\t// > name code point\n\t// >   A name-start code point, a digit, or U+002D HYPHEN-MINUS (-)\n\t// That means only ASCII code points has a special meaning and we a maps for 0..127 codes only\n\tvar SafeUint32Array = typeof Uint32Array !== 'undefined' ? Uint32Array : Array; // fallback on Array when TypedArray is not supported\n\tvar SYMBOL_TYPE = new SafeUint32Array(0x80);\n\tvar PUNCTUATION = new SafeUint32Array(0x80);\n\tvar STOP_URL_RAW = new SafeUint32Array(0x80);\n\n\tfor (var i = 0; i < SYMBOL_TYPE.length; i++) {\n\t    SYMBOL_TYPE[i] = IDENTIFIER;\n\t}\n\n\t// fill categories\n\t[\n\t    TYPE.ExclamationMark,    // !\n\t    TYPE.QuotationMark,      // \"\n\t    TYPE.NumberSign,         // #\n\t    TYPE.DollarSign,         // $\n\t    TYPE.PercentSign,        // %\n\t    TYPE.Ampersand,          // &\n\t    TYPE.Apostrophe,         // '\n\t    TYPE.LeftParenthesis,    // (\n\t    TYPE.RightParenthesis,   // )\n\t    TYPE.Asterisk,           // *\n\t    TYPE.PlusSign,           // +\n\t    TYPE.Comma,              // ,\n\t    TYPE.HyphenMinus,        // -\n\t    TYPE.FullStop,           // .\n\t    TYPE.Solidus,            // /\n\t    TYPE.Colon,              // :\n\t    TYPE.Semicolon,          // ;\n\t    TYPE.LessThanSign,       // <\n\t    TYPE.EqualsSign,         // =\n\t    TYPE.GreaterThanSign,    // >\n\t    TYPE.QuestionMark,       // ?\n\t    TYPE.CommercialAt,       // @\n\t    TYPE.LeftSquareBracket,  // [\n\t    // TYPE.Backslash,          // \\\n\t    TYPE.RightSquareBracket, // ]\n\t    TYPE.CircumflexAccent,   // ^\n\t    // TYPE.LowLine,            // _\n\t    TYPE.GraveAccent,        // `\n\t    TYPE.LeftCurlyBracket,   // {\n\t    TYPE.VerticalLine,       // |\n\t    TYPE.RightCurlyBracket,  // }\n\t    TYPE.Tilde               // ~\n\t].forEach(function(key) {\n\t    SYMBOL_TYPE[Number(key)] = PUNCTUATOR;\n\t    PUNCTUATION[Number(key)] = PUNCTUATOR;\n\t});\n\n\tfor (var i = 48; i <= 57; i++) {\n\t    SYMBOL_TYPE[i] = NUMBER;\n\t}\n\n\tSYMBOL_TYPE[SPACE] = WHITESPACE;\n\tSYMBOL_TYPE[TAB] = WHITESPACE;\n\tSYMBOL_TYPE[N] = WHITESPACE;\n\tSYMBOL_TYPE[R] = WHITESPACE;\n\tSYMBOL_TYPE[F] = WHITESPACE;\n\n\tSYMBOL_TYPE[TYPE.Apostrophe] = STRING;\n\tSYMBOL_TYPE[TYPE.QuotationMark] = STRING;\n\n\tSTOP_URL_RAW[SPACE] = 1;\n\tSTOP_URL_RAW[TAB] = 1;\n\tSTOP_URL_RAW[N] = 1;\n\tSTOP_URL_RAW[R] = 1;\n\tSTOP_URL_RAW[F] = 1;\n\tSTOP_URL_RAW[TYPE.Apostrophe] = 1;\n\tSTOP_URL_RAW[TYPE.QuotationMark] = 1;\n\tSTOP_URL_RAW[TYPE.LeftParenthesis] = 1;\n\tSTOP_URL_RAW[TYPE.RightParenthesis] = 1;\n\n\t// whitespace is punctuation ...\n\tPUNCTUATION[SPACE] = PUNCTUATOR;\n\tPUNCTUATION[TAB] = PUNCTUATOR;\n\tPUNCTUATION[N] = PUNCTUATOR;\n\tPUNCTUATION[R] = PUNCTUATOR;\n\tPUNCTUATION[F] = PUNCTUATOR;\n\t// ... hyper minus is not\n\tPUNCTUATION[TYPE.HyphenMinus] = 0;\n\n\tvar _const = {\n\t    TYPE: TYPE,\n\t    NAME: NAME,\n\n\t    SYMBOL_TYPE: SYMBOL_TYPE,\n\t    PUNCTUATION: PUNCTUATION,\n\t    STOP_URL_RAW: STOP_URL_RAW\n\t};\n\n\tvar PUNCTUATION$1 = _const.PUNCTUATION;\n\tvar STOP_URL_RAW$1 = _const.STOP_URL_RAW;\n\tvar TYPE$1 = _const.TYPE;\n\tvar FULLSTOP = TYPE$1.FullStop;\n\tvar PLUSSIGN = TYPE$1.PlusSign;\n\tvar HYPHENMINUS = TYPE$1.HyphenMinus;\n\tvar PUNCTUATOR$1 = TYPE$1.Punctuator;\n\tvar TAB$1 = 9;\n\tvar N$1 = 10;\n\tvar F$1 = 12;\n\tvar R$1 = 13;\n\tvar SPACE$1 = 32;\n\tvar BACK_SLASH = 92;\n\tvar E = 101; // 'e'.charCodeAt(0)\n\n\tfunction firstCharOffset(source) {\n\t    // detect BOM (https://en.wikipedia.org/wiki/Byte_order_mark)\n\t    if (source.charCodeAt(0) === 0xFEFF ||  // UTF-16BE\n\t        source.charCodeAt(0) === 0xFFFE) {  // UTF-16LE\n\t        return 1;\n\t    }\n\n\t    return 0;\n\t}\n\n\tfunction isHex(code) {\n\t    return (code >= 48 && code <= 57) || // 0 .. 9\n\t           (code >= 65 && code <= 70) || // A .. F\n\t           (code >= 97 && code <= 102);  // a .. f\n\t}\n\n\tfunction isNumber(code) {\n\t    return code >= 48 && code <= 57;\n\t}\n\n\tfunction isNewline(source, offset, code) {\n\t    if (code === N$1 || code === F$1 || code === R$1) {\n\t        if (code === R$1 && offset + 1 < source.length && source.charCodeAt(offset + 1) === N$1) {\n\t            return 2;\n\t        }\n\n\t        return 1;\n\t    }\n\n\t    return 0;\n\t}\n\n\tfunction cmpChar(testStr, offset, referenceCode) {\n\t    var code = testStr.charCodeAt(offset);\n\n\t    // code.toLowerCase()\n\t    if (code >= 65 && code <= 90) {\n\t        code = code | 32;\n\t    }\n\n\t    return code === referenceCode;\n\t}\n\n\tfunction cmpStr(testStr, start, end, referenceStr) {\n\t    if (end - start !== referenceStr.length) {\n\t        return false;\n\t    }\n\n\t    if (start < 0 || end > testStr.length) {\n\t        return false;\n\t    }\n\n\t    for (var i = start; i < end; i++) {\n\t        var testCode = testStr.charCodeAt(i);\n\t        var refCode = referenceStr.charCodeAt(i - start);\n\n\t        // testStr[i].toLowerCase()\n\t        if (testCode >= 65 && testCode <= 90) {\n\t            testCode = testCode | 32;\n\t        }\n\n\t        if (testCode !== refCode) {\n\t            return false;\n\t        }\n\t    }\n\n\t    return true;\n\t}\n\n\tfunction endsWith(testStr, referenceStr) {\n\t    return cmpStr(testStr, testStr.length - referenceStr.length, testStr.length, referenceStr);\n\t}\n\n\tfunction findLastNonSpaceLocation(scanner) {\n\t    for (var i = scanner.source.length - 1; i >= 0; i--) {\n\t        var code = scanner.source.charCodeAt(i);\n\n\t        if (code !== SPACE$1 && code !== TAB$1 && code !== R$1 && code !== N$1 && code !== F$1) {\n\t            break;\n\t        }\n\t    }\n\n\t    return scanner.getLocation(i + 1);\n\t}\n\n\tfunction findWhiteSpaceEnd(source, offset) {\n\t    for (; offset < source.length; offset++) {\n\t        var code = source.charCodeAt(offset);\n\n\t        if (code !== SPACE$1 && code !== TAB$1 && code !== R$1 && code !== N$1 && code !== F$1) {\n\t            break;\n\t        }\n\t    }\n\n\t    return offset;\n\t}\n\n\tfunction findCommentEnd(source, offset) {\n\t    var commentEnd = source.indexOf('*/', offset);\n\n\t    if (commentEnd === -1) {\n\t        return source.length;\n\t    }\n\n\t    return commentEnd + 2;\n\t}\n\n\tfunction findStringEnd(source, offset, quote) {\n\t    for (; offset < source.length; offset++) {\n\t        var code = source.charCodeAt(offset);\n\n\t        // TODO: bad string\n\t        if (code === BACK_SLASH) {\n\t            offset++;\n\t        } else if (code === quote) {\n\t            offset++;\n\t            break;\n\t        }\n\t    }\n\n\t    return offset;\n\t}\n\n\tfunction findDecimalNumberEnd(source, offset) {\n\t    for (; offset < source.length; offset++) {\n\t        var code = source.charCodeAt(offset);\n\n\t        if (code < 48 || code > 57) {  // not a 0 .. 9\n\t            break;\n\t        }\n\t    }\n\n\t    return offset;\n\t}\n\n\tfunction findNumberEnd(source, offset, allowFraction) {\n\t    var code;\n\n\t    offset = findDecimalNumberEnd(source, offset);\n\n\t    // fraction: .\\d+\n\t    if (allowFraction && offset + 1 < source.length && source.charCodeAt(offset) === FULLSTOP) {\n\t        code = source.charCodeAt(offset + 1);\n\n\t        if (isNumber(code)) {\n\t            offset = findDecimalNumberEnd(source, offset + 1);\n\t        }\n\t    }\n\n\t    // exponent: e[+-]\\d+\n\t    if (offset + 1 < source.length) {\n\t        if ((source.charCodeAt(offset) | 32) === E) { // case insensitive check for `e`\n\t            code = source.charCodeAt(offset + 1);\n\n\t            if (code === PLUSSIGN || code === HYPHENMINUS) {\n\t                if (offset + 2 < source.length) {\n\t                    code = source.charCodeAt(offset + 2);\n\t                }\n\t            }\n\n\t            if (isNumber(code)) {\n\t                offset = findDecimalNumberEnd(source, offset + 2);\n\t            }\n\t        }\n\t    }\n\n\t    return offset;\n\t}\n\n\t// skip escaped unicode sequence that can ends with space\n\t// [0-9a-f]{1,6}(\\r\\n|[ \\n\\r\\t\\f])?\n\tfunction findEscaseEnd(source, offset) {\n\t    for (var i = 0; i < 7 && offset + i < source.length; i++) {\n\t        var code = source.charCodeAt(offset + i);\n\n\t        if (i !== 6 && isHex(code)) {\n\t            continue;\n\t        }\n\n\t        if (i > 0) {\n\t            offset += i - 1 + isNewline(source, offset + i, code);\n\t            if (code === SPACE$1 || code === TAB$1) {\n\t                offset++;\n\t            }\n\t        }\n\n\t        break;\n\t    }\n\n\t    return offset;\n\t}\n\n\tfunction findIdentifierEnd(source, offset) {\n\t    for (; offset < source.length; offset++) {\n\t        var code = source.charCodeAt(offset);\n\n\t        if (code === BACK_SLASH) {\n\t            offset = findEscaseEnd(source, offset + 1);\n\t        } else if (code < 0x80 && PUNCTUATION$1[code] === PUNCTUATOR$1) {\n\t            break;\n\t        }\n\t    }\n\n\t    return offset;\n\t}\n\n\tfunction findUrlRawEnd(source, offset) {\n\t    for (; offset < source.length; offset++) {\n\t        var code = source.charCodeAt(offset);\n\n\t        if (code === BACK_SLASH) {\n\t            offset = findEscaseEnd(source, offset + 1);\n\t        } else if (code < 0x80 && STOP_URL_RAW$1[code] === 1) {\n\t            break;\n\t        }\n\t    }\n\n\t    return offset;\n\t}\n\n\tvar utils = {\n\t    firstCharOffset: firstCharOffset,\n\n\t    isHex: isHex,\n\t    isNumber: isNumber,\n\t    isNewline: isNewline,\n\n\t    cmpChar: cmpChar,\n\t    cmpStr: cmpStr,\n\t    endsWith: endsWith,\n\n\t    findLastNonSpaceLocation: findLastNonSpaceLocation,\n\t    findWhiteSpaceEnd: findWhiteSpaceEnd,\n\t    findCommentEnd: findCommentEnd,\n\t    findStringEnd: findStringEnd,\n\t    findDecimalNumberEnd: findDecimalNumberEnd,\n\t    findNumberEnd: findNumberEnd,\n\t    findEscaseEnd: findEscaseEnd,\n\t    findIdentifierEnd: findIdentifierEnd,\n\t    findUrlRawEnd: findUrlRawEnd\n\t};\n\n\tvar TYPE$2 = _const.TYPE;\n\tvar NAME$1 = _const.NAME;\n\tvar SYMBOL_TYPE$1 = _const.SYMBOL_TYPE;\n\n\n\tvar firstCharOffset$1 = utils.firstCharOffset;\n\tvar cmpStr$1 = utils.cmpStr;\n\tvar isNumber$1 = utils.isNumber;\n\tvar findLastNonSpaceLocation$1 = utils.findLastNonSpaceLocation;\n\tvar findWhiteSpaceEnd$1 = utils.findWhiteSpaceEnd;\n\tvar findCommentEnd$1 = utils.findCommentEnd;\n\tvar findStringEnd$1 = utils.findStringEnd;\n\tvar findNumberEnd$1 = utils.findNumberEnd;\n\tvar findIdentifierEnd$1 = utils.findIdentifierEnd;\n\tvar findUrlRawEnd$1 = utils.findUrlRawEnd;\n\n\tvar NULL = 0;\n\tvar WHITESPACE$1 = TYPE$2.WhiteSpace;\n\tvar IDENTIFIER$1 = TYPE$2.Identifier;\n\tvar NUMBER$1 = TYPE$2.Number;\n\tvar STRING$1 = TYPE$2.String;\n\tvar COMMENT$1 = TYPE$2.Comment;\n\tvar PUNCTUATOR$2 = TYPE$2.Punctuator;\n\tvar CDO$1 = TYPE$2.CDO;\n\tvar CDC$1 = TYPE$2.CDC;\n\tvar ATRULE$1 = TYPE$2.Atrule;\n\tvar FUNCTION$1 = TYPE$2.Function;\n\tvar URL$1 = TYPE$2.Url;\n\tvar RAW$1 = TYPE$2.Raw;\n\n\tvar N$2 = 10;\n\tvar F$2 = 12;\n\tvar R$2 = 13;\n\tvar STAR = TYPE$2.Asterisk;\n\tvar SLASH = TYPE$2.Solidus;\n\tvar FULLSTOP$1 = TYPE$2.FullStop;\n\tvar PLUSSIGN$1 = TYPE$2.PlusSign;\n\tvar HYPHENMINUS$1 = TYPE$2.HyphenMinus;\n\tvar GREATERTHANSIGN = TYPE$2.GreaterThanSign;\n\tvar LESSTHANSIGN = TYPE$2.LessThanSign;\n\tvar EXCLAMATIONMARK = TYPE$2.ExclamationMark;\n\tvar COMMERCIALAT = TYPE$2.CommercialAt;\n\tvar QUOTATIONMARK = TYPE$2.QuotationMark;\n\tvar APOSTROPHE = TYPE$2.Apostrophe;\n\tvar LEFTPARENTHESIS = TYPE$2.LeftParenthesis;\n\tvar RIGHTPARENTHESIS = TYPE$2.RightParenthesis;\n\tvar LEFTCURLYBRACKET = TYPE$2.LeftCurlyBracket;\n\tvar RIGHTCURLYBRACKET = TYPE$2.RightCurlyBracket;\n\tvar LEFTSQUAREBRACKET = TYPE$2.LeftSquareBracket;\n\tvar RIGHTSQUAREBRACKET = TYPE$2.RightSquareBracket;\n\n\tvar MIN_BUFFER_SIZE = 16 * 1024;\n\tvar OFFSET_MASK = 0x00FFFFFF;\n\tvar TYPE_SHIFT = 24;\n\tvar SafeUint32Array$1 = typeof Uint32Array !== 'undefined' ? Uint32Array : Array; // fallback on Array when TypedArray is not supported\n\n\tfunction computeLinesAndColumns(tokenizer, source) {\n\t    var sourceLength = source.length;\n\t    var start = firstCharOffset$1(source);\n\t    var lines = tokenizer.lines;\n\t    var line = tokenizer.startLine;\n\t    var columns = tokenizer.columns;\n\t    var column = tokenizer.startColumn;\n\n\t    if (lines === null || lines.length < sourceLength + 1) {\n\t        lines = new SafeUint32Array$1(Math.max(sourceLength + 1024, MIN_BUFFER_SIZE));\n\t        columns = new SafeUint32Array$1(lines.length);\n\t    }\n\n\t    for (var i = start; i < sourceLength; i++) {\n\t        var code = source.charCodeAt(i);\n\n\t        lines[i] = line;\n\t        columns[i] = column++;\n\n\t        if (code === N$2 || code === R$2 || code === F$2) {\n\t            if (code === R$2 && i + 1 < sourceLength && source.charCodeAt(i + 1) === N$2) {\n\t                i++;\n\t                lines[i] = line;\n\t                columns[i] = column;\n\t            }\n\n\t            line++;\n\t            column = 1;\n\t        }\n\t    }\n\n\t    lines[i] = line;\n\t    columns[i] = column;\n\n\t    tokenizer.linesAnsColumnsComputed = true;\n\t    tokenizer.lines = lines;\n\t    tokenizer.columns = columns;\n\t}\n\n\tfunction tokenLayout(tokenizer, source, startPos) {\n\t    var sourceLength = source.length;\n\t    var offsetAndType = tokenizer.offsetAndType;\n\t    var balance = tokenizer.balance;\n\t    var tokenCount = 0;\n\t    var prevType = 0;\n\t    var offset = startPos;\n\t    var anchor = 0;\n\t    var balanceCloseCode = 0;\n\t    var balanceStart = 0;\n\t    var balancePrev = 0;\n\n\t    if (offsetAndType === null || offsetAndType.length < sourceLength + 1) {\n\t        offsetAndType = new SafeUint32Array$1(sourceLength + 1024);\n\t        balance = new SafeUint32Array$1(sourceLength + 1024);\n\t    }\n\n\t    while (offset < sourceLength) {\n\t        var code = source.charCodeAt(offset);\n\t        var type = code < 0x80 ? SYMBOL_TYPE$1[code] : IDENTIFIER$1;\n\n\t        balance[tokenCount] = sourceLength;\n\n\t        switch (type) {\n\t            case WHITESPACE$1:\n\t                offset = findWhiteSpaceEnd$1(source, offset + 1);\n\t                break;\n\n\t            case PUNCTUATOR$2:\n\t                switch (code) {\n\t                    case balanceCloseCode:\n\t                        balancePrev = balanceStart & OFFSET_MASK;\n\t                        balanceStart = balance[balancePrev];\n\t                        balanceCloseCode = balanceStart >> TYPE_SHIFT;\n\t                        balance[tokenCount] = balancePrev;\n\t                        balance[balancePrev++] = tokenCount;\n\t                        for (; balancePrev < tokenCount; balancePrev++) {\n\t                            if (balance[balancePrev] === sourceLength) {\n\t                                balance[balancePrev] = tokenCount;\n\t                            }\n\t                        }\n\t                        break;\n\n\t                    case LEFTSQUAREBRACKET:\n\t                        balance[tokenCount] = balanceStart;\n\t                        balanceCloseCode = RIGHTSQUAREBRACKET;\n\t                        balanceStart = (balanceCloseCode << TYPE_SHIFT) | tokenCount;\n\t                        break;\n\n\t                    case LEFTCURLYBRACKET:\n\t                        balance[tokenCount] = balanceStart;\n\t                        balanceCloseCode = RIGHTCURLYBRACKET;\n\t                        balanceStart = (balanceCloseCode << TYPE_SHIFT) | tokenCount;\n\t                        break;\n\n\t                    case LEFTPARENTHESIS:\n\t                        balance[tokenCount] = balanceStart;\n\t                        balanceCloseCode = RIGHTPARENTHESIS;\n\t                        balanceStart = (balanceCloseCode << TYPE_SHIFT) | tokenCount;\n\t                        break;\n\t                }\n\n\t                // /*\n\t                if (code === STAR && prevType === SLASH) {\n\t                    type = COMMENT$1;\n\t                    offset = findCommentEnd$1(source, offset + 1);\n\t                    tokenCount--; // rewrite prev token\n\t                    break;\n\t                }\n\n\t                // edge case for -.123 and +.123\n\t                if (code === FULLSTOP$1 && (prevType === PLUSSIGN$1 || prevType === HYPHENMINUS$1)) {\n\t                    if (offset + 1 < sourceLength && isNumber$1(source.charCodeAt(offset + 1))) {\n\t                        type = NUMBER$1;\n\t                        offset = findNumberEnd$1(source, offset + 2, false);\n\t                        tokenCount--; // rewrite prev token\n\t                        break;\n\t                    }\n\t                }\n\n\t                // <!--\n\t                if (code === EXCLAMATIONMARK && prevType === LESSTHANSIGN) {\n\t                    if (offset + 2 < sourceLength &&\n\t                        source.charCodeAt(offset + 1) === HYPHENMINUS$1 &&\n\t                        source.charCodeAt(offset + 2) === HYPHENMINUS$1) {\n\t                        type = CDO$1;\n\t                        offset = offset + 3;\n\t                        tokenCount--; // rewrite prev token\n\t                        break;\n\t                    }\n\t                }\n\n\t                // -->\n\t                if (code === HYPHENMINUS$1 && prevType === HYPHENMINUS$1) {\n\t                    if (offset + 1 < sourceLength && source.charCodeAt(offset + 1) === GREATERTHANSIGN) {\n\t                        type = CDC$1;\n\t                        offset = offset + 2;\n\t                        tokenCount--; // rewrite prev token\n\t                        break;\n\t                    }\n\t                }\n\n\t                // ident(\n\t                if (code === LEFTPARENTHESIS && prevType === IDENTIFIER$1) {\n\t                    offset = offset + 1;\n\t                    tokenCount--; // rewrite prev token\n\t                    balance[tokenCount] = balance[tokenCount + 1];\n\t                    balanceStart--;\n\n\t                    // 4 char length identifier and equal to `url(` (case insensitive)\n\t                    if (offset - anchor === 4 && cmpStr$1(source, anchor, offset, 'url(')) {\n\t                        // special case for url() because it can contain any symbols sequence with few exceptions\n\t                        anchor = findWhiteSpaceEnd$1(source, offset);\n\t                        code = source.charCodeAt(anchor);\n\t                        if (code !== LEFTPARENTHESIS &&\n\t                            code !== RIGHTPARENTHESIS &&\n\t                            code !== QUOTATIONMARK &&\n\t                            code !== APOSTROPHE) {\n\t                            // url(\n\t                            offsetAndType[tokenCount++] = (URL$1 << TYPE_SHIFT) | offset;\n\t                            balance[tokenCount] = sourceLength;\n\n\t                            // ws*\n\t                            if (anchor !== offset) {\n\t                                offsetAndType[tokenCount++] = (WHITESPACE$1 << TYPE_SHIFT) | anchor;\n\t                                balance[tokenCount] = sourceLength;\n\t                            }\n\n\t                            // raw\n\t                            type = RAW$1;\n\t                            offset = findUrlRawEnd$1(source, anchor);\n\t                        } else {\n\t                            type = URL$1;\n\t                        }\n\t                    } else {\n\t                        type = FUNCTION$1;\n\t                    }\n\t                    break;\n\t                }\n\n\t                type = code;\n\t                offset = offset + 1;\n\t                break;\n\n\t            case NUMBER$1:\n\t                offset = findNumberEnd$1(source, offset + 1, prevType !== FULLSTOP$1);\n\n\t                // merge number with a preceding dot, dash or plus\n\t                if (prevType === FULLSTOP$1 ||\n\t                    prevType === HYPHENMINUS$1 ||\n\t                    prevType === PLUSSIGN$1) {\n\t                    tokenCount--; // rewrite prev token\n\t                }\n\n\t                break;\n\n\t            case STRING$1:\n\t                offset = findStringEnd$1(source, offset + 1, code);\n\t                break;\n\n\t            default:\n\t                anchor = offset;\n\t                offset = findIdentifierEnd$1(source, offset);\n\n\t                // merge identifier with a preceding dash\n\t                if (prevType === HYPHENMINUS$1) {\n\t                    // rewrite prev token\n\t                    tokenCount--;\n\t                    // restore prev prev token type\n\t                    // for case @-prefix-ident\n\t                    prevType = tokenCount === 0 ? 0 : offsetAndType[tokenCount - 1] >> TYPE_SHIFT;\n\t                }\n\n\t                if (prevType === COMMERCIALAT) {\n\t                    // rewrite prev token and change type to <at-keyword-token>\n\t                    tokenCount--;\n\t                    type = ATRULE$1;\n\t                }\n\t        }\n\n\t        offsetAndType[tokenCount++] = (type << TYPE_SHIFT) | offset;\n\t        prevType = type;\n\t    }\n\n\t    // finalize arrays\n\t    offsetAndType[tokenCount] = offset;\n\t    balance[tokenCount] = sourceLength;\n\t    while (balanceStart !== 0) {\n\t        balancePrev = balanceStart & OFFSET_MASK;\n\t        balanceStart = balance[balancePrev];\n\t        balance[balancePrev] = sourceLength;\n\t    }\n\n\t    tokenizer.offsetAndType = offsetAndType;\n\t    tokenizer.tokenCount = tokenCount;\n\t    tokenizer.balance = balance;\n\t}\n\n\t//\n\t// tokenizer\n\t//\n\n\tvar Tokenizer = function(source, startOffset, startLine, startColumn) {\n\t    this.offsetAndType = null;\n\t    this.balance = null;\n\t    this.lines = null;\n\t    this.columns = null;\n\n\t    this.setSource(source, startOffset, startLine, startColumn);\n\t};\n\n\tTokenizer.prototype = {\n\t    setSource: function(source, startOffset, startLine, startColumn) {\n\t        var safeSource = String(source || '');\n\t        var start = firstCharOffset$1(safeSource);\n\n\t        this.source = safeSource;\n\t        this.firstCharOffset = start;\n\t        this.startOffset = typeof startOffset === 'undefined' ? 0 : startOffset;\n\t        this.startLine = typeof startLine === 'undefined' ? 1 : startLine;\n\t        this.startColumn = typeof startColumn === 'undefined' ? 1 : startColumn;\n\t        this.linesAnsColumnsComputed = false;\n\n\t        this.eof = false;\n\t        this.currentToken = -1;\n\t        this.tokenType = 0;\n\t        this.tokenStart = start;\n\t        this.tokenEnd = start;\n\n\t        tokenLayout(this, safeSource, start);\n\t        this.next();\n\t    },\n\n\t    lookupType: function(offset) {\n\t        offset += this.currentToken;\n\n\t        if (offset < this.tokenCount) {\n\t            return this.offsetAndType[offset] >> TYPE_SHIFT;\n\t        }\n\n\t        return NULL;\n\t    },\n\t    lookupNonWSType: function(offset) {\n\t        offset += this.currentToken;\n\n\t        for (var type; offset < this.tokenCount; offset++) {\n\t            type = this.offsetAndType[offset] >> TYPE_SHIFT;\n\n\t            if (type !== WHITESPACE$1) {\n\t                return type;\n\t            }\n\t        }\n\n\t        return NULL;\n\t    },\n\t    lookupValue: function(offset, referenceStr) {\n\t        offset += this.currentToken;\n\n\t        if (offset < this.tokenCount) {\n\t            return cmpStr$1(\n\t                this.source,\n\t                this.offsetAndType[offset - 1] & OFFSET_MASK,\n\t                this.offsetAndType[offset] & OFFSET_MASK,\n\t                referenceStr\n\t            );\n\t        }\n\n\t        return false;\n\t    },\n\t    getTokenStart: function(tokenNum) {\n\t        if (tokenNum === this.currentToken) {\n\t            return this.tokenStart;\n\t        }\n\n\t        if (tokenNum > 0) {\n\t            return tokenNum < this.tokenCount\n\t                ? this.offsetAndType[tokenNum - 1] & OFFSET_MASK\n\t                : this.offsetAndType[this.tokenCount] & OFFSET_MASK;\n\t        }\n\n\t        return this.firstCharOffset;\n\t    },\n\t    getOffsetExcludeWS: function() {\n\t        if (this.currentToken > 0) {\n\t            if ((this.offsetAndType[this.currentToken - 1] >> TYPE_SHIFT) === WHITESPACE$1) {\n\t                return this.currentToken > 1\n\t                    ? this.offsetAndType[this.currentToken - 2] & OFFSET_MASK\n\t                    : this.firstCharOffset;\n\t            }\n\t        }\n\t        return this.tokenStart;\n\t    },\n\t    getRawLength: function(startToken, endTokenType1, endTokenType2, includeTokenType2) {\n\t        var cursor = startToken;\n\t        var balanceEnd;\n\n\t        loop:\n\t        for (; cursor < this.tokenCount; cursor++) {\n\t            balanceEnd = this.balance[cursor];\n\n\t            // belance end points to offset before start\n\t            if (balanceEnd < startToken) {\n\t                break loop;\n\t            }\n\n\t            // check token is stop type\n\t            switch (this.offsetAndType[cursor] >> TYPE_SHIFT) {\n\t                case endTokenType1:\n\t                    break loop;\n\n\t                case endTokenType2:\n\t                    if (includeTokenType2) {\n\t                        cursor++;\n\t                    }\n\t                    break loop;\n\n\t                default:\n\t                    // fast forward to the end of balanced block\n\t                    if (this.balance[balanceEnd] === cursor) {\n\t                        cursor = balanceEnd;\n\t                    }\n\t            }\n\n\t        }\n\n\t        return cursor - this.currentToken;\n\t    },\n\n\t    getTokenValue: function() {\n\t        return this.source.substring(this.tokenStart, this.tokenEnd);\n\t    },\n\t    substrToCursor: function(start) {\n\t        return this.source.substring(start, this.tokenStart);\n\t    },\n\n\t    skipWS: function() {\n\t        for (var i = this.currentToken, skipTokenCount = 0; i < this.tokenCount; i++, skipTokenCount++) {\n\t            if ((this.offsetAndType[i] >> TYPE_SHIFT) !== WHITESPACE$1) {\n\t                break;\n\t            }\n\t        }\n\n\t        if (skipTokenCount > 0) {\n\t            this.skip(skipTokenCount);\n\t        }\n\t    },\n\t    skipSC: function() {\n\t        while (this.tokenType === WHITESPACE$1 || this.tokenType === COMMENT$1) {\n\t            this.next();\n\t        }\n\t    },\n\t    skip: function(tokenCount) {\n\t        var next = this.currentToken + tokenCount;\n\n\t        if (next < this.tokenCount) {\n\t            this.currentToken = next;\n\t            this.tokenStart = this.offsetAndType[next - 1] & OFFSET_MASK;\n\t            next = this.offsetAndType[next];\n\t            this.tokenType = next >> TYPE_SHIFT;\n\t            this.tokenEnd = next & OFFSET_MASK;\n\t        } else {\n\t            this.currentToken = this.tokenCount;\n\t            this.next();\n\t        }\n\t    },\n\t    next: function() {\n\t        var next = this.currentToken + 1;\n\n\t        if (next < this.tokenCount) {\n\t            this.currentToken = next;\n\t            this.tokenStart = this.tokenEnd;\n\t            next = this.offsetAndType[next];\n\t            this.tokenType = next >> TYPE_SHIFT;\n\t            this.tokenEnd = next & OFFSET_MASK;\n\t        } else {\n\t            this.currentToken = this.tokenCount;\n\t            this.eof = true;\n\t            this.tokenType = NULL;\n\t            this.tokenStart = this.tokenEnd = this.source.length;\n\t        }\n\t    },\n\n\t    eat: function(tokenType) {\n\t        if (this.tokenType !== tokenType) {\n\t            var offset = this.tokenStart;\n\t            var message = NAME$1[tokenType] + ' is expected';\n\n\t            // tweak message and offset\n\t            if (tokenType === IDENTIFIER$1) {\n\t                // when identifier is expected but there is a function or url\n\t                if (this.tokenType === FUNCTION$1 || this.tokenType === URL$1) {\n\t                    offset = this.tokenEnd - 1;\n\t                    message += ' but function found';\n\t                }\n\t            } else {\n\t                // when test type is part of another token show error for current position + 1\n\t                // e.g. eat(HYPHENMINUS) will fail on \"-foo\", but pointing on \"-\" is odd\n\t                if (this.source.charCodeAt(this.tokenStart) === tokenType) {\n\t                    offset = offset + 1;\n\t                }\n\t            }\n\n\t            this.error(message, offset);\n\t        }\n\n\t        this.next();\n\t    },\n\t    eatNonWS: function(tokenType) {\n\t        this.skipWS();\n\t        this.eat(tokenType);\n\t    },\n\n\t    consume: function(tokenType) {\n\t        var value = this.getTokenValue();\n\n\t        this.eat(tokenType);\n\n\t        return value;\n\t    },\n\t    consumeFunctionName: function() {\n\t        var name = this.source.substring(this.tokenStart, this.tokenEnd - 1);\n\n\t        this.eat(FUNCTION$1);\n\n\t        return name;\n\t    },\n\t    consumeNonWS: function(tokenType) {\n\t        this.skipWS();\n\n\t        return this.consume(tokenType);\n\t    },\n\n\t    expectIdentifier: function(name) {\n\t        if (this.tokenType !== IDENTIFIER$1 || cmpStr$1(this.source, this.tokenStart, this.tokenEnd, name) === false) {\n\t            this.error('Identifier `' + name + '` is expected');\n\t        }\n\n\t        this.next();\n\t    },\n\n\t    getLocation: function(offset, filename) {\n\t        if (!this.linesAnsColumnsComputed) {\n\t            computeLinesAndColumns(this, this.source);\n\t        }\n\n\t        return {\n\t            source: filename,\n\t            offset: this.startOffset + offset,\n\t            line: this.lines[offset],\n\t            column: this.columns[offset]\n\t        };\n\t    },\n\n\t    getLocationRange: function(start, end, filename) {\n\t        if (!this.linesAnsColumnsComputed) {\n\t            computeLinesAndColumns(this, this.source);\n\t        }\n\n\t        return {\n\t            source: filename,\n\t            start: {\n\t                offset: this.startOffset + start,\n\t                line: this.lines[start],\n\t                column: this.columns[start]\n\t            },\n\t            end: {\n\t                offset: this.startOffset + end,\n\t                line: this.lines[end],\n\t                column: this.columns[end]\n\t            }\n\t        };\n\t    },\n\n\t    error: function(message, offset) {\n\t        var location = typeof offset !== 'undefined' && offset < this.source.length\n\t            ? this.getLocation(offset)\n\t            : this.eof\n\t                ? findLastNonSpaceLocation$1(this)\n\t                : this.getLocation(this.tokenStart);\n\n\t        throw new error(\n\t            message || 'Unexpected input',\n\t            this.source,\n\t            location.offset,\n\t            location.line,\n\t            location.column\n\t        );\n\t    },\n\n\t    dump: function() {\n\t        var offset = 0;\n\n\t        return Array.prototype.slice.call(this.offsetAndType, 0, this.tokenCount).map(function(item, idx) {\n\t            var start = offset;\n\t            var end = item & OFFSET_MASK;\n\n\t            offset = end;\n\n\t            return {\n\t                idx: idx,\n\t                type: NAME$1[item >> TYPE_SHIFT],\n\t                chunk: this.source.substring(start, end),\n\t                balance: this.balance[idx]\n\t            };\n\t        }, this);\n\t    }\n\t};\n\n\t// extend with error class\n\tTokenizer.CssSyntaxError = error;\n\n\t// extend tokenizer with constants\n\tObject.keys(_const).forEach(function(key) {\n\t    Tokenizer[key] = _const[key];\n\t});\n\n\t// extend tokenizer with static methods from utils\n\tObject.keys(utils).forEach(function(key) {\n\t    Tokenizer[key] = utils[key];\n\t});\n\n\t// warm up tokenizer to elimitate code branches that never execute\n\t// fix soft deoptimizations (insufficient type feedback)\n\tnew Tokenizer('\\n\\r\\r\\n\\f<!---->//\"\"\\'\\'/*\\r\\n\\f*/1a;.\\\\31\\t\\+2{url(a);func();+1.2e3 -.4e-5 .6e+7}').getLocation();\n\n\tvar Tokenizer_1 = Tokenizer;\n\n\tvar tokenizer = Tokenizer_1;\n\n\t//\n\t//            item        item        item        item\n\t//          /------\\    /------\\    /------\\    /------\\\n\t//          | data |    | data |    | data |    | data |\n\t//  null <--+-prev |<---+-prev |<---+-prev |<---+-prev |\n\t//          | next-+--->| next-+--->| next-+--->| next-+--> null\n\t//          \\------/    \\------/    \\------/    \\------/\n\t//             ^                                    ^\n\t//             |                list                |\n\t//             |              /------\\              |\n\t//             \\--------------+-head |              |\n\t//                            | tail-+--------------/\n\t//                            \\------/\n\t//\n\n\tfunction createItem(data) {\n\t    return {\n\t        prev: null,\n\t        next: null,\n\t        data: data\n\t    };\n\t}\n\n\tvar cursors = null;\n\tvar List = function() {\n\t    this.cursor = null;\n\t    this.head = null;\n\t    this.tail = null;\n\t};\n\n\tList.createItem = createItem;\n\tList.prototype.createItem = createItem;\n\n\tList.prototype.getSize = function() {\n\t    var size = 0;\n\t    var cursor = this.head;\n\n\t    while (cursor) {\n\t        size++;\n\t        cursor = cursor.next;\n\t    }\n\n\t    return size;\n\t};\n\n\tList.prototype.fromArray = function(array) {\n\t    var cursor = null;\n\n\t    this.head = null;\n\n\t    for (var i = 0; i < array.length; i++) {\n\t        var item = createItem(array[i]);\n\n\t        if (cursor !== null) {\n\t            cursor.next = item;\n\t        } else {\n\t            this.head = item;\n\t        }\n\n\t        item.prev = cursor;\n\t        cursor = item;\n\t    }\n\n\t    this.tail = cursor;\n\n\t    return this;\n\t};\n\n\tList.prototype.toArray = function() {\n\t    var cursor = this.head;\n\t    var result = [];\n\n\t    while (cursor) {\n\t        result.push(cursor.data);\n\t        cursor = cursor.next;\n\t    }\n\n\t    return result;\n\t};\n\n\tList.prototype.toJSON = List.prototype.toArray;\n\n\tList.prototype.isEmpty = function() {\n\t    return this.head === null;\n\t};\n\n\tList.prototype.first = function() {\n\t    return this.head && this.head.data;\n\t};\n\n\tList.prototype.last = function() {\n\t    return this.tail && this.tail.data;\n\t};\n\n\tfunction allocateCursor(node, prev, next) {\n\t    var cursor;\n\n\t    if (cursors !== null) {\n\t        cursor = cursors;\n\t        cursors = cursors.cursor;\n\t        cursor.prev = prev;\n\t        cursor.next = next;\n\t        cursor.cursor = node.cursor;\n\t    } else {\n\t        cursor = {\n\t            prev: prev,\n\t            next: next,\n\t            cursor: node.cursor\n\t        };\n\t    }\n\n\t    node.cursor = cursor;\n\n\t    return cursor;\n\t}\n\n\tfunction releaseCursor(node) {\n\t    var cursor = node.cursor;\n\n\t    node.cursor = cursor.cursor;\n\t    cursor.prev = null;\n\t    cursor.next = null;\n\t    cursor.cursor = cursors;\n\t    cursors = cursor;\n\t}\n\n\tList.prototype.each = function(fn, context) {\n\t    var item;\n\n\t    if (context === undefined) {\n\t        context = this;\n\t    }\n\n\t    // push cursor\n\t    var cursor = allocateCursor(this, null, this.head);\n\n\t    while (cursor.next !== null) {\n\t        item = cursor.next;\n\t        cursor.next = item.next;\n\n\t        fn.call(context, item.data, item, this);\n\t    }\n\n\t    // pop cursor\n\t    releaseCursor(this);\n\t};\n\n\tList.prototype.eachRight = function(fn, context) {\n\t    var item;\n\n\t    if (context === undefined) {\n\t        context = this;\n\t    }\n\n\t    // push cursor\n\t    var cursor = allocateCursor(this, this.tail, null);\n\n\t    while (cursor.prev !== null) {\n\t        item = cursor.prev;\n\t        cursor.prev = item.prev;\n\n\t        fn.call(context, item.data, item, this);\n\t    }\n\n\t    // pop cursor\n\t    releaseCursor(this);\n\t};\n\n\tList.prototype.nextUntil = function(start, fn, context) {\n\t    if (start === null) {\n\t        return;\n\t    }\n\n\t    var item;\n\n\t    if (context === undefined) {\n\t        context = this;\n\t    }\n\n\t    // push cursor\n\t    var cursor = allocateCursor(this, null, start);\n\n\t    while (cursor.next !== null) {\n\t        item = cursor.next;\n\t        cursor.next = item.next;\n\n\t        if (fn.call(context, item.data, item, this)) {\n\t            break;\n\t        }\n\t    }\n\n\t    // pop cursor\n\t    releaseCursor(this);\n\t};\n\n\tList.prototype.prevUntil = function(start, fn, context) {\n\t    if (start === null) {\n\t        return;\n\t    }\n\n\t    var item;\n\n\t    if (context === undefined) {\n\t        context = this;\n\t    }\n\n\t    // push cursor\n\t    var cursor = allocateCursor(this, start, null);\n\n\t    while (cursor.prev !== null) {\n\t        item = cursor.prev;\n\t        cursor.prev = item.prev;\n\n\t        if (fn.call(context, item.data, item, this)) {\n\t            break;\n\t        }\n\t    }\n\n\t    // pop cursor\n\t    releaseCursor(this);\n\t};\n\n\tList.prototype.some = function(fn, context) {\n\t    var cursor = this.head;\n\n\t    if (context === undefined) {\n\t        context = this;\n\t    }\n\n\t    while (cursor !== null) {\n\t        if (fn.call(context, cursor.data, cursor, this)) {\n\t            return true;\n\t        }\n\n\t        cursor = cursor.next;\n\t    }\n\n\t    return false;\n\t};\n\n\tList.prototype.map = function(fn, context) {\n\t    var result = [];\n\t    var cursor = this.head;\n\n\t    if (context === undefined) {\n\t        context = this;\n\t    }\n\n\t    while (cursor !== null) {\n\t        result.push(fn.call(context, cursor.data, cursor, this));\n\t        cursor = cursor.next;\n\t    }\n\n\t    return result;\n\t};\n\n\tList.prototype.clear = function() {\n\t    this.head = null;\n\t    this.tail = null;\n\t};\n\n\tList.prototype.copy = function() {\n\t    var result = new List();\n\t    var cursor = this.head;\n\n\t    while (cursor !== null) {\n\t        result.insert(createItem(cursor.data));\n\t        cursor = cursor.next;\n\t    }\n\n\t    return result;\n\t};\n\n\tList.prototype.updateCursors = function(prevOld, prevNew, nextOld, nextNew) {\n\t    var cursor = this.cursor;\n\n\t    while (cursor !== null) {\n\t        if (cursor.prev === prevOld) {\n\t            cursor.prev = prevNew;\n\t        }\n\n\t        if (cursor.next === nextOld) {\n\t            cursor.next = nextNew;\n\t        }\n\n\t        cursor = cursor.cursor;\n\t    }\n\t};\n\n\tList.prototype.prepend = function(item) {\n\t    //      head\n\t    //    ^\n\t    // item\n\t    this.updateCursors(null, item, this.head, item);\n\n\t    // insert to the beginning of the list\n\t    if (this.head !== null) {\n\t        // new item <- first item\n\t        this.head.prev = item;\n\n\t        // new item -> first item\n\t        item.next = this.head;\n\t    } else {\n\t        // if list has no head, then it also has no tail\n\t        // in this case tail points to the new item\n\t        this.tail = item;\n\t    }\n\n\t    // head always points to new item\n\t    this.head = item;\n\n\t    return this;\n\t};\n\n\tList.prototype.prependData = function(data) {\n\t    return this.prepend(createItem(data));\n\t};\n\n\tList.prototype.append = function(item) {\n\t    // tail\n\t    //      ^\n\t    //      item\n\t    this.updateCursors(this.tail, item, null, item);\n\n\t    // insert to the ending of the list\n\t    if (this.tail !== null) {\n\t        // last item -> new item\n\t        this.tail.next = item;\n\n\t        // last item <- new item\n\t        item.prev = this.tail;\n\t    } else {\n\t        // if list has no tail, then it also has no head\n\t        // in this case head points to new item\n\t        this.head = item;\n\t    }\n\n\t    // tail always points to new item\n\t    this.tail = item;\n\n\t    return this;\n\t};\n\n\tList.prototype.appendData = function(data) {\n\t    return this.append(createItem(data));\n\t};\n\n\tList.prototype.insert = function(item, before) {\n\t    if (before !== undefined && before !== null) {\n\t        // prev   before\n\t        //      ^\n\t        //     item\n\t        this.updateCursors(before.prev, item, before, item);\n\n\t        if (before.prev === null) {\n\t            // insert to the beginning of list\n\t            if (this.head !== before) {\n\t                throw new Error('before doesn\\'t belong to list');\n\t            }\n\n\t            // since head points to before therefore list doesn't empty\n\t            // no need to check tail\n\t            this.head = item;\n\t            before.prev = item;\n\t            item.next = before;\n\n\t            this.updateCursors(null, item);\n\t        } else {\n\n\t            // insert between two items\n\t            before.prev.next = item;\n\t            item.prev = before.prev;\n\n\t            before.prev = item;\n\t            item.next = before;\n\t        }\n\t    } else {\n\t        this.append(item);\n\t    }\n\t};\n\n\tList.prototype.insertData = function(data, before) {\n\t    this.insert(createItem(data), before);\n\t};\n\n\tList.prototype.remove = function(item) {\n\t    //      item\n\t    //       ^\n\t    // prev     next\n\t    this.updateCursors(item, item.prev, item, item.next);\n\n\t    if (item.prev !== null) {\n\t        item.prev.next = item.next;\n\t    } else {\n\t        if (this.head !== item) {\n\t            throw new Error('item doesn\\'t belong to list');\n\t        }\n\n\t        this.head = item.next;\n\t    }\n\n\t    if (item.next !== null) {\n\t        item.next.prev = item.prev;\n\t    } else {\n\t        if (this.tail !== item) {\n\t            throw new Error('item doesn\\'t belong to list');\n\t        }\n\n\t        this.tail = item.prev;\n\t    }\n\n\t    item.prev = null;\n\t    item.next = null;\n\n\t    return item;\n\t};\n\n\tList.prototype.appendList = function(list) {\n\t    // ignore empty lists\n\t    if (list.head === null) {\n\t        return;\n\t    }\n\n\t    this.updateCursors(this.tail, list.tail, null, list.head);\n\n\t    // insert to end of the list\n\t    if (this.tail !== null) {\n\t        // if destination list has a tail, then it also has a head,\n\t        // but head doesn't change\n\n\t        // dest tail -> source head\n\t        this.tail.next = list.head;\n\n\t        // dest tail <- source head\n\t        list.head.prev = this.tail;\n\t    } else {\n\t        // if list has no a tail, then it also has no a head\n\t        // in this case points head to new item\n\t        this.head = list.head;\n\t    }\n\n\t    // tail always start point to new item\n\t    this.tail = list.tail;\n\n\t    list.head = null;\n\t    list.tail = null;\n\t};\n\n\tList.prototype.insertList = function(list, before) {\n\t    if (before !== undefined && before !== null) {\n\t        // ignore empty lists\n\t        if (list.head === null) {\n\t            return;\n\t        }\n\n\t        this.updateCursors(before.prev, list.tail, before, list.head);\n\n\t        // insert in the middle of dist list\n\t        if (before.prev !== null) {\n\t            // before.prev <-> list.head\n\t            before.prev.next = list.head;\n\t            list.head.prev = before.prev;\n\t        } else {\n\t            this.head = list.head;\n\t        }\n\n\t        before.prev = list.tail;\n\t        list.tail.next = before;\n\n\t        list.head = null;\n\t        list.tail = null;\n\t    } else {\n\t        this.appendList(list);\n\t    }\n\t};\n\n\tList.prototype.replace = function(oldItem, newItemOrList) {\n\t    if ('head' in newItemOrList) {\n\t        this.insertList(newItemOrList, oldItem);\n\t    } else {\n\t        this.insert(newItemOrList, oldItem);\n\t    }\n\t    this.remove(oldItem);\n\t};\n\n\tvar list = List;\n\n\tvar TYPE$3 = tokenizer.TYPE;\n\tvar WHITESPACE$2 = TYPE$3.WhiteSpace;\n\tvar COMMENT$2 = TYPE$3.Comment;\n\n\tvar sequence = function readSequence(recognizer) {\n\t    var children = new list();\n\t    var child = null;\n\t    var context = {\n\t        recognizer: recognizer,\n\t        space: null,\n\t        ignoreWS: false,\n\t        ignoreWSAfter: false\n\t    };\n\n\t    this.scanner.skipSC();\n\n\t    while (!this.scanner.eof) {\n\t        switch (this.scanner.tokenType) {\n\t            case COMMENT$2:\n\t                this.scanner.next();\n\t                continue;\n\n\t            case WHITESPACE$2:\n\t                if (context.ignoreWS) {\n\t                    this.scanner.next();\n\t                } else {\n\t                    context.space = this.WhiteSpace();\n\t                }\n\t                continue;\n\t        }\n\n\t        child = recognizer.getNode.call(this, context);\n\n\t        if (child === undefined) {\n\t            break;\n\t        }\n\n\t        if (context.space !== null) {\n\t            children.appendData(context.space);\n\t            context.space = null;\n\t        }\n\n\t        children.appendData(child);\n\n\t        if (context.ignoreWSAfter) {\n\t            context.ignoreWSAfter = false;\n\t            context.ignoreWS = true;\n\t        } else {\n\t            context.ignoreWS = false;\n\t        }\n\t    }\n\n\t    return children;\n\t};\n\n\tvar noop = function() {};\n\n\tfunction createParseContext(name) {\n\t    return function() {\n\t        return this[name]();\n\t    };\n\t}\n\n\tfunction processConfig(config) {\n\t    var parserConfig = {\n\t        context: {},\n\t        scope: {},\n\t        atrule: {},\n\t        pseudo: {}\n\t    };\n\n\t    if (config.parseContext) {\n\t        for (var name in config.parseContext) {\n\t            switch (typeof config.parseContext[name]) {\n\t                case 'function':\n\t                    parserConfig.context[name] = config.parseContext[name];\n\t                    break;\n\n\t                case 'string':\n\t                    parserConfig.context[name] = createParseContext(config.parseContext[name]);\n\t                    break;\n\t            }\n\t        }\n\t    }\n\n\t    if (config.scope) {\n\t        for (var name in config.scope) {\n\t            parserConfig.scope[name] = config.scope[name];\n\t        }\n\t    }\n\n\t    if (config.atrule) {\n\t        for (var name in config.atrule) {\n\t            var atrule = config.atrule[name];\n\n\t            if (atrule.parse) {\n\t                parserConfig.atrule[name] = atrule.parse;\n\t            }\n\t        }\n\t    }\n\n\t    if (config.pseudo) {\n\t        for (var name in config.pseudo) {\n\t            var pseudo = config.pseudo[name];\n\n\t            if (pseudo.parse) {\n\t                parserConfig.pseudo[name] = pseudo.parse;\n\t            }\n\t        }\n\t    }\n\n\t    if (config.node) {\n\t        for (var name in config.node) {\n\t            parserConfig[name] = config.node[name].parse;\n\t        }\n\t    }\n\n\t    return parserConfig;\n\t}\n\n\tvar create = function createParser(config) {\n\t    var parser = {\n\t        scanner: new tokenizer(),\n\t        filename: '<unknown>',\n\t        needPositions: false,\n\t        tolerant: false,\n\t        onParseError: noop,\n\t        parseAtruleExpression: true,\n\t        parseSelector: true,\n\t        parseValue: true,\n\t        parseCustomProperty: false,\n\n\t        readSequence: sequence,\n\n\t        tolerantParse: function(consumer, fallback) {\n\t            if (this.tolerant) {\n\t                var start = this.scanner.currentToken;\n\n\t                try {\n\t                    return consumer.call(this);\n\t                } catch (e) {\n\t                    this.onParseError(e);\n\t                    return fallback.call(this, start);\n\t                }\n\t            } else {\n\t                return consumer.call(this);\n\t            }\n\t        },\n\n\t        getLocation: function(start, end) {\n\t            if (this.needPositions) {\n\t                return this.scanner.getLocationRange(\n\t                    start,\n\t                    end,\n\t                    this.filename\n\t                );\n\t            }\n\n\t            return null;\n\t        },\n\t        getLocationFromList: function(list) {\n\t            if (this.needPositions) {\n\t                return this.scanner.getLocationRange(\n\t                    list.head !== null ? list.first().loc.start.offset - this.scanner.startOffset : this.scanner.tokenStart,\n\t                    list.head !== null ? list.last().loc.end.offset - this.scanner.startOffset : this.scanner.tokenStart,\n\t                    this.filename\n\t                );\n\t            }\n\n\t            return null;\n\t        }\n\t    };\n\n\t    config = processConfig(config || {});\n\t    for (var key in config) {\n\t        parser[key] = config[key];\n\t    }\n\n\t    return function(source, options) {\n\t        options = options || {};\n\n\t        var context = options.context || 'default';\n\t        var ast;\n\n\t        parser.scanner.setSource(source, options.offset, options.line, options.column);\n\t        parser.filename = options.filename || '<unknown>';\n\t        parser.needPositions = Boolean(options.positions);\n\t        parser.tolerant = Boolean(options.tolerant);\n\t        parser.onParseError = typeof options.onParseError === 'function' ? options.onParseError : noop;\n\t        parser.parseAtruleExpression = 'parseAtruleExpression' in options ? Boolean(options.parseAtruleExpression) : true;\n\t        parser.parseSelector = 'parseSelector' in options ? Boolean(options.parseSelector) : true;\n\t        parser.parseValue = 'parseValue' in options ? Boolean(options.parseValue) : true;\n\t        parser.parseCustomProperty = 'parseCustomProperty' in options ? Boolean(options.parseCustomProperty) : false;\n\n\t        if (!parser.context.hasOwnProperty(context)) {\n\t            throw new Error('Unknown context `' + context + '`');\n\t        }\n\n\t        ast = parser.context[context].call(parser, options);\n\n\t        if (!parser.scanner.eof) {\n\t            parser.scanner.error();\n\t        }\n\n\t        // console.log(JSON.stringify(ast, null, 4));\n\t        return ast;\n\t    };\n\t};\n\n\tvar cmpChar$1 = tokenizer.cmpChar;\n\tvar TYPE$4 = tokenizer.TYPE;\n\n\tvar IDENTIFIER$2 = TYPE$4.Identifier;\n\tvar STRING$2 = TYPE$4.String;\n\tvar NUMBER$2 = TYPE$4.Number;\n\tvar FUNCTION$2 = TYPE$4.Function;\n\tvar URL$2 = TYPE$4.Url;\n\tvar NUMBERSIGN = TYPE$4.NumberSign;\n\tvar LEFTPARENTHESIS$1 = TYPE$4.LeftParenthesis;\n\tvar LEFTSQUAREBRACKET$1 = TYPE$4.LeftSquareBracket;\n\tvar PLUSSIGN$2 = TYPE$4.PlusSign;\n\tvar HYPHENMINUS$2 = TYPE$4.HyphenMinus;\n\tvar COMMA = TYPE$4.Comma;\n\tvar SOLIDUS = TYPE$4.Solidus;\n\tvar ASTERISK = TYPE$4.Asterisk;\n\tvar PERCENTSIGN = TYPE$4.PercentSign;\n\tvar BACKSLASH = TYPE$4.Backslash;\n\tvar U = 117; // 'u'.charCodeAt(0)\n\n\tvar _default = function defaultRecognizer(context) {\n\t    switch (this.scanner.tokenType) {\n\t        case NUMBERSIGN:\n\t            return this.HexColor();\n\n\t        case COMMA:\n\t            context.space = null;\n\t            context.ignoreWSAfter = true;\n\t            return this.Operator();\n\n\t        case SOLIDUS:\n\t        case ASTERISK:\n\t        case PLUSSIGN$2:\n\t        case HYPHENMINUS$2:\n\t            return this.Operator();\n\n\t        case LEFTPARENTHESIS$1:\n\t            return this.Parentheses(this.readSequence, context.recognizer);\n\n\t        case LEFTSQUAREBRACKET$1:\n\t            return this.Brackets(this.readSequence, context.recognizer);\n\n\t        case STRING$2:\n\t            return this.String();\n\n\t        case NUMBER$2:\n\t            switch (this.scanner.lookupType(1)) {\n\t                case PERCENTSIGN:\n\t                    return this.Percentage();\n\n\t                case IDENTIFIER$2:\n\t                    // edge case: number with folowing \\0 and \\9 hack shouldn't to be a Dimension\n\t                    if (cmpChar$1(this.scanner.source, this.scanner.tokenEnd, BACKSLASH)) {\n\t                        return this.Number();\n\t                    } else {\n\t                        return this.Dimension();\n\t                    }\n\n\t                default:\n\t                    return this.Number();\n\t            }\n\n\t        case FUNCTION$2:\n\t            return this.Function(this.readSequence, context.recognizer);\n\n\t        case URL$2:\n\t            return this.Url();\n\n\t        case IDENTIFIER$2:\n\t            // check for unicode range, it should start with u+ or U+\n\t            if (cmpChar$1(this.scanner.source, this.scanner.tokenStart, U) &&\n\t                cmpChar$1(this.scanner.source, this.scanner.tokenStart + 1, PLUSSIGN$2)) {\n\t                return this.UnicodeRange();\n\t            } else {\n\t                return this.Identifier();\n\t            }\n\t    }\n\t};\n\n\tvar atruleExpression = {\n\t    getNode: _default\n\t};\n\n\tvar TYPE$5 = tokenizer.TYPE;\n\n\tvar IDENTIFIER$3 = TYPE$5.Identifier;\n\tvar NUMBER$3 = TYPE$5.Number;\n\tvar NUMBERSIGN$1 = TYPE$5.NumberSign;\n\tvar LEFTSQUAREBRACKET$2 = TYPE$5.LeftSquareBracket;\n\tvar PLUSSIGN$3 = TYPE$5.PlusSign;\n\tvar SOLIDUS$1 = TYPE$5.Solidus;\n\tvar ASTERISK$1 = TYPE$5.Asterisk;\n\tvar FULLSTOP$2 = TYPE$5.FullStop;\n\tvar COLON = TYPE$5.Colon;\n\tvar GREATERTHANSIGN$1 = TYPE$5.GreaterThanSign;\n\tvar VERTICALLINE = TYPE$5.VerticalLine;\n\tvar TILDE = TYPE$5.Tilde;\n\n\tfunction getNode(context) {\n\t    switch (this.scanner.tokenType) {\n\t        case PLUSSIGN$3:\n\t        case GREATERTHANSIGN$1:\n\t        case TILDE:\n\t            context.space = null;\n\t            context.ignoreWSAfter = true;\n\t            return this.Combinator();\n\n\t        case SOLIDUS$1:  // /deep/\n\t            return this.Combinator();\n\n\t        case FULLSTOP$2:\n\t            return this.ClassSelector();\n\n\t        case LEFTSQUAREBRACKET$2:\n\t            return this.AttributeSelector();\n\n\t        case NUMBERSIGN$1:\n\t            return this.IdSelector();\n\n\t        case COLON:\n\t            if (this.scanner.lookupType(1) === COLON) {\n\t                return this.PseudoElementSelector();\n\t            } else {\n\t                return this.PseudoClassSelector();\n\t            }\n\n\t        case IDENTIFIER$3:\n\t        case ASTERISK$1:\n\t        case VERTICALLINE:\n\t            return this.TypeSelector();\n\n\t        case NUMBER$3:\n\t            return this.Percentage();\n\t    }\n\t}\n\tvar selector = {\n\t    getNode: getNode\n\t};\n\n\t// https://drafts.csswg.org/css-images-4/#element-notation\n\t// https://developer.mozilla.org/en-US/docs/Web/CSS/element\n\tvar element = function() {\n\t    this.scanner.skipSC();\n\n\t    var id = this.IdSelector();\n\n\t    this.scanner.skipSC();\n\n\t    return new list().appendData(\n\t        id\n\t    );\n\t};\n\n\t// legacy IE function\n\t// expression '(' raw ')'\n\tvar expression = function() {\n\t    return new list().appendData(\n\t        this.Raw(this.scanner.currentToken, 0, 0, false, false)\n\t    );\n\t};\n\n\tvar TYPE$6 = tokenizer.TYPE;\n\n\tvar IDENTIFIER$4 = TYPE$6.Identifier;\n\tvar COMMA$1 = TYPE$6.Comma;\n\tvar SEMICOLON = TYPE$6.Semicolon;\n\tvar HYPHENMINUS$3 = TYPE$6.HyphenMinus;\n\tvar EXCLAMATIONMARK$1 = TYPE$6.ExclamationMark;\n\n\t// var '(' ident (',' <value>? )? ')'\n\tvar _var = function() {\n\t    var children = new list();\n\n\t    this.scanner.skipSC();\n\n\t    var identStart = this.scanner.tokenStart;\n\n\t    this.scanner.eat(HYPHENMINUS$3);\n\t    if (this.scanner.source.charCodeAt(this.scanner.tokenStart) !== HYPHENMINUS$3) {\n\t        this.scanner.error('HyphenMinus is expected');\n\t    }\n\t    this.scanner.eat(IDENTIFIER$4);\n\n\t    children.appendData({\n\t        type: 'Identifier',\n\t        loc: this.getLocation(identStart, this.scanner.tokenStart),\n\t        name: this.scanner.substrToCursor(identStart)\n\t    });\n\n\t    this.scanner.skipSC();\n\n\t    if (this.scanner.tokenType === COMMA$1) {\n\t        children.appendData(this.Operator());\n\t        children.appendData(this.parseCustomProperty\n\t            ? this.Value(null)\n\t            : this.Raw(this.scanner.currentToken, EXCLAMATIONMARK$1, SEMICOLON, false, false)\n\t        );\n\t    }\n\n\t    return children;\n\t};\n\n\tvar value = {\n\t    getNode: _default,\n\t    '-moz-element': element,\n\t    'element': element,\n\t    'expression': expression,\n\t    'var': _var\n\t};\n\n\tvar scope = {\n\t    AtruleExpression: atruleExpression,\n\t    Selector: selector,\n\t    Value: value\n\t};\n\n\tvar fontFace = {\n\t    parse: {\n\t        expression: null,\n\t        block: function() {\n\t            return this.Block(this.Declaration);\n\t        }\n\t    }\n\t};\n\n\tvar TYPE$7 = tokenizer.TYPE;\n\n\tvar STRING$3 = TYPE$7.String;\n\tvar IDENTIFIER$5 = TYPE$7.Identifier;\n\tvar URL$3 = TYPE$7.Url;\n\tvar LEFTPARENTHESIS$2 = TYPE$7.LeftParenthesis;\n\n\tvar _import = {\n\t    parse: {\n\t        expression: function() {\n\t            var children = new list();\n\n\t            this.scanner.skipSC();\n\n\t            switch (this.scanner.tokenType) {\n\t                case STRING$3:\n\t                    children.appendData(this.String());\n\t                    break;\n\n\t                case URL$3:\n\t                    children.appendData(this.Url());\n\t                    break;\n\n\t                default:\n\t                    this.scanner.error('String or url() is expected');\n\t            }\n\n\t            if (this.scanner.lookupNonWSType(0) === IDENTIFIER$5 ||\n\t                this.scanner.lookupNonWSType(0) === LEFTPARENTHESIS$2) {\n\t                children.appendData(this.WhiteSpace());\n\t                children.appendData(this.MediaQueryList());\n\t            }\n\n\t            return children;\n\t        },\n\t        block: null\n\t    }\n\t};\n\n\tvar media = {\n\t    parse: {\n\t        expression: function() {\n\t            return new list().appendData(\n\t                this.MediaQueryList()\n\t            );\n\t        },\n\t        block: function() {\n\t            return this.Block(this.Rule);\n\t        }\n\t    }\n\t};\n\n\tvar TYPE$8 = tokenizer.TYPE;\n\tvar LEFTCURLYBRACKET$1 = TYPE$8.LeftCurlyBracket;\n\n\tvar page = {\n\t    parse: {\n\t        expression: function() {\n\t            if (this.scanner.lookupNonWSType(0) === LEFTCURLYBRACKET$1) {\n\t                return null;\n\t            }\n\n\t            return new list().appendData(\n\t                this.SelectorList()\n\t            );\n\t        },\n\t        block: function() {\n\t            return this.Block(this.Declaration);\n\t        }\n\t    }\n\t};\n\n\tvar TYPE$9 = tokenizer.TYPE;\n\n\tvar WHITESPACE$3 = TYPE$9.WhiteSpace;\n\tvar COMMENT$3 = TYPE$9.Comment;\n\tvar IDENTIFIER$6 = TYPE$9.Identifier;\n\tvar FUNCTION$3 = TYPE$9.Function;\n\tvar LEFTPARENTHESIS$3 = TYPE$9.LeftParenthesis;\n\tvar HYPHENMINUS$4 = TYPE$9.HyphenMinus;\n\tvar COLON$1 = TYPE$9.Colon;\n\n\tfunction consumeRaw() {\n\t    return new list().appendData(\n\t        this.Raw(this.scanner.currentToken, 0, 0, false, false)\n\t    );\n\t}\n\n\tfunction parentheses() {\n\t    var index = 0;\n\n\t    this.scanner.skipSC();\n\n\t    // TODO: make it simplier\n\t    if (this.scanner.tokenType === IDENTIFIER$6) {\n\t        index = 1;\n\t    } else if (this.scanner.tokenType === HYPHENMINUS$4 &&\n\t               this.scanner.lookupType(1) === IDENTIFIER$6) {\n\t        index = 2;\n\t    }\n\n\t    if (index !== 0 && this.scanner.lookupNonWSType(index) === COLON$1) {\n\t        return new list().appendData(\n\t            this.Declaration()\n\t        );\n\t    }\n\n\t    return readSequence.call(this);\n\t}\n\n\tfunction readSequence() {\n\t    var children = new list();\n\t    var space = null;\n\t    var child;\n\n\t    this.scanner.skipSC();\n\n\t    scan:\n\t    while (!this.scanner.eof) {\n\t        switch (this.scanner.tokenType) {\n\t            case WHITESPACE$3:\n\t                space = this.WhiteSpace();\n\t                continue;\n\n\t            case COMMENT$3:\n\t                this.scanner.next();\n\t                continue;\n\n\t            case FUNCTION$3:\n\t                child = this.Function(consumeRaw, this.scope.AtruleExpression);\n\t                break;\n\n\t            case IDENTIFIER$6:\n\t                child = this.Identifier();\n\t                break;\n\n\t            case LEFTPARENTHESIS$3:\n\t                child = this.Parentheses(parentheses, this.scope.AtruleExpression);\n\t                break;\n\n\t            default:\n\t                break scan;\n\t        }\n\n\t        if (space !== null) {\n\t            children.appendData(space);\n\t            space = null;\n\t        }\n\n\t        children.appendData(child);\n\t    }\n\n\t    return children;\n\t}\n\n\tvar supports = {\n\t    parse: {\n\t        expression: function() {\n\t            var children = readSequence.call(this);\n\n\t            if (children.isEmpty()) {\n\t                this.scanner.error('Condition is expected');\n\t            }\n\n\t            return children;\n\t        },\n\t        block: function() {\n\t            return this.Block(this.Rule);\n\t        }\n\t    }\n\t};\n\n\tvar atrule = {\n\t    'font-face': fontFace,\n\t    'import': _import,\n\t    'media': media,\n\t    'page': page,\n\t    'supports': supports\n\t};\n\n\tvar dir = {\n\t    parse: function() {\n\t        return new list().appendData(\n\t            this.Identifier()\n\t        );\n\t    }\n\t};\n\n\tvar has$1 = {\n\t    parse: function() {\n\t        return new list().appendData(\n\t            this.SelectorList()\n\t        );\n\t    }\n\t};\n\n\tvar lang = {\n\t    parse: function() {\n\t        return new list().appendData(\n\t            this.Identifier()\n\t        );\n\t    }\n\t};\n\n\tvar selectorList = {\n\t    parse: function selectorList() {\n\t        return new list().appendData(\n\t            this.SelectorList()\n\t        );\n\t    }\n\t};\n\n\tvar matches = selectorList;\n\n\tvar not = selectorList;\n\n\tvar ALLOW_OF_CLAUSE = true;\n\n\tvar nthWithOfClause = {\n\t    parse: function() {\n\t        return new list().appendData(\n\t            this.Nth(ALLOW_OF_CLAUSE)\n\t        );\n\t    }\n\t};\n\n\tvar nthChild = nthWithOfClause;\n\n\tvar nthLastChild = nthWithOfClause;\n\n\tvar DISALLOW_OF_CLAUSE = false;\n\n\tvar nth = {\n\t    parse: function nth() {\n\t        return new list().appendData(\n\t            this.Nth(DISALLOW_OF_CLAUSE)\n\t        );\n\t    }\n\t};\n\n\tvar nthLastOfType = nth;\n\n\tvar nthOfType = nth;\n\n\tvar slotted = {\n\t    parse: function compoundSelector() {\n\t        return new list().appendData(\n\t            this.Selector()\n\t        );\n\t    }\n\t};\n\n\tvar pseudo = {\n\t    'dir': dir,\n\t    'has': has$1,\n\t    'lang': lang,\n\t    'matches': matches,\n\t    'not': not,\n\t    'nth-child': nthChild,\n\t    'nth-last-child': nthLastChild,\n\t    'nth-last-of-type': nthLastOfType,\n\t    'nth-of-type': nthOfType,\n\t    'slotted': slotted\n\t};\n\n\tvar cmpChar$2 = tokenizer.cmpChar;\n\tvar isNumber$2 = tokenizer.isNumber;\n\tvar TYPE$a = tokenizer.TYPE;\n\n\tvar IDENTIFIER$7 = TYPE$a.Identifier;\n\tvar NUMBER$4 = TYPE$a.Number;\n\tvar PLUSSIGN$4 = TYPE$a.PlusSign;\n\tvar HYPHENMINUS$5 = TYPE$a.HyphenMinus;\n\tvar N$3 = 110; // 'n'.charCodeAt(0)\n\tvar DISALLOW_SIGN = true;\n\tvar ALLOW_SIGN = false;\n\n\tfunction checkTokenIsInteger(scanner, disallowSign) {\n\t    var pos = scanner.tokenStart;\n\n\t    if (scanner.source.charCodeAt(pos) === PLUSSIGN$4 ||\n\t        scanner.source.charCodeAt(pos) === HYPHENMINUS$5) {\n\t        if (disallowSign) {\n\t            scanner.error();\n\t        }\n\t        pos++;\n\t    }\n\n\t    for (; pos < scanner.tokenEnd; pos++) {\n\t        if (!isNumber$2(scanner.source.charCodeAt(pos))) {\n\t            scanner.error('Unexpected input', pos);\n\t        }\n\t    }\n\t}\n\n\t// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb\n\tvar AnPlusB = {\n\t    name: 'AnPlusB',\n\t    structure: {\n\t        a: [String, null],\n\t        b: [String, null]\n\t    },\n\t    parse: function() {\n\t        var start = this.scanner.tokenStart;\n\t        var end = start;\n\t        var prefix = '';\n\t        var a = null;\n\t        var b = null;\n\n\t        if (this.scanner.tokenType === NUMBER$4 ||\n\t            this.scanner.tokenType === PLUSSIGN$4) {\n\t            checkTokenIsInteger(this.scanner, ALLOW_SIGN);\n\t            prefix = this.scanner.getTokenValue();\n\t            this.scanner.next();\n\t            end = this.scanner.tokenStart;\n\t        }\n\n\t        if (this.scanner.tokenType === IDENTIFIER$7) {\n\t            var bStart = this.scanner.tokenStart;\n\n\t            if (cmpChar$2(this.scanner.source, bStart, HYPHENMINUS$5)) {\n\t                if (prefix === '') {\n\t                    prefix = '-';\n\t                    bStart++;\n\t                } else {\n\t                    this.scanner.error('Unexpected hyphen minus');\n\t                }\n\t            }\n\n\t            if (!cmpChar$2(this.scanner.source, bStart, N$3)) {\n\t                this.scanner.error();\n\t            }\n\n\t            a = prefix === ''  ? '1'  :\n\t                prefix === '+' ? '+1' :\n\t                prefix === '-' ? '-1' :\n\t                prefix;\n\n\t            var len = this.scanner.tokenEnd - bStart;\n\t            if (len > 1) {\n\t                // ..n-..\n\t                if (this.scanner.source.charCodeAt(bStart + 1) !== HYPHENMINUS$5) {\n\t                    this.scanner.error('Unexpected input', bStart + 1);\n\t                }\n\n\t                if (len > 2) {\n\t                    // ..n-{number}..\n\t                    this.scanner.tokenStart = bStart + 2;\n\t                } else {\n\t                    // ..n- {number}\n\t                    this.scanner.next();\n\t                    this.scanner.skipSC();\n\t                }\n\n\t                checkTokenIsInteger(this.scanner, DISALLOW_SIGN);\n\t                b = '-' + this.scanner.getTokenValue();\n\t                this.scanner.next();\n\t                end = this.scanner.tokenStart;\n\t            } else {\n\t                prefix = '';\n\t                this.scanner.next();\n\t                end = this.scanner.tokenStart;\n\t                this.scanner.skipSC();\n\n\t                if (this.scanner.tokenType === HYPHENMINUS$5 ||\n\t                    this.scanner.tokenType === PLUSSIGN$4) {\n\t                    prefix = this.scanner.getTokenValue();\n\t                    this.scanner.next();\n\t                    this.scanner.skipSC();\n\t                }\n\n\t                if (this.scanner.tokenType === NUMBER$4) {\n\t                    checkTokenIsInteger(this.scanner, prefix !== '');\n\n\t                    if (!isNumber$2(this.scanner.source.charCodeAt(this.scanner.tokenStart))) {\n\t                        prefix = this.scanner.source.charAt(this.scanner.tokenStart);\n\t                        this.scanner.tokenStart++;\n\t                    }\n\n\t                    if (prefix === '') {\n\t                        // should be an operator before number\n\t                        this.scanner.error();\n\t                    } else if (prefix === '+') {\n\t                        // plus is using by default\n\t                        prefix = '';\n\t                    }\n\n\t                    b = prefix + this.scanner.getTokenValue();\n\n\t                    this.scanner.next();\n\t                    end = this.scanner.tokenStart;\n\t                } else {\n\t                    if (prefix) {\n\t                        this.scanner.eat(NUMBER$4);\n\t                    }\n\t                }\n\t            }\n\t        } else {\n\t            if (prefix === '' || prefix === '+') { // no number\n\t                this.scanner.error(\n\t                    'Number or identifier is expected',\n\t                    this.scanner.tokenStart + (\n\t                        this.scanner.tokenType === PLUSSIGN$4 ||\n\t                        this.scanner.tokenType === HYPHENMINUS$5\n\t                    )\n\t                );\n\t            }\n\n\t            b = prefix;\n\t        }\n\n\t        return {\n\t            type: 'AnPlusB',\n\t            loc: this.getLocation(start, end),\n\t            a: a,\n\t            b: b\n\t        };\n\t    },\n\t    generate: function(processChunk, node) {\n\t        var a = node.a !== null && node.a !== undefined;\n\t        var b = node.b !== null && node.b !== undefined;\n\n\t        if (a) {\n\t            processChunk(\n\t                node.a === '+1' ? '+n' :\n\t                node.a ===  '1' ?  'n' :\n\t                node.a === '-1' ? '-n' :\n\t                node.a + 'n'\n\t            );\n\n\t            if (b) {\n\t                b = String(node.b);\n\t                if (b.charAt(0) === '-' || b.charAt(0) === '+') {\n\t                    processChunk(b.charAt(0));\n\t                    processChunk(b.substr(1));\n\t                } else {\n\t                    processChunk('+');\n\t                    processChunk(b);\n\t                }\n\t            }\n\t        } else {\n\t            processChunk(String(node.b));\n\t        }\n\t    }\n\t};\n\n\tvar TYPE$b = tokenizer.TYPE;\n\n\tvar ATRULE$2 = TYPE$b.Atrule;\n\tvar SEMICOLON$1 = TYPE$b.Semicolon;\n\tvar LEFTCURLYBRACKET$2 = TYPE$b.LeftCurlyBracket;\n\tvar RIGHTCURLYBRACKET$1 = TYPE$b.RightCurlyBracket;\n\n\tfunction isBlockAtrule() {\n\t    for (var offset = 1, type; type = this.scanner.lookupType(offset); offset++) {\n\t        if (type === RIGHTCURLYBRACKET$1) {\n\t            return true;\n\t        }\n\n\t        if (type === LEFTCURLYBRACKET$2 ||\n\t            type === ATRULE$2) {\n\t            return false;\n\t        }\n\t    }\n\n\t    this.scanner.skip(offset);\n\t    this.scanner.eat(RIGHTCURLYBRACKET$1);\n\t}\n\n\tvar Atrule = {\n\t    name: 'Atrule',\n\t    structure: {\n\t        name: String,\n\t        expression: ['AtruleExpression', null],\n\t        block: ['Block', null]\n\t    },\n\t    parse: function() {\n\t        var start = this.scanner.tokenStart;\n\t        var name;\n\t        var nameLowerCase;\n\t        var expression = null;\n\t        var block = null;\n\n\t        this.scanner.eat(ATRULE$2);\n\n\t        name = this.scanner.substrToCursor(start + 1);\n\t        nameLowerCase = name.toLowerCase();\n\t        this.scanner.skipSC();\n\n\t        expression = this.AtruleExpression(name);\n\n\t        // turn empty AtruleExpression into null\n\t        if (expression.children.head === null) {\n\t            expression = null;\n\t        }\n\n\t        this.scanner.skipSC();\n\n\t        if (this.atrule.hasOwnProperty(nameLowerCase)) {\n\t            if (typeof this.atrule[nameLowerCase].block === 'function') {\n\t                if (this.scanner.tokenType !== LEFTCURLYBRACKET$2) {\n\t                    // FIXME: make tolerant\n\t                    this.scanner.error('Curly bracket is expected');\n\t                }\n\n\t                block = this.atrule[nameLowerCase].block.call(this);\n\t            } else {\n\t                if (!this.tolerant || !this.scanner.eof) {\n\t                    this.scanner.eat(SEMICOLON$1);\n\t                }\n\t            }\n\t        } else {\n\t            switch (this.scanner.tokenType) {\n\t                case SEMICOLON$1:\n\t                    this.scanner.next();\n\t                    break;\n\n\t                case LEFTCURLYBRACKET$2:\n\t                    // TODO: should consume block content as Raw?\n\t                    block = this.Block(isBlockAtrule.call(this) ? this.Declaration : this.Rule);\n\t                    break;\n\n\t                default:\n\t                    if (!this.tolerant) {\n\t                        this.scanner.error('Semicolon or block is expected');\n\t                    }\n\t            }\n\t        }\n\n\t        return {\n\t            type: 'Atrule',\n\t            loc: this.getLocation(start, this.scanner.tokenStart),\n\t            name: name,\n\t            expression: expression,\n\t            block: block\n\t        };\n\t    },\n\t    generate: function(processChunk, node) {\n\t        processChunk('@');\n\t        processChunk(node.name);\n\n\t        if (node.expression !== null) {\n\t            processChunk(' ');\n\t            this.generate(processChunk, node.expression);\n\t        }\n\n\t        if (node.block) {\n\t            this.generate(processChunk, node.block);\n\t        } else {\n\t            processChunk(';');\n\t        }\n\t    },\n\t    walkContext: 'atrule'\n\t};\n\n\tvar TYPE$c = tokenizer.TYPE;\n\tvar SEMICOLON$2 = TYPE$c.Semicolon;\n\tvar LEFTCURLYBRACKET$3 = TYPE$c.LeftCurlyBracket;\n\n\tfunction consumeRaw$1(startToken) {\n\t    return new list().appendData(\n\t        this.Raw(startToken, SEMICOLON$2, LEFTCURLYBRACKET$3, false, true)\n\t    );\n\t}\n\n\tfunction consumeDefaultSequence() {\n\t    return this.readSequence(this.scope.AtruleExpression);\n\t}\n\n\tvar AtruleExpression = {\n\t    name: 'AtruleExpression',\n\t    structure: {\n\t        children: [[]]\n\t    },\n\t    parse: function(name) {\n\t        var children = null;\n\t        var startToken = this.scanner.currentToken;\n\n\t        if (name !== null) {\n\t            name = name.toLowerCase();\n\t        }\n\n\t        if (this.parseAtruleExpression) {\n\t            // custom consumer\n\t            if (this.atrule.hasOwnProperty(name)) {\n\t                if (typeof this.atrule[name].expression === 'function') {\n\t                    children = this.tolerantParse(this.atrule[name].expression, consumeRaw$1);\n\t                }\n\t            } else {\n\t                // default consumer\n\t                this.scanner.skipSC();\n\t                children = this.tolerantParse(consumeDefaultSequence, consumeRaw$1);\n\t            }\n\n\t            if (this.tolerant) {\n\t                if (this.scanner.eof || (this.scanner.tokenType !== SEMICOLON$2 && this.scanner.tokenType !== LEFTCURLYBRACKET$3)) {\n\t                    children = consumeRaw$1.call(this, startToken);\n\t                }\n\t            }\n\t        } else {\n\t            children = consumeRaw$1.call(this, startToken);\n\t        }\n\n\t        if (children === null) {\n\t            children = new list();\n\t        }\n\n\t        return {\n\t            type: 'AtruleExpression',\n\t            loc: this.getLocationFromList(children),\n\t            children: children\n\t        };\n\t    },\n\t    generate: function(processChunk, node) {\n\t        this.each(processChunk, node);\n\t    },\n\t    walkContext: 'atruleExpression'\n\t};\n\n\tvar TYPE$d = tokenizer.TYPE;\n\n\tvar IDENTIFIER$8 = TYPE$d.Identifier;\n\tvar STRING$4 = TYPE$d.String;\n\tvar DOLLARSIGN = TYPE$d.DollarSign;\n\tvar ASTERISK$2 = TYPE$d.Asterisk;\n\tvar COLON$2 = TYPE$d.Colon;\n\tvar EQUALSSIGN = TYPE$d.EqualsSign;\n\tvar LEFTSQUAREBRACKET$3 = TYPE$d.LeftSquareBracket;\n\tvar RIGHTSQUAREBRACKET$1 = TYPE$d.RightSquareBracket;\n\tvar CIRCUMFLEXACCENT = TYPE$d.CircumflexAccent;\n\tvar VERTICALLINE$1 = TYPE$d.VerticalLine;\n\tvar TILDE$1 = TYPE$d.Tilde;\n\n\tfunction getAttributeName() {\n\t    if (this.scanner.eof) {\n\t        this.scanner.error('Unexpected end of input');\n\t    }\n\n\t    var start = this.scanner.tokenStart;\n\t    var expectIdentifier = false;\n\t    var checkColon = true;\n\n\t    if (this.scanner.tokenType === ASTERISK$2) {\n\t        expectIdentifier = true;\n\t        checkColon = false;\n\t        this.scanner.next();\n\t    } else if (this.scanner.tokenType !== VERTICALLINE$1) {\n\t        this.scanner.eat(IDENTIFIER$8);\n\t    }\n\n\t    if (this.scanner.tokenType === VERTICALLINE$1) {\n\t        if (this.scanner.lookupType(1) !== EQUALSSIGN) {\n\t            this.scanner.next();\n\t            this.scanner.eat(IDENTIFIER$8);\n\t        } else if (expectIdentifier) {\n\t            this.scanner.error('Identifier is expected', this.scanner.tokenEnd);\n\t        }\n\t    } else if (expectIdentifier) {\n\t        this.scanner.error('Vertical line is expected');\n\t    }\n\n\t    if (checkColon && this.scanner.tokenType === COLON$2) {\n\t        this.scanner.next();\n\t        this.scanner.eat(IDENTIFIER$8);\n\t    }\n\n\t    return {\n\t        type: 'Identifier',\n\t        loc: this.getLocation(start, this.scanner.tokenStart),\n\t        name: this.scanner.substrToCursor(start)\n\t    };\n\t}\n\n\tfunction getOperator() {\n\t    var start = this.scanner.tokenStart;\n\t    var tokenType = this.scanner.tokenType;\n\n\t    if (tokenType !== EQUALSSIGN &&        // =\n\t        tokenType !== TILDE$1 &&             // ~=\n\t        tokenType !== CIRCUMFLEXACCENT &&  // ^=\n\t        tokenType !== DOLLARSIGN &&        // $=\n\t        tokenType !== ASTERISK$2 &&          // *=\n\t        tokenType !== VERTICALLINE$1         // |=\n\t    ) {\n\t        this.scanner.error('Attribute selector (=, ~=, ^=, $=, *=, |=) is expected');\n\t    }\n\n\t    if (tokenType === EQUALSSIGN) {\n\t        this.scanner.next();\n\t    } else {\n\t        this.scanner.next();\n\t        this.scanner.eat(EQUALSSIGN);\n\t    }\n\n\t    return this.scanner.substrToCursor(start);\n\t}\n\n\t// '[' S* attrib_name ']'\n\t// '[' S* attrib_name S* attrib_matcher S* [ IDENT | STRING ] S* attrib_flags? S* ']'\n\tvar AttributeSelector = {\n\t    name: 'AttributeSelector',\n\t    structure: {\n\t        name: 'Identifier',\n\t        matcher: [String, null],\n\t        value: ['String', 'Identifier', null],\n\t        flags: [String, null]\n\t    },\n\t    parse: function() {\n\t        var start = this.scanner.tokenStart;\n\t        var name;\n\t        var matcher = null;\n\t        var value = null;\n\t        var flags = null;\n\n\t        this.scanner.eat(LEFTSQUAREBRACKET$3);\n\t        this.scanner.skipSC();\n\n\t        name = getAttributeName.call(this);\n\t        this.scanner.skipSC();\n\n\t        if (this.scanner.tokenType !== RIGHTSQUAREBRACKET$1) {\n\t            // avoid case `[name i]`\n\t            if (this.scanner.tokenType !== IDENTIFIER$8) {\n\t                matcher = getOperator.call(this);\n\n\t                this.scanner.skipSC();\n\n\t                value = this.scanner.tokenType === STRING$4\n\t                    ? this.String()\n\t                    : this.Identifier();\n\n\t                this.scanner.skipSC();\n\t            }\n\n\t            // attribute flags\n\t            if (this.scanner.tokenType === IDENTIFIER$8) {\n\t                flags = this.scanner.getTokenValue();\n\t                this.scanner.next();\n\n\t                this.scanner.skipSC();\n\t            }\n\t        }\n\n\t        this.scanner.eat(RIGHTSQUAREBRACKET$1);\n\n\t        return {\n\t            type: 'AttributeSelector',\n\t            loc: this.getLocation(start, this.scanner.tokenStart),\n\t            name: name,\n\t            matcher: matcher,\n\t            value: value,\n\t            flags: flags\n\t        };\n\t    },\n\t    generate: function(processChunk, node) {\n\t        var flagsPrefix = ' ';\n\n\t        processChunk('[');\n\t        this.generate(processChunk, node.name);\n\n\t        if (node.matcher !== null) {\n\t            processChunk(node.matcher);\n\n\t            if (node.value !== null) {\n\t                this.generate(processChunk, node.value);\n\n\t                // space between string and flags is not required\n\t                if (node.value.type === 'String') {\n\t                    flagsPrefix = '';\n\t                }\n\t            }\n\t        }\n\n\t        if (node.flags !== null) {\n\t            processChunk(flagsPrefix);\n\t            processChunk(node.flags);\n\t        }\n\n\t        processChunk(']');\n\t    }\n\t};\n\n\tvar TYPE$e = tokenizer.TYPE;\n\n\tvar WHITESPACE$4 = TYPE$e.WhiteSpace;\n\tvar COMMENT$4 = TYPE$e.Comment;\n\tvar SEMICOLON$3 = TYPE$e.Semicolon;\n\tvar ATRULE$3 = TYPE$e.Atrule;\n\tvar LEFTCURLYBRACKET$4 = TYPE$e.LeftCurlyBracket;\n\tvar RIGHTCURLYBRACKET$2 = TYPE$e.RightCurlyBracket;\n\n\tfunction consumeRaw$2(startToken) {\n\t    return this.Raw(startToken, 0, SEMICOLON$3, true, true);\n\t}\n\n\tvar Block = {\n\t    name: 'Block',\n\t    structure: {\n\t        children: [['Atrule', 'Rule', 'Declaration']]\n\t    },\n\t    parse: function(defaultConsumer) {\n\t        if (!defaultConsumer) {\n\t            defaultConsumer = this.Declaration;\n\t        }\n\n\t        var start = this.scanner.tokenStart;\n\t        var children = new list();\n\n\t        this.scanner.eat(LEFTCURLYBRACKET$4);\n\n\t        scan:\n\t        while (!this.scanner.eof) {\n\t            switch (this.scanner.tokenType) {\n\t                case RIGHTCURLYBRACKET$2:\n\t                    break scan;\n\n\t                case WHITESPACE$4:\n\t                case COMMENT$4:\n\t                case SEMICOLON$3:\n\t                    this.scanner.next();\n\t                    break;\n\n\t                case ATRULE$3:\n\t                    children.appendData(this.tolerantParse(this.Atrule, consumeRaw$2));\n\t                    break;\n\n\t                default:\n\t                    children.appendData(this.tolerantParse(defaultConsumer, consumeRaw$2));\n\t            }\n\t        }\n\n\t        if (!this.tolerant || !this.scanner.eof) {\n\t            this.scanner.eat(RIGHTCURLYBRACKET$2);\n\t        }\n\n\t        return {\n\t            type: 'Block',\n\t            loc: this.getLocation(start, this.scanner.tokenStart),\n\t            children: children\n\t        };\n\t    },\n\t    generate: function(processChunk, node) {\n\t        processChunk('{');\n\t        this.each(processChunk, node);\n\t        processChunk('}');\n\t    },\n\t    walkContext: 'block'\n\t};\n\n\tvar TYPE$f = tokenizer.TYPE;\n\tvar LEFTSQUAREBRACKET$4 = TYPE$f.LeftSquareBracket;\n\tvar RIGHTSQUAREBRACKET$2 = TYPE$f.RightSquareBracket;\n\n\t// currently only Grid Layout uses square brackets, but left it universal\n\t// https://drafts.csswg.org/css-grid/#track-sizing\n\t// [ ident* ]\n\tvar Brackets = {\n\t    name: 'Brackets',\n\t    structure: {\n\t        children: [[]]\n\t    },\n\t    parse: function(readSequence, recognizer) {\n\t        var start = this.scanner.tokenStart;\n\t        var children = null;\n\n\t        this.scanner.eat(LEFTSQUAREBRACKET$4);\n\t        children = readSequence.call(this, recognizer);\n\t        this.scanner.eat(RIGHTSQUAREBRACKET$2);\n\n\t        return {\n\t            type: 'Brackets',\n\t            loc: this.getLocation(start, this.scanner.tokenStart),\n\t            children: children\n\t        };\n\t    },\n\t    generate: function(processChunk, node) {\n\t        processChunk('[');\n\t        this.each(processChunk, node);\n\t        processChunk(']');\n\t    }\n\t};\n\n\tvar CDC$2 = tokenizer.TYPE.CDC;\n\n\tvar CDC_1 = {\n\t    name: 'CDC',\n\t    structure: [],\n\t    parse: function() {\n\t        var start = this.scanner.tokenStart;\n\n\t        this.scanner.eat(CDC$2); // -->\n\n\t        return {\n\t            type: 'CDC',\n\t            loc: this.getLocation(start, this.scanner.tokenStart)\n\t        };\n\t    },\n\t    generate: function(processChunk) {\n\t        processChunk('-->');\n\t    }\n\t};\n\n\tvar CDO$2 = tokenizer.TYPE.CDO;\n\n\tvar CDO_1 = {\n\t    name: 'CDO',\n\t    structure: [],\n\t    parse: function() {\n\t        var start = this.scanner.tokenStart;\n\n\t        this.scanner.eat(CDO$2); // <!--\n\n\t        return {\n\t            type: 'CDO',\n\t            loc: this.getLocation(start, this.scanner.tokenStart)\n\t        };\n\t    },\n\t    generate: function(processChunk) {\n\t        processChunk('<!--');\n\t    }\n\t};\n\n\tvar TYPE$g = tokenizer.TYPE;\n\tvar IDENTIFIER$9 = TYPE$g.Identifier;\n\tvar FULLSTOP$3 = TYPE$g.FullStop;\n\n\t// '.' ident\n\tvar ClassSelector = {\n\t    name: 'ClassSelector',\n\t    structure: {\n\t        name: String\n\t    },\n\t    parse: function() {\n\t        this.scanner.eat(FULLSTOP$3);\n\n\t        return {\n\t            type: 'ClassSelector',\n\t            loc: this.getLocation(this.scanner.tokenStart - 1, this.scanner.tokenEnd),\n\t            name: this.scanner.consume(IDENTIFIER$9)\n\t        };\n\t    },\n\t    generate: function(processChunk, node) {\n\t        processChunk('.');\n\t        processChunk(node.name);\n\t    }\n\t};\n\n\tvar TYPE$h = tokenizer.TYPE;\n\n\tvar PLUSSIGN$5 = TYPE$h.PlusSign;\n\tvar SOLIDUS$2 = TYPE$h.Solidus;\n\tvar GREATERTHANSIGN$2 = TYPE$h.GreaterThanSign;\n\tvar TILDE$2 = TYPE$h.Tilde;\n\n\t// + | > | ~ | /deep/\n\tvar Combinator = {\n\t    name: 'Combinator',\n\t    structure: {\n\t        name: String\n\t    },\n\t    parse: function() {\n\t        var start = this.scanner.tokenStart;\n\n\t        switch (this.scanner.tokenType) {\n\t            case GREATERTHANSIGN$2:\n\t            case PLUSSIGN$5:\n\t            case TILDE$2:\n\t                this.scanner.next();\n\t                break;\n\n\t            case SOLIDUS$2:\n\t                this.scanner.next();\n\t                this.scanner.expectIdentifier('deep');\n\t                this.scanner.eat(SOLIDUS$2);\n\t                break;\n\n\t            default:\n\t                this.scanner.error('Combinator is expected');\n\t        }\n\n\t        return {\n\t            type: 'Combinator',\n\t            loc: this.getLocation(start, this.scanner.tokenStart),\n\t            name: this.scanner.substrToCursor(start)\n\t        };\n\t    },\n\t    generate: function(processChunk, node) {\n\t        processChunk(node.name);\n\t    }\n\t};\n\n\tvar TYPE$i = tokenizer.TYPE;\n\n\tvar ASTERISK$3 = TYPE$i.Asterisk;\n\tvar SOLIDUS$3 = TYPE$i.Solidus;\n\n\t// '/*' .* '*/'\n\tvar Comment = {\n\t    name: 'Comment',\n\t    structure: {\n\t        value: String\n\t    },\n\t    parse: function() {\n\t        var start = this.scanner.tokenStart;\n\t        var end = this.scanner.tokenEnd;\n\n\t        if ((end - start + 2) >= 2 &&\n\t            this.scanner.source.charCodeAt(end - 2) === ASTERISK$3 &&\n\t            this.scanner.source.charCodeAt(end - 1) === SOLIDUS$3) {\n\t            end -= 2;\n\t        }\n\n\t        this.scanner.next();\n\n\t        return {\n\t            type: 'Comment',\n\t            loc: this.getLocation(start, this.scanner.tokenStart),\n\t            value: this.scanner.source.substring(start + 2, end)\n\t        };\n\t    },\n\t    generate: function(processChunk, node) {\n\t        processChunk('/*');\n\t        processChunk(node.value);\n\t        processChunk('*/');\n\t    }\n\t};\n\n\tvar TYPE$j = tokenizer.TYPE;\n\n\tvar IDENTIFIER$a = TYPE$j.Identifier;\n\tvar COLON$3 = TYPE$j.Colon;\n\tvar EXCLAMATIONMARK$2 = TYPE$j.ExclamationMark;\n\tvar SOLIDUS$4 = TYPE$j.Solidus;\n\tvar ASTERISK$4 = TYPE$j.Asterisk;\n\tvar DOLLARSIGN$1 = TYPE$j.DollarSign;\n\tvar HYPHENMINUS$6 = TYPE$j.HyphenMinus;\n\tvar SEMICOLON$4 = TYPE$j.Semicolon;\n\tvar RIGHTCURLYBRACKET$3 = TYPE$j.RightCurlyBracket;\n\tvar RIGHTPARENTHESIS$1 = TYPE$j.RightParenthesis;\n\tvar PLUSSIGN$6 = TYPE$j.PlusSign;\n\tvar NUMBERSIGN$2 = TYPE$j.NumberSign;\n\n\tvar Declaration = {\n\t    name: 'Declaration',\n\t    structure: {\n\t        important: [Boolean, String],\n\t        property: String,\n\t        value: ['Value', 'Raw']\n\t    },\n\t    parse: function() {\n\t        var start = this.scanner.tokenStart;\n\t        var property = readProperty.call(this);\n\t        var important = false;\n\t        var value;\n\n\t        this.scanner.skipSC();\n\t        this.scanner.eat(COLON$3);\n\n\t        if (isCustomProperty(property) ? this.parseCustomProperty : this.parseValue) {\n\t            value = this.Value(property);\n\t        } else {\n\t            value = this.Raw(this.scanner.currentToken, EXCLAMATIONMARK$2, SEMICOLON$4, false, false);\n\t        }\n\n\t        if (this.scanner.tokenType === EXCLAMATIONMARK$2) {\n\t            important = getImportant(this.scanner);\n\t            this.scanner.skipSC();\n\t        }\n\n\t        // TODO: include or not to include semicolon to range?\n\t        // if (this.scanner.tokenType === SEMICOLON) {\n\t        //     this.scanner.next();\n\t        // }\n\n\t        if (!this.scanner.eof &&\n\t            this.scanner.tokenType !== SEMICOLON$4 &&\n\t            this.scanner.tokenType !== RIGHTPARENTHESIS$1 &&\n\t            this.scanner.tokenType !== RIGHTCURLYBRACKET$3) {\n\t            this.scanner.error();\n\t        }\n\n\t        return {\n\t            type: 'Declaration',\n\t            loc: this.getLocation(start, this.scanner.tokenStart),\n\t            important: important,\n\t            property: property,\n\t            value: value\n\t        };\n\t    },\n\t    generate: function(processChunk, node, item) {\n\t        processChunk(node.property);\n\t        processChunk(':');\n\t        this.generate(processChunk, node.value);\n\n\t        if (node.important) {\n\t            processChunk(node.important === true ? '!important' : '!' + node.important);\n\t        }\n\n\t        if (item && item.next) {\n\t            processChunk(';');\n\t        }\n\t    },\n\t    walkContext: 'declaration'\n\t};\n\n\tfunction isCustomProperty(name) {\n\t    return name.length >= 2 &&\n\t           name.charCodeAt(0) === HYPHENMINUS$6 &&\n\t           name.charCodeAt(1) === HYPHENMINUS$6;\n\t}\n\n\tfunction readProperty() {\n\t    var start = this.scanner.tokenStart;\n\t    var prefix = 0;\n\n\t    // hacks\n\t    switch (this.scanner.tokenType) {\n\t        case ASTERISK$4:\n\t        case DOLLARSIGN$1:\n\t        case PLUSSIGN$6:\n\t        case NUMBERSIGN$2:\n\t            prefix = 1;\n\t            break;\n\n\t        // TODO: not sure we should support this hack\n\t        case SOLIDUS$4:\n\t            prefix = this.scanner.lookupType(1) === SOLIDUS$4 ? 2 : 1;\n\t            break;\n\t    }\n\n\t    if (this.scanner.lookupType(prefix) === HYPHENMINUS$6) {\n\t        prefix++;\n\t    }\n\n\t    if (prefix) {\n\t        this.scanner.skip(prefix);\n\t    }\n\n\t    this.scanner.eat(IDENTIFIER$a);\n\n\t    return this.scanner.substrToCursor(start);\n\t}\n\n\t// ! ws* important\n\tfunction getImportant(scanner) {\n\t    scanner.eat(EXCLAMATIONMARK$2);\n\t    scanner.skipSC();\n\n\t    var important = scanner.consume(IDENTIFIER$a);\n\n\t    // store original value in case it differ from `important`\n\t    // for better original source restoring and hacks like `!ie` support\n\t    return important === 'important' ? true : important;\n\t}\n\n\tvar TYPE$k = tokenizer.TYPE;\n\n\tvar WHITESPACE$5 = TYPE$k.WhiteSpace;\n\tvar COMMENT$5 = TYPE$k.Comment;\n\tvar SEMICOLON$5 = TYPE$k.Semicolon;\n\n\tfunction consumeRaw$3(startToken) {\n\t    return this.Raw(startToken, 0, SEMICOLON$5, true, true);\n\t}\n\n\tvar DeclarationList = {\n\t    name: 'DeclarationList',\n\t    structure: {\n\t        children: [['Declaration']]\n\t    },\n\t    parse: function() {\n\t        var children = new list();\n\n\t        \n\t        while (!this.scanner.eof) {\n\t            switch (this.scanner.tokenType) {\n\t                case WHITESPACE$5:\n\t                case COMMENT$5:\n\t                case SEMICOLON$5:\n\t                    this.scanner.next();\n\t                    break;\n\n\t                default:\n\t                    children.appendData(this.tolerantParse(this.Declaration, consumeRaw$3));\n\t            }\n\t        }\n\n\t        return {\n\t            type: 'DeclarationList',\n\t            loc: this.getLocationFromList(children),\n\t            children: children\n\t        };\n\t    },\n\t    generate: function(processChunk, node) {\n\t        this.each(processChunk, node);\n\t    }\n\t};\n\n\tvar NUMBER$5 = tokenizer.TYPE.Number;\n\n\t// special reader for units to avoid adjoined IE hacks (i.e. '1px\\9')\n\tfunction readUnit(scanner) {\n\t    var unit = scanner.getTokenValue();\n\t    var backSlashPos = unit.indexOf('\\\\');\n\n\t    if (backSlashPos > 0) {\n\t        // patch token offset\n\t        scanner.tokenStart += backSlashPos;\n\n\t        // return part before backslash\n\t        return unit.substring(0, backSlashPos);\n\t    }\n\n\t    // no backslash in unit name\n\t    scanner.next();\n\n\t    return unit;\n\t}\n\n\t// number ident\n\tvar Dimension = {\n\t    name: 'Dimension',\n\t    structure: {\n\t        value: String,\n\t        unit: String\n\t    },\n\t    parse: function() {\n\t        var start = this.scanner.tokenStart;\n\t        var value = this.scanner.consume(NUMBER$5);\n\t        var unit = readUnit(this.scanner);\n\n\t        return {\n\t            type: 'Dimension',\n\t            loc: this.getLocation(start, this.scanner.tokenStart),\n\t            value: value,\n\t            unit: unit\n\t        };\n\t    },\n\t    generate: function(processChunk, node) {\n\t        processChunk(node.value);\n\t        processChunk(node.unit);\n\t    }\n\t};\n\n\tvar TYPE$l = tokenizer.TYPE;\n\tvar RIGHTPARENTHESIS$2 = TYPE$l.RightParenthesis;\n\n\t// <function-token> <sequence> ')'\n\tvar _Function = {\n\t    name: 'Function',\n\t    structure: {\n\t        name: String,\n\t        children: [[]]\n\t    },\n\t    parse: function(readSequence, recognizer) {\n\t        var start = this.scanner.tokenStart;\n\t        var name = this.scanner.consumeFunctionName();\n\t        var nameLowerCase = name.toLowerCase();\n\t        var children;\n\n\t        children = recognizer.hasOwnProperty(nameLowerCase)\n\t            ? recognizer[nameLowerCase].call(this, recognizer)\n\t            : readSequence.call(this, recognizer);\n\n\t        this.scanner.eat(RIGHTPARENTHESIS$2);\n\n\t        return {\n\t            type: 'Function',\n\t            loc: this.getLocation(start, this.scanner.tokenStart),\n\t            name: name,\n\t            children: children\n\t        };\n\t    },\n\t    generate: function(processChunk, node) {\n\t        processChunk(node.name);\n\t        processChunk('(');\n\t        this.each(processChunk, node);\n\t        processChunk(')');\n\t    },\n\t    walkContext: 'function'\n\t};\n\n\tvar isHex$1 = tokenizer.isHex;\n\tvar TYPE$m = tokenizer.TYPE;\n\n\tvar IDENTIFIER$b = TYPE$m.Identifier;\n\tvar NUMBER$6 = TYPE$m.Number;\n\tvar NUMBERSIGN$3 = TYPE$m.NumberSign;\n\n\tfunction consumeHexSequence(scanner, required) {\n\t    if (!isHex$1(scanner.source.charCodeAt(scanner.tokenStart))) {\n\t        if (required) {\n\t            scanner.error('Unexpected input', scanner.tokenStart);\n\t        } else {\n\t            return;\n\t        }\n\t    }\n\n\t    for (var pos = scanner.tokenStart + 1; pos < scanner.tokenEnd; pos++) {\n\t        var code = scanner.source.charCodeAt(pos);\n\n\t        // break on non-hex char\n\t        if (!isHex$1(code)) {\n\t            // break token, exclude symbol\n\t            scanner.tokenStart = pos;\n\t            return;\n\t        }\n\t    }\n\n\t    // token is full hex sequence, go to next token\n\t    scanner.next();\n\t}\n\n\t// # ident\n\tvar HexColor = {\n\t    name: 'HexColor',\n\t    structure: {\n\t        value: String\n\t    },\n\t    parse: function() {\n\t        var start = this.scanner.tokenStart;\n\n\t        this.scanner.eat(NUMBERSIGN$3);\n\n\t        \n\t        switch (this.scanner.tokenType) {\n\t            case NUMBER$6:\n\t                consumeHexSequence(this.scanner, true);\n\n\t                // if token is identifier then number consists of hex only,\n\t                // try to add identifier to result\n\t                if (this.scanner.tokenType === IDENTIFIER$b) {\n\t                    consumeHexSequence(this.scanner, false);\n\t                }\n\n\t                break;\n\n\t            case IDENTIFIER$b:\n\t                consumeHexSequence(this.scanner, true);\n\t                break;\n\n\t            default:\n\t                this.scanner.error('Number or identifier is expected');\n\t        }\n\n\t        return {\n\t            type: 'HexColor',\n\t            loc: this.getLocation(start, this.scanner.tokenStart),\n\t            value: this.scanner.substrToCursor(start + 1) // skip #\n\t        };\n\t    },\n\t    generate: function(processChunk, node) {\n\t        processChunk('#');\n\t        processChunk(node.value);\n\t    }\n\t};\n\n\tvar TYPE$n = tokenizer.TYPE;\n\tvar IDENTIFIER$c = TYPE$n.Identifier;\n\n\tvar Identifier = {\n\t    name: 'Identifier',\n\t    structure: {\n\t        name: String\n\t    },\n\t    parse: function() {\n\t        return {\n\t            type: 'Identifier',\n\t            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),\n\t            name: this.scanner.consume(IDENTIFIER$c)\n\t        };\n\t    },\n\t    generate: function(processChunk, node) {\n\t        processChunk(node.name);\n\t    }\n\t};\n\n\tvar TYPE$o = tokenizer.TYPE;\n\tvar IDENTIFIER$d = TYPE$o.Identifier;\n\tvar NUMBERSIGN$4 = TYPE$o.NumberSign;\n\n\t// '#' ident\n\tvar IdSelector = {\n\t    name: 'IdSelector',\n\t    structure: {\n\t        name: String\n\t    },\n\t    parse: function() {\n\t        this.scanner.eat(NUMBERSIGN$4);\n\n\t        return {\n\t            type: 'IdSelector',\n\t            loc: this.getLocation(this.scanner.tokenStart - 1, this.scanner.tokenEnd),\n\t            name: this.scanner.consume(IDENTIFIER$d)\n\t        };\n\t    },\n\t    generate: function(processChunk, node) {\n\t        processChunk('#');\n\t        processChunk(node.name);\n\t    }\n\t};\n\n\tvar TYPE$p = tokenizer.TYPE;\n\n\tvar IDENTIFIER$e = TYPE$p.Identifier;\n\tvar NUMBER$7 = TYPE$p.Number;\n\tvar LEFTPARENTHESIS$4 = TYPE$p.LeftParenthesis;\n\tvar RIGHTPARENTHESIS$3 = TYPE$p.RightParenthesis;\n\tvar COLON$4 = TYPE$p.Colon;\n\tvar SOLIDUS$5 = TYPE$p.Solidus;\n\n\tvar MediaFeature = {\n\t    name: 'MediaFeature',\n\t    structure: {\n\t        name: String,\n\t        value: ['Identifier', 'Number', 'Dimension', 'Ratio', null]\n\t    },\n\t    parse: function() {\n\t        var start = this.scanner.tokenStart;\n\t        var name;\n\t        var value = null;\n\n\t        this.scanner.eat(LEFTPARENTHESIS$4);\n\t        this.scanner.skipSC();\n\n\t        name = this.scanner.consume(IDENTIFIER$e);\n\t        this.scanner.skipSC();\n\n\t        if (this.scanner.tokenType !== RIGHTPARENTHESIS$3) {\n\t            this.scanner.eat(COLON$4);\n\t            this.scanner.skipSC();\n\n\t            switch (this.scanner.tokenType) {\n\t                case NUMBER$7:\n\t                    if (this.scanner.lookupType(1) === IDENTIFIER$e) {\n\t                        value = this.Dimension();\n\t                    } else if (this.scanner.lookupNonWSType(1) === SOLIDUS$5) {\n\t                        value = this.Ratio();\n\t                    } else {\n\t                        value = this.Number();\n\t                    }\n\n\t                    break;\n\n\t                case IDENTIFIER$e:\n\t                    value = this.Identifier();\n\n\t                    break;\n\n\t                default:\n\t                    this.scanner.error('Number, dimension, ratio or identifier is expected');\n\t            }\n\n\t            this.scanner.skipSC();\n\t        }\n\n\t        this.scanner.eat(RIGHTPARENTHESIS$3);\n\n\t        return {\n\t            type: 'MediaFeature',\n\t            loc: this.getLocation(start, this.scanner.tokenStart),\n\t            name: name,\n\t            value: value\n\t        };\n\t    },\n\t    generate: function(processChunk, node) {\n\t        processChunk('(');\n\t        processChunk(node.name);\n\t        if (node.value !== null) {\n\t            processChunk(':');\n\t            this.generate(processChunk, node.value);\n\t        }\n\t        processChunk(')');\n\t    }\n\t};\n\n\tvar TYPE$q = tokenizer.TYPE;\n\n\tvar WHITESPACE$6 = TYPE$q.WhiteSpace;\n\tvar COMMENT$6 = TYPE$q.Comment;\n\tvar IDENTIFIER$f = TYPE$q.Identifier;\n\tvar LEFTPARENTHESIS$5 = TYPE$q.LeftParenthesis;\n\n\tvar MediaQuery = {\n\t    name: 'MediaQuery',\n\t    structure: {\n\t        children: [['Identifier', 'MediaFeature', 'WhiteSpace']]\n\t    },\n\t    parse: function() {\n\t        this.scanner.skipSC();\n\n\t        var children = new list();\n\t        var child = null;\n\t        var space = null;\n\n\t        scan:\n\t        while (!this.scanner.eof) {\n\t            switch (this.scanner.tokenType) {\n\t                case COMMENT$6:\n\t                    this.scanner.next();\n\t                    continue;\n\n\t                case WHITESPACE$6:\n\t                    space = this.WhiteSpace();\n\t                    continue;\n\n\t                case IDENTIFIER$f:\n\t                    child = this.Identifier();\n\t                    break;\n\n\t                case LEFTPARENTHESIS$5:\n\t                    child = this.MediaFeature();\n\t                    break;\n\n\t                default:\n\t                    break scan;\n\t            }\n\n\t            if (space !== null) {\n\t                children.appendData(space);\n\t                space = null;\n\t            }\n\n\t            children.appendData(child);\n\t        }\n\n\t        if (child === null) {\n\t            this.scanner.error('Identifier or parenthesis is expected');\n\t        }\n\n\t        return {\n\t            type: 'MediaQuery',\n\t            loc: this.getLocationFromList(children),\n\t            children: children\n\t        };\n\t    },\n\t    generate: function(processChunk, node) {\n\t        this.each(processChunk, node);\n\t    }\n\t};\n\n\tvar COMMA$2 = tokenizer.TYPE.Comma;\n\n\tvar MediaQueryList = {\n\t    name: 'MediaQueryList',\n\t    structure: {\n\t        children: [['MediaQuery']]\n\t    },\n\t    parse: function(relative) {\n\t        var children = new list();\n\n\t        this.scanner.skipSC();\n\n\t        while (!this.scanner.eof) {\n\t            children.appendData(this.MediaQuery(relative));\n\n\t            if (this.scanner.tokenType !== COMMA$2) {\n\t                break;\n\t            }\n\n\t            this.scanner.next();\n\t        }\n\n\t        return {\n\t            type: 'MediaQueryList',\n\t            loc: this.getLocationFromList(children),\n\t            children: children\n\t        };\n\t    },\n\t    generate: function(processChunk, node) {\n\t        this.eachComma(processChunk, node);\n\t    }\n\t};\n\n\t// https://drafts.csswg.org/css-syntax-3/#the-anb-type\n\tvar Nth = {\n\t    name: 'Nth',\n\t    structure: {\n\t        nth: ['AnPlusB', 'Identifier'],\n\t        selector: ['SelectorList', null]\n\t    },\n\t    parse: function(allowOfClause) {\n\t        this.scanner.skipSC();\n\n\t        var start = this.scanner.tokenStart;\n\t        var end = start;\n\t        var selector = null;\n\t        var query;\n\n\t        if (this.scanner.lookupValue(0, 'odd') || this.scanner.lookupValue(0, 'even')) {\n\t            query = this.Identifier();\n\t        } else {\n\t            query = this.AnPlusB();\n\t        }\n\n\t        this.scanner.skipSC();\n\n\t        if (allowOfClause && this.scanner.lookupValue(0, 'of')) {\n\t            this.scanner.next();\n\n\t            selector = this.SelectorList();\n\n\t            if (this.needPositions) {\n\t                end = selector.children.last().loc.end.offset;\n\t            }\n\t        } else {\n\t            if (this.needPositions) {\n\t                end = query.loc.end.offset;\n\t            }\n\t        }\n\n\t        return {\n\t            type: 'Nth',\n\t            loc: this.getLocation(start, end),\n\t            nth: query,\n\t            selector: selector\n\t        };\n\t    },\n\t    generate: function(processChunk, node) {\n\t        this.generate(processChunk, node.nth);\n\t        if (node.selector !== null) {\n\t            processChunk(' of ');\n\t            this.generate(processChunk, node.selector);\n\t        }\n\t    }\n\t};\n\n\tvar NUMBER$8 = tokenizer.TYPE.Number;\n\n\tvar _Number = {\n\t    name: 'Number',\n\t    structure: {\n\t        value: String\n\t    },\n\t    parse: function() {\n\t        return {\n\t            type: 'Number',\n\t            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),\n\t            value: this.scanner.consume(NUMBER$8)\n\t        };\n\t    },\n\t    generate: function(processChunk, node) {\n\t        processChunk(node.value);\n\t    }\n\t};\n\n\t// '/' | '*' | ',' | ':' | '+' | '-'\n\tvar Operator = {\n\t    name: 'Operator',\n\t    structure: {\n\t        value: String\n\t    },\n\t    parse: function() {\n\t        var start = this.scanner.tokenStart;\n\n\t        this.scanner.next();\n\n\t        return {\n\t            type: 'Operator',\n\t            loc: this.getLocation(start, this.scanner.tokenStart),\n\t            value: this.scanner.substrToCursor(start)\n\t        };\n\t    },\n\t    generate: function(processChunk, node) {\n\t        processChunk(node.value);\n\t    }\n\t};\n\n\tvar TYPE$r = tokenizer.TYPE;\n\tvar LEFTPARENTHESIS$6 = TYPE$r.LeftParenthesis;\n\tvar RIGHTPARENTHESIS$4 = TYPE$r.RightParenthesis;\n\n\tvar Parentheses = {\n\t    name: 'Parentheses',\n\t    structure: {\n\t        children: [[]]\n\t    },\n\t    parse: function(readSequence, recognizer) {\n\t        var start = this.scanner.tokenStart;\n\t        var children = null;\n\n\t        this.scanner.eat(LEFTPARENTHESIS$6);\n\t        children = readSequence.call(this, recognizer);\n\t        this.scanner.eat(RIGHTPARENTHESIS$4);\n\n\t        return {\n\t            type: 'Parentheses',\n\t            loc: this.getLocation(start, this.scanner.tokenStart),\n\t            children: children\n\t        };\n\t    },\n\t    generate: function(processChunk, node) {\n\t        processChunk('(');\n\t        this.each(processChunk, node);\n\t        processChunk(')');\n\t    }\n\t};\n\n\tvar TYPE$s = tokenizer.TYPE;\n\n\tvar NUMBER$9 = TYPE$s.Number;\n\tvar PERCENTSIGN$1 = TYPE$s.PercentSign;\n\n\tvar Percentage = {\n\t    name: 'Percentage',\n\t    structure: {\n\t        value: String\n\t    },\n\t    parse: function() {\n\t        var start = this.scanner.tokenStart;\n\t        var number = this.scanner.consume(NUMBER$9);\n\n\t        this.scanner.eat(PERCENTSIGN$1);\n\n\t        return {\n\t            type: 'Percentage',\n\t            loc: this.getLocation(start, this.scanner.tokenStart),\n\t            value: number\n\t        };\n\t    },\n\t    generate: function(processChunk, node) {\n\t        processChunk(node.value);\n\t        processChunk('%');\n\t    }\n\t};\n\n\tvar TYPE$t = tokenizer.TYPE;\n\n\tvar IDENTIFIER$g = TYPE$t.Identifier;\n\tvar FUNCTION$4 = TYPE$t.Function;\n\tvar COLON$5 = TYPE$t.Colon;\n\tvar RIGHTPARENTHESIS$5 = TYPE$t.RightParenthesis;\n\n\t// : ident [ '(' .. ')' ]?\n\tvar PseudoClassSelector = {\n\t    name: 'PseudoClassSelector',\n\t    structure: {\n\t        name: String,\n\t        children: [['Raw'], null]\n\t    },\n\t    parse: function() {\n\t        var start = this.scanner.tokenStart;\n\t        var children = null;\n\t        var name;\n\t        var nameLowerCase;\n\n\t        this.scanner.eat(COLON$5);\n\n\t        if (this.scanner.tokenType === FUNCTION$4) {\n\t            name = this.scanner.consumeFunctionName();\n\t            nameLowerCase = name.toLowerCase();\n\n\t            if (this.pseudo.hasOwnProperty(nameLowerCase)) {\n\t                this.scanner.skipSC();\n\t                children = this.pseudo[nameLowerCase].call(this);\n\t                this.scanner.skipSC();\n\t            } else {\n\t                children = new list().appendData(\n\t                    this.Raw(this.scanner.currentToken, 0, 0, false, false)\n\t                );\n\t            }\n\n\t            this.scanner.eat(RIGHTPARENTHESIS$5);\n\t        } else {\n\t            name = this.scanner.consume(IDENTIFIER$g);\n\t        }\n\n\t        return {\n\t            type: 'PseudoClassSelector',\n\t            loc: this.getLocation(start, this.scanner.tokenStart),\n\t            name: name,\n\t            children: children\n\t        };\n\t    },\n\t    generate: function(processChunk, node) {\n\t        processChunk(':');\n\t        processChunk(node.name);\n\n\t        if (node.children !== null) {\n\t            processChunk('(');\n\t            this.each(processChunk, node);\n\t            processChunk(')');\n\t        }\n\t    },\n\t    walkContext: 'function'\n\t};\n\n\tvar TYPE$u = tokenizer.TYPE;\n\n\tvar IDENTIFIER$h = TYPE$u.Identifier;\n\tvar FUNCTION$5 = TYPE$u.Function;\n\tvar COLON$6 = TYPE$u.Colon;\n\tvar RIGHTPARENTHESIS$6 = TYPE$u.RightParenthesis;\n\n\t// :: ident [ '(' .. ')' ]?\n\tvar PseudoElementSelector = {\n\t    name: 'PseudoElementSelector',\n\t    structure: {\n\t        name: String,\n\t        children: [['Raw'], null]\n\t    },\n\t    parse: function() {\n\t        var start = this.scanner.tokenStart;\n\t        var children = null;\n\t        var name;\n\t        var nameLowerCase;\n\n\t        this.scanner.eat(COLON$6);\n\t        this.scanner.eat(COLON$6);\n\n\t        if (this.scanner.tokenType === FUNCTION$5) {\n\t            name = this.scanner.consumeFunctionName();\n\t            nameLowerCase = name.toLowerCase();\n\n\t            if (this.pseudo.hasOwnProperty(nameLowerCase)) {\n\t                this.scanner.skipSC();\n\t                children = this.pseudo[nameLowerCase].call(this);\n\t                this.scanner.skipSC();\n\t            } else {\n\t                children = new list().appendData(\n\t                    this.Raw(this.scanner.currentToken, 0, 0, false, false)\n\t                );\n\t            }\n\n\t            this.scanner.eat(RIGHTPARENTHESIS$6);\n\t        } else {\n\t            name = this.scanner.consume(IDENTIFIER$h);\n\t        }\n\n\t        return {\n\t            type: 'PseudoElementSelector',\n\t            loc: this.getLocation(start, this.scanner.tokenStart),\n\t            name: name,\n\t            children: children\n\t        };\n\t    },\n\t    generate: function(processChunk, node) {\n\t        processChunk('::');\n\t        processChunk(node.name);\n\n\t        if (node.children !== null) {\n\t            processChunk('(');\n\t            this.each(processChunk, node);\n\t            processChunk(')');\n\t        }\n\t    },\n\t    walkContext: 'function'\n\t};\n\n\tvar isNumber$3 = tokenizer.isNumber;\n\tvar TYPE$v = tokenizer.TYPE;\n\tvar NUMBER$a = TYPE$v.Number;\n\tvar SOLIDUS$6 = TYPE$v.Solidus;\n\tvar FULLSTOP$4 = TYPE$v.FullStop;\n\n\t// Terms of <ratio> should to be a positive number (not zero or negative)\n\t// (see https://drafts.csswg.org/mediaqueries-3/#values)\n\t// However, -o-min-device-pixel-ratio takes fractional values as a ratio's term\n\t// and this is using by various sites. Therefore we relax checking on parse\n\t// to test a term is unsigned number without exponent part.\n\t// Additional checks may to be applied on lexer validation.\n\tfunction consumeNumber(scanner) {\n\t    var value = scanner.consumeNonWS(NUMBER$a);\n\n\t    for (var i = 0; i < value.length; i++) {\n\t        var code = value.charCodeAt(i);\n\t        if (!isNumber$3(code) && code !== FULLSTOP$4) {\n\t            scanner.error('Unsigned number is expected', scanner.tokenStart - value.length + i);\n\t        }\n\t    }\n\n\t    if (Number(value) === 0) {\n\t        scanner.error('Zero number is not allowed', scanner.tokenStart - value.length);\n\t    }\n\n\t    return value;\n\t}\n\n\t// <positive-integer> S* '/' S* <positive-integer>\n\tvar Ratio = {\n\t    name: 'Ratio',\n\t    structure: {\n\t        left: String,\n\t        right: String\n\t    },\n\t    parse: function() {\n\t        var start = this.scanner.tokenStart;\n\t        var left = consumeNumber(this.scanner);\n\t        var right;\n\n\t        this.scanner.eatNonWS(SOLIDUS$6);\n\t        right = consumeNumber(this.scanner);\n\n\t        return {\n\t            type: 'Ratio',\n\t            loc: this.getLocation(start, this.scanner.tokenStart),\n\t            left: left,\n\t            right: right\n\t        };\n\t    },\n\t    generate: function(processChunk, node) {\n\t        processChunk(node.left);\n\t        processChunk('/');\n\t        processChunk(node.right);\n\t    }\n\t};\n\n\tvar Raw = {\n\t    name: 'Raw',\n\t    structure: {\n\t        value: String\n\t    },\n\t    parse: function(startToken, endTokenType1, endTokenType2, includeTokenType2, excludeWhiteSpace) {\n\t        var startOffset = this.scanner.getTokenStart(startToken);\n\t        var endOffset;\n\n\t        this.scanner.skip(\n\t            this.scanner.getRawLength(\n\t                startToken,\n\t                endTokenType1,\n\t                endTokenType2,\n\t                includeTokenType2\n\t            )\n\t        );\n\n\t        if (excludeWhiteSpace && this.scanner.tokenStart > startOffset) {\n\t            endOffset = this.scanner.getOffsetExcludeWS();\n\t        } else {\n\t            endOffset = this.scanner.tokenStart;\n\t        }\n\n\t        return {\n\t            type: 'Raw',\n\t            loc: this.getLocation(startOffset, endOffset),\n\t            value: this.scanner.source.substring(startOffset, endOffset)\n\t        };\n\t    },\n\t    generate: function(processChunk, node) {\n\t        processChunk(node.value);\n\t    }\n\t};\n\n\tvar TYPE$w = tokenizer.TYPE;\n\n\tvar LEFTCURLYBRACKET$5 = TYPE$w.LeftCurlyBracket;\n\n\tfunction consumeRaw$4(startToken) {\n\t    return this.Raw(startToken, LEFTCURLYBRACKET$5, 0, false, true);\n\t}\n\n\tvar Rule = {\n\t    name: 'Rule',\n\t    structure: {\n\t        selector: ['SelectorList', 'Raw'],\n\t        block: ['Block']\n\t    },\n\t    parse: function() {\n\t        var startToken = this.scanner.currentToken;\n\t        var startOffset = this.scanner.tokenStart;\n\t        var selector = this.parseSelector\n\t            ? this.tolerantParse(this.SelectorList, consumeRaw$4)\n\t            : consumeRaw$4.call(this, startToken);\n\t        var block = this.Block(this.Declaration);\n\n\t        return {\n\t            type: 'Rule',\n\t            loc: this.getLocation(startOffset, this.scanner.tokenStart),\n\t            selector: selector,\n\t            block: block\n\t        };\n\t    },\n\t    generate: function(processChunk, node) {\n\t        this.generate(processChunk, node.selector);\n\t        this.generate(processChunk, node.block);\n\t    },\n\t    walkContext: 'rule'\n\t};\n\n\tvar Selector = {\n\t    name: 'Selector',\n\t    structure: {\n\t        children: [[\n\t            'TypeSelector',\n\t            'IdSelector',\n\t            'ClassSelector',\n\t            'AttributeSelector',\n\t            'PseudoClassSelector',\n\t            'PseudoElementSelector',\n\t            'Combinator',\n\t            'WhiteSpace'\n\t        ]]\n\t    },\n\t    parse: function() {\n\t        var children = this.readSequence(this.scope.Selector);\n\n\t        // nothing were consumed\n\t        if (children.isEmpty()) {\n\t            this.scanner.error('Selector is expected');\n\t        }\n\n\t        return {\n\t            type: 'Selector',\n\t            loc: this.getLocationFromList(children),\n\t            children: children\n\t        };\n\t    },\n\t    generate: function(processChunk, node) {\n\t        this.each(processChunk, node);\n\t    }\n\t};\n\n\tvar TYPE$x = tokenizer.TYPE;\n\n\tvar COMMA$3 = TYPE$x.Comma;\n\tvar LEFTCURLYBRACKET$6 = TYPE$x.LeftCurlyBracket;\n\n\tvar SelectorList = {\n\t    name: 'SelectorList',\n\t    structure: {\n\t        children: [['Selector', 'Raw']]\n\t    },\n\t    parse: function() {\n\t        var children = new list();\n\n\t        while (!this.scanner.eof) {\n\t            children.appendData(this.parseSelector\n\t                ? this.Selector()\n\t                : this.Raw(this.scanner.currentToken, COMMA$3, LEFTCURLYBRACKET$6, false, false)\n\t            );\n\n\t            if (this.scanner.tokenType === COMMA$3) {\n\t                this.scanner.next();\n\t                continue;\n\t            }\n\n\t            break;\n\t        }\n\n\t        return {\n\t            type: 'SelectorList',\n\t            loc: this.getLocationFromList(children),\n\t            children: children\n\t        };\n\t    },\n\t    generate: function(processChunk, node) {\n\t        this.eachComma(processChunk, node);\n\t    },\n\t    walkContext: 'selector'\n\t};\n\n\tvar STRING$5 = tokenizer.TYPE.String;\n\n\tvar _String = {\n\t    name: 'String',\n\t    structure: {\n\t        value: String\n\t    },\n\t    parse: function() {\n\t        return {\n\t            type: 'String',\n\t            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),\n\t            value: this.scanner.consume(STRING$5)\n\t        };\n\t    },\n\t    generate: function(processChunk, node) {\n\t        processChunk(node.value);\n\t    }\n\t};\n\n\tvar TYPE$y = tokenizer.TYPE;\n\n\tvar WHITESPACE$7 = TYPE$y.WhiteSpace;\n\tvar COMMENT$7 = TYPE$y.Comment;\n\tvar EXCLAMATIONMARK$3 = TYPE$y.ExclamationMark;\n\tvar ATRULE$4 = TYPE$y.Atrule;\n\tvar CDO$3 = TYPE$y.CDO;\n\tvar CDC$3 = TYPE$y.CDC;\n\n\tfunction consumeRaw$5(startToken) {\n\t    return this.Raw(startToken, 0, 0, false, false);\n\t}\n\n\tvar StyleSheet = {\n\t    name: 'StyleSheet',\n\t    structure: {\n\t        children: [['Comment', 'Atrule', 'Rule', 'Raw']]\n\t    },\n\t    parse: function() {\n\t        var start = this.scanner.tokenStart;\n\t        var children = new list();\n\t        var child;\n\n\t        \n\t        while (!this.scanner.eof) {\n\t            switch (this.scanner.tokenType) {\n\t                case WHITESPACE$7:\n\t                    this.scanner.next();\n\t                    continue;\n\n\t                case COMMENT$7:\n\t                    // ignore comments except exclamation comments (i.e. /*! .. */) on top level\n\t                    if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 2) !== EXCLAMATIONMARK$3) {\n\t                        this.scanner.next();\n\t                        continue;\n\t                    }\n\n\t                    child = this.Comment();\n\t                    break;\n\n\t                case CDO$3: // <!--\n\t                    child = this.CDO();\n\t                    break;\n\n\t                case CDC$3: // -->\n\t                    child = this.CDC();\n\t                    break;\n\n\t                // CSS Syntax Module Level 3\n\t                // \u00A72.2 Error handling\n\t                // At the \"top level\" of a stylesheet, an <at-keyword-token> starts an at-rule.\n\t                case ATRULE$4:\n\t                    child = this.Atrule();\n\t                    break;\n\n\t                // Anything else starts a qualified rule ...\n\t                default:\n\t                    child = this.tolerantParse(this.Rule, consumeRaw$5);\n\t            }\n\n\t            children.appendData(child);\n\t        }\n\n\t        return {\n\t            type: 'StyleSheet',\n\t            loc: this.getLocation(start, this.scanner.tokenStart),\n\t            children: children\n\t        };\n\t    },\n\t    generate: function(processChunk, node) {\n\t        this.each(processChunk, node);\n\t    },\n\t    walkContext: 'stylesheet'\n\t};\n\n\tvar TYPE$z = tokenizer.TYPE;\n\n\tvar IDENTIFIER$i = TYPE$z.Identifier;\n\tvar ASTERISK$5 = TYPE$z.Asterisk;\n\tvar VERTICALLINE$2 = TYPE$z.VerticalLine;\n\n\tfunction eatIdentifierOrAsterisk() {\n\t    if (this.scanner.tokenType !== IDENTIFIER$i &&\n\t        this.scanner.tokenType !== ASTERISK$5) {\n\t        this.scanner.error('Identifier or asterisk is expected');\n\t    }\n\n\t    this.scanner.next();\n\t}\n\n\t// ident\n\t// ident|ident\n\t// ident|*\n\t// *\n\t// *|ident\n\t// *|*\n\t// |ident\n\t// |*\n\tvar TypeSelector = {\n\t    name: 'TypeSelector',\n\t    structure: {\n\t        name: String\n\t    },\n\t    parse: function() {\n\t        var start = this.scanner.tokenStart;\n\n\t        if (this.scanner.tokenType === VERTICALLINE$2) {\n\t            this.scanner.next();\n\t            eatIdentifierOrAsterisk.call(this);\n\t        } else {\n\t            eatIdentifierOrAsterisk.call(this);\n\n\t            if (this.scanner.tokenType === VERTICALLINE$2) {\n\t                this.scanner.next();\n\t                eatIdentifierOrAsterisk.call(this);\n\t            }\n\t        }\n\n\t        return {\n\t            type: 'TypeSelector',\n\t            loc: this.getLocation(start, this.scanner.tokenStart),\n\t            name: this.scanner.substrToCursor(start)\n\t        };\n\t    },\n\t    generate: function(processChunk, node) {\n\t        processChunk(node.name);\n\t    }\n\t};\n\n\tvar isHex$2 = tokenizer.isHex;\n\tvar TYPE$A = tokenizer.TYPE;\n\n\tvar IDENTIFIER$j = TYPE$A.Identifier;\n\tvar NUMBER$b = TYPE$A.Number;\n\tvar PLUSSIGN$7 = TYPE$A.PlusSign;\n\tvar HYPHENMINUS$7 = TYPE$A.HyphenMinus;\n\tvar FULLSTOP$5 = TYPE$A.FullStop;\n\tvar QUESTIONMARK = TYPE$A.QuestionMark;\n\n\tfunction scanUnicodeNumber(scanner) {\n\t    for (var pos = scanner.tokenStart + 1; pos < scanner.tokenEnd; pos++) {\n\t        var code = scanner.source.charCodeAt(pos);\n\n\t        // break on fullstop or hyperminus/plussign after exponent\n\t        if (code === FULLSTOP$5 || code === PLUSSIGN$7) {\n\t            // break token, exclude symbol\n\t            scanner.tokenStart = pos;\n\t            return false;\n\t        }\n\t    }\n\n\t    return true;\n\t}\n\n\t// https://drafts.csswg.org/css-syntax-3/#urange\n\tfunction scanUnicodeRange(scanner) {\n\t    var hexStart = scanner.tokenStart + 1; // skip +\n\t    var hexLength = 0;\n\n\t    scan: {\n\t        if (scanner.tokenType === NUMBER$b) {\n\t            if (scanner.source.charCodeAt(scanner.tokenStart) !== FULLSTOP$5 && scanUnicodeNumber(scanner)) {\n\t                scanner.next();\n\t            } else if (scanner.source.charCodeAt(scanner.tokenStart) !== HYPHENMINUS$7) {\n\t                break scan;\n\t            }\n\t        } else {\n\t            scanner.next(); // PLUSSIGN\n\t        }\n\n\t        if (scanner.tokenType === HYPHENMINUS$7) {\n\t            scanner.next();\n\t        }\n\n\t        if (scanner.tokenType === NUMBER$b) {\n\t            scanner.next();\n\t        }\n\n\t        if (scanner.tokenType === IDENTIFIER$j) {\n\t            scanner.next();\n\t        }\n\n\t        if (scanner.tokenStart === hexStart) {\n\t            scanner.error('Unexpected input', hexStart);\n\t        }\n\t    }\n\n\t    // validate for U+x{1,6} or U+x{1,6}-x{1,6}\n\t    // where x is [0-9a-fA-F]\n\t    for (var i = hexStart, wasHyphenMinus = false; i < scanner.tokenStart; i++) {\n\t        var code = scanner.source.charCodeAt(i);\n\n\t        if (isHex$2(code) === false && (code !== HYPHENMINUS$7 || wasHyphenMinus)) {\n\t            scanner.error('Unexpected input', i);\n\t        }\n\n\t        if (code === HYPHENMINUS$7) {\n\t            // hex sequence shouldn't be an empty\n\t            if (hexLength === 0) {\n\t                scanner.error('Unexpected input', i);\n\t            }\n\n\t            wasHyphenMinus = true;\n\t            hexLength = 0;\n\t        } else {\n\t            hexLength++;\n\n\t            // too long hex sequence\n\t            if (hexLength > 6) {\n\t                scanner.error('Too long hex sequence', i);\n\t            }\n\t        }\n\n\t    }\n\n\t    // check we have a non-zero sequence\n\t    if (hexLength === 0) {\n\t        scanner.error('Unexpected input', i - 1);\n\t    }\n\n\t    // U+abc???\n\t    if (!wasHyphenMinus) {\n\t        // consume as many U+003F QUESTION MARK (?) code points as possible\n\t        for (; hexLength < 6 && !scanner.eof; scanner.next()) {\n\t            if (scanner.tokenType !== QUESTIONMARK) {\n\t                break;\n\t            }\n\n\t            hexLength++;\n\t        }\n\t    }\n\t}\n\n\tvar UnicodeRange = {\n\t    name: 'UnicodeRange',\n\t    structure: {\n\t        value: String\n\t    },\n\t    parse: function() {\n\t        var start = this.scanner.tokenStart;\n\n\t        this.scanner.next(); // U or u\n\t        scanUnicodeRange(this.scanner);\n\n\t        return {\n\t            type: 'UnicodeRange',\n\t            loc: this.getLocation(start, this.scanner.tokenStart),\n\t            value: this.scanner.substrToCursor(start)\n\t        };\n\t    },\n\t    generate: function(processChunk, node) {\n\t        processChunk(node.value);\n\t    }\n\t};\n\n\tvar TYPE$B = tokenizer.TYPE;\n\n\tvar STRING$6 = TYPE$B.String;\n\tvar URL$4 = TYPE$B.Url;\n\tvar RAW$2 = TYPE$B.Raw;\n\tvar RIGHTPARENTHESIS$7 = TYPE$B.RightParenthesis;\n\n\t// url '(' S* (string | raw) S* ')'\n\tvar Url = {\n\t    name: 'Url',\n\t    structure: {\n\t        value: ['String', 'Raw']\n\t    },\n\t    parse: function() {\n\t        var start = this.scanner.tokenStart;\n\t        var value;\n\n\t        this.scanner.eat(URL$4);\n\t        this.scanner.skipSC();\n\n\t        switch (this.scanner.tokenType) {\n\t            case STRING$6:\n\t                value = this.String();\n\t                break;\n\n\t            case RAW$2:\n\t                value = this.Raw(this.scanner.currentToken, 0, RAW$2, true, false);\n\t                break;\n\n\t            default:\n\t                this.scanner.error('String or Raw is expected');\n\t        }\n\n\t        this.scanner.skipSC();\n\t        this.scanner.eat(RIGHTPARENTHESIS$7);\n\n\t        return {\n\t            type: 'Url',\n\t            loc: this.getLocation(start, this.scanner.tokenStart),\n\t            value: value\n\t        };\n\t    },\n\t    generate: function(processChunk, node) {\n\t        processChunk('url');\n\t        processChunk('(');\n\t        this.generate(processChunk, node.value);\n\t        processChunk(')');\n\t    }\n\t};\n\n\tvar endsWith$1 = tokenizer.endsWith;\n\tvar TYPE$C = tokenizer.TYPE;\n\n\tvar WHITESPACE$8 = TYPE$C.WhiteSpace;\n\tvar COMMENT$8 = TYPE$C.Comment;\n\tvar FUNCTION$6 = TYPE$C.Function;\n\tvar COLON$7 = TYPE$C.Colon;\n\tvar SEMICOLON$6 = TYPE$C.Semicolon;\n\tvar EXCLAMATIONMARK$4 = TYPE$C.ExclamationMark;\n\n\t// 'progid:' ws* 'DXImageTransform.Microsoft.' ident ws* '(' .* ')'\n\tfunction checkProgid(scanner) {\n\t    var offset = 0;\n\n\t    for (var type; type = scanner.lookupType(offset); offset++) {\n\t        if (type !== WHITESPACE$8 && type !== COMMENT$8) {\n\t            break;\n\t        }\n\t    }\n\n\t    if (scanner.lookupValue(offset, 'alpha(') ||\n\t        scanner.lookupValue(offset, 'chroma(') ||\n\t        scanner.lookupValue(offset, 'dropshadow(')) {\n\t        if (scanner.lookupType(offset) !== FUNCTION$6) {\n\t            return false;\n\t        }\n\t    } else {\n\t        if (scanner.lookupValue(offset, 'progid') === false ||\n\t            scanner.lookupType(offset + 1) !== COLON$7) {\n\t            return false;\n\t        }\n\t    }\n\n\t    return true;\n\t}\n\n\tvar Value = {\n\t    name: 'Value',\n\t    structure: {\n\t        children: [[]]\n\t    },\n\t    parse: function(property) {\n\t        // special parser for filter property since it can contains non-standart syntax for old IE\n\t        if (property !== null && endsWith$1(property, 'filter') && checkProgid(this.scanner)) {\n\t            this.scanner.skipSC();\n\t            return this.Raw(this.scanner.currentToken, EXCLAMATIONMARK$4, SEMICOLON$6, false, false);\n\t        }\n\n\t        var start = this.scanner.tokenStart;\n\t        var children = this.readSequence(this.scope.Value);\n\n\t        return {\n\t            type: 'Value',\n\t            loc: this.getLocation(start, this.scanner.tokenStart),\n\t            children: children\n\t        };\n\t    },\n\t    generate: function(processChunk, node) {\n\t        this.each(processChunk, node);\n\t    }\n\t};\n\n\tvar WHITESPACE$9 = tokenizer.TYPE.WhiteSpace;\n\tvar SPACE$2 = Object.freeze({\n\t    type: 'WhiteSpace',\n\t    loc: null,\n\t    value: ' '\n\t});\n\n\tvar WhiteSpace = {\n\t    name: 'WhiteSpace',\n\t    structure: {\n\t        value: String\n\t    },\n\t    parse: function() {\n\t        this.scanner.eat(WHITESPACE$9);\n\t        return SPACE$2;\n\n\t        // return {\n\t        //     type: 'WhiteSpace',\n\t        //     loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),\n\t        //     value: this.scanner.consume(WHITESPACE)\n\t        // };\n\t    },\n\t    generate: function(processChunk, node) {\n\t        processChunk(node.value);\n\t    }\n\t};\n\n\tvar node = {\n\t    AnPlusB: AnPlusB,\n\t    Atrule: Atrule,\n\t    AtruleExpression: AtruleExpression,\n\t    AttributeSelector: AttributeSelector,\n\t    Block: Block,\n\t    Brackets: Brackets,\n\t    CDC: CDC_1,\n\t    CDO: CDO_1,\n\t    ClassSelector: ClassSelector,\n\t    Combinator: Combinator,\n\t    Comment: Comment,\n\t    Declaration: Declaration,\n\t    DeclarationList: DeclarationList,\n\t    Dimension: Dimension,\n\t    Function: _Function,\n\t    HexColor: HexColor,\n\t    Identifier: Identifier,\n\t    IdSelector: IdSelector,\n\t    MediaFeature: MediaFeature,\n\t    MediaQuery: MediaQuery,\n\t    MediaQueryList: MediaQueryList,\n\t    Nth: Nth,\n\t    Number: _Number,\n\t    Operator: Operator,\n\t    Parentheses: Parentheses,\n\t    Percentage: Percentage,\n\t    PseudoClassSelector: PseudoClassSelector,\n\t    PseudoElementSelector: PseudoElementSelector,\n\t    Ratio: Ratio,\n\t    Raw: Raw,\n\t    Rule: Rule,\n\t    Selector: Selector,\n\t    SelectorList: SelectorList,\n\t    String: _String,\n\t    StyleSheet: StyleSheet,\n\t    TypeSelector: TypeSelector,\n\t    UnicodeRange: UnicodeRange,\n\t    Url: Url,\n\t    Value: Value,\n\t    WhiteSpace: WhiteSpace\n\t};\n\n\tvar parser = {\n\t    parseContext: {\n\t        default: 'StyleSheet',\n\t        stylesheet: 'StyleSheet',\n\t        atrule: 'Atrule',\n\t        atruleExpression: function(options) {\n\t            return this.AtruleExpression(options.atrule ? String(options.atrule) : null);\n\t        },\n\t        mediaQueryList: 'MediaQueryList',\n\t        mediaQuery: 'MediaQuery',\n\t        rule: 'Rule',\n\t        selectorList: 'SelectorList',\n\t        selector: 'Selector',\n\t        block: function() {\n\t            return this.Block(this.Declaration);\n\t        },\n\t        declarationList: 'DeclarationList',\n\t        declaration: 'Declaration',\n\t        value: function(options) {\n\t            return this.Value(options.property ? String(options.property) : null);\n\t        }\n\t    },\n\t    scope: scope,\n\t    atrule: atrule,\n\t    pseudo: pseudo,\n\t    node: node\n\t};\n\n\tvar parser$1 = create(parser);\n\n\tfunction read_style(parser, start, attributes) {\n\t    const content_start = parser.index;\n\t    const styles = parser.read_until(/<\\/style>/);\n\t    const content_end = parser.index;\n\t    let ast;\n\t    try {\n\t        ast = parser$1(styles, {\n\t            positions: true,\n\t            offset: content_start,\n\t        });\n\t    }\n\t    catch (err) {\n\t        if (err.name === 'CssSyntaxError') {\n\t            parser.error({\n\t                code: `css-syntax-error`,\n\t                message: err.message\n\t            }, err.offset);\n\t        }\n\t        else {\n\t            throw err;\n\t        }\n\t    }\n\t    ast = JSON.parse(JSON.stringify(ast));\n\t    // tidy up AST\n\t    walk(ast, {\n\t        enter: (node) => {\n\t            // replace `ref:a` nodes\n\t            if (node.type === 'Selector') {\n\t                for (let i = 0; i < node.children.length; i += 1) {\n\t                    const a = node.children[i];\n\t                    const b = node.children[i + 1];\n\t                    if (is_ref_selector(a, b)) {\n\t                        parser.error({\n\t                            code: `invalid-ref-selector`,\n\t                            message: 'ref selectors are no longer supported'\n\t                        }, a.loc.start.offset);\n\t                    }\n\t                }\n\t            }\n\t            if (node.type === 'Declaration' && node.value.type === 'Value' && node.value.children.length === 0) {\n\t                parser.error({\n\t                    code: `invalid-declaration`,\n\t                    message: `Declaration cannot be empty`\n\t                }, node.start);\n\t            }\n\t            if (node.type === 'PseudoClassSelector' && node.name === 'global' && node.children === null) {\n\t                parser.error({\n\t                    code: `css-syntax-error`,\n\t                    message: `:global() must contain a selector`\n\t                }, node.loc.start.offset);\n\t            }\n\t            if (node.loc) {\n\t                node.start = node.loc.start.offset;\n\t                node.end = node.loc.end.offset;\n\t                delete node.loc;\n\t            }\n\t        }\n\t    });\n\t    parser.eat('</style>', true);\n\t    const end = parser.index;\n\t    return {\n\t        type: 'Style',\n\t        start,\n\t        end,\n\t        attributes,\n\t        children: ast.children,\n\t        content: {\n\t            start: content_start,\n\t            end: content_end,\n\t            styles\n\t        }\n\t    };\n\t}\n\tfunction is_ref_selector(a, b) {\n\t    if (!b)\n\t        return false;\n\t    return (a.type === 'TypeSelector' &&\n\t        a.name === 'ref' &&\n\t        b.type === 'PseudoClassSelector');\n\t}\n\n\t// https://dev.w3.org/html5/html-author/charref\n\tvar entities = {\n\t    CounterClockwiseContourIntegral: 8755,\n\t    ClockwiseContourIntegral: 8754,\n\t    DoubleLongLeftRightArrow: 10234,\n\t    DiacriticalDoubleAcute: 733,\n\t    NotSquareSupersetEqual: 8931,\n\t    CloseCurlyDoubleQuote: 8221,\n\t    DoubleContourIntegral: 8751,\n\t    FilledVerySmallSquare: 9642,\n\t    NegativeVeryThinSpace: 8203,\n\t    NotPrecedesSlantEqual: 8928,\n\t    NotRightTriangleEqual: 8941,\n\t    NotSucceedsSlantEqual: 8929,\n\t    CapitalDifferentialD: 8517,\n\t    DoubleLeftRightArrow: 8660,\n\t    DoubleLongRightArrow: 10233,\n\t    EmptyVerySmallSquare: 9643,\n\t    NestedGreaterGreater: 8811,\n\t    NotDoubleVerticalBar: 8742,\n\t    NotLeftTriangleEqual: 8940,\n\t    NotSquareSubsetEqual: 8930,\n\t    OpenCurlyDoubleQuote: 8220,\n\t    ReverseUpEquilibrium: 10607,\n\t    DoubleLongLeftArrow: 10232,\n\t    DownLeftRightVector: 10576,\n\t    LeftArrowRightArrow: 8646,\n\t    NegativeMediumSpace: 8203,\n\t    RightArrowLeftArrow: 8644,\n\t    SquareSupersetEqual: 8850,\n\t    leftrightsquigarrow: 8621,\n\t    DownRightTeeVector: 10591,\n\t    DownRightVectorBar: 10583,\n\t    LongLeftRightArrow: 10231,\n\t    Longleftrightarrow: 10234,\n\t    NegativeThickSpace: 8203,\n\t    PrecedesSlantEqual: 8828,\n\t    ReverseEquilibrium: 8651,\n\t    RightDoubleBracket: 10215,\n\t    RightDownTeeVector: 10589,\n\t    RightDownVectorBar: 10581,\n\t    RightTriangleEqual: 8885,\n\t    SquareIntersection: 8851,\n\t    SucceedsSlantEqual: 8829,\n\t    blacktriangleright: 9656,\n\t    longleftrightarrow: 10231,\n\t    DoubleUpDownArrow: 8661,\n\t    DoubleVerticalBar: 8741,\n\t    DownLeftTeeVector: 10590,\n\t    DownLeftVectorBar: 10582,\n\t    FilledSmallSquare: 9724,\n\t    GreaterSlantEqual: 10878,\n\t    LeftDoubleBracket: 10214,\n\t    LeftDownTeeVector: 10593,\n\t    LeftDownVectorBar: 10585,\n\t    LeftTriangleEqual: 8884,\n\t    NegativeThinSpace: 8203,\n\t    NotReverseElement: 8716,\n\t    NotTildeFullEqual: 8775,\n\t    RightAngleBracket: 10217,\n\t    RightUpDownVector: 10575,\n\t    SquareSubsetEqual: 8849,\n\t    VerticalSeparator: 10072,\n\t    blacktriangledown: 9662,\n\t    blacktriangleleft: 9666,\n\t    leftrightharpoons: 8651,\n\t    rightleftharpoons: 8652,\n\t    twoheadrightarrow: 8608,\n\t    DiacriticalAcute: 180,\n\t    DiacriticalGrave: 96,\n\t    DiacriticalTilde: 732,\n\t    DoubleRightArrow: 8658,\n\t    DownArrowUpArrow: 8693,\n\t    EmptySmallSquare: 9723,\n\t    GreaterEqualLess: 8923,\n\t    GreaterFullEqual: 8807,\n\t    LeftAngleBracket: 10216,\n\t    LeftUpDownVector: 10577,\n\t    LessEqualGreater: 8922,\n\t    NonBreakingSpace: 160,\n\t    NotRightTriangle: 8939,\n\t    NotSupersetEqual: 8841,\n\t    RightTriangleBar: 10704,\n\t    RightUpTeeVector: 10588,\n\t    RightUpVectorBar: 10580,\n\t    UnderParenthesis: 9181,\n\t    UpArrowDownArrow: 8645,\n\t    circlearrowright: 8635,\n\t    downharpoonright: 8642,\n\t    ntrianglerighteq: 8941,\n\t    rightharpoondown: 8641,\n\t    rightrightarrows: 8649,\n\t    twoheadleftarrow: 8606,\n\t    vartriangleright: 8883,\n\t    CloseCurlyQuote: 8217,\n\t    ContourIntegral: 8750,\n\t    DoubleDownArrow: 8659,\n\t    DoubleLeftArrow: 8656,\n\t    DownRightVector: 8641,\n\t    LeftRightVector: 10574,\n\t    LeftTriangleBar: 10703,\n\t    LeftUpTeeVector: 10592,\n\t    LeftUpVectorBar: 10584,\n\t    LowerRightArrow: 8600,\n\t    NotGreaterEqual: 8817,\n\t    NotGreaterTilde: 8821,\n\t    NotLeftTriangle: 8938,\n\t    OverParenthesis: 9180,\n\t    RightDownVector: 8642,\n\t    ShortRightArrow: 8594,\n\t    UpperRightArrow: 8599,\n\t    bigtriangledown: 9661,\n\t    circlearrowleft: 8634,\n\t    curvearrowright: 8631,\n\t    downharpoonleft: 8643,\n\t    leftharpoondown: 8637,\n\t    leftrightarrows: 8646,\n\t    nLeftrightarrow: 8654,\n\t    nleftrightarrow: 8622,\n\t    ntrianglelefteq: 8940,\n\t    rightleftarrows: 8644,\n\t    rightsquigarrow: 8605,\n\t    rightthreetimes: 8908,\n\t    straightepsilon: 1013,\n\t    trianglerighteq: 8885,\n\t    vartriangleleft: 8882,\n\t    DiacriticalDot: 729,\n\t    DoubleRightTee: 8872,\n\t    DownLeftVector: 8637,\n\t    GreaterGreater: 10914,\n\t    HorizontalLine: 9472,\n\t    InvisibleComma: 8291,\n\t    InvisibleTimes: 8290,\n\t    LeftDownVector: 8643,\n\t    LeftRightArrow: 8596,\n\t    Leftrightarrow: 8660,\n\t    LessSlantEqual: 10877,\n\t    LongRightArrow: 10230,\n\t    Longrightarrow: 10233,\n\t    LowerLeftArrow: 8601,\n\t    NestedLessLess: 8810,\n\t    NotGreaterLess: 8825,\n\t    NotLessGreater: 8824,\n\t    NotSubsetEqual: 8840,\n\t    NotVerticalBar: 8740,\n\t    OpenCurlyQuote: 8216,\n\t    ReverseElement: 8715,\n\t    RightTeeVector: 10587,\n\t    RightVectorBar: 10579,\n\t    ShortDownArrow: 8595,\n\t    ShortLeftArrow: 8592,\n\t    SquareSuperset: 8848,\n\t    TildeFullEqual: 8773,\n\t    UpperLeftArrow: 8598,\n\t    ZeroWidthSpace: 8203,\n\t    curvearrowleft: 8630,\n\t    doublebarwedge: 8966,\n\t    downdownarrows: 8650,\n\t    hookrightarrow: 8618,\n\t    leftleftarrows: 8647,\n\t    leftrightarrow: 8596,\n\t    leftthreetimes: 8907,\n\t    longrightarrow: 10230,\n\t    looparrowright: 8620,\n\t    nshortparallel: 8742,\n\t    ntriangleright: 8939,\n\t    rightarrowtail: 8611,\n\t    rightharpoonup: 8640,\n\t    trianglelefteq: 8884,\n\t    upharpoonright: 8638,\n\t    ApplyFunction: 8289,\n\t    DifferentialD: 8518,\n\t    DoubleLeftTee: 10980,\n\t    DoubleUpArrow: 8657,\n\t    LeftTeeVector: 10586,\n\t    LeftVectorBar: 10578,\n\t    LessFullEqual: 8806,\n\t    LongLeftArrow: 10229,\n\t    Longleftarrow: 10232,\n\t    NotTildeEqual: 8772,\n\t    NotTildeTilde: 8777,\n\t    Poincareplane: 8460,\n\t    PrecedesEqual: 10927,\n\t    PrecedesTilde: 8830,\n\t    RightArrowBar: 8677,\n\t    RightTeeArrow: 8614,\n\t    RightTriangle: 8883,\n\t    RightUpVector: 8638,\n\t    SucceedsEqual: 10928,\n\t    SucceedsTilde: 8831,\n\t    SupersetEqual: 8839,\n\t    UpEquilibrium: 10606,\n\t    VerticalTilde: 8768,\n\t    VeryThinSpace: 8202,\n\t    bigtriangleup: 9651,\n\t    blacktriangle: 9652,\n\t    divideontimes: 8903,\n\t    fallingdotseq: 8786,\n\t    hookleftarrow: 8617,\n\t    leftarrowtail: 8610,\n\t    leftharpoonup: 8636,\n\t    longleftarrow: 10229,\n\t    looparrowleft: 8619,\n\t    measuredangle: 8737,\n\t    ntriangleleft: 8938,\n\t    shortparallel: 8741,\n\t    smallsetminus: 8726,\n\t    triangleright: 9657,\n\t    upharpoonleft: 8639,\n\t    DownArrowBar: 10515,\n\t    DownTeeArrow: 8615,\n\t    ExponentialE: 8519,\n\t    GreaterEqual: 8805,\n\t    GreaterTilde: 8819,\n\t    HilbertSpace: 8459,\n\t    HumpDownHump: 8782,\n\t    Intersection: 8898,\n\t    LeftArrowBar: 8676,\n\t    LeftTeeArrow: 8612,\n\t    LeftTriangle: 8882,\n\t    LeftUpVector: 8639,\n\t    NotCongruent: 8802,\n\t    NotLessEqual: 8816,\n\t    NotLessTilde: 8820,\n\t    Proportional: 8733,\n\t    RightCeiling: 8969,\n\t    RoundImplies: 10608,\n\t    ShortUpArrow: 8593,\n\t    SquareSubset: 8847,\n\t    UnderBracket: 9141,\n\t    VerticalLine: 124,\n\t    blacklozenge: 10731,\n\t    exponentiale: 8519,\n\t    risingdotseq: 8787,\n\t    triangledown: 9663,\n\t    triangleleft: 9667,\n\t    CircleMinus: 8854,\n\t    CircleTimes: 8855,\n\t    Equilibrium: 8652,\n\t    GreaterLess: 8823,\n\t    LeftCeiling: 8968,\n\t    LessGreater: 8822,\n\t    MediumSpace: 8287,\n\t    NotPrecedes: 8832,\n\t    NotSucceeds: 8833,\n\t    OverBracket: 9140,\n\t    RightVector: 8640,\n\t    Rrightarrow: 8667,\n\t    RuleDelayed: 10740,\n\t    SmallCircle: 8728,\n\t    SquareUnion: 8852,\n\t    SubsetEqual: 8838,\n\t    UpDownArrow: 8597,\n\t    Updownarrow: 8661,\n\t    VerticalBar: 8739,\n\t    backepsilon: 1014,\n\t    blacksquare: 9642,\n\t    circledcirc: 8858,\n\t    circleddash: 8861,\n\t    curlyeqprec: 8926,\n\t    curlyeqsucc: 8927,\n\t    diamondsuit: 9830,\n\t    eqslantless: 10901,\n\t    expectation: 8496,\n\t    nRightarrow: 8655,\n\t    nrightarrow: 8603,\n\t    preccurlyeq: 8828,\n\t    precnapprox: 10937,\n\t    quaternions: 8461,\n\t    straightphi: 981,\n\t    succcurlyeq: 8829,\n\t    succnapprox: 10938,\n\t    thickapprox: 8776,\n\t    updownarrow: 8597,\n\t    Bernoullis: 8492,\n\t    CirclePlus: 8853,\n\t    EqualTilde: 8770,\n\t    Fouriertrf: 8497,\n\t    ImaginaryI: 8520,\n\t    Laplacetrf: 8466,\n\t    LeftVector: 8636,\n\t    Lleftarrow: 8666,\n\t    NotElement: 8713,\n\t    NotGreater: 8815,\n\t    Proportion: 8759,\n\t    RightArrow: 8594,\n\t    RightFloor: 8971,\n\t    Rightarrow: 8658,\n\t    TildeEqual: 8771,\n\t    TildeTilde: 8776,\n\t    UnderBrace: 9183,\n\t    UpArrowBar: 10514,\n\t    UpTeeArrow: 8613,\n\t    circledast: 8859,\n\t    complement: 8705,\n\t    curlywedge: 8911,\n\t    eqslantgtr: 10902,\n\t    gtreqqless: 10892,\n\t    lessapprox: 10885,\n\t    lesseqqgtr: 10891,\n\t    lmoustache: 9136,\n\t    longmapsto: 10236,\n\t    mapstodown: 8615,\n\t    mapstoleft: 8612,\n\t    nLeftarrow: 8653,\n\t    nleftarrow: 8602,\n\t    precapprox: 10935,\n\t    rightarrow: 8594,\n\t    rmoustache: 9137,\n\t    sqsubseteq: 8849,\n\t    sqsupseteq: 8850,\n\t    subsetneqq: 10955,\n\t    succapprox: 10936,\n\t    supsetneqq: 10956,\n\t    upuparrows: 8648,\n\t    varepsilon: 949,\n\t    varnothing: 8709,\n\t    Backslash: 8726,\n\t    CenterDot: 183,\n\t    CircleDot: 8857,\n\t    Congruent: 8801,\n\t    Coproduct: 8720,\n\t    DoubleDot: 168,\n\t    DownArrow: 8595,\n\t    DownBreve: 785,\n\t    Downarrow: 8659,\n\t    HumpEqual: 8783,\n\t    LeftArrow: 8592,\n\t    LeftFloor: 8970,\n\t    Leftarrow: 8656,\n\t    LessTilde: 8818,\n\t    Mellintrf: 8499,\n\t    MinusPlus: 8723,\n\t    NotCupCap: 8813,\n\t    NotExists: 8708,\n\t    OverBrace: 9182,\n\t    PlusMinus: 177,\n\t    Therefore: 8756,\n\t    ThinSpace: 8201,\n\t    TripleDot: 8411,\n\t    UnionPlus: 8846,\n\t    backprime: 8245,\n\t    backsimeq: 8909,\n\t    bigotimes: 10754,\n\t    centerdot: 183,\n\t    checkmark: 10003,\n\t    complexes: 8450,\n\t    dotsquare: 8865,\n\t    downarrow: 8595,\n\t    gtrapprox: 10886,\n\t    gtreqless: 8923,\n\t    heartsuit: 9829,\n\t    leftarrow: 8592,\n\t    lesseqgtr: 8922,\n\t    nparallel: 8742,\n\t    nshortmid: 8740,\n\t    nsubseteq: 8840,\n\t    nsupseteq: 8841,\n\t    pitchfork: 8916,\n\t    rationals: 8474,\n\t    spadesuit: 9824,\n\t    subseteqq: 10949,\n\t    subsetneq: 8842,\n\t    supseteqq: 10950,\n\t    supsetneq: 8843,\n\t    therefore: 8756,\n\t    triangleq: 8796,\n\t    varpropto: 8733,\n\t    DDotrahd: 10513,\n\t    DotEqual: 8784,\n\t    Integral: 8747,\n\t    LessLess: 10913,\n\t    NotEqual: 8800,\n\t    NotTilde: 8769,\n\t    PartialD: 8706,\n\t    Precedes: 8826,\n\t    RightTee: 8866,\n\t    Succeeds: 8827,\n\t    SuchThat: 8715,\n\t    Superset: 8835,\n\t    Uarrocir: 10569,\n\t    UnderBar: 818,\n\t    andslope: 10840,\n\t    angmsdaa: 10664,\n\t    angmsdab: 10665,\n\t    angmsdac: 10666,\n\t    angmsdad: 10667,\n\t    angmsdae: 10668,\n\t    angmsdaf: 10669,\n\t    angmsdag: 10670,\n\t    angmsdah: 10671,\n\t    angrtvbd: 10653,\n\t    approxeq: 8778,\n\t    awconint: 8755,\n\t    backcong: 8780,\n\t    barwedge: 8965,\n\t    bbrktbrk: 9142,\n\t    bigoplus: 10753,\n\t    bigsqcup: 10758,\n\t    biguplus: 10756,\n\t    bigwedge: 8896,\n\t    boxminus: 8863,\n\t    boxtimes: 8864,\n\t    capbrcup: 10825,\n\t    circledR: 174,\n\t    circledS: 9416,\n\t    cirfnint: 10768,\n\t    clubsuit: 9827,\n\t    cupbrcap: 10824,\n\t    curlyvee: 8910,\n\t    cwconint: 8754,\n\t    doteqdot: 8785,\n\t    dotminus: 8760,\n\t    drbkarow: 10512,\n\t    dzigrarr: 10239,\n\t    elinters: 9191,\n\t    emptyset: 8709,\n\t    eqvparsl: 10725,\n\t    fpartint: 10765,\n\t    geqslant: 10878,\n\t    gesdotol: 10884,\n\t    gnapprox: 10890,\n\t    hksearow: 10533,\n\t    hkswarow: 10534,\n\t    imagline: 8464,\n\t    imagpart: 8465,\n\t    infintie: 10717,\n\t    integers: 8484,\n\t    intercal: 8890,\n\t    intlarhk: 10775,\n\t    laemptyv: 10676,\n\t    ldrushar: 10571,\n\t    leqslant: 10877,\n\t    lesdotor: 10883,\n\t    llcorner: 8990,\n\t    lnapprox: 10889,\n\t    lrcorner: 8991,\n\t    lurdshar: 10570,\n\t    mapstoup: 8613,\n\t    multimap: 8888,\n\t    naturals: 8469,\n\t    otimesas: 10806,\n\t    parallel: 8741,\n\t    plusacir: 10787,\n\t    pointint: 10773,\n\t    precneqq: 10933,\n\t    precnsim: 8936,\n\t    profalar: 9006,\n\t    profline: 8978,\n\t    profsurf: 8979,\n\t    raemptyv: 10675,\n\t    realpart: 8476,\n\t    rppolint: 10770,\n\t    rtriltri: 10702,\n\t    scpolint: 10771,\n\t    setminus: 8726,\n\t    shortmid: 8739,\n\t    smeparsl: 10724,\n\t    sqsubset: 8847,\n\t    sqsupset: 8848,\n\t    subseteq: 8838,\n\t    succneqq: 10934,\n\t    succnsim: 8937,\n\t    supseteq: 8839,\n\t    thetasym: 977,\n\t    thicksim: 8764,\n\t    timesbar: 10801,\n\t    triangle: 9653,\n\t    triminus: 10810,\n\t    trpezium: 9186,\n\t    ulcorner: 8988,\n\t    urcorner: 8989,\n\t    varkappa: 1008,\n\t    varsigma: 962,\n\t    vartheta: 977,\n\t    Because: 8757,\n\t    Cayleys: 8493,\n\t    Cconint: 8752,\n\t    Cedilla: 184,\n\t    Diamond: 8900,\n\t    DownTee: 8868,\n\t    Element: 8712,\n\t    Epsilon: 917,\n\t    Implies: 8658,\n\t    LeftTee: 8867,\n\t    NewLine: 10,\n\t    NoBreak: 8288,\n\t    NotLess: 8814,\n\t    Omicron: 927,\n\t    OverBar: 175,\n\t    Product: 8719,\n\t    UpArrow: 8593,\n\t    Uparrow: 8657,\n\t    Upsilon: 933,\n\t    alefsym: 8501,\n\t    angrtvb: 8894,\n\t    angzarr: 9084,\n\t    asympeq: 8781,\n\t    backsim: 8765,\n\t    because: 8757,\n\t    bemptyv: 10672,\n\t    between: 8812,\n\t    bigcirc: 9711,\n\t    bigodot: 10752,\n\t    bigstar: 9733,\n\t    boxplus: 8862,\n\t    ccupssm: 10832,\n\t    cemptyv: 10674,\n\t    cirscir: 10690,\n\t    coloneq: 8788,\n\t    congdot: 10861,\n\t    cudarrl: 10552,\n\t    cudarrr: 10549,\n\t    cularrp: 10557,\n\t    curarrm: 10556,\n\t    dbkarow: 10511,\n\t    ddagger: 8225,\n\t    ddotseq: 10871,\n\t    demptyv: 10673,\n\t    diamond: 8900,\n\t    digamma: 989,\n\t    dotplus: 8724,\n\t    dwangle: 10662,\n\t    epsilon: 949,\n\t    eqcolon: 8789,\n\t    equivDD: 10872,\n\t    gesdoto: 10882,\n\t    gtquest: 10876,\n\t    gtrless: 8823,\n\t    harrcir: 10568,\n\t    intprod: 10812,\n\t    isindot: 8949,\n\t    larrbfs: 10527,\n\t    larrsim: 10611,\n\t    lbrksld: 10639,\n\t    lbrkslu: 10637,\n\t    ldrdhar: 10599,\n\t    lesdoto: 10881,\n\t    lessdot: 8918,\n\t    lessgtr: 8822,\n\t    lesssim: 8818,\n\t    lotimes: 10804,\n\t    lozenge: 9674,\n\t    ltquest: 10875,\n\t    luruhar: 10598,\n\t    maltese: 10016,\n\t    minusdu: 10794,\n\t    napprox: 8777,\n\t    natural: 9838,\n\t    nearrow: 8599,\n\t    nexists: 8708,\n\t    notinva: 8713,\n\t    notinvb: 8951,\n\t    notinvc: 8950,\n\t    notniva: 8716,\n\t    notnivb: 8958,\n\t    notnivc: 8957,\n\t    npolint: 10772,\n\t    nsqsube: 8930,\n\t    nsqsupe: 8931,\n\t    nvinfin: 10718,\n\t    nwarrow: 8598,\n\t    olcross: 10683,\n\t    omicron: 959,\n\t    orderof: 8500,\n\t    orslope: 10839,\n\t    pertenk: 8241,\n\t    planckh: 8462,\n\t    pluscir: 10786,\n\t    plussim: 10790,\n\t    plustwo: 10791,\n\t    precsim: 8830,\n\t    quatint: 10774,\n\t    questeq: 8799,\n\t    rarrbfs: 10528,\n\t    rarrsim: 10612,\n\t    rbrksld: 10638,\n\t    rbrkslu: 10640,\n\t    rdldhar: 10601,\n\t    realine: 8475,\n\t    rotimes: 10805,\n\t    ruluhar: 10600,\n\t    searrow: 8600,\n\t    simplus: 10788,\n\t    simrarr: 10610,\n\t    subedot: 10947,\n\t    submult: 10945,\n\t    subplus: 10943,\n\t    subrarr: 10617,\n\t    succsim: 8831,\n\t    supdsub: 10968,\n\t    supedot: 10948,\n\t    suphsub: 10967,\n\t    suplarr: 10619,\n\t    supmult: 10946,\n\t    supplus: 10944,\n\t    swarrow: 8601,\n\t    topfork: 10970,\n\t    triplus: 10809,\n\t    tritime: 10811,\n\t    uparrow: 8593,\n\t    upsilon: 965,\n\t    uwangle: 10663,\n\t    vzigzag: 10650,\n\t    zigrarr: 8669,\n\t    Aacute: 193,\n\t    Abreve: 258,\n\t    Agrave: 192,\n\t    Assign: 8788,\n\t    Atilde: 195,\n\t    Barwed: 8966,\n\t    Bumpeq: 8782,\n\t    Cacute: 262,\n\t    Ccaron: 268,\n\t    Ccedil: 199,\n\t    Colone: 10868,\n\t    Conint: 8751,\n\t    CupCap: 8781,\n\t    Dagger: 8225,\n\t    Dcaron: 270,\n\t    DotDot: 8412,\n\t    Dstrok: 272,\n\t    Eacute: 201,\n\t    Ecaron: 282,\n\t    Egrave: 200,\n\t    Exists: 8707,\n\t    ForAll: 8704,\n\t    Gammad: 988,\n\t    Gbreve: 286,\n\t    Gcedil: 290,\n\t    HARDcy: 1066,\n\t    Hstrok: 294,\n\t    Iacute: 205,\n\t    Igrave: 204,\n\t    Itilde: 296,\n\t    Jsercy: 1032,\n\t    Kcedil: 310,\n\t    Lacute: 313,\n\t    Lambda: 923,\n\t    Lcaron: 317,\n\t    Lcedil: 315,\n\t    Lmidot: 319,\n\t    Lstrok: 321,\n\t    Nacute: 323,\n\t    Ncaron: 327,\n\t    Ncedil: 325,\n\t    Ntilde: 209,\n\t    Oacute: 211,\n\t    Odblac: 336,\n\t    Ograve: 210,\n\t    Oslash: 216,\n\t    Otilde: 213,\n\t    Otimes: 10807,\n\t    Racute: 340,\n\t    Rarrtl: 10518,\n\t    Rcaron: 344,\n\t    Rcedil: 342,\n\t    SHCHcy: 1065,\n\t    SOFTcy: 1068,\n\t    Sacute: 346,\n\t    Scaron: 352,\n\t    Scedil: 350,\n\t    Square: 9633,\n\t    Subset: 8912,\n\t    Supset: 8913,\n\t    Tcaron: 356,\n\t    Tcedil: 354,\n\t    Tstrok: 358,\n\t    Uacute: 218,\n\t    Ubreve: 364,\n\t    Udblac: 368,\n\t    Ugrave: 217,\n\t    Utilde: 360,\n\t    Vdashl: 10982,\n\t    Verbar: 8214,\n\t    Vvdash: 8874,\n\t    Yacute: 221,\n\t    Zacute: 377,\n\t    Zcaron: 381,\n\t    aacute: 225,\n\t    abreve: 259,\n\t    agrave: 224,\n\t    andand: 10837,\n\t    angmsd: 8737,\n\t    angsph: 8738,\n\t    apacir: 10863,\n\t    approx: 8776,\n\t    atilde: 227,\n\t    barvee: 8893,\n\t    barwed: 8965,\n\t    becaus: 8757,\n\t    bernou: 8492,\n\t    bigcap: 8898,\n\t    bigcup: 8899,\n\t    bigvee: 8897,\n\t    bkarow: 10509,\n\t    bottom: 8869,\n\t    bowtie: 8904,\n\t    boxbox: 10697,\n\t    bprime: 8245,\n\t    brvbar: 166,\n\t    bullet: 8226,\n\t    bumpeq: 8783,\n\t    cacute: 263,\n\t    capand: 10820,\n\t    capcap: 10827,\n\t    capcup: 10823,\n\t    capdot: 10816,\n\t    ccaron: 269,\n\t    ccedil: 231,\n\t    circeq: 8791,\n\t    cirmid: 10991,\n\t    colone: 8788,\n\t    commat: 64,\n\t    compfn: 8728,\n\t    conint: 8750,\n\t    coprod: 8720,\n\t    copysr: 8471,\n\t    cularr: 8630,\n\t    cupcap: 10822,\n\t    cupcup: 10826,\n\t    cupdot: 8845,\n\t    curarr: 8631,\n\t    curren: 164,\n\t    cylcty: 9005,\n\t    dagger: 8224,\n\t    daleth: 8504,\n\t    dcaron: 271,\n\t    dfisht: 10623,\n\t    divide: 247,\n\t    divonx: 8903,\n\t    dlcorn: 8990,\n\t    dlcrop: 8973,\n\t    dollar: 36,\n\t    drcorn: 8991,\n\t    drcrop: 8972,\n\t    dstrok: 273,\n\t    eacute: 233,\n\t    easter: 10862,\n\t    ecaron: 283,\n\t    ecolon: 8789,\n\t    egrave: 232,\n\t    egsdot: 10904,\n\t    elsdot: 10903,\n\t    emptyv: 8709,\n\t    emsp13: 8196,\n\t    emsp14: 8197,\n\t    eparsl: 10723,\n\t    eqcirc: 8790,\n\t    equals: 61,\n\t    equest: 8799,\n\t    female: 9792,\n\t    ffilig: 64259,\n\t    ffllig: 64260,\n\t    forall: 8704,\n\t    frac12: 189,\n\t    frac13: 8531,\n\t    frac14: 188,\n\t    frac15: 8533,\n\t    frac16: 8537,\n\t    frac18: 8539,\n\t    frac23: 8532,\n\t    frac25: 8534,\n\t    frac34: 190,\n\t    frac35: 8535,\n\t    frac38: 8540,\n\t    frac45: 8536,\n\t    frac56: 8538,\n\t    frac58: 8541,\n\t    frac78: 8542,\n\t    gacute: 501,\n\t    gammad: 989,\n\t    gbreve: 287,\n\t    gesdot: 10880,\n\t    gesles: 10900,\n\t    gtlPar: 10645,\n\t    gtrarr: 10616,\n\t    gtrdot: 8919,\n\t    gtrsim: 8819,\n\t    hairsp: 8202,\n\t    hamilt: 8459,\n\t    hardcy: 1098,\n\t    hearts: 9829,\n\t    hellip: 8230,\n\t    hercon: 8889,\n\t    homtht: 8763,\n\t    horbar: 8213,\n\t    hslash: 8463,\n\t    hstrok: 295,\n\t    hybull: 8259,\n\t    hyphen: 8208,\n\t    iacute: 237,\n\t    igrave: 236,\n\t    iiiint: 10764,\n\t    iinfin: 10716,\n\t    incare: 8453,\n\t    inodot: 305,\n\t    intcal: 8890,\n\t    iquest: 191,\n\t    isinsv: 8947,\n\t    itilde: 297,\n\t    jsercy: 1112,\n\t    kappav: 1008,\n\t    kcedil: 311,\n\t    kgreen: 312,\n\t    lAtail: 10523,\n\t    lacute: 314,\n\t    lagran: 8466,\n\t    lambda: 955,\n\t    langle: 10216,\n\t    larrfs: 10525,\n\t    larrhk: 8617,\n\t    larrlp: 8619,\n\t    larrpl: 10553,\n\t    larrtl: 8610,\n\t    latail: 10521,\n\t    lbrace: 123,\n\t    lbrack: 91,\n\t    lcaron: 318,\n\t    lcedil: 316,\n\t    ldquor: 8222,\n\t    lesdot: 10879,\n\t    lesges: 10899,\n\t    lfisht: 10620,\n\t    lfloor: 8970,\n\t    lharul: 10602,\n\t    llhard: 10603,\n\t    lmidot: 320,\n\t    lmoust: 9136,\n\t    loplus: 10797,\n\t    lowast: 8727,\n\t    lowbar: 95,\n\t    lparlt: 10643,\n\t    lrhard: 10605,\n\t    lsaquo: 8249,\n\t    lsquor: 8218,\n\t    lstrok: 322,\n\t    lthree: 8907,\n\t    ltimes: 8905,\n\t    ltlarr: 10614,\n\t    ltrPar: 10646,\n\t    mapsto: 8614,\n\t    marker: 9646,\n\t    mcomma: 10793,\n\t    midast: 42,\n\t    midcir: 10992,\n\t    middot: 183,\n\t    minusb: 8863,\n\t    minusd: 8760,\n\t    mnplus: 8723,\n\t    models: 8871,\n\t    mstpos: 8766,\n\t    nVDash: 8879,\n\t    nVdash: 8878,\n\t    nacute: 324,\n\t    ncaron: 328,\n\t    ncedil: 326,\n\t    nearhk: 10532,\n\t    nequiv: 8802,\n\t    nesear: 10536,\n\t    nexist: 8708,\n\t    nltrie: 8940,\n\t    nprcue: 8928,\n\t    nrtrie: 8941,\n\t    nsccue: 8929,\n\t    nsimeq: 8772,\n\t    ntilde: 241,\n\t    numero: 8470,\n\t    nvDash: 8877,\n\t    nvHarr: 10500,\n\t    nvdash: 8876,\n\t    nvlArr: 10498,\n\t    nvrArr: 10499,\n\t    nwarhk: 10531,\n\t    nwnear: 10535,\n\t    oacute: 243,\n\t    odblac: 337,\n\t    odsold: 10684,\n\t    ograve: 242,\n\t    ominus: 8854,\n\t    origof: 8886,\n\t    oslash: 248,\n\t    otilde: 245,\n\t    otimes: 8855,\n\t    parsim: 10995,\n\t    percnt: 37,\n\t    period: 46,\n\t    permil: 8240,\n\t    phmmat: 8499,\n\t    planck: 8463,\n\t    plankv: 8463,\n\t    plusdo: 8724,\n\t    plusdu: 10789,\n\t    plusmn: 177,\n\t    preceq: 10927,\n\t    primes: 8473,\n\t    prnsim: 8936,\n\t    propto: 8733,\n\t    prurel: 8880,\n\t    puncsp: 8200,\n\t    qprime: 8279,\n\t    rAtail: 10524,\n\t    racute: 341,\n\t    rangle: 10217,\n\t    rarrap: 10613,\n\t    rarrfs: 10526,\n\t    rarrhk: 8618,\n\t    rarrlp: 8620,\n\t    rarrpl: 10565,\n\t    rarrtl: 8611,\n\t    ratail: 10522,\n\t    rbrace: 125,\n\t    rbrack: 93,\n\t    rcaron: 345,\n\t    rcedil: 343,\n\t    rdquor: 8221,\n\t    rfisht: 10621,\n\t    rfloor: 8971,\n\t    rharul: 10604,\n\t    rmoust: 9137,\n\t    roplus: 10798,\n\t    rpargt: 10644,\n\t    rsaquo: 8250,\n\t    rsquor: 8217,\n\t    rthree: 8908,\n\t    rtimes: 8906,\n\t    sacute: 347,\n\t    scaron: 353,\n\t    scedil: 351,\n\t    scnsim: 8937,\n\t    searhk: 10533,\n\t    seswar: 10537,\n\t    sfrown: 8994,\n\t    shchcy: 1097,\n\t    sigmaf: 962,\n\t    sigmav: 962,\n\t    simdot: 10858,\n\t    smashp: 10803,\n\t    softcy: 1100,\n\t    solbar: 9023,\n\t    spades: 9824,\n\t    sqsube: 8849,\n\t    sqsupe: 8850,\n\t    square: 9633,\n\t    squarf: 9642,\n\t    ssetmn: 8726,\n\t    ssmile: 8995,\n\t    sstarf: 8902,\n\t    subdot: 10941,\n\t    subset: 8834,\n\t    subsim: 10951,\n\t    subsub: 10965,\n\t    subsup: 10963,\n\t    succeq: 10928,\n\t    supdot: 10942,\n\t    supset: 8835,\n\t    supsim: 10952,\n\t    supsub: 10964,\n\t    supsup: 10966,\n\t    swarhk: 10534,\n\t    swnwar: 10538,\n\t    target: 8982,\n\t    tcaron: 357,\n\t    tcedil: 355,\n\t    telrec: 8981,\n\t    there4: 8756,\n\t    thetav: 977,\n\t    thinsp: 8201,\n\t    thksim: 8764,\n\t    timesb: 8864,\n\t    timesd: 10800,\n\t    topbot: 9014,\n\t    topcir: 10993,\n\t    tprime: 8244,\n\t    tridot: 9708,\n\t    tstrok: 359,\n\t    uacute: 250,\n\t    ubreve: 365,\n\t    udblac: 369,\n\t    ufisht: 10622,\n\t    ugrave: 249,\n\t    ulcorn: 8988,\n\t    ulcrop: 8975,\n\t    urcorn: 8989,\n\t    urcrop: 8974,\n\t    utilde: 361,\n\t    vangrt: 10652,\n\t    varphi: 966,\n\t    varrho: 1009,\n\t    veebar: 8891,\n\t    vellip: 8942,\n\t    verbar: 124,\n\t    wedbar: 10847,\n\t    wedgeq: 8793,\n\t    weierp: 8472,\n\t    wreath: 8768,\n\t    xoplus: 10753,\n\t    xotime: 10754,\n\t    xsqcup: 10758,\n\t    xuplus: 10756,\n\t    xwedge: 8896,\n\t    yacute: 253,\n\t    zacute: 378,\n\t    zcaron: 382,\n\t    zeetrf: 8488,\n\t    AElig: 198,\n\t    Acirc: 194,\n\t    Alpha: 913,\n\t    Amacr: 256,\n\t    Aogon: 260,\n\t    Aring: 197,\n\t    Breve: 728,\n\t    Ccirc: 264,\n\t    Colon: 8759,\n\t    Cross: 10799,\n\t    Dashv: 10980,\n\t    Delta: 916,\n\t    Ecirc: 202,\n\t    Emacr: 274,\n\t    Eogon: 280,\n\t    Equal: 10869,\n\t    Gamma: 915,\n\t    Gcirc: 284,\n\t    Hacek: 711,\n\t    Hcirc: 292,\n\t    IJlig: 306,\n\t    Icirc: 206,\n\t    Imacr: 298,\n\t    Iogon: 302,\n\t    Iukcy: 1030,\n\t    Jcirc: 308,\n\t    Jukcy: 1028,\n\t    Kappa: 922,\n\t    OElig: 338,\n\t    Ocirc: 212,\n\t    Omacr: 332,\n\t    Omega: 937,\n\t    Prime: 8243,\n\t    RBarr: 10512,\n\t    Scirc: 348,\n\t    Sigma: 931,\n\t    THORN: 222,\n\t    TRADE: 8482,\n\t    TSHcy: 1035,\n\t    Theta: 920,\n\t    Tilde: 8764,\n\t    Ubrcy: 1038,\n\t    Ucirc: 219,\n\t    Umacr: 362,\n\t    Union: 8899,\n\t    Uogon: 370,\n\t    UpTee: 8869,\n\t    Uring: 366,\n\t    VDash: 8875,\n\t    Vdash: 8873,\n\t    Wcirc: 372,\n\t    Wedge: 8896,\n\t    Ycirc: 374,\n\t    acirc: 226,\n\t    acute: 180,\n\t    aelig: 230,\n\t    aleph: 8501,\n\t    alpha: 945,\n\t    amacr: 257,\n\t    amalg: 10815,\n\t    angle: 8736,\n\t    angrt: 8735,\n\t    angst: 8491,\n\t    aogon: 261,\n\t    aring: 229,\n\t    asymp: 8776,\n\t    awint: 10769,\n\t    bcong: 8780,\n\t    bdquo: 8222,\n\t    bepsi: 1014,\n\t    blank: 9251,\n\t    blk12: 9618,\n\t    blk14: 9617,\n\t    blk34: 9619,\n\t    block: 9608,\n\t    boxDL: 9559,\n\t    boxDR: 9556,\n\t    boxDl: 9558,\n\t    boxDr: 9555,\n\t    boxHD: 9574,\n\t    boxHU: 9577,\n\t    boxHd: 9572,\n\t    boxHu: 9575,\n\t    boxUL: 9565,\n\t    boxUR: 9562,\n\t    boxUl: 9564,\n\t    boxUr: 9561,\n\t    boxVH: 9580,\n\t    boxVL: 9571,\n\t    boxVR: 9568,\n\t    boxVh: 9579,\n\t    boxVl: 9570,\n\t    boxVr: 9567,\n\t    boxdL: 9557,\n\t    boxdR: 9554,\n\t    boxdl: 9488,\n\t    boxdr: 9484,\n\t    boxhD: 9573,\n\t    boxhU: 9576,\n\t    boxhd: 9516,\n\t    boxhu: 9524,\n\t    boxuL: 9563,\n\t    boxuR: 9560,\n\t    boxul: 9496,\n\t    boxur: 9492,\n\t    boxvH: 9578,\n\t    boxvL: 9569,\n\t    boxvR: 9566,\n\t    boxvh: 9532,\n\t    boxvl: 9508,\n\t    boxvr: 9500,\n\t    breve: 728,\n\t    bsemi: 8271,\n\t    bsime: 8909,\n\t    bsolb: 10693,\n\t    bumpE: 10926,\n\t    bumpe: 8783,\n\t    caret: 8257,\n\t    caron: 711,\n\t    ccaps: 10829,\n\t    ccirc: 265,\n\t    ccups: 10828,\n\t    cedil: 184,\n\t    check: 10003,\n\t    clubs: 9827,\n\t    colon: 58,\n\t    comma: 44,\n\t    crarr: 8629,\n\t    cross: 10007,\n\t    csube: 10961,\n\t    csupe: 10962,\n\t    ctdot: 8943,\n\t    cuepr: 8926,\n\t    cuesc: 8927,\n\t    cupor: 10821,\n\t    cuvee: 8910,\n\t    cuwed: 8911,\n\t    cwint: 8753,\n\t    dashv: 8867,\n\t    dblac: 733,\n\t    ddarr: 8650,\n\t    delta: 948,\n\t    dharl: 8643,\n\t    dharr: 8642,\n\t    diams: 9830,\n\t    disin: 8946,\n\t    doteq: 8784,\n\t    dtdot: 8945,\n\t    dtrif: 9662,\n\t    duarr: 8693,\n\t    duhar: 10607,\n\t    eDDot: 10871,\n\t    ecirc: 234,\n\t    efDot: 8786,\n\t    emacr: 275,\n\t    empty: 8709,\n\t    eogon: 281,\n\t    eplus: 10865,\n\t    epsiv: 949,\n\t    eqsim: 8770,\n\t    equiv: 8801,\n\t    erDot: 8787,\n\t    erarr: 10609,\n\t    esdot: 8784,\n\t    exist: 8707,\n\t    fflig: 64256,\n\t    filig: 64257,\n\t    fllig: 64258,\n\t    fltns: 9649,\n\t    forkv: 10969,\n\t    frasl: 8260,\n\t    frown: 8994,\n\t    gamma: 947,\n\t    gcirc: 285,\n\t    gescc: 10921,\n\t    gimel: 8503,\n\t    gneqq: 8809,\n\t    gnsim: 8935,\n\t    grave: 96,\n\t    gsime: 10894,\n\t    gsiml: 10896,\n\t    gtcir: 10874,\n\t    gtdot: 8919,\n\t    harrw: 8621,\n\t    hcirc: 293,\n\t    hoarr: 8703,\n\t    icirc: 238,\n\t    iexcl: 161,\n\t    iiint: 8749,\n\t    iiota: 8489,\n\t    ijlig: 307,\n\t    imacr: 299,\n\t    image: 8465,\n\t    imath: 305,\n\t    imped: 437,\n\t    infin: 8734,\n\t    iogon: 303,\n\t    iprod: 10812,\n\t    isinE: 8953,\n\t    isins: 8948,\n\t    isinv: 8712,\n\t    iukcy: 1110,\n\t    jcirc: 309,\n\t    jmath: 567,\n\t    jukcy: 1108,\n\t    kappa: 954,\n\t    lAarr: 8666,\n\t    lBarr: 10510,\n\t    langd: 10641,\n\t    laquo: 171,\n\t    larrb: 8676,\n\t    lbarr: 10508,\n\t    lbbrk: 10098,\n\t    lbrke: 10635,\n\t    lceil: 8968,\n\t    ldquo: 8220,\n\t    lescc: 10920,\n\t    lhard: 8637,\n\t    lharu: 8636,\n\t    lhblk: 9604,\n\t    llarr: 8647,\n\t    lltri: 9722,\n\t    lneqq: 8808,\n\t    lnsim: 8934,\n\t    loang: 10220,\n\t    loarr: 8701,\n\t    lobrk: 10214,\n\t    lopar: 10629,\n\t    lrarr: 8646,\n\t    lrhar: 8651,\n\t    lrtri: 8895,\n\t    lsime: 10893,\n\t    lsimg: 10895,\n\t    lsquo: 8216,\n\t    ltcir: 10873,\n\t    ltdot: 8918,\n\t    ltrie: 8884,\n\t    ltrif: 9666,\n\t    mDDot: 8762,\n\t    mdash: 8212,\n\t    micro: 181,\n\t    minus: 8722,\n\t    mumap: 8888,\n\t    nabla: 8711,\n\t    napos: 329,\n\t    natur: 9838,\n\t    ncong: 8775,\n\t    ndash: 8211,\n\t    neArr: 8663,\n\t    nearr: 8599,\n\t    ngsim: 8821,\n\t    nhArr: 8654,\n\t    nharr: 8622,\n\t    nhpar: 10994,\n\t    nlArr: 8653,\n\t    nlarr: 8602,\n\t    nless: 8814,\n\t    nlsim: 8820,\n\t    nltri: 8938,\n\t    notin: 8713,\n\t    notni: 8716,\n\t    nprec: 8832,\n\t    nrArr: 8655,\n\t    nrarr: 8603,\n\t    nrtri: 8939,\n\t    nsime: 8772,\n\t    nsmid: 8740,\n\t    nspar: 8742,\n\t    nsube: 8840,\n\t    nsucc: 8833,\n\t    nsupe: 8841,\n\t    numsp: 8199,\n\t    nwArr: 8662,\n\t    nwarr: 8598,\n\t    ocirc: 244,\n\t    odash: 8861,\n\t    oelig: 339,\n\t    ofcir: 10687,\n\t    ohbar: 10677,\n\t    olarr: 8634,\n\t    olcir: 10686,\n\t    oline: 8254,\n\t    omacr: 333,\n\t    omega: 969,\n\t    operp: 10681,\n\t    oplus: 8853,\n\t    orarr: 8635,\n\t    order: 8500,\n\t    ovbar: 9021,\n\t    parsl: 11005,\n\t    phone: 9742,\n\t    plusb: 8862,\n\t    pluse: 10866,\n\t    pound: 163,\n\t    prcue: 8828,\n\t    prime: 8242,\n\t    prnap: 10937,\n\t    prsim: 8830,\n\t    quest: 63,\n\t    rAarr: 8667,\n\t    rBarr: 10511,\n\t    radic: 8730,\n\t    rangd: 10642,\n\t    range: 10661,\n\t    raquo: 187,\n\t    rarrb: 8677,\n\t    rarrc: 10547,\n\t    rarrw: 8605,\n\t    ratio: 8758,\n\t    rbarr: 10509,\n\t    rbbrk: 10099,\n\t    rbrke: 10636,\n\t    rceil: 8969,\n\t    rdquo: 8221,\n\t    reals: 8477,\n\t    rhard: 8641,\n\t    rharu: 8640,\n\t    rlarr: 8644,\n\t    rlhar: 8652,\n\t    rnmid: 10990,\n\t    roang: 10221,\n\t    roarr: 8702,\n\t    robrk: 10215,\n\t    ropar: 10630,\n\t    rrarr: 8649,\n\t    rsquo: 8217,\n\t    rtrie: 8885,\n\t    rtrif: 9656,\n\t    sbquo: 8218,\n\t    sccue: 8829,\n\t    scirc: 349,\n\t    scnap: 10938,\n\t    scsim: 8831,\n\t    sdotb: 8865,\n\t    sdote: 10854,\n\t    seArr: 8664,\n\t    searr: 8600,\n\t    setmn: 8726,\n\t    sharp: 9839,\n\t    sigma: 963,\n\t    simeq: 8771,\n\t    simgE: 10912,\n\t    simlE: 10911,\n\t    simne: 8774,\n\t    slarr: 8592,\n\t    smile: 8995,\n\t    sqcap: 8851,\n\t    sqcup: 8852,\n\t    sqsub: 8847,\n\t    sqsup: 8848,\n\t    srarr: 8594,\n\t    starf: 9733,\n\t    strns: 175,\n\t    subnE: 10955,\n\t    subne: 8842,\n\t    supnE: 10956,\n\t    supne: 8843,\n\t    swArr: 8665,\n\t    swarr: 8601,\n\t    szlig: 223,\n\t    theta: 952,\n\t    thkap: 8776,\n\t    thorn: 254,\n\t    tilde: 732,\n\t    times: 215,\n\t    trade: 8482,\n\t    trisb: 10701,\n\t    tshcy: 1115,\n\t    twixt: 8812,\n\t    ubrcy: 1118,\n\t    ucirc: 251,\n\t    udarr: 8645,\n\t    udhar: 10606,\n\t    uharl: 8639,\n\t    uharr: 8638,\n\t    uhblk: 9600,\n\t    ultri: 9720,\n\t    umacr: 363,\n\t    uogon: 371,\n\t    uplus: 8846,\n\t    upsih: 978,\n\t    uring: 367,\n\t    urtri: 9721,\n\t    utdot: 8944,\n\t    utrif: 9652,\n\t    uuarr: 8648,\n\t    vBarv: 10985,\n\t    vDash: 8872,\n\t    varpi: 982,\n\t    vdash: 8866,\n\t    veeeq: 8794,\n\t    vltri: 8882,\n\t    vprop: 8733,\n\t    vrtri: 8883,\n\t    wcirc: 373,\n\t    wedge: 8743,\n\t    xcirc: 9711,\n\t    xdtri: 9661,\n\t    xhArr: 10234,\n\t    xharr: 10231,\n\t    xlArr: 10232,\n\t    xlarr: 10229,\n\t    xodot: 10752,\n\t    xrArr: 10233,\n\t    xrarr: 10230,\n\t    xutri: 9651,\n\t    ycirc: 375,\n\t    Aopf: 120120,\n\t    Ascr: 119964,\n\t    Auml: 196,\n\t    Barv: 10983,\n\t    Beta: 914,\n\t    Bopf: 120121,\n\t    Bscr: 8492,\n\t    CHcy: 1063,\n\t    COPY: 169,\n\t    Cdot: 266,\n\t    Copf: 8450,\n\t    Cscr: 119966,\n\t    DJcy: 1026,\n\t    DScy: 1029,\n\t    DZcy: 1039,\n\t    Darr: 8609,\n\t    Dopf: 120123,\n\t    Dscr: 119967,\n\t    Edot: 278,\n\t    Eopf: 120124,\n\t    Escr: 8496,\n\t    Esim: 10867,\n\t    Euml: 203,\n\t    Fopf: 120125,\n\t    Fscr: 8497,\n\t    GJcy: 1027,\n\t    Gdot: 288,\n\t    Gopf: 120126,\n\t    Gscr: 119970,\n\t    Hopf: 8461,\n\t    Hscr: 8459,\n\t    IEcy: 1045,\n\t    IOcy: 1025,\n\t    Idot: 304,\n\t    Iopf: 120128,\n\t    Iota: 921,\n\t    Iscr: 8464,\n\t    Iuml: 207,\n\t    Jopf: 120129,\n\t    Jscr: 119973,\n\t    KHcy: 1061,\n\t    KJcy: 1036,\n\t    Kopf: 120130,\n\t    Kscr: 119974,\n\t    LJcy: 1033,\n\t    Lang: 10218,\n\t    Larr: 8606,\n\t    Lopf: 120131,\n\t    Lscr: 8466,\n\t    Mopf: 120132,\n\t    Mscr: 8499,\n\t    NJcy: 1034,\n\t    Nopf: 8469,\n\t    Nscr: 119977,\n\t    Oopf: 120134,\n\t    Oscr: 119978,\n\t    Ouml: 214,\n\t    Popf: 8473,\n\t    Pscr: 119979,\n\t    QUOT: 34,\n\t    Qopf: 8474,\n\t    Qscr: 119980,\n\t    Rang: 10219,\n\t    Rarr: 8608,\n\t    Ropf: 8477,\n\t    Rscr: 8475,\n\t    SHcy: 1064,\n\t    Sopf: 120138,\n\t    Sqrt: 8730,\n\t    Sscr: 119982,\n\t    Star: 8902,\n\t    TScy: 1062,\n\t    Topf: 120139,\n\t    Tscr: 119983,\n\t    Uarr: 8607,\n\t    Uopf: 120140,\n\t    Upsi: 978,\n\t    Uscr: 119984,\n\t    Uuml: 220,\n\t    Vbar: 10987,\n\t    Vert: 8214,\n\t    Vopf: 120141,\n\t    Vscr: 119985,\n\t    Wopf: 120142,\n\t    Wscr: 119986,\n\t    Xopf: 120143,\n\t    Xscr: 119987,\n\t    YAcy: 1071,\n\t    YIcy: 1031,\n\t    YUcy: 1070,\n\t    Yopf: 120144,\n\t    Yscr: 119988,\n\t    Yuml: 376,\n\t    ZHcy: 1046,\n\t    Zdot: 379,\n\t    Zeta: 918,\n\t    Zopf: 8484,\n\t    Zscr: 119989,\n\t    andd: 10844,\n\t    andv: 10842,\n\t    ange: 10660,\n\t    aopf: 120146,\n\t    apid: 8779,\n\t    apos: 39,\n\t    ascr: 119990,\n\t    auml: 228,\n\t    bNot: 10989,\n\t    bbrk: 9141,\n\t    beta: 946,\n\t    beth: 8502,\n\t    bnot: 8976,\n\t    bopf: 120147,\n\t    boxH: 9552,\n\t    boxV: 9553,\n\t    boxh: 9472,\n\t    boxv: 9474,\n\t    bscr: 119991,\n\t    bsim: 8765,\n\t    bsol: 92,\n\t    bull: 8226,\n\t    bump: 8782,\n\t    cdot: 267,\n\t    cent: 162,\n\t    chcy: 1095,\n\t    cirE: 10691,\n\t    circ: 710,\n\t    cire: 8791,\n\t    comp: 8705,\n\t    cong: 8773,\n\t    copf: 120148,\n\t    copy: 169,\n\t    cscr: 119992,\n\t    csub: 10959,\n\t    csup: 10960,\n\t    dArr: 8659,\n\t    dHar: 10597,\n\t    darr: 8595,\n\t    dash: 8208,\n\t    diam: 8900,\n\t    djcy: 1106,\n\t    dopf: 120149,\n\t    dscr: 119993,\n\t    dscy: 1109,\n\t    dsol: 10742,\n\t    dtri: 9663,\n\t    dzcy: 1119,\n\t    eDot: 8785,\n\t    ecir: 8790,\n\t    edot: 279,\n\t    emsp: 8195,\n\t    ensp: 8194,\n\t    eopf: 120150,\n\t    epar: 8917,\n\t    epsi: 1013,\n\t    escr: 8495,\n\t    esim: 8770,\n\t    euml: 235,\n\t    euro: 8364,\n\t    excl: 33,\n\t    flat: 9837,\n\t    fnof: 402,\n\t    fopf: 120151,\n\t    fork: 8916,\n\t    fscr: 119995,\n\t    gdot: 289,\n\t    geqq: 8807,\n\t    gjcy: 1107,\n\t    gnap: 10890,\n\t    gneq: 10888,\n\t    gopf: 120152,\n\t    gscr: 8458,\n\t    gsim: 8819,\n\t    gtcc: 10919,\n\t    hArr: 8660,\n\t    half: 189,\n\t    harr: 8596,\n\t    hbar: 8463,\n\t    hopf: 120153,\n\t    hscr: 119997,\n\t    iecy: 1077,\n\t    imof: 8887,\n\t    iocy: 1105,\n\t    iopf: 120154,\n\t    iota: 953,\n\t    iscr: 119998,\n\t    isin: 8712,\n\t    iuml: 239,\n\t    jopf: 120155,\n\t    jscr: 119999,\n\t    khcy: 1093,\n\t    kjcy: 1116,\n\t    kopf: 120156,\n\t    kscr: 120000,\n\t    lArr: 8656,\n\t    lHar: 10594,\n\t    lang: 10216,\n\t    larr: 8592,\n\t    late: 10925,\n\t    lcub: 123,\n\t    ldca: 10550,\n\t    ldsh: 8626,\n\t    leqq: 8806,\n\t    ljcy: 1113,\n\t    lnap: 10889,\n\t    lneq: 10887,\n\t    lopf: 120157,\n\t    lozf: 10731,\n\t    lpar: 40,\n\t    lscr: 120001,\n\t    lsim: 8818,\n\t    lsqb: 91,\n\t    ltcc: 10918,\n\t    ltri: 9667,\n\t    macr: 175,\n\t    male: 9794,\n\t    malt: 10016,\n\t    mlcp: 10971,\n\t    mldr: 8230,\n\t    mopf: 120158,\n\t    mscr: 120002,\n\t    nbsp: 160,\n\t    ncap: 10819,\n\t    ncup: 10818,\n\t    ngeq: 8817,\n\t    ngtr: 8815,\n\t    nisd: 8954,\n\t    njcy: 1114,\n\t    nldr: 8229,\n\t    nleq: 8816,\n\t    nmid: 8740,\n\t    nopf: 120159,\n\t    npar: 8742,\n\t    nscr: 120003,\n\t    nsim: 8769,\n\t    nsub: 8836,\n\t    nsup: 8837,\n\t    ntgl: 8825,\n\t    ntlg: 8824,\n\t    oast: 8859,\n\t    ocir: 8858,\n\t    odiv: 10808,\n\t    odot: 8857,\n\t    ogon: 731,\n\t    oint: 8750,\n\t    omid: 10678,\n\t    oopf: 120160,\n\t    opar: 10679,\n\t    ordf: 170,\n\t    ordm: 186,\n\t    oror: 10838,\n\t    oscr: 8500,\n\t    osol: 8856,\n\t    ouml: 246,\n\t    para: 182,\n\t    part: 8706,\n\t    perp: 8869,\n\t    phiv: 966,\n\t    plus: 43,\n\t    popf: 120161,\n\t    prap: 10935,\n\t    prec: 8826,\n\t    prnE: 10933,\n\t    prod: 8719,\n\t    prop: 8733,\n\t    pscr: 120005,\n\t    qint: 10764,\n\t    qopf: 120162,\n\t    qscr: 120006,\n\t    quot: 34,\n\t    rArr: 8658,\n\t    rHar: 10596,\n\t    race: 10714,\n\t    rang: 10217,\n\t    rarr: 8594,\n\t    rcub: 125,\n\t    rdca: 10551,\n\t    rdsh: 8627,\n\t    real: 8476,\n\t    rect: 9645,\n\t    rhov: 1009,\n\t    ring: 730,\n\t    ropf: 120163,\n\t    rpar: 41,\n\t    rscr: 120007,\n\t    rsqb: 93,\n\t    rtri: 9657,\n\t    scap: 10936,\n\t    scnE: 10934,\n\t    sdot: 8901,\n\t    sect: 167,\n\t    semi: 59,\n\t    sext: 10038,\n\t    shcy: 1096,\n\t    sime: 8771,\n\t    simg: 10910,\n\t    siml: 10909,\n\t    smid: 8739,\n\t    smte: 10924,\n\t    solb: 10692,\n\t    sopf: 120164,\n\t    spar: 8741,\n\t    squf: 9642,\n\t    sscr: 120008,\n\t    star: 9734,\n\t    subE: 10949,\n\t    sube: 8838,\n\t    succ: 8827,\n\t    sung: 9834,\n\t    sup1: 185,\n\t    sup2: 178,\n\t    sup3: 179,\n\t    supE: 10950,\n\t    supe: 8839,\n\t    tbrk: 9140,\n\t    tdot: 8411,\n\t    tint: 8749,\n\t    toea: 10536,\n\t    topf: 120165,\n\t    tosa: 10537,\n\t    trie: 8796,\n\t    tscr: 120009,\n\t    tscy: 1094,\n\t    uArr: 8657,\n\t    uHar: 10595,\n\t    uarr: 8593,\n\t    uopf: 120166,\n\t    upsi: 965,\n\t    uscr: 120010,\n\t    utri: 9653,\n\t    uuml: 252,\n\t    vArr: 8661,\n\t    vBar: 10984,\n\t    varr: 8597,\n\t    vert: 124,\n\t    vopf: 120167,\n\t    vscr: 120011,\n\t    wopf: 120168,\n\t    wscr: 120012,\n\t    xcap: 8898,\n\t    xcup: 8899,\n\t    xmap: 10236,\n\t    xnis: 8955,\n\t    xopf: 120169,\n\t    xscr: 120013,\n\t    xvee: 8897,\n\t    yacy: 1103,\n\t    yicy: 1111,\n\t    yopf: 120170,\n\t    yscr: 120014,\n\t    yucy: 1102,\n\t    yuml: 255,\n\t    zdot: 380,\n\t    zeta: 950,\n\t    zhcy: 1078,\n\t    zopf: 120171,\n\t    zscr: 120015,\n\t    zwnj: 8204,\n\t    AMP: 38,\n\t    Acy: 1040,\n\t    Afr: 120068,\n\t    And: 10835,\n\t    Bcy: 1041,\n\t    Bfr: 120069,\n\t    Cap: 8914,\n\t    Cfr: 8493,\n\t    Chi: 935,\n\t    Cup: 8915,\n\t    Dcy: 1044,\n\t    Del: 8711,\n\t    Dfr: 120071,\n\t    Dot: 168,\n\t    ENG: 330,\n\t    ETH: 208,\n\t    Ecy: 1069,\n\t    Efr: 120072,\n\t    Eta: 919,\n\t    Fcy: 1060,\n\t    Ffr: 120073,\n\t    Gcy: 1043,\n\t    Gfr: 120074,\n\t    Hat: 94,\n\t    Hfr: 8460,\n\t    Icy: 1048,\n\t    Ifr: 8465,\n\t    Int: 8748,\n\t    Jcy: 1049,\n\t    Jfr: 120077,\n\t    Kcy: 1050,\n\t    Kfr: 120078,\n\t    Lcy: 1051,\n\t    Lfr: 120079,\n\t    Lsh: 8624,\n\t    Map: 10501,\n\t    Mcy: 1052,\n\t    Mfr: 120080,\n\t    Ncy: 1053,\n\t    Nfr: 120081,\n\t    Not: 10988,\n\t    Ocy: 1054,\n\t    Ofr: 120082,\n\t    Pcy: 1055,\n\t    Pfr: 120083,\n\t    Phi: 934,\n\t    Psi: 936,\n\t    Qfr: 120084,\n\t    REG: 174,\n\t    Rcy: 1056,\n\t    Rfr: 8476,\n\t    Rho: 929,\n\t    Rsh: 8625,\n\t    Scy: 1057,\n\t    Sfr: 120086,\n\t    Sub: 8912,\n\t    Sum: 8721,\n\t    Sup: 8913,\n\t    Tab: 9,\n\t    Tau: 932,\n\t    Tcy: 1058,\n\t    Tfr: 120087,\n\t    Ucy: 1059,\n\t    Ufr: 120088,\n\t    Vcy: 1042,\n\t    Vee: 8897,\n\t    Vfr: 120089,\n\t    Wfr: 120090,\n\t    Xfr: 120091,\n\t    Ycy: 1067,\n\t    Yfr: 120092,\n\t    Zcy: 1047,\n\t    Zfr: 8488,\n\t    acd: 8767,\n\t    acy: 1072,\n\t    afr: 120094,\n\t    amp: 38,\n\t    and: 8743,\n\t    ang: 8736,\n\t    apE: 10864,\n\t    ape: 8778,\n\t    ast: 42,\n\t    bcy: 1073,\n\t    bfr: 120095,\n\t    bot: 8869,\n\t    cap: 8745,\n\t    cfr: 120096,\n\t    chi: 967,\n\t    cir: 9675,\n\t    cup: 8746,\n\t    dcy: 1076,\n\t    deg: 176,\n\t    dfr: 120097,\n\t    die: 168,\n\t    div: 247,\n\t    dot: 729,\n\t    ecy: 1101,\n\t    efr: 120098,\n\t    egs: 10902,\n\t    ell: 8467,\n\t    els: 10901,\n\t    eng: 331,\n\t    eta: 951,\n\t    eth: 240,\n\t    fcy: 1092,\n\t    ffr: 120099,\n\t    gEl: 10892,\n\t    gap: 10886,\n\t    gcy: 1075,\n\t    gel: 8923,\n\t    geq: 8805,\n\t    ges: 10878,\n\t    gfr: 120100,\n\t    ggg: 8921,\n\t    glE: 10898,\n\t    gla: 10917,\n\t    glj: 10916,\n\t    gnE: 8809,\n\t    gne: 10888,\n\t    hfr: 120101,\n\t    icy: 1080,\n\t    iff: 8660,\n\t    ifr: 120102,\n\t    int: 8747,\n\t    jcy: 1081,\n\t    jfr: 120103,\n\t    kcy: 1082,\n\t    kfr: 120104,\n\t    lEg: 10891,\n\t    lap: 10885,\n\t    lat: 10923,\n\t    lcy: 1083,\n\t    leg: 8922,\n\t    leq: 8804,\n\t    les: 10877,\n\t    lfr: 120105,\n\t    lgE: 10897,\n\t    lnE: 8808,\n\t    lne: 10887,\n\t    loz: 9674,\n\t    lrm: 8206,\n\t    lsh: 8624,\n\t    map: 8614,\n\t    mcy: 1084,\n\t    mfr: 120106,\n\t    mho: 8487,\n\t    mid: 8739,\n\t    nap: 8777,\n\t    ncy: 1085,\n\t    nfr: 120107,\n\t    nge: 8817,\n\t    ngt: 8815,\n\t    nis: 8956,\n\t    niv: 8715,\n\t    nle: 8816,\n\t    nlt: 8814,\n\t    not: 172,\n\t    npr: 8832,\n\t    nsc: 8833,\n\t    num: 35,\n\t    ocy: 1086,\n\t    ofr: 120108,\n\t    ogt: 10689,\n\t    ohm: 8486,\n\t    olt: 10688,\n\t    ord: 10845,\n\t    orv: 10843,\n\t    par: 8741,\n\t    pcy: 1087,\n\t    pfr: 120109,\n\t    phi: 966,\n\t    piv: 982,\n\t    prE: 10931,\n\t    pre: 10927,\n\t    psi: 968,\n\t    qfr: 120110,\n\t    rcy: 1088,\n\t    reg: 174,\n\t    rfr: 120111,\n\t    rho: 961,\n\t    rlm: 8207,\n\t    rsh: 8625,\n\t    scE: 10932,\n\t    sce: 10928,\n\t    scy: 1089,\n\t    sfr: 120112,\n\t    shy: 173,\n\t    sim: 8764,\n\t    smt: 10922,\n\t    sol: 47,\n\t    squ: 9633,\n\t    sub: 8834,\n\t    sum: 8721,\n\t    sup: 8835,\n\t    tau: 964,\n\t    tcy: 1090,\n\t    tfr: 120113,\n\t    top: 8868,\n\t    ucy: 1091,\n\t    ufr: 120114,\n\t    uml: 168,\n\t    vcy: 1074,\n\t    vee: 8744,\n\t    vfr: 120115,\n\t    wfr: 120116,\n\t    xfr: 120117,\n\t    ycy: 1099,\n\t    yen: 165,\n\t    yfr: 120118,\n\t    zcy: 1079,\n\t    zfr: 120119,\n\t    zwj: 8205,\n\t    DD: 8517,\n\t    GT: 62,\n\t    Gg: 8921,\n\t    Gt: 8811,\n\t    Im: 8465,\n\t    LT: 60,\n\t    Ll: 8920,\n\t    Lt: 8810,\n\t    Mu: 924,\n\t    Nu: 925,\n\t    Or: 10836,\n\t    Pi: 928,\n\t    Pr: 10939,\n\t    Re: 8476,\n\t    Sc: 10940,\n\t    Xi: 926,\n\t    ac: 8766,\n\t    af: 8289,\n\t    ap: 8776,\n\t    dd: 8518,\n\t    ee: 8519,\n\t    eg: 10906,\n\t    el: 10905,\n\t    gE: 8807,\n\t    ge: 8805,\n\t    gg: 8811,\n\t    gl: 8823,\n\t    gt: 62,\n\t    ic: 8291,\n\t    ii: 8520,\n\t    in: 8712,\n\t    it: 8290,\n\t    lE: 8806,\n\t    le: 8804,\n\t    lg: 8822,\n\t    ll: 8810,\n\t    lt: 60,\n\t    mp: 8723,\n\t    mu: 956,\n\t    ne: 8800,\n\t    ni: 8715,\n\t    nu: 957,\n\t    oS: 9416,\n\t    or: 8744,\n\t    pi: 960,\n\t    pm: 177,\n\t    pr: 8826,\n\t    rx: 8478,\n\t    sc: 8827,\n\t    wp: 8472,\n\t    wr: 8768,\n\t    xi: 958,\n\t};\n\n\tconst windows_1252 = [\n\t    8364,\n\t    129,\n\t    8218,\n\t    402,\n\t    8222,\n\t    8230,\n\t    8224,\n\t    8225,\n\t    710,\n\t    8240,\n\t    352,\n\t    8249,\n\t    338,\n\t    141,\n\t    381,\n\t    143,\n\t    144,\n\t    8216,\n\t    8217,\n\t    8220,\n\t    8221,\n\t    8226,\n\t    8211,\n\t    8212,\n\t    732,\n\t    8482,\n\t    353,\n\t    8250,\n\t    339,\n\t    157,\n\t    382,\n\t    376,\n\t];\n\tconst entity_pattern = new RegExp(`&(#?(?:x[\\\\w\\\\d]+|\\\\d+|${Object.keys(entities).join('|')}))(?:;|\\\\b)`, 'g');\n\tfunction decode_character_references(html) {\n\t    return html.replace(entity_pattern, (match, entity) => {\n\t        let code;\n\t        // Handle named entities\n\t        if (entity[0] !== '#') {\n\t            code = entities[entity];\n\t        }\n\t        else if (entity[1] === 'x') {\n\t            code = parseInt(entity.substring(2), 16);\n\t        }\n\t        else {\n\t            code = parseInt(entity.substring(1), 10);\n\t        }\n\t        if (!code) {\n\t            return match;\n\t        }\n\t        return String.fromCodePoint(validate_code(code));\n\t    });\n\t}\n\tconst NUL = 0;\n\t// some code points are verboten. If we were inserting HTML, the browser would replace the illegal\n\t// code points with alternatives in some cases - since we're bypassing that mechanism, we need\n\t// to replace them ourselves\n\t//\n\t// Source: http://en.wikipedia.org/wiki/Character_encodings_in_HTML#Illegal_characters\n\tfunction validate_code(code) {\n\t    // line feed becomes generic whitespace\n\t    if (code === 10) {\n\t        return 32;\n\t    }\n\t    // ASCII range. (Why someone would use HTML entities for ASCII characters I don't know, but...)\n\t    if (code < 128) {\n\t        return code;\n\t    }\n\t    // code points 128-159 are dealt with leniently by browsers, but they're incorrect. We need\n\t    // to correct the mistake or we'll end up with missing \u20AC signs and so on\n\t    if (code <= 159) {\n\t        return windows_1252[code - 128];\n\t    }\n\t    // basic multilingual plane\n\t    if (code < 55296) {\n\t        return code;\n\t    }\n\t    // UTF-16 surrogate halves\n\t    if (code <= 57343) {\n\t        return NUL;\n\t    }\n\t    // rest of the basic multilingual plane\n\t    if (code <= 65535) {\n\t        return code;\n\t    }\n\t    // supplementary multilingual plane 0x10000 - 0x1ffff\n\t    if (code >= 65536 && code <= 131071) {\n\t        return code;\n\t    }\n\t    // supplementary ideographic plane 0x20000 - 0x2ffff\n\t    if (code >= 131072 && code <= 196607) {\n\t        return code;\n\t    }\n\t    return NUL;\n\t}\n\t// based on http://developers.whatwg.org/syntax.html#syntax-tag-omission\n\tconst disallowed_contents = new Map([\n\t    ['li', new Set(['li'])],\n\t    ['dt', new Set(['dt', 'dd'])],\n\t    ['dd', new Set(['dt', 'dd'])],\n\t    [\n\t        'p',\n\t        new Set('address article aside blockquote div dl fieldset footer form h1 h2 h3 h4 h5 h6 header hgroup hr main menu nav ol p pre section table ul'.split(' ')),\n\t    ],\n\t    ['rt', new Set(['rt', 'rp'])],\n\t    ['rp', new Set(['rt', 'rp'])],\n\t    ['optgroup', new Set(['optgroup'])],\n\t    ['option', new Set(['option', 'optgroup'])],\n\t    ['thead', new Set(['tbody', 'tfoot'])],\n\t    ['tbody', new Set(['tbody', 'tfoot'])],\n\t    ['tfoot', new Set(['tbody'])],\n\t    ['tr', new Set(['tr', 'tbody'])],\n\t    ['td', new Set(['td', 'th', 'tr'])],\n\t    ['th', new Set(['td', 'th', 'tr'])],\n\t]);\n\t// can this be a child of the parent element, or does it implicitly\n\t// close it, like `<li>one<li>two`?\n\tfunction closing_tag_omitted(current, next) {\n\t    if (disallowed_contents.has(current)) {\n\t        if (!next || disallowed_contents.get(current).has(next)) {\n\t            return true;\n\t        }\n\t    }\n\t    return false;\n\t}\n\n\t// Adapted from https://github.com/acornjs/acorn/blob/6584815dca7440e00de841d1dad152302fdd7ca5/src/tokenize.js\n\t// Reproduced under MIT License https://github.com/acornjs/acorn/blob/master/LICENSE\n\tfunction full_char_code_at(str, i) {\n\t    const code = str.charCodeAt(i);\n\t    if (code <= 0xd7ff || code >= 0xe000)\n\t        return code;\n\t    const next = str.charCodeAt(i + 1);\n\t    return (code << 10) + next - 0x35fdc00;\n\t}\n\n\tconst globals = new Set([\n\t    'alert',\n\t    'Array',\n\t    'Boolean',\n\t    'clearInterval',\n\t    'clearTimeout',\n\t    'confirm',\n\t    'console',\n\t    'Date',\n\t    'decodeURI',\n\t    'decodeURIComponent',\n\t    'document',\n\t    'encodeURI',\n\t    'encodeURIComponent',\n\t    'Error',\n\t    'EvalError',\n\t    'Event',\n\t    'fetch',\n\t    'global',\n\t    'globalThis',\n\t    'history',\n\t    'Infinity',\n\t    'InternalError',\n\t    'Intl',\n\t    'isFinite',\n\t    'isNaN',\n\t    'JSON',\n\t    'localStorage',\n\t    'location',\n\t    'Map',\n\t    'Math',\n\t    'NaN',\n\t    'navigator',\n\t    'Number',\n\t    'Object',\n\t    'parseFloat',\n\t    'parseInt',\n\t    'process',\n\t    'Promise',\n\t    'prompt',\n\t    'RangeError',\n\t    'ReferenceError',\n\t    'RegExp',\n\t    'sessionStorage',\n\t    'Set',\n\t    'setInterval',\n\t    'setTimeout',\n\t    'String',\n\t    'SyntaxError',\n\t    'TypeError',\n\t    'undefined',\n\t    'URIError',\n\t    'URL',\n\t    'window'\n\t]);\n\tconst reserved = new Set([\n\t    'arguments',\n\t    'await',\n\t    'break',\n\t    'case',\n\t    'catch',\n\t    'class',\n\t    'const',\n\t    'continue',\n\t    'debugger',\n\t    'default',\n\t    'delete',\n\t    'do',\n\t    'else',\n\t    'enum',\n\t    'eval',\n\t    'export',\n\t    'extends',\n\t    'false',\n\t    'finally',\n\t    'for',\n\t    'function',\n\t    'if',\n\t    'implements',\n\t    'import',\n\t    'in',\n\t    'instanceof',\n\t    'interface',\n\t    'let',\n\t    'new',\n\t    'null',\n\t    'package',\n\t    'private',\n\t    'protected',\n\t    'public',\n\t    'return',\n\t    'static',\n\t    'super',\n\t    'switch',\n\t    'this',\n\t    'throw',\n\t    'true',\n\t    'try',\n\t    'typeof',\n\t    'var',\n\t    'void',\n\t    'while',\n\t    'with',\n\t    'yield',\n\t]);\n\tconst void_element_names = /^(?:area|base|br|col|command|embed|hr|img|input|keygen|link|meta|param|source|track|wbr)$/;\n\tfunction is_void(name) {\n\t    return void_element_names.test(name) || name.toLowerCase() === '!doctype';\n\t}\n\tfunction is_valid(str) {\n\t    let i = 0;\n\t    while (i < str.length) {\n\t        const code = full_char_code_at(str, i);\n\t        if (!(i === 0 ? isIdentifierStart : isIdentifierChar)(code, true))\n\t            return false;\n\t        i += code <= 0xffff ? 1 : 2;\n\t    }\n\t    return true;\n\t}\n\tfunction sanitize(name) {\n\t    return name\n\t        .replace(/[^a-zA-Z0-9_]+/g, '_')\n\t        .replace(/^_/, '')\n\t        .replace(/_$/, '')\n\t        .replace(/^[0-9]/, '_$&');\n\t}\n\n\tfunction fuzzymatch(name, names) {\n\t    const set = new FuzzySet(names);\n\t    const matches = set.get(name);\n\t    return matches && matches[0] && matches[0][0] > 0.7 ? matches[0][1] : null;\n\t}\n\t// adapted from https://github.com/Glench/fuzzyset.js/blob/master/lib/fuzzyset.js\n\t// BSD Licensed\n\tconst GRAM_SIZE_LOWER = 2;\n\tconst GRAM_SIZE_UPPER = 3;\n\t// return an edit distance from 0 to 1\n\tfunction _distance(str1, str2) {\n\t    if (str1 === null && str2 === null)\n\t        throw 'Trying to compare two null values';\n\t    if (str1 === null || str2 === null)\n\t        return 0;\n\t    str1 = String(str1);\n\t    str2 = String(str2);\n\t    const distance = levenshtein(str1, str2);\n\t    if (str1.length > str2.length) {\n\t        return 1 - distance / str1.length;\n\t    }\n\t    else {\n\t        return 1 - distance / str2.length;\n\t    }\n\t}\n\t// helper functions\n\tfunction levenshtein(str1, str2) {\n\t    const current = [];\n\t    let prev;\n\t    let value;\n\t    for (let i = 0; i <= str2.length; i++) {\n\t        for (let j = 0; j <= str1.length; j++) {\n\t            if (i && j) {\n\t                if (str1.charAt(j - 1) === str2.charAt(i - 1)) {\n\t                    value = prev;\n\t                }\n\t                else {\n\t                    value = Math.min(current[j], current[j - 1], prev) + 1;\n\t                }\n\t            }\n\t            else {\n\t                value = i + j;\n\t            }\n\t            prev = current[j];\n\t            current[j] = value;\n\t        }\n\t    }\n\t    return current.pop();\n\t}\n\tconst non_word_regex = /[^\\w, ]+/;\n\tfunction iterate_grams(value, gram_size = 2) {\n\t    const simplified = '-' + value.toLowerCase().replace(non_word_regex, '') + '-';\n\t    const len_diff = gram_size - simplified.length;\n\t    const results = [];\n\t    if (len_diff > 0) {\n\t        for (let i = 0; i < len_diff; ++i) {\n\t            value += '-';\n\t        }\n\t    }\n\t    for (let i = 0; i < simplified.length - gram_size + 1; ++i) {\n\t        results.push(simplified.slice(i, i + gram_size));\n\t    }\n\t    return results;\n\t}\n\tfunction gram_counter(value, gram_size = 2) {\n\t    // return an object where key=gram, value=number of occurrences\n\t    const result = {};\n\t    const grams = iterate_grams(value, gram_size);\n\t    let i = 0;\n\t    for (i; i < grams.length; ++i) {\n\t        if (grams[i] in result) {\n\t            result[grams[i]] += 1;\n\t        }\n\t        else {\n\t            result[grams[i]] = 1;\n\t        }\n\t    }\n\t    return result;\n\t}\n\tfunction sort_descending(a, b) {\n\t    return b[0] - a[0];\n\t}\n\tclass FuzzySet {\n\t    constructor(arr) {\n\t        this.exact_set = {};\n\t        this.match_dict = {};\n\t        this.items = {};\n\t        // initialization\n\t        for (let i = GRAM_SIZE_LOWER; i < GRAM_SIZE_UPPER + 1; ++i) {\n\t            this.items[i] = [];\n\t        }\n\t        // add all the items to the set\n\t        for (let i = 0; i < arr.length; ++i) {\n\t            this.add(arr[i]);\n\t        }\n\t    }\n\t    add(value) {\n\t        const normalized_value = value.toLowerCase();\n\t        if (normalized_value in this.exact_set) {\n\t            return false;\n\t        }\n\t        let i = GRAM_SIZE_LOWER;\n\t        for (i; i < GRAM_SIZE_UPPER + 1; ++i) {\n\t            this._add(value, i);\n\t        }\n\t    }\n\t    _add(value, gram_size) {\n\t        const normalized_value = value.toLowerCase();\n\t        const items = this.items[gram_size] || [];\n\t        const index = items.length;\n\t        items.push(0);\n\t        const gram_counts = gram_counter(normalized_value, gram_size);\n\t        let sum_of_square_gram_counts = 0;\n\t        let gram;\n\t        let gram_count;\n\t        for (gram in gram_counts) {\n\t            gram_count = gram_counts[gram];\n\t            sum_of_square_gram_counts += Math.pow(gram_count, 2);\n\t            if (gram in this.match_dict) {\n\t                this.match_dict[gram].push([index, gram_count]);\n\t            }\n\t            else {\n\t                this.match_dict[gram] = [[index, gram_count]];\n\t            }\n\t        }\n\t        const vector_normal = Math.sqrt(sum_of_square_gram_counts);\n\t        items[index] = [vector_normal, normalized_value];\n\t        this.items[gram_size] = items;\n\t        this.exact_set[normalized_value] = value;\n\t    }\n\t    get(value) {\n\t        const normalized_value = value.toLowerCase();\n\t        const result = this.exact_set[normalized_value];\n\t        if (result) {\n\t            return [[1, result]];\n\t        }\n\t        let results = [];\n\t        // start with high gram size and if there are no results, go to lower gram sizes\n\t        for (let gram_size = GRAM_SIZE_UPPER; gram_size >= GRAM_SIZE_LOWER; --gram_size) {\n\t            results = this.__get(value, gram_size);\n\t            if (results) {\n\t                return results;\n\t            }\n\t        }\n\t        return null;\n\t    }\n\t    __get(value, gram_size) {\n\t        const normalized_value = value.toLowerCase();\n\t        const matches = {};\n\t        const gram_counts = gram_counter(normalized_value, gram_size);\n\t        const items = this.items[gram_size];\n\t        let sum_of_square_gram_counts = 0;\n\t        let gram;\n\t        let gram_count;\n\t        let i;\n\t        let index;\n\t        let other_gram_count;\n\t        for (gram in gram_counts) {\n\t            gram_count = gram_counts[gram];\n\t            sum_of_square_gram_counts += Math.pow(gram_count, 2);\n\t            if (gram in this.match_dict) {\n\t                for (i = 0; i < this.match_dict[gram].length; ++i) {\n\t                    index = this.match_dict[gram][i][0];\n\t                    other_gram_count = this.match_dict[gram][i][1];\n\t                    if (index in matches) {\n\t                        matches[index] += gram_count * other_gram_count;\n\t                    }\n\t                    else {\n\t                        matches[index] = gram_count * other_gram_count;\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        const vector_normal = Math.sqrt(sum_of_square_gram_counts);\n\t        let results = [];\n\t        let match_score;\n\t        // build a results list of [score, str]\n\t        for (const match_index in matches) {\n\t            match_score = matches[match_index];\n\t            results.push([\n\t                match_score / (vector_normal * items[match_index][0]),\n\t                items[match_index][1],\n\t            ]);\n\t        }\n\t        results.sort(sort_descending);\n\t        let new_results = [];\n\t        const end_index = Math.min(50, results.length);\n\t        // truncate somewhat arbitrarily to 50\n\t        for (let i = 0; i < end_index; ++i) {\n\t            new_results.push([\n\t                _distance(results[i][1], normalized_value),\n\t                results[i][1],\n\t            ]);\n\t        }\n\t        results = new_results;\n\t        results.sort(sort_descending);\n\t        new_results = [];\n\t        for (let i = 0; i < results.length; ++i) {\n\t            if (results[i][0] == results[0][0]) {\n\t                new_results.push([results[i][0], this.exact_set[results[i][1]]]);\n\t            }\n\t        }\n\t        return new_results;\n\t    }\n\t}\n\n\tfunction list$1(items, conjunction = 'or') {\n\t    if (items.length === 1)\n\t        return items[0];\n\t    return `${items.slice(0, -1).join(', ')} ${conjunction} ${items[items.length - 1]}`;\n\t}\n\n\t// eslint-disable-next-line no-useless-escape\n\tconst valid_tag_name = /^\\!?[a-zA-Z]{1,}:?[a-zA-Z0-9\\-]*/;\n\tconst meta_tags = new Map([\n\t    ['svelte:head', 'Head'],\n\t    ['svelte:options', 'Options'],\n\t    ['svelte:window', 'Window'],\n\t    ['svelte:body', 'Body']\n\t]);\n\tconst valid_meta_tags = Array.from(meta_tags.keys()).concat('svelte:self', 'svelte:component');\n\tconst specials = new Map([\n\t    [\n\t        'script',\n\t        {\n\t            read: read_script,\n\t            property: 'js',\n\t        },\n\t    ],\n\t    [\n\t        'style',\n\t        {\n\t            read: read_style,\n\t            property: 'css',\n\t        },\n\t    ],\n\t]);\n\tconst SELF = /^svelte:self(?=[\\s/>])/;\n\tconst COMPONENT = /^svelte:component(?=[\\s/>])/;\n\tfunction parent_is_head(stack) {\n\t    let i = stack.length;\n\t    while (i--) {\n\t        const { type } = stack[i];\n\t        if (type === 'Head')\n\t            return true;\n\t        if (type === 'Element' || type === 'InlineComponent')\n\t            return false;\n\t    }\n\t    return false;\n\t}\n\tfunction tag(parser) {\n\t    const start = parser.index++;\n\t    let parent = parser.current();\n\t    if (parser.eat('!--')) {\n\t        const data = parser.read_until(/-->/);\n\t        parser.eat('-->', true, 'comment was left open, expected -->');\n\t        parser.current().children.push({\n\t            start,\n\t            end: parser.index,\n\t            type: 'Comment',\n\t            data,\n\t        });\n\t        return;\n\t    }\n\t    const is_closing_tag = parser.eat('/');\n\t    const name = read_tag_name(parser);\n\t    if (meta_tags.has(name)) {\n\t        const slug = meta_tags.get(name).toLowerCase();\n\t        if (is_closing_tag) {\n\t            if ((name === 'svelte:window' || name === 'svelte:body') &&\n\t                parser.current().children.length) {\n\t                parser.error({\n\t                    code: `invalid-${slug}-content`,\n\t                    message: `<${name}> cannot have children`\n\t                }, parser.current().children[0].start);\n\t            }\n\t        }\n\t        else {\n\t            if (name in parser.meta_tags) {\n\t                parser.error({\n\t                    code: `duplicate-${slug}`,\n\t                    message: `A component can only have one <${name}> tag`\n\t                }, start);\n\t            }\n\t            if (parser.stack.length > 1) {\n\t                parser.error({\n\t                    code: `invalid-${slug}-placement`,\n\t                    message: `<${name}> tags cannot be inside elements or blocks`\n\t                }, start);\n\t            }\n\t            parser.meta_tags[name] = true;\n\t        }\n\t    }\n\t    const type = meta_tags.has(name)\n\t        ? meta_tags.get(name)\n\t        : (/[A-Z]/.test(name[0]) || name === 'svelte:self' || name === 'svelte:component') ? 'InlineComponent'\n\t            : name === 'title' && parent_is_head(parser.stack) ? 'Title'\n\t                : name === 'slot' && !parser.customElement ? 'Slot' : 'Element';\n\t    const element = {\n\t        start,\n\t        end: null,\n\t        type,\n\t        name,\n\t        attributes: [],\n\t        children: [],\n\t    };\n\t    parser.allow_whitespace();\n\t    if (is_closing_tag) {\n\t        if (is_void(name)) {\n\t            parser.error({\n\t                code: `invalid-void-content`,\n\t                message: `<${name}> is a void element and cannot have children, or a closing tag`\n\t            }, start);\n\t        }\n\t        parser.eat('>', true);\n\t        // close any elements that don't have their own closing tags, e.g. <div><p></div>\n\t        while (parent.name !== name) {\n\t            if (parent.type !== 'Element')\n\t                parser.error({\n\t                    code: `invalid-closing-tag`,\n\t                    message: `</${name}> attempted to close an element that was not open`\n\t                }, start);\n\t            parent.end = start;\n\t            parser.stack.pop();\n\t            parent = parser.current();\n\t        }\n\t        parent.end = parser.index;\n\t        parser.stack.pop();\n\t        return;\n\t    }\n\t    else if (closing_tag_omitted(parent.name, name)) {\n\t        parent.end = start;\n\t        parser.stack.pop();\n\t    }\n\t    const unique_names = new Set();\n\t    let attribute;\n\t    while ((attribute = read_attribute(parser, unique_names))) {\n\t        element.attributes.push(attribute);\n\t        parser.allow_whitespace();\n\t    }\n\t    if (name === 'svelte:component') {\n\t        const index = element.attributes.findIndex(attr => attr.type === 'Attribute' && attr.name === 'this');\n\t        if (!~index) {\n\t            parser.error({\n\t                code: `missing-component-definition`,\n\t                message: `<svelte:component> must have a 'this' attribute`\n\t            }, start);\n\t        }\n\t        const definition = element.attributes.splice(index, 1)[0];\n\t        if (definition.value === true || definition.value.length !== 1 || definition.value[0].type === 'Text') {\n\t            parser.error({\n\t                code: `invalid-component-definition`,\n\t                message: `invalid component definition`\n\t            }, definition.start);\n\t        }\n\t        element.expression = definition.value[0].expression;\n\t    }\n\t    // special cases \u2013 top-level <script> and <style>\n\t    if (specials.has(name) && parser.stack.length === 1) {\n\t        const special = specials.get(name);\n\t        parser.eat('>', true);\n\t        const content = special.read(parser, start, element.attributes);\n\t        if (content)\n\t            parser[special.property].push(content);\n\t        return;\n\t    }\n\t    parser.current().children.push(element);\n\t    const self_closing = parser.eat('/') || is_void(name);\n\t    parser.eat('>', true);\n\t    if (self_closing) {\n\t        // don't push self-closing elements onto the stack\n\t        element.end = parser.index;\n\t    }\n\t    else if (name === 'textarea') {\n\t        // special case\n\t        element.children = read_sequence(parser, () => parser.template.slice(parser.index, parser.index + 11) === '</textarea>');\n\t        parser.read(/<\\/textarea>/);\n\t        element.end = parser.index;\n\t    }\n\t    else if (name === 'script') {\n\t        // special case\n\t        const start = parser.index;\n\t        const data = parser.read_until(/<\\/script>/);\n\t        const end = parser.index;\n\t        element.children.push({ start, end, type: 'Text', data });\n\t        parser.eat('</script>', true);\n\t        element.end = parser.index;\n\t    }\n\t    else if (name === 'style') {\n\t        // special case\n\t        const start = parser.index;\n\t        const data = parser.read_until(/<\\/style>/);\n\t        const end = parser.index;\n\t        element.children.push({ start, end, type: 'Text', data });\n\t        parser.eat('</style>', true);\n\t    }\n\t    else {\n\t        parser.stack.push(element);\n\t    }\n\t}\n\tfunction read_tag_name(parser) {\n\t    const start = parser.index;\n\t    if (parser.read(SELF)) {\n\t        // check we're inside a block, otherwise this\n\t        // will cause infinite recursion\n\t        let i = parser.stack.length;\n\t        let legal = false;\n\t        while (i--) {\n\t            const fragment = parser.stack[i];\n\t            if (fragment.type === 'IfBlock' || fragment.type === 'EachBlock' || fragment.type === 'InlineComponent') {\n\t                legal = true;\n\t                break;\n\t            }\n\t        }\n\t        if (!legal) {\n\t            parser.error({\n\t                code: `invalid-self-placement`,\n\t                message: `<svelte:self> components can only exist inside {#if} blocks, {#each} blocks, or slots passed to components`\n\t            }, start);\n\t        }\n\t        return 'svelte:self';\n\t    }\n\t    if (parser.read(COMPONENT))\n\t        return 'svelte:component';\n\t    const name = parser.read_until(/(\\s|\\/|>)/);\n\t    if (meta_tags.has(name))\n\t        return name;\n\t    if (name.startsWith('svelte:')) {\n\t        const match = fuzzymatch(name.slice(7), valid_meta_tags);\n\t        let message = `Valid <svelte:...> tag names are ${list$1(valid_meta_tags)}`;\n\t        if (match)\n\t            message += ` (did you mean '${match}'?)`;\n\t        parser.error({\n\t            code: 'invalid-tag-name',\n\t            message\n\t        }, start);\n\t    }\n\t    if (!valid_tag_name.test(name)) {\n\t        parser.error({\n\t            code: `invalid-tag-name`,\n\t            message: `Expected valid tag name`\n\t        }, start);\n\t    }\n\t    return name;\n\t}\n\tfunction read_attribute(parser, unique_names) {\n\t    const start = parser.index;\n\t    function check_unique(name) {\n\t        if (unique_names.has(name)) {\n\t            parser.error({\n\t                code: `duplicate-attribute`,\n\t                message: 'Attributes need to be unique'\n\t            }, start);\n\t        }\n\t        unique_names.add(name);\n\t    }\n\t    if (parser.eat('{')) {\n\t        parser.allow_whitespace();\n\t        if (parser.eat('...')) {\n\t            const expression = read_expression(parser);\n\t            parser.allow_whitespace();\n\t            parser.eat('}', true);\n\t            return {\n\t                start,\n\t                end: parser.index,\n\t                type: 'Spread',\n\t                expression\n\t            };\n\t        }\n\t        else {\n\t            const value_start = parser.index;\n\t            const name = parser.read_identifier();\n\t            parser.allow_whitespace();\n\t            parser.eat('}', true);\n\t            check_unique(name);\n\t            return {\n\t                start,\n\t                end: parser.index,\n\t                type: 'Attribute',\n\t                name,\n\t                value: [{\n\t                        start: value_start,\n\t                        end: value_start + name.length,\n\t                        type: 'AttributeShorthand',\n\t                        expression: {\n\t                            start: value_start,\n\t                            end: value_start + name.length,\n\t                            type: 'Identifier',\n\t                            name\n\t                        }\n\t                    }]\n\t            };\n\t        }\n\t    }\n\t    // eslint-disable-next-line no-useless-escape\n\t    const name = parser.read_until(/[\\s=\\/>\"']/);\n\t    if (!name)\n\t        return null;\n\t    let end = parser.index;\n\t    parser.allow_whitespace();\n\t    const colon_index = name.indexOf(':');\n\t    const type = colon_index !== -1 && get_directive_type(name.slice(0, colon_index));\n\t    let value = true;\n\t    if (parser.eat('=')) {\n\t        parser.allow_whitespace();\n\t        value = read_attribute_value(parser);\n\t        end = parser.index;\n\t    }\n\t    else if (parser.match_regex(/[\"']/)) {\n\t        parser.error({\n\t            code: `unexpected-token`,\n\t            message: `Expected =`\n\t        }, parser.index);\n\t    }\n\t    if (type) {\n\t        const [directive_name, ...modifiers] = name.slice(colon_index + 1).split('|');\n\t        if (type === 'Binding' && directive_name !== 'this') {\n\t            check_unique(directive_name);\n\t        }\n\t        else if (type !== 'EventHandler') {\n\t            check_unique(name);\n\t        }\n\t        if (type === 'Ref') {\n\t            parser.error({\n\t                code: `invalid-ref-directive`,\n\t                message: `The ref directive is no longer supported \u2014 use \\`bind:this={${directive_name}}\\` instead`\n\t            }, start);\n\t        }\n\t        if (value[0]) {\n\t            if (value.length > 1 || value[0].type === 'Text') {\n\t                parser.error({\n\t                    code: `invalid-directive-value`,\n\t                    message: `Directive value must be a JavaScript expression enclosed in curly braces`\n\t                }, value[0].start);\n\t            }\n\t        }\n\t        const directive = {\n\t            start,\n\t            end,\n\t            type,\n\t            name: directive_name,\n\t            modifiers,\n\t            expression: (value[0] && value[0].expression) || null\n\t        };\n\t        if (type === 'Transition') {\n\t            const direction = name.slice(0, colon_index);\n\t            directive.intro = direction === 'in' || direction === 'transition';\n\t            directive.outro = direction === 'out' || direction === 'transition';\n\t        }\n\t        if (!directive.expression && (type === 'Binding' || type === 'Class')) {\n\t            directive.expression = {\n\t                start: directive.start + colon_index + 1,\n\t                end: directive.end,\n\t                type: 'Identifier',\n\t                name: directive.name\n\t            };\n\t        }\n\t        return directive;\n\t    }\n\t    check_unique(name);\n\t    return {\n\t        start,\n\t        end,\n\t        type: 'Attribute',\n\t        name,\n\t        value,\n\t    };\n\t}\n\tfunction get_directive_type(name) {\n\t    if (name === 'use')\n\t        return 'Action';\n\t    if (name === 'animate')\n\t        return 'Animation';\n\t    if (name === 'bind')\n\t        return 'Binding';\n\t    if (name === 'class')\n\t        return 'Class';\n\t    if (name === 'on')\n\t        return 'EventHandler';\n\t    if (name === 'let')\n\t        return 'Let';\n\t    if (name === 'ref')\n\t        return 'Ref';\n\t    if (name === 'in' || name === 'out' || name === 'transition')\n\t        return 'Transition';\n\t}\n\tfunction read_attribute_value(parser) {\n\t    const quote_mark = parser.eat(`'`) ? `'` : parser.eat(`\"`) ? `\"` : null;\n\t    const regex = (quote_mark === `'` ? /'/ :\n\t        quote_mark === `\"` ? /\"/ :\n\t            /(\\/>|[\\s\"'=<>`])/);\n\t    const value = read_sequence(parser, () => !!parser.match_regex(regex));\n\t    if (quote_mark)\n\t        parser.index += 1;\n\t    return value;\n\t}\n\tfunction read_sequence(parser, done) {\n\t    let current_chunk = {\n\t        start: parser.index,\n\t        end: null,\n\t        type: 'Text',\n\t        raw: '',\n\t        data: null\n\t    };\n\t    function flush() {\n\t        if (current_chunk.raw) {\n\t            current_chunk.data = decode_character_references(current_chunk.raw);\n\t            current_chunk.end = parser.index;\n\t            chunks.push(current_chunk);\n\t        }\n\t    }\n\t    const chunks = [];\n\t    while (parser.index < parser.template.length) {\n\t        const index = parser.index;\n\t        if (done()) {\n\t            flush();\n\t            return chunks;\n\t        }\n\t        else if (parser.eat('{')) {\n\t            flush();\n\t            parser.allow_whitespace();\n\t            const expression = read_expression(parser);\n\t            parser.allow_whitespace();\n\t            parser.eat('}', true);\n\t            chunks.push({\n\t                start: index,\n\t                end: parser.index,\n\t                type: 'MustacheTag',\n\t                expression,\n\t            });\n\t            current_chunk = {\n\t                start: parser.index,\n\t                end: null,\n\t                type: 'Text',\n\t                raw: '',\n\t                data: null\n\t            };\n\t        }\n\t        else {\n\t            current_chunk.raw += parser.template[parser.index++];\n\t        }\n\t    }\n\t    parser.error({\n\t        code: `unexpected-eof`,\n\t        message: `Unexpected end of input`\n\t    });\n\t}\n\n\tconst SQUARE_BRACKET_OPEN = \"[\".charCodeAt(0);\n\tconst SQUARE_BRACKET_CLOSE = \"]\".charCodeAt(0);\n\tconst CURLY_BRACKET_OPEN = \"{\".charCodeAt(0);\n\tconst CURLY_BRACKET_CLOSE = \"}\".charCodeAt(0);\n\tfunction is_bracket_open(code) {\n\t    return code === SQUARE_BRACKET_OPEN || code === CURLY_BRACKET_OPEN;\n\t}\n\tfunction is_bracket_close(code) {\n\t    return code === SQUARE_BRACKET_CLOSE || code === CURLY_BRACKET_CLOSE;\n\t}\n\tfunction is_bracket_pair(open, close) {\n\t    return ((open === SQUARE_BRACKET_OPEN && close === SQUARE_BRACKET_CLOSE) ||\n\t        (open === CURLY_BRACKET_OPEN && close === CURLY_BRACKET_CLOSE));\n\t}\n\tfunction get_bracket_close(open) {\n\t    if (open === SQUARE_BRACKET_OPEN) {\n\t        return SQUARE_BRACKET_CLOSE;\n\t    }\n\t    if (open === CURLY_BRACKET_OPEN) {\n\t        return CURLY_BRACKET_CLOSE;\n\t    }\n\t}\n\n\tfunction read_context(parser) {\n\t    const start = parser.index;\n\t    let i = parser.index;\n\t    const code = full_char_code_at(parser.template, i);\n\t    if (isIdentifierStart(code, true)) {\n\t        return {\n\t            type: \"Identifier\",\n\t            name: parser.read_identifier(),\n\t            start,\n\t            end: parser.index\n\t        };\n\t    }\n\t    if (!is_bracket_open(code)) {\n\t        parser.error({\n\t            code: \"unexpected-token\",\n\t            message: \"Expected identifier or destructure pattern\"\n\t        });\n\t    }\n\t    const bracket_stack = [code];\n\t    i += code <= 0xffff ? 1 : 2;\n\t    while (i < parser.template.length) {\n\t        const code = full_char_code_at(parser.template, i);\n\t        if (is_bracket_open(code)) {\n\t            bracket_stack.push(code);\n\t        }\n\t        else if (is_bracket_close(code)) {\n\t            if (!is_bracket_pair(bracket_stack[bracket_stack.length - 1], code)) {\n\t                parser.error({\n\t                    code: \"unexpected-token\",\n\t                    message: `Expected ${String.fromCharCode(get_bracket_close(bracket_stack[bracket_stack.length - 1]))}`\n\t                });\n\t            }\n\t            bracket_stack.pop();\n\t            if (bracket_stack.length === 0) {\n\t                i += code <= 0xffff ? 1 : 2;\n\t                break;\n\t            }\n\t        }\n\t        i += code <= 0xffff ? 1 : 2;\n\t    }\n\t    parser.index = i;\n\t    const pattern_string = parser.template.slice(start, i);\n\t    try {\n\t        // the length of the `space_with_newline` has to be start - 1\n\t        // because we added a `(` in front of the pattern_string,\n\t        // which shifted the entire string to right by 1\n\t        // so we offset it by removing 1 character in the `space_with_newline`\n\t        // to achieve that, we remove the 1st space encountered,\n\t        // so it will not affect the `column` of the node\n\t        let space_with_newline = parser.template.slice(0, start).replace(/[^\\n]/g, ' ');\n\t        const first_space = space_with_newline.indexOf(' ');\n\t        space_with_newline = space_with_newline.slice(0, first_space) + space_with_newline.slice(first_space + 1);\n\t        return parse_expression_at(`${space_with_newline}(${pattern_string} = 1)`, start - 1).left;\n\t    }\n\t    catch (error) {\n\t        parser.acorn_error(error);\n\t    }\n\t}\n\n\tfunction trim_start(str) {\n\t    let i = 0;\n\t    while (whitespace.test(str[i]))\n\t        i += 1;\n\t    return str.slice(i);\n\t}\n\tfunction trim_end(str) {\n\t    let i = str.length;\n\t    while (whitespace.test(str[i - 1]))\n\t        i -= 1;\n\t    return str.slice(0, i);\n\t}\n\n\tfunction to_string(node) {\n\t    switch (node.type) {\n\t        case 'IfBlock':\n\t            return '{#if} block';\n\t        case 'ThenBlock':\n\t            return '{:then} block';\n\t        case 'ElseBlock':\n\t            return '{:else} block';\n\t        case 'PendingBlock':\n\t        case 'AwaitBlock':\n\t            return '{#await} block';\n\t        case 'CatchBlock':\n\t            return '{:catch} block';\n\t        case 'EachBlock':\n\t            return '{#each} block';\n\t        case 'RawMustacheTag':\n\t            return '{@html} block';\n\t        case 'DebugTag':\n\t            return '{@debug} block';\n\t        case 'Element':\n\t        case 'InlineComponent':\n\t        case 'Slot':\n\t        case 'Title':\n\t            return `<${node.name}> tag`;\n\t        default:\n\t            return node.type;\n\t    }\n\t}\n\n\tfunction trim_whitespace(block, trim_before, trim_after) {\n\t    if (!block.children || block.children.length === 0)\n\t        return; // AwaitBlock\n\t    const first_child = block.children[0];\n\t    const last_child = block.children[block.children.length - 1];\n\t    if (first_child.type === 'Text' && trim_before) {\n\t        first_child.data = trim_start(first_child.data);\n\t        if (!first_child.data)\n\t            block.children.shift();\n\t    }\n\t    if (last_child.type === 'Text' && trim_after) {\n\t        last_child.data = trim_end(last_child.data);\n\t        if (!last_child.data)\n\t            block.children.pop();\n\t    }\n\t    if (block.else) {\n\t        trim_whitespace(block.else, trim_before, trim_after);\n\t    }\n\t    if (first_child.elseif) {\n\t        trim_whitespace(first_child, trim_before, trim_after);\n\t    }\n\t}\n\tfunction mustache(parser) {\n\t    const start = parser.index;\n\t    parser.index += 1;\n\t    parser.allow_whitespace();\n\t    // {/if}, {/each} or {/await}\n\t    if (parser.eat('/')) {\n\t        let block = parser.current();\n\t        let expected;\n\t        if (closing_tag_omitted(block.name)) {\n\t            block.end = start;\n\t            parser.stack.pop();\n\t            block = parser.current();\n\t        }\n\t        if (block.type === 'ElseBlock' || block.type === 'PendingBlock' || block.type === 'ThenBlock' || block.type === 'CatchBlock') {\n\t            block.end = start;\n\t            parser.stack.pop();\n\t            block = parser.current();\n\t            expected = 'await';\n\t        }\n\t        if (block.type === 'IfBlock') {\n\t            expected = 'if';\n\t        }\n\t        else if (block.type === 'EachBlock') {\n\t            expected = 'each';\n\t        }\n\t        else if (block.type === 'AwaitBlock') {\n\t            expected = 'await';\n\t        }\n\t        else {\n\t            parser.error({\n\t                code: `unexpected-block-close`,\n\t                message: `Unexpected block closing tag`\n\t            });\n\t        }\n\t        parser.eat(expected, true);\n\t        parser.allow_whitespace();\n\t        parser.eat('}', true);\n\t        while (block.elseif) {\n\t            block.end = parser.index;\n\t            parser.stack.pop();\n\t            block = parser.current();\n\t            if (block.else) {\n\t                block.else.end = start;\n\t            }\n\t        }\n\t        // strip leading/trailing whitespace as necessary\n\t        const char_before = parser.template[block.start - 1];\n\t        const char_after = parser.template[parser.index];\n\t        const trim_before = !char_before || whitespace.test(char_before);\n\t        const trim_after = !char_after || whitespace.test(char_after);\n\t        trim_whitespace(block, trim_before, trim_after);\n\t        block.end = parser.index;\n\t        parser.stack.pop();\n\t    }\n\t    else if (parser.eat(':else')) {\n\t        if (parser.eat('if')) {\n\t            parser.error({\n\t                code: 'invalid-elseif',\n\t                message: `'elseif' should be 'else if'`\n\t            });\n\t        }\n\t        parser.allow_whitespace();\n\t        // :else if\n\t        if (parser.eat('if')) {\n\t            const block = parser.current();\n\t            if (block.type !== 'IfBlock') {\n\t                parser.error({\n\t                    code: `invalid-elseif-placement`,\n\t                    message: parser.stack.some(block => block.type === 'IfBlock')\n\t                        ? `Expected to close ${to_string(block)} before seeing {:else if ...} block`\n\t                        : `Cannot have an {:else if ...} block outside an {#if ...} block`\n\t                });\n\t            }\n\t            parser.require_whitespace();\n\t            const expression = read_expression(parser);\n\t            parser.allow_whitespace();\n\t            parser.eat('}', true);\n\t            block.else = {\n\t                start: parser.index,\n\t                end: null,\n\t                type: 'ElseBlock',\n\t                children: [\n\t                    {\n\t                        start: parser.index,\n\t                        end: null,\n\t                        type: 'IfBlock',\n\t                        elseif: true,\n\t                        expression,\n\t                        children: [],\n\t                    },\n\t                ],\n\t            };\n\t            parser.stack.push(block.else.children[0]);\n\t        }\n\t        // :else\n\t        else {\n\t            const block = parser.current();\n\t            if (block.type !== 'IfBlock' && block.type !== 'EachBlock') {\n\t                parser.error({\n\t                    code: `invalid-else-placement`,\n\t                    message: parser.stack.some(block => block.type === 'IfBlock' || block.type === 'EachBlock')\n\t                        ? `Expected to close ${to_string(block)} before seeing {:else} block`\n\t                        : `Cannot have an {:else} block outside an {#if ...} or {#each ...} block`\n\t                });\n\t            }\n\t            parser.allow_whitespace();\n\t            parser.eat('}', true);\n\t            block.else = {\n\t                start: parser.index,\n\t                end: null,\n\t                type: 'ElseBlock',\n\t                children: [],\n\t            };\n\t            parser.stack.push(block.else);\n\t        }\n\t    }\n\t    else if (parser.match(':then') || parser.match(':catch')) {\n\t        const block = parser.current();\n\t        const is_then = parser.eat(':then') || !parser.eat(':catch');\n\t        if (is_then) {\n\t            if (block.type !== 'PendingBlock') {\n\t                parser.error({\n\t                    code: `invalid-then-placement`,\n\t                    message: parser.stack.some(block => block.type === 'PendingBlock')\n\t                        ? `Expected to close ${to_string(block)} before seeing {:then} block`\n\t                        : `Cannot have an {:then} block outside an {#await ...} block`\n\t                });\n\t            }\n\t        }\n\t        else {\n\t            if (block.type !== 'ThenBlock' && block.type !== 'PendingBlock') {\n\t                parser.error({\n\t                    code: `invalid-catch-placement`,\n\t                    message: parser.stack.some(block => block.type === 'ThenBlock' || block.type === 'PendingBlock')\n\t                        ? `Expected to close ${to_string(block)} before seeing {:catch} block`\n\t                        : `Cannot have an {:catch} block outside an {#await ...} block`\n\t                });\n\t            }\n\t        }\n\t        block.end = start;\n\t        parser.stack.pop();\n\t        const await_block = parser.current();\n\t        if (!parser.eat('}')) {\n\t            parser.require_whitespace();\n\t            await_block[is_then ? 'value' : 'error'] = read_context(parser);\n\t            parser.allow_whitespace();\n\t            parser.eat('}', true);\n\t        }\n\t        const new_block = {\n\t            start,\n\t            end: null,\n\t            type: is_then ? 'ThenBlock' : 'CatchBlock',\n\t            children: [],\n\t            skip: false\n\t        };\n\t        await_block[is_then ? 'then' : 'catch'] = new_block;\n\t        parser.stack.push(new_block);\n\t    }\n\t    else if (parser.eat('#')) {\n\t        // {#if foo}, {#each foo} or {#await foo}\n\t        let type;\n\t        if (parser.eat('if')) {\n\t            type = 'IfBlock';\n\t        }\n\t        else if (parser.eat('each')) {\n\t            type = 'EachBlock';\n\t        }\n\t        else if (parser.eat('await')) {\n\t            type = 'AwaitBlock';\n\t        }\n\t        else {\n\t            parser.error({\n\t                code: `expected-block-type`,\n\t                message: `Expected if, each or await`\n\t            });\n\t        }\n\t        parser.require_whitespace();\n\t        const expression = read_expression(parser);\n\t        const block = type === 'AwaitBlock' ?\n\t            {\n\t                start,\n\t                end: null,\n\t                type,\n\t                expression,\n\t                value: null,\n\t                error: null,\n\t                pending: {\n\t                    start: null,\n\t                    end: null,\n\t                    type: 'PendingBlock',\n\t                    children: [],\n\t                    skip: true\n\t                },\n\t                then: {\n\t                    start: null,\n\t                    end: null,\n\t                    type: 'ThenBlock',\n\t                    children: [],\n\t                    skip: true\n\t                },\n\t                catch: {\n\t                    start: null,\n\t                    end: null,\n\t                    type: 'CatchBlock',\n\t                    children: [],\n\t                    skip: true\n\t                },\n\t            } :\n\t            {\n\t                start,\n\t                end: null,\n\t                type,\n\t                expression,\n\t                children: [],\n\t            };\n\t        parser.allow_whitespace();\n\t        // {#each} blocks must declare a context \u2013 {#each list as item}\n\t        if (type === 'EachBlock') {\n\t            parser.eat('as', true);\n\t            parser.require_whitespace();\n\t            block.context = read_context(parser);\n\t            parser.allow_whitespace();\n\t            if (parser.eat(',')) {\n\t                parser.allow_whitespace();\n\t                block.index = parser.read_identifier();\n\t                if (!block.index)\n\t                    parser.error({\n\t                        code: `expected-name`,\n\t                        message: `Expected name`\n\t                    });\n\t                parser.allow_whitespace();\n\t            }\n\t            if (parser.eat('(')) {\n\t                parser.allow_whitespace();\n\t                block.key = read_expression(parser);\n\t                parser.allow_whitespace();\n\t                parser.eat(')', true);\n\t                parser.allow_whitespace();\n\t            }\n\t        }\n\t        const await_block_shorthand = type === 'AwaitBlock' && parser.eat('then');\n\t        if (await_block_shorthand) {\n\t            parser.require_whitespace();\n\t            block.value = read_context(parser);\n\t            parser.allow_whitespace();\n\t        }\n\t        const await_block_catch_shorthand = !await_block_shorthand && type === 'AwaitBlock' && parser.eat('catch');\n\t        if (await_block_catch_shorthand) {\n\t            parser.require_whitespace();\n\t            block.error = read_context(parser);\n\t            parser.allow_whitespace();\n\t        }\n\t        parser.eat('}', true);\n\t        parser.current().children.push(block);\n\t        parser.stack.push(block);\n\t        if (type === 'AwaitBlock') {\n\t            let child_block;\n\t            if (await_block_shorthand) {\n\t                block.then.skip = false;\n\t                child_block = block.then;\n\t            }\n\t            else if (await_block_catch_shorthand) {\n\t                block.catch.skip = false;\n\t                child_block = block.catch;\n\t            }\n\t            else {\n\t                block.pending.skip = false;\n\t                child_block = block.pending;\n\t            }\n\t            child_block.start = parser.index;\n\t            parser.stack.push(child_block);\n\t        }\n\t    }\n\t    else if (parser.eat('@html')) {\n\t        // {@html content} tag\n\t        parser.require_whitespace();\n\t        const expression = read_expression(parser);\n\t        parser.allow_whitespace();\n\t        parser.eat('}', true);\n\t        parser.current().children.push({\n\t            start,\n\t            end: parser.index,\n\t            type: 'RawMustacheTag',\n\t            expression,\n\t        });\n\t    }\n\t    else if (parser.eat('@debug')) {\n\t        let identifiers;\n\t        // Implies {@debug} which indicates \"debug all\"\n\t        if (parser.read(/\\s*}/)) {\n\t            identifiers = [];\n\t        }\n\t        else {\n\t            const expression = read_expression(parser);\n\t            identifiers = expression.type === 'SequenceExpression'\n\t                ? expression.expressions\n\t                : [expression];\n\t            identifiers.forEach(node => {\n\t                if (node.type !== 'Identifier') {\n\t                    parser.error({\n\t                        code: 'invalid-debug-args',\n\t                        message: '{@debug ...} arguments must be identifiers, not arbitrary expressions'\n\t                    }, node.start);\n\t                }\n\t            });\n\t            parser.allow_whitespace();\n\t            parser.eat('}', true);\n\t        }\n\t        parser.current().children.push({\n\t            start,\n\t            end: parser.index,\n\t            type: 'DebugTag',\n\t            identifiers\n\t        });\n\t    }\n\t    else {\n\t        const expression = read_expression(parser);\n\t        parser.allow_whitespace();\n\t        parser.eat('}', true);\n\t        parser.current().children.push({\n\t            start,\n\t            end: parser.index,\n\t            type: 'MustacheTag',\n\t            expression,\n\t        });\n\t    }\n\t}\n\n\tfunction text(parser) {\n\t    const start = parser.index;\n\t    let data = '';\n\t    while (parser.index < parser.template.length &&\n\t        !parser.match('<') &&\n\t        !parser.match('{')) {\n\t        data += parser.template[parser.index++];\n\t    }\n\t    const node = {\n\t        start,\n\t        end: parser.index,\n\t        type: 'Text',\n\t        raw: data,\n\t        data: decode_character_references(data),\n\t    };\n\t    parser.current().children.push(node);\n\t}\n\n\tfunction fragment(parser) {\n\t    if (parser.match('<')) {\n\t        return tag;\n\t    }\n\t    if (parser.match('{')) {\n\t        return mustache;\n\t    }\n\t    return text;\n\t}\n\n\tfunction getLocator(source, options) {\n\t    if (options === void 0) { options = {}; }\n\t    var offsetLine = options.offsetLine || 0;\n\t    var offsetColumn = options.offsetColumn || 0;\n\t    var originalLines = source.split('\\n');\n\t    var start = 0;\n\t    var lineRanges = originalLines.map(function (line, i) {\n\t        var end = start + line.length + 1;\n\t        var range = { start: start, end: end, line: i };\n\t        start = end;\n\t        return range;\n\t    });\n\t    var i = 0;\n\t    function rangeContains(range, index) {\n\t        return range.start <= index && index < range.end;\n\t    }\n\t    function getLocation(range, index) {\n\t        return { line: offsetLine + range.line, column: offsetColumn + index - range.start, character: index };\n\t    }\n\t    function locate(search, startIndex) {\n\t        if (typeof search === 'string') {\n\t            search = source.indexOf(search, startIndex || 0);\n\t        }\n\t        var range = lineRanges[i];\n\t        var d = search >= range.end ? 1 : -1;\n\t        while (range) {\n\t            if (rangeContains(range, search))\n\t                return getLocation(range, search);\n\t            i += d;\n\t            range = lineRanges[i];\n\t        }\n\t    }\n\t    return locate;\n\t}\n\tfunction locate(source, search, options) {\n\t    if (typeof options === 'number') {\n\t        throw new Error('locate takes a { startIndex, offsetLine, offsetColumn } object as the third argument');\n\t    }\n\t    return getLocator(source, options)(search, options && options.startIndex);\n\t}\n\n\tfunction tabs_to_spaces(str) {\n\t    return str.replace(/^\\t+/, match => match.split('\\t').join('  '));\n\t}\n\tfunction get_code_frame(source, line, column) {\n\t    const lines = source.split('\\n');\n\t    const frame_start = Math.max(0, line - 2);\n\t    const frame_end = Math.min(line + 3, lines.length);\n\t    const digits = String(frame_end + 1).length;\n\t    return lines\n\t        .slice(frame_start, frame_end)\n\t        .map((str, i) => {\n\t        const isErrorLine = frame_start + i === line;\n\t        const line_num = String(i + frame_start + 1).padStart(digits, ' ');\n\t        if (isErrorLine) {\n\t            const indicator = ' '.repeat(digits + 2 + tabs_to_spaces(str.slice(0, column)).length) + '^';\n\t            return `${line_num}: ${tabs_to_spaces(str)}\\n${indicator}`;\n\t        }\n\t        return `${line_num}: ${tabs_to_spaces(str)}`;\n\t    })\n\t        .join('\\n');\n\t}\n\n\tclass CompileError extends Error {\n\t    toString() {\n\t        return `${this.message} (${this.start.line}:${this.start.column})\\n${this.frame}`;\n\t    }\n\t}\n\tfunction error$1(message, props) {\n\t    const error = new CompileError(message);\n\t    error.name = props.name;\n\t    const start = locate(props.source, props.start, { offsetLine: 1 });\n\t    const end = locate(props.source, props.end || props.start, { offsetLine: 1 });\n\t    error.code = props.code;\n\t    error.start = start;\n\t    error.end = end;\n\t    error.pos = props.start;\n\t    error.filename = props.filename;\n\t    error.frame = get_code_frame(props.source, start.line - 1, start.column);\n\t    throw error;\n\t}\n\n\tclass Parser$1 {\n\t    constructor(template, options) {\n\t        this.index = 0;\n\t        this.stack = [];\n\t        this.css = [];\n\t        this.js = [];\n\t        this.meta_tags = {};\n\t        if (typeof template !== 'string') {\n\t            throw new TypeError('Template must be a string');\n\t        }\n\t        this.template = template.replace(/\\s+$/, '');\n\t        this.filename = options.filename;\n\t        this.customElement = options.customElement;\n\t        this.html = {\n\t            start: null,\n\t            end: null,\n\t            type: 'Fragment',\n\t            children: [],\n\t        };\n\t        this.stack.push(this.html);\n\t        let state = fragment;\n\t        while (this.index < this.template.length) {\n\t            state = state(this) || fragment;\n\t        }\n\t        if (this.stack.length > 1) {\n\t            const current = this.current();\n\t            const type = current.type === 'Element' ? `<${current.name}>` : 'Block';\n\t            const slug = current.type === 'Element' ? 'element' : 'block';\n\t            this.error({\n\t                code: `unclosed-${slug}`,\n\t                message: `${type} was left open`\n\t            }, current.start);\n\t        }\n\t        if (state !== fragment) {\n\t            this.error({\n\t                code: `unexpected-eof`,\n\t                message: 'Unexpected end of input'\n\t            });\n\t        }\n\t        if (this.html.children.length) {\n\t            let start = this.html.children[0].start;\n\t            while (whitespace.test(template[start]))\n\t                start += 1;\n\t            let end = this.html.children[this.html.children.length - 1].end;\n\t            while (whitespace.test(template[end - 1]))\n\t                end -= 1;\n\t            this.html.start = start;\n\t            this.html.end = end;\n\t        }\n\t        else {\n\t            this.html.start = this.html.end = null;\n\t        }\n\t    }\n\t    current() {\n\t        return this.stack[this.stack.length - 1];\n\t    }\n\t    acorn_error(err) {\n\t        this.error({\n\t            code: `parse-error`,\n\t            message: err.message.replace(/ \\(\\d+:\\d+\\)$/, '')\n\t        }, err.pos);\n\t    }\n\t    error({ code, message }, index = this.index) {\n\t        error$1(message, {\n\t            name: 'ParseError',\n\t            code,\n\t            source: this.template,\n\t            start: index,\n\t            filename: this.filename\n\t        });\n\t    }\n\t    eat(str, required, message) {\n\t        if (this.match(str)) {\n\t            this.index += str.length;\n\t            return true;\n\t        }\n\t        if (required) {\n\t            this.error({\n\t                code: `unexpected-${this.index === this.template.length ? 'eof' : 'token'}`,\n\t                message: message || `Expected ${str}`\n\t            });\n\t        }\n\t        return false;\n\t    }\n\t    match(str) {\n\t        return this.template.slice(this.index, this.index + str.length) === str;\n\t    }\n\t    match_regex(pattern) {\n\t        const match = pattern.exec(this.template.slice(this.index));\n\t        if (!match || match.index !== 0)\n\t            return null;\n\t        return match[0];\n\t    }\n\t    allow_whitespace() {\n\t        while (this.index < this.template.length &&\n\t            whitespace.test(this.template[this.index])) {\n\t            this.index++;\n\t        }\n\t    }\n\t    read(pattern) {\n\t        const result = this.match_regex(pattern);\n\t        if (result)\n\t            this.index += result.length;\n\t        return result;\n\t    }\n\t    read_identifier(allow_reserved = false) {\n\t        const start = this.index;\n\t        let i = this.index;\n\t        const code = full_char_code_at(this.template, i);\n\t        if (!isIdentifierStart(code, true))\n\t            return null;\n\t        i += code <= 0xffff ? 1 : 2;\n\t        while (i < this.template.length) {\n\t            const code = full_char_code_at(this.template, i);\n\t            if (!isIdentifierChar(code, true))\n\t                break;\n\t            i += code <= 0xffff ? 1 : 2;\n\t        }\n\t        const identifier = this.template.slice(this.index, this.index = i);\n\t        if (!allow_reserved && reserved.has(identifier)) {\n\t            this.error({\n\t                code: `unexpected-reserved-word`,\n\t                message: `'${identifier}' is a reserved word in JavaScript and cannot be used here`\n\t            }, start);\n\t        }\n\t        return identifier;\n\t    }\n\t    read_until(pattern) {\n\t        if (this.index >= this.template.length)\n\t            this.error({\n\t                code: `unexpected-eof`,\n\t                message: 'Unexpected end of input'\n\t            });\n\t        const start = this.index;\n\t        const match = pattern.exec(this.template.slice(start));\n\t        if (match) {\n\t            this.index = start + match.index;\n\t            return this.template.slice(start, this.index);\n\t        }\n\t        this.index = this.template.length;\n\t        return this.template.slice(start);\n\t    }\n\t    require_whitespace() {\n\t        if (!whitespace.test(this.template[this.index])) {\n\t            this.error({\n\t                code: `missing-whitespace`,\n\t                message: `Expected whitespace`\n\t            });\n\t        }\n\t        this.allow_whitespace();\n\t    }\n\t}\n\tfunction parse$3(template, options = {}) {\n\t    const parser = new Parser$1(template, options);\n\t    // TODO we may want to allow multiple <style> tags \u2014\n\t    // one scoped, one global. for now, only allow one\n\t    if (parser.css.length > 1) {\n\t        parser.error({\n\t            code: 'duplicate-style',\n\t            message: 'You can only have one top-level <style> tag per component'\n\t        }, parser.css[1].start);\n\t    }\n\t    const instance_scripts = parser.js.filter(script => script.context === 'default');\n\t    const module_scripts = parser.js.filter(script => script.context === 'module');\n\t    if (instance_scripts.length > 1) {\n\t        parser.error({\n\t            code: `invalid-script`,\n\t            message: `A component can only have one instance-level <script> element`\n\t        }, instance_scripts[1].start);\n\t    }\n\t    if (module_scripts.length > 1) {\n\t        parser.error({\n\t            code: `invalid-script`,\n\t            message: `A component can only have one <script context=\"module\"> element`\n\t        }, module_scripts[1].start);\n\t    }\n\t    return {\n\t        html: parser.html,\n\t        css: parser.css[0],\n\t        instance: instance_scripts[0],\n\t        module: module_scripts[0]\n\t    };\n\t}\n\n\tfunction is_head(node) {\n\t    return node && node.type === 'MemberExpression' && node.object.name === '@_document' && node.property.name === 'head';\n\t}\n\n\tclass Block$1 {\n\t    constructor(options) {\n\t        this.dependencies = new Set();\n\t        this.event_listeners = [];\n\t        this.variables = new Map();\n\t        this.has_update_method = false;\n\t        this.parent = options.parent;\n\t        this.renderer = options.renderer;\n\t        this.name = options.name;\n\t        this.type = options.type;\n\t        this.comment = options.comment;\n\t        this.wrappers = [];\n\t        // for keyed each blocks\n\t        this.key = options.key;\n\t        this.first = null;\n\t        this.bindings = options.bindings;\n\t        this.chunks = {\n\t            declarations: [],\n\t            init: [],\n\t            create: [],\n\t            claim: [],\n\t            hydrate: [],\n\t            mount: [],\n\t            measure: [],\n\t            fix: [],\n\t            animate: [],\n\t            intro: [],\n\t            update: [],\n\t            outro: [],\n\t            destroy: [],\n\t        };\n\t        this.has_animation = false;\n\t        this.has_intro_method = false; // a block could have an intro method but not intro transitions, e.g. if a sibling block has intros\n\t        this.has_outro_method = false;\n\t        this.outros = 0;\n\t        this.get_unique_name = this.renderer.component.get_unique_name_maker();\n\t        this.aliases = new Map();\n\t        if (this.key)\n\t            this.aliases.set('key', this.get_unique_name('key'));\n\t    }\n\t    assign_variable_names() {\n\t        const seen = new Set();\n\t        const dupes = new Set();\n\t        let i = this.wrappers.length;\n\t        while (i--) {\n\t            const wrapper = this.wrappers[i];\n\t            if (!wrapper.var)\n\t                continue;\n\t            if (seen.has(wrapper.var.name)) {\n\t                dupes.add(wrapper.var.name);\n\t            }\n\t            seen.add(wrapper.var.name);\n\t        }\n\t        const counts = new Map();\n\t        i = this.wrappers.length;\n\t        while (i--) {\n\t            const wrapper = this.wrappers[i];\n\t            if (!wrapper.var)\n\t                continue;\n\t            let suffix = '';\n\t            if (dupes.has(wrapper.var.name)) {\n\t                const i = counts.get(wrapper.var.name) || 0;\n\t                counts.set(wrapper.var.name, i + 1);\n\t                suffix = i;\n\t            }\n\t            wrapper.var.name = this.get_unique_name(wrapper.var.name + suffix).name;\n\t        }\n\t    }\n\t    add_dependencies(dependencies) {\n\t        dependencies.forEach(dependency => {\n\t            this.dependencies.add(dependency);\n\t        });\n\t        this.has_update_method = true;\n\t        if (this.parent) {\n\t            this.parent.add_dependencies(dependencies);\n\t        }\n\t    }\n\t    add_element(id, render_statement, claim_statement, parent_node, no_detach) {\n\t        this.add_variable(id);\n\t        this.chunks.create.push(b `${id} = ${render_statement};`);\n\t        if (this.renderer.options.hydratable) {\n\t            this.chunks.claim.push(b `${id} = ${claim_statement || render_statement};`);\n\t        }\n\t        if (parent_node) {\n\t            this.chunks.mount.push(b `@append(${parent_node}, ${id});`);\n\t            if (is_head(parent_node) && !no_detach)\n\t                this.chunks.destroy.push(b `@detach(${id});`);\n\t        }\n\t        else {\n\t            this.chunks.mount.push(b `@insert(#target, ${id}, #anchor);`);\n\t            if (!no_detach)\n\t                this.chunks.destroy.push(b `if (detaching) @detach(${id});`);\n\t        }\n\t    }\n\t    add_intro(local) {\n\t        this.has_intros = this.has_intro_method = true;\n\t        if (!local && this.parent)\n\t            this.parent.add_intro();\n\t    }\n\t    add_outro(local) {\n\t        this.has_outros = this.has_outro_method = true;\n\t        this.outros += 1;\n\t        if (!local && this.parent)\n\t            this.parent.add_outro();\n\t    }\n\t    add_animation() {\n\t        this.has_animation = true;\n\t    }\n\t    add_variable(id, init) {\n\t        if (this.variables.has(id.name)) {\n\t            throw new Error(`Variable '${id.name}' already initialised with a different value`);\n\t        }\n\t        this.variables.set(id.name, { id, init });\n\t    }\n\t    alias(name) {\n\t        if (!this.aliases.has(name)) {\n\t            this.aliases.set(name, this.get_unique_name(name));\n\t        }\n\t        return this.aliases.get(name);\n\t    }\n\t    child(options) {\n\t        return new Block$1(Object.assign({}, this, { key: null }, options, { parent: this }));\n\t    }\n\t    get_contents(key) {\n\t        const { dev } = this.renderer.options;\n\t        if (this.has_outros) {\n\t            this.add_variable({ type: 'Identifier', name: '#current' });\n\t            if (this.chunks.intro.length > 0) {\n\t                this.chunks.intro.push(b `#current = true;`);\n\t                this.chunks.mount.push(b `#current = true;`);\n\t            }\n\t            if (this.chunks.outro.length > 0) {\n\t                this.chunks.outro.push(b `#current = false;`);\n\t            }\n\t        }\n\t        if (this.autofocus) {\n\t            this.chunks.mount.push(b `${this.autofocus}.focus();`);\n\t        }\n\t        this.render_listeners();\n\t        const properties = {};\n\t        const noop = x `@noop`;\n\t        properties.key = key;\n\t        if (this.first) {\n\t            properties.first = x `null`;\n\t            this.chunks.hydrate.push(b `this.first = ${this.first};`);\n\t        }\n\t        if (this.chunks.create.length === 0 && this.chunks.hydrate.length === 0) {\n\t            properties.create = noop;\n\t        }\n\t        else {\n\t            const hydrate = this.chunks.hydrate.length > 0 && (this.renderer.options.hydratable\n\t                ? b `this.h();`\n\t                : this.chunks.hydrate);\n\t            properties.create = x `function #create() {\n\t\t\t\t${this.chunks.create}\n\t\t\t\t${hydrate}\n\t\t\t}`;\n\t        }\n\t        if (this.renderer.options.hydratable || this.chunks.claim.length > 0) {\n\t            if (this.chunks.claim.length === 0 && this.chunks.hydrate.length === 0) {\n\t                properties.claim = noop;\n\t            }\n\t            else {\n\t                properties.claim = x `function #claim(#nodes) {\n\t\t\t\t\t${this.chunks.claim}\n\t\t\t\t\t${this.renderer.options.hydratable && this.chunks.hydrate.length > 0 && b `this.h();`}\n\t\t\t\t}`;\n\t            }\n\t        }\n\t        if (this.renderer.options.hydratable && this.chunks.hydrate.length > 0) {\n\t            properties.hydrate = x `function #hydrate() {\n\t\t\t\t${this.chunks.hydrate}\n\t\t\t}`;\n\t        }\n\t        if (this.chunks.mount.length === 0) {\n\t            properties.mount = noop;\n\t        }\n\t        else if (this.event_listeners.length === 0) {\n\t            properties.mount = x `function #mount(#target, #anchor) {\n\t\t\t\t${this.chunks.mount}\n\t\t\t}`;\n\t        }\n\t        else {\n\t            properties.mount = x `function #mount(#target, #anchor) {\n\t\t\t\t${this.chunks.mount}\n\t\t\t}`;\n\t        }\n\t        if (this.has_update_method || this.maintain_context) {\n\t            if (this.chunks.update.length === 0 && !this.maintain_context) {\n\t                properties.update = noop;\n\t            }\n\t            else {\n\t                const ctx = this.maintain_context ? x `#new_ctx` : x `#ctx`;\n\t                let dirty = { type: 'Identifier', name: '#dirty' };\n\t                if (!this.renderer.context_overflow && !this.parent) {\n\t                    dirty = { type: 'ArrayPattern', elements: [dirty] };\n\t                }\n\t                properties.update = x `function #update(${ctx}, ${dirty}) {\n\t\t\t\t\t${this.maintain_context && b `#ctx = ${ctx};`}\n\t\t\t\t\t${this.chunks.update}\n\t\t\t\t}`;\n\t            }\n\t        }\n\t        if (this.has_animation) {\n\t            properties.measure = x `function #measure() {\n\t\t\t\t${this.chunks.measure}\n\t\t\t}`;\n\t            properties.fix = x `function #fix() {\n\t\t\t\t${this.chunks.fix}\n\t\t\t}`;\n\t            properties.animate = x `function #animate() {\n\t\t\t\t${this.chunks.animate}\n\t\t\t}`;\n\t        }\n\t        if (this.has_intro_method || this.has_outro_method) {\n\t            if (this.chunks.intro.length === 0) {\n\t                properties.intro = noop;\n\t            }\n\t            else {\n\t                properties.intro = x `function #intro(#local) {\n\t\t\t\t\t${this.has_outros && b `if (#current) return;`}\n\t\t\t\t\t${this.chunks.intro}\n\t\t\t\t}`;\n\t            }\n\t            if (this.chunks.outro.length === 0) {\n\t                properties.outro = noop;\n\t            }\n\t            else {\n\t                properties.outro = x `function #outro(#local) {\n\t\t\t\t\t${this.chunks.outro}\n\t\t\t\t}`;\n\t            }\n\t        }\n\t        if (this.chunks.destroy.length === 0) {\n\t            properties.destroy = noop;\n\t        }\n\t        else {\n\t            properties.destroy = x `function #destroy(detaching) {\n\t\t\t\t${this.chunks.destroy}\n\t\t\t}`;\n\t        }\n\t        if (!this.renderer.component.compile_options.dev) {\n\t            // allow shorthand names\n\t            for (const name in properties) {\n\t                const property = properties[name];\n\t                if (property)\n\t                    property.id = null;\n\t            }\n\t        }\n\t        const return_value = x `{\n\t\t\tkey: ${properties.key},\n\t\t\tfirst: ${properties.first},\n\t\t\tc: ${properties.create},\n\t\t\tl: ${properties.claim},\n\t\t\th: ${properties.hydrate},\n\t\t\tm: ${properties.mount},\n\t\t\tp: ${properties.update},\n\t\t\tr: ${properties.measure},\n\t\t\tf: ${properties.fix},\n\t\t\ta: ${properties.animate},\n\t\t\ti: ${properties.intro},\n\t\t\to: ${properties.outro},\n\t\t\td: ${properties.destroy}\n\t\t}`;\n\t        const block = dev && this.get_unique_name('block');\n\t        const body = b `\n\t\t\t${this.chunks.declarations}\n\n\t\t\t${Array.from(this.variables.values()).map(({ id, init }) => {\n            return init\n                ? b `let ${id} = ${init}`\n                : b `let ${id}`;\n        })}\n\n\t\t\t${this.chunks.init}\n\n\t\t\t${dev\n            ? b `\n\t\t\t\t\tconst ${block} = ${return_value};\n\t\t\t\t\t@dispatch_dev(\"SvelteRegisterBlock\", {\n\t\t\t\t\t\tblock: ${block},\n\t\t\t\t\t\tid: ${this.name || 'create_fragment'}.name,\n\t\t\t\t\t\ttype: \"${this.type}\",\n\t\t\t\t\t\tsource: \"${this.comment ? this.comment.replace(/\"/g, '\\\\\"') : ''}\",\n\t\t\t\t\t\tctx: #ctx\n\t\t\t\t\t});\n\t\t\t\t\treturn ${block};`\n            : b `\n\t\t\t\t\treturn ${return_value};`}\n\t\t`;\n\t        return body;\n\t    }\n\t    has_content() {\n\t        return !!this.first ||\n\t            this.event_listeners.length > 0 ||\n\t            this.chunks.intro.length > 0 ||\n\t            this.chunks.outro.length > 0 ||\n\t            this.chunks.create.length > 0 ||\n\t            this.chunks.hydrate.length > 0 ||\n\t            this.chunks.claim.length > 0 ||\n\t            this.chunks.mount.length > 0 ||\n\t            this.chunks.update.length > 0 ||\n\t            this.chunks.destroy.length > 0 ||\n\t            this.has_animation;\n\t    }\n\t    render() {\n\t        const key = this.key && this.get_unique_name('key');\n\t        const args = [x `#ctx`];\n\t        if (key)\n\t            args.unshift(key);\n\t        const fn = b `function ${this.name}(${args}) {\n\t\t\t${this.get_contents(key)}\n\t\t}`;\n\t        return this.comment\n\t            ? b `\n\t\t\t\t// ${this.comment}\n\t\t\t\t${fn}`\n\t            : fn;\n\t    }\n\t    render_listeners(chunk = '') {\n\t        if (this.event_listeners.length > 0) {\n\t            this.add_variable({ type: 'Identifier', name: '#mounted' });\n\t            this.chunks.destroy.push(b `#mounted = false`);\n\t            const dispose = {\n\t                type: 'Identifier',\n\t                name: `#dispose${chunk}`\n\t            };\n\t            this.add_variable(dispose);\n\t            if (this.event_listeners.length === 1) {\n\t                this.chunks.mount.push(b `\n\t\t\t\t\t\tif (!#mounted) {\n\t\t\t\t\t\t\t${dispose} = ${this.event_listeners[0]};\n\t\t\t\t\t\t\t#mounted = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t`);\n\t                this.chunks.destroy.push(b `${dispose}();`);\n\t            }\n\t            else {\n\t                this.chunks.mount.push(b `\n\t\t\t\t\tif (!#mounted) {\n\t\t\t\t\t\t${dispose} = [\n\t\t\t\t\t\t\t${this.event_listeners}\n\t\t\t\t\t\t];\n\t\t\t\t\t\t#mounted = true;\n\t\t\t\t\t}\n\t\t\t\t`);\n\t                this.chunks.destroy.push(b `@run_all(${dispose});`);\n\t            }\n\t        }\n\t    }\n\t}\n\n\tclass Wrapper {\n\t    constructor(renderer, block, parent, node) {\n\t        this.node = node;\n\t        // make these non-enumerable so that they can be logged sensibly\n\t        // (TODO in dev only?)\n\t        Object.defineProperties(this, {\n\t            renderer: {\n\t                value: renderer\n\t            },\n\t            parent: {\n\t                value: parent\n\t            }\n\t        });\n\t        this.can_use_innerhtml = !renderer.options.hydratable;\n\t        this.is_static_content = !renderer.options.hydratable;\n\t        block.wrappers.push(this);\n\t    }\n\t    cannot_use_innerhtml() {\n\t        this.can_use_innerhtml = false;\n\t        if (this.parent)\n\t            this.parent.cannot_use_innerhtml();\n\t    }\n\t    not_static_content() {\n\t        this.is_static_content = false;\n\t        if (this.parent)\n\t            this.parent.not_static_content();\n\t    }\n\t    get_or_create_anchor(block, parent_node, parent_nodes) {\n\t        // TODO use this in EachBlock and IfBlock \u2014 tricky because\n\t        // children need to be created first\n\t        const needs_anchor = this.next ? !this.next.is_dom_node() : !parent_node || !this.parent.is_dom_node();\n\t        const anchor = needs_anchor\n\t            ? block.get_unique_name(`${this.var.name}_anchor`)\n\t            : (this.next && this.next.var) || { type: 'Identifier', name: 'null' };\n\t        if (needs_anchor) {\n\t            block.add_element(anchor, x `@empty()`, parent_nodes && x `@empty()`, parent_node);\n\t        }\n\t        return anchor;\n\t    }\n\t    get_update_mount_node(anchor) {\n\t        return ((this.parent && this.parent.is_dom_node())\n\t            ? this.parent.var\n\t            : x `${anchor}.parentNode`);\n\t    }\n\t    is_dom_node() {\n\t        return (this.node.type === 'Element' ||\n\t            this.node.type === 'Text' ||\n\t            this.node.type === 'MustacheTag');\n\t    }\n\t    render(_block, _parent_node, _parent_nodes) {\n\t        throw Error('Wrapper class is not renderable');\n\t    }\n\t}\n\n\tfunction create_debugging_comment(node, component) {\n\t    const { locate, source } = component;\n\t    let c = node.start;\n\t    if (node.type === 'ElseBlock') {\n\t        while (source[c - 1] !== '{')\n\t            c -= 1;\n\t        while (source[c - 1] === '{')\n\t            c -= 1;\n\t    }\n\t    let d;\n\t    if (node.type === 'InlineComponent' || node.type === 'Element') {\n\t        if (node.children.length) {\n\t            d = node.children[0].start;\n\t            while (source[d - 1] !== '>')\n\t                d -= 1;\n\t        }\n\t        else {\n\t            d = node.start;\n\t            while (source[d] !== '>')\n\t                d += 1;\n\t            d += 1;\n\t        }\n\t    }\n\t    else if (node.type === 'Text' || node.type === 'Comment') {\n\t        d = node.end;\n\t    }\n\t    else {\n\t        // @ts-ignore\n\t        d = node.expression ? node.expression.node.end : c;\n\t        while (source[d] !== '}')\n\t            d += 1;\n\t        while (source[d] === '}')\n\t            d += 1;\n\t    }\n\t    const start = locate(c);\n\t    const loc = `(${start.line}:${start.column})`;\n\t    return `${loc} ${source.slice(c, d)}`.replace(/\\s/g, ' ');\n\t}\n\n\tclass AwaitBlockBranch extends Wrapper {\n\t    constructor(status, renderer, block, parent, node, strip_whitespace, next_sibling) {\n\t        super(renderer, block, parent, node);\n\t        this.var = null;\n\t        this.status = status;\n\t        this.block = block.child({\n\t            comment: create_debugging_comment(node, this.renderer.component),\n\t            name: this.renderer.component.get_unique_name(`create_${status}_block`),\n\t            type: status\n\t        });\n\t        this.add_context(parent.node[status + '_node'], parent.node[status + '_contexts']);\n\t        this.fragment = new FragmentWrapper(renderer, this.block, this.node.children, parent, strip_whitespace, next_sibling);\n\t        this.is_dynamic = this.block.dependencies.size > 0;\n\t    }\n\t    add_context(node, contexts) {\n\t        if (!node)\n\t            return;\n\t        if (node.type === 'Identifier') {\n\t            this.value = node.name;\n\t            this.renderer.add_to_context(this.value, true);\n\t        }\n\t        else {\n\t            contexts.forEach(context => {\n\t                this.renderer.add_to_context(context.key.name, true);\n\t            });\n\t            this.value = this.block.parent.get_unique_name('value').name;\n\t            this.value_contexts = contexts;\n\t            this.renderer.add_to_context(this.value, true);\n\t            this.is_destructured = true;\n\t        }\n\t        this.value_index = this.renderer.context_lookup.get(this.value).index;\n\t    }\n\t    render(block, parent_node, parent_nodes) {\n\t        this.fragment.render(block, parent_node, parent_nodes);\n\t        if (this.is_destructured) {\n\t            this.render_destructure();\n\t        }\n\t    }\n\t    render_destructure() {\n\t        const props = this.value_contexts.map(prop => b `#ctx[${this.block.renderer.context_lookup.get(prop.key.name).index}] = ${prop.modifier(x `#ctx[${this.value_index}]`)};`);\n\t        const get_context = this.block.renderer.component.get_unique_name(`get_${this.status}_context`);\n\t        this.block.renderer.blocks.push(b `\n\t\t\tfunction ${get_context}(#ctx) {\n\t\t\t\t${props}\n\t\t\t}\n\t\t`);\n\t        this.block.chunks.declarations.push(b `${get_context}(#ctx)`);\n\t        if (this.block.has_update_method) {\n\t            this.block.chunks.update.push(b `${get_context}(#ctx)`);\n\t        }\n\t    }\n\t}\n\tclass AwaitBlockWrapper extends Wrapper {\n\t    constructor(renderer, block, parent, node, strip_whitespace, next_sibling) {\n\t        super(renderer, block, parent, node);\n\t        this.var = { type: 'Identifier', name: 'await_block' };\n\t        this.cannot_use_innerhtml();\n\t        this.not_static_content();\n\t        block.add_dependencies(this.node.expression.dependencies);\n\t        let is_dynamic = false;\n\t        let has_intros = false;\n\t        let has_outros = false;\n\t        ['pending', 'then', 'catch'].forEach((status) => {\n\t            const child = this.node[status];\n\t            const branch = new AwaitBlockBranch(status, renderer, block, this, child, strip_whitespace, next_sibling);\n\t            renderer.blocks.push(branch.block);\n\t            if (branch.is_dynamic) {\n\t                is_dynamic = true;\n\t                // TODO should blocks update their own parents?\n\t                block.add_dependencies(branch.block.dependencies);\n\t            }\n\t            if (branch.block.has_intros)\n\t                has_intros = true;\n\t            if (branch.block.has_outros)\n\t                has_outros = true;\n\t            this[status] = branch;\n\t        });\n\t        ['pending', 'then', 'catch'].forEach(status => {\n\t            this[status].block.has_update_method = is_dynamic;\n\t            this[status].block.has_intro_method = has_intros;\n\t            this[status].block.has_outro_method = has_outros;\n\t        });\n\t        if (has_outros) {\n\t            block.add_outro();\n\t        }\n\t    }\n\t    render(block, parent_node, parent_nodes) {\n\t        const anchor = this.get_or_create_anchor(block, parent_node, parent_nodes);\n\t        const update_mount_node = this.get_update_mount_node(anchor);\n\t        const snippet = this.node.expression.manipulate(block);\n\t        const info = block.get_unique_name(`info`);\n\t        const promise = block.get_unique_name(`promise`);\n\t        block.add_variable(promise);\n\t        block.maintain_context = true;\n\t        const info_props = x `{\n\t\t\tctx: #ctx,\n\t\t\tcurrent: null,\n\t\t\ttoken: null,\n\t\t\tpending: ${this.pending.block.name},\n\t\t\tthen: ${this.then.block.name},\n\t\t\tcatch: ${this.catch.block.name},\n\t\t\tvalue: ${this.then.value_index},\n\t\t\terror: ${this.catch.value_index},\n\t\t\tblocks: ${this.pending.block.has_outro_method && x `[,,,]`}\n\t\t}`;\n\t        block.chunks.init.push(b `\n\t\t\tlet ${info} = ${info_props};\n\t\t`);\n\t        block.chunks.init.push(b `\n\t\t\t@handle_promise(${promise} = ${snippet}, ${info});\n\t\t`);\n\t        block.chunks.create.push(b `\n\t\t\t${info}.block.c();\n\t\t`);\n\t        if (parent_nodes && this.renderer.options.hydratable) {\n\t            block.chunks.claim.push(b `\n\t\t\t\t${info}.block.l(${parent_nodes});\n\t\t\t`);\n\t        }\n\t        const initial_mount_node = parent_node || '#target';\n\t        const anchor_node = parent_node ? 'null' : '#anchor';\n\t        const has_transitions = this.pending.block.has_intro_method || this.pending.block.has_outro_method;\n\t        block.chunks.mount.push(b `\n\t\t\t${info}.block.m(${initial_mount_node}, ${info}.anchor = ${anchor_node});\n\t\t\t${info}.mount = () => ${update_mount_node};\n\t\t\t${info}.anchor = ${anchor};\n\t\t`);\n\t        if (has_transitions) {\n\t            block.chunks.intro.push(b `@transition_in(${info}.block);`);\n\t        }\n\t        const dependencies = this.node.expression.dynamic_dependencies();\n\t        if (dependencies.length > 0) {\n\t            const condition = x `\n\t\t\t\t${block.renderer.dirty(dependencies)} &&\n\t\t\t\t${promise} !== (${promise} = ${snippet}) &&\n\t\t\t\t@handle_promise(${promise}, ${info})`;\n\t            block.chunks.update.push(b `${info}.ctx = #ctx;`);\n\t            if (this.pending.block.has_update_method) {\n\t                block.chunks.update.push(b `\n\t\t\t\t\tif (${condition}) {\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst #child_ctx = #ctx.slice();\n\t\t\t\t\t\t${this.then.value && b `#child_ctx[${this.then.value_index}] = ${info}.resolved;`}\n\t\t\t\t\t\t${info}.block.p(#child_ctx, #dirty);\n\t\t\t\t\t}\n\t\t\t\t`);\n\t            }\n\t            else {\n\t                block.chunks.update.push(b `\n\t\t\t\t\t${condition}\n\t\t\t\t`);\n\t            }\n\t        }\n\t        else {\n\t            if (this.pending.block.has_update_method) {\n\t                block.chunks.update.push(b `\n\t\t\t\t\t{\n\t\t\t\t\t\tconst #child_ctx = #ctx.slice();\n\t\t\t\t\t\t${this.then.value && b `#child_ctx[${this.then.value_index}] = ${info}.resolved;`}\n\t\t\t\t\t\t${info}.block.p(#child_ctx, #dirty);\n\t\t\t\t\t}\n\t\t\t\t`);\n\t            }\n\t        }\n\t        if (this.pending.block.has_outro_method) {\n\t            block.chunks.outro.push(b `\n\t\t\t\tfor (let #i = 0; #i < 3; #i += 1) {\n\t\t\t\t\tconst block = ${info}.blocks[#i];\n\t\t\t\t\t@transition_out(block);\n\t\t\t\t}\n\t\t\t`);\n\t        }\n\t        block.chunks.destroy.push(b `\n\t\t\t${info}.block.d(${parent_node ? null : 'detaching'});\n\t\t\t${info}.token = null;\n\t\t\t${info} = null;\n\t\t`);\n\t        [this.pending, this.then, this.catch].forEach(branch => {\n\t            branch.render(branch.block, null, x `#nodes`);\n\t        });\n\t    }\n\t}\n\n\tconst TRUE = x `true`;\n\tconst FALSE = x `false`;\n\tclass EventHandlerWrapper {\n\t    constructor(node, parent) {\n\t        this.node = node;\n\t        this.parent = parent;\n\t        if (!node.expression) {\n\t            this.parent.renderer.add_to_context(node.handler_name.name);\n\t            this.parent.renderer.component.partly_hoisted.push(b `\n\t\t\t\tfunction ${node.handler_name.name}(event) {\n\t\t\t\t\t@bubble($$self, event);\n\t\t\t\t}\n\t\t\t`);\n\t        }\n\t    }\n\t    get_snippet(block) {\n\t        const snippet = this.node.expression ? this.node.expression.manipulate(block) : block.renderer.reference(this.node.handler_name);\n\t        if (this.node.reassigned) {\n\t            block.maintain_context = true;\n\t            return x `function () { if (@is_function(${snippet})) ${snippet}.apply(this, arguments); }`;\n\t        }\n\t        return snippet;\n\t    }\n\t    render(block, target) {\n\t        let snippet = this.get_snippet(block);\n\t        if (this.node.modifiers.has('preventDefault'))\n\t            snippet = x `@prevent_default(${snippet})`;\n\t        if (this.node.modifiers.has('stopPropagation'))\n\t            snippet = x `@stop_propagation(${snippet})`;\n\t        if (this.node.modifiers.has('self'))\n\t            snippet = x `@self(${snippet})`;\n\t        const args = [];\n\t        const opts = ['passive', 'once', 'capture'].filter(mod => this.node.modifiers.has(mod));\n\t        if (opts.length) {\n\t            args.push((opts.length === 1 && opts[0] === 'capture')\n\t                ? TRUE\n\t                : x `{ ${opts.map(opt => p `${opt}: true`)} }`);\n\t        }\n\t        else if (block.renderer.options.dev) {\n\t            args.push(FALSE);\n\t        }\n\t        if (block.renderer.options.dev) {\n\t            args.push(this.node.modifiers.has('preventDefault') ? TRUE : FALSE);\n\t            args.push(this.node.modifiers.has('stopPropagation') ? TRUE : FALSE);\n\t        }\n\t        block.event_listeners.push(x `@listen(${target}, \"${this.node.name}\", ${snippet}, ${args})`);\n\t    }\n\t}\n\n\tfunction add_event_handlers(block, target, handlers) {\n\t    handlers.forEach(handler => add_event_handler(block, target, handler));\n\t}\n\tfunction add_event_handler(block, target, handler) {\n\t    handler.render(block, target);\n\t}\n\n\tclass BodyWrapper extends Wrapper {\n\t    constructor(renderer, block, parent, node) {\n\t        super(renderer, block, parent, node);\n\t        this.handlers = this.node.handlers.map(handler => new EventHandlerWrapper(handler, this));\n\t    }\n\t    render(block, _parent_node, _parent_nodes) {\n\t        add_event_handlers(block, x `@_document.body`, this.handlers);\n\t    }\n\t}\n\n\tfunction add_to_set(a, b) {\n\t    // @ts-ignore\n\t    b.forEach(item => {\n\t        a.add(item);\n\t    });\n\t}\n\n\tclass DebugTagWrapper extends Wrapper {\n\t    constructor(renderer, block, parent, node, _strip_whitespace, _next_sibling) {\n\t        super(renderer, block, parent, node);\n\t    }\n\t    render(block, _parent_node, _parent_nodes) {\n\t        const { renderer } = this;\n\t        const { component } = renderer;\n\t        if (!renderer.options.dev)\n\t            return;\n\t        const { var_lookup } = component;\n\t        const start = component.locate(this.node.start + 1);\n\t        const end = { line: start.line, column: start.column + 6 };\n\t        const loc = { start, end };\n\t        const debug = {\n\t            type: 'DebuggerStatement',\n\t            loc\n\t        };\n\t        if (this.node.expressions.length === 0) {\n\t            // Debug all\n\t            block.chunks.create.push(debug);\n\t            block.chunks.update.push(debug);\n\t        }\n\t        else {\n\t            const log = {\n\t                type: 'Identifier',\n\t                name: 'log',\n\t                loc\n\t            };\n\t            const dependencies = new Set();\n\t            this.node.expressions.forEach(expression => {\n\t                add_to_set(dependencies, expression.dependencies);\n\t            });\n\t            const contextual_identifiers = this.node.expressions\n\t                .filter(e => {\n\t                const variable = var_lookup.get(e.node.name);\n\t                return !(variable && variable.hoistable);\n\t            })\n\t                .map(e => e.node.name);\n\t            const logged_identifiers = this.node.expressions.map(e => p `${e.node.name}`);\n\t            const debug_statements = b `\n\t\t\t\t${contextual_identifiers.map(name => b `const ${name} = ${renderer.reference(name)};`)}\n\t\t\t\t@_console.${log}({ ${logged_identifiers} });\n\t\t\t\tdebugger;`;\n\t            if (dependencies.size) {\n\t                const condition = renderer.dirty(Array.from(dependencies));\n\t                block.chunks.update.push(b `\n\t\t\t\t\tif (${condition}) {\n\t\t\t\t\t\t${debug_statements}\n\t\t\t\t\t}\n\t\t\t\t`);\n\t            }\n\t            block.chunks.create.push(b `{\n\t\t\t\t${debug_statements}\n\t\t\t}`);\n\t        }\n\t    }\n\t}\n\n\tclass ElseBlockWrapper extends Wrapper {\n\t    constructor(renderer, block, parent, node, strip_whitespace, next_sibling) {\n\t        super(renderer, block, parent, node);\n\t        this.var = null;\n\t        this.block = block.child({\n\t            comment: create_debugging_comment(node, this.renderer.component),\n\t            name: this.renderer.component.get_unique_name(`create_else_block`),\n\t            type: 'else'\n\t        });\n\t        this.fragment = new FragmentWrapper(renderer, this.block, this.node.children, parent, strip_whitespace, next_sibling);\n\t        this.is_dynamic = this.block.dependencies.size > 0;\n\t    }\n\t}\n\tclass EachBlockWrapper extends Wrapper {\n\t    constructor(renderer, block, parent, node, strip_whitespace, next_sibling) {\n\t        super(renderer, block, parent, node);\n\t        this.updates = [];\n\t        this.var = { type: 'Identifier', name: 'each' };\n\t        this.cannot_use_innerhtml();\n\t        this.not_static_content();\n\t        const { dependencies } = node.expression;\n\t        block.add_dependencies(dependencies);\n\t        this.node.contexts.forEach(context => {\n\t            renderer.add_to_context(context.key.name, true);\n\t        });\n\t        this.block = block.child({\n\t            comment: create_debugging_comment(this.node, this.renderer.component),\n\t            name: renderer.component.get_unique_name('create_each_block'),\n\t            type: 'each',\n\t            // @ts-ignore todo: probably error\n\t            key: node.key,\n\t            bindings: new Map(block.bindings)\n\t        });\n\t        // TODO this seems messy\n\t        this.block.has_animation = this.node.has_animation;\n\t        this.index_name = this.node.index\n\t            ? { type: 'Identifier', name: this.node.index }\n\t            : renderer.component.get_unique_name(`${this.node.context}_index`);\n\t        const fixed_length = node.expression.node.type === 'ArrayExpression' &&\n\t            node.expression.node.elements.every(element => element.type !== 'SpreadElement')\n\t            ? node.expression.node.elements.length\n\t            : null;\n\t        // hack the sourcemap, so that if data is missing the bug\n\t        // is easy to find\n\t        let c = this.node.start + 2;\n\t        while (renderer.component.source[c] !== 'e')\n\t            c += 1;\n\t        const start = renderer.component.locate(c);\n\t        const end = { line: start.line, column: start.column + 4 };\n\t        const length = {\n\t            type: 'Identifier',\n\t            name: 'length',\n\t            loc: { start, end }\n\t        };\n\t        const each_block_value = renderer.component.get_unique_name(`${this.var.name}_value`);\n\t        const iterations = block.get_unique_name(`${this.var.name}_blocks`);\n\t        renderer.add_to_context(each_block_value.name, true);\n\t        renderer.add_to_context(this.index_name.name, true);\n\t        this.vars = {\n\t            create_each_block: this.block.name,\n\t            each_block_value,\n\t            get_each_context: renderer.component.get_unique_name(`get_${this.var.name}_context`),\n\t            iterations,\n\t            // optimisation for array literal\n\t            fixed_length,\n\t            data_length: fixed_length === null ? x `${each_block_value}.${length}` : fixed_length,\n\t            view_length: fixed_length === null ? x `${iterations}.length` : fixed_length\n\t        };\n\t        const store = node.expression.node.type === 'Identifier' &&\n\t            node.expression.node.name[0] === '$'\n\t            ? node.expression.node.name.slice(1)\n\t            : null;\n\t        node.contexts.forEach(prop => {\n\t            this.block.bindings.set(prop.key.name, {\n\t                object: this.vars.each_block_value,\n\t                property: this.index_name,\n\t                modifier: prop.modifier,\n\t                snippet: prop.modifier(x `${this.vars.each_block_value}[${this.index_name}]`),\n\t                store,\n\t                tail: prop.modifier(x `[${this.index_name}]`)\n\t            });\n\t        });\n\t        if (this.node.index) {\n\t            this.block.get_unique_name(this.node.index); // this prevents name collisions (#1254)\n\t        }\n\t        renderer.blocks.push(this.block);\n\t        this.fragment = new FragmentWrapper(renderer, this.block, node.children, this, strip_whitespace, next_sibling);\n\t        if (this.node.else) {\n\t            this.else = new ElseBlockWrapper(renderer, block, this, this.node.else, strip_whitespace, next_sibling);\n\t            renderer.blocks.push(this.else.block);\n\t            if (this.else.is_dynamic) {\n\t                this.block.add_dependencies(this.else.block.dependencies);\n\t            }\n\t        }\n\t        block.add_dependencies(this.block.dependencies);\n\t        if (this.block.has_outros || (this.else && this.else.block.has_outros)) {\n\t            block.add_outro();\n\t        }\n\t    }\n\t    render(block, parent_node, parent_nodes) {\n\t        if (this.fragment.nodes.length === 0)\n\t            return;\n\t        const { renderer } = this;\n\t        const { component } = renderer;\n\t        const needs_anchor = this.next\n\t            ? !this.next.is_dom_node() :\n\t            !parent_node || !this.parent.is_dom_node();\n\t        this.context_props = this.node.contexts.map(prop => b `child_ctx[${renderer.context_lookup.get(prop.key.name).index}] = ${prop.modifier(x `list[i]`)};`);\n\t        if (this.node.has_binding)\n\t            this.context_props.push(b `child_ctx[${renderer.context_lookup.get(this.vars.each_block_value.name).index}] = list;`);\n\t        if (this.node.has_binding || this.node.has_index_binding || this.node.index)\n\t            this.context_props.push(b `child_ctx[${renderer.context_lookup.get(this.index_name.name).index}] = i;`);\n\t        const snippet = this.node.expression.manipulate(block);\n\t        block.chunks.init.push(b `let ${this.vars.each_block_value} = ${snippet};`);\n\t        if (this.renderer.options.dev) {\n\t            block.chunks.init.push(b `@validate_each_argument(${this.vars.each_block_value});`);\n\t        }\n\t        // TODO which is better \u2014 Object.create(array) or array.slice()?\n\t        renderer.blocks.push(b `\n\t\t\tfunction ${this.vars.get_each_context}(#ctx, list, i) {\n\t\t\t\tconst child_ctx = #ctx.slice();\n\t\t\t\t${this.context_props}\n\t\t\t\treturn child_ctx;\n\t\t\t}\n\t\t`);\n\t        const initial_anchor_node = { type: 'Identifier', name: parent_node ? 'null' : '#anchor' };\n\t        const initial_mount_node = parent_node || { type: 'Identifier', name: '#target' };\n\t        const update_anchor_node = needs_anchor\n\t            ? block.get_unique_name(`${this.var.name}_anchor`)\n\t            : (this.next && this.next.var) || { type: 'Identifier', name: 'null' };\n\t        const update_mount_node = this.get_update_mount_node(update_anchor_node);\n\t        const args = {\n\t            block,\n\t            parent_node,\n\t            parent_nodes,\n\t            snippet,\n\t            initial_anchor_node,\n\t            initial_mount_node,\n\t            update_anchor_node,\n\t            update_mount_node\n\t        };\n\t        const all_dependencies = new Set(this.block.dependencies); // TODO should be dynamic deps only\n\t        this.node.expression.dynamic_dependencies().forEach((dependency) => {\n\t            all_dependencies.add(dependency);\n\t        });\n\t        this.dependencies = all_dependencies;\n\t        if (this.node.key) {\n\t            this.render_keyed(args);\n\t        }\n\t        else {\n\t            this.render_unkeyed(args);\n\t        }\n\t        if (this.block.has_intro_method || this.block.has_outro_method) {\n\t            block.chunks.intro.push(b `\n\t\t\t\tfor (let #i = 0; #i < ${this.vars.data_length}; #i += 1) {\n\t\t\t\t\t@transition_in(${this.vars.iterations}[#i]);\n\t\t\t\t}\n\t\t\t`);\n\t        }\n\t        if (needs_anchor) {\n\t            block.add_element(update_anchor_node, x `@empty()`, parent_nodes && x `@empty()`, parent_node);\n\t        }\n\t        if (this.else) {\n\t            const each_block_else = component.get_unique_name(`${this.var.name}_else`);\n\t            block.chunks.init.push(b `let ${each_block_else} = null;`);\n\t            // TODO neaten this up... will end up with an empty line in the block\n\t            block.chunks.init.push(b `\n\t\t\t\tif (!${this.vars.data_length}) {\n\t\t\t\t\t${each_block_else} = ${this.else.block.name}(#ctx);\n\t\t\t\t}\n\t\t\t`);\n\t            block.chunks.create.push(b `\n\t\t\t\tif (${each_block_else}) {\n\t\t\t\t\t${each_block_else}.c();\n\t\t\t\t}\n\t\t\t`);\n\t            if (this.renderer.options.hydratable) {\n\t                block.chunks.claim.push(b `\n\t\t\t\t\tif (${each_block_else}) {\n\t\t\t\t\t\t${each_block_else}.l(${parent_nodes});\n\t\t\t\t\t}\n\t\t\t\t`);\n\t            }\n\t            block.chunks.mount.push(b `\n\t\t\t\tif (${each_block_else}) {\n\t\t\t\t\t${each_block_else}.m(${initial_mount_node}, ${initial_anchor_node});\n\t\t\t\t}\n\t\t\t`);\n\t            if (this.else.block.has_update_method) {\n\t                this.updates.push(b `\n\t\t\t\t\tif (!${this.vars.data_length} && ${each_block_else}) {\n\t\t\t\t\t\t${each_block_else}.p(#ctx, #dirty);\n\t\t\t\t\t} else if (!${this.vars.data_length}) {\n\t\t\t\t\t\t${each_block_else} = ${this.else.block.name}(#ctx);\n\t\t\t\t\t\t${each_block_else}.c();\n\t\t\t\t\t\t${each_block_else}.m(${update_mount_node}, ${update_anchor_node});\n\t\t\t\t\t} else if (${each_block_else}) {\n\t\t\t\t\t\t${each_block_else}.d(1);\n\t\t\t\t\t\t${each_block_else} = null;\n\t\t\t\t\t}\n\t\t\t\t`);\n\t            }\n\t            else {\n\t                this.updates.push(b `\n\t\t\t\t\tif (${this.vars.data_length}) {\n\t\t\t\t\t\tif (${each_block_else}) {\n\t\t\t\t\t\t\t${each_block_else}.d(1);\n\t\t\t\t\t\t\t${each_block_else} = null;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (!${each_block_else}) {\n\t\t\t\t\t\t${each_block_else} = ${this.else.block.name}(#ctx);\n\t\t\t\t\t\t${each_block_else}.c();\n\t\t\t\t\t\t${each_block_else}.m(${update_mount_node}, ${update_anchor_node});\n\t\t\t\t\t}\n\t\t\t\t`);\n\t            }\n\t            block.chunks.destroy.push(b `\n\t\t\t\tif (${each_block_else}) ${each_block_else}.d(${parent_node ? '' : 'detaching'});\n\t\t\t`);\n\t        }\n\t        if (this.updates.length) {\n\t            block.chunks.update.push(b `\n\t\t\t\tif (${block.renderer.dirty(Array.from(all_dependencies))}) {\n\t\t\t\t\t${this.updates}\n\t\t\t\t}\n\t\t\t`);\n\t        }\n\t        this.fragment.render(this.block, null, x `#nodes`);\n\t        if (this.else) {\n\t            this.else.fragment.render(this.else.block, null, x `#nodes`);\n\t        }\n\t    }\n\t    render_keyed({ block, parent_node, parent_nodes, snippet, initial_anchor_node, initial_mount_node, update_anchor_node, update_mount_node }) {\n\t        const { create_each_block, iterations, data_length, view_length } = this.vars;\n\t        const get_key = block.get_unique_name('get_key');\n\t        const lookup = block.get_unique_name(`${this.var.name}_lookup`);\n\t        block.add_variable(iterations, x `[]`);\n\t        block.add_variable(lookup, x `new @_Map()`);\n\t        if (this.fragment.nodes[0].is_dom_node()) {\n\t            this.block.first = this.fragment.nodes[0].var;\n\t        }\n\t        else {\n\t            this.block.first = this.block.get_unique_name('first');\n\t            this.block.add_element(this.block.first, x `@empty()`, parent_nodes && x `@empty()`, null);\n\t        }\n\t        block.chunks.init.push(b `\n\t\t\tconst ${get_key} = #ctx => ${this.node.key.manipulate(block)};\n\n\t\t\t${this.renderer.options.dev && b `@validate_each_keys(#ctx, ${this.vars.each_block_value}, ${this.vars.get_each_context}, ${get_key});`}\n\t\t\tfor (let #i = 0; #i < ${data_length}; #i += 1) {\n\t\t\t\tlet child_ctx = ${this.vars.get_each_context}(#ctx, ${this.vars.each_block_value}, #i);\n\t\t\t\tlet key = ${get_key}(child_ctx);\n\t\t\t\t${lookup}.set(key, ${iterations}[#i] = ${create_each_block}(key, child_ctx));\n\t\t\t}\n\t\t`);\n\t        block.chunks.create.push(b `\n\t\t\tfor (let #i = 0; #i < ${view_length}; #i += 1) {\n\t\t\t\t${iterations}[#i].c();\n\t\t\t}\n\t\t`);\n\t        if (parent_nodes && this.renderer.options.hydratable) {\n\t            block.chunks.claim.push(b `\n\t\t\t\tfor (let #i = 0; #i < ${view_length}; #i += 1) {\n\t\t\t\t\t${iterations}[#i].l(${parent_nodes});\n\t\t\t\t}\n\t\t\t`);\n\t        }\n\t        block.chunks.mount.push(b `\n\t\t\tfor (let #i = 0; #i < ${view_length}; #i += 1) {\n\t\t\t\t${iterations}[#i].m(${initial_mount_node}, ${initial_anchor_node});\n\t\t\t}\n\t\t`);\n\t        const dynamic = this.block.has_update_method;\n\t        const destroy = this.node.has_animation\n\t            ? (this.block.has_outros\n\t                ? `@fix_and_outro_and_destroy_block`\n\t                : `@fix_and_destroy_block`)\n\t            : this.block.has_outros\n\t                ? `@outro_and_destroy_block`\n\t                : `@destroy_block`;\n\t        if (this.dependencies.size) {\n\t            this.updates.push(b `\n\t\t\t\tconst ${this.vars.each_block_value} = ${snippet};\n\t\t\t\t${this.renderer.options.dev && b `@validate_each_argument(${this.vars.each_block_value});`}\n\n\t\t\t\t${this.block.has_outros && b `@group_outros();`}\n\t\t\t\t${this.node.has_animation && b `for (let #i = 0; #i < ${view_length}; #i += 1) ${iterations}[#i].r();`}\n\t\t\t\t${this.renderer.options.dev && b `@validate_each_keys(#ctx, ${this.vars.each_block_value}, ${this.vars.get_each_context}, ${get_key});`}\n\t\t\t\t${iterations} = @update_keyed_each(${iterations}, #dirty, ${get_key}, ${dynamic ? 1 : 0}, #ctx, ${this.vars.each_block_value}, ${lookup}, ${update_mount_node}, ${destroy}, ${create_each_block}, ${update_anchor_node}, ${this.vars.get_each_context});\n\t\t\t\t${this.node.has_animation && b `for (let #i = 0; #i < ${view_length}; #i += 1) ${iterations}[#i].a();`}\n\t\t\t\t${this.block.has_outros && b `@check_outros();`}\n\t\t\t`);\n\t        }\n\t        if (this.block.has_outros) {\n\t            block.chunks.outro.push(b `\n\t\t\t\tfor (let #i = 0; #i < ${view_length}; #i += 1) {\n\t\t\t\t\t@transition_out(${iterations}[#i]);\n\t\t\t\t}\n\t\t\t`);\n\t        }\n\t        block.chunks.destroy.push(b `\n\t\t\tfor (let #i = 0; #i < ${view_length}; #i += 1) {\n\t\t\t\t${iterations}[#i].d(${parent_node ? null : 'detaching'});\n\t\t\t}\n\t\t`);\n\t    }\n\t    render_unkeyed({ block, parent_nodes, snippet, initial_anchor_node, initial_mount_node, update_anchor_node, update_mount_node }) {\n\t        const { create_each_block, iterations, fixed_length, data_length, view_length } = this.vars;\n\t        block.chunks.init.push(b `\n\t\t\tlet ${iterations} = [];\n\n\t\t\tfor (let #i = 0; #i < ${data_length}; #i += 1) {\n\t\t\t\t${iterations}[#i] = ${create_each_block}(${this.vars.get_each_context}(#ctx, ${this.vars.each_block_value}, #i));\n\t\t\t}\n\t\t`);\n\t        block.chunks.create.push(b `\n\t\t\tfor (let #i = 0; #i < ${view_length}; #i += 1) {\n\t\t\t\t${iterations}[#i].c();\n\t\t\t}\n\t\t`);\n\t        if (parent_nodes && this.renderer.options.hydratable) {\n\t            block.chunks.claim.push(b `\n\t\t\t\tfor (let #i = 0; #i < ${view_length}; #i += 1) {\n\t\t\t\t\t${iterations}[#i].l(${parent_nodes});\n\t\t\t\t}\n\t\t\t`);\n\t        }\n\t        block.chunks.mount.push(b `\n\t\t\tfor (let #i = 0; #i < ${view_length}; #i += 1) {\n\t\t\t\t${iterations}[#i].m(${initial_mount_node}, ${initial_anchor_node});\n\t\t\t}\n\t\t`);\n\t        if (this.dependencies.size) {\n\t            const has_transitions = !!(this.block.has_intro_method || this.block.has_outro_method);\n\t            const for_loop_body = this.block.has_update_method\n\t                ? b `\n\t\t\t\t\tif (${iterations}[#i]) {\n\t\t\t\t\t\t${iterations}[#i].p(child_ctx, #dirty);\n\t\t\t\t\t\t${has_transitions && b `@transition_in(${this.vars.iterations}[#i], 1);`}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t${iterations}[#i] = ${create_each_block}(child_ctx);\n\t\t\t\t\t\t${iterations}[#i].c();\n\t\t\t\t\t\t${has_transitions && b `@transition_in(${this.vars.iterations}[#i], 1);`}\n\t\t\t\t\t\t${iterations}[#i].m(${update_mount_node}, ${update_anchor_node});\n\t\t\t\t\t}\n\t\t\t\t`\n\t                : has_transitions\n\t                    ? b `\n\t\t\t\t\t\tif (${iterations}[#i]) {\n\t\t\t\t\t\t\t@transition_in(${this.vars.iterations}[#i], 1);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t${iterations}[#i] = ${create_each_block}(child_ctx);\n\t\t\t\t\t\t\t${iterations}[#i].c();\n\t\t\t\t\t\t\t@transition_in(${this.vars.iterations}[#i], 1);\n\t\t\t\t\t\t\t${iterations}[#i].m(${update_mount_node}, ${update_anchor_node});\n\t\t\t\t\t\t}\n\t\t\t\t\t`\n\t                    : b `\n\t\t\t\t\t\tif (!${iterations}[#i]) {\n\t\t\t\t\t\t\t${iterations}[#i] = ${create_each_block}(child_ctx);\n\t\t\t\t\t\t\t${iterations}[#i].c();\n\t\t\t\t\t\t\t${iterations}[#i].m(${update_mount_node}, ${update_anchor_node});\n\t\t\t\t\t\t}\n\t\t\t\t\t`;\n\t            const start = this.block.has_update_method ? 0 : `#old_length`;\n\t            let remove_old_blocks;\n\t            if (this.block.has_outros) {\n\t                const out = block.get_unique_name('out');\n\t                block.chunks.init.push(b `\n\t\t\t\t\tconst ${out} = i => @transition_out(${iterations}[i], 1, 1, () => {\n\t\t\t\t\t\t${iterations}[i] = null;\n\t\t\t\t\t});\n\t\t\t\t`);\n\t                remove_old_blocks = b `\n\t\t\t\t\t@group_outros();\n\t\t\t\t\tfor (#i = ${data_length}; #i < ${view_length}; #i += 1) {\n\t\t\t\t\t\t${out}(#i);\n\t\t\t\t\t}\n\t\t\t\t\t@check_outros();\n\t\t\t\t`;\n\t            }\n\t            else {\n\t                remove_old_blocks = b `\n\t\t\t\t\tfor (${this.block.has_update_method ? null : x `#i = ${data_length}`}; #i < ${this.block.has_update_method ? view_length : '#old_length'}; #i += 1) {\n\t\t\t\t\t\t${iterations}[#i].d(1);\n\t\t\t\t\t}\n\t\t\t\t\t${!fixed_length && b `${view_length} = ${data_length};`}\n\t\t\t\t`;\n\t            }\n\t            // We declare `i` as block scoped here, as the `remove_old_blocks` code\n\t            // may rely on continuing where this iteration stopped.\n\t            const update = b `\n\t\t\t\t${!this.block.has_update_method && b `const #old_length = ${this.vars.each_block_value}.length;`}\n\t\t\t\t${this.vars.each_block_value} = ${snippet};\n\t\t\t\t${this.renderer.options.dev && b `@validate_each_argument(${this.vars.each_block_value});`}\n\n\t\t\t\tlet #i;\n\t\t\t\tfor (#i = ${start}; #i < ${data_length}; #i += 1) {\n\t\t\t\t\tconst child_ctx = ${this.vars.get_each_context}(#ctx, ${this.vars.each_block_value}, #i);\n\n\t\t\t\t\t${for_loop_body}\n\t\t\t\t}\n\n\t\t\t\t${remove_old_blocks}\n\t\t\t`;\n\t            this.updates.push(update);\n\t        }\n\t        if (this.block.has_outros) {\n\t            block.chunks.outro.push(b `\n\t\t\t\t${iterations} = ${iterations}.filter(@_Boolean);\n\t\t\t\tfor (let #i = 0; #i < ${view_length}; #i += 1) {\n\t\t\t\t\t@transition_out(${iterations}[#i]);\n\t\t\t\t}\n\t\t\t`);\n\t        }\n\t        block.chunks.destroy.push(b `@destroy_each(${iterations}, detaching);`);\n\t    }\n\t}\n\n\tfunction string_literal(data) {\n\t    return {\n\t        type: 'Literal',\n\t        value: data\n\t    };\n\t}\n\tconst escaped = {\n\t    '\"': '&quot;',\n\t    \"'\": '&#39;',\n\t    '&': '&amp;',\n\t    '<': '&lt;',\n\t    '>': '&gt;',\n\t};\n\tfunction escape_html(html) {\n\t    return String(html).replace(/[\"'&<>]/g, match => escaped[match]);\n\t}\n\tfunction escape_template(str) {\n\t    return str.replace(/(\\${|`|\\\\)/g, '\\\\$1');\n\t}\n\n\tclass TextWrapper extends Wrapper {\n\t    constructor(renderer, block, parent, node, data) {\n\t        super(renderer, block, parent, node);\n\t        this.skip = this.node.should_skip();\n\t        this.data = data;\n\t        this.var = (this.skip ? null : x `t`);\n\t    }\n\t    use_space() {\n\t        if (this.renderer.component.component_options.preserveWhitespace)\n\t            return false;\n\t        if (/[\\S\\u00A0]/.test(this.data))\n\t            return false;\n\t        let node = this.parent && this.parent.node;\n\t        while (node) {\n\t            if (node.type === 'Element' && node.name === 'pre') {\n\t                return false;\n\t            }\n\t            node = node.parent;\n\t        }\n\t        return true;\n\t    }\n\t    render(block, parent_node, parent_nodes) {\n\t        if (this.skip)\n\t            return;\n\t        const use_space = this.use_space();\n\t        block.add_element(this.var, use_space ? x `@space()` : x `@text(\"${this.data}\")`, parent_nodes && (use_space ? x `@claim_space(${parent_nodes})` : x `@claim_text(${parent_nodes}, \"${this.data}\")`), parent_node);\n\t    }\n\t}\n\n\tconst svg_attributes = 'accent-height accumulate additive alignment-baseline allowReorder alphabetic amplitude arabic-form ascent attributeName attributeType autoReverse azimuth baseFrequency baseline-shift baseProfile bbox begin bias by calcMode cap-height class clip clipPathUnits clip-path clip-rule color color-interpolation color-interpolation-filters color-profile color-rendering contentScriptType contentStyleType cursor cx cy d decelerate descent diffuseConstant direction display divisor dominant-baseline dur dx dy edgeMode elevation enable-background end exponent externalResourcesRequired fill fill-opacity fill-rule filter filterRes filterUnits flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight format from fr fx fy g1 g2 glyph-name glyph-orientation-horizontal glyph-orientation-vertical glyphRef gradientTransform gradientUnits hanging height href horiz-adv-x horiz-origin-x id ideographic image-rendering in in2 intercept k k1 k2 k3 k4 kernelMatrix kernelUnitLength kerning keyPoints keySplines keyTimes lang lengthAdjust letter-spacing lighting-color limitingConeAngle local marker-end marker-mid marker-start markerHeight markerUnits markerWidth mask maskContentUnits maskUnits mathematical max media method min mode name numOctaves offset onabort onactivate onbegin onclick onend onerror onfocusin onfocusout onload onmousedown onmousemove onmouseout onmouseover onmouseup onrepeat onresize onscroll onunload opacity operator order orient orientation origin overflow overline-position overline-thickness panose-1 paint-order pathLength patternContentUnits patternTransform patternUnits pointer-events points pointsAtX pointsAtY pointsAtZ preserveAlpha preserveAspectRatio primitiveUnits r radius refX refY rendering-intent repeatCount repeatDur requiredExtensions requiredFeatures restart result rotate rx ry scale seed shape-rendering slope spacing specularConstant specularExponent speed spreadMethod startOffset stdDeviation stemh stemv stitchTiles stop-color stop-opacity strikethrough-position strikethrough-thickness string stroke stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width style surfaceScale systemLanguage tabindex tableValues target targetX targetY text-anchor text-decoration text-rendering textLength to transform type u1 u2 underline-position underline-thickness unicode unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical values version vert-adv-y vert-origin-x vert-origin-y viewBox viewTarget visibility width widths word-spacing writing-mode x x-height x1 x2 xChannelSelector xlink:actuate xlink:arcrole xlink:href xlink:role xlink:show xlink:title xlink:type xml:base xml:lang xml:space y y1 y2 yChannelSelector z zoomAndPan'.split(' ');\n\tconst svg_attribute_lookup = new Map();\n\tsvg_attributes.forEach(name => {\n\t    svg_attribute_lookup.set(name.toLowerCase(), name);\n\t});\n\tfunction fix_attribute_casing(name) {\n\t    name = name.toLowerCase();\n\t    return svg_attribute_lookup.get(name) || name;\n\t}\n\n\tconst html = 'http://www.w3.org/1999/xhtml';\n\tconst mathml = 'http://www.w3.org/1998/Math/MathML';\n\tconst svg = 'http://www.w3.org/2000/svg';\n\tconst xlink = 'http://www.w3.org/1999/xlink';\n\tconst xml = 'http://www.w3.org/XML/1998/namespace';\n\tconst xmlns = 'http://www.w3.org/2000/xmlns';\n\tconst valid_namespaces = [\n\t    'html',\n\t    'mathml',\n\t    'svg',\n\t    'xlink',\n\t    'xml',\n\t    'xmlns',\n\t    html,\n\t    mathml,\n\t    svg,\n\t    xlink,\n\t    xml,\n\t    xmlns,\n\t];\n\tconst namespaces = { html, mathml, svg, xlink, xml, xmlns };\n\n\tfunction handle_select_value_binding(attr, dependencies) {\n\t    const { parent } = attr;\n\t    if (parent.node.name === \"select\") {\n\t        parent.select_binding_dependencies = dependencies;\n\t        dependencies.forEach((prop) => {\n\t            parent.renderer.component.indirect_dependencies.set(prop, new Set());\n\t        });\n\t    }\n\t}\n\n\tclass BaseAttributeWrapper {\n\t    constructor(parent, block, node) {\n\t        this.node = node;\n\t        this.parent = parent;\n\t        if (node.dependencies.size > 0) {\n\t            parent.cannot_use_innerhtml();\n\t            parent.not_static_content();\n\t            block.add_dependencies(node.dependencies);\n\t        }\n\t    }\n\t    render(_block) { }\n\t}\n\tclass AttributeWrapper extends BaseAttributeWrapper {\n\t    constructor(parent, block, node) {\n\t        super(parent, block, node);\n\t        if (node.dependencies.size > 0) {\n\t            // special case \u2014 <option value={foo}> \u2014 see below\n\t            if (this.parent.node.name === 'option' && node.name === 'value') {\n\t                let select = this.parent;\n\t                while (select && (select.node.type !== 'Element' || select.node.name !== 'select'))\n\t                    // @ts-ignore todo: doublecheck this, but looks to be correct\n\t                    select = select.parent;\n\t                if (select && select.select_binding_dependencies) {\n\t                    select.select_binding_dependencies.forEach(prop => {\n\t                        this.node.dependencies.forEach((dependency) => {\n\t                            this.parent.renderer.component.indirect_dependencies.get(prop).add(dependency);\n\t                        });\n\t                    });\n\t                }\n\t            }\n\t            if (node.name === 'value') {\n\t                handle_select_value_binding(this, node.dependencies);\n\t            }\n\t        }\n\t        this.name = fix_attribute_casing(this.node.name);\n\t        this.metadata = this.get_metadata();\n\t        this.is_indirectly_bound_value = is_indirectly_bound_value(this);\n\t        this.property_name = this.is_indirectly_bound_value\n\t            ? '__value'\n\t            : this.metadata && this.metadata.property_name;\n\t        this.is_src = this.name === 'src'; // TODO retire this exception in favour of https://github.com/sveltejs/svelte/issues/3750\n\t        this.is_select_value_attribute = this.name === 'value' && this.parent.node.name === 'select';\n\t        this.is_input_value = this.name === 'value' && this.parent.node.name === 'input';\n\t        this.should_cache = should_cache(this);\n\t    }\n\t    render(block) {\n\t        const element = this.parent;\n\t        const { name, property_name, should_cache, is_indirectly_bound_value } = this;\n\t        // xlink is a special case... we could maybe extend this to generic\n\t        // namespaced attributes but I'm not sure that's applicable in\n\t        // HTML5?\n\t        const method = /-/.test(element.node.name)\n\t            ? '@set_custom_element_data'\n\t            : name.slice(0, 6) === 'xlink:'\n\t                ? '@xlink_attr'\n\t                : '@attr';\n\t        const is_legacy_input_type = element.renderer.component.compile_options.legacy && name === 'type' && this.parent.node.name === 'input';\n\t        const dependencies = this.get_dependencies();\n\t        const value = this.get_value(block);\n\t        let updater;\n\t        const init = this.get_init(block, value);\n\t        if (is_legacy_input_type) {\n\t            block.chunks.hydrate.push(b `@set_input_type(${element.var}, ${init});`);\n\t            updater = b `@set_input_type(${element.var}, ${should_cache ? this.last : value});`;\n\t        }\n\t        else if (this.is_select_value_attribute) {\n\t            // annoying special case\n\t            const is_multiple_select = element.node.get_static_attribute_value('multiple');\n\t            if (is_multiple_select) {\n\t                updater = b `@select_options(${element.var}, ${value});`;\n\t            }\n\t            else {\n\t                updater = b `@select_option(${element.var}, ${value});`;\n\t            }\n\t            block.chunks.mount.push(b `\n\t\t\t\t${updater}\n\t\t\t`);\n\t        }\n\t        else if (this.is_src) {\n\t            block.chunks.hydrate.push(b `if (${element.var}.src !== ${init}) ${method}(${element.var}, \"${name}\", ${this.last});`);\n\t            updater = b `${method}(${element.var}, \"${name}\", ${should_cache ? this.last : value});`;\n\t        }\n\t        else if (property_name) {\n\t            block.chunks.hydrate.push(b `${element.var}.${property_name} = ${init};`);\n\t            updater = block.renderer.options.dev\n\t                ? b `@prop_dev(${element.var}, \"${property_name}\", ${should_cache ? this.last : value});`\n\t                : b `${element.var}.${property_name} = ${should_cache ? this.last : value};`;\n\t        }\n\t        else {\n\t            block.chunks.hydrate.push(b `${method}(${element.var}, \"${name}\", ${init});`);\n\t            updater = b `${method}(${element.var}, \"${name}\", ${should_cache ? this.last : value});`;\n\t        }\n\t        if (is_indirectly_bound_value) {\n\t            const update_value = b `${element.var}.value = ${element.var}.__value;`;\n\t            block.chunks.hydrate.push(update_value);\n\t            updater = b `\n\t\t\t\t${updater}\n\t\t\t\t${update_value};\n\t\t\t`;\n\t        }\n\t        if (dependencies.length > 0) {\n\t            const condition = this.get_dom_update_conditions(block, block.renderer.dirty(dependencies));\n\t            block.chunks.update.push(b `\n\t\t\t\tif (${condition}) {\n\t\t\t\t\t${updater}\n\t\t\t\t}`);\n\t        }\n\t        // special case \u2013 autofocus. has to be handled in a bit of a weird way\n\t        if (this.node.is_true && name === 'autofocus') {\n\t            block.autofocus = element.var;\n\t        }\n\t    }\n\t    get_init(block, value) {\n\t        this.last = this.should_cache && block.get_unique_name(`${this.parent.var.name}_${this.name.replace(/[^a-zA-Z_$]/g, '_')}_value`);\n\t        if (this.should_cache)\n\t            block.add_variable(this.last);\n\t        return this.should_cache ? x `${this.last} = ${value}` : value;\n\t    }\n\t    get_dom_update_conditions(block, dependency_condition) {\n\t        const { property_name, should_cache, last } = this;\n\t        const element = this.parent;\n\t        const value = this.get_value(block);\n\t        let condition = dependency_condition;\n\t        if (should_cache) {\n\t            condition = this.is_src\n\t                ? x `${condition} && (${element.var}.src !== (${last} = ${value}))`\n\t                : x `${condition} && (${last} !== (${last} = ${value}))`;\n\t        }\n\t        if (this.is_input_value) {\n\t            const type = element.node.get_static_attribute_value('type');\n\t            if (type === null || type === \"\" || type === \"text\" || type === \"email\" || type === \"password\") {\n\t                condition = x `${condition} && ${element.var}.${property_name} !== ${should_cache ? last : value}`;\n\t            }\n\t        }\n\t        if (block.has_outros) {\n\t            condition = x `!#current || ${condition}`;\n\t        }\n\t        return condition;\n\t    }\n\t    get_dependencies() {\n\t        const node_dependencies = this.node.get_dependencies();\n\t        const dependencies = new Set(node_dependencies);\n\t        node_dependencies.forEach((prop) => {\n\t            const indirect_dependencies = this.parent.renderer.component.indirect_dependencies.get(prop);\n\t            if (indirect_dependencies) {\n\t                indirect_dependencies.forEach(indirect_dependency => {\n\t                    dependencies.add(indirect_dependency);\n\t                });\n\t            }\n\t        });\n\t        return Array.from(dependencies);\n\t    }\n\t    get_metadata() {\n\t        if (this.parent.node.namespace)\n\t            return null;\n\t        const metadata = attribute_lookup[this.name];\n\t        if (metadata && metadata.applies_to && !metadata.applies_to.includes(this.parent.node.name))\n\t            return null;\n\t        return metadata;\n\t    }\n\t    get_value(block) {\n\t        if (this.node.is_true) {\n\t            if (this.metadata && boolean_attribute.has(this.metadata.property_name.toLowerCase())) {\n\t                return x `true`;\n\t            }\n\t            return x `\"\"`;\n\t        }\n\t        if (this.node.chunks.length === 0)\n\t            return x `\"\"`;\n\t        // TODO some of this code is repeated in Tag.ts \u2014 would be good to\n\t        // DRY it out if that's possible without introducing crazy indirection\n\t        if (this.node.chunks.length === 1) {\n\t            return this.node.chunks[0].type === 'Text'\n\t                ? string_literal(this.node.chunks[0].data)\n\t                : this.node.chunks[0].manipulate(block);\n\t        }\n\t        let value = this.node.name === 'class'\n\t            ? this.get_class_name_text(block)\n\t            : this.render_chunks(block).reduce((lhs, rhs) => x `${lhs} + ${rhs}`);\n\t        // '{foo} {bar}' \u2014 treat as string concatenation\n\t        if (this.node.chunks[0].type !== 'Text') {\n\t            value = x `\"\" + ${value}`;\n\t        }\n\t        return value;\n\t    }\n\t    get_class_name_text(block) {\n\t        const scoped_css = this.node.chunks.some((chunk) => chunk.synthetic);\n\t        const rendered = this.render_chunks(block);\n\t        if (scoped_css && rendered.length === 2) {\n\t            // we have a situation like class={possiblyUndefined}\n\t            rendered[0] = x `@null_to_empty(${rendered[0]})`;\n\t        }\n\t        return rendered.reduce((lhs, rhs) => x `${lhs} + ${rhs}`);\n\t    }\n\t    render_chunks(block) {\n\t        return this.node.chunks.map((chunk) => {\n\t            if (chunk.type === 'Text') {\n\t                return string_literal(chunk.data);\n\t            }\n\t            return chunk.manipulate(block);\n\t        });\n\t    }\n\t    stringify() {\n\t        if (this.node.is_true)\n\t            return '';\n\t        const value = this.node.chunks;\n\t        if (value.length === 0)\n\t            return `=\"\"`;\n\t        return `=\"${value.map(chunk => {\n            return chunk.type === 'Text'\n                ? chunk.data.replace(/\"/g, '\\\\\"')\n                : `\\${${chunk.manipulate()}}`;\n        }).join('')}\"`;\n\t    }\n\t}\n\t// source: https://html.spec.whatwg.org/multipage/indices.html\n\tconst attribute_lookup = {\n\t    allowfullscreen: { property_name: 'allowFullscreen', applies_to: ['iframe'] },\n\t    allowpaymentrequest: { property_name: 'allowPaymentRequest', applies_to: ['iframe'] },\n\t    async: { applies_to: ['script'] },\n\t    autofocus: { applies_to: ['button', 'input', 'keygen', 'select', 'textarea'] },\n\t    autoplay: { applies_to: ['audio', 'video'] },\n\t    checked: { applies_to: ['input'] },\n\t    controls: { applies_to: ['audio', 'video'] },\n\t    default: { applies_to: ['track'] },\n\t    defer: { applies_to: ['script'] },\n\t    disabled: {\n\t        applies_to: [\n\t            'button',\n\t            'fieldset',\n\t            'input',\n\t            'keygen',\n\t            'optgroup',\n\t            'option',\n\t            'select',\n\t            'textarea',\n\t        ],\n\t    },\n\t    formnovalidate: { property_name: 'formNoValidate', applies_to: ['button', 'input'] },\n\t    hidden: {},\n\t    indeterminate: { applies_to: ['input'] },\n\t    ismap: { property_name: 'isMap', applies_to: ['img'] },\n\t    loop: { applies_to: ['audio', 'bgsound', 'video'] },\n\t    multiple: { applies_to: ['input', 'select'] },\n\t    muted: { applies_to: ['audio', 'video'] },\n\t    nomodule: { property_name: 'noModule', applies_to: ['script'] },\n\t    novalidate: { property_name: 'noValidate', applies_to: ['form'] },\n\t    open: { applies_to: ['details', 'dialog'] },\n\t    playsinline: { property_name: 'playsInline', applies_to: ['video'] },\n\t    readonly: { property_name: 'readOnly', applies_to: ['input', 'textarea'] },\n\t    required: { applies_to: ['input', 'select', 'textarea'] },\n\t    reversed: { applies_to: ['ol'] },\n\t    selected: { applies_to: ['option'] },\n\t    value: {\n\t        applies_to: [\n\t            'button',\n\t            'option',\n\t            'input',\n\t            'li',\n\t            'meter',\n\t            'progress',\n\t            'param',\n\t            'select',\n\t            'textarea',\n\t        ],\n\t    },\n\t};\n\tObject.keys(attribute_lookup).forEach(name => {\n\t    const metadata = attribute_lookup[name];\n\t    if (!metadata.property_name)\n\t        metadata.property_name = name;\n\t});\n\t// source: https://html.spec.whatwg.org/multipage/indices.html\n\tconst boolean_attribute = new Set([\n\t    'allowfullscreen',\n\t    'allowpaymentrequest',\n\t    'async',\n\t    'autofocus',\n\t    'autoplay',\n\t    'checked',\n\t    'controls',\n\t    'default',\n\t    'defer',\n\t    'disabled',\n\t    'formnovalidate',\n\t    'hidden',\n\t    'ismap',\n\t    'itemscope',\n\t    'loop',\n\t    'multiple',\n\t    'muted',\n\t    'nomodule',\n\t    'novalidate',\n\t    'open',\n\t    'playsinline',\n\t    'readonly',\n\t    'required',\n\t    'reversed',\n\t    'selected'\n\t]);\n\tfunction should_cache(attribute) {\n\t    return attribute.is_src || attribute.node.should_cache();\n\t}\n\tfunction is_indirectly_bound_value(attribute) {\n\t    const element = attribute.parent;\n\t    return attribute.name === 'value' &&\n\t        (element.node.name === 'option' || // TODO check it's actually bound\n\t            (element.node.name === 'input' &&\n\t                element.node.bindings.some((binding) => /checked|group/.test(binding.name))));\n\t}\n\n\tclass StyleAttributeWrapper extends AttributeWrapper {\n\t    render(block) {\n\t        const style_props = optimize_style(this.node.chunks);\n\t        if (!style_props)\n\t            return super.render(block);\n\t        style_props.forEach((prop) => {\n\t            let value;\n\t            if (is_dynamic(prop.value)) {\n\t                const prop_dependencies = new Set();\n\t                value = prop.value\n\t                    .map(chunk => {\n\t                    if (chunk.type === 'Text') {\n\t                        return string_literal(chunk.data);\n\t                    }\n\t                    else {\n\t                        add_to_set(prop_dependencies, chunk.dynamic_dependencies());\n\t                        return chunk.manipulate(block);\n\t                    }\n\t                })\n\t                    .reduce((lhs, rhs) => x `${lhs} + ${rhs}`);\n\t                // TODO is this necessary? style.setProperty always treats value as string, no?\n\t                // if (prop.value.length === 1 || prop.value[0].type !== 'Text') {\n\t                // \tvalue = x`\"\" + ${value}`;\n\t                // }\n\t                if (prop_dependencies.size) {\n\t                    let condition = block.renderer.dirty(Array.from(prop_dependencies));\n\t                    if (block.has_outros) {\n\t                        condition = x `!#current || ${condition}`;\n\t                    }\n\t                    const update = b `\n\t\t\t\t\t\tif (${condition}) {\n\t\t\t\t\t\t\t@set_style(${this.parent.var}, \"${prop.key}\", ${value}, ${prop.important ? 1 : null});\n\t\t\t\t\t\t}`;\n\t                    block.chunks.update.push(update);\n\t                }\n\t            }\n\t            else {\n\t                value = string_literal(prop.value[0].data);\n\t            }\n\t            block.chunks.hydrate.push(b `@set_style(${this.parent.var}, \"${prop.key}\", ${value}, ${prop.important ? 1 : null});`);\n\t        });\n\t    }\n\t}\n\tfunction optimize_style(value) {\n\t    const props = [];\n\t    let chunks = value.slice();\n\t    while (chunks.length) {\n\t        const chunk = chunks[0];\n\t        if (chunk.type !== 'Text')\n\t            return null;\n\t        const key_match = /^\\s*([\\w-]+):\\s*/.exec(chunk.data);\n\t        if (!key_match)\n\t            return null;\n\t        const key = key_match[1];\n\t        const offset = key_match.index + key_match[0].length;\n\t        const remaining_data = chunk.data.slice(offset);\n\t        if (remaining_data) {\n\t            chunks[0] = {\n\t                start: chunk.start + offset,\n\t                end: chunk.end,\n\t                type: 'Text',\n\t                data: remaining_data\n\t            };\n\t        }\n\t        else {\n\t            chunks.shift();\n\t        }\n\t        const result = get_style_value(chunks);\n\t        props.push({ key, value: result.value, important: result.important });\n\t        chunks = result.chunks;\n\t    }\n\t    return props;\n\t}\n\tfunction get_style_value(chunks) {\n\t    const value = [];\n\t    let in_url = false;\n\t    let quote_mark = null;\n\t    let escaped = false;\n\t    let closed = false;\n\t    while (chunks.length && !closed) {\n\t        const chunk = chunks.shift();\n\t        if (chunk.type === 'Text') {\n\t            let c = 0;\n\t            while (c < chunk.data.length) {\n\t                const char = chunk.data[c];\n\t                if (escaped) {\n\t                    escaped = false;\n\t                }\n\t                else if (char === '\\\\') {\n\t                    escaped = true;\n\t                }\n\t                else if (char === quote_mark) {\n\t                    quote_mark = null;\n\t                }\n\t                else if (char === '\"' || char === \"'\") {\n\t                    quote_mark = char;\n\t                }\n\t                else if (char === ')' && in_url) {\n\t                    in_url = false;\n\t                }\n\t                else if (char === 'u' && chunk.data.slice(c, c + 4) === 'url(') {\n\t                    in_url = true;\n\t                }\n\t                else if (char === ';' && !in_url && !quote_mark) {\n\t                    closed = true;\n\t                    break;\n\t                }\n\t                c += 1;\n\t            }\n\t            if (c > 0) {\n\t                value.push({\n\t                    type: 'Text',\n\t                    start: chunk.start,\n\t                    end: chunk.start + c,\n\t                    data: chunk.data.slice(0, c)\n\t                });\n\t            }\n\t            while (/[;\\s]/.test(chunk.data[c]))\n\t                c += 1;\n\t            const remaining_data = chunk.data.slice(c);\n\t            if (remaining_data) {\n\t                chunks.unshift({\n\t                    start: chunk.start + c,\n\t                    end: chunk.end,\n\t                    type: 'Text',\n\t                    data: remaining_data\n\t                });\n\t                break;\n\t            }\n\t        }\n\t        else {\n\t            value.push(chunk);\n\t        }\n\t    }\n\t    let important = false;\n\t    const last_chunk = value[value.length - 1];\n\t    if (last_chunk && last_chunk.type === 'Text' && /\\s*!important\\s*$/.test(last_chunk.data)) {\n\t        important = true;\n\t        last_chunk.data = last_chunk.data.replace(/\\s*!important\\s*$/, '');\n\t        if (!last_chunk.data)\n\t            value.pop();\n\t    }\n\t    return {\n\t        chunks,\n\t        value,\n\t        important\n\t    };\n\t}\n\tfunction is_dynamic(value) {\n\t    return value.length > 1 || value[0].type !== 'Text';\n\t}\n\n\tclass SpreadAttributeWrapper extends BaseAttributeWrapper {\n\t}\n\n\tfunction get_object(node) {\n\t    while (node.type === 'MemberExpression')\n\t        node = node.object;\n\t    return node;\n\t}\n\n\tfunction replace_object(node, replacement) {\n\t    if (node.type === 'Identifier')\n\t        return replacement;\n\t    const ancestor = node;\n\t    let parent;\n\t    while (node.type === 'MemberExpression') {\n\t        parent = node;\n\t        node = node.object;\n\t    }\n\t    parent.object = replacement;\n\t    return ancestor;\n\t}\n\n\tfunction flatten_reference(node) {\n\t    const nodes = [];\n\t    const parts = [];\n\t    while (node.type === 'MemberExpression') {\n\t        nodes.unshift(node.property);\n\t        if (!node.computed) {\n\t            parts.unshift(node.property.name);\n\t        }\n\t        else {\n\t            const computed_property = to_string$1(node.property);\n\t            if (computed_property) {\n\t                parts.unshift(`[${computed_property}]`);\n\t            }\n\t        }\n\t        node = node.object;\n\t    }\n\t    const name = node.type === 'Identifier'\n\t        ? node.name\n\t        : node.type === 'ThisExpression' ? 'this' : null;\n\t    nodes.unshift(node);\n\t    parts.unshift(name);\n\t    return { name, nodes, parts };\n\t}\n\tfunction to_string$1(node) {\n\t    switch (node.type) {\n\t        case 'Literal':\n\t            return String(node.value);\n\t        case 'Identifier':\n\t            return node.name;\n\t    }\n\t}\n\n\tfunction mark_each_block_bindings(parent, binding) {\n\t    // we need to ensure that the each block creates a context including\n\t    // the list and the index, if they're not otherwise referenced\n\t    const object = get_object(binding.expression.node).name;\n\t    const each_block = parent.node.scope.get_owner(object);\n\t    each_block.has_binding = true;\n\t    if (binding.name === \"group\") {\n\t        // for `<input bind:group={} >`, we make sure that all the each blocks creates context with `index`\n\t        for (const name of binding.expression.contextual_dependencies) {\n\t            const each_block = parent.node.scope.get_owner(name);\n\t            each_block.has_index_binding = true;\n\t        }\n\t    }\n\t}\n\n\tclass BindingWrapper {\n\t    constructor(block, node, parent) {\n\t        this.node = node;\n\t        this.parent = parent;\n\t        const { dependencies } = this.node.expression;\n\t        block.add_dependencies(dependencies);\n\t        // TODO does this also apply to e.g. `<input type='checkbox' bind:group='foo'>`?\n\t        handle_select_value_binding(this, dependencies);\n\t        if (node.is_contextual) {\n\t            mark_each_block_bindings(this.parent, this.node);\n\t        }\n\t        this.object = get_object(this.node.expression.node).name;\n\t        // view to model\n\t        this.handler = get_event_handler(this, parent.renderer, block, this.object, this.node.raw_expression);\n\t        this.snippet = this.node.expression.manipulate(block);\n\t        this.is_readonly = this.node.is_readonly;\n\t        this.needs_lock = this.node.name === 'currentTime'; // TODO others?\n\t    }\n\t    get_dependencies() {\n\t        const dependencies = new Set(this.node.expression.dependencies);\n\t        this.node.expression.dependencies.forEach((prop) => {\n\t            const indirect_dependencies = this.parent.renderer.component.indirect_dependencies.get(prop);\n\t            if (indirect_dependencies) {\n\t                indirect_dependencies.forEach(indirect_dependency => {\n\t                    dependencies.add(indirect_dependency);\n\t                });\n\t            }\n\t        });\n\t        return dependencies;\n\t    }\n\t    is_readonly_media_attribute() {\n\t        return this.node.is_readonly_media_attribute();\n\t    }\n\t    render(block, lock) {\n\t        if (this.is_readonly)\n\t            return;\n\t        const { parent } = this;\n\t        const update_conditions = this.needs_lock ? [x `!${lock}`] : [];\n\t        const mount_conditions = [];\n\t        const dependency_array = Array.from(this.get_dependencies());\n\t        if (dependency_array.length > 0) {\n\t            update_conditions.push(block.renderer.dirty(dependency_array));\n\t        }\n\t        if (parent.node.name === \"input\") {\n\t            const type = parent.node.get_static_attribute_value(\"type\");\n\t            if (type === null ||\n\t                type === \"\" ||\n\t                type === \"text\" ||\n\t                type === \"email\" ||\n\t                type === \"password\") {\n\t                update_conditions.push(x `${parent.var}.${this.node.name} !== ${this.snippet}`);\n\t            }\n\t            else if (type === \"number\") {\n\t                update_conditions.push(x `@to_number(${parent.var}.${this.node.name}) !== ${this.snippet}`);\n\t            }\n\t        }\n\t        // model to view\n\t        let update_dom = get_dom_updater(parent, this);\n\t        let mount_dom = update_dom;\n\t        // special cases\n\t        switch (this.node.name) {\n\t            case 'group':\n\t                {\n\t                    const { binding_group, is_context, contexts, index } = get_binding_group(parent.renderer, this.node, block);\n\t                    block.renderer.add_to_context(`$$binding_groups`);\n\t                    if (is_context) {\n\t                        if (contexts.length > 1) {\n\t                            let binding_group = x `${block.renderer.reference('$$binding_groups')}[${index}]`;\n\t                            for (const name of contexts.slice(0, -1)) {\n\t                                binding_group = x `${binding_group}[${block.renderer.reference(name)}]`;\n\t                                block.chunks.init.push(b `${binding_group} = ${binding_group} || [];`);\n\t                            }\n\t                        }\n\t                        block.chunks.init.push(b `${binding_group(true)} = [];`);\n\t                    }\n\t                    block.chunks.hydrate.push(b `${binding_group(true)}.push(${parent.var});`);\n\t                    block.chunks.destroy.push(b `${binding_group(true)}.splice(${binding_group(true)}.indexOf(${parent.var}), 1);`);\n\t                    break;\n\t                }\n\t            case 'textContent':\n\t                update_conditions.push(x `${this.snippet} !== ${parent.var}.textContent`);\n\t                mount_conditions.push(x `${this.snippet} !== void 0`);\n\t                break;\n\t            case 'innerHTML':\n\t                update_conditions.push(x `${this.snippet} !== ${parent.var}.innerHTML`);\n\t                mount_conditions.push(x `${this.snippet} !== void 0`);\n\t                break;\n\t            case 'currentTime':\n\t                update_conditions.push(x `!@_isNaN(${this.snippet})`);\n\t                mount_dom = null;\n\t                break;\n\t            case 'playbackRate':\n\t            case 'volume':\n\t                update_conditions.push(x `!@_isNaN(${this.snippet})`);\n\t                mount_conditions.push(x `!@_isNaN(${this.snippet})`);\n\t                break;\n\t            case 'paused':\n\t                {\n\t                    // this is necessary to prevent audio restarting by itself\n\t                    const last = block.get_unique_name(`${parent.var.name}_is_paused`);\n\t                    block.add_variable(last, x `true`);\n\t                    update_conditions.push(x `${last} !== (${last} = ${this.snippet})`);\n\t                    update_dom = b `${parent.var}[${last} ? \"pause\" : \"play\"]();`;\n\t                    mount_dom = null;\n\t                    break;\n\t                }\n\t            case 'value':\n\t                if (parent.node.get_static_attribute_value('type') === 'file') {\n\t                    update_dom = null;\n\t                    mount_dom = null;\n\t                }\n\t        }\n\t        if (update_dom) {\n\t            if (update_conditions.length > 0) {\n\t                const condition = update_conditions.reduce((lhs, rhs) => x `${lhs} && ${rhs}`);\n\t                block.chunks.update.push(b `\n\t\t\t\t\tif (${condition}) {\n\t\t\t\t\t\t${update_dom}\n\t\t\t\t\t}\n\t\t\t\t`);\n\t            }\n\t            else {\n\t                block.chunks.update.push(update_dom);\n\t            }\n\t        }\n\t        if (mount_dom) {\n\t            if (mount_conditions.length > 0) {\n\t                const condition = mount_conditions.reduce((lhs, rhs) => x `${lhs} && ${rhs}`);\n\t                block.chunks.mount.push(b `\n\t\t\t\t\tif (${condition}) {\n\t\t\t\t\t\t${mount_dom}\n\t\t\t\t\t}\n\t\t\t\t`);\n\t            }\n\t            else {\n\t                block.chunks.mount.push(mount_dom);\n\t            }\n\t        }\n\t    }\n\t}\n\tfunction get_dom_updater(element, binding) {\n\t    const { node } = element;\n\t    if (binding.is_readonly_media_attribute()) {\n\t        return null;\n\t    }\n\t    if (binding.node.name === 'this') {\n\t        return null;\n\t    }\n\t    if (node.name === 'select') {\n\t        return node.get_static_attribute_value('multiple') === true ?\n\t            b `@select_options(${element.var}, ${binding.snippet})` :\n\t            b `@select_option(${element.var}, ${binding.snippet})`;\n\t    }\n\t    if (binding.node.name === 'group') {\n\t        const type = node.get_static_attribute_value('type');\n\t        const condition = type === 'checkbox'\n\t            ? x `~${binding.snippet}.indexOf(${element.var}.__value)`\n\t            : x `${element.var}.__value === ${binding.snippet}`;\n\t        return b `${element.var}.checked = ${condition};`;\n\t    }\n\t    if (binding.node.name === 'value') {\n\t        return b `@set_input_value(${element.var}, ${binding.snippet});`;\n\t    }\n\t    return b `${element.var}.${binding.node.name} = ${binding.snippet};`;\n\t}\n\tfunction get_binding_group(renderer, value, block) {\n\t    const { parts } = flatten_reference(value.raw_expression);\n\t    let keypath = parts.join('.');\n\t    const contexts = [];\n\t    for (const dep of value.expression.contextual_dependencies) {\n\t        const context = block.bindings.get(dep);\n\t        let key;\n\t        let name;\n\t        if (context) {\n\t            key = context.object.name;\n\t            name = context.property.name;\n\t        }\n\t        else {\n\t            key = dep;\n\t            name = dep;\n\t        }\n\t        keypath = `${key}@${keypath}`;\n\t        contexts.push(name);\n\t    }\n\t    if (!renderer.binding_groups.has(keypath)) {\n\t        const index = renderer.binding_groups.size;\n\t        contexts.forEach(context => {\n\t            renderer.add_to_context(context, true);\n\t        });\n\t        renderer.binding_groups.set(keypath, {\n\t            binding_group: (to_reference = false) => {\n\t                let binding_group = '$$binding_groups';\n\t                let _secondary_indexes = contexts;\n\t                if (to_reference) {\n\t                    binding_group = block.renderer.reference(binding_group);\n\t                    _secondary_indexes = _secondary_indexes.map(name => block.renderer.reference(name));\n\t                }\n\t                if (_secondary_indexes.length > 0) {\n\t                    let obj = x `${binding_group}[${index}]`;\n\t                    _secondary_indexes.forEach(secondary_index => {\n\t                        obj = x `${obj}[${secondary_index}]`;\n\t                    });\n\t                    return obj;\n\t                }\n\t                else {\n\t                    return x `${binding_group}[${index}]`;\n\t                }\n\t            },\n\t            is_context: contexts.length > 0,\n\t            contexts,\n\t            index,\n\t        });\n\t    }\n\t    return renderer.binding_groups.get(keypath);\n\t}\n\tfunction get_event_handler(binding, renderer, block, name, lhs) {\n\t    const contextual_dependencies = new Set(binding.node.expression.contextual_dependencies);\n\t    const context = block.bindings.get(name);\n\t    let set_store;\n\t    if (context) {\n\t        const { object, property, store, snippet } = context;\n\t        lhs = replace_object(lhs, snippet);\n\t        contextual_dependencies.add(object.name);\n\t        contextual_dependencies.add(property.name);\n\t        contextual_dependencies.delete(name);\n\t        if (store) {\n\t            set_store = b `${store}.set(${`$${store}`});`;\n\t        }\n\t    }\n\t    else {\n\t        const object = get_object(lhs);\n\t        if (object.name[0] === '$') {\n\t            const store = object.name.slice(1);\n\t            set_store = b `${store}.set(${object.name});`;\n\t        }\n\t    }\n\t    const value = get_value_from_dom(renderer, binding.parent, binding, block, contextual_dependencies);\n\t    const mutation = b `\n\t\t${lhs} = ${value};\n\t\t${set_store}\n\t`;\n\t    return {\n\t        uses_context: binding.node.is_contextual || binding.node.expression.uses_context,\n\t        mutation,\n\t        contextual_dependencies,\n\t        lhs,\n\t    };\n\t}\n\tfunction get_value_from_dom(renderer, element, binding, block, contextual_dependencies) {\n\t    const { node } = element;\n\t    const { name } = binding.node;\n\t    if (name === 'this') {\n\t        return x `$$value`;\n\t    }\n\t    // <select bind:value='selected>\n\t    if (node.name === 'select') {\n\t        return node.get_static_attribute_value('multiple') === true ?\n\t            x `@select_multiple_value(this)` :\n\t            x `@select_value(this)`;\n\t    }\n\t    const type = node.get_static_attribute_value('type');\n\t    // <input type='checkbox' bind:group='foo'>\n\t    if (name === 'group') {\n\t        if (type === 'checkbox') {\n\t            const { binding_group, contexts } = get_binding_group(renderer, binding.node, block);\n\t            add_to_set(contextual_dependencies, contexts);\n\t            return x `@get_binding_group_value(${binding_group()}, this.__value, this.checked)`;\n\t        }\n\t        return x `this.__value`;\n\t    }\n\t    // <input type='range|number' bind:value>\n\t    if (type === 'range' || type === 'number') {\n\t        return x `@to_number(this.${name})`;\n\t    }\n\t    if ((name === 'buffered' || name === 'seekable' || name === 'played')) {\n\t        return x `@time_ranges_to_array(this.${name})`;\n\t    }\n\t    // everything else\n\t    return x `this.${name}`;\n\t}\n\n\tfunction add_actions(block, target, actions) {\n\t    actions.forEach(action => add_action(block, target, action));\n\t}\n\tfunction add_action(block, target, action) {\n\t    const { expression } = action;\n\t    let snippet;\n\t    let dependencies;\n\t    if (expression) {\n\t        snippet = expression.manipulate(block);\n\t        dependencies = expression.dynamic_dependencies();\n\t    }\n\t    const id = block.get_unique_name(`${action.name.replace(/[^a-zA-Z0-9_$]/g, '_')}_action`);\n\t    block.add_variable(id);\n\t    const fn = block.renderer.reference(action.name);\n\t    block.event_listeners.push(x `@action_destroyer(${id} = ${fn}.call(null, ${target}, ${snippet}))`);\n\t    if (dependencies && dependencies.length > 0) {\n\t        let condition = x `${id} && @is_function(${id}.update)`;\n\t        if (dependencies.length > 0) {\n\t            condition = x `${condition} && ${block.renderer.dirty(dependencies)}`;\n\t        }\n\t        block.chunks.update.push(b `if (${condition}) ${id}.update.call(null, ${snippet});`);\n\t    }\n\t}\n\n\tfunction get_slot_definition(block, scope, lets) {\n\t    if (lets.length === 0)\n\t        return { block, scope };\n\t    const context_input = {\n\t        type: 'ObjectPattern',\n\t        properties: lets.map(l => ({\n\t            type: 'Property',\n\t            kind: 'init',\n\t            key: l.name,\n\t            value: l.value || l.name\n\t        }))\n\t    };\n\t    const properties = [];\n\t    const value_map = new Map();\n\t    lets.forEach(l => {\n\t        let value;\n\t        if (l.names.length > 1) {\n\t            // more than one, probably destructuring\n\t            const unique_name = block.get_unique_name(l.names.join('_')).name;\n\t            value_map.set(l.value, unique_name);\n\t            value = { type: 'Identifier', name: unique_name };\n\t        }\n\t        else {\n\t            value = l.value || l.name;\n\t        }\n\t        properties.push({\n\t            type: 'Property',\n\t            kind: 'init',\n\t            key: l.name,\n\t            value,\n\t        });\n\t    });\n\t    const changes_input = {\n\t        type: 'ObjectPattern',\n\t        properties,\n\t    };\n\t    const names = new Set();\n\t    const names_lookup = new Map();\n\t    lets.forEach(l => {\n\t        l.names.forEach(name => {\n\t            names.add(name);\n\t            if (value_map.has(l.value)) {\n\t                names_lookup.set(name, value_map.get(l.value));\n\t            }\n\t        });\n\t    });\n\t    const context = {\n\t        type: 'ObjectExpression',\n\t        properties: Array.from(names).map(name => p `${block.renderer.context_lookup.get(name).index}: ${name}`)\n\t    };\n\t    const { context_lookup } = block.renderer;\n\t    // i am well aware that this code is gross\n\t    // TODO: context-overflow make it less gross\n\t    const changes = {\n\t        type: 'ParenthesizedExpression',\n\t        get expression() {\n\t            if (block.renderer.context_overflow) {\n\t                const grouped = [];\n\t                Array.from(names).forEach(name => {\n\t                    const i = context_lookup.get(name).index.value;\n\t                    const g = Math.floor(i / 31);\n\t                    const lookup_name = names_lookup.has(name) ? names_lookup.get(name) : name;\n\t                    if (!grouped[g])\n\t                        grouped[g] = [];\n\t                    grouped[g].push({ name: lookup_name, n: i % 31 });\n\t                });\n\t                const elements = [];\n\t                for (let g = 0; g < grouped.length; g += 1) {\n\t                    elements[g] = grouped[g]\n\t                        ? grouped[g]\n\t                            .map(({ name, n }) => x `${name} ? ${1 << n} : 0`)\n\t                            .reduce((lhs, rhs) => x `${lhs} | ${rhs}`)\n\t                        : x `0`;\n\t                }\n\t                return {\n\t                    type: 'ArrayExpression',\n\t                    elements\n\t                };\n\t            }\n\t            return Array.from(names)\n\t                .map(name => {\n\t                const lookup_name = names_lookup.has(name) ? names_lookup.get(name) : name;\n\t                const i = context_lookup.get(name).index.value;\n\t                return x `${lookup_name} ? ${1 << i} : 0`;\n\t            })\n\t                .reduce((lhs, rhs) => x `${lhs} | ${rhs}`);\n\t        }\n\t    };\n\t    return {\n\t        block,\n\t        scope,\n\t        get_context: x `${context_input} => ${context}`,\n\t        get_changes: x `${changes_input} => ${changes}`\n\t    };\n\t}\n\n\tfunction compare_node(a, b) {\n\t    if (a === b)\n\t        return true;\n\t    if (!a || !b)\n\t        return false;\n\t    if (a.type !== b.type)\n\t        return false;\n\t    switch (a.type) {\n\t        case \"Identifier\":\n\t            return a.name === b.name;\n\t        case \"MemberExpression\":\n\t            return (compare_node(a.object, b.object) &&\n\t                compare_node(a.property, b.property) &&\n\t                a.computed === b.computed);\n\t        case 'Literal':\n\t            return a.value === b.value;\n\t    }\n\t}\n\n\tfunction bind_this(component, block, binding, variable) {\n\t    const fn = component.get_unique_name(`${variable.name}_binding`);\n\t    block.renderer.add_to_context(fn.name);\n\t    const callee = block.renderer.reference(fn.name);\n\t    const { contextual_dependencies, mutation } = binding.handler;\n\t    const dependencies = binding.get_dependencies();\n\t    const body = b `\n\t\t${mutation}\n\t\t${Array.from(dependencies)\n        .filter(dep => dep[0] !== '$')\n        .filter(dep => !contextual_dependencies.has(dep))\n        .map(dep => b `${block.renderer.invalidate(dep)};`)}\n\t`;\n\t    if (contextual_dependencies.size) {\n\t        const params = Array.from(contextual_dependencies).map(name => ({\n\t            type: 'Identifier',\n\t            name\n\t        }));\n\t        component.partly_hoisted.push(b `\n\t\t\tfunction ${fn}($$value, ${params}) {\n\t\t\t\t@binding_callbacks[$$value ? 'unshift' : 'push'](() => {\n\t\t\t\t\t${body}\n\t\t\t\t});\n\t\t\t}\n\t\t`);\n\t        const alias_map = new Map();\n\t        const args = [];\n\t        for (let id of params) {\n\t            const value = block.renderer.reference(id.name);\n\t            let found = false;\n\t            if (block.variables.has(id.name)) {\n\t                let alias = id.name;\n\t                for (let i = 1; block.variables.has(alias) && !compare_node(block.variables.get(alias).init, value); alias = `${id.name}_${i++}`)\n\t                    ;\n\t                alias_map.set(alias, id.name);\n\t                id = { type: 'Identifier', name: alias };\n\t                found = block.variables.has(alias);\n\t            }\n\t            args.push(id);\n\t            if (!found) {\n\t                block.add_variable(id, value);\n\t            }\n\t        }\n\t        const assign = block.get_unique_name(`assign_${variable.name}`);\n\t        const unassign = block.get_unique_name(`unassign_${variable.name}`);\n\t        block.chunks.init.push(b `\n\t\t\tconst ${assign} = () => ${callee}(${variable}, ${args});\n\t\t\tconst ${unassign} = () => ${callee}(null, ${args});\n\t\t`);\n\t        const condition = Array.from(args)\n\t            .map(name => x `${name} !== ${block.renderer.reference(alias_map.get(name.name) || name.name)}`)\n\t            .reduce((lhs, rhs) => x `${lhs} || ${rhs}`);\n\t        // we push unassign and unshift assign so that references are\n\t        // nulled out before they're created, to avoid glitches\n\t        // with shifting indices\n\t        block.chunks.update.push(b `\n\t\t\tif (${condition}) {\n\t\t\t\t${unassign}();\n\t\t\t\t${args.map(a => b `${a} = ${block.renderer.reference(alias_map.get(a.name) || a.name)}`)};\n\t\t\t\t${assign}();\n\t\t\t}`);\n\t        block.chunks.destroy.push(b `${unassign}();`);\n\t        return b `${assign}();`;\n\t    }\n\t    component.partly_hoisted.push(b `\n\t\tfunction ${fn}($$value) {\n\t\t\t@binding_callbacks[$$value ? 'unshift' : 'push'](() => {\n\t\t\t\t${body}\n\t\t\t});\n\t\t}\n\t`);\n\t    block.chunks.destroy.push(b `${callee}(null);`);\n\t    return b `${callee}(${variable});`;\n\t}\n\n\tclass Node$1 {\n\t    constructor(component, parent, _scope, info) {\n\t        this.start = info.start;\n\t        this.end = info.end;\n\t        this.type = info.type;\n\t        // this makes properties non-enumerable, which makes logging\n\t        // bearable. might have a performance cost. TODO remove in prod?\n\t        Object.defineProperties(this, {\n\t            component: {\n\t                value: component\n\t            },\n\t            parent: {\n\t                value: parent\n\t            }\n\t        });\n\t    }\n\t    cannot_use_innerhtml() {\n\t        if (this.can_use_innerhtml !== false) {\n\t            this.can_use_innerhtml = false;\n\t            if (this.parent)\n\t                this.parent.cannot_use_innerhtml();\n\t        }\n\t    }\n\t    find_nearest(selector) {\n\t        if (selector.test(this.type))\n\t            return this;\n\t        if (this.parent)\n\t            return this.parent.find_nearest(selector);\n\t    }\n\t    get_static_attribute_value(name) {\n\t        const attribute = this.attributes && this.attributes.find((attr) => attr.type === 'Attribute' && attr.name.toLowerCase() === name);\n\t        if (!attribute)\n\t            return null;\n\t        if (attribute.is_true)\n\t            return true;\n\t        if (attribute.chunks.length === 0)\n\t            return '';\n\t        if (attribute.chunks.length === 1 && attribute.chunks[0].type === 'Text') {\n\t            return attribute.chunks[0].data;\n\t        }\n\t        return null;\n\t    }\n\t    has_ancestor(type) {\n\t        return this.parent ?\n\t            this.parent.type === type || this.parent.has_ancestor(type) :\n\t            false;\n\t    }\n\t}\n\n\tfunction create_scopes(expression) {\n\t    return analyze(expression);\n\t}\n\n\tfunction is_dynamic$1(variable) {\n\t    if (variable) {\n\t        if (variable.mutated || variable.reassigned)\n\t            return true; // dynamic internal state\n\t        if (!variable.module && variable.writable && variable.export_name)\n\t            return true; // writable props\n\t    }\n\t    return false;\n\t}\n\n\tfunction nodes_match(a, b) {\n\t    if (!!a !== !!b)\n\t        return false;\n\t    if (Array.isArray(a) !== Array.isArray(b))\n\t        return false;\n\t    if (a && typeof a === 'object') {\n\t        if (Array.isArray(a)) {\n\t            if (a.length !== b.length)\n\t                return false;\n\t            return a.every((child, i) => nodes_match(child, b[i]));\n\t        }\n\t        const a_keys = Object.keys(a).sort();\n\t        const b_keys = Object.keys(b).sort();\n\t        if (a_keys.length !== b_keys.length)\n\t            return false;\n\t        let i = a_keys.length;\n\t        while (i--) {\n\t            const key = a_keys[i];\n\t            if (b_keys[i] !== key)\n\t                return false;\n\t            if (key === 'start' || key === 'end')\n\t                continue;\n\t            if (!nodes_match(a[key], b[key])) {\n\t                return false;\n\t            }\n\t        }\n\t        return true;\n\t    }\n\t    return a === b;\n\t}\n\n\tfunction invalidate(renderer, scope, node, names, main_execution_context = false) {\n\t    const { component } = renderer;\n\t    const [head, ...tail] = Array.from(names)\n\t        .filter(name => {\n\t        const owner = scope.find_owner(name);\n\t        return !owner || owner === component.instance_scope;\n\t    })\n\t        .map(name => component.var_lookup.get(name))\n\t        .filter(variable => {\n\t        return variable && (!variable.hoistable &&\n\t            !variable.global &&\n\t            !variable.module &&\n\t            (variable.referenced ||\n\t                variable.subscribable ||\n\t                variable.is_reactive_dependency ||\n\t                variable.export_name ||\n\t                variable.name[0] === '$'));\n\t    });\n\t    function get_invalidated(variable, node) {\n\t        if (main_execution_context && !variable.subscribable && variable.name[0] !== '$') {\n\t            return node || x `${variable.name}`;\n\t        }\n\t        return renderer.invalidate(variable.name);\n\t    }\n\t    if (head) {\n\t        component.has_reactive_assignments = true;\n\t        if (node.type === 'AssignmentExpression' && node.operator === '=' && nodes_match(node.left, node.right) && tail.length === 0) {\n\t            return get_invalidated(head, node);\n\t        }\n\t        else {\n\t            const is_store_value = head.name[0] === '$' && head.name[1] !== '$';\n\t            const extra_args = tail.map(variable => get_invalidated(variable));\n\t            const pass_value = (extra_args.length > 0 ||\n\t                (node.type === 'AssignmentExpression' && node.left.type !== 'Identifier') ||\n\t                (node.type === 'UpdateExpression' && (!node.prefix || node.argument.type !== 'Identifier')));\n\t            if (pass_value) {\n\t                extra_args.unshift({\n\t                    type: 'Identifier',\n\t                    name: head.name\n\t                });\n\t            }\n\t            let invalidate = is_store_value\n\t                ? x `@set_store_value(${head.name.slice(1)}, ${node}, ${extra_args})`\n\t                : !main_execution_context\n\t                    ? x `$$invalidate(${renderer.context_lookup.get(head.name).index}, ${node}, ${extra_args})`\n\t                    : node;\n\t            if (head.subscribable && head.reassigned) {\n\t                const subscribe = `$$subscribe_${head.name}`;\n\t                invalidate = x `${subscribe}(${invalidate})`;\n\t            }\n\t            return invalidate;\n\t        }\n\t    }\n\t    return node;\n\t}\n\n\tconst reserved_keywords = new Set([\"$$props\", \"$$restProps\"]);\n\tfunction is_reserved_keyword(name) {\n\t    return reserved_keywords.has(name);\n\t}\n\n\tclass Expression {\n\t    // todo: owner type\n\t    constructor(component, owner, template_scope, info, lazy) {\n\t        this.type = 'Expression';\n\t        this.dependencies = new Set();\n\t        this.contextual_dependencies = new Set();\n\t        this.declarations = [];\n\t        this.uses_context = false;\n\t        // TODO revert to direct property access in prod?\n\t        Object.defineProperties(this, {\n\t            component: {\n\t                value: component\n\t            }\n\t        });\n\t        this.node = info;\n\t        this.template_scope = template_scope;\n\t        this.owner = owner;\n\t        const { dependencies, contextual_dependencies } = this;\n\t        let { map, scope } = create_scopes(info);\n\t        this.scope = scope;\n\t        this.scope_map = map;\n\t        const expression = this;\n\t        let function_expression;\n\t        // discover dependencies, but don't change the code yet\n\t        walk(info, {\n\t            enter(node, parent, key) {\n\t                // don't manipulate shorthand props twice\n\t                if (key === 'value' && parent.shorthand)\n\t                    return;\n\t                if (map.has(node)) {\n\t                    scope = map.get(node);\n\t                }\n\t                if (!function_expression && /FunctionExpression/.test(node.type)) {\n\t                    function_expression = node;\n\t                }\n\t                if (isReference(node, parent)) {\n\t                    const { name, nodes } = flatten_reference(node);\n\t                    if (scope.has(name))\n\t                        return;\n\t                    if (name[0] === '$') {\n\t                        const store_name = name.slice(1);\n\t                        if (template_scope.names.has(store_name) || scope.has(store_name)) {\n\t                            component.error(node, {\n\t                                code: `contextual-store`,\n\t                                message: `Stores must be declared at the top level of the component (this may change in a future version of Svelte)`\n\t                            });\n\t                        }\n\t                    }\n\t                    if (template_scope.is_let(name)) {\n\t                        if (!function_expression) { // TODO should this be `!lazy` ?\n\t                            contextual_dependencies.add(name);\n\t                            dependencies.add(name);\n\t                        }\n\t                    }\n\t                    else if (template_scope.names.has(name)) {\n\t                        expression.uses_context = true;\n\t                        contextual_dependencies.add(name);\n\t                        const owner = template_scope.get_owner(name);\n\t                        const is_index = owner.type === 'EachBlock' && owner.key && name === owner.index;\n\t                        if (!lazy || is_index) {\n\t                            template_scope.dependencies_for_name.get(name).forEach(name => dependencies.add(name));\n\t                        }\n\t                    }\n\t                    else {\n\t                        if (!lazy) {\n\t                            dependencies.add(name);\n\t                        }\n\t                        component.add_reference(name);\n\t                        component.warn_if_undefined(name, nodes[0], template_scope);\n\t                    }\n\t                    this.skip();\n\t                }\n\t                // track any assignments from template expressions as mutable\n\t                let names;\n\t                let deep = false;\n\t                if (function_expression) {\n\t                    if (node.type === 'AssignmentExpression') {\n\t                        deep = node.left.type === 'MemberExpression';\n\t                        names = extract_names(deep ? get_object(node.left) : node.left);\n\t                    }\n\t                    else if (node.type === 'UpdateExpression') {\n\t                        names = extract_names(get_object(node.argument));\n\t                    }\n\t                }\n\t                if (names) {\n\t                    names.forEach(name => {\n\t                        if (template_scope.names.has(name)) {\n\t                            template_scope.dependencies_for_name.get(name).forEach(name => {\n\t                                const variable = component.var_lookup.get(name);\n\t                                if (variable)\n\t                                    variable[deep ? 'mutated' : 'reassigned'] = true;\n\t                            });\n\t                            const each_block = template_scope.get_owner(name);\n\t                            each_block.has_binding = true;\n\t                        }\n\t                        else {\n\t                            component.add_reference(name);\n\t                            const variable = component.var_lookup.get(name);\n\t                            if (variable)\n\t                                variable[deep ? 'mutated' : 'reassigned'] = true;\n\t                        }\n\t                    });\n\t                }\n\t            },\n\t            leave(node) {\n\t                if (map.has(node)) {\n\t                    scope = scope.parent;\n\t                }\n\t                if (node === function_expression) {\n\t                    function_expression = null;\n\t                }\n\t            }\n\t        });\n\t    }\n\t    dynamic_dependencies() {\n\t        return Array.from(this.dependencies).filter(name => {\n\t            if (this.template_scope.is_let(name))\n\t                return true;\n\t            if (is_reserved_keyword(name))\n\t                return true;\n\t            const variable = this.component.var_lookup.get(name);\n\t            return is_dynamic$1(variable);\n\t        });\n\t    }\n\t    // TODO move this into a render-dom wrapper?\n\t    manipulate(block) {\n\t        // TODO ideally we wouldn't end up calling this method\n\t        // multiple times\n\t        if (this.manipulated)\n\t            return this.manipulated;\n\t        const { component, declarations, scope_map: map, template_scope, owner } = this;\n\t        let scope = this.scope;\n\t        let function_expression;\n\t        let dependencies;\n\t        let contextual_dependencies;\n\t        const node = walk(this.node, {\n\t            enter(node, parent) {\n\t                if (node.type === 'Property' && node.shorthand) {\n\t                    node.value = JSON.parse(JSON.stringify(node.value));\n\t                    node.shorthand = false;\n\t                }\n\t                if (map.has(node)) {\n\t                    scope = map.get(node);\n\t                }\n\t                if (node.type === 'Identifier' && isReference(node, parent)) {\n\t                    const { name } = flatten_reference(node);\n\t                    if (scope.has(name))\n\t                        return;\n\t                    if (function_expression) {\n\t                        if (template_scope.names.has(name)) {\n\t                            contextual_dependencies.add(name);\n\t                            template_scope.dependencies_for_name.get(name).forEach(dependency => {\n\t                                dependencies.add(dependency);\n\t                            });\n\t                        }\n\t                        else {\n\t                            dependencies.add(name);\n\t                            component.add_reference(name); // TODO is this redundant/misplaced?\n\t                        }\n\t                    }\n\t                    else if (is_contextual(component, template_scope, name)) {\n\t                        const reference = block.renderer.reference(node);\n\t                        this.replace(reference);\n\t                    }\n\t                    this.skip();\n\t                }\n\t                if (!function_expression) {\n\t                    if (node.type === 'AssignmentExpression') ;\n\t                    if (node.type === 'FunctionExpression' || node.type === 'ArrowFunctionExpression') {\n\t                        function_expression = node;\n\t                        dependencies = new Set();\n\t                        contextual_dependencies = new Set();\n\t                    }\n\t                }\n\t            },\n\t            leave(node, parent) {\n\t                if (map.has(node))\n\t                    scope = scope.parent;\n\t                if (node === function_expression) {\n\t                    const id = component.get_unique_name(sanitize(get_function_name(node, owner)));\n\t                    const declaration = b `const ${id} = ${node}`;\n\t                    if (dependencies.size === 0 && contextual_dependencies.size === 0) {\n\t                        // we can hoist this out of the component completely\n\t                        component.fully_hoisted.push(declaration);\n\t                        this.replace(id);\n\t                        component.add_var({\n\t                            name: id.name,\n\t                            internal: true,\n\t                            hoistable: true,\n\t                            referenced: true\n\t                        });\n\t                    }\n\t                    else if (contextual_dependencies.size === 0) {\n\t                        // function can be hoisted inside the component init\n\t                        component.partly_hoisted.push(declaration);\n\t                        block.renderer.add_to_context(id.name);\n\t                        this.replace(block.renderer.reference(id));\n\t                    }\n\t                    else {\n\t                        // we need a combo block/init recipe\n\t                        const deps = Array.from(contextual_dependencies);\n\t                        node.params = [\n\t                            ...deps.map(name => ({ type: 'Identifier', name })),\n\t                            ...node.params\n\t                        ];\n\t                        const context_args = deps.map(name => block.renderer.reference(name));\n\t                        component.partly_hoisted.push(declaration);\n\t                        block.renderer.add_to_context(id.name);\n\t                        const callee = block.renderer.reference(id);\n\t                        this.replace(id);\n\t                        if (node.params.length > 0) {\n\t                            declarations.push(b `\n\t\t\t\t\t\t\t\tfunction ${id}(...args) {\n\t\t\t\t\t\t\t\t\treturn ${callee}(${context_args}, ...args);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t`);\n\t                        }\n\t                        else {\n\t                            declarations.push(b `\n\t\t\t\t\t\t\t\tfunction ${id}() {\n\t\t\t\t\t\t\t\t\treturn ${callee}(${context_args});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t`);\n\t                        }\n\t                    }\n\t                    function_expression = null;\n\t                    dependencies = null;\n\t                    contextual_dependencies = null;\n\t                    if (parent && parent.type === 'Property') {\n\t                        parent.method = false;\n\t                    }\n\t                }\n\t                if (node.type === 'AssignmentExpression' || node.type === 'UpdateExpression') {\n\t                    const assignee = node.type === 'AssignmentExpression' ? node.left : node.argument;\n\t                    const object_name = get_object(assignee).name;\n\t                    if (scope.has(object_name))\n\t                        return;\n\t                    // normally (`a = 1`, `b.c = 2`), there'll be a single name\n\t                    // (a or b). In destructuring cases (`[d, e] = [e, d]`) there\n\t                    // may be more, in which case we need to tack the extra ones\n\t                    // onto the initial function call\n\t                    const names = new Set(extract_names(assignee));\n\t                    const traced = new Set();\n\t                    names.forEach(name => {\n\t                        const dependencies = template_scope.dependencies_for_name.get(name);\n\t                        if (dependencies) {\n\t                            dependencies.forEach(name => traced.add(name));\n\t                        }\n\t                        else {\n\t                            traced.add(name);\n\t                        }\n\t                    });\n\t                    const context = block.bindings.get(object_name);\n\t                    if (context) {\n\t                        // for `{#each array as item}`\n\t                        // replace `item = 1` to `each_array[each_index] = 1`, this allow us to mutate the array\n\t                        // rather than mutating the local `item` variable\n\t                        const { snippet, object, property } = context;\n\t                        const replaced = replace_object(assignee, snippet);\n\t                        if (node.type === 'AssignmentExpression') {\n\t                            node.left = replaced;\n\t                        }\n\t                        else {\n\t                            node.argument = replaced;\n\t                        }\n\t                        contextual_dependencies.add(object.name);\n\t                        contextual_dependencies.add(property.name);\n\t                    }\n\t                    this.replace(invalidate(block.renderer, scope, node, traced));\n\t                }\n\t            }\n\t        });\n\t        if (declarations.length > 0) {\n\t            block.maintain_context = true;\n\t            declarations.forEach(declaration => {\n\t                block.chunks.init.push(declaration);\n\t            });\n\t        }\n\t        return (this.manipulated = node);\n\t    }\n\t}\n\tfunction get_function_name(_node, parent) {\n\t    if (parent.type === 'EventHandler') {\n\t        return `${parent.name}_handler`;\n\t    }\n\t    if (parent.type === 'Action') {\n\t        return `${parent.name}_function`;\n\t    }\n\t    return 'func';\n\t}\n\tfunction is_contextual(component, scope, name) {\n\t    if (is_reserved_keyword(name))\n\t        return true;\n\t    // if it's a name below root scope, it's contextual\n\t    if (!scope.is_top_level(name))\n\t        return true;\n\t    const variable = component.var_lookup.get(name);\n\t    // hoistables, module declarations, and imports are non-contextual\n\t    if (!variable || variable.hoistable)\n\t        return false;\n\t    // assume contextual\n\t    return true;\n\t}\n\n\tclass Action extends Node$1 {\n\t    constructor(component, parent, scope, info) {\n\t        super(component, parent, scope, info);\n\t        component.warn_if_undefined(info.name, info, scope);\n\t        this.name = info.name;\n\t        component.add_reference(info.name.split('.')[0]);\n\t        this.expression = info.expression\n\t            ? new Expression(component, this, scope, info.expression)\n\t            : null;\n\t        this.uses_context = this.expression && this.expression.uses_context;\n\t    }\n\t}\n\n\tclass Tag extends Wrapper {\n\t    constructor(renderer, block, parent, node) {\n\t        super(renderer, block, parent, node);\n\t        this.cannot_use_innerhtml();\n\t        if (!this.is_dependencies_static()) {\n\t            this.not_static_content();\n\t        }\n\t        block.add_dependencies(node.expression.dependencies);\n\t    }\n\t    is_dependencies_static() {\n\t        return this.node.expression.contextual_dependencies.size === 0 && this.node.expression.dynamic_dependencies().length === 0;\n\t    }\n\t    rename_this_method(block, update) {\n\t        const dependencies = this.node.expression.dynamic_dependencies();\n\t        let snippet = this.node.expression.manipulate(block);\n\t        const value = this.node.should_cache && block.get_unique_name(`${this.var.name}_value`);\n\t        const content = this.node.should_cache ? value : snippet;\n\t        snippet = x `${snippet} + \"\"`;\n\t        if (this.node.should_cache)\n\t            block.add_variable(value, snippet); // TODO may need to coerce snippet to string\n\t        if (dependencies.length > 0) {\n\t            let condition = block.renderer.dirty(dependencies);\n\t            if (block.has_outros) {\n\t                condition = x `!#current || ${condition}`;\n\t            }\n\t            const update_cached_value = x `${value} !== (${value} = ${snippet})`;\n\t            if (this.node.should_cache) {\n\t                condition = x `${condition} && ${update_cached_value}`;\n\t            }\n\t            block.chunks.update.push(b `if (${condition}) ${update(content)}`);\n\t        }\n\t        return { init: content };\n\t    }\n\t}\n\n\tclass MustacheTagWrapper extends Tag {\n\t    constructor(renderer, block, parent, node) {\n\t        super(renderer, block, parent, node);\n\t        this.var = { type: 'Identifier', name: 't' };\n\t    }\n\t    render(block, parent_node, parent_nodes) {\n\t        const { init } = this.rename_this_method(block, value => x `@set_data(${this.var}, ${value})`);\n\t        block.add_element(this.var, x `@text(${init})`, parent_nodes && x `@claim_text(${parent_nodes}, ${init})`, parent_node);\n\t    }\n\t}\n\n\tclass RawMustacheTagWrapper extends Tag {\n\t    constructor(renderer, block, parent, node) {\n\t        super(renderer, block, parent, node);\n\t        this.var = { type: 'Identifier', name: 'raw' };\n\t        this.cannot_use_innerhtml();\n\t        this.not_static_content();\n\t    }\n\t    render(block, parent_node, _parent_nodes) {\n\t        const in_head = is_head(parent_node);\n\t        const can_use_innerhtml = !in_head && parent_node && !this.prev && !this.next;\n\t        if (can_use_innerhtml) {\n\t            const insert = content => b `${parent_node}.innerHTML = ${content};`[0];\n\t            const { init } = this.rename_this_method(block, content => insert(content));\n\t            block.chunks.mount.push(insert(init));\n\t        }\n\t        else {\n\t            const needs_anchor = in_head || (this.next ? !this.next.is_dom_node() : (!this.parent || !this.parent.is_dom_node()));\n\t            const html_tag = block.get_unique_name('html_tag');\n\t            const html_anchor = needs_anchor && block.get_unique_name('html_anchor');\n\t            block.add_variable(html_tag);\n\t            const { init } = this.rename_this_method(block, content => x `${html_tag}.p(${content})`);\n\t            const update_anchor = needs_anchor ? html_anchor : this.next ? this.next.var : 'null';\n\t            block.chunks.hydrate.push(b `${html_tag} = new @HtmlTag(${update_anchor});`);\n\t            block.chunks.mount.push(b `${html_tag}.m(${init}, ${parent_node || '#target'}, ${parent_node ? null : '#anchor'});`);\n\t            if (needs_anchor) {\n\t                block.add_element(html_anchor, x `@empty()`, x `@empty()`, parent_node);\n\t            }\n\t            if (!parent_node || in_head) {\n\t                block.chunks.destroy.push(b `if (detaching) ${html_tag}.d();`);\n\t            }\n\t        }\n\t    }\n\t}\n\n\tconst events = [\n\t    {\n\t        event_names: ['input'],\n\t        filter: (node, _name) => node.name === 'textarea' ||\n\t            node.name === 'input' && !/radio|checkbox|range|file/.test(node.get_static_attribute_value('type'))\n\t    },\n\t    {\n\t        event_names: ['input'],\n\t        filter: (node, name) => (name === 'textContent' || name === 'innerHTML') &&\n\t            node.attributes.some(attribute => attribute.name === 'contenteditable')\n\t    },\n\t    {\n\t        event_names: ['change'],\n\t        filter: (node, _name) => node.name === 'select' ||\n\t            node.name === 'input' && /radio|checkbox|file/.test(node.get_static_attribute_value('type'))\n\t    },\n\t    {\n\t        event_names: ['change', 'input'],\n\t        filter: (node, _name) => node.name === 'input' && node.get_static_attribute_value('type') === 'range'\n\t    },\n\t    {\n\t        event_names: ['elementresize'],\n\t        filter: (_node, name) => dimensions.test(name)\n\t    },\n\t    // media events\n\t    {\n\t        event_names: ['timeupdate'],\n\t        filter: (node, name) => node.is_media_node() &&\n\t            (name === 'currentTime' || name === 'played' || name === 'ended')\n\t    },\n\t    {\n\t        event_names: ['durationchange'],\n\t        filter: (node, name) => node.is_media_node() &&\n\t            name === 'duration'\n\t    },\n\t    {\n\t        event_names: ['play', 'pause'],\n\t        filter: (node, name) => node.is_media_node() &&\n\t            name === 'paused'\n\t    },\n\t    {\n\t        event_names: ['progress'],\n\t        filter: (node, name) => node.is_media_node() &&\n\t            name === 'buffered'\n\t    },\n\t    {\n\t        event_names: ['loadedmetadata'],\n\t        filter: (node, name) => node.is_media_node() &&\n\t            (name === 'buffered' || name === 'seekable')\n\t    },\n\t    {\n\t        event_names: ['volumechange'],\n\t        filter: (node, name) => node.is_media_node() &&\n\t            (name === 'volume' || name === 'muted')\n\t    },\n\t    {\n\t        event_names: ['ratechange'],\n\t        filter: (node, name) => node.is_media_node() &&\n\t            name === 'playbackRate'\n\t    },\n\t    {\n\t        event_names: ['seeking', 'seeked'],\n\t        filter: (node, name) => node.is_media_node() &&\n\t            (name === 'seeking')\n\t    },\n\t    {\n\t        event_names: ['ended'],\n\t        filter: (node, name) => node.is_media_node() &&\n\t            name === 'ended'\n\t    },\n\t    {\n\t        event_names: ['resize'],\n\t        filter: (node, name) => node.is_media_node() &&\n\t            (name === 'videoHeight' || name === 'videoWidth')\n\t    },\n\t    // details event\n\t    {\n\t        event_names: ['toggle'],\n\t        filter: (node, _name) => node.name === 'details'\n\t    },\n\t];\n\tclass ElementWrapper extends Wrapper {\n\t    constructor(renderer, block, parent, node, strip_whitespace, next_sibling) {\n\t        super(renderer, block, parent, node);\n\t        this.var = {\n\t            type: 'Identifier',\n\t            name: node.name.replace(/[^a-zA-Z0-9_$]/g, '_')\n\t        };\n\t        this.void = is_void(node.name);\n\t        this.class_dependencies = [];\n\t        if (this.node.children.length) {\n\t            this.node.lets.forEach(l => {\n\t                extract_names(l.value || l.name).forEach(name => {\n\t                    renderer.add_to_context(name, true);\n\t                });\n\t            });\n\t        }\n\t        this.attributes = this.node.attributes.map(attribute => {\n\t            if (attribute.name === 'slot') {\n\t                // TODO make separate subclass for this?\n\t                let owner = this.parent;\n\t                while (owner) {\n\t                    if (owner.node.type === 'InlineComponent') {\n\t                        break;\n\t                    }\n\t                    if (owner.node.type === 'Element' && /-/.test(owner.node.name)) {\n\t                        break;\n\t                    }\n\t                    owner = owner.parent;\n\t                }\n\t                if (owner && owner.node.type === 'InlineComponent') {\n\t                    const name = attribute.get_static_value();\n\t                    if (!owner.slots.has(name)) {\n\t                        const child_block = block.child({\n\t                            comment: create_debugging_comment(node, this.renderer.component),\n\t                            name: this.renderer.component.get_unique_name(`create_${sanitize(name)}_slot`),\n\t                            type: 'slot'\n\t                        });\n\t                        const { scope, lets } = this.node;\n\t                        const seen = new Set(lets.map(l => l.name.name));\n\t                        owner.node.lets.forEach(l => {\n\t                            if (!seen.has(l.name.name))\n\t                                lets.push(l);\n\t                        });\n\t                        owner.slots.set(name, get_slot_definition(child_block, scope, lets));\n\t                        this.renderer.blocks.push(child_block);\n\t                    }\n\t                    this.slot_block = owner.slots.get(name).block;\n\t                    block = this.slot_block;\n\t                }\n\t            }\n\t            if (attribute.name === 'style') {\n\t                return new StyleAttributeWrapper(this, block, attribute);\n\t            }\n\t            if (attribute.type === 'Spread') {\n\t                return new SpreadAttributeWrapper(this, block, attribute);\n\t            }\n\t            return new AttributeWrapper(this, block, attribute);\n\t        });\n\t        // ordinarily, there'll only be one... but we need to handle\n\t        // the rare case where an element can have multiple bindings,\n\t        // e.g. <audio bind:paused bind:currentTime>\n\t        this.bindings = this.node.bindings.map(binding => new BindingWrapper(block, binding, this));\n\t        this.event_handlers = this.node.handlers.map(event_handler => new EventHandlerWrapper(event_handler, this));\n\t        if (node.intro || node.outro) {\n\t            if (node.intro)\n\t                block.add_intro(node.intro.is_local);\n\t            if (node.outro)\n\t                block.add_outro(node.outro.is_local);\n\t        }\n\t        if (node.animation) {\n\t            block.add_animation();\n\t        }\n\t        // add directive and handler dependencies\n\t        [node.animation, node.outro, ...node.actions, ...node.classes].forEach(directive => {\n\t            if (directive && directive.expression) {\n\t                block.add_dependencies(directive.expression.dependencies);\n\t            }\n\t        });\n\t        node.handlers.forEach(handler => {\n\t            if (handler.expression) {\n\t                block.add_dependencies(handler.expression.dependencies);\n\t            }\n\t        });\n\t        if (this.parent) {\n\t            if (node.actions.length > 0 ||\n\t                node.animation ||\n\t                node.bindings.length > 0 ||\n\t                node.classes.length > 0 ||\n\t                node.intro || node.outro ||\n\t                node.handlers.length > 0 ||\n\t                this.node.name === 'option' ||\n\t                renderer.options.dev) {\n\t                this.parent.cannot_use_innerhtml(); // need to use add_location\n\t                this.parent.not_static_content();\n\t            }\n\t        }\n\t        this.fragment = new FragmentWrapper(renderer, block, node.children, this, strip_whitespace, next_sibling);\n\t        if (this.slot_block) {\n\t            block.parent.add_dependencies(block.dependencies);\n\t            // appalling hack\n\t            const index = block.parent.wrappers.indexOf(this);\n\t            block.parent.wrappers.splice(index, 1);\n\t            block.wrappers.push(this);\n\t        }\n\t    }\n\t    render(block, parent_node, parent_nodes) {\n\t        const { renderer } = this;\n\t        if (this.node.name === 'noscript')\n\t            return;\n\t        if (this.slot_block) {\n\t            block = this.slot_block;\n\t        }\n\t        const node = this.var;\n\t        const nodes = parent_nodes && block.get_unique_name(`${this.var.name}_nodes`); // if we're in unclaimable territory, i.e. <head>, parent_nodes is null\n\t        const children = x `@children(${this.node.name === 'template' ? x `${node}.content` : node})`;\n\t        block.add_variable(node);\n\t        const render_statement = this.get_render_statement(block);\n\t        block.chunks.create.push(b `${node} = ${render_statement};`);\n\t        if (renderer.options.hydratable) {\n\t            if (parent_nodes) {\n\t                block.chunks.claim.push(b `\n\t\t\t\t\t${node} = ${this.get_claim_statement(parent_nodes)};\n\t\t\t\t`);\n\t                if (!this.void && this.node.children.length > 0) {\n\t                    block.chunks.claim.push(b `\n\t\t\t\t\t\tvar ${nodes} = ${children};\n\t\t\t\t\t`);\n\t                }\n\t            }\n\t            else {\n\t                block.chunks.claim.push(b `${node} = ${render_statement};`);\n\t            }\n\t        }\n\t        if (parent_node) {\n\t            block.chunks.mount.push(b `@append(${parent_node}, ${node});`);\n\t            if (is_head(parent_node)) {\n\t                block.chunks.destroy.push(b `@detach(${node});`);\n\t            }\n\t        }\n\t        else {\n\t            block.chunks.mount.push(b `@insert(#target, ${node}, #anchor);`);\n\t            // TODO we eventually need to consider what happens to elements\n\t            // that belong to the same outgroup as an outroing element...\n\t            block.chunks.destroy.push(b `if (detaching) @detach(${node});`);\n\t        }\n\t        // insert static children with textContent or innerHTML\n\t        const can_use_textcontent = this.can_use_textcontent();\n\t        if (!this.node.namespace && (this.can_use_innerhtml || can_use_textcontent) && this.fragment.nodes.length > 0) {\n\t            if (this.fragment.nodes.length === 1 && this.fragment.nodes[0].node.type === 'Text') {\n\t                block.chunks.create.push(b `${node}.textContent = ${string_literal(this.fragment.nodes[0].data)};`);\n\t            }\n\t            else {\n\t                const state = {\n\t                    quasi: {\n\t                        type: 'TemplateElement',\n\t                        value: { raw: '' }\n\t                    }\n\t                };\n\t                const literal = {\n\t                    type: 'TemplateLiteral',\n\t                    expressions: [],\n\t                    quasis: []\n\t                };\n\t                const can_use_raw_text = !this.can_use_innerhtml && can_use_textcontent;\n\t                to_html(this.fragment.nodes, block, literal, state, can_use_raw_text);\n\t                literal.quasis.push(state.quasi);\n\t                block.chunks.create.push(b `${node}.${this.can_use_innerhtml ? 'innerHTML' : 'textContent'} = ${literal};`);\n\t            }\n\t        }\n\t        else {\n\t            this.fragment.nodes.forEach((child) => {\n\t                child.render(block, this.node.name === 'template' ? x `${node}.content` : node, nodes);\n\t            });\n\t        }\n\t        const event_handler_or_binding_uses_context = (this.bindings.some(binding => binding.handler.uses_context) ||\n\t            this.node.handlers.some(handler => handler.uses_context) ||\n\t            this.node.actions.some(action => action.uses_context));\n\t        if (event_handler_or_binding_uses_context) {\n\t            block.maintain_context = true;\n\t        }\n\t        this.add_attributes(block);\n\t        this.add_directives_in_order(block);\n\t        this.add_transitions(block);\n\t        this.add_animation(block);\n\t        this.add_classes(block);\n\t        this.add_manual_style_scoping(block);\n\t        if (nodes && this.renderer.options.hydratable && !this.void) {\n\t            block.chunks.claim.push(b `${this.node.children.length > 0 ? nodes : children}.forEach(@detach);`);\n\t        }\n\t        if (renderer.options.dev) {\n\t            const loc = renderer.locate(this.node.start);\n\t            block.chunks.hydrate.push(b `@add_location(${this.var}, ${renderer.file_var}, ${loc.line - 1}, ${loc.column}, ${this.node.start});`);\n\t        }\n\t    }\n\t    can_use_textcontent() {\n\t        return this.is_static_content && this.fragment.nodes.every(node => node.node.type === 'Text' || node.node.type === 'MustacheTag');\n\t    }\n\t    get_render_statement(block) {\n\t        const { name, namespace } = this.node;\n\t        if (namespace === namespaces.svg) {\n\t            return x `@svg_element(\"${name}\")`;\n\t        }\n\t        if (namespace) {\n\t            return x `@_document.createElementNS(\"${namespace}\", \"${name}\")`;\n\t        }\n\t        const is = this.attributes.find(attr => attr.node.name === 'is');\n\t        if (is) {\n\t            return x `@element_is(\"${name}\", ${is.render_chunks(block).reduce((lhs, rhs) => x `${lhs} + ${rhs}`)})`;\n\t        }\n\t        return x `@element(\"${name}\")`;\n\t    }\n\t    get_claim_statement(nodes) {\n\t        const attributes = this.node.attributes\n\t            .filter((attr) => attr.type === 'Attribute')\n\t            .map((attr) => p `${attr.name}: true`);\n\t        const name = this.node.namespace\n\t            ? this.node.name\n\t            : this.node.name.toUpperCase();\n\t        const svg = this.node.namespace === namespaces.svg ? 1 : null;\n\t        return x `@claim_element(${nodes}, \"${name}\", { ${attributes} }, ${svg})`;\n\t    }\n\t    add_directives_in_order(block) {\n\t        const binding_groups = events\n\t            .map(event => ({\n\t            events: event.event_names,\n\t            bindings: this.bindings\n\t                .filter(binding => binding.node.name !== 'this')\n\t                .filter(binding => event.filter(this.node, binding.node.name))\n\t        }))\n\t            .filter(group => group.bindings.length);\n\t        const this_binding = this.bindings.find(b => b.node.name === 'this');\n\t        function getOrder(item) {\n\t            if (item instanceof EventHandlerWrapper) {\n\t                return item.node.start;\n\t            }\n\t            else if (item instanceof BindingWrapper) {\n\t                return item.node.start;\n\t            }\n\t            else if (item instanceof Action) {\n\t                return item.start;\n\t            }\n\t            else {\n\t                return item.bindings[0].node.start;\n\t            }\n\t        }\n\t        [\n\t            ...binding_groups,\n\t            ...this.event_handlers,\n\t            this_binding,\n\t            ...this.node.actions\n\t        ]\n\t            .filter(Boolean)\n\t            .sort((a, b) => getOrder(a) - getOrder(b))\n\t            .forEach(item => {\n\t            if (item instanceof EventHandlerWrapper) {\n\t                add_event_handler(block, this.var, item);\n\t            }\n\t            else if (item instanceof BindingWrapper) {\n\t                this.add_this_binding(block, item);\n\t            }\n\t            else if (item instanceof Action) {\n\t                add_action(block, this.var, item);\n\t            }\n\t            else {\n\t                this.add_bindings(block, item);\n\t            }\n\t        });\n\t    }\n\t    add_bindings(block, binding_group) {\n\t        const { renderer } = this;\n\t        if (binding_group.bindings.length === 0)\n\t            return;\n\t        renderer.component.has_reactive_assignments = true;\n\t        const lock = binding_group.bindings.some(binding => binding.needs_lock) ?\n\t            block.get_unique_name(`${this.var.name}_updating`) :\n\t            null;\n\t        if (lock)\n\t            block.add_variable(lock, x `false`);\n\t        const handler = renderer.component.get_unique_name(`${this.var.name}_${binding_group.events.join('_')}_handler`);\n\t        renderer.add_to_context(handler.name);\n\t        // TODO figure out how to handle locks\n\t        const needs_lock = binding_group.bindings.some(binding => binding.needs_lock);\n\t        const dependencies = new Set();\n\t        const contextual_dependencies = new Set();\n\t        binding_group.bindings.forEach(binding => {\n\t            // TODO this is a mess\n\t            add_to_set(dependencies, binding.get_dependencies());\n\t            add_to_set(contextual_dependencies, binding.handler.contextual_dependencies);\n\t            binding.render(block, lock);\n\t        });\n\t        // media bindings \u2014 awkward special case. The native timeupdate events\n\t        // fire too infrequently, so we need to take matters into our\n\t        // own hands\n\t        let animation_frame;\n\t        if (binding_group.events[0] === 'timeupdate') {\n\t            animation_frame = block.get_unique_name(`${this.var.name}_animationframe`);\n\t            block.add_variable(animation_frame);\n\t        }\n\t        const has_local_function = contextual_dependencies.size > 0 || needs_lock || animation_frame;\n\t        let callee = renderer.reference(handler);\n\t        // TODO dry this out \u2014 similar code for event handlers and component bindings\n\t        if (has_local_function) {\n\t            const args = Array.from(contextual_dependencies).map(name => renderer.reference(name));\n\t            // need to create a block-local function that calls an instance-level function\n\t            if (animation_frame) {\n\t                block.chunks.init.push(b `\n\t\t\t\t\tfunction ${handler}() {\n\t\t\t\t\t\t@_cancelAnimationFrame(${animation_frame});\n\t\t\t\t\t\tif (!${this.var}.paused) {\n\t\t\t\t\t\t\t${animation_frame} = @raf(${handler});\n\t\t\t\t\t\t\t${needs_lock && b `${lock} = true;`}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t${callee}.call(${this.var}, ${args});\n\t\t\t\t\t}\n\t\t\t\t`);\n\t            }\n\t            else {\n\t                block.chunks.init.push(b `\n\t\t\t\t\tfunction ${handler}() {\n\t\t\t\t\t\t${needs_lock && b `${lock} = true;`}\n\t\t\t\t\t\t${callee}.call(${this.var}, ${args});\n\t\t\t\t\t}\n\t\t\t\t`);\n\t            }\n\t            callee = handler;\n\t        }\n\t        const params = Array.from(contextual_dependencies).map(name => ({\n\t            type: 'Identifier',\n\t            name\n\t        }));\n\t        this.renderer.component.partly_hoisted.push(b `\n\t\t\tfunction ${handler}(${params}) {\n\t\t\t\t${binding_group.bindings.map(b => b.handler.mutation)}\n\t\t\t\t${Array.from(dependencies)\n            .filter(dep => dep[0] !== '$')\n            .filter(dep => !contextual_dependencies.has(dep))\n            .map(dep => b `${this.renderer.invalidate(dep)};`)}\n\t\t\t}\n\t\t`);\n\t        binding_group.events.forEach(name => {\n\t            if (name === 'elementresize') {\n\t                // special case\n\t                const resize_listener = block.get_unique_name(`${this.var.name}_resize_listener`);\n\t                block.add_variable(resize_listener);\n\t                block.chunks.mount.push(b `${resize_listener} = @add_resize_listener(${this.var}, ${callee}.bind(${this.var}));`);\n\t                block.chunks.destroy.push(b `${resize_listener}();`);\n\t            }\n\t            else {\n\t                block.event_listeners.push(x `@listen(${this.var}, \"${name}\", ${callee})`);\n\t            }\n\t        });\n\t        const some_initial_state_is_undefined = binding_group.bindings\n\t            .map(binding => x `${binding.snippet} === void 0`)\n\t            .reduce((lhs, rhs) => x `${lhs} || ${rhs}`);\n\t        const should_initialise = (this.node.name === 'select' ||\n\t            binding_group.bindings.find(binding => {\n\t                return (binding.node.name === 'indeterminate' ||\n\t                    binding.node.name === 'textContent' ||\n\t                    binding.node.name === 'innerHTML' ||\n\t                    binding.is_readonly_media_attribute());\n\t            }));\n\t        if (should_initialise) {\n\t            const callback = has_local_function ? handler : x `() => ${callee}.call(${this.var})`;\n\t            block.chunks.hydrate.push(b `if (${some_initial_state_is_undefined}) @add_render_callback(${callback});`);\n\t        }\n\t        if (binding_group.events[0] === 'elementresize') {\n\t            block.chunks.hydrate.push(b `@add_render_callback(() => ${callee}.call(${this.var}));`);\n\t        }\n\t        if (lock) {\n\t            block.chunks.update.push(b `${lock} = false;`);\n\t        }\n\t    }\n\t    add_this_binding(block, this_binding) {\n\t        const { renderer } = this;\n\t        renderer.component.has_reactive_assignments = true;\n\t        const binding_callback = bind_this(renderer.component, block, this_binding, this.var);\n\t        block.chunks.mount.push(binding_callback);\n\t    }\n\t    add_attributes(block) {\n\t        // Get all the class dependencies first\n\t        this.attributes.forEach((attribute) => {\n\t            if (attribute.node.name === 'class') {\n\t                const dependencies = attribute.node.get_dependencies();\n\t                this.class_dependencies.push(...dependencies);\n\t            }\n\t        });\n\t        if (this.node.attributes.some(attr => attr.is_spread)) {\n\t            this.add_spread_attributes(block);\n\t            return;\n\t        }\n\t        this.attributes.forEach((attribute) => {\n\t            attribute.render(block);\n\t        });\n\t    }\n\t    add_spread_attributes(block) {\n\t        const levels = block.get_unique_name(`${this.var.name}_levels`);\n\t        const data = block.get_unique_name(`${this.var.name}_data`);\n\t        const initial_props = [];\n\t        const updates = [];\n\t        this.attributes\n\t            .forEach(attr => {\n\t            const dependencies = attr.node.get_dependencies();\n\t            const condition = dependencies.length > 0\n\t                ? block.renderer.dirty(dependencies)\n\t                : null;\n\t            if (attr instanceof SpreadAttributeWrapper) {\n\t                const snippet = attr.node.expression.manipulate(block);\n\t                initial_props.push(snippet);\n\t                updates.push(condition ? x `${condition} && ${snippet}` : snippet);\n\t            }\n\t            else {\n\t                const name = attr.property_name || attr.name;\n\t                initial_props.push(x `{ ${name}: ${attr.get_init(block, attr.get_value(block))} }`);\n\t                const snippet = x `{ ${name}: ${attr.should_cache ? attr.last : attr.get_value(block)} }`;\n\t                updates.push(condition ? x `${attr.get_dom_update_conditions(block, condition)} && ${snippet}` : snippet);\n\t            }\n\t        });\n\t        block.chunks.init.push(b `\n\t\t\tlet ${levels} = [${initial_props}];\n\n\t\t\tlet ${data} = {};\n\t\t\tfor (let #i = 0; #i < ${levels}.length; #i += 1) {\n\t\t\t\t${data} = @assign(${data}, ${levels}[#i]);\n\t\t\t}\n\t\t`);\n\t        const fn = this.node.namespace === namespaces.svg ? x `@set_svg_attributes` : x `@set_attributes`;\n\t        block.chunks.hydrate.push(b `${fn}(${this.var}, ${data});`);\n\t        block.chunks.update.push(b `\n\t\t\t${fn}(${this.var}, ${data} = @get_spread_update(${levels}, [\n\t\t\t\t${updates}\n\t\t\t]));\n\t\t`);\n\t        // handle edge cases for elements\n\t        if (this.node.name === 'select') {\n\t            const dependencies = new Set();\n\t            for (const attr of this.attributes) {\n\t                for (const dep of attr.node.dependencies) {\n\t                    dependencies.add(dep);\n\t                }\n\t            }\n\t            block.chunks.mount.push(b `\n\t\t\t\tif (${data}.multiple) @select_options(${this.var}, ${data}.value);\n\t\t\t`);\n\t            block.chunks.update.push(b `\n\t\t\t\tif (${block.renderer.dirty(Array.from(dependencies))} && ${data}.multiple) @select_options(${this.var}, ${data}.value);\n\t\t\t`);\n\t        }\n\t    }\n\t    add_transitions(block) {\n\t        const { intro, outro } = this.node;\n\t        if (!intro && !outro)\n\t            return;\n\t        if (intro === outro) {\n\t            // bidirectional transition\n\t            const name = block.get_unique_name(`${this.var.name}_transition`);\n\t            const snippet = intro.expression\n\t                ? intro.expression.manipulate(block)\n\t                : x `{}`;\n\t            block.add_variable(name);\n\t            const fn = this.renderer.reference(intro.name);\n\t            const intro_block = b `\n\t\t\t\t@add_render_callback(() => {\n\t\t\t\t\tif (!${name}) ${name} = @create_bidirectional_transition(${this.var}, ${fn}, ${snippet}, true);\n\t\t\t\t\t${name}.run(1);\n\t\t\t\t});\n\t\t\t`;\n\t            const outro_block = b `\n\t\t\t\tif (!${name}) ${name} = @create_bidirectional_transition(${this.var}, ${fn}, ${snippet}, false);\n\t\t\t\t${name}.run(0);\n\t\t\t`;\n\t            if (intro.is_local) {\n\t                block.chunks.intro.push(b `\n\t\t\t\t\tif (#local) {\n\t\t\t\t\t\t${intro_block}\n\t\t\t\t\t}\n\t\t\t\t`);\n\t                block.chunks.outro.push(b `\n\t\t\t\t\tif (#local) {\n\t\t\t\t\t\t${outro_block}\n\t\t\t\t\t}\n\t\t\t\t`);\n\t            }\n\t            else {\n\t                block.chunks.intro.push(intro_block);\n\t                block.chunks.outro.push(outro_block);\n\t            }\n\t            block.chunks.destroy.push(b `if (detaching && ${name}) ${name}.end();`);\n\t        }\n\t        else {\n\t            const intro_name = intro && block.get_unique_name(`${this.var.name}_intro`);\n\t            const outro_name = outro && block.get_unique_name(`${this.var.name}_outro`);\n\t            if (intro) {\n\t                block.add_variable(intro_name);\n\t                const snippet = intro.expression\n\t                    ? intro.expression.manipulate(block)\n\t                    : x `{}`;\n\t                const fn = this.renderer.reference(intro.name);\n\t                let intro_block;\n\t                if (outro) {\n\t                    intro_block = b `\n\t\t\t\t\t\t@add_render_callback(() => {\n\t\t\t\t\t\t\tif (${outro_name}) ${outro_name}.end(1);\n\t\t\t\t\t\t\tif (!${intro_name}) ${intro_name} = @create_in_transition(${this.var}, ${fn}, ${snippet});\n\t\t\t\t\t\t\t${intro_name}.start();\n\t\t\t\t\t\t});\n\t\t\t\t\t`;\n\t                    block.chunks.outro.push(b `if (${intro_name}) ${intro_name}.invalidate();`);\n\t                }\n\t                else {\n\t                    intro_block = b `\n\t\t\t\t\t\tif (!${intro_name}) {\n\t\t\t\t\t\t\t@add_render_callback(() => {\n\t\t\t\t\t\t\t\t${intro_name} = @create_in_transition(${this.var}, ${fn}, ${snippet});\n\t\t\t\t\t\t\t\t${intro_name}.start();\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t`;\n\t                }\n\t                if (intro.is_local) {\n\t                    intro_block = b `\n\t\t\t\t\t\tif (#local) {\n\t\t\t\t\t\t\t${intro_block}\n\t\t\t\t\t\t}\n\t\t\t\t\t`;\n\t                }\n\t                block.chunks.intro.push(intro_block);\n\t            }\n\t            if (outro) {\n\t                block.add_variable(outro_name);\n\t                const snippet = outro.expression\n\t                    ? outro.expression.manipulate(block)\n\t                    : x `{}`;\n\t                const fn = this.renderer.reference(outro.name);\n\t                if (!intro) {\n\t                    block.chunks.intro.push(b `\n\t\t\t\t\t\tif (${outro_name}) ${outro_name}.end(1);\n\t\t\t\t\t`);\n\t                }\n\t                // TODO hide elements that have outro'd (unless they belong to a still-outroing\n\t                // group) prior to their removal from the DOM\n\t                let outro_block = b `\n\t\t\t\t\t${outro_name} = @create_out_transition(${this.var}, ${fn}, ${snippet});\n\t\t\t\t`;\n\t                if (outro.is_local) {\n\t                    outro_block = b `\n\t\t\t\t\t\tif (#local) {\n\t\t\t\t\t\t\t${outro_block}\n\t\t\t\t\t\t}\n\t\t\t\t\t`;\n\t                }\n\t                block.chunks.outro.push(outro_block);\n\t                block.chunks.destroy.push(b `if (detaching && ${outro_name}) ${outro_name}.end();`);\n\t            }\n\t        }\n\t    }\n\t    add_animation(block) {\n\t        if (!this.node.animation)\n\t            return;\n\t        const { outro } = this.node;\n\t        const rect = block.get_unique_name('rect');\n\t        const stop_animation = block.get_unique_name('stop_animation');\n\t        block.add_variable(rect);\n\t        block.add_variable(stop_animation, x `@noop`);\n\t        block.chunks.measure.push(b `\n\t\t\t${rect} = ${this.var}.getBoundingClientRect();\n\t\t`);\n\t        block.chunks.fix.push(b `\n\t\t\t@fix_position(${this.var});\n\t\t\t${stop_animation}();\n\t\t\t${outro && b `@add_transform(${this.var}, ${rect});`}\n\t\t`);\n\t        const params = this.node.animation.expression ? this.node.animation.expression.manipulate(block) : x `{}`;\n\t        const name = this.renderer.reference(this.node.animation.name);\n\t        block.chunks.animate.push(b `\n\t\t\t${stop_animation}();\n\t\t\t${stop_animation} = @create_animation(${this.var}, ${rect}, ${name}, ${params});\n\t\t`);\n\t    }\n\t    add_classes(block) {\n\t        const has_spread = this.node.attributes.some(attr => attr.is_spread);\n\t        this.node.classes.forEach(class_directive => {\n\t            const { expression, name } = class_directive;\n\t            let snippet;\n\t            let dependencies;\n\t            if (expression) {\n\t                snippet = expression.manipulate(block);\n\t                dependencies = expression.dependencies;\n\t            }\n\t            else {\n\t                snippet = name;\n\t                dependencies = new Set([name]);\n\t            }\n\t            const updater = b `@toggle_class(${this.var}, \"${name}\", ${snippet});`;\n\t            block.chunks.hydrate.push(updater);\n\t            if (has_spread) {\n\t                block.chunks.update.push(updater);\n\t            }\n\t            else if ((dependencies && dependencies.size > 0) || this.class_dependencies.length) {\n\t                const all_dependencies = this.class_dependencies.concat(...dependencies);\n\t                const condition = block.renderer.dirty(all_dependencies);\n\t                block.chunks.update.push(b `\n\t\t\t\t\tif (${condition}) {\n\t\t\t\t\t\t${updater}\n\t\t\t\t\t}`);\n\t            }\n\t        });\n\t    }\n\t    add_manual_style_scoping(block) {\n\t        if (this.node.needs_manual_style_scoping) {\n\t            const updater = b `@toggle_class(${this.var}, \"${this.node.component.stylesheet.id}\", true);`;\n\t            block.chunks.hydrate.push(updater);\n\t            block.chunks.update.push(updater);\n\t        }\n\t    }\n\t}\n\tfunction to_html(wrappers, block, literal, state, can_use_raw_text) {\n\t    wrappers.forEach(wrapper => {\n\t        if (wrapper instanceof TextWrapper) {\n\t            if (wrapper.use_space())\n\t                state.quasi.value.raw += ' ';\n\t            const parent = wrapper.node.parent;\n\t            const raw = parent && (parent.name === 'script' ||\n\t                parent.name === 'style' ||\n\t                can_use_raw_text);\n\t            state.quasi.value.raw += (raw ? wrapper.data : escape_html(wrapper.data))\n\t                .replace(/\\\\/g, '\\\\\\\\')\n\t                .replace(/`/g, '\\\\`')\n\t                .replace(/\\$/g, '\\\\$');\n\t        }\n\t        else if (wrapper instanceof MustacheTagWrapper || wrapper instanceof RawMustacheTagWrapper) {\n\t            literal.quasis.push(state.quasi);\n\t            literal.expressions.push(wrapper.node.expression.manipulate(block));\n\t            state.quasi = {\n\t                type: 'TemplateElement',\n\t                value: { raw: '' }\n\t            };\n\t        }\n\t        else if (wrapper.node.name === 'noscript') ;\n\t        else {\n\t            // element\n\t            state.quasi.value.raw += `<${wrapper.node.name}`;\n\t            wrapper.attributes.forEach((attr) => {\n\t                state.quasi.value.raw += ` ${fix_attribute_casing(attr.node.name)}=\"`;\n\t                attr.node.chunks.forEach(chunk => {\n\t                    if (chunk.type === 'Text') {\n\t                        state.quasi.value.raw += escape_html(chunk.data);\n\t                    }\n\t                    else {\n\t                        literal.quasis.push(state.quasi);\n\t                        literal.expressions.push(chunk.manipulate(block));\n\t                        state.quasi = {\n\t                            type: 'TemplateElement',\n\t                            value: { raw: '' }\n\t                        };\n\t                    }\n\t                });\n\t                state.quasi.value.raw += `\"`;\n\t            });\n\t            state.quasi.value.raw += '>';\n\t            if (!wrapper.void) {\n\t                to_html(wrapper.fragment.nodes, block, literal, state);\n\t                state.quasi.value.raw += `</${wrapper.node.name}>`;\n\t            }\n\t        }\n\t    });\n\t}\n\n\tclass HeadWrapper extends Wrapper {\n\t    constructor(renderer, block, parent, node, strip_whitespace, next_sibling) {\n\t        super(renderer, block, parent, node);\n\t        this.can_use_innerhtml = false;\n\t        this.fragment = new FragmentWrapper(renderer, block, node.children, this, strip_whitespace, next_sibling);\n\t    }\n\t    render(block, _parent_node, _parent_nodes) {\n\t        let nodes;\n\t        if (this.renderer.options.hydratable && this.fragment.nodes.length) {\n\t            nodes = block.get_unique_name('head_nodes');\n\t            block.chunks.claim.push(b `const ${nodes} = @query_selector_all('[data-svelte=\"${this.node.id}\"]', @_document.head);`);\n\t        }\n\t        this.fragment.render(block, x `@_document.head`, nodes);\n\t        if (nodes && this.renderer.options.hydratable) {\n\t            block.chunks.claim.push(b `${nodes}.forEach(@detach);`);\n\t        }\n\t    }\n\t}\n\n\tfunction is_else_if(node) {\n\t    return (node && node.children.length === 1 && node.children[0].type === 'IfBlock');\n\t}\n\tclass IfBlockBranch extends Wrapper {\n\t    constructor(renderer, block, parent, node, strip_whitespace, next_sibling) {\n\t        super(renderer, block, parent, node);\n\t        this.var = null;\n\t        const { expression } = node;\n\t        const is_else = !expression;\n\t        if (expression) {\n\t            this.dependencies = expression.dynamic_dependencies();\n\t            // TODO is this the right rule? or should any non-reference count?\n\t            // const should_cache = !is_reference(expression.node, null) && dependencies.length > 0;\n\t            let should_cache = false;\n\t            walk(expression.node, {\n\t                enter(node) {\n\t                    if (node.type === 'CallExpression' || node.type === 'NewExpression') {\n\t                        should_cache = true;\n\t                    }\n\t                }\n\t            });\n\t            if (should_cache) {\n\t                this.condition = block.get_unique_name(`show_if`);\n\t                this.snippet = expression.manipulate(block);\n\t            }\n\t            else {\n\t                this.condition = expression.manipulate(block);\n\t            }\n\t        }\n\t        this.block = block.child({\n\t            comment: create_debugging_comment(node, parent.renderer.component),\n\t            name: parent.renderer.component.get_unique_name(is_else ? `create_else_block` : `create_if_block`),\n\t            type: node.expression ? 'if' : 'else'\n\t        });\n\t        this.fragment = new FragmentWrapper(renderer, this.block, node.children, parent, strip_whitespace, next_sibling);\n\t        this.is_dynamic = this.block.dependencies.size > 0;\n\t    }\n\t}\n\tclass IfBlockWrapper extends Wrapper {\n\t    constructor(renderer, block, parent, node, strip_whitespace, next_sibling) {\n\t        super(renderer, block, parent, node);\n\t        this.needs_update = false;\n\t        this.var = { type: 'Identifier', name: 'if_block' };\n\t        this.cannot_use_innerhtml();\n\t        this.not_static_content();\n\t        this.branches = [];\n\t        const blocks = [];\n\t        let is_dynamic = false;\n\t        let has_intros = false;\n\t        let has_outros = false;\n\t        const create_branches = (node) => {\n\t            const branch = new IfBlockBranch(renderer, block, this, node, strip_whitespace, next_sibling);\n\t            this.branches.push(branch);\n\t            blocks.push(branch.block);\n\t            block.add_dependencies(node.expression.dependencies);\n\t            if (branch.block.dependencies.size > 0) {\n\t                // the condition, or its contents, is dynamic\n\t                is_dynamic = true;\n\t                block.add_dependencies(branch.block.dependencies);\n\t            }\n\t            if (branch.dependencies && branch.dependencies.length > 0) {\n\t                // the condition itself is dynamic\n\t                this.needs_update = true;\n\t            }\n\t            if (branch.block.has_intros)\n\t                has_intros = true;\n\t            if (branch.block.has_outros)\n\t                has_outros = true;\n\t            if (is_else_if(node.else)) {\n\t                create_branches(node.else.children[0]);\n\t            }\n\t            else if (node.else) {\n\t                const branch = new IfBlockBranch(renderer, block, this, node.else, strip_whitespace, next_sibling);\n\t                this.branches.push(branch);\n\t                blocks.push(branch.block);\n\t                if (branch.block.dependencies.size > 0) {\n\t                    is_dynamic = true;\n\t                    block.add_dependencies(branch.block.dependencies);\n\t                }\n\t                if (branch.block.has_intros)\n\t                    has_intros = true;\n\t                if (branch.block.has_outros)\n\t                    has_outros = true;\n\t            }\n\t        };\n\t        create_branches(this.node);\n\t        blocks.forEach(block => {\n\t            block.has_update_method = is_dynamic;\n\t            block.has_intro_method = has_intros;\n\t            block.has_outro_method = has_outros;\n\t        });\n\t        renderer.blocks.push(...blocks);\n\t    }\n\t    render(block, parent_node, parent_nodes) {\n\t        const name = this.var;\n\t        const needs_anchor = this.next ? !this.next.is_dom_node() : !parent_node || !this.parent.is_dom_node();\n\t        const anchor = needs_anchor\n\t            ? block.get_unique_name(`${this.var.name}_anchor`)\n\t            : (this.next && this.next.var) || 'null';\n\t        const has_else = !(this.branches[this.branches.length - 1].condition);\n\t        const if_exists_condition = has_else ? null : name;\n\t        const dynamic = this.branches[0].block.has_update_method; // can use [0] as proxy for all, since they necessarily have the same value\n\t        const has_intros = this.branches[0].block.has_intro_method;\n\t        const has_outros = this.branches[0].block.has_outro_method;\n\t        const has_transitions = has_intros || has_outros;\n\t        const vars = { name, anchor, if_exists_condition, has_else, has_transitions };\n\t        const detaching = parent_node && !is_head(parent_node) ? null : 'detaching';\n\t        if (this.node.else) {\n\t            this.branches.forEach(branch => {\n\t                if (branch.snippet)\n\t                    block.add_variable(branch.condition);\n\t            });\n\t            if (has_outros) {\n\t                this.render_compound_with_outros(block, parent_node, parent_nodes, dynamic, vars, detaching);\n\t                block.chunks.outro.push(b `@transition_out(${name});`);\n\t            }\n\t            else {\n\t                this.render_compound(block, parent_node, parent_nodes, dynamic, vars, detaching);\n\t            }\n\t        }\n\t        else {\n\t            this.render_simple(block, parent_node, parent_nodes, dynamic, vars, detaching);\n\t            if (has_outros) {\n\t                block.chunks.outro.push(b `@transition_out(${name});`);\n\t            }\n\t        }\n\t        if (if_exists_condition) {\n\t            block.chunks.create.push(b `if (${if_exists_condition}) ${name}.c();`);\n\t        }\n\t        else {\n\t            block.chunks.create.push(b `${name}.c();`);\n\t        }\n\t        if (parent_nodes && this.renderer.options.hydratable) {\n\t            if (if_exists_condition) {\n\t                block.chunks.claim.push(b `if (${if_exists_condition}) ${name}.l(${parent_nodes});`);\n\t            }\n\t            else {\n\t                block.chunks.claim.push(b `${name}.l(${parent_nodes});`);\n\t            }\n\t        }\n\t        if (has_intros || has_outros) {\n\t            block.chunks.intro.push(b `@transition_in(${name});`);\n\t        }\n\t        if (needs_anchor) {\n\t            block.add_element(anchor, x `@empty()`, parent_nodes && x `@empty()`, parent_node);\n\t        }\n\t        this.branches.forEach(branch => {\n\t            branch.fragment.render(branch.block, null, x `#nodes`);\n\t        });\n\t    }\n\t    render_compound(block, parent_node, _parent_nodes, dynamic, { name, anchor, has_else, if_exists_condition, has_transitions }, detaching) {\n\t        const select_block_type = this.renderer.component.get_unique_name(`select_block_type`);\n\t        const current_block_type = block.get_unique_name(`current_block_type`);\n\t        const get_block = has_else\n\t            ? x `${current_block_type}(#ctx)`\n\t            : x `${current_block_type} && ${current_block_type}(#ctx)`;\n\t        if (this.needs_update) {\n\t            block.chunks.init.push(b `\n\t\t\t\tfunction ${select_block_type}(#ctx, #dirty) {\n\t\t\t\t\t${this.branches.map(({ dependencies, condition, snippet, block }) => condition\n                ? b `\n\t\t\t\t\t${snippet && (dependencies.length > 0\n                    ? b `if (${condition} == null || ${block.renderer.dirty(dependencies)}) ${condition} = !!${snippet}`\n                    : b `if (${condition} == null) ${condition} = !!${snippet}`)}\n\t\t\t\t\tif (${condition}) return ${block.name};`\n                : b `return ${block.name};`)}\n\t\t\t\t}\n\t\t\t`);\n\t        }\n\t        else {\n\t            block.chunks.init.push(b `\n\t\t\t\tfunction ${select_block_type}(#ctx, #dirty) {\n\t\t\t\t\t${this.branches.map(({ condition, snippet, block }) => condition\n                ? b `if (${snippet || condition}) return ${block.name};`\n                : b `return ${block.name};`)}\n\t\t\t\t}\n\t\t\t`);\n\t        }\n\t        block.chunks.init.push(b `\n\t\t\tlet ${current_block_type} = ${select_block_type}(#ctx, ${this.get_initial_dirty_bit()});\n\t\t\tlet ${name} = ${get_block};\n\t\t`);\n\t        const initial_mount_node = parent_node || '#target';\n\t        const anchor_node = parent_node ? 'null' : '#anchor';\n\t        if (if_exists_condition) {\n\t            block.chunks.mount.push(b `if (${if_exists_condition}) ${name}.m(${initial_mount_node}, ${anchor_node});`);\n\t        }\n\t        else {\n\t            block.chunks.mount.push(b `${name}.m(${initial_mount_node}, ${anchor_node});`);\n\t        }\n\t        if (this.needs_update) {\n\t            const update_mount_node = this.get_update_mount_node(anchor);\n\t            const change_block = b `\n\t\t\t\t${if_exists_condition ? b `if (${if_exists_condition}) ${name}.d(1)` : b `${name}.d(1)`};\n\t\t\t\t${name} = ${get_block};\n\t\t\t\tif (${name}) {\n\t\t\t\t\t${name}.c();\n\t\t\t\t\t${has_transitions && b `@transition_in(${name}, 1);`}\n\t\t\t\t\t${name}.m(${update_mount_node}, ${anchor});\n\t\t\t\t}\n\t\t\t`;\n\t            if (dynamic) {\n\t                block.chunks.update.push(b `\n\t\t\t\t\tif (${current_block_type} === (${current_block_type} = ${select_block_type}(#ctx, #dirty)) && ${name}) {\n\t\t\t\t\t\t${name}.p(#ctx, #dirty);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t${change_block}\n\t\t\t\t\t}\n\t\t\t\t`);\n\t            }\n\t            else {\n\t                block.chunks.update.push(b `\n\t\t\t\t\tif (${current_block_type} !== (${current_block_type} = ${select_block_type}(#ctx, #dirty))) {\n\t\t\t\t\t\t${change_block}\n\t\t\t\t\t}\n\t\t\t\t`);\n\t            }\n\t        }\n\t        else if (dynamic) {\n\t            if (if_exists_condition) {\n\t                block.chunks.update.push(b `if (${if_exists_condition}) ${name}.p(#ctx, #dirty);`);\n\t            }\n\t            else {\n\t                block.chunks.update.push(b `${name}.p(#ctx, #dirty);`);\n\t            }\n\t        }\n\t        if (if_exists_condition) {\n\t            block.chunks.destroy.push(b `\n\t\t\t\tif (${if_exists_condition}) {\n\t\t\t\t\t${name}.d(${detaching});\n\t\t\t\t}\n\t\t\t`);\n\t        }\n\t        else {\n\t            block.chunks.destroy.push(b `\n\t\t\t\t${name}.d(${detaching});\n\t\t\t`);\n\t        }\n\t    }\n\t    // if any of the siblings have outros, we need to keep references to the blocks\n\t    // (TODO does this only apply to bidi transitions?)\n\t    render_compound_with_outros(block, parent_node, _parent_nodes, dynamic, { name, anchor, has_else, has_transitions, if_exists_condition }, detaching) {\n\t        const select_block_type = this.renderer.component.get_unique_name(`select_block_type`);\n\t        const current_block_type_index = block.get_unique_name(`current_block_type_index`);\n\t        const previous_block_index = block.get_unique_name(`previous_block_index`);\n\t        const if_block_creators = block.get_unique_name(`if_block_creators`);\n\t        const if_blocks = block.get_unique_name(`if_blocks`);\n\t        const if_current_block_type_index = has_else\n\t            ? nodes => nodes\n\t            : nodes => b `if (~${current_block_type_index}) { ${nodes} }`;\n\t        block.add_variable(current_block_type_index);\n\t        block.add_variable(name);\n\t        block.chunks.init.push(b `\n\t\t\tconst ${if_block_creators} = [\n\t\t\t\t${this.branches.map(branch => branch.block.name)}\n\t\t\t];\n\n\t\t\tconst ${if_blocks} = [];\n\n\t\t\t${this.needs_update\n            ? b `\n\t\t\t\t\tfunction ${select_block_type}(#ctx, #dirty) {\n\t\t\t\t\t\t${this.branches.map(({ dependencies, condition, snippet }, i) => condition\n                ? b `\n\t\t\t\t\t\t${snippet && (dependencies.length > 0\n                    ? b `if (${block.renderer.dirty(dependencies)}) ${condition} = !!${snippet}`\n                    : b `if (${condition} == null) ${condition} = !!${snippet}`)}\n\t\t\t\t\t\tif (${condition}) return ${i};`\n                : b `return ${i};`)}\n\t\t\t\t\t\t${!has_else && b `return -1;`}\n\t\t\t\t\t}\n\t\t\t\t`\n            : b `\n\t\t\t\t\tfunction ${select_block_type}(#ctx, #dirty) {\n\t\t\t\t\t\t${this.branches.map(({ condition, snippet }, i) => condition\n                ? b `if (${snippet || condition}) return ${i};`\n                : b `return ${i};`)}\n\t\t\t\t\t\t${!has_else && b `return -1;`}\n\t\t\t\t\t}\n\t\t\t\t`}\n\t\t`);\n\t        if (has_else) {\n\t            block.chunks.init.push(b `\n\t\t\t\t${current_block_type_index} = ${select_block_type}(#ctx, ${this.get_initial_dirty_bit()});\n\t\t\t\t${name} = ${if_blocks}[${current_block_type_index}] = ${if_block_creators}[${current_block_type_index}](#ctx);\n\t\t\t`);\n\t        }\n\t        else {\n\t            block.chunks.init.push(b `\n\t\t\t\tif (~(${current_block_type_index} = ${select_block_type}(#ctx, ${this.get_initial_dirty_bit()}))) {\n\t\t\t\t\t${name} = ${if_blocks}[${current_block_type_index}] = ${if_block_creators}[${current_block_type_index}](#ctx);\n\t\t\t\t}\n\t\t\t`);\n\t        }\n\t        const initial_mount_node = parent_node || '#target';\n\t        const anchor_node = parent_node ? 'null' : '#anchor';\n\t        block.chunks.mount.push(if_current_block_type_index(b `${if_blocks}[${current_block_type_index}].m(${initial_mount_node}, ${anchor_node});`));\n\t        if (this.needs_update) {\n\t            const update_mount_node = this.get_update_mount_node(anchor);\n\t            const destroy_old_block = b `\n\t\t\t\t@group_outros();\n\t\t\t\t@transition_out(${if_blocks}[${previous_block_index}], 1, 1, () => {\n\t\t\t\t\t${if_blocks}[${previous_block_index}] = null;\n\t\t\t\t});\n\t\t\t\t@check_outros();\n\t\t\t`;\n\t            const create_new_block = b `\n\t\t\t\t${name} = ${if_blocks}[${current_block_type_index}];\n\t\t\t\tif (!${name}) {\n\t\t\t\t\t${name} = ${if_blocks}[${current_block_type_index}] = ${if_block_creators}[${current_block_type_index}](#ctx);\n\t\t\t\t\t${name}.c();\n\t\t\t\t}\n\t\t\t\t${has_transitions && b `@transition_in(${name}, 1);`}\n\t\t\t\t${name}.m(${update_mount_node}, ${anchor});\n\t\t\t`;\n\t            const change_block = has_else\n\t                ? b `\n\t\t\t\t\t${destroy_old_block}\n\n\t\t\t\t\t${create_new_block}\n\t\t\t\t`\n\t                : b `\n\t\t\t\t\tif (${name}) {\n\t\t\t\t\t\t${destroy_old_block}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (~${current_block_type_index}) {\n\t\t\t\t\t\t${create_new_block}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t${name} = null;\n\t\t\t\t\t}\n\t\t\t\t`;\n\t            if (dynamic) {\n\t                block.chunks.update.push(b `\n\t\t\t\t\tlet ${previous_block_index} = ${current_block_type_index};\n\t\t\t\t\t${current_block_type_index} = ${select_block_type}(#ctx, #dirty);\n\t\t\t\t\tif (${current_block_type_index} === ${previous_block_index}) {\n\t\t\t\t\t\t${if_current_block_type_index(b `${if_blocks}[${current_block_type_index}].p(#ctx, #dirty);`)}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t${change_block}\n\t\t\t\t\t}\n\t\t\t\t`);\n\t            }\n\t            else {\n\t                block.chunks.update.push(b `\n\t\t\t\t\tlet ${previous_block_index} = ${current_block_type_index};\n\t\t\t\t\t${current_block_type_index} = ${select_block_type}(#ctx, #dirty);\n\t\t\t\t\tif (${current_block_type_index} !== ${previous_block_index}) {\n\t\t\t\t\t\t${change_block}\n\t\t\t\t\t}\n\t\t\t\t`);\n\t            }\n\t        }\n\t        else if (dynamic) {\n\t            if (if_exists_condition) {\n\t                block.chunks.update.push(b `if (${if_exists_condition}) ${name}.p(#ctx, #dirty);`);\n\t            }\n\t            else {\n\t                block.chunks.update.push(b `${name}.p(#ctx, #dirty);`);\n\t            }\n\t        }\n\t        block.chunks.destroy.push(if_current_block_type_index(b `${if_blocks}[${current_block_type_index}].d(${detaching});`));\n\t    }\n\t    render_simple(block, parent_node, _parent_nodes, dynamic, { name, anchor, if_exists_condition, has_transitions }, detaching) {\n\t        const branch = this.branches[0];\n\t        if (branch.snippet)\n\t            block.add_variable(branch.condition, branch.snippet);\n\t        block.chunks.init.push(b `\n\t\t\tlet ${name} = ${branch.condition} && ${branch.block.name}(#ctx);\n\t\t`);\n\t        const initial_mount_node = parent_node || '#target';\n\t        const anchor_node = parent_node ? 'null' : '#anchor';\n\t        block.chunks.mount.push(b `if (${name}) ${name}.m(${initial_mount_node}, ${anchor_node});`);\n\t        if (branch.dependencies.length > 0) {\n\t            const update_mount_node = this.get_update_mount_node(anchor);\n\t            const enter = b `\n\t\t\t\tif (${name}) {\n\t\t\t\t\t${dynamic && b `${name}.p(#ctx, #dirty);`}\n\t\t\t\t\t${has_transitions &&\n                b `if (${block.renderer.dirty(branch.dependencies)}) {\n\t\t\t\t\t\t\t@transition_in(${name}, 1);\n\t\t\t\t\t\t}`}\n\t\t\t\t} else {\n\t\t\t\t\t${name} = ${branch.block.name}(#ctx);\n\t\t\t\t\t${name}.c();\n\t\t\t\t\t${has_transitions && b `@transition_in(${name}, 1);`}\n\t\t\t\t\t${name}.m(${update_mount_node}, ${anchor});\n\t\t\t\t}\n\t\t\t`;\n\t            if (branch.snippet) {\n\t                block.chunks.update.push(b `if (${block.renderer.dirty(branch.dependencies)}) ${branch.condition} = ${branch.snippet}`);\n\t            }\n\t            // no `p()` here \u2014 we don't want to update outroing nodes,\n\t            // as that will typically result in glitching\n\t            if (branch.block.has_outro_method) {\n\t                block.chunks.update.push(b `\n\t\t\t\t\tif (${branch.condition}) {\n\t\t\t\t\t\t${enter}\n\t\t\t\t\t} else if (${name}) {\n\t\t\t\t\t\t@group_outros();\n\t\t\t\t\t\t@transition_out(${name}, 1, 1, () => {\n\t\t\t\t\t\t\t${name} = null;\n\t\t\t\t\t\t});\n\t\t\t\t\t\t@check_outros();\n\t\t\t\t\t}\n\t\t\t\t`);\n\t            }\n\t            else {\n\t                block.chunks.update.push(b `\n\t\t\t\t\tif (${branch.condition}) {\n\t\t\t\t\t\t${enter}\n\t\t\t\t\t} else if (${name}) {\n\t\t\t\t\t\t${name}.d(1);\n\t\t\t\t\t\t${name} = null;\n\t\t\t\t\t}\n\t\t\t\t`);\n\t            }\n\t        }\n\t        else if (dynamic) {\n\t            block.chunks.update.push(b `\n\t\t\t\tif (${branch.condition}) ${name}.p(#ctx, #dirty);\n\t\t\t`);\n\t        }\n\t        if (if_exists_condition) {\n\t            block.chunks.destroy.push(b `\n\t\t\t\tif (${if_exists_condition}) ${name}.d(${detaching});\n\t\t\t`);\n\t        }\n\t        else {\n\t            block.chunks.destroy.push(b `\n\t\t\t\t${name}.d(${detaching});\n\t\t\t`);\n\t        }\n\t    }\n\t    get_initial_dirty_bit() {\n\t        const _this = this;\n\t        // TODO: context-overflow make it less gross\n\t        const val = x `-1`;\n\t        return {\n\t            get type() {\n\t                return _this.renderer.context_overflow ? 'ArrayExpression' : 'UnaryExpression';\n\t            },\n\t            // as [-1]\n\t            elements: [val],\n\t            // as -1\n\t            operator: val.operator,\n\t            prefix: val.prefix,\n\t            argument: val.argument,\n\t        };\n\t    }\n\t}\n\n\tclass InlineComponentWrapper extends Wrapper {\n\t    constructor(renderer, block, parent, node, strip_whitespace, next_sibling) {\n\t        super(renderer, block, parent, node);\n\t        this.slots = new Map();\n\t        this.cannot_use_innerhtml();\n\t        this.not_static_content();\n\t        if (this.node.expression) {\n\t            block.add_dependencies(this.node.expression.dependencies);\n\t        }\n\t        this.node.attributes.forEach(attr => {\n\t            block.add_dependencies(attr.dependencies);\n\t        });\n\t        this.node.bindings.forEach(binding => {\n\t            if (binding.is_contextual) {\n\t                mark_each_block_bindings(this, binding);\n\t            }\n\t            block.add_dependencies(binding.expression.dependencies);\n\t        });\n\t        this.node.handlers.forEach(handler => {\n\t            if (handler.expression) {\n\t                block.add_dependencies(handler.expression.dependencies);\n\t            }\n\t        });\n\t        this.var = {\n\t            type: 'Identifier',\n\t            name: (this.node.name === 'svelte:self' ? renderer.component.name.name :\n\t                this.node.name === 'svelte:component' ? 'switch_instance' :\n\t                    sanitize(this.node.name)).toLowerCase()\n\t        };\n\t        if (this.node.children.length) {\n\t            this.node.lets.forEach(l => {\n\t                extract_names(l.value || l.name).forEach(name => {\n\t                    renderer.add_to_context(name, true);\n\t                });\n\t            });\n\t            const default_slot = block.child({\n\t                comment: create_debugging_comment(node, renderer.component),\n\t                name: renderer.component.get_unique_name(`create_default_slot`),\n\t                type: 'slot'\n\t            });\n\t            this.renderer.blocks.push(default_slot);\n\t            this.slots.set('default', get_slot_definition(default_slot, this.node.scope, this.node.lets));\n\t            this.fragment = new FragmentWrapper(renderer, default_slot, node.children, this, strip_whitespace, next_sibling);\n\t            const dependencies = new Set();\n\t            // TODO is this filtering necessary? (I *think* so)\n\t            default_slot.dependencies.forEach(name => {\n\t                if (!this.node.scope.is_let(name)) {\n\t                    dependencies.add(name);\n\t                }\n\t            });\n\t            block.add_dependencies(dependencies);\n\t        }\n\t        block.add_outro();\n\t    }\n\t    warn_if_reactive() {\n\t        const { name } = this.node;\n\t        const variable = this.renderer.component.var_lookup.get(name);\n\t        if (!variable) {\n\t            return;\n\t        }\n\t        if (variable.reassigned || variable.export_name || variable.is_reactive_dependency) {\n\t            this.renderer.component.warn(this.node, {\n\t                code: 'reactive-component',\n\t                message: `<${name}/> will not be reactive if ${name} changes. Use <svelte:component this={${name}}/> if you want this reactivity.`,\n\t            });\n\t        }\n\t    }\n\t    render(block, parent_node, parent_nodes) {\n\t        this.warn_if_reactive();\n\t        const { renderer } = this;\n\t        const { component } = renderer;\n\t        const name = this.var;\n\t        block.add_variable(name);\n\t        const component_opts = x `{}`;\n\t        const statements = [];\n\t        const updates = [];\n\t        if (this.fragment) {\n\t            this.renderer.add_to_context('$$scope', true);\n\t            const default_slot = this.slots.get('default');\n\t            this.fragment.nodes.forEach((child) => {\n\t                child.render(default_slot.block, null, x `#nodes`);\n\t            });\n\t        }\n\t        let props;\n\t        const name_changes = block.get_unique_name(`${name.name}_changes`);\n\t        const uses_spread = !!this.node.attributes.find(a => a.is_spread);\n\t        // removing empty slot\n\t        for (const slot of this.slots.keys()) {\n\t            if (!this.slots.get(slot).block.has_content()) {\n\t                this.renderer.remove_block(this.slots.get(slot).block);\n\t                this.slots.delete(slot);\n\t            }\n\t        }\n\t        const initial_props = this.slots.size > 0\n\t            ? [\n\t                p `$$slots: {\n\t\t\t\t\t${Array.from(this.slots).map(([name, slot]) => {\n                    return p `${name}: [${slot.block.name}, ${slot.get_context || null}, ${slot.get_changes || null}]`;\n                })}\n\t\t\t\t}`,\n\t                p `$$scope: {\n\t\t\t\t\tctx: #ctx\n\t\t\t\t}`\n\t            ]\n\t            : [];\n\t        const attribute_object = uses_spread\n\t            ? x `{ ${initial_props} }`\n\t            : x `{\n\t\t\t\t${this.node.attributes.map(attr => p `${attr.name}: ${attr.get_value(block)}`)},\n\t\t\t\t${initial_props}\n\t\t\t}`;\n\t        if (this.node.attributes.length || this.node.bindings.length || initial_props.length) {\n\t            if (!uses_spread && this.node.bindings.length === 0) {\n\t                component_opts.properties.push(p `props: ${attribute_object}`);\n\t            }\n\t            else {\n\t                props = block.get_unique_name(`${name.name}_props`);\n\t                component_opts.properties.push(p `props: ${props}`);\n\t            }\n\t        }\n\t        if (component.compile_options.dev) {\n\t            // TODO this is a terrible hack, but without it the component\n\t            // will complain that options.target is missing. This would\n\t            // work better if components had separate public and private\n\t            // APIs\n\t            component_opts.properties.push(p `$$inline: true`);\n\t        }\n\t        const fragment_dependencies = new Set(this.fragment ? ['$$scope'] : []);\n\t        this.slots.forEach(slot => {\n\t            slot.block.dependencies.forEach(name => {\n\t                const is_let = slot.scope.is_let(name);\n\t                const variable = renderer.component.var_lookup.get(name);\n\t                if (is_let || is_dynamic$1(variable))\n\t                    fragment_dependencies.add(name);\n\t            });\n\t        });\n\t        const dynamic_attributes = this.node.attributes.filter(a => a.get_dependencies().length > 0);\n\t        if (!uses_spread && (dynamic_attributes.length > 0 || this.node.bindings.length > 0 || fragment_dependencies.size > 0)) {\n\t            updates.push(b `const ${name_changes} = {};`);\n\t        }\n\t        if (this.node.attributes.length) {\n\t            if (uses_spread) {\n\t                const levels = block.get_unique_name(`${this.var.name}_spread_levels`);\n\t                const initial_props = [];\n\t                const changes = [];\n\t                const all_dependencies = new Set();\n\t                this.node.attributes.forEach(attr => {\n\t                    add_to_set(all_dependencies, attr.dependencies);\n\t                });\n\t                this.node.attributes.forEach((attr, i) => {\n\t                    const { name, dependencies } = attr;\n\t                    const condition = dependencies.size > 0 && (dependencies.size !== all_dependencies.size)\n\t                        ? renderer.dirty(Array.from(dependencies))\n\t                        : null;\n\t                    const unchanged = dependencies.size === 0;\n\t                    let change_object;\n\t                    if (attr.is_spread) {\n\t                        const value = attr.expression.manipulate(block);\n\t                        initial_props.push(value);\n\t                        let value_object = value;\n\t                        if (attr.expression.node.type !== 'ObjectExpression') {\n\t                            value_object = x `@get_spread_object(${value})`;\n\t                        }\n\t                        change_object = value_object;\n\t                    }\n\t                    else {\n\t                        const obj = x `{ ${name}: ${attr.get_value(block)} }`;\n\t                        initial_props.push(obj);\n\t                        change_object = obj;\n\t                    }\n\t                    changes.push(unchanged\n\t                        ? x `${levels}[${i}]`\n\t                        : condition\n\t                            ? x `${condition} && ${change_object}`\n\t                            : change_object);\n\t                });\n\t                block.chunks.init.push(b `\n\t\t\t\t\tconst ${levels} = [\n\t\t\t\t\t\t${initial_props}\n\t\t\t\t\t];\n\t\t\t\t`);\n\t                statements.push(b `\n\t\t\t\t\tfor (let #i = 0; #i < ${levels}.length; #i += 1) {\n\t\t\t\t\t\t${props} = @assign(${props}, ${levels}[#i]);\n\t\t\t\t\t}\n\t\t\t\t`);\n\t                if (all_dependencies.size) {\n\t                    const condition = renderer.dirty(Array.from(all_dependencies));\n\t                    updates.push(b `\n\t\t\t\t\t\tconst ${name_changes} = ${condition} ? @get_spread_update(${levels}, [\n\t\t\t\t\t\t\t${changes}\n\t\t\t\t\t\t]) : {}\n\t\t\t\t\t`);\n\t                }\n\t                else {\n\t                    updates.push(b `\n\t\t\t\t\t\tconst ${name_changes} = {};\n\t\t\t\t\t`);\n\t                }\n\t            }\n\t            else {\n\t                dynamic_attributes.forEach((attribute) => {\n\t                    const dependencies = attribute.get_dependencies();\n\t                    if (dependencies.length > 0) {\n\t                        const condition = renderer.dirty(dependencies);\n\t                        updates.push(b `\n\t\t\t\t\t\t\tif (${condition}) ${name_changes}.${attribute.name} = ${attribute.get_value(block)};\n\t\t\t\t\t\t`);\n\t                    }\n\t                });\n\t            }\n\t        }\n\t        if (fragment_dependencies.size > 0) {\n\t            updates.push(b `\n\t\t\t\tif (${renderer.dirty(Array.from(fragment_dependencies))}) {\n\t\t\t\t\t${name_changes}.$$scope = { dirty: #dirty, ctx: #ctx };\n\t\t\t\t}`);\n\t        }\n\t        const munged_bindings = this.node.bindings.map(binding => {\n\t            component.has_reactive_assignments = true;\n\t            if (binding.name === 'this') {\n\t                return bind_this(component, block, new BindingWrapper(block, binding, this), this.var);\n\t            }\n\t            const id = component.get_unique_name(`${this.var.name}_${binding.name}_binding`);\n\t            renderer.add_to_context(id.name);\n\t            const callee = renderer.reference(id);\n\t            const updating = block.get_unique_name(`updating_${binding.name}`);\n\t            block.add_variable(updating);\n\t            const snippet = binding.expression.manipulate(block);\n\t            statements.push(b `\n\t\t\t\tif (${snippet} !== void 0) {\n\t\t\t\t\t${props}.${binding.name} = ${snippet};\n\t\t\t\t}`);\n\t            updates.push(b `\n\t\t\t\tif (!${updating} && ${renderer.dirty(Array.from(binding.expression.dependencies))}) {\n\t\t\t\t\t${updating} = true;\n\t\t\t\t\t${name_changes}.${binding.name} = ${snippet};\n\t\t\t\t\t@add_flush_callback(() => ${updating} = false);\n\t\t\t\t}\n\t\t\t`);\n\t            const contextual_dependencies = Array.from(binding.expression.contextual_dependencies);\n\t            const dependencies = Array.from(binding.expression.dependencies);\n\t            let lhs = binding.raw_expression;\n\t            if (binding.is_contextual && binding.expression.node.type === 'Identifier') {\n\t                // bind:x={y} \u2014 we can't just do `y = x`, we need to\n\t                // to `array[index] = x;\n\t                const { name } = binding.expression.node;\n\t                const { object, property, snippet } = block.bindings.get(name);\n\t                lhs = snippet;\n\t                contextual_dependencies.push(object.name, property.name);\n\t            }\n\t            const params = [x `#value`];\n\t            if (contextual_dependencies.length > 0) {\n\t                const args = [];\n\t                contextual_dependencies.forEach(name => {\n\t                    params.push({\n\t                        type: 'Identifier',\n\t                        name\n\t                    });\n\t                    renderer.add_to_context(name, true);\n\t                    args.push(renderer.reference(name));\n\t                });\n\t                block.chunks.init.push(b `\n\t\t\t\t\tfunction ${id}(#value) {\n\t\t\t\t\t\t${callee}.call(null, #value, ${args});\n\t\t\t\t\t}\n\t\t\t\t`);\n\t                block.maintain_context = true; // TODO put this somewhere more logical\n\t            }\n\t            else {\n\t                block.chunks.init.push(b `\n\t\t\t\t\tfunction ${id}(#value) {\n\t\t\t\t\t\t${callee}.call(null, #value);\n\t\t\t\t\t}\n\t\t\t\t`);\n\t            }\n\t            const body = b `\n\t\t\t\tfunction ${id}(${params}) {\n\t\t\t\t\t${lhs} = #value;\n\t\t\t\t\t${renderer.invalidate(dependencies[0])};\n\t\t\t\t}\n\t\t\t`;\n\t            component.partly_hoisted.push(body);\n\t            return b `@binding_callbacks.push(() => @bind(${this.var}, '${binding.name}', ${id}));`;\n\t        });\n\t        const munged_handlers = this.node.handlers.map(handler => {\n\t            const event_handler = new EventHandlerWrapper(handler, this);\n\t            let snippet = event_handler.get_snippet(block);\n\t            if (handler.modifiers.has('once'))\n\t                snippet = x `@once(${snippet})`;\n\t            return b `${name}.$on(\"${handler.name}\", ${snippet});`;\n\t        });\n\t        if (this.node.name === 'svelte:component') {\n\t            const switch_value = block.get_unique_name('switch_value');\n\t            const switch_props = block.get_unique_name('switch_props');\n\t            const snippet = this.node.expression.manipulate(block);\n\t            block.chunks.init.push(b `\n\t\t\t\tvar ${switch_value} = ${snippet};\n\n\t\t\t\tfunction ${switch_props}(#ctx) {\n\t\t\t\t\t${(this.node.attributes.length > 0 || this.node.bindings.length > 0) && b `\n\t\t\t\t\t${props && b `let ${props} = ${attribute_object};`}`}\n\t\t\t\t\t${statements}\n\t\t\t\t\treturn ${component_opts};\n\t\t\t\t}\n\n\t\t\t\tif (${switch_value}) {\n\t\t\t\t\t${name} = new ${switch_value}(${switch_props}(#ctx));\n\n\t\t\t\t\t${munged_bindings}\n\t\t\t\t\t${munged_handlers}\n\t\t\t\t}\n\t\t\t`);\n\t            block.chunks.create.push(b `if (${name}) @create_component(${name}.$$.fragment);`);\n\t            if (parent_nodes && this.renderer.options.hydratable) {\n\t                block.chunks.claim.push(b `if (${name}) @claim_component(${name}.$$.fragment, ${parent_nodes});`);\n\t            }\n\t            block.chunks.mount.push(b `\n\t\t\t\tif (${name}) {\n\t\t\t\t\t@mount_component(${name}, ${parent_node || '#target'}, ${parent_node ? 'null' : '#anchor'});\n\t\t\t\t}\n\t\t\t`);\n\t            const anchor = this.get_or_create_anchor(block, parent_node, parent_nodes);\n\t            const update_mount_node = this.get_update_mount_node(anchor);\n\t            if (updates.length) {\n\t                block.chunks.update.push(b `\n\t\t\t\t\t${updates}\n\t\t\t\t`);\n\t            }\n\t            block.chunks.update.push(b `\n\t\t\t\tif (${switch_value} !== (${switch_value} = ${snippet})) {\n\t\t\t\t\tif (${name}) {\n\t\t\t\t\t\t@group_outros();\n\t\t\t\t\t\tconst old_component = ${name};\n\t\t\t\t\t\t@transition_out(old_component.$$.fragment, 1, 0, () => {\n\t\t\t\t\t\t\t@destroy_component(old_component, 1);\n\t\t\t\t\t\t});\n\t\t\t\t\t\t@check_outros();\n\t\t\t\t\t}\n\n\t\t\t\t\tif (${switch_value}) {\n\t\t\t\t\t\t${name} = new ${switch_value}(${switch_props}(#ctx));\n\n\t\t\t\t\t\t${munged_bindings}\n\t\t\t\t\t\t${munged_handlers}\n\n\t\t\t\t\t\t@create_component(${name}.$$.fragment);\n\t\t\t\t\t\t@transition_in(${name}.$$.fragment, 1);\n\t\t\t\t\t\t@mount_component(${name}, ${update_mount_node}, ${anchor});\n\t\t\t\t\t} else {\n\t\t\t\t\t\t${name} = null;\n\t\t\t\t\t}\n\t\t\t\t} else if (${switch_value}) {\n\t\t\t\t\t${updates.length && b `${name}.$set(${name_changes});`}\n\t\t\t\t}\n\t\t\t`);\n\t            block.chunks.intro.push(b `\n\t\t\t\tif (${name}) @transition_in(${name}.$$.fragment, #local);\n\t\t\t`);\n\t            block.chunks.outro.push(b `if (${name}) @transition_out(${name}.$$.fragment, #local);`);\n\t            block.chunks.destroy.push(b `if (${name}) @destroy_component(${name}, ${parent_node ? null : 'detaching'});`);\n\t        }\n\t        else {\n\t            const expression = this.node.name === 'svelte:self'\n\t                ? component.name\n\t                : this.renderer.reference(this.node.name);\n\t            block.chunks.init.push(b `\n\t\t\t\t${(this.node.attributes.length > 0 || this.node.bindings.length > 0) && b `\n\t\t\t\t${props && b `let ${props} = ${attribute_object};`}`}\n\t\t\t\t${statements}\n\t\t\t\t${name} = new ${expression}(${component_opts});\n\n\t\t\t\t${munged_bindings}\n\t\t\t\t${munged_handlers}\n\t\t\t`);\n\t            block.chunks.create.push(b `@create_component(${name}.$$.fragment);`);\n\t            if (parent_nodes && this.renderer.options.hydratable) {\n\t                block.chunks.claim.push(b `@claim_component(${name}.$$.fragment, ${parent_nodes});`);\n\t            }\n\t            block.chunks.mount.push(b `@mount_component(${name}, ${parent_node || '#target'}, ${parent_node ? 'null' : '#anchor'});`);\n\t            block.chunks.intro.push(b `\n\t\t\t\t@transition_in(${name}.$$.fragment, #local);\n\t\t\t`);\n\t            if (updates.length) {\n\t                block.chunks.update.push(b `\n\t\t\t\t\t${updates}\n\t\t\t\t\t${name}.$set(${name_changes});\n\t\t\t\t`);\n\t            }\n\t            block.chunks.destroy.push(b `\n\t\t\t\t@destroy_component(${name}, ${parent_node ? null : 'detaching'});\n\t\t\t`);\n\t            block.chunks.outro.push(b `@transition_out(${name}.$$.fragment, #local);`);\n\t        }\n\t    }\n\t}\n\n\tfunction get_slot_data(values, block = null) {\n\t    return {\n\t        type: 'ObjectExpression',\n\t        properties: Array.from(values.values())\n\t            .filter(attribute => attribute.name !== 'name')\n\t            .map(attribute => {\n\t            const value = get_value(block, attribute);\n\t            return p `${attribute.name}: ${value}`;\n\t        })\n\t    };\n\t}\n\tfunction get_value(block, attribute) {\n\t    if (attribute.is_true)\n\t        return x `true`;\n\t    if (attribute.chunks.length === 0)\n\t        return x `\"\"`;\n\t    let value = attribute.chunks\n\t        .map(chunk => chunk.type === 'Text' ? string_literal(chunk.data) : (block ? chunk.manipulate(block) : chunk.node))\n\t        .reduce((lhs, rhs) => x `${lhs} + ${rhs}`);\n\t    if (attribute.chunks.length > 1 && attribute.chunks[0].type !== 'Text') {\n\t        value = x `\"\" + ${value}`;\n\t    }\n\t    return value;\n\t}\n\n\tclass SlotWrapper extends Wrapper {\n\t    constructor(renderer, block, parent, node, strip_whitespace, next_sibling) {\n\t        super(renderer, block, parent, node);\n\t        this.fallback = null;\n\t        this.var = { type: 'Identifier', name: 'slot' };\n\t        this.dependencies = new Set(['$$scope']);\n\t        this.cannot_use_innerhtml();\n\t        this.not_static_content();\n\t        if (this.node.children.length) {\n\t            this.fallback = block.child({\n\t                comment: create_debugging_comment(this.node.children[0], this.renderer.component),\n\t                name: this.renderer.component.get_unique_name(`fallback_block`),\n\t                type: 'fallback'\n\t            });\n\t            renderer.blocks.push(this.fallback);\n\t        }\n\t        this.fragment = new FragmentWrapper(renderer, this.fallback, node.children, this, strip_whitespace, next_sibling);\n\t        this.node.values.forEach(attribute => {\n\t            add_to_set(this.dependencies, attribute.dependencies);\n\t        });\n\t        block.add_dependencies(this.dependencies);\n\t        // we have to do this, just in case\n\t        block.add_intro();\n\t        block.add_outro();\n\t    }\n\t    render(block, parent_node, parent_nodes) {\n\t        const { renderer } = this;\n\t        const { slot_name } = this.node;\n\t        let get_slot_changes_fn;\n\t        let get_slot_context_fn;\n\t        if (this.node.values.size > 0) {\n\t            get_slot_changes_fn = renderer.component.get_unique_name(`get_${sanitize(slot_name)}_slot_changes`);\n\t            get_slot_context_fn = renderer.component.get_unique_name(`get_${sanitize(slot_name)}_slot_context`);\n\t            const changes = x `{}`;\n\t            const dependencies = new Set();\n\t            this.node.values.forEach(attribute => {\n\t                attribute.chunks.forEach(chunk => {\n\t                    if (chunk.dependencies) {\n\t                        add_to_set(dependencies, chunk.contextual_dependencies);\n\t                        // add_to_set(dependencies, (chunk as Expression).dependencies);\n\t                        chunk.dependencies.forEach(name => {\n\t                            const variable = renderer.component.var_lookup.get(name);\n\t                            if (variable && !variable.hoistable)\n\t                                dependencies.add(name);\n\t                        });\n\t                    }\n\t                });\n\t                const dynamic_dependencies = Array.from(attribute.dependencies).filter(name => {\n\t                    if (this.node.scope.is_let(name))\n\t                        return true;\n\t                    const variable = renderer.component.var_lookup.get(name);\n\t                    return is_dynamic$1(variable);\n\t                });\n\t                if (dynamic_dependencies.length > 0) {\n\t                    changes.properties.push(p `${attribute.name}: ${renderer.dirty(dynamic_dependencies)}`);\n\t                }\n\t            });\n\t            renderer.blocks.push(b `\n\t\t\t\tconst ${get_slot_changes_fn} = #dirty => ${changes};\n\t\t\t\tconst ${get_slot_context_fn} = #ctx => ${get_slot_data(this.node.values, block)};\n\t\t\t`);\n\t        }\n\t        else {\n\t            get_slot_changes_fn = 'null';\n\t            get_slot_context_fn = 'null';\n\t        }\n\t        let has_fallback = !!this.fallback;\n\t        if (this.fallback) {\n\t            this.fragment.render(this.fallback, null, x `#nodes`);\n\t            has_fallback = this.fallback.has_content();\n\t            if (!has_fallback) {\n\t                renderer.remove_block(this.fallback);\n\t            }\n\t        }\n\t        const slot = block.get_unique_name(`${sanitize(slot_name)}_slot`);\n\t        const slot_definition = block.get_unique_name(`${sanitize(slot_name)}_slot_template`);\n\t        const slot_or_fallback = has_fallback ? block.get_unique_name(`${sanitize(slot_name)}_slot_or_fallback`) : slot;\n\t        block.chunks.init.push(b `\n\t\t\tconst ${slot_definition} = ${renderer.reference('$$slots')}.${slot_name};\n\t\t\tconst ${slot} = @create_slot(${slot_definition}, #ctx, ${renderer.reference('$$scope')}, ${get_slot_context_fn});\n\t\t\t${has_fallback ? b `const ${slot_or_fallback} = ${slot} || ${this.fallback.name}(#ctx);` : null}\n\t\t`);\n\t        block.chunks.create.push(b `if (${slot_or_fallback}) ${slot_or_fallback}.c();`);\n\t        if (renderer.options.hydratable) {\n\t            block.chunks.claim.push(b `if (${slot_or_fallback}) ${slot_or_fallback}.l(${parent_nodes});`);\n\t        }\n\t        block.chunks.mount.push(b `\n\t\t\tif (${slot_or_fallback}) {\n\t\t\t\t${slot_or_fallback}.m(${parent_node || '#target'}, ${parent_node ? 'null' : '#anchor'});\n\t\t\t}\n\t\t`);\n\t        block.chunks.intro.push(b `@transition_in(${slot_or_fallback}, #local);`);\n\t        block.chunks.outro.push(b `@transition_out(${slot_or_fallback}, #local);`);\n\t        const is_dependency_dynamic = name => {\n\t            if (name === '$$scope')\n\t                return true;\n\t            if (this.node.scope.is_let(name))\n\t                return true;\n\t            const variable = renderer.component.var_lookup.get(name);\n\t            return is_dynamic$1(variable);\n\t        };\n\t        const dynamic_dependencies = Array.from(this.dependencies).filter(is_dependency_dynamic);\n\t        const fallback_dynamic_dependencies = has_fallback\n\t            ? Array.from(this.fallback.dependencies).filter(is_dependency_dynamic)\n\t            : [];\n\t        const slot_update = b `\n\t\t\tif (${slot}.p && ${renderer.dirty(dynamic_dependencies)}) {\n\t\t\t\t@update_slot(${slot}, ${slot_definition}, #ctx, ${renderer.reference('$$scope')}, #dirty, ${get_slot_changes_fn}, ${get_slot_context_fn});\n\t\t\t}\n\t\t`;\n\t        const fallback_update = has_fallback && fallback_dynamic_dependencies.length > 0 && b `\n\t\t\tif (${slot_or_fallback} && ${slot_or_fallback}.p && ${renderer.dirty(fallback_dynamic_dependencies)}) {\n\t\t\t\t${slot_or_fallback}.p(#ctx, #dirty);\n\t\t\t}\n\t\t`;\n\t        if (fallback_update) {\n\t            block.chunks.update.push(b `\n\t\t\t\tif (${slot}) {\n\t\t\t\t\t${slot_update}\n\t\t\t\t} else {\n\t\t\t\t\t${fallback_update}\n\t\t\t\t}\n\t\t\t`);\n\t        }\n\t        else {\n\t            block.chunks.update.push(b `\n\t\t\t\tif (${slot}) {\n\t\t\t\t\t${slot_update}\n\t\t\t\t}\n\t\t\t`);\n\t        }\n\t        block.chunks.destroy.push(b `if (${slot_or_fallback}) ${slot_or_fallback}.d(detaching);`);\n\t    }\n\t}\n\n\tclass TitleWrapper extends Wrapper {\n\t    constructor(renderer, block, parent, node, _strip_whitespace, _next_sibling) {\n\t        super(renderer, block, parent, node);\n\t    }\n\t    render(block, _parent_node, _parent_nodes) {\n\t        const is_dynamic = !!this.node.children.find(node => node.type !== 'Text');\n\t        if (is_dynamic) {\n\t            let value;\n\t            const all_dependencies = new Set();\n\t            // TODO some of this code is repeated in Tag.ts \u2014 would be good to\n\t            // DRY it out if that's possible without introducing crazy indirection\n\t            if (this.node.children.length === 1) {\n\t                // single {tag} \u2014 may be a non-string\n\t                // @ts-ignore todo: check this\n\t                const { expression } = this.node.children[0];\n\t                value = expression.manipulate(block);\n\t                add_to_set(all_dependencies, expression.dependencies);\n\t            }\n\t            else {\n\t                // '{foo} {bar}' \u2014 treat as string concatenation\n\t                value = this.node.children\n\t                    .map(chunk => {\n\t                    if (chunk.type === 'Text')\n\t                        return string_literal(chunk.data);\n\t                    chunk.expression.dependencies.forEach(d => {\n\t                        all_dependencies.add(d);\n\t                    });\n\t                    return chunk.expression.manipulate(block);\n\t                })\n\t                    .reduce((lhs, rhs) => x `${lhs} + ${rhs}`);\n\t                if (this.node.children[0].type !== 'Text') {\n\t                    value = x `\"\" + ${value}`;\n\t                }\n\t            }\n\t            const last = this.node.should_cache && block.get_unique_name(`title_value`);\n\t            if (this.node.should_cache)\n\t                block.add_variable(last);\n\t            const init = this.node.should_cache ? x `${last} = ${value}` : value;\n\t            block.chunks.init.push(b `@_document.title = ${init};`);\n\t            const updater = b `@_document.title = ${this.node.should_cache ? last : value};`;\n\t            if (all_dependencies.size) {\n\t                const dependencies = Array.from(all_dependencies);\n\t                let condition = block.renderer.dirty(dependencies);\n\t                if (block.has_outros) {\n\t                    condition = x `!#current || ${condition}`;\n\t                }\n\t                if (this.node.should_cache) {\n\t                    condition = x `${condition} && (${last} !== (${last} = ${value}))`;\n\t                }\n\t                block.chunks.update.push(b `\n\t\t\t\t\tif (${condition}) {\n\t\t\t\t\t\t${updater}\n\t\t\t\t\t}`);\n\t            }\n\t        }\n\t        else {\n\t            const value = this.node.children.length > 0\n\t                ? string_literal(this.node.children[0].data)\n\t                : x `\"\"`;\n\t            block.chunks.hydrate.push(b `@_document.title = ${value};`);\n\t        }\n\t    }\n\t}\n\n\tconst associated_events = {\n\t    innerWidth: 'resize',\n\t    innerHeight: 'resize',\n\t    outerWidth: 'resize',\n\t    outerHeight: 'resize',\n\t    scrollX: 'scroll',\n\t    scrollY: 'scroll',\n\t};\n\tconst properties = {\n\t    scrollX: 'pageXOffset',\n\t    scrollY: 'pageYOffset'\n\t};\n\tconst readonly = new Set([\n\t    'innerWidth',\n\t    'innerHeight',\n\t    'outerWidth',\n\t    'outerHeight',\n\t    'online',\n\t]);\n\tclass WindowWrapper extends Wrapper {\n\t    constructor(renderer, block, parent, node) {\n\t        super(renderer, block, parent, node);\n\t        this.handlers = this.node.handlers.map(handler => new EventHandlerWrapper(handler, this));\n\t    }\n\t    render(block, _parent_node, _parent_nodes) {\n\t        const { renderer } = this;\n\t        const { component } = renderer;\n\t        const events = {};\n\t        const bindings = {};\n\t        add_actions(block, '@_window', this.node.actions);\n\t        add_event_handlers(block, '@_window', this.handlers);\n\t        this.node.bindings.forEach(binding => {\n\t            // in dev mode, throw if read-only values are written to\n\t            if (readonly.has(binding.name)) {\n\t                renderer.readonly.add(binding.expression.node.name);\n\t            }\n\t            bindings[binding.name] = binding.expression.node.name;\n\t            // bind:online is a special case, we need to listen for two separate events\n\t            if (binding.name === 'online')\n\t                return;\n\t            const associated_event = associated_events[binding.name];\n\t            const property = properties[binding.name] || binding.name;\n\t            if (!events[associated_event])\n\t                events[associated_event] = [];\n\t            events[associated_event].push({\n\t                name: binding.expression.node.name,\n\t                value: property\n\t            });\n\t        });\n\t        const scrolling = block.get_unique_name(`scrolling`);\n\t        const clear_scrolling = block.get_unique_name(`clear_scrolling`);\n\t        const scrolling_timeout = block.get_unique_name(`scrolling_timeout`);\n\t        Object.keys(events).forEach(event => {\n\t            const id = block.get_unique_name(`onwindow${event}`);\n\t            const props = events[event];\n\t            renderer.add_to_context(id.name);\n\t            const fn = renderer.reference(id.name);\n\t            if (event === 'scroll') {\n\t                // TODO other bidirectional bindings...\n\t                block.add_variable(scrolling, x `false`);\n\t                block.add_variable(clear_scrolling, x `() => { ${scrolling} = false }`);\n\t                block.add_variable(scrolling_timeout);\n\t                const condition = bindings.scrollX && bindings.scrollY\n\t                    ? x `\"${bindings.scrollX}\" in this._state || \"${bindings.scrollY}\" in this._state`\n\t                    : x `\"${bindings.scrollX || bindings.scrollY}\" in this._state`;\n\t                const scrollX = bindings.scrollX && x `this._state.${bindings.scrollX}`;\n\t                const scrollY = bindings.scrollY && x `this._state.${bindings.scrollY}`;\n\t                renderer.meta_bindings.push(b `\n\t\t\t\t\tif (${condition}) {\n\t\t\t\t\t\t@_scrollTo(${scrollX || '@_window.pageXOffset'}, ${scrollY || '@_window.pageYOffset'});\n\t\t\t\t\t}\n\t\t\t\t\t${scrollX && `${scrollX} = @_window.pageXOffset;`}\n\t\t\t\t\t${scrollY && `${scrollY} = @_window.pageYOffset;`}\n\t\t\t\t`);\n\t                block.event_listeners.push(x `\n\t\t\t\t\t@listen(@_window, \"${event}\", () => {\n\t\t\t\t\t\t${scrolling} = true;\n\t\t\t\t\t\t@_clearTimeout(${scrolling_timeout});\n\t\t\t\t\t\t${scrolling_timeout} = @_setTimeout(${clear_scrolling}, 100);\n\t\t\t\t\t\t${fn}();\n\t\t\t\t\t})\n\t\t\t\t`);\n\t            }\n\t            else {\n\t                props.forEach(prop => {\n\t                    renderer.meta_bindings.push(b `this._state.${prop.name} = @_window.${prop.value};`);\n\t                });\n\t                block.event_listeners.push(x `\n\t\t\t\t\t@listen(@_window, \"${event}\", ${fn})\n\t\t\t\t`);\n\t            }\n\t            component.partly_hoisted.push(b `\n\t\t\t\tfunction ${id}() {\n\t\t\t\t\t${props.map(prop => renderer.invalidate(prop.name, x `${prop.name} = @_window.${prop.value}`))}\n\t\t\t\t}\n\t\t\t`);\n\t            block.chunks.init.push(b `\n\t\t\t\t@add_render_callback(${fn});\n\t\t\t`);\n\t            component.has_reactive_assignments = true;\n\t        });\n\t        // special case... might need to abstract this out if we add more special cases\n\t        if (bindings.scrollX || bindings.scrollY) {\n\t            const condition = renderer.dirty([bindings.scrollX, bindings.scrollY].filter(Boolean));\n\t            const scrollX = bindings.scrollX ? renderer.reference(bindings.scrollX) : x `@_window.pageXOffset`;\n\t            const scrollY = bindings.scrollY ? renderer.reference(bindings.scrollY) : x `@_window.pageYOffset`;\n\t            block.chunks.update.push(b `\n\t\t\t\tif (${condition} && !${scrolling}) {\n\t\t\t\t\t${scrolling} = true;\n\t\t\t\t\t@_clearTimeout(${scrolling_timeout});\n\t\t\t\t\t@_scrollTo(${scrollX}, ${scrollY});\n\t\t\t\t\t${scrolling_timeout} = @_setTimeout(${clear_scrolling}, 100);\n\t\t\t\t}\n\t\t\t`);\n\t        }\n\t        // another special case. (I'm starting to think these are all special cases.)\n\t        if (bindings.online) {\n\t            const id = block.get_unique_name(`onlinestatuschanged`);\n\t            const name = bindings.online;\n\t            renderer.add_to_context(id.name);\n\t            const reference = renderer.reference(id.name);\n\t            component.partly_hoisted.push(b `\n\t\t\t\tfunction ${id}() {\n\t\t\t\t\t${renderer.invalidate(name, x `${name} = @_navigator.onLine`)}\n\t\t\t\t}\n\t\t\t`);\n\t            block.chunks.init.push(b `\n\t\t\t\t@add_render_callback(${reference});\n\t\t\t`);\n\t            block.event_listeners.push(x `@listen(@_window, \"online\", ${reference})`, x `@listen(@_window, \"offline\", ${reference})`);\n\t            component.has_reactive_assignments = true;\n\t        }\n\t    }\n\t}\n\n\tfunction link(next, prev) {\n\t    prev.next = next;\n\t    if (next)\n\t        next.prev = prev;\n\t}\n\n\tconst wrappers = {\n\t    AwaitBlock: AwaitBlockWrapper,\n\t    Body: BodyWrapper,\n\t    Comment: null,\n\t    DebugTag: DebugTagWrapper,\n\t    EachBlock: EachBlockWrapper,\n\t    Element: ElementWrapper,\n\t    Head: HeadWrapper,\n\t    IfBlock: IfBlockWrapper,\n\t    InlineComponent: InlineComponentWrapper,\n\t    MustacheTag: MustacheTagWrapper,\n\t    Options: null,\n\t    RawMustacheTag: RawMustacheTagWrapper,\n\t    Slot: SlotWrapper,\n\t    Text: TextWrapper,\n\t    Title: TitleWrapper,\n\t    Window: WindowWrapper\n\t};\n\tfunction trimmable_at(child, next_sibling) {\n\t    // Whitespace is trimmable if one of the following is true:\n\t    // The child and its sibling share a common nearest each block (not at an each block boundary)\n\t    // The next sibling's previous node is an each block\n\t    return (next_sibling.node.find_nearest(/EachBlock/) === child.find_nearest(/EachBlock/)) || next_sibling.node.prev.type === 'EachBlock';\n\t}\n\tclass FragmentWrapper {\n\t    constructor(renderer, block, nodes, parent, strip_whitespace, next_sibling) {\n\t        this.nodes = [];\n\t        let last_child;\n\t        let window_wrapper;\n\t        let i = nodes.length;\n\t        while (i--) {\n\t            const child = nodes[i];\n\t            if (!child.type) {\n\t                throw new Error(`missing type`);\n\t            }\n\t            if (!(child.type in wrappers)) {\n\t                throw new Error(`TODO implement ${child.type}`);\n\t            }\n\t            // special case \u2014 this is an easy way to remove whitespace surrounding\n\t            // <svelte:window/>. lil hacky but it works\n\t            if (child.type === 'Window') {\n\t                window_wrapper = new WindowWrapper(renderer, block, parent, child);\n\t                continue;\n\t            }\n\t            if (child.type === 'Text') {\n\t                let { data } = child;\n\t                // We want to remove trailing whitespace inside an element/component/block,\n\t                // *unless* there is no whitespace between this node and its next sibling\n\t                if (this.nodes.length === 0) {\n\t                    const should_trim = (next_sibling ? (next_sibling.node.type === 'Text' && /^\\s/.test(next_sibling.node.data) && trimmable_at(child, next_sibling)) : !child.has_ancestor('EachBlock'));\n\t                    if (should_trim) {\n\t                        data = trim_end(data);\n\t                        if (!data)\n\t                            continue;\n\t                    }\n\t                }\n\t                // glue text nodes (which could e.g. be separated by comments) together\n\t                if (last_child && last_child.node.type === 'Text') {\n\t                    last_child.data = data + last_child.data;\n\t                    continue;\n\t                }\n\t                const wrapper = new TextWrapper(renderer, block, parent, child, data);\n\t                if (wrapper.skip)\n\t                    continue;\n\t                this.nodes.unshift(wrapper);\n\t                link(last_child, last_child = wrapper);\n\t            }\n\t            else {\n\t                const Wrapper = wrappers[child.type];\n\t                if (!Wrapper)\n\t                    continue;\n\t                const wrapper = new Wrapper(renderer, block, parent, child, strip_whitespace, last_child || next_sibling);\n\t                this.nodes.unshift(wrapper);\n\t                link(last_child, last_child = wrapper);\n\t            }\n\t        }\n\t        if (strip_whitespace) {\n\t            const first = this.nodes[0];\n\t            if (first && first.node.type === 'Text') {\n\t                first.data = trim_start(first.data);\n\t                if (!first.data) {\n\t                    first.var = null;\n\t                    this.nodes.shift();\n\t                    if (this.nodes[0]) {\n\t                        this.nodes[0].prev = null;\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        if (window_wrapper) {\n\t            this.nodes.unshift(window_wrapper);\n\t            link(last_child, window_wrapper);\n\t        }\n\t    }\n\t    render(block, parent_node, parent_nodes) {\n\t        for (let i = 0; i < this.nodes.length; i += 1) {\n\t            this.nodes[i].render(block, parent_node, parent_nodes);\n\t        }\n\t    }\n\t}\n\n\tclass Renderer {\n\t    constructor(component, options) {\n\t        this.context = [];\n\t        this.initial_context = [];\n\t        this.context_lookup = new Map();\n\t        this.blocks = [];\n\t        this.readonly = new Set();\n\t        this.meta_bindings = []; // initial values for e.g. window.innerWidth, if there's a <svelte:window> meta tag\n\t        this.binding_groups = new Map();\n\t        this.component = component;\n\t        this.options = options;\n\t        this.locate = component.locate; // TODO messy\n\t        this.file_var = options.dev && this.component.get_unique_name('file');\n\t        component.vars.filter(v => !v.hoistable || (v.export_name && !v.module)).forEach(v => this.add_to_context(v.name));\n\t        // ensure store values are included in context\n\t        component.vars.filter(v => v.subscribable).forEach(v => this.add_to_context(`$${v.name}`));\n\t        reserved_keywords.forEach(keyword => {\n\t            if (component.var_lookup.has(keyword)) {\n\t                this.add_to_context(keyword);\n\t            }\n\t        });\n\t        if (component.slots.size > 0) {\n\t            this.add_to_context('$$scope');\n\t            this.add_to_context('$$slots');\n\t        }\n\t        if (this.binding_groups.size > 0) {\n\t            this.add_to_context('$$binding_groups');\n\t        }\n\t        // main block\n\t        this.block = new Block$1({\n\t            renderer: this,\n\t            name: null,\n\t            type: 'component',\n\t            key: null,\n\t            bindings: new Map(),\n\t            dependencies: new Set(),\n\t        });\n\t        this.block.has_update_method = true;\n\t        this.fragment = new FragmentWrapper(this, this.block, component.fragment.children, null, true, null);\n\t        // TODO messy\n\t        this.blocks.forEach(block => {\n\t            if (block instanceof Block$1) {\n\t                block.assign_variable_names();\n\t            }\n\t        });\n\t        this.block.assign_variable_names();\n\t        this.fragment.render(this.block, null, x `#nodes`);\n\t        this.context_overflow = this.context.length > 31;\n\t        this.context.forEach(member => {\n\t            const { variable } = member;\n\t            if (variable) {\n\t                member.priority += 2;\n\t                if (variable.mutated || variable.reassigned)\n\t                    member.priority += 4;\n\t                // these determine whether variable is included in initial context\n\t                // array, so must have the highest priority\n\t                if (variable.export_name)\n\t                    member.priority += 16;\n\t                if (variable.referenced)\n\t                    member.priority += 32;\n\t            }\n\t            else if (member.is_non_contextual) {\n\t                // determine whether variable is included in initial context\n\t                // array, so must have the highest priority\n\t                member.priority += 8;\n\t            }\n\t            if (!member.is_contextual) {\n\t                member.priority += 1;\n\t            }\n\t        });\n\t        this.context.sort((a, b) => (b.priority - a.priority) || (a.index.value - b.index.value));\n\t        this.context.forEach((member, i) => member.index.value = i);\n\t        let i = this.context.length;\n\t        while (i--) {\n\t            const member = this.context[i];\n\t            if (member.variable) {\n\t                if (member.variable.referenced || member.variable.export_name)\n\t                    break;\n\t            }\n\t            else if (member.is_non_contextual) {\n\t                break;\n\t            }\n\t        }\n\t        this.initial_context = this.context.slice(0, i + 1);\n\t    }\n\t    add_to_context(name, contextual = false) {\n\t        if (!this.context_lookup.has(name)) {\n\t            const member = {\n\t                name,\n\t                index: { type: 'Literal', value: this.context.length },\n\t                is_contextual: false,\n\t                is_non_contextual: false,\n\t                variable: null,\n\t                priority: 0\n\t            };\n\t            this.context_lookup.set(name, member);\n\t            this.context.push(member);\n\t        }\n\t        const member = this.context_lookup.get(name);\n\t        if (contextual) {\n\t            member.is_contextual = true;\n\t        }\n\t        else {\n\t            member.is_non_contextual = true;\n\t            const variable = this.component.var_lookup.get(name);\n\t            member.variable = variable;\n\t        }\n\t        return member;\n\t    }\n\t    invalidate(name, value) {\n\t        const variable = this.component.var_lookup.get(name);\n\t        const member = this.context_lookup.get(name);\n\t        if (variable && (variable.subscribable && (variable.reassigned || variable.export_name))) {\n\t            return x `${`$$subscribe_${name}`}($$invalidate(${member.index}, ${value || name}))`;\n\t        }\n\t        if (name[0] === '$' && name[1] !== '$') {\n\t            return x `${name.slice(1)}.set(${value || name})`;\n\t        }\n\t        if (variable && (variable.module || (!variable.referenced &&\n\t            !variable.is_reactive_dependency &&\n\t            !variable.export_name &&\n\t            !name.startsWith('$$')))) {\n\t            return value || name;\n\t        }\n\t        if (value) {\n\t            return x `$$invalidate(${member.index}, ${value})`;\n\t        }\n\t        // if this is a reactive declaration, invalidate dependencies recursively\n\t        const deps = new Set([name]);\n\t        deps.forEach(name => {\n\t            const reactive_declarations = this.component.reactive_declarations.filter(x => x.assignees.has(name));\n\t            reactive_declarations.forEach(declaration => {\n\t                declaration.dependencies.forEach(name => {\n\t                    deps.add(name);\n\t                });\n\t            });\n\t        });\n\t        // TODO ideally globals etc wouldn't be here in the first place\n\t        const filtered = Array.from(deps).filter(n => this.context_lookup.has(n));\n\t        if (!filtered.length)\n\t            return null;\n\t        return filtered\n\t            .map(n => x `$$invalidate(${this.context_lookup.get(n).index}, ${n})`)\n\t            .reduce((lhs, rhs) => x `${lhs}, ${rhs}`);\n\t    }\n\t    dirty(names, is_reactive_declaration = false) {\n\t        const renderer = this;\n\t        const dirty = (is_reactive_declaration\n\t            ? x `$$self.$$.dirty`\n\t            : x `#dirty`);\n\t        const get_bitmask = () => {\n\t            const bitmask = [];\n\t            names.forEach((name) => {\n\t                const member = renderer.context_lookup.get(name);\n\t                if (!member)\n\t                    return;\n\t                if (member.index.value === -1) {\n\t                    throw new Error(`unset index`);\n\t                }\n\t                const value = member.index.value;\n\t                const i = (value / 31) | 0;\n\t                const n = 1 << (value % 31);\n\t                if (!bitmask[i])\n\t                    bitmask[i] = { n: 0, names: [] };\n\t                bitmask[i].n |= n;\n\t                bitmask[i].names.push(name);\n\t            });\n\t            return bitmask;\n\t        };\n\t        // TODO: context-overflow make it less gross\n\t        return {\n\t            // Using a ParenthesizedExpression allows us to create\n\t            // the expression lazily. TODO would be better if\n\t            // context was determined before rendering, so that\n\t            // this indirection was unnecessary\n\t            type: 'ParenthesizedExpression',\n\t            get expression() {\n\t                const bitmask = get_bitmask();\n\t                if (!bitmask.length) {\n\t                    return x `${dirty} & /*${names.join(', ')}*/ 0`;\n\t                }\n\t                if (renderer.context_overflow) {\n\t                    return bitmask\n\t                        .map((b, i) => ({ b, i }))\n\t                        .filter(({ b }) => b)\n\t                        .map(({ b, i }) => x `${dirty}[${i}] & /*${b.names.join(', ')}*/ ${b.n}`)\n\t                        .reduce((lhs, rhs) => x `${lhs} | ${rhs}`);\n\t                }\n\t                return x `${dirty} & /*${names.join(', ')}*/ ${bitmask[0].n}`;\n\t            }\n\t        };\n\t    }\n\t    reference(node) {\n\t        if (typeof node === 'string') {\n\t            node = { type: 'Identifier', name: node };\n\t        }\n\t        const { name, nodes } = flatten_reference(node);\n\t        const member = this.context_lookup.get(name);\n\t        // TODO is this correct?\n\t        if (this.component.var_lookup.get(name)) {\n\t            this.component.add_reference(name);\n\t        }\n\t        if (member !== undefined) {\n\t            const replacement = x `/*${member.name}*/ #ctx[${member.index}]`;\n\t            if (nodes[0].loc)\n\t                replacement.object.loc = nodes[0].loc;\n\t            nodes[0] = replacement;\n\t            return nodes.reduce((lhs, rhs) => x `${lhs}.${rhs}`);\n\t        }\n\t        return node;\n\t    }\n\t    remove_block(block) {\n\t        this.blocks.splice(this.blocks.indexOf(block), 1);\n\t    }\n\t}\n\n\tfunction dom(component, options) {\n\t    const { name } = component;\n\t    const renderer = new Renderer(component, options);\n\t    const { block } = renderer;\n\t    block.has_outro_method = true;\n\t    // prevent fragment being created twice (#1063)\n\t    if (options.customElement)\n\t        block.chunks.create.push(b `this.c = @noop;`);\n\t    const body = [];\n\t    if (renderer.file_var) {\n\t        const file = component.file ? x `\"${component.file}\"` : x `undefined`;\n\t        body.push(b `const ${renderer.file_var} = ${file};`);\n\t    }\n\t    const css = component.stylesheet.render(options.filename, !options.customElement);\n\t    const styles = component.stylesheet.has_styles && options.dev\n\t        ? `${css.code}\\n/*# sourceMappingURL=${css.map.toUrl()} */`\n\t        : css.code;\n\t    const add_css = component.get_unique_name('add_css');\n\t    const should_add_css = (!options.customElement &&\n\t        !!styles &&\n\t        options.css !== false);\n\t    if (should_add_css) {\n\t        body.push(b `\n\t\t\tfunction ${add_css}() {\n\t\t\t\tvar style = @element(\"style\");\n\t\t\t\tstyle.id = \"${component.stylesheet.id}-style\";\n\t\t\t\tstyle.textContent = \"${styles}\";\n\t\t\t\t@append(@_document.head, style);\n\t\t\t}\n\t\t`);\n\t    }\n\t    // fix order\n\t    // TODO the deconflicted names of blocks are reversed... should set them here\n\t    const blocks = renderer.blocks.slice().reverse();\n\t    body.push(...blocks.map(block => {\n\t        // TODO this is a horrible mess \u2014 renderer.blocks\n\t        // contains a mixture of Blocks and Nodes\n\t        if (block.render)\n\t            return block.render();\n\t        return block;\n\t    }));\n\t    if (options.dev && !options.hydratable) {\n\t        block.chunks.claim.push(b `throw new @_Error(\"options.hydrate only works if the component was compiled with the \\`hydratable: true\\` option\");`);\n\t    }\n\t    const uses_props = component.var_lookup.has('$$props');\n\t    const uses_rest = component.var_lookup.has('$$restProps');\n\t    const $$props = uses_props || uses_rest ? `$$new_props` : `$$props`;\n\t    const props = component.vars.filter(variable => !variable.module && variable.export_name);\n\t    const writable_props = props.filter(variable => variable.writable);\n\t    const omit_props_names = component.get_unique_name('omit_props_names');\n\t    const compute_rest = x `@compute_rest_props($$props, ${omit_props_names.name})`;\n\t    const rest = uses_rest ? b `\n\t\tconst ${omit_props_names.name} = [${props.map(prop => `\"${prop.export_name}\"`).join(',')}];\n\t\tlet $$restProps = ${compute_rest};\n\t` : null;\n\t    const set = (uses_props || uses_rest || writable_props.length > 0 || component.slots.size > 0)\n\t        ? x `\n\t\t\t${$$props} => {\n\t\t\t\t${uses_props && renderer.invalidate('$$props', x `$$props = @assign(@assign({}, $$props), @exclude_internal_props($$new_props))`)}\n\t\t\t\t${uses_rest && !uses_props && x `$$props = @assign(@assign({}, $$props), @exclude_internal_props($$new_props))`}\n\t\t\t\t${uses_rest && renderer.invalidate('$$restProps', x `$$restProps = ${compute_rest}`)}\n\t\t\t\t${writable_props.map(prop => b `if ('${prop.export_name}' in ${$$props}) ${renderer.invalidate(prop.name, x `${prop.name} = ${$$props}.${prop.export_name}`)};`)}\n\t\t\t\t${component.slots.size > 0 &&\n            b `if ('$$scope' in ${$$props}) ${renderer.invalidate('$$scope', x `$$scope = ${$$props}.$$scope`)};`}\n\t\t\t}\n\t\t`\n\t        : null;\n\t    const accessors = [];\n\t    const not_equal = component.component_options.immutable ? x `@not_equal` : x `@safe_not_equal`;\n\t    let dev_props_check;\n\t    let inject_state;\n\t    let capture_state;\n\t    let props_inject;\n\t    props.forEach(prop => {\n\t        const variable = component.var_lookup.get(prop.name);\n\t        if (!variable.writable || component.component_options.accessors) {\n\t            accessors.push({\n\t                type: 'MethodDefinition',\n\t                kind: 'get',\n\t                key: { type: 'Identifier', name: prop.export_name },\n\t                value: x `function() {\n\t\t\t\t\treturn ${prop.hoistable ? prop.name : x `this.$$.ctx[${renderer.context_lookup.get(prop.name).index}]`}\n\t\t\t\t}`\n\t            });\n\t        }\n\t        else if (component.compile_options.dev) {\n\t            accessors.push({\n\t                type: 'MethodDefinition',\n\t                kind: 'get',\n\t                key: { type: 'Identifier', name: prop.export_name },\n\t                value: x `function() {\n\t\t\t\t\tthrow new @_Error(\"<${component.tag}>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n\t\t\t\t}`\n\t            });\n\t        }\n\t        if (component.component_options.accessors) {\n\t            if (variable.writable && !renderer.readonly.has(prop.name)) {\n\t                accessors.push({\n\t                    type: 'MethodDefinition',\n\t                    kind: 'set',\n\t                    key: { type: 'Identifier', name: prop.export_name },\n\t                    value: x `function(${prop.name}) {\n\t\t\t\t\t\tthis.$set({ ${prop.export_name}: ${prop.name} });\n\t\t\t\t\t\t@flush();\n\t\t\t\t\t}`\n\t                });\n\t            }\n\t            else if (component.compile_options.dev) {\n\t                accessors.push({\n\t                    type: 'MethodDefinition',\n\t                    kind: 'set',\n\t                    key: { type: 'Identifier', name: prop.export_name },\n\t                    value: x `function(value) {\n\t\t\t\t\t\tthrow new @_Error(\"<${component.tag}>: Cannot set read-only property '${prop.export_name}'\");\n\t\t\t\t\t}`\n\t                });\n\t            }\n\t        }\n\t        else if (component.compile_options.dev) {\n\t            accessors.push({\n\t                type: 'MethodDefinition',\n\t                kind: 'set',\n\t                key: { type: 'Identifier', name: prop.export_name },\n\t                value: x `function(value) {\n\t\t\t\t\tthrow new @_Error(\"<${component.tag}>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n\t\t\t\t}`\n\t            });\n\t        }\n\t    });\n\t    if (component.compile_options.dev) {\n\t        // checking that expected ones were passed\n\t        const expected = props.filter(prop => prop.writable && !prop.initialised);\n\t        if (expected.length) {\n\t            dev_props_check = b `\n\t\t\t\tconst { ctx: #ctx } = this.$$;\n\t\t\t\tconst props = ${options.customElement ? x `this.attributes` : x `options.props || {}`};\n\t\t\t\t${expected.map(prop => b `\n\t\t\t\tif (${renderer.reference(prop.name)} === undefined && !('${prop.export_name}' in props)) {\n\t\t\t\t\t@_console.warn(\"<${component.tag}> was created without expected prop '${prop.export_name}'\");\n\t\t\t\t}`)}\n\t\t\t`;\n\t        }\n\t        const capturable_vars = component.vars.filter(v => !v.internal && !v.global && !v.name.startsWith('$$'));\n\t        if (capturable_vars.length > 0) {\n\t            capture_state = x `() => ({ ${capturable_vars.map(prop => p `${prop.name}`)} })`;\n\t        }\n\t        const injectable_vars = capturable_vars.filter(v => !v.module && v.writable && v.name[0] !== '$');\n\t        if (uses_props || injectable_vars.length > 0) {\n\t            inject_state = x `\n\t\t\t\t${$$props} => {\n\t\t\t\t\t${uses_props && renderer.invalidate('$$props', x `$$props = @assign(@assign({}, $$props), $$new_props)`)}\n\t\t\t\t\t${injectable_vars.map(v => b `if ('${v.name}' in $$props) ${renderer.invalidate(v.name, x `${v.name} = ${$$props}.${v.name}`)};`)}\n\t\t\t\t}\n\t\t\t`;\n\t            props_inject = b `\n\t\t\t\tif ($$props && \"$$inject\" in $$props) {\n\t\t\t\t\t$$self.$inject_state($$props.$$inject);\n\t\t\t\t}\n\t\t\t`;\n\t        }\n\t    }\n\t    // instrument assignments\n\t    if (component.ast.instance) {\n\t        let scope = component.instance_scope;\n\t        const map = component.instance_scope_map;\n\t        let execution_context = null;\n\t        walk(component.ast.instance.content, {\n\t            enter(node) {\n\t                if (map.has(node)) {\n\t                    scope = map.get(node);\n\t                    if (!execution_context && !scope.block) {\n\t                        execution_context = node;\n\t                    }\n\t                }\n\t                else if (!execution_context && node.type === 'LabeledStatement' && node.label.name === '$') {\n\t                    execution_context = node;\n\t                }\n\t            },\n\t            leave(node) {\n\t                if (map.has(node)) {\n\t                    scope = scope.parent;\n\t                }\n\t                if (execution_context === node) {\n\t                    execution_context = null;\n\t                }\n\t                if (node.type === 'AssignmentExpression' || node.type === 'UpdateExpression') {\n\t                    const assignee = node.type === 'AssignmentExpression' ? node.left : node.argument;\n\t                    // normally (`a = 1`, `b.c = 2`), there'll be a single name\n\t                    // (a or b). In destructuring cases (`[d, e] = [e, d]`) there\n\t                    // may be more, in which case we need to tack the extra ones\n\t                    // onto the initial function call\n\t                    const names = new Set(extract_names(assignee));\n\t                    this.replace(invalidate(renderer, scope, node, names, execution_context === null));\n\t                }\n\t            }\n\t        });\n\t        component.rewrite_props(({ name, reassigned, export_name }) => {\n\t            const value = `$${name}`;\n\t            const i = renderer.context_lookup.get(`$${name}`).index;\n\t            const insert = (reassigned || export_name)\n\t                ? b `${`$$subscribe_${name}`}()`\n\t                : b `@component_subscribe($$self, ${name}, #value => $$invalidate(${i}, ${value} = #value))`;\n\t            if (component.compile_options.dev) {\n\t                return b `@validate_store(${name}, '${name}'); ${insert}`;\n\t            }\n\t            return insert;\n\t        });\n\t    }\n\t    const args = [x `$$self`];\n\t    const has_invalidate = props.length > 0 ||\n\t        component.has_reactive_assignments ||\n\t        component.slots.size > 0 ||\n\t        capture_state ||\n\t        inject_state;\n\t    if (has_invalidate) {\n\t        args.push(x `$$props`, x `$$invalidate`);\n\t    }\n\t    else if (component.compile_options.dev) {\n\t        // $$props arg is still needed for unknown prop check\n\t        args.push(x `$$props`);\n\t    }\n\t    const has_create_fragment = component.compile_options.dev || block.has_content();\n\t    if (has_create_fragment) {\n\t        body.push(b `\n\t\t\tfunction create_fragment(#ctx) {\n\t\t\t\t${block.get_contents()}\n\t\t\t}\n\t\t`);\n\t    }\n\t    body.push(b `\n\t\t${component.extract_javascript(component.ast.module)}\n\n\t\t${component.fully_hoisted}\n\t`);\n\t    const filtered_props = props.filter(prop => {\n\t        const variable = component.var_lookup.get(prop.name);\n\t        if (variable.hoistable)\n\t            return false;\n\t        if (prop.name[0] === '$')\n\t            return false;\n\t        return true;\n\t    });\n\t    const reactive_stores = component.vars.filter(variable => variable.name[0] === '$' && variable.name[1] !== '$');\n\t    const instance_javascript = component.extract_javascript(component.ast.instance);\n\t    const has_definition = (component.compile_options.dev ||\n\t        (instance_javascript && instance_javascript.length > 0) ||\n\t        filtered_props.length > 0 ||\n\t        uses_props ||\n\t        component.partly_hoisted.length > 0 ||\n\t        renderer.initial_context.length > 0 ||\n\t        component.reactive_declarations.length > 0 ||\n\t        capture_state ||\n\t        inject_state);\n\t    const definition = has_definition\n\t        ? component.alias('instance')\n\t        : { type: 'Literal', value: null };\n\t    const reactive_store_subscriptions = reactive_stores\n\t        .filter(store => {\n\t        const variable = component.var_lookup.get(store.name.slice(1));\n\t        return !variable || variable.hoistable;\n\t    })\n\t        .map(({ name }) => b `\n\t\t\t${component.compile_options.dev && b `@validate_store(${name.slice(1)}, '${name.slice(1)}');`}\n\t\t\t@component_subscribe($$self, ${name.slice(1)}, $$value => $$invalidate(${renderer.context_lookup.get(name).index}, ${name} = $$value));\n\t\t`);\n\t    const resubscribable_reactive_store_unsubscribers = reactive_stores\n\t        .filter(store => {\n\t        const variable = component.var_lookup.get(store.name.slice(1));\n\t        return variable && (variable.reassigned || variable.export_name);\n\t    })\n\t        .map(({ name }) => b `$$self.$$.on_destroy.push(() => ${`$$unsubscribe_${name.slice(1)}`}());`);\n\t    if (has_definition) {\n\t        const reactive_declarations = [];\n\t        const fixed_reactive_declarations = []; // not really 'reactive' but whatever\n\t        component.reactive_declarations.forEach(d => {\n\t            const dependencies = Array.from(d.dependencies);\n\t            const uses_rest_or_props = !!dependencies.find(n => n === '$$props' || n === '$$restProps');\n\t            const writable = dependencies.filter(n => {\n\t                const variable = component.var_lookup.get(n);\n\t                return variable && (variable.export_name || variable.mutated || variable.reassigned);\n\t            });\n\t            const condition = !uses_rest_or_props && writable.length > 0 && renderer.dirty(writable, true);\n\t            let statement = d.node; // TODO remove label (use d.node.body) if it's not referenced\n\t            if (condition)\n\t                statement = b `if (${condition}) { ${statement} }`[0];\n\t            if (condition || uses_rest_or_props) {\n\t                reactive_declarations.push(statement);\n\t            }\n\t            else {\n\t                fixed_reactive_declarations.push(statement);\n\t            }\n\t        });\n\t        const injected = Array.from(component.injected_reactive_declaration_vars).filter(name => {\n\t            const variable = component.var_lookup.get(name);\n\t            return variable.injected && variable.name[0] !== '$';\n\t        });\n\t        const reactive_store_declarations = reactive_stores.map(variable => {\n\t            const $name = variable.name;\n\t            const name = $name.slice(1);\n\t            const store = component.var_lookup.get(name);\n\t            if (store && (store.reassigned || store.export_name)) {\n\t                const unsubscribe = `$$unsubscribe_${name}`;\n\t                const subscribe = `$$subscribe_${name}`;\n\t                const i = renderer.context_lookup.get($name).index;\n\t                return b `let ${$name}, ${unsubscribe} = @noop, ${subscribe} = () => (${unsubscribe}(), ${unsubscribe} = @subscribe(${name}, $$value => $$invalidate(${i}, ${$name} = $$value)), ${name})`;\n\t            }\n\t            return b `let ${$name};`;\n\t        });\n\t        let unknown_props_check;\n\t        if (component.compile_options.dev && !(uses_props || uses_rest)) {\n\t            unknown_props_check = b `\n\t\t\t\tconst writable_props = [${writable_props.map(prop => x `'${prop.export_name}'`)}];\n\t\t\t\t@_Object.keys($$props).forEach(key => {\n\t\t\t\t\tif (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$') @_console.warn(\\`<${component.tag}> was created with unknown prop '\\${key}'\\`);\n\t\t\t\t});\n\t\t\t`;\n\t        }\n\t        const return_value = {\n\t            type: 'ArrayExpression',\n\t            elements: renderer.initial_context.map(member => ({\n\t                type: 'Identifier',\n\t                name: member.name\n\t            }))\n\t        };\n\t        body.push(b `\n\t\t\tfunction ${definition}(${args}) {\n\t\t\t\t${rest}\n\n\t\t\t\t${reactive_store_declarations}\n\n\t\t\t\t${reactive_store_subscriptions}\n\n\t\t\t\t${resubscribable_reactive_store_unsubscribers}\n\n\t\t\t\t${instance_javascript}\n\n\t\t\t\t${unknown_props_check}\n\n\t\t\t\t${component.slots.size || component.compile_options.dev ? b `let { $$slots = {}, $$scope } = $$props;` : null}\n\t\t\t\t${component.compile_options.dev && b `@validate_slots('${component.tag}', $$slots, [${[...component.slots.keys()].map(key => `'${key}'`).join(',')}]);`}\n\n\t\t\t\t${renderer.binding_groups.size > 0 && b `const $$binding_groups = [${[...renderer.binding_groups.keys()].map(_ => x `[]`)}];`}\n\n\t\t\t\t${component.partly_hoisted}\n\n\t\t\t\t${set && b `$$self.$set = ${set};`}\n\n\t\t\t\t${capture_state && b `$$self.$capture_state = ${capture_state};`}\n\n\t\t\t\t${inject_state && b `$$self.$inject_state = ${inject_state};`}\n\n\t\t\t\t${injected.map(name => b `let ${name};`)}\n\n\t\t\t\t${ /* before reactive declarations */props_inject}\n\n\t\t\t\t${reactive_declarations.length > 0 && b `\n\t\t\t\t$$self.$$.update = () => {\n\t\t\t\t\t${reactive_declarations}\n\t\t\t\t};\n\t\t\t\t`}\n\n\t\t\t\t${fixed_reactive_declarations}\n\n\t\t\t\t${uses_props && b `$$props = @exclude_internal_props($$props);`}\n\n\t\t\t\treturn ${return_value};\n\t\t\t}\n\t\t`);\n\t    }\n\t    const prop_indexes = x `{\n\t\t${props.filter(v => v.export_name && !v.module).map(v => p `${v.export_name}: ${renderer.context_lookup.get(v.name).index}`)}\n\t}`;\n\t    let dirty;\n\t    if (renderer.context_overflow) {\n\t        dirty = x `[]`;\n\t        for (let i = 0; i < renderer.context.length; i += 31) {\n\t            dirty.elements.push(x `-1`);\n\t        }\n\t    }\n\t    if (options.customElement) {\n\t        const declaration = b `\n\t\t\tclass ${name} extends @SvelteElement {\n\t\t\t\tconstructor(options) {\n\t\t\t\t\tsuper();\n\n\t\t\t\t\t${css.code && b `this.shadowRoot.innerHTML = \\`<style>${css.code.replace(/\\\\/g, '\\\\\\\\')}${options.dev ? `\\n/*# sourceMappingURL=${css.map.toUrl()} */` : ''}</style>\\`;`}\n\n\t\t\t\t\t@init(this, { target: this.shadowRoot }, ${definition}, ${has_create_fragment ? 'create_fragment' : 'null'}, ${not_equal}, ${prop_indexes}, ${dirty});\n\n\t\t\t\t\t${dev_props_check}\n\n\t\t\t\t\tif (options) {\n\t\t\t\t\t\tif (options.target) {\n\t\t\t\t\t\t\t@insert(options.target, this, options.anchor);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t${(props.length > 0 || uses_props || uses_rest) && b `\n\t\t\t\t\t\tif (options.props) {\n\t\t\t\t\t\t\tthis.$set(options.props);\n\t\t\t\t\t\t\t@flush();\n\t\t\t\t\t\t}`}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t`[0];\n\t        if (props.length > 0) {\n\t            declaration.body.body.push({\n\t                type: 'MethodDefinition',\n\t                kind: 'get',\n\t                static: true,\n\t                computed: false,\n\t                key: { type: 'Identifier', name: 'observedAttributes' },\n\t                value: x `function() {\n\t\t\t\t\treturn [${props.map(prop => x `\"${prop.export_name}\"`)}];\n\t\t\t\t}`\n\t            });\n\t        }\n\t        declaration.body.body.push(...accessors);\n\t        body.push(declaration);\n\t        if (component.tag != null) {\n\t            body.push(b `\n\t\t\t\t@_customElements.define(\"${component.tag}\", ${name});\n\t\t\t`);\n\t        }\n\t    }\n\t    else {\n\t        const superclass = {\n\t            type: 'Identifier',\n\t            name: options.dev ? '@SvelteComponentDev' : '@SvelteComponent'\n\t        };\n\t        const declaration = b `\n\t\t\tclass ${name} extends ${superclass} {\n\t\t\t\tconstructor(options) {\n\t\t\t\t\tsuper(${options.dev && `options`});\n\t\t\t\t\t${should_add_css && b `if (!@_document.getElementById(\"${component.stylesheet.id}-style\")) ${add_css}();`}\n\t\t\t\t\t@init(this, options, ${definition}, ${has_create_fragment ? 'create_fragment' : 'null'}, ${not_equal}, ${prop_indexes}, ${dirty});\n\t\t\t\t\t${options.dev && b `@dispatch_dev(\"SvelteRegisterComponent\", { component: this, tagName: \"${name.name}\", options, id: create_fragment.name });`}\n\n\t\t\t\t\t${dev_props_check}\n\t\t\t\t}\n\t\t\t}\n\t\t`[0];\n\t        declaration.body.body.push(...accessors);\n\t        body.push(declaration);\n\t    }\n\t    return { js: flatten$1(body, []), css };\n\t}\n\tfunction flatten$1(nodes, target) {\n\t    for (let i = 0; i < nodes.length; i += 1) {\n\t        const node = nodes[i];\n\t        if (Array.isArray(node)) {\n\t            flatten$1(node, target);\n\t        }\n\t        else {\n\t            target.push(node);\n\t        }\n\t    }\n\t    return target;\n\t}\n\n\tfunction AwaitBlock (node, renderer, options) {\n\t    renderer.push();\n\t    renderer.render(node.pending.children, options);\n\t    const pending = renderer.pop();\n\t    renderer.push();\n\t    renderer.render(node.then.children, options);\n\t    const then = renderer.pop();\n\t    renderer.add_expression(x `\n\t\tfunction(__value) {\n\t\t\tif (@is_promise(__value)) return ${pending};\n\t\t\treturn (function(${node.then_node ? node.then_node : ''}) { return ${then}; }(__value));\n\t\t}(${node.expression.node})\n\t`);\n\t}\n\n\tfunction Comment$1 (_node, _renderer, _options) {\n\t    // TODO preserve comments\n\t    // if (options.preserveComments) {\n\t    // \trenderer.append(`<!--${node.data}-->`);\n\t    // }\n\t}\n\n\tfunction DebugTag (node, renderer, options) {\n\t    if (!options.dev)\n\t        return;\n\t    const filename = options.filename || null;\n\t    const { line, column } = options.locate(node.start + 1);\n\t    const obj = x `{\n\t\t${node.expressions.map(e => p `${e.node.name}`)}\n\t}`;\n\t    renderer.add_expression(x `@debug(${filename ? x `\"${filename}\"` : x `null`}, ${line - 1}, ${column}, ${obj})`);\n\t}\n\n\tfunction EachBlock (node, renderer, options) {\n\t    const args = [node.context_node];\n\t    if (node.index)\n\t        args.push({ type: 'Identifier', name: node.index });\n\t    renderer.push();\n\t    renderer.render(node.children, options);\n\t    const result = renderer.pop();\n\t    const consequent = x `@each(${node.expression.node}, (${args}) => ${result})`;\n\t    if (node.else) {\n\t        renderer.push();\n\t        renderer.render(node.else.children, options);\n\t        const alternate = renderer.pop();\n\t        renderer.add_expression(x `${node.expression.node}.length ? ${consequent} : ${alternate}`);\n\t    }\n\t    else {\n\t        renderer.add_expression(consequent);\n\t    }\n\t}\n\n\tfunction get_class_attribute_value(attribute) {\n\t    // handle special case \u2014 `class={possiblyUndefined}` with scoped CSS\n\t    if (attribute.chunks.length === 2 && attribute.chunks[1].synthetic) {\n\t        const value = attribute.chunks[0].node;\n\t        return x `@escape(@null_to_empty(${value})) + \"${attribute.chunks[1].data}\"`;\n\t    }\n\t    return get_attribute_value(attribute);\n\t}\n\tfunction get_attribute_value(attribute) {\n\t    if (attribute.chunks.length === 0)\n\t        return x `\"\"`;\n\t    return attribute.chunks\n\t        .map((chunk) => {\n\t        return chunk.type === 'Text'\n\t            ? string_literal(chunk.data.replace(/\"/g, '&quot;'))\n\t            : x `@escape(${chunk.node})`;\n\t    })\n\t        .reduce((lhs, rhs) => x `${lhs} + ${rhs}`);\n\t}\n\n\tfunction get_slot_scope(lets) {\n\t    if (lets.length === 0)\n\t        return null;\n\t    return {\n\t        type: 'ObjectPattern',\n\t        properties: lets.map(l => {\n\t            return {\n\t                type: 'Property',\n\t                kind: 'init',\n\t                method: false,\n\t                shorthand: false,\n\t                computed: false,\n\t                key: l.name,\n\t                value: l.value || l.name\n\t            };\n\t        })\n\t    };\n\t}\n\n\t// source: https://html.spec.whatwg.org/multipage/indices.html\n\tconst boolean_attributes = new Set([\n\t    'allowfullscreen',\n\t    'allowpaymentrequest',\n\t    'async',\n\t    'autofocus',\n\t    'autoplay',\n\t    'checked',\n\t    'controls',\n\t    'default',\n\t    'defer',\n\t    'disabled',\n\t    'formnovalidate',\n\t    'hidden',\n\t    'ismap',\n\t    'loop',\n\t    'multiple',\n\t    'muted',\n\t    'nomodule',\n\t    'novalidate',\n\t    'open',\n\t    'playsinline',\n\t    'readonly',\n\t    'required',\n\t    'reversed',\n\t    'selected'\n\t]);\n\n\t// similar logic from `compile/render_dom/wrappers/Fragment`\n\t// We want to remove trailing whitespace inside an element/component/block,\n\t// *unless* there is no whitespace between this node and its next sibling\n\tfunction remove_whitespace_children(children, next) {\n\t    const nodes = [];\n\t    let last_child;\n\t    let i = children.length;\n\t    while (i--) {\n\t        const child = children[i];\n\t        if (child.type === 'Text') {\n\t            if (child.should_skip()) {\n\t                continue;\n\t            }\n\t            let { data } = child;\n\t            if (nodes.length === 0) {\n\t                const should_trim = next\n\t                    ? next.type === 'Text' &&\n\t                        /^\\s/.test(next.data) &&\n\t                        trimmable_at$1(child, next)\n\t                    : !child.has_ancestor('EachBlock');\n\t                if (should_trim) {\n\t                    data = trim_end(data);\n\t                    if (!data)\n\t                        continue;\n\t                }\n\t            }\n\t            // glue text nodes (which could e.g. be separated by comments) together\n\t            if (last_child && last_child.type === 'Text') {\n\t                last_child.data = data + last_child.data;\n\t                continue;\n\t            }\n\t            nodes.unshift(child);\n\t            link(last_child, last_child = child);\n\t        }\n\t        else {\n\t            nodes.unshift(child);\n\t            link(last_child, last_child = child);\n\t        }\n\t    }\n\t    const first = nodes[0];\n\t    if (first && first.type === 'Text') {\n\t        first.data = trim_start(first.data);\n\t        if (!first.data) {\n\t            first.var = null;\n\t            nodes.shift();\n\t            if (nodes[0]) {\n\t                nodes[0].prev = null;\n\t            }\n\t        }\n\t    }\n\t    return nodes;\n\t}\n\tfunction trimmable_at$1(child, next_sibling) {\n\t    // Whitespace is trimmable if one of the following is true:\n\t    // The child and its sibling share a common nearest each block (not at an each block boundary)\n\t    // The next sibling's previous node is an each block\n\t    return (next_sibling.find_nearest(/EachBlock/) ===\n\t        child.find_nearest(/EachBlock/) || next_sibling.prev.type === 'EachBlock');\n\t}\n\n\tfunction Element (node, renderer, options) {\n\t    const children = remove_whitespace_children(node.children, node.next);\n\t    // awkward special case\n\t    let node_contents;\n\t    const contenteditable = (node.name !== 'textarea' &&\n\t        node.name !== 'input' &&\n\t        node.attributes.some((attribute) => attribute.name === 'contenteditable'));\n\t    const slot = node.get_static_attribute_value('slot');\n\t    const nearest_inline_component = node.find_nearest(/InlineComponent/);\n\t    if (slot && nearest_inline_component) {\n\t        renderer.push();\n\t    }\n\t    renderer.add_string(`<${node.name}`);\n\t    const class_expression_list = node.classes.map(class_directive => {\n\t        const { expression, name } = class_directive;\n\t        const snippet = expression ? expression.node : x `#ctx.${name}`; // TODO is this right?\n\t        return x `${snippet} ? \"${name}\" : \"\"`;\n\t    });\n\t    if (node.needs_manual_style_scoping) {\n\t        class_expression_list.push(x `\"${node.component.stylesheet.id}\"`);\n\t    }\n\t    const class_expression = class_expression_list.length > 0 &&\n\t        class_expression_list.reduce((lhs, rhs) => x `${lhs} + ' ' + ${rhs}`);\n\t    if (node.attributes.some(attr => attr.is_spread)) {\n\t        // TODO dry this out\n\t        const args = [];\n\t        node.attributes.forEach(attribute => {\n\t            if (attribute.is_spread) {\n\t                args.push(attribute.expression.node);\n\t            }\n\t            else {\n\t                const name = attribute.name.toLowerCase();\n\t                if (name === 'value' && node.name.toLowerCase() === 'textarea') {\n\t                    node_contents = get_attribute_value(attribute);\n\t                }\n\t                else if (attribute.is_true) {\n\t                    args.push(x `{ ${attribute.name}: true }`);\n\t                }\n\t                else if (boolean_attributes.has(name) &&\n\t                    attribute.chunks.length === 1 &&\n\t                    attribute.chunks[0].type !== 'Text') {\n\t                    // a boolean attribute with one non-Text chunk\n\t                    args.push(x `{ ${attribute.name}: ${attribute.chunks[0].node} || null }`);\n\t                }\n\t                else {\n\t                    args.push(x `{ ${attribute.name}: ${get_attribute_value(attribute)} }`);\n\t                }\n\t            }\n\t        });\n\t        renderer.add_expression(x `@spread([${args}], ${class_expression})`);\n\t    }\n\t    else {\n\t        let add_class_attribute = !!class_expression;\n\t        node.attributes.forEach(attribute => {\n\t            const name = attribute.name.toLowerCase();\n\t            if (name === 'value' && node.name.toLowerCase() === 'textarea') {\n\t                node_contents = get_attribute_value(attribute);\n\t            }\n\t            else if (attribute.is_true) {\n\t                renderer.add_string(` ${attribute.name}`);\n\t            }\n\t            else if (boolean_attributes.has(name) &&\n\t                attribute.chunks.length === 1 &&\n\t                attribute.chunks[0].type !== 'Text') {\n\t                // a boolean attribute with one non-Text chunk\n\t                renderer.add_string(` `);\n\t                renderer.add_expression(x `${attribute.chunks[0].node} ? \"${attribute.name}\" : \"\"`);\n\t            }\n\t            else if (name === 'class' && class_expression) {\n\t                add_class_attribute = false;\n\t                renderer.add_string(` ${attribute.name}=\"`);\n\t                renderer.add_expression(x `[${get_class_attribute_value(attribute)}, ${class_expression}].join(' ').trim()`);\n\t                renderer.add_string(`\"`);\n\t            }\n\t            else if (attribute.chunks.length === 1 && attribute.chunks[0].type !== 'Text') {\n\t                const snippet = attribute.chunks[0].node;\n\t                renderer.add_expression(x `@add_attribute(\"${attribute.name}\", ${snippet}, ${boolean_attributes.has(name) ? 1 : 0})`);\n\t            }\n\t            else {\n\t                renderer.add_string(` ${attribute.name}=\"`);\n\t                renderer.add_expression((name === 'class' ? get_class_attribute_value : get_attribute_value)(attribute));\n\t                renderer.add_string(`\"`);\n\t            }\n\t        });\n\t        if (add_class_attribute) {\n\t            renderer.add_expression(x `@add_classes([${class_expression}].join(' ').trim())`);\n\t        }\n\t    }\n\t    node.bindings.forEach(binding => {\n\t        const { name, expression } = binding;\n\t        if (binding.is_readonly) {\n\t            return;\n\t        }\n\t        if (name === 'group') ;\n\t        else if (contenteditable && (name === 'textContent' || name === 'innerHTML')) {\n\t            node_contents = expression.node;\n\t            // TODO where was this used?\n\t            // value = name === 'textContent' ? x`@escape($$value)` : x`$$value`;\n\t        }\n\t        else if (binding.name === 'value' && node.name === 'textarea') {\n\t            const snippet = expression.node;\n\t            node_contents = x `${snippet} || \"\"`;\n\t        }\n\t        else {\n\t            const snippet = expression.node;\n\t            renderer.add_expression(x `@add_attribute(\"${name}\", ${snippet}, 1)`);\n\t        }\n\t    });\n\t    if (options.hydratable && options.head_id) {\n\t        renderer.add_string(` data-svelte=\"${options.head_id}\"`);\n\t    }\n\t    renderer.add_string('>');\n\t    if (node_contents !== undefined) {\n\t        if (contenteditable) {\n\t            renderer.push();\n\t            renderer.render(children, options);\n\t            const result = renderer.pop();\n\t            renderer.add_expression(x `($$value => $$value === void 0 ? ${result} : $$value)(${node_contents})`);\n\t        }\n\t        else {\n\t            renderer.add_expression(node_contents);\n\t        }\n\t        if (!is_void(node.name)) {\n\t            renderer.add_string(`</${node.name}>`);\n\t        }\n\t    }\n\t    else if (slot && nearest_inline_component) {\n\t        renderer.render(children, options);\n\t        if (!is_void(node.name)) {\n\t            renderer.add_string(`</${node.name}>`);\n\t        }\n\t        const lets = node.lets;\n\t        const seen = new Set(lets.map(l => l.name.name));\n\t        nearest_inline_component.lets.forEach(l => {\n\t            if (!seen.has(l.name.name))\n\t                lets.push(l);\n\t        });\n\t        options.slot_scopes.set(slot, {\n\t            input: get_slot_scope(node.lets),\n\t            output: renderer.pop()\n\t        });\n\t    }\n\t    else {\n\t        renderer.render(children, options);\n\t        if (!is_void(node.name)) {\n\t            renderer.add_string(`</${node.name}>`);\n\t        }\n\t    }\n\t}\n\n\tfunction Head (node, renderer, options) {\n\t    const head_options = Object.assign({}, options, { head_id: node.id });\n\t    renderer.push();\n\t    renderer.render(node.children, head_options);\n\t    const result = renderer.pop();\n\t    renderer.add_expression(x `$$result.head += ${result}, \"\"`);\n\t}\n\n\tfunction HtmlTag (node, renderer, _options) {\n\t    renderer.add_expression(node.expression.node);\n\t}\n\n\tfunction IfBlock (node, renderer, options) {\n\t    const condition = node.expression.node;\n\t    renderer.push();\n\t    renderer.render(node.children, options);\n\t    const consequent = renderer.pop();\n\t    renderer.push();\n\t    if (node.else)\n\t        renderer.render(node.else.children, options);\n\t    const alternate = renderer.pop();\n\t    renderer.add_expression(x `${condition} ? ${consequent} : ${alternate}`);\n\t}\n\n\tfunction get_prop_value(attribute) {\n\t    if (attribute.is_true)\n\t        return x `true`;\n\t    if (attribute.chunks.length === 0)\n\t        return x `''`;\n\t    return attribute.chunks\n\t        .map(chunk => {\n\t        if (chunk.type === 'Text')\n\t            return string_literal(chunk.data);\n\t        return chunk.node;\n\t    })\n\t        .reduce((lhs, rhs) => x `${lhs} + ${rhs}`);\n\t}\n\tfunction InlineComponent (node, renderer, options) {\n\t    const binding_props = [];\n\t    const binding_fns = [];\n\t    node.bindings.forEach(binding => {\n\t        renderer.has_bindings = true;\n\t        // TODO this probably won't work for contextual bindings\n\t        const snippet = binding.expression.node;\n\t        binding_props.push(p `${binding.name}: ${snippet}`);\n\t        binding_fns.push(p `${binding.name}: $$value => { ${snippet} = $$value; $$settled = false }`);\n\t    });\n\t    const uses_spread = node.attributes.find(attr => attr.is_spread);\n\t    let props;\n\t    if (uses_spread) {\n\t        props = x `@_Object.assign(${node.attributes\n            .map(attribute => {\n            if (attribute.is_spread) {\n                return attribute.expression.node;\n            }\n            else {\n                return x `{ ${attribute.name}: ${get_prop_value(attribute)} }`;\n            }\n        })\n            .concat(binding_props.map(p => x `{ ${p} }`))})`;\n\t    }\n\t    else {\n\t        props = x `{\n\t\t\t${node.attributes.map(attribute => p `${attribute.name}: ${get_prop_value(attribute)}`)},\n\t\t\t${binding_props}\n\t\t}`;\n\t    }\n\t    const bindings = x `{\n\t\t${binding_fns}\n\t}`;\n\t    const expression = (node.name === 'svelte:self'\n\t        ? renderer.name\n\t        : node.name === 'svelte:component'\n\t            ? x `(${node.expression.node}) || @missing_component`\n\t            : node.name.split('.').reduce(((lhs, rhs) => x `${lhs}.${rhs}`)));\n\t    const slot_fns = [];\n\t    const children = remove_whitespace_children(node.children, node.next);\n\t    if (children.length) {\n\t        const slot_scopes = new Map();\n\t        renderer.push();\n\t        renderer.render(children, Object.assign({}, options, {\n\t            slot_scopes\n\t        }));\n\t        slot_scopes.set('default', {\n\t            input: get_slot_scope(node.lets),\n\t            output: renderer.pop()\n\t        });\n\t        slot_scopes.forEach(({ input, output }, name) => {\n\t            if (!is_empty_template_literal(output)) {\n\t                slot_fns.push(p `${name}: (${input}) => ${output}`);\n\t            }\n\t        });\n\t    }\n\t    const slots = x `{\n\t\t${slot_fns}\n\t}`;\n\t    renderer.add_expression(x `@validate_component(${expression}, \"${node.name}\").$$render($$result, ${props}, ${bindings}, ${slots})`);\n\t}\n\tfunction is_empty_template_literal(template_literal) {\n\t    return (template_literal.expressions.length === 0 &&\n\t        template_literal.quasis.length === 1 &&\n\t        template_literal.quasis[0].value.raw === \"\");\n\t}\n\n\tfunction Slot (node, renderer, options) {\n\t    const slot_data = get_slot_data(node.values);\n\t    renderer.push();\n\t    renderer.render(node.children, options);\n\t    const result = renderer.pop();\n\t    renderer.add_expression(x `\n\t\t$$slots.${node.slot_name}\n\t\t\t? $$slots.${node.slot_name}(${slot_data})\n\t\t\t: ${result}\n\t`);\n\t}\n\n\tfunction Tag$1 (node, renderer, _options) {\n\t    const snippet = node.expression.node;\n\t    renderer.add_expression(node.parent &&\n\t        node.parent.type === 'Element' &&\n\t        node.parent.name === 'style'\n\t        ? snippet\n\t        : x `@escape(${snippet})`);\n\t}\n\n\tfunction Text (node, renderer, _options) {\n\t    let text = node.data;\n\t    if (!node.parent ||\n\t        node.parent.type !== 'Element' ||\n\t        (node.parent.name !== 'script' && node.parent.name !== 'style')) {\n\t        // unless this Text node is inside a <script> or <style> element, escape &,<,>\n\t        text = escape_html(text);\n\t    }\n\t    renderer.add_string(text);\n\t}\n\n\tfunction Title (node, renderer, options) {\n\t    renderer.push();\n\t    renderer.add_string(`<title>`);\n\t    renderer.render(node.children, options);\n\t    renderer.add_string(`</title>`);\n\t    const result = renderer.pop();\n\t    renderer.add_expression(x `$$result.title = ${result}, \"\"`);\n\t}\n\n\tfunction noop$1() { }\n\tconst handlers$1 = {\n\t    AwaitBlock,\n\t    Body: noop$1,\n\t    Comment: Comment$1,\n\t    DebugTag,\n\t    EachBlock,\n\t    Element,\n\t    Head,\n\t    IfBlock,\n\t    InlineComponent,\n\t    MustacheTag: Tag$1,\n\t    Options: noop$1,\n\t    RawMustacheTag: HtmlTag,\n\t    Slot,\n\t    Text,\n\t    Title,\n\t    Window: noop$1\n\t};\n\tclass Renderer$1 {\n\t    constructor({ name }) {\n\t        this.has_bindings = false;\n\t        this.stack = [];\n\t        this.targets = [];\n\t        this.name = name;\n\t        this.push();\n\t    }\n\t    add_string(str) {\n\t        this.current.value += escape_template(str);\n\t    }\n\t    add_expression(node) {\n\t        this.literal.quasis.push({\n\t            type: 'TemplateElement',\n\t            value: { raw: this.current.value, cooked: null },\n\t            tail: false\n\t        });\n\t        this.literal.expressions.push(node);\n\t        this.current.value = '';\n\t    }\n\t    push() {\n\t        const current = this.current = { value: '' };\n\t        const literal = this.literal = {\n\t            type: 'TemplateLiteral',\n\t            expressions: [],\n\t            quasis: []\n\t        };\n\t        this.stack.push({ current, literal });\n\t    }\n\t    pop() {\n\t        this.literal.quasis.push({\n\t            type: 'TemplateElement',\n\t            value: { raw: this.current.value, cooked: null },\n\t            tail: true\n\t        });\n\t        const popped = this.stack.pop();\n\t        const last = this.stack[this.stack.length - 1];\n\t        if (last) {\n\t            this.literal = last.literal;\n\t            this.current = last.current;\n\t        }\n\t        return popped.literal;\n\t    }\n\t    render(nodes, options) {\n\t        nodes.forEach(node => {\n\t            const handler = handlers$1[node.type];\n\t            if (!handler) {\n\t                throw new Error(`No handler for '${node.type}' nodes`);\n\t            }\n\t            handler(node, this, options);\n\t        });\n\t    }\n\t}\n\n\tfunction ssr(component, options) {\n\t    const renderer = new Renderer$1({\n\t        name: component.name\n\t    });\n\t    const { name } = component;\n\t    // create $$render function\n\t    renderer.render(trim(component.fragment.children), Object.assign({\n\t        locate: component.locate\n\t    }, options));\n\t    // TODO put this inside the Renderer class\n\t    const literal = renderer.pop();\n\t    // TODO concatenate CSS maps\n\t    const css = options.customElement ?\n\t        { code: null, map: null } :\n\t        component.stylesheet.render(options.filename, true);\n\t    const uses_rest = component.var_lookup.has('$$restProps');\n\t    const props = component.vars.filter(variable => !variable.module && variable.export_name);\n\t    const rest = uses_rest ? b `let $$restProps = @compute_rest_props($$props, [${props.map(prop => `\"${prop.export_name}\"`).join(',')}]);` : null;\n\t    const reactive_stores = component.vars.filter(variable => variable.name[0] === '$' && variable.name[1] !== '$');\n\t    const reactive_store_values = reactive_stores\n\t        .map(({ name }) => {\n\t        const store_name = name.slice(1);\n\t        const store = component.var_lookup.get(store_name);\n\t        if (store && store.hoistable)\n\t            return null;\n\t        const assignment = b `${name} = @get_store_value(${store_name});`;\n\t        return component.compile_options.dev\n\t            ? b `@validate_store(${store_name}, '${store_name}'); ${assignment}`\n\t            : assignment;\n\t    })\n\t        .filter(Boolean);\n\t    component.rewrite_props(({ name }) => {\n\t        const value = `$${name}`;\n\t        let insert = b `${value} = @get_store_value(${name})`;\n\t        if (component.compile_options.dev) {\n\t            insert = b `@validate_store(${name}, '${name}'); ${insert}`;\n\t        }\n\t        return insert;\n\t    });\n\t    const instance_javascript = component.extract_javascript(component.ast.instance);\n\t    // TODO only do this for props with a default value\n\t    const parent_bindings = instance_javascript\n\t        ? component.vars\n\t            .filter(variable => !variable.module && variable.export_name)\n\t            .map(prop => {\n\t            return b `if ($$props.${prop.export_name} === void 0 && $$bindings.${prop.export_name} && ${prop.name} !== void 0) $$bindings.${prop.export_name}(${prop.name});`;\n\t        })\n\t        : [];\n\t    const reactive_declarations = component.reactive_declarations.map(d => {\n\t        const body = d.node.body;\n\t        let statement = b `${body}`;\n\t        if (d.declaration) {\n\t            const declared = extract_names(d.declaration);\n\t            const injected = declared.filter(name => {\n\t                return name[0] !== '$' && component.var_lookup.get(name).injected;\n\t            });\n\t            const self_dependencies = injected.filter(name => d.dependencies.has(name));\n\t            if (injected.length) {\n\t                // in some cases we need to do `let foo; [expression]`, in\n\t                // others we can do `let [expression]`\n\t                const separate = (self_dependencies.length > 0 ||\n\t                    declared.length > injected.length);\n\t                const { left, right } = body.expression;\n\t                statement = separate\n\t                    ? b `\n\t\t\t\t\t\t${injected.map(name => b `let ${name};`)}\n\t\t\t\t\t\t${statement}`\n\t                    : b `\n\t\t\t\t\t\tlet ${left} = ${right}`;\n\t            }\n\t        }\n\t        else { // TODO do not add label if it's not referenced\n\t            statement = b `$: { ${statement} }`;\n\t        }\n\t        return statement;\n\t    });\n\t    const main = renderer.has_bindings\n\t        ? b `\n\t\t\tlet $$settled;\n\t\t\tlet $$rendered;\n\n\t\t\tdo {\n\t\t\t\t$$settled = true;\n\n\t\t\t\t${reactive_store_values}\n\n\t\t\t\t${reactive_declarations}\n\n\t\t\t\t$$rendered = ${literal};\n\t\t\t} while (!$$settled);\n\n\t\t\treturn $$rendered;\n\t\t`\n\t        : b `\n\t\t\t${reactive_store_values}\n\n\t\t\t${reactive_declarations}\n\n\t\t\treturn ${literal};`;\n\t    const blocks = [\n\t        rest,\n\t        ...reactive_stores.map(({ name }) => {\n\t            const store_name = name.slice(1);\n\t            const store = component.var_lookup.get(store_name);\n\t            if (store && store.hoistable) {\n\t                return b `let ${name} = @get_store_value(${store_name});`;\n\t            }\n\t            return b `let ${name};`;\n\t        }),\n\t        instance_javascript,\n\t        ...parent_bindings,\n\t        css.code && b `$$result.css.add(#css);`,\n\t        main\n\t    ].filter(Boolean);\n\t    const js = b `\n\t\t${css.code ? b `\n\t\tconst #css = {\n\t\t\tcode: \"${css.code}\",\n\t\t\tmap: ${css.map ? string_literal(css.map.toString()) : 'null'}\n\t\t};` : null}\n\n\t\t${component.extract_javascript(component.ast.module)}\n\n\t\t${component.fully_hoisted}\n\n\t\tconst ${name} = @create_ssr_component(($$result, $$props, $$bindings, $$slots) => {\n\t\t\t${blocks}\n\t\t});\n\t`;\n\t    return { js, css };\n\t}\n\tfunction trim(nodes) {\n\t    let start = 0;\n\t    for (; start < nodes.length; start += 1) {\n\t        const node = nodes[start];\n\t        if (node.type !== 'Text')\n\t            break;\n\t        node.data = node.data.replace(/^\\s+/, '');\n\t        if (node.data)\n\t            break;\n\t    }\n\t    let end = nodes.length;\n\t    for (; end > start; end -= 1) {\n\t        const node = nodes[end - 1];\n\t        if (node.type !== 'Text')\n\t            break;\n\t        node.data = node.data.replace(/\\s+$/, '');\n\t        if (node.data)\n\t            break;\n\t    }\n\t    return nodes.slice(start, end);\n\t}\n\n\tconst wrappers$1 = { esm, cjs };\n\tfunction create_module(program, format, name, banner, sveltePath = 'svelte', helpers, globals, imports, module_exports) {\n\t    const internal_path = `${sveltePath}/internal`;\n\t    helpers.sort((a, b) => (a.name < b.name) ? -1 : 1);\n\t    globals.sort((a, b) => (a.name < b.name) ? -1 : 1);\n\t    if (format === 'esm') {\n\t        return esm(program, name, banner, sveltePath, internal_path, helpers, globals, imports, module_exports);\n\t    }\n\t    if (format === 'cjs')\n\t        return cjs(program, name, banner, sveltePath, internal_path, helpers, globals, imports, module_exports);\n\t    throw new Error(`options.format is invalid (must be ${list$1(Object.keys(wrappers$1))})`);\n\t}\n\tfunction edit_source(source, sveltePath) {\n\t    return source === 'svelte' || source.startsWith('svelte/')\n\t        ? source.replace('svelte', sveltePath)\n\t        : source;\n\t}\n\tfunction get_internal_globals(globals, helpers) {\n\t    return globals.length > 0 && {\n\t        type: 'VariableDeclaration',\n\t        kind: 'const',\n\t        declarations: [{\n\t                type: 'VariableDeclarator',\n\t                id: {\n\t                    type: 'ObjectPattern',\n\t                    properties: globals.map(g => ({\n\t                        type: 'Property',\n\t                        method: false,\n\t                        shorthand: false,\n\t                        computed: false,\n\t                        key: { type: 'Identifier', name: g.name },\n\t                        value: g.alias,\n\t                        kind: 'init'\n\t                    }))\n\t                },\n\t                init: helpers.find(({ name }) => name === 'globals').alias\n\t            }]\n\t    };\n\t}\n\tfunction esm(program, name, banner, sveltePath, internal_path, helpers, globals, imports, module_exports) {\n\t    const import_declaration = {\n\t        type: 'ImportDeclaration',\n\t        specifiers: helpers.map(h => ({\n\t            type: 'ImportSpecifier',\n\t            local: h.alias,\n\t            imported: { type: 'Identifier', name: h.name }\n\t        })),\n\t        source: { type: 'Literal', value: internal_path }\n\t    };\n\t    const internal_globals = get_internal_globals(globals, helpers);\n\t    // edit user imports\n\t    imports.forEach(node => {\n\t        node.source.value = edit_source(node.source.value, sveltePath);\n\t    });\n\t    const exports = module_exports.length > 0 && {\n\t        type: 'ExportNamedDeclaration',\n\t        specifiers: module_exports.map(x => ({\n\t            type: 'Specifier',\n\t            local: { type: 'Identifier', name: x.name },\n\t            exported: { type: 'Identifier', name: x.as }\n\t        }))\n\t    };\n\t    program.body = b `\n\t\t/* ${banner} */\n\n\t\t${import_declaration}\n\t\t${internal_globals}\n\t\t${imports}\n\n\t\t${program.body}\n\n\t\texport default ${name};\n\t\t${exports}\n\t`;\n\t}\n\tfunction cjs(program, name, banner, sveltePath, internal_path, helpers, globals, imports, module_exports) {\n\t    const internal_requires = {\n\t        type: 'VariableDeclaration',\n\t        kind: 'const',\n\t        declarations: [{\n\t                type: 'VariableDeclarator',\n\t                id: {\n\t                    type: 'ObjectPattern',\n\t                    properties: helpers.map(h => ({\n\t                        type: 'Property',\n\t                        method: false,\n\t                        shorthand: false,\n\t                        computed: false,\n\t                        key: { type: 'Identifier', name: h.name },\n\t                        value: h.alias,\n\t                        kind: 'init'\n\t                    }))\n\t                },\n\t                init: x `require(\"${internal_path}\")`\n\t            }]\n\t    };\n\t    const internal_globals = get_internal_globals(globals, helpers);\n\t    const user_requires = imports.map(node => {\n\t        const init = x `require(\"${edit_source(node.source.value, sveltePath)}\")`;\n\t        if (node.specifiers.length === 0) {\n\t            return b `${init};`;\n\t        }\n\t        return {\n\t            type: 'VariableDeclaration',\n\t            kind: 'const',\n\t            declarations: [{\n\t                    type: 'VariableDeclarator',\n\t                    id: node.specifiers[0].type === 'ImportNamespaceSpecifier'\n\t                        ? { type: 'Identifier', name: node.specifiers[0].local.name }\n\t                        : {\n\t                            type: 'ObjectPattern',\n\t                            properties: node.specifiers.map(s => ({\n\t                                type: 'Property',\n\t                                method: false,\n\t                                shorthand: false,\n\t                                computed: false,\n\t                                key: s.type === 'ImportSpecifier' ? s.imported : { type: 'Identifier', name: 'default' },\n\t                                value: s.local,\n\t                                kind: 'init'\n\t                            }))\n\t                        },\n\t                    init\n\t                }]\n\t        };\n\t    });\n\t    const exports = module_exports.map(x => b `exports.${{ type: 'Identifier', name: x.as }} = ${{ type: 'Identifier', name: x.name }};`);\n\t    program.body = b `\n\t\t/* ${banner} */\n\n\t\t\"use strict\";\n\t\t${internal_requires}\n\t\t${internal_globals}\n\t\t${user_requires}\n\n\t\t${program.body}\n\n\t\texports.default = ${name};\n\t\t${exports}\n\t`;\n\t}\n\n\tvar Chunk = function Chunk(start, end, content) {\n\t\tthis.start = start;\n\t\tthis.end = end;\n\t\tthis.original = content;\n\n\t\tthis.intro = '';\n\t\tthis.outro = '';\n\n\t\tthis.content = content;\n\t\tthis.storeName = false;\n\t\tthis.edited = false;\n\n\t\t// we make these non-enumerable, for sanity while debugging\n\t\tObject.defineProperties(this, {\n\t\t\tprevious: { writable: true, value: null },\n\t\t\tnext:     { writable: true, value: null }\n\t\t});\n\t};\n\n\tChunk.prototype.appendLeft = function appendLeft (content) {\n\t\tthis.outro += content;\n\t};\n\n\tChunk.prototype.appendRight = function appendRight (content) {\n\t\tthis.intro = this.intro + content;\n\t};\n\n\tChunk.prototype.clone = function clone () {\n\t\tvar chunk = new Chunk(this.start, this.end, this.original);\n\n\t\tchunk.intro = this.intro;\n\t\tchunk.outro = this.outro;\n\t\tchunk.content = this.content;\n\t\tchunk.storeName = this.storeName;\n\t\tchunk.edited = this.edited;\n\n\t\treturn chunk;\n\t};\n\n\tChunk.prototype.contains = function contains (index) {\n\t\treturn this.start < index && index < this.end;\n\t};\n\n\tChunk.prototype.eachNext = function eachNext (fn) {\n\t\tvar chunk = this;\n\t\twhile (chunk) {\n\t\t\tfn(chunk);\n\t\t\tchunk = chunk.next;\n\t\t}\n\t};\n\n\tChunk.prototype.eachPrevious = function eachPrevious (fn) {\n\t\tvar chunk = this;\n\t\twhile (chunk) {\n\t\t\tfn(chunk);\n\t\t\tchunk = chunk.previous;\n\t\t}\n\t};\n\n\tChunk.prototype.edit = function edit (content, storeName, contentOnly) {\n\t\tthis.content = content;\n\t\tif (!contentOnly) {\n\t\t\tthis.intro = '';\n\t\t\tthis.outro = '';\n\t\t}\n\t\tthis.storeName = storeName;\n\n\t\tthis.edited = true;\n\n\t\treturn this;\n\t};\n\n\tChunk.prototype.prependLeft = function prependLeft (content) {\n\t\tthis.outro = content + this.outro;\n\t};\n\n\tChunk.prototype.prependRight = function prependRight (content) {\n\t\tthis.intro = content + this.intro;\n\t};\n\n\tChunk.prototype.split = function split (index) {\n\t\tvar sliceIndex = index - this.start;\n\n\t\tvar originalBefore = this.original.slice(0, sliceIndex);\n\t\tvar originalAfter = this.original.slice(sliceIndex);\n\n\t\tthis.original = originalBefore;\n\n\t\tvar newChunk = new Chunk(index, this.end, originalAfter);\n\t\tnewChunk.outro = this.outro;\n\t\tthis.outro = '';\n\n\t\tthis.end = index;\n\n\t\tif (this.edited) {\n\t\t\t// TODO is this block necessary?...\n\t\t\tnewChunk.edit('', false);\n\t\t\tthis.content = '';\n\t\t} else {\n\t\t\tthis.content = originalBefore;\n\t\t}\n\n\t\tnewChunk.next = this.next;\n\t\tif (newChunk.next) { newChunk.next.previous = newChunk; }\n\t\tnewChunk.previous = this;\n\t\tthis.next = newChunk;\n\n\t\treturn newChunk;\n\t};\n\n\tChunk.prototype.toString = function toString () {\n\t\treturn this.intro + this.content + this.outro;\n\t};\n\n\tChunk.prototype.trimEnd = function trimEnd (rx) {\n\t\tthis.outro = this.outro.replace(rx, '');\n\t\tif (this.outro.length) { return true; }\n\n\t\tvar trimmed = this.content.replace(rx, '');\n\n\t\tif (trimmed.length) {\n\t\t\tif (trimmed !== this.content) {\n\t\t\t\tthis.split(this.start + trimmed.length).edit('', undefined, true);\n\t\t\t}\n\t\t\treturn true;\n\n\t\t} else {\n\t\t\tthis.edit('', undefined, true);\n\n\t\t\tthis.intro = this.intro.replace(rx, '');\n\t\t\tif (this.intro.length) { return true; }\n\t\t}\n\t};\n\n\tChunk.prototype.trimStart = function trimStart (rx) {\n\t\tthis.intro = this.intro.replace(rx, '');\n\t\tif (this.intro.length) { return true; }\n\n\t\tvar trimmed = this.content.replace(rx, '');\n\n\t\tif (trimmed.length) {\n\t\t\tif (trimmed !== this.content) {\n\t\t\t\tthis.split(this.end - trimmed.length);\n\t\t\t\tthis.edit('', undefined, true);\n\t\t\t}\n\t\t\treturn true;\n\n\t\t} else {\n\t\t\tthis.edit('', undefined, true);\n\n\t\t\tthis.outro = this.outro.replace(rx, '');\n\t\t\tif (this.outro.length) { return true; }\n\t\t}\n\t};\n\n\tvar btoa$1 = function () {\n\t\tthrow new Error('Unsupported environment: `window.btoa` or `Buffer` should be supported.');\n\t};\n\tif (typeof window !== 'undefined' && typeof window.btoa === 'function') {\n\t\tbtoa$1 = function (str) { return window.btoa(unescape(encodeURIComponent(str))); };\n\t} else if (typeof Buffer === 'function') {\n\t\tbtoa$1 = function (str) { return Buffer.from(str, 'utf-8').toString('base64'); };\n\t}\n\n\tvar SourceMap = function SourceMap(properties) {\n\t\tthis.version = 3;\n\t\tthis.file = properties.file;\n\t\tthis.sources = properties.sources;\n\t\tthis.sourcesContent = properties.sourcesContent;\n\t\tthis.names = properties.names;\n\t\tthis.mappings = encode(properties.mappings);\n\t};\n\n\tSourceMap.prototype.toString = function toString () {\n\t\treturn JSON.stringify(this);\n\t};\n\n\tSourceMap.prototype.toUrl = function toUrl () {\n\t\treturn 'data:application/json;charset=utf-8;base64,' + btoa$1(this.toString());\n\t};\n\n\tfunction guessIndent(code) {\n\t\tvar lines = code.split('\\n');\n\n\t\tvar tabbed = lines.filter(function (line) { return /^\\t+/.test(line); });\n\t\tvar spaced = lines.filter(function (line) { return /^ {2,}/.test(line); });\n\n\t\tif (tabbed.length === 0 && spaced.length === 0) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// More lines tabbed than spaced? Assume tabs, and\n\t\t// default to tabs in the case of a tie (or nothing\n\t\t// to go on)\n\t\tif (tabbed.length >= spaced.length) {\n\t\t\treturn '\\t';\n\t\t}\n\n\t\t// Otherwise, we need to guess the multiple\n\t\tvar min = spaced.reduce(function (previous, current) {\n\t\t\tvar numSpaces = /^ +/.exec(current)[0].length;\n\t\t\treturn Math.min(numSpaces, previous);\n\t\t}, Infinity);\n\n\t\treturn new Array(min + 1).join(' ');\n\t}\n\n\tfunction getRelativePath(from, to) {\n\t\tvar fromParts = from.split(/[/\\\\]/);\n\t\tvar toParts = to.split(/[/\\\\]/);\n\n\t\tfromParts.pop(); // get dirname\n\n\t\twhile (fromParts[0] === toParts[0]) {\n\t\t\tfromParts.shift();\n\t\t\ttoParts.shift();\n\t\t}\n\n\t\tif (fromParts.length) {\n\t\t\tvar i = fromParts.length;\n\t\t\twhile (i--) { fromParts[i] = '..'; }\n\t\t}\n\n\t\treturn fromParts.concat(toParts).join('/');\n\t}\n\n\tvar toString$1 = Object.prototype.toString;\n\n\tfunction isObject(thing) {\n\t\treturn toString$1.call(thing) === '[object Object]';\n\t}\n\n\tfunction getLocator$1(source) {\n\t\tvar originalLines = source.split('\\n');\n\t\tvar lineOffsets = [];\n\n\t\tfor (var i = 0, pos = 0; i < originalLines.length; i++) {\n\t\t\tlineOffsets.push(pos);\n\t\t\tpos += originalLines[i].length + 1;\n\t\t}\n\n\t\treturn function locate(index) {\n\t\t\tvar i = 0;\n\t\t\tvar j = lineOffsets.length;\n\t\t\twhile (i < j) {\n\t\t\t\tvar m = (i + j) >> 1;\n\t\t\t\tif (index < lineOffsets[m]) {\n\t\t\t\t\tj = m;\n\t\t\t\t} else {\n\t\t\t\t\ti = m + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar line = i - 1;\n\t\t\tvar column = index - lineOffsets[line];\n\t\t\treturn { line: line, column: column };\n\t\t};\n\t}\n\n\tvar Mappings = function Mappings(hires) {\n\t\tthis.hires = hires;\n\t\tthis.generatedCodeLine = 0;\n\t\tthis.generatedCodeColumn = 0;\n\t\tthis.raw = [];\n\t\tthis.rawSegments = this.raw[this.generatedCodeLine] = [];\n\t\tthis.pending = null;\n\t};\n\n\tMappings.prototype.addEdit = function addEdit (sourceIndex, content, loc, nameIndex) {\n\t\tif (content.length) {\n\t\t\tvar segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];\n\t\t\tif (nameIndex >= 0) {\n\t\t\t\tsegment.push(nameIndex);\n\t\t\t}\n\t\t\tthis.rawSegments.push(segment);\n\t\t} else if (this.pending) {\n\t\t\tthis.rawSegments.push(this.pending);\n\t\t}\n\n\t\tthis.advance(content);\n\t\tthis.pending = null;\n\t};\n\n\tMappings.prototype.addUneditedChunk = function addUneditedChunk (sourceIndex, chunk, original, loc, sourcemapLocations) {\n\t\tvar originalCharIndex = chunk.start;\n\t\tvar first = true;\n\n\t\twhile (originalCharIndex < chunk.end) {\n\t\t\tif (this.hires || first || sourcemapLocations[originalCharIndex]) {\n\t\t\t\tthis.rawSegments.push([this.generatedCodeColumn, sourceIndex, loc.line, loc.column]);\n\t\t\t}\n\n\t\t\tif (original[originalCharIndex] === '\\n') {\n\t\t\t\tloc.line += 1;\n\t\t\t\tloc.column = 0;\n\t\t\t\tthis.generatedCodeLine += 1;\n\t\t\t\tthis.raw[this.generatedCodeLine] = this.rawSegments = [];\n\t\t\t\tthis.generatedCodeColumn = 0;\n\t\t\t} else {\n\t\t\t\tloc.column += 1;\n\t\t\t\tthis.generatedCodeColumn += 1;\n\t\t\t}\n\n\t\t\toriginalCharIndex += 1;\n\t\t\tfirst = false;\n\t\t}\n\n\t\tthis.pending = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];\n\t};\n\n\tMappings.prototype.advance = function advance (str) {\n\t\tif (!str) { return; }\n\n\t\tvar lines = str.split('\\n');\n\n\t\tif (lines.length > 1) {\n\t\t\tfor (var i = 0; i < lines.length - 1; i++) {\n\t\t\t\tthis.generatedCodeLine++;\n\t\t\t\tthis.raw[this.generatedCodeLine] = this.rawSegments = [];\n\t\t\t}\n\t\t\tthis.generatedCodeColumn = 0;\n\t\t}\n\n\t\tthis.generatedCodeColumn += lines[lines.length - 1].length;\n\t};\n\n\tvar n = '\\n';\n\n\tvar warned = {\n\t\tinsertLeft: false,\n\t\tinsertRight: false,\n\t\tstoreName: false\n\t};\n\n\tvar MagicString = function MagicString(string, options) {\n\t\tif ( options === void 0 ) options = {};\n\n\t\tvar chunk = new Chunk(0, string.length, string);\n\n\t\tObject.defineProperties(this, {\n\t\t\toriginal:              { writable: true, value: string },\n\t\t\toutro:                 { writable: true, value: '' },\n\t\t\tintro:                 { writable: true, value: '' },\n\t\t\tfirstChunk:            { writable: true, value: chunk },\n\t\t\tlastChunk:             { writable: true, value: chunk },\n\t\t\tlastSearchedChunk:     { writable: true, value: chunk },\n\t\t\tbyStart:               { writable: true, value: {} },\n\t\t\tbyEnd:                 { writable: true, value: {} },\n\t\t\tfilename:              { writable: true, value: options.filename },\n\t\t\tindentExclusionRanges: { writable: true, value: options.indentExclusionRanges },\n\t\t\tsourcemapLocations:    { writable: true, value: {} },\n\t\t\tstoredNames:           { writable: true, value: {} },\n\t\t\tindentStr:             { writable: true, value: guessIndent(string) }\n\t\t});\n\n\t\tthis.byStart[0] = chunk;\n\t\tthis.byEnd[string.length] = chunk;\n\t};\n\n\tMagicString.prototype.addSourcemapLocation = function addSourcemapLocation (char) {\n\t\tthis.sourcemapLocations[char] = true;\n\t};\n\n\tMagicString.prototype.append = function append (content) {\n\t\tif (typeof content !== 'string') { throw new TypeError('outro content must be a string'); }\n\n\t\tthis.outro += content;\n\t\treturn this;\n\t};\n\n\tMagicString.prototype.appendLeft = function appendLeft (index, content) {\n\t\tif (typeof content !== 'string') { throw new TypeError('inserted content must be a string'); }\n\n\t\tthis._split(index);\n\n\t\tvar chunk = this.byEnd[index];\n\n\t\tif (chunk) {\n\t\t\tchunk.appendLeft(content);\n\t\t} else {\n\t\t\tthis.intro += content;\n\t\t}\n\t\treturn this;\n\t};\n\n\tMagicString.prototype.appendRight = function appendRight (index, content) {\n\t\tif (typeof content !== 'string') { throw new TypeError('inserted content must be a string'); }\n\n\t\tthis._split(index);\n\n\t\tvar chunk = this.byStart[index];\n\n\t\tif (chunk) {\n\t\t\tchunk.appendRight(content);\n\t\t} else {\n\t\t\tthis.outro += content;\n\t\t}\n\t\treturn this;\n\t};\n\n\tMagicString.prototype.clone = function clone () {\n\t\tvar cloned = new MagicString(this.original, { filename: this.filename });\n\n\t\tvar originalChunk = this.firstChunk;\n\t\tvar clonedChunk = (cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone());\n\n\t\twhile (originalChunk) {\n\t\t\tcloned.byStart[clonedChunk.start] = clonedChunk;\n\t\t\tcloned.byEnd[clonedChunk.end] = clonedChunk;\n\n\t\t\tvar nextOriginalChunk = originalChunk.next;\n\t\t\tvar nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();\n\n\t\t\tif (nextClonedChunk) {\n\t\t\t\tclonedChunk.next = nextClonedChunk;\n\t\t\t\tnextClonedChunk.previous = clonedChunk;\n\n\t\t\t\tclonedChunk = nextClonedChunk;\n\t\t\t}\n\n\t\t\toriginalChunk = nextOriginalChunk;\n\t\t}\n\n\t\tcloned.lastChunk = clonedChunk;\n\n\t\tif (this.indentExclusionRanges) {\n\t\t\tcloned.indentExclusionRanges = this.indentExclusionRanges.slice();\n\t\t}\n\n\t\tObject.keys(this.sourcemapLocations).forEach(function (loc) {\n\t\t\tcloned.sourcemapLocations[loc] = true;\n\t\t});\n\n\t\treturn cloned;\n\t};\n\n\tMagicString.prototype.generateDecodedMap = function generateDecodedMap (options) {\n\t\t\tvar this$1 = this;\n\n\t\toptions = options || {};\n\n\t\tvar sourceIndex = 0;\n\t\tvar names = Object.keys(this.storedNames);\n\t\tvar mappings = new Mappings(options.hires);\n\n\t\tvar locate = getLocator$1(this.original);\n\n\t\tif (this.intro) {\n\t\t\tmappings.advance(this.intro);\n\t\t}\n\n\t\tthis.firstChunk.eachNext(function (chunk) {\n\t\t\tvar loc = locate(chunk.start);\n\n\t\t\tif (chunk.intro.length) { mappings.advance(chunk.intro); }\n\n\t\t\tif (chunk.edited) {\n\t\t\t\tmappings.addEdit(\n\t\t\t\t\tsourceIndex,\n\t\t\t\t\tchunk.content,\n\t\t\t\t\tloc,\n\t\t\t\t\tchunk.storeName ? names.indexOf(chunk.original) : -1\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tmappings.addUneditedChunk(sourceIndex, chunk, this$1.original, loc, this$1.sourcemapLocations);\n\t\t\t}\n\n\t\t\tif (chunk.outro.length) { mappings.advance(chunk.outro); }\n\t\t});\n\n\t\treturn {\n\t\t\tfile: options.file ? options.file.split(/[/\\\\]/).pop() : null,\n\t\t\tsources: [options.source ? getRelativePath(options.file || '', options.source) : null],\n\t\t\tsourcesContent: options.includeContent ? [this.original] : [null],\n\t\t\tnames: names,\n\t\t\tmappings: mappings.raw\n\t\t};\n\t};\n\n\tMagicString.prototype.generateMap = function generateMap (options) {\n\t\treturn new SourceMap(this.generateDecodedMap(options));\n\t};\n\n\tMagicString.prototype.getIndentString = function getIndentString () {\n\t\treturn this.indentStr === null ? '\\t' : this.indentStr;\n\t};\n\n\tMagicString.prototype.indent = function indent (indentStr, options) {\n\t\tvar pattern = /^[^\\r\\n]/gm;\n\n\t\tif (isObject(indentStr)) {\n\t\t\toptions = indentStr;\n\t\t\tindentStr = undefined;\n\t\t}\n\n\t\tindentStr = indentStr !== undefined ? indentStr : this.indentStr || '\\t';\n\n\t\tif (indentStr === '') { return this; } // noop\n\n\t\toptions = options || {};\n\n\t\t// Process exclusion ranges\n\t\tvar isExcluded = {};\n\n\t\tif (options.exclude) {\n\t\t\tvar exclusions =\n\t\t\t\ttypeof options.exclude[0] === 'number' ? [options.exclude] : options.exclude;\n\t\t\texclusions.forEach(function (exclusion) {\n\t\t\t\tfor (var i = exclusion[0]; i < exclusion[1]; i += 1) {\n\t\t\t\t\tisExcluded[i] = true;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tvar shouldIndentNextCharacter = options.indentStart !== false;\n\t\tvar replacer = function (match) {\n\t\t\tif (shouldIndentNextCharacter) { return (\"\" + indentStr + match); }\n\t\t\tshouldIndentNextCharacter = true;\n\t\t\treturn match;\n\t\t};\n\n\t\tthis.intro = this.intro.replace(pattern, replacer);\n\n\t\tvar charIndex = 0;\n\t\tvar chunk = this.firstChunk;\n\n\t\twhile (chunk) {\n\t\t\tvar end = chunk.end;\n\n\t\t\tif (chunk.edited) {\n\t\t\t\tif (!isExcluded[charIndex]) {\n\t\t\t\t\tchunk.content = chunk.content.replace(pattern, replacer);\n\n\t\t\t\t\tif (chunk.content.length) {\n\t\t\t\t\t\tshouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === '\\n';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcharIndex = chunk.start;\n\n\t\t\t\twhile (charIndex < end) {\n\t\t\t\t\tif (!isExcluded[charIndex]) {\n\t\t\t\t\t\tvar char = this.original[charIndex];\n\n\t\t\t\t\t\tif (char === '\\n') {\n\t\t\t\t\t\t\tshouldIndentNextCharacter = true;\n\t\t\t\t\t\t} else if (char !== '\\r' && shouldIndentNextCharacter) {\n\t\t\t\t\t\t\tshouldIndentNextCharacter = false;\n\n\t\t\t\t\t\t\tif (charIndex === chunk.start) {\n\t\t\t\t\t\t\t\tchunk.prependRight(indentStr);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis._splitChunk(chunk, charIndex);\n\t\t\t\t\t\t\t\tchunk = chunk.next;\n\t\t\t\t\t\t\t\tchunk.prependRight(indentStr);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tcharIndex += 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcharIndex = chunk.end;\n\t\t\tchunk = chunk.next;\n\t\t}\n\n\t\tthis.outro = this.outro.replace(pattern, replacer);\n\n\t\treturn this;\n\t};\n\n\tMagicString.prototype.insert = function insert () {\n\t\tthrow new Error('magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)');\n\t};\n\n\tMagicString.prototype.insertLeft = function insertLeft (index, content) {\n\t\tif (!warned.insertLeft) {\n\t\t\tconsole.warn('magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead'); // eslint-disable-line no-console\n\t\t\twarned.insertLeft = true;\n\t\t}\n\n\t\treturn this.appendLeft(index, content);\n\t};\n\n\tMagicString.prototype.insertRight = function insertRight (index, content) {\n\t\tif (!warned.insertRight) {\n\t\t\tconsole.warn('magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead'); // eslint-disable-line no-console\n\t\t\twarned.insertRight = true;\n\t\t}\n\n\t\treturn this.prependRight(index, content);\n\t};\n\n\tMagicString.prototype.move = function move (start, end, index) {\n\t\tif (index >= start && index <= end) { throw new Error('Cannot move a selection inside itself'); }\n\n\t\tthis._split(start);\n\t\tthis._split(end);\n\t\tthis._split(index);\n\n\t\tvar first = this.byStart[start];\n\t\tvar last = this.byEnd[end];\n\n\t\tvar oldLeft = first.previous;\n\t\tvar oldRight = last.next;\n\n\t\tvar newRight = this.byStart[index];\n\t\tif (!newRight && last === this.lastChunk) { return this; }\n\t\tvar newLeft = newRight ? newRight.previous : this.lastChunk;\n\n\t\tif (oldLeft) { oldLeft.next = oldRight; }\n\t\tif (oldRight) { oldRight.previous = oldLeft; }\n\n\t\tif (newLeft) { newLeft.next = first; }\n\t\tif (newRight) { newRight.previous = last; }\n\n\t\tif (!first.previous) { this.firstChunk = last.next; }\n\t\tif (!last.next) {\n\t\t\tthis.lastChunk = first.previous;\n\t\t\tthis.lastChunk.next = null;\n\t\t}\n\n\t\tfirst.previous = newLeft;\n\t\tlast.next = newRight || null;\n\n\t\tif (!newLeft) { this.firstChunk = first; }\n\t\tif (!newRight) { this.lastChunk = last; }\n\t\treturn this;\n\t};\n\n\tMagicString.prototype.overwrite = function overwrite (start, end, content, options) {\n\t\tif (typeof content !== 'string') { throw new TypeError('replacement content must be a string'); }\n\n\t\twhile (start < 0) { start += this.original.length; }\n\t\twhile (end < 0) { end += this.original.length; }\n\n\t\tif (end > this.original.length) { throw new Error('end is out of bounds'); }\n\t\tif (start === end)\n\t\t\t{ throw new Error('Cannot overwrite a zero-length range \u2013 use appendLeft or prependRight instead'); }\n\n\t\tthis._split(start);\n\t\tthis._split(end);\n\n\t\tif (options === true) {\n\t\t\tif (!warned.storeName) {\n\t\t\t\tconsole.warn('The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string'); // eslint-disable-line no-console\n\t\t\t\twarned.storeName = true;\n\t\t\t}\n\n\t\t\toptions = { storeName: true };\n\t\t}\n\t\tvar storeName = options !== undefined ? options.storeName : false;\n\t\tvar contentOnly = options !== undefined ? options.contentOnly : false;\n\n\t\tif (storeName) {\n\t\t\tvar original = this.original.slice(start, end);\n\t\t\tthis.storedNames[original] = true;\n\t\t}\n\n\t\tvar first = this.byStart[start];\n\t\tvar last = this.byEnd[end];\n\n\t\tif (first) {\n\t\t\tif (end > first.end && first.next !== this.byStart[first.end]) {\n\t\t\t\tthrow new Error('Cannot overwrite across a split point');\n\t\t\t}\n\n\t\t\tfirst.edit(content, storeName, contentOnly);\n\n\t\t\tif (first !== last) {\n\t\t\t\tvar chunk = first.next;\n\t\t\t\twhile (chunk !== last) {\n\t\t\t\t\tchunk.edit('', false);\n\t\t\t\t\tchunk = chunk.next;\n\t\t\t\t}\n\n\t\t\t\tchunk.edit('', false);\n\t\t\t}\n\t\t} else {\n\t\t\t// must be inserting at the end\n\t\t\tvar newChunk = new Chunk(start, end, '').edit(content, storeName);\n\n\t\t\t// TODO last chunk in the array may not be the last chunk, if it's moved...\n\t\t\tlast.next = newChunk;\n\t\t\tnewChunk.previous = last;\n\t\t}\n\t\treturn this;\n\t};\n\n\tMagicString.prototype.prepend = function prepend (content) {\n\t\tif (typeof content !== 'string') { throw new TypeError('outro content must be a string'); }\n\n\t\tthis.intro = content + this.intro;\n\t\treturn this;\n\t};\n\n\tMagicString.prototype.prependLeft = function prependLeft (index, content) {\n\t\tif (typeof content !== 'string') { throw new TypeError('inserted content must be a string'); }\n\n\t\tthis._split(index);\n\n\t\tvar chunk = this.byEnd[index];\n\n\t\tif (chunk) {\n\t\t\tchunk.prependLeft(content);\n\t\t} else {\n\t\t\tthis.intro = content + this.intro;\n\t\t}\n\t\treturn this;\n\t};\n\n\tMagicString.prototype.prependRight = function prependRight (index, content) {\n\t\tif (typeof content !== 'string') { throw new TypeError('inserted content must be a string'); }\n\n\t\tthis._split(index);\n\n\t\tvar chunk = this.byStart[index];\n\n\t\tif (chunk) {\n\t\t\tchunk.prependRight(content);\n\t\t} else {\n\t\t\tthis.outro = content + this.outro;\n\t\t}\n\t\treturn this;\n\t};\n\n\tMagicString.prototype.remove = function remove (start, end) {\n\t\twhile (start < 0) { start += this.original.length; }\n\t\twhile (end < 0) { end += this.original.length; }\n\n\t\tif (start === end) { return this; }\n\n\t\tif (start < 0 || end > this.original.length) { throw new Error('Character is out of bounds'); }\n\t\tif (start > end) { throw new Error('end must be greater than start'); }\n\n\t\tthis._split(start);\n\t\tthis._split(end);\n\n\t\tvar chunk = this.byStart[start];\n\n\t\twhile (chunk) {\n\t\t\tchunk.intro = '';\n\t\t\tchunk.outro = '';\n\t\t\tchunk.edit('');\n\n\t\t\tchunk = end > chunk.end ? this.byStart[chunk.end] : null;\n\t\t}\n\t\treturn this;\n\t};\n\n\tMagicString.prototype.lastChar = function lastChar () {\n\t\tif (this.outro.length)\n\t\t\t{ return this.outro[this.outro.length - 1]; }\n\t\tvar chunk = this.lastChunk;\n\t\tdo {\n\t\t\tif (chunk.outro.length)\n\t\t\t\t{ return chunk.outro[chunk.outro.length - 1]; }\n\t\t\tif (chunk.content.length)\n\t\t\t\t{ return chunk.content[chunk.content.length - 1]; }\n\t\t\tif (chunk.intro.length)\n\t\t\t\t{ return chunk.intro[chunk.intro.length - 1]; }\n\t\t} while (chunk = chunk.previous);\n\t\tif (this.intro.length)\n\t\t\t{ return this.intro[this.intro.length - 1]; }\n\t\treturn '';\n\t};\n\n\tMagicString.prototype.lastLine = function lastLine () {\n\t\tvar lineIndex = this.outro.lastIndexOf(n);\n\t\tif (lineIndex !== -1)\n\t\t\t{ return this.outro.substr(lineIndex + 1); }\n\t\tvar lineStr = this.outro;\n\t\tvar chunk = this.lastChunk;\n\t\tdo {\n\t\t\tif (chunk.outro.length > 0) {\n\t\t\t\tlineIndex = chunk.outro.lastIndexOf(n);\n\t\t\t\tif (lineIndex !== -1)\n\t\t\t\t\t{ return chunk.outro.substr(lineIndex + 1) + lineStr; }\n\t\t\t\tlineStr = chunk.outro + lineStr;\n\t\t\t}\n\n\t\t\tif (chunk.content.length > 0) {\n\t\t\t\tlineIndex = chunk.content.lastIndexOf(n);\n\t\t\t\tif (lineIndex !== -1)\n\t\t\t\t\t{ return chunk.content.substr(lineIndex + 1) + lineStr; }\n\t\t\t\tlineStr = chunk.content + lineStr;\n\t\t\t}\n\n\t\t\tif (chunk.intro.length > 0) {\n\t\t\t\tlineIndex = chunk.intro.lastIndexOf(n);\n\t\t\t\tif (lineIndex !== -1)\n\t\t\t\t\t{ return chunk.intro.substr(lineIndex + 1) + lineStr; }\n\t\t\t\tlineStr = chunk.intro + lineStr;\n\t\t\t}\n\t\t} while (chunk = chunk.previous);\n\t\tlineIndex = this.intro.lastIndexOf(n);\n\t\tif (lineIndex !== -1)\n\t\t\t{ return this.intro.substr(lineIndex + 1) + lineStr; }\n\t\treturn this.intro + lineStr;\n\t};\n\n\tMagicString.prototype.slice = function slice (start, end) {\n\t\t\tif ( start === void 0 ) start = 0;\n\t\t\tif ( end === void 0 ) end = this.original.length;\n\n\t\twhile (start < 0) { start += this.original.length; }\n\t\twhile (end < 0) { end += this.original.length; }\n\n\t\tvar result = '';\n\n\t\t// find start chunk\n\t\tvar chunk = this.firstChunk;\n\t\twhile (chunk && (chunk.start > start || chunk.end <= start)) {\n\t\t\t// found end chunk before start\n\t\t\tif (chunk.start < end && chunk.end >= end) {\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\tchunk = chunk.next;\n\t\t}\n\n\t\tif (chunk && chunk.edited && chunk.start !== start)\n\t\t\t{ throw new Error((\"Cannot use replaced character \" + start + \" as slice start anchor.\")); }\n\n\t\tvar startChunk = chunk;\n\t\twhile (chunk) {\n\t\t\tif (chunk.intro && (startChunk !== chunk || chunk.start === start)) {\n\t\t\t\tresult += chunk.intro;\n\t\t\t}\n\n\t\t\tvar containsEnd = chunk.start < end && chunk.end >= end;\n\t\t\tif (containsEnd && chunk.edited && chunk.end !== end)\n\t\t\t\t{ throw new Error((\"Cannot use replaced character \" + end + \" as slice end anchor.\")); }\n\n\t\t\tvar sliceStart = startChunk === chunk ? start - chunk.start : 0;\n\t\t\tvar sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;\n\n\t\t\tresult += chunk.content.slice(sliceStart, sliceEnd);\n\n\t\t\tif (chunk.outro && (!containsEnd || chunk.end === end)) {\n\t\t\t\tresult += chunk.outro;\n\t\t\t}\n\n\t\t\tif (containsEnd) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tchunk = chunk.next;\n\t\t}\n\n\t\treturn result;\n\t};\n\n\t// TODO deprecate this? not really very useful\n\tMagicString.prototype.snip = function snip (start, end) {\n\t\tvar clone = this.clone();\n\t\tclone.remove(0, start);\n\t\tclone.remove(end, clone.original.length);\n\n\t\treturn clone;\n\t};\n\n\tMagicString.prototype._split = function _split (index) {\n\t\tif (this.byStart[index] || this.byEnd[index]) { return; }\n\n\t\tvar chunk = this.lastSearchedChunk;\n\t\tvar searchForward = index > chunk.end;\n\n\t\twhile (chunk) {\n\t\t\tif (chunk.contains(index)) { return this._splitChunk(chunk, index); }\n\n\t\t\tchunk = searchForward ? this.byStart[chunk.end] : this.byEnd[chunk.start];\n\t\t}\n\t};\n\n\tMagicString.prototype._splitChunk = function _splitChunk (chunk, index) {\n\t\tif (chunk.edited && chunk.content.length) {\n\t\t\t// zero-length edited chunks are a special case (overlapping replacements)\n\t\t\tvar loc = getLocator$1(this.original)(index);\n\t\t\tthrow new Error(\n\t\t\t\t(\"Cannot split a chunk that has already been edited (\" + (loc.line) + \":\" + (loc.column) + \" \u2013 \\\"\" + (chunk.original) + \"\\\")\")\n\t\t\t);\n\t\t}\n\n\t\tvar newChunk = chunk.split(index);\n\n\t\tthis.byEnd[index] = chunk;\n\t\tthis.byStart[index] = newChunk;\n\t\tthis.byEnd[newChunk.end] = newChunk;\n\n\t\tif (chunk === this.lastChunk) { this.lastChunk = newChunk; }\n\n\t\tthis.lastSearchedChunk = chunk;\n\t\treturn true;\n\t};\n\n\tMagicString.prototype.toString = function toString () {\n\t\tvar str = this.intro;\n\n\t\tvar chunk = this.firstChunk;\n\t\twhile (chunk) {\n\t\t\tstr += chunk.toString();\n\t\t\tchunk = chunk.next;\n\t\t}\n\n\t\treturn str + this.outro;\n\t};\n\n\tMagicString.prototype.isEmpty = function isEmpty () {\n\t\tvar chunk = this.firstChunk;\n\t\tdo {\n\t\t\tif (chunk.intro.length && chunk.intro.trim() ||\n\t\t\t\t\tchunk.content.length && chunk.content.trim() ||\n\t\t\t\t\tchunk.outro.length && chunk.outro.trim())\n\t\t\t\t{ return false; }\n\t\t} while (chunk = chunk.next);\n\t\treturn true;\n\t};\n\n\tMagicString.prototype.length = function length () {\n\t\tvar chunk = this.firstChunk;\n\t\tvar length = 0;\n\t\tdo {\n\t\t\tlength += chunk.intro.length + chunk.content.length + chunk.outro.length;\n\t\t} while (chunk = chunk.next);\n\t\treturn length;\n\t};\n\n\tMagicString.prototype.trimLines = function trimLines () {\n\t\treturn this.trim('[\\\\r\\\\n]');\n\t};\n\n\tMagicString.prototype.trim = function trim (charType) {\n\t\treturn this.trimStart(charType).trimEnd(charType);\n\t};\n\n\tMagicString.prototype.trimEndAborted = function trimEndAborted (charType) {\n\t\tvar rx = new RegExp((charType || '\\\\s') + '+$');\n\n\t\tthis.outro = this.outro.replace(rx, '');\n\t\tif (this.outro.length) { return true; }\n\n\t\tvar chunk = this.lastChunk;\n\n\t\tdo {\n\t\t\tvar end = chunk.end;\n\t\t\tvar aborted = chunk.trimEnd(rx);\n\n\t\t\t// if chunk was trimmed, we have a new lastChunk\n\t\t\tif (chunk.end !== end) {\n\t\t\t\tif (this.lastChunk === chunk) {\n\t\t\t\t\tthis.lastChunk = chunk.next;\n\t\t\t\t}\n\n\t\t\t\tthis.byEnd[chunk.end] = chunk;\n\t\t\t\tthis.byStart[chunk.next.start] = chunk.next;\n\t\t\t\tthis.byEnd[chunk.next.end] = chunk.next;\n\t\t\t}\n\n\t\t\tif (aborted) { return true; }\n\t\t\tchunk = chunk.previous;\n\t\t} while (chunk);\n\n\t\treturn false;\n\t};\n\n\tMagicString.prototype.trimEnd = function trimEnd (charType) {\n\t\tthis.trimEndAborted(charType);\n\t\treturn this;\n\t};\n\tMagicString.prototype.trimStartAborted = function trimStartAborted (charType) {\n\t\tvar rx = new RegExp('^' + (charType || '\\\\s') + '+');\n\n\t\tthis.intro = this.intro.replace(rx, '');\n\t\tif (this.intro.length) { return true; }\n\n\t\tvar chunk = this.firstChunk;\n\n\t\tdo {\n\t\t\tvar end = chunk.end;\n\t\t\tvar aborted = chunk.trimStart(rx);\n\n\t\t\tif (chunk.end !== end) {\n\t\t\t\t// special case...\n\t\t\t\tif (chunk === this.lastChunk) { this.lastChunk = chunk.next; }\n\n\t\t\t\tthis.byEnd[chunk.end] = chunk;\n\t\t\t\tthis.byStart[chunk.next.start] = chunk.next;\n\t\t\t\tthis.byEnd[chunk.next.end] = chunk.next;\n\t\t\t}\n\n\t\t\tif (aborted) { return true; }\n\t\t\tchunk = chunk.next;\n\t\t} while (chunk);\n\n\t\treturn false;\n\t};\n\n\tMagicString.prototype.trimStart = function trimStart (charType) {\n\t\tthis.trimStartAborted(charType);\n\t\treturn this;\n\t};\n\n\tconst UNKNOWN = {};\n\tfunction gather_possible_values(node, set) {\n\t    if (node.type === 'Literal') {\n\t        set.add(node.value);\n\t    }\n\t    else if (node.type === 'ConditionalExpression') {\n\t        gather_possible_values(node.consequent, set);\n\t        gather_possible_values(node.alternate, set);\n\t    }\n\t    else {\n\t        set.add(UNKNOWN);\n\t    }\n\t}\n\n\tvar BlockAppliesToNode;\n\t(function (BlockAppliesToNode) {\n\t    BlockAppliesToNode[BlockAppliesToNode[\"NotPossible\"] = 0] = \"NotPossible\";\n\t    BlockAppliesToNode[BlockAppliesToNode[\"Possible\"] = 1] = \"Possible\";\n\t    BlockAppliesToNode[BlockAppliesToNode[\"UnknownSelectorType\"] = 2] = \"UnknownSelectorType\";\n\t})(BlockAppliesToNode || (BlockAppliesToNode = {}));\n\tclass Selector$1 {\n\t    constructor(node, stylesheet) {\n\t        this.node = node;\n\t        this.stylesheet = stylesheet;\n\t        this.blocks = group_selectors(node);\n\t        // take trailing :global(...) selectors out of consideration\n\t        let i = this.blocks.length;\n\t        while (i > 0) {\n\t            if (!this.blocks[i - 1].global)\n\t                break;\n\t            i -= 1;\n\t        }\n\t        this.local_blocks = this.blocks.slice(0, i);\n\t        this.used = this.local_blocks.length === 0;\n\t    }\n\t    apply(node, stack) {\n\t        const to_encapsulate = [];\n\t        apply_selector(this.local_blocks.slice(), node, stack.slice(), to_encapsulate);\n\t        if (to_encapsulate.length > 0) {\n\t            to_encapsulate.forEach(({ node, block }) => {\n\t                this.stylesheet.nodes_with_css_class.add(node);\n\t                block.should_encapsulate = true;\n\t            });\n\t            this.used = true;\n\t        }\n\t    }\n\t    minify(code) {\n\t        let c = null;\n\t        this.blocks.forEach((block, i) => {\n\t            if (i > 0) {\n\t                if (block.start - c > 1) {\n\t                    code.overwrite(c, block.start, block.combinator.name || ' ');\n\t                }\n\t            }\n\t            c = block.end;\n\t        });\n\t    }\n\t    transform(code, attr, max_amount_class_specificity_increased) {\n\t        const amount_class_specificity_to_increase = max_amount_class_specificity_increased - this.blocks.filter(block => block.should_encapsulate).length;\n\t        attr = attr.repeat(amount_class_specificity_to_increase + 1);\n\t        function encapsulate_block(block) {\n\t            let i = block.selectors.length;\n\t            while (i--) {\n\t                const selector = block.selectors[i];\n\t                if (selector.type === 'PseudoElementSelector' || selector.type === 'PseudoClassSelector') {\n\t                    if (selector.name !== 'root') {\n\t                        if (i === 0)\n\t                            code.prependRight(selector.start, attr);\n\t                    }\n\t                    continue;\n\t                }\n\t                if (selector.type === 'TypeSelector' && selector.name === '*') {\n\t                    code.overwrite(selector.start, selector.end, attr);\n\t                }\n\t                else {\n\t                    code.appendLeft(selector.end, attr);\n\t                }\n\t                break;\n\t            }\n\t        }\n\t        this.blocks.forEach((block) => {\n\t            if (block.global) {\n\t                const selector = block.selectors[0];\n\t                const first = selector.children[0];\n\t                const last = selector.children[selector.children.length - 1];\n\t                code.remove(selector.start, first.start).remove(last.end, selector.end);\n\t            }\n\t            if (block.should_encapsulate)\n\t                encapsulate_block(block);\n\t        });\n\t    }\n\t    validate(component) {\n\t        this.blocks.forEach((block) => {\n\t            let i = block.selectors.length;\n\t            while (i-- > 1) {\n\t                const selector = block.selectors[i];\n\t                if (selector.type === 'PseudoClassSelector' && selector.name === 'global') {\n\t                    component.error(selector, {\n\t                        code: `css-invalid-global`,\n\t                        message: `:global(...) must be the first element in a compound selector`\n\t                    });\n\t                }\n\t            }\n\t        });\n\t        let start = 0;\n\t        let end = this.blocks.length;\n\t        for (; start < end; start += 1) {\n\t            if (!this.blocks[start].global)\n\t                break;\n\t        }\n\t        for (; end > start; end -= 1) {\n\t            if (!this.blocks[end - 1].global)\n\t                break;\n\t        }\n\t        for (let i = start; i < end; i += 1) {\n\t            if (this.blocks[i].global) {\n\t                component.error(this.blocks[i].selectors[0], {\n\t                    code: `css-invalid-global`,\n\t                    message: `:global(...) can be at the start or end of a selector sequence, but not in the middle`\n\t                });\n\t            }\n\t        }\n\t    }\n\t    get_amount_class_specificity_increased() {\n\t        let count = 0;\n\t        for (const block of this.blocks) {\n\t            if (block.should_encapsulate) {\n\t                count++;\n\t            }\n\t        }\n\t        return count;\n\t    }\n\t}\n\tfunction apply_selector(blocks, node, stack, to_encapsulate) {\n\t    const block = blocks.pop();\n\t    if (!block)\n\t        return false;\n\t    if (!node) {\n\t        return blocks.every(block => block.global);\n\t    }\n\t    switch (block_might_apply_to_node(block, node)) {\n\t        case BlockAppliesToNode.NotPossible:\n\t            return false;\n\t        case BlockAppliesToNode.UnknownSelectorType:\n\t            // bail. TODO figure out what these could be\n\t            to_encapsulate.push({ node, block });\n\t            return true;\n\t    }\n\t    if (block.combinator) {\n\t        if (block.combinator.type === 'WhiteSpace') {\n\t            for (const ancestor_block of blocks) {\n\t                if (ancestor_block.global) {\n\t                    continue;\n\t                }\n\t                for (const stack_node of stack) {\n\t                    if (block_might_apply_to_node(ancestor_block, stack_node) !== BlockAppliesToNode.NotPossible) {\n\t                        to_encapsulate.push({ node: stack_node, block: ancestor_block });\n\t                    }\n\t                }\n\t                if (to_encapsulate.length) {\n\t                    to_encapsulate.push({ node, block });\n\t                    return true;\n\t                }\n\t            }\n\t            if (blocks.every(block => block.global)) {\n\t                to_encapsulate.push({ node, block });\n\t                return true;\n\t            }\n\t            return false;\n\t        }\n\t        else if (block.combinator.name === '>') {\n\t            if (apply_selector(blocks, stack.pop(), stack, to_encapsulate)) {\n\t                to_encapsulate.push({ node, block });\n\t                return true;\n\t            }\n\t            return false;\n\t        }\n\t        // TODO other combinators\n\t        to_encapsulate.push({ node, block });\n\t        return true;\n\t    }\n\t    to_encapsulate.push({ node, block });\n\t    return true;\n\t}\n\tfunction block_might_apply_to_node(block, node) {\n\t    let i = block.selectors.length;\n\t    while (i--) {\n\t        const selector = block.selectors[i];\n\t        const name = typeof selector.name === 'string' && selector.name.replace(/\\\\(.)/g, '$1');\n\t        if (selector.type === 'PseudoClassSelector' || selector.type === 'PseudoElementSelector') {\n\t            continue;\n\t        }\n\t        if (selector.type === 'PseudoClassSelector' && name === 'global') {\n\t            // TODO shouldn't see this here... maybe we should enforce that :global(...)\n\t            // cannot be sandwiched between non-global selectors?\n\t            return BlockAppliesToNode.NotPossible;\n\t        }\n\t        if (selector.type === 'ClassSelector') {\n\t            if (!attribute_matches(node, 'class', name, '~=', false) && !node.classes.some(c => c.name === name))\n\t                return BlockAppliesToNode.NotPossible;\n\t        }\n\t        else if (selector.type === 'IdSelector') {\n\t            if (!attribute_matches(node, 'id', name, '=', false))\n\t                return BlockAppliesToNode.NotPossible;\n\t        }\n\t        else if (selector.type === 'AttributeSelector') {\n\t            if (!attribute_matches(node, selector.name.name, selector.value && unquote(selector.value), selector.matcher, selector.flags))\n\t                return BlockAppliesToNode.NotPossible;\n\t        }\n\t        else if (selector.type === 'TypeSelector') {\n\t            if (node.name.toLowerCase() !== name.toLowerCase() && name !== '*')\n\t                return BlockAppliesToNode.NotPossible;\n\t        }\n\t        else {\n\t            return BlockAppliesToNode.UnknownSelectorType;\n\t        }\n\t    }\n\t    return BlockAppliesToNode.Possible;\n\t}\n\tfunction test_attribute(operator, expected_value, case_insensitive, value) {\n\t    if (case_insensitive) {\n\t        expected_value = expected_value.toLowerCase();\n\t        value = value.toLowerCase();\n\t    }\n\t    switch (operator) {\n\t        case '=': return value === expected_value;\n\t        case '~=': return value.split(/\\s/).includes(expected_value);\n\t        case '|=': return `${value}-`.startsWith(`${expected_value}-`);\n\t        case '^=': return value.startsWith(expected_value);\n\t        case '$=': return value.endsWith(expected_value);\n\t        case '*=': return value.includes(expected_value);\n\t        default: throw new Error(`this shouldn't happen`);\n\t    }\n\t}\n\tfunction attribute_matches(node, name, expected_value, operator, case_insensitive) {\n\t    const spread = node.attributes.find(attr => attr.type === 'Spread');\n\t    if (spread)\n\t        return true;\n\t    if (node.bindings.some((binding) => binding.name === name))\n\t        return true;\n\t    const attr = node.attributes.find((attr) => attr.name === name);\n\t    if (!attr)\n\t        return false;\n\t    if (attr.is_true)\n\t        return operator === null;\n\t    if (!expected_value)\n\t        return true;\n\t    if (attr.chunks.length === 1) {\n\t        const value = attr.chunks[0];\n\t        if (!value)\n\t            return false;\n\t        if (value.type === 'Text')\n\t            return test_attribute(operator, expected_value, case_insensitive, value.data);\n\t    }\n\t    const possible_values = new Set();\n\t    let prev_values = [];\n\t    for (const chunk of attr.chunks) {\n\t        const current_possible_values = new Set();\n\t        if (chunk.type === 'Text') {\n\t            current_possible_values.add(chunk.data);\n\t        }\n\t        else {\n\t            gather_possible_values(chunk.node, current_possible_values);\n\t        }\n\t        // impossible to find out all combinations\n\t        if (current_possible_values.has(UNKNOWN))\n\t            return true;\n\t        if (prev_values.length > 0) {\n\t            const start_with_space = [];\n\t            const remaining = [];\n\t            current_possible_values.forEach((current_possible_value) => {\n\t                if (/^\\s/.test(current_possible_value)) {\n\t                    start_with_space.push(current_possible_value);\n\t                }\n\t                else {\n\t                    remaining.push(current_possible_value);\n\t                }\n\t            });\n\t            if (remaining.length > 0) {\n\t                if (start_with_space.length > 0) {\n\t                    prev_values.forEach(prev_value => possible_values.add(prev_value));\n\t                }\n\t                const combined = [];\n\t                prev_values.forEach((prev_value) => {\n\t                    remaining.forEach((value) => {\n\t                        combined.push(prev_value + value);\n\t                    });\n\t                });\n\t                prev_values = combined;\n\t                start_with_space.forEach((value) => {\n\t                    if (/\\s$/.test(value)) {\n\t                        possible_values.add(value);\n\t                    }\n\t                    else {\n\t                        prev_values.push(value);\n\t                    }\n\t                });\n\t                continue;\n\t            }\n\t            else {\n\t                prev_values.forEach(prev_value => possible_values.add(prev_value));\n\t                prev_values = [];\n\t            }\n\t        }\n\t        current_possible_values.forEach((current_possible_value) => {\n\t            if (/\\s$/.test(current_possible_value)) {\n\t                possible_values.add(current_possible_value);\n\t            }\n\t            else {\n\t                prev_values.push(current_possible_value);\n\t            }\n\t        });\n\t        if (prev_values.length < current_possible_values.size) {\n\t            prev_values.push(' ');\n\t        }\n\t        if (prev_values.length > 20) {\n\t            // might grow exponentially, bail out\n\t            return true;\n\t        }\n\t    }\n\t    prev_values.forEach(prev_value => possible_values.add(prev_value));\n\t    if (possible_values.has(UNKNOWN))\n\t        return true;\n\t    for (const value of possible_values) {\n\t        if (test_attribute(operator, expected_value, case_insensitive, value))\n\t            return true;\n\t    }\n\t    return false;\n\t}\n\tfunction unquote(value) {\n\t    if (value.type === 'Identifier')\n\t        return value.name;\n\t    const str = value.value;\n\t    if (str[0] === str[str.length - 1] && str[0] === \"'\" || str[0] === '\"') {\n\t        return str.slice(1, str.length - 1);\n\t    }\n\t    return str;\n\t}\n\tclass Block$2 {\n\t    constructor(combinator) {\n\t        this.combinator = combinator;\n\t        this.global = false;\n\t        this.selectors = [];\n\t        this.start = null;\n\t        this.end = null;\n\t        this.should_encapsulate = false;\n\t    }\n\t    add(selector) {\n\t        if (this.selectors.length === 0) {\n\t            this.start = selector.start;\n\t            this.global = selector.type === 'PseudoClassSelector' && selector.name === 'global';\n\t        }\n\t        this.selectors.push(selector);\n\t        this.end = selector.end;\n\t    }\n\t}\n\tfunction group_selectors(selector) {\n\t    let block = new Block$2(null);\n\t    const blocks = [block];\n\t    selector.children.forEach((child) => {\n\t        if (child.type === 'WhiteSpace' || child.type === 'Combinator') {\n\t            block = new Block$2(child);\n\t            blocks.push(block);\n\t        }\n\t        else {\n\t            block.add(child);\n\t        }\n\t    });\n\t    return blocks;\n\t}\n\n\t// https://github.com/darkskyapp/string-hash/blob/master/index.js\n\tfunction hash(str) {\n\t    str = str.replace(/\\r/g, \"\");\n\t    let hash = 5381;\n\t    let i = str.length;\n\t    while (i--)\n\t        hash = ((hash << 5) - hash) ^ str.charCodeAt(i);\n\t    return (hash >>> 0).toString(36);\n\t}\n\n\tfunction remove_css_prefix(name) {\n\t    return name.replace(/^-((webkit)|(moz)|(o)|(ms))-/, '');\n\t}\n\tconst is_keyframes_node = (node) => remove_css_prefix(node.name) === 'keyframes';\n\tconst at_rule_has_declaration = ({ block }) => block &&\n\t    block.children &&\n\t    block.children.find((node) => node.type === 'Declaration');\n\tfunction minify_declarations(code, start, declarations) {\n\t    let c = start;\n\t    declarations.forEach((declaration, i) => {\n\t        const separator = i > 0 ? ';' : '';\n\t        if ((declaration.node.start - c) > separator.length) {\n\t            code.overwrite(c, declaration.node.start, separator);\n\t        }\n\t        declaration.minify(code);\n\t        c = declaration.node.end;\n\t    });\n\t    return c;\n\t}\n\tclass Rule$1 {\n\t    constructor(node, stylesheet, parent) {\n\t        this.node = node;\n\t        this.parent = parent;\n\t        this.selectors = node.selector.children.map((node) => new Selector$1(node, stylesheet));\n\t        this.declarations = node.block.children.map((node) => new Declaration$1(node));\n\t    }\n\t    apply(node, stack) {\n\t        this.selectors.forEach(selector => selector.apply(node, stack)); // TODO move the logic in here?\n\t    }\n\t    is_used(dev) {\n\t        if (this.parent && this.parent.node.type === 'Atrule' && is_keyframes_node(this.parent.node))\n\t            return true;\n\t        if (this.declarations.length === 0)\n\t            return dev;\n\t        return this.selectors.some(s => s.used);\n\t    }\n\t    minify(code, _dev) {\n\t        let c = this.node.start;\n\t        let started = false;\n\t        this.selectors.forEach((selector) => {\n\t            if (selector.used) {\n\t                const separator = started ? ',' : '';\n\t                if ((selector.node.start - c) > separator.length) {\n\t                    code.overwrite(c, selector.node.start, separator);\n\t                }\n\t                selector.minify(code);\n\t                c = selector.node.end;\n\t                started = true;\n\t            }\n\t        });\n\t        code.remove(c, this.node.block.start);\n\t        c = this.node.block.start + 1;\n\t        c = minify_declarations(code, c, this.declarations);\n\t        code.remove(c, this.node.block.end - 1);\n\t    }\n\t    transform(code, id, keyframes, max_amount_class_specificity_increased) {\n\t        if (this.parent && this.parent.node.type === 'Atrule' && is_keyframes_node(this.parent.node))\n\t            return true;\n\t        const attr = `.${id}`;\n\t        this.selectors.forEach(selector => selector.transform(code, attr, max_amount_class_specificity_increased));\n\t        this.declarations.forEach(declaration => declaration.transform(code, keyframes));\n\t    }\n\t    validate(component) {\n\t        this.selectors.forEach(selector => {\n\t            selector.validate(component);\n\t        });\n\t    }\n\t    warn_on_unused_selector(handler) {\n\t        this.selectors.forEach(selector => {\n\t            if (!selector.used)\n\t                handler(selector);\n\t        });\n\t    }\n\t    get_max_amount_class_specificity_increased() {\n\t        return Math.max(...this.selectors.map(selector => selector.get_amount_class_specificity_increased()));\n\t    }\n\t}\n\tclass Declaration$1 {\n\t    constructor(node) {\n\t        this.node = node;\n\t    }\n\t    transform(code, keyframes) {\n\t        const property = this.node.property && remove_css_prefix(this.node.property.toLowerCase());\n\t        if (property === 'animation' || property === 'animation-name') {\n\t            this.node.value.children.forEach((block) => {\n\t                if (block.type === 'Identifier') {\n\t                    const name = block.name;\n\t                    if (keyframes.has(name)) {\n\t                        code.overwrite(block.start, block.end, keyframes.get(name));\n\t                    }\n\t                }\n\t            });\n\t        }\n\t    }\n\t    minify(code) {\n\t        if (!this.node.property)\n\t            return; // @apply, and possibly other weird cases?\n\t        const c = this.node.start + this.node.property.length;\n\t        const first = this.node.value.children\n\t            ? this.node.value.children[0]\n\t            : this.node.value;\n\t        let start = first.start;\n\t        while (/\\s/.test(code.original[start]))\n\t            start += 1;\n\t        if (start - c > 1) {\n\t            code.overwrite(c, start, ':');\n\t        }\n\t    }\n\t}\n\tclass Atrule$1 {\n\t    constructor(node) {\n\t        this.node = node;\n\t        this.children = [];\n\t        this.declarations = [];\n\t    }\n\t    apply(node, stack) {\n\t        if (this.node.name === 'media' || this.node.name === 'supports') {\n\t            this.children.forEach(child => {\n\t                child.apply(node, stack);\n\t            });\n\t        }\n\t        else if (is_keyframes_node(this.node)) {\n\t            this.children.forEach((rule) => {\n\t                rule.selectors.forEach(selector => {\n\t                    selector.used = true;\n\t                });\n\t            });\n\t        }\n\t    }\n\t    is_used(_dev) {\n\t        return true; // TODO\n\t    }\n\t    minify(code, dev) {\n\t        if (this.node.name === 'media') {\n\t            const expression_char = code.original[this.node.expression.start];\n\t            let c = this.node.start + (expression_char === '(' ? 6 : 7);\n\t            if (this.node.expression.start > c)\n\t                code.remove(c, this.node.expression.start);\n\t            this.node.expression.children.forEach((query) => {\n\t                // TODO minify queries\n\t                c = query.end;\n\t            });\n\t            code.remove(c, this.node.block.start);\n\t        }\n\t        else if (this.node.name === 'supports') {\n\t            let c = this.node.start + 9;\n\t            if (this.node.expression.start - c > 1)\n\t                code.overwrite(c, this.node.expression.start, ' ');\n\t            this.node.expression.children.forEach((query) => {\n\t                // TODO minify queries\n\t                c = query.end;\n\t            });\n\t            code.remove(c, this.node.block.start);\n\t        }\n\t        else {\n\t            let c = this.node.start + this.node.name.length + 1;\n\t            if (this.node.expression) {\n\t                if (this.node.expression.start - c > 1)\n\t                    code.overwrite(c, this.node.expression.start, ' ');\n\t                c = this.node.expression.end;\n\t            }\n\t            if (this.node.block && this.node.block.start - c > 0) {\n\t                code.remove(c, this.node.block.start);\n\t            }\n\t        }\n\t        // TODO other atrules\n\t        if (this.node.block) {\n\t            let c = this.node.block.start + 1;\n\t            if (this.declarations.length) {\n\t                c = minify_declarations(code, c, this.declarations);\n\t                // if the atrule has children, leave the last declaration semicolon alone\n\t                if (this.children.length)\n\t                    c++;\n\t            }\n\t            this.children.forEach(child => {\n\t                if (child.is_used(dev)) {\n\t                    code.remove(c, child.node.start);\n\t                    child.minify(code, dev);\n\t                    c = child.node.end;\n\t                }\n\t            });\n\t            code.remove(c, this.node.block.end - 1);\n\t        }\n\t    }\n\t    transform(code, id, keyframes, max_amount_class_specificity_increased) {\n\t        if (is_keyframes_node(this.node)) {\n\t            this.node.expression.children.forEach(({ type, name, start, end }) => {\n\t                if (type === 'Identifier') {\n\t                    if (name.startsWith('-global-')) {\n\t                        code.remove(start, start + 8);\n\t                        this.children.forEach((rule) => {\n\t                            rule.selectors.forEach(selector => {\n\t                                selector.used = true;\n\t                            });\n\t                        });\n\t                    }\n\t                    else {\n\t                        code.overwrite(start, end, keyframes.get(name));\n\t                    }\n\t                }\n\t            });\n\t        }\n\t        this.children.forEach(child => {\n\t            child.transform(code, id, keyframes, max_amount_class_specificity_increased);\n\t        });\n\t    }\n\t    validate(component) {\n\t        this.children.forEach(child => {\n\t            child.validate(component);\n\t        });\n\t    }\n\t    warn_on_unused_selector(handler) {\n\t        if (this.node.name !== 'media')\n\t            return;\n\t        this.children.forEach(child => {\n\t            child.warn_on_unused_selector(handler);\n\t        });\n\t    }\n\t    get_max_amount_class_specificity_increased() {\n\t        return Math.max(...this.children.map(rule => rule.get_max_amount_class_specificity_increased()));\n\t    }\n\t}\n\tclass Stylesheet {\n\t    constructor(source, ast, filename, dev) {\n\t        this.children = [];\n\t        this.keyframes = new Map();\n\t        this.nodes_with_css_class = new Set();\n\t        this.source = source;\n\t        this.ast = ast;\n\t        this.filename = filename;\n\t        this.dev = dev;\n\t        if (ast.css && ast.css.children.length) {\n\t            this.id = `svelte-${hash(ast.css.content.styles)}`;\n\t            this.has_styles = true;\n\t            const stack = [];\n\t            let depth = 0;\n\t            let current_atrule = null;\n\t            walk(ast.css, {\n\t                enter: (node) => {\n\t                    if (node.type === 'Atrule') {\n\t                        const atrule = new Atrule$1(node);\n\t                        stack.push(atrule);\n\t                        if (current_atrule) {\n\t                            current_atrule.children.push(atrule);\n\t                        }\n\t                        else if (depth <= 1) {\n\t                            this.children.push(atrule);\n\t                        }\n\t                        if (is_keyframes_node(node)) {\n\t                            node.expression.children.forEach((expression) => {\n\t                                if (expression.type === 'Identifier' && !expression.name.startsWith('-global-')) {\n\t                                    this.keyframes.set(expression.name, `${this.id}-${expression.name}`);\n\t                                }\n\t                            });\n\t                        }\n\t                        else if (at_rule_has_declaration(node)) {\n\t                            const at_rule_declarations = node.block.children\n\t                                .filter(node => node.type === 'Declaration')\n\t                                .map(node => new Declaration$1(node));\n\t                            atrule.declarations.push(...at_rule_declarations);\n\t                        }\n\t                        current_atrule = atrule;\n\t                    }\n\t                    if (node.type === 'Rule') {\n\t                        const rule = new Rule$1(node, this, current_atrule);\n\t                        if (current_atrule) {\n\t                            current_atrule.children.push(rule);\n\t                        }\n\t                        else if (depth <= 1) {\n\t                            this.children.push(rule);\n\t                        }\n\t                    }\n\t                    depth += 1;\n\t                },\n\t                leave: (node) => {\n\t                    if (node.type === 'Atrule') {\n\t                        stack.pop();\n\t                        current_atrule = stack[stack.length - 1];\n\t                    }\n\t                    depth -= 1;\n\t                }\n\t            });\n\t        }\n\t        else {\n\t            this.has_styles = false;\n\t        }\n\t    }\n\t    apply(node) {\n\t        if (!this.has_styles)\n\t            return;\n\t        const stack = [];\n\t        let parent = node;\n\t        while (parent = parent.parent) {\n\t            if (parent.type === 'Element')\n\t                stack.unshift(parent);\n\t        }\n\t        for (let i = 0; i < this.children.length; i += 1) {\n\t            const child = this.children[i];\n\t            child.apply(node, stack);\n\t        }\n\t    }\n\t    reify() {\n\t        this.nodes_with_css_class.forEach((node) => {\n\t            node.add_css_class();\n\t        });\n\t    }\n\t    render(file, should_transform_selectors) {\n\t        if (!this.has_styles) {\n\t            return { code: null, map: null };\n\t        }\n\t        const code = new MagicString(this.source);\n\t        walk(this.ast.css, {\n\t            enter: (node) => {\n\t                code.addSourcemapLocation(node.start);\n\t                code.addSourcemapLocation(node.end);\n\t            }\n\t        });\n\t        if (should_transform_selectors) {\n\t            const max = Math.max(...this.children.map(rule => rule.get_max_amount_class_specificity_increased()));\n\t            this.children.forEach((child) => {\n\t                child.transform(code, this.id, this.keyframes, max);\n\t            });\n\t        }\n\t        let c = 0;\n\t        this.children.forEach(child => {\n\t            if (child.is_used(this.dev)) {\n\t                code.remove(c, child.node.start);\n\t                child.minify(code, this.dev);\n\t                c = child.node.end;\n\t            }\n\t        });\n\t        code.remove(c, this.source.length);\n\t        return {\n\t            code: code.toString(),\n\t            map: code.generateMap({\n\t                includeContent: true,\n\t                source: this.filename,\n\t                file\n\t            })\n\t        };\n\t    }\n\t    validate(component) {\n\t        this.children.forEach(child => {\n\t            child.validate(component);\n\t        });\n\t    }\n\t    warn_on_unused_selectors(component) {\n\t        this.children.forEach(child => {\n\t            child.warn_on_unused_selector((selector) => {\n\t                component.warn(selector.node, {\n\t                    code: `css-unused-selector`,\n\t                    message: `Unused CSS selector`\n\t                });\n\t            });\n\t        });\n\t    }\n\t}\n\n\tconst test = typeof process !== 'undefined' && process.env.TEST;\n\n\tclass AbstractBlock extends Node$1 {\n\t    constructor(component, parent, scope, info) {\n\t        super(component, parent, scope, info);\n\t    }\n\t    warn_if_empty_block() {\n\t        if (!this.children || this.children.length > 1)\n\t            return;\n\t        const child = this.children[0];\n\t        if (!child || (child.type === 'Text' && !/[^ \\r\\n\\f\\v\\t]/.test(child.data))) {\n\t            this.component.warn(this, {\n\t                code: 'empty-block',\n\t                message: 'Empty block'\n\t            });\n\t        }\n\t    }\n\t}\n\n\tclass PendingBlock extends AbstractBlock {\n\t    constructor(component, parent, scope, info) {\n\t        super(component, parent, scope, info);\n\t        this.children = map_children(component, parent, scope, info.children);\n\t        if (!info.skip) {\n\t            this.warn_if_empty_block();\n\t        }\n\t    }\n\t}\n\n\tclass ThenBlock extends AbstractBlock {\n\t    constructor(component, parent, scope, info) {\n\t        super(component, parent, scope, info);\n\t        this.scope = scope.child();\n\t        if (parent.then_node) {\n\t            parent.then_contexts.forEach(context => {\n\t                this.scope.add(context.key.name, parent.expression.dependencies, this);\n\t            });\n\t        }\n\t        this.children = map_children(component, parent, this.scope, info.children);\n\t        if (!info.skip) {\n\t            this.warn_if_empty_block();\n\t        }\n\t    }\n\t}\n\n\tclass CatchBlock extends AbstractBlock {\n\t    constructor(component, parent, scope, info) {\n\t        super(component, parent, scope, info);\n\t        this.scope = scope.child();\n\t        if (parent.catch_node) {\n\t            parent.catch_contexts.forEach(context => {\n\t                this.scope.add(context.key.name, parent.expression.dependencies, this);\n\t            });\n\t        }\n\t        this.children = map_children(component, parent, this.scope, info.children);\n\t        if (!info.skip) {\n\t            this.warn_if_empty_block();\n\t        }\n\t    }\n\t}\n\n\tfunction unpack_destructuring(contexts, node, modifier) {\n\t    if (!node)\n\t        return;\n\t    if (node.type === 'Identifier') {\n\t        contexts.push({\n\t            key: node,\n\t            modifier\n\t        });\n\t    }\n\t    else if (node.type === 'RestElement') {\n\t        contexts.push({\n\t            key: node.argument,\n\t            modifier\n\t        });\n\t    }\n\t    else if (node.type === 'ArrayPattern') {\n\t        node.elements.forEach((element, i) => {\n\t            if (element && element.type === 'RestElement') {\n\t                unpack_destructuring(contexts, element, node => x `${modifier(node)}.slice(${i})`);\n\t            }\n\t            else if (element && element.type === 'AssignmentPattern') {\n\t                unpack_destructuring(contexts, element.left, node => x `${modifier(node)}[${i}] !== undefined ? ${modifier(node)}[${i}] : ${element.right}`);\n\t            }\n\t            else {\n\t                unpack_destructuring(contexts, element, node => x `${modifier(node)}[${i}]`);\n\t            }\n\t        });\n\t    }\n\t    else if (node.type === 'ObjectPattern') {\n\t        const used_properties = [];\n\t        node.properties.forEach((property) => {\n\t            if (property.type === 'RestElement') {\n\t                unpack_destructuring(contexts, property.argument, node => x `@object_without_properties(${modifier(node)}, [${used_properties}])`);\n\t            }\n\t            else {\n\t                const key = property.key;\n\t                const value = property.value;\n\t                used_properties.push(x `\"${key.name}\"`);\n\t                if (value.type === 'AssignmentPattern') {\n\t                    unpack_destructuring(contexts, value.left, node => x `${modifier(node)}.${key.name} !== undefined ? ${modifier(node)}.${key.name} : ${value.right}`);\n\t                }\n\t                else {\n\t                    unpack_destructuring(contexts, value, node => x `${modifier(node)}.${key.name}`);\n\t                }\n\t            }\n\t        });\n\t    }\n\t}\n\n\tclass AwaitBlock$1 extends Node$1 {\n\t    constructor(component, parent, scope, info) {\n\t        super(component, parent, scope, info);\n\t        this.expression = new Expression(component, this, scope, info.expression);\n\t        this.then_node = info.value;\n\t        this.catch_node = info.error;\n\t        if (this.then_node) {\n\t            this.then_contexts = [];\n\t            unpack_destructuring(this.then_contexts, info.value, node => node);\n\t        }\n\t        if (this.catch_node) {\n\t            this.catch_contexts = [];\n\t            unpack_destructuring(this.catch_contexts, info.error, node => node);\n\t        }\n\t        this.pending = new PendingBlock(component, this, scope, info.pending);\n\t        this.then = new ThenBlock(component, this, scope, info.then);\n\t        this.catch = new CatchBlock(component, this, scope, info.catch);\n\t    }\n\t}\n\n\tclass EventHandler extends Node$1 {\n\t    constructor(component, parent, template_scope, info) {\n\t        super(component, parent, template_scope, info);\n\t        this.uses_context = false;\n\t        this.can_make_passive = false;\n\t        this.name = info.name;\n\t        this.modifiers = new Set(info.modifiers);\n\t        if (info.expression) {\n\t            this.expression = new Expression(component, this, template_scope, info.expression);\n\t            this.uses_context = this.expression.uses_context;\n\t            if (/FunctionExpression/.test(info.expression.type) && info.expression.params.length === 0) {\n\t                // TODO make this detection more accurate \u2014 if `event.preventDefault` isn't called, and\n\t                // `event` is passed to another function, we can make it passive\n\t                this.can_make_passive = true;\n\t            }\n\t            else if (info.expression.type === 'Identifier') {\n\t                let node = component.node_for_declaration.get(info.expression.name);\n\t                if (node) {\n\t                    if (node.type === 'VariableDeclaration') {\n\t                        // for `const handleClick = () => {...}`, we want the [arrow] function expression node\n\t                        const declarator = node.declarations.find(d => d.id.name === info.expression.name);\n\t                        node = declarator && declarator.init;\n\t                    }\n\t                    if (node && (node.type === 'FunctionExpression' || node.type === 'FunctionDeclaration' || node.type === 'ArrowFunctionExpression') && node.params.length === 0) {\n\t                        this.can_make_passive = true;\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        else {\n\t            this.handler_name = component.get_unique_name(`${sanitize(this.name)}_handler`);\n\t        }\n\t    }\n\t    get reassigned() {\n\t        if (!this.expression) {\n\t            return false;\n\t        }\n\t        const node = this.expression.node;\n\t        if (/FunctionExpression/.test(node.type)) {\n\t            return false;\n\t        }\n\t        return this.expression.dynamic_dependencies().length > 0;\n\t    }\n\t}\n\n\tclass Body extends Node$1 {\n\t    constructor(component, parent, scope, info) {\n\t        super(component, parent, scope, info);\n\t        this.handlers = [];\n\t        info.attributes.forEach(node => {\n\t            if (node.type === 'EventHandler') {\n\t                this.handlers.push(new EventHandler(component, this, scope, node));\n\t            }\n\t        });\n\t    }\n\t}\n\n\tconst pattern = /^\\s*svelte-ignore\\s+([\\s\\S]+)\\s*$/m;\n\tclass Comment$2 extends Node$1 {\n\t    constructor(component, parent, scope, info) {\n\t        super(component, parent, scope, info);\n\t        this.data = info.data;\n\t        const match = pattern.exec(this.data);\n\t        this.ignores = match ? match[1].split(/[^\\S]/).map(x => x.trim()).filter(Boolean) : [];\n\t    }\n\t}\n\n\tclass ElseBlock extends AbstractBlock {\n\t    constructor(component, parent, scope, info) {\n\t        super(component, parent, scope, info);\n\t        this.children = map_children(component, this, scope, info.children);\n\t        this.warn_if_empty_block();\n\t    }\n\t}\n\n\tclass EachBlock$1 extends AbstractBlock {\n\t    constructor(component, parent, scope, info) {\n\t        super(component, parent, scope, info);\n\t        this.has_binding = false;\n\t        this.has_index_binding = false;\n\t        this.expression = new Expression(component, this, scope, info.expression);\n\t        this.context = info.context.name || 'each'; // TODO this is used to facilitate binding; currently fails with destructuring\n\t        this.context_node = info.context;\n\t        this.index = info.index;\n\t        this.scope = scope.child();\n\t        this.contexts = [];\n\t        unpack_destructuring(this.contexts, info.context, node => node);\n\t        this.contexts.forEach(context => {\n\t            this.scope.add(context.key.name, this.expression.dependencies, this);\n\t        });\n\t        if (this.index) {\n\t            // index can only change if this is a keyed each block\n\t            const dependencies = info.key ? this.expression.dependencies : new Set([]);\n\t            this.scope.add(this.index, dependencies, this);\n\t        }\n\t        this.key = info.key\n\t            ? new Expression(component, this, this.scope, info.key)\n\t            : null;\n\t        this.has_animation = false;\n\t        this.children = map_children(component, this, this.scope, info.children);\n\t        if (this.has_animation) {\n\t            if (this.children.length !== 1) {\n\t                const child = this.children.find(child => !!child.animation);\n\t                component.error(child.animation, {\n\t                    code: `invalid-animation`,\n\t                    message: `An element that use the animate directive must be the sole child of a keyed each block`\n\t                });\n\t            }\n\t        }\n\t        this.warn_if_empty_block();\n\t        this.else = info.else\n\t            ? new ElseBlock(component, this, this.scope, info.else)\n\t            : null;\n\t    }\n\t}\n\n\tclass Attribute extends Node$1 {\n\t    constructor(component, parent, scope, info) {\n\t        super(component, parent, scope, info);\n\t        this.scope = scope;\n\t        if (info.type === 'Spread') {\n\t            this.name = null;\n\t            this.is_spread = true;\n\t            this.is_true = false;\n\t            this.expression = new Expression(component, this, scope, info.expression);\n\t            this.dependencies = this.expression.dependencies;\n\t            this.chunks = null;\n\t            this.is_static = false;\n\t        }\n\t        else {\n\t            this.name = info.name;\n\t            this.is_true = info.value === true;\n\t            this.is_static = true;\n\t            this.dependencies = new Set();\n\t            this.chunks = this.is_true\n\t                ? []\n\t                : info.value.map(node => {\n\t                    if (node.type === 'Text')\n\t                        return node;\n\t                    this.is_static = false;\n\t                    const expression = new Expression(component, this, scope, node.expression);\n\t                    add_to_set(this.dependencies, expression.dependencies);\n\t                    return expression;\n\t                });\n\t        }\n\t    }\n\t    get_dependencies() {\n\t        if (this.is_spread)\n\t            return this.expression.dynamic_dependencies();\n\t        const dependencies = new Set();\n\t        this.chunks.forEach(chunk => {\n\t            if (chunk.type === 'Expression') {\n\t                add_to_set(dependencies, chunk.dynamic_dependencies());\n\t            }\n\t        });\n\t        return Array.from(dependencies);\n\t    }\n\t    get_value(block) {\n\t        if (this.is_true)\n\t            return x `true`;\n\t        if (this.chunks.length === 0)\n\t            return x `\"\"`;\n\t        if (this.chunks.length === 1) {\n\t            return this.chunks[0].type === 'Text'\n\t                ? string_literal(this.chunks[0].data)\n\t                : this.chunks[0].manipulate(block);\n\t        }\n\t        let expression = this.chunks\n\t            .map(chunk => chunk.type === 'Text' ? string_literal(chunk.data) : chunk.manipulate(block))\n\t            .reduce((lhs, rhs) => x `${lhs} + ${rhs}`);\n\t        if (this.chunks[0].type !== 'Text') {\n\t            expression = x `\"\" + ${expression}`;\n\t        }\n\t        return expression;\n\t    }\n\t    get_static_value() {\n\t        if (this.is_spread || this.dependencies.size > 0)\n\t            return null;\n\t        return this.is_true\n\t            ? true\n\t            : this.chunks[0]\n\t                // method should be called only when `is_static = true`\n\t                ? this.chunks[0].data\n\t                : '';\n\t    }\n\t    should_cache() {\n\t        return this.is_static\n\t            ? false\n\t            : this.chunks.length === 1\n\t                // @ts-ignore todo: probably error\n\t                ? this.chunks[0].node.type !== 'Identifier' || this.scope.names.has(this.chunks[0].node.name)\n\t                : true;\n\t    }\n\t}\n\n\t// TODO this should live in a specific binding\n\tconst read_only_media_attributes = new Set([\n\t    'duration',\n\t    'buffered',\n\t    'seekable',\n\t    'played',\n\t    'seeking',\n\t    'ended',\n\t    'videoHeight',\n\t    'videoWidth'\n\t]);\n\tclass Binding extends Node$1 {\n\t    constructor(component, parent, scope, info) {\n\t        super(component, parent, scope, info);\n\t        if (info.expression.type !== 'Identifier' && info.expression.type !== 'MemberExpression') {\n\t            component.error(info, {\n\t                code: 'invalid-directive-value',\n\t                message: 'Can only bind to an identifier (e.g. `foo`) or a member expression (e.g. `foo.bar` or `foo[baz]`)'\n\t            });\n\t        }\n\t        this.name = info.name;\n\t        this.expression = new Expression(component, this, scope, info.expression);\n\t        this.raw_expression = JSON.parse(JSON.stringify(info.expression));\n\t        const { name } = get_object(this.expression.node);\n\t        this.is_contextual = scope.names.has(name);\n\t        // make sure we track this as a mutable ref\n\t        if (scope.is_let(name)) {\n\t            component.error(this, {\n\t                code: 'invalid-binding',\n\t                message: 'Cannot bind to a variable declared with the let: directive'\n\t            });\n\t        }\n\t        else if (this.is_contextual) {\n\t            if (scope.is_await(name)) {\n\t                component.error(this, {\n\t                    code: 'invalid-binding',\n\t                    message: 'Cannot bind to a variable declared with {#await ... then} or {:catch} blocks'\n\t                });\n\t            }\n\t            scope.dependencies_for_name.get(name).forEach(name => {\n\t                const variable = component.var_lookup.get(name);\n\t                if (variable) {\n\t                    variable.mutated = true;\n\t                }\n\t            });\n\t        }\n\t        else {\n\t            const variable = component.var_lookup.get(name);\n\t            if (!variable || variable.global)\n\t                component.error(this.expression.node, {\n\t                    code: 'binding-undeclared',\n\t                    message: `${name} is not declared`\n\t                });\n\t            variable[this.expression.node.type === 'MemberExpression' ? 'mutated' : 'reassigned'] = true;\n\t            if (info.expression.type === 'Identifier' && !variable.writable)\n\t                component.error(this.expression.node, {\n\t                    code: 'invalid-binding',\n\t                    message: 'Cannot bind to a variable which is not writable',\n\t                });\n\t        }\n\t        const type = parent.get_static_attribute_value('type');\n\t        this.is_readonly = (dimensions.test(this.name) ||\n\t            (parent.is_media_node && parent.is_media_node() && read_only_media_attributes.has(this.name)) ||\n\t            (parent.name === 'input' && type === 'file') // TODO others?\n\t        );\n\t    }\n\t    is_readonly_media_attribute() {\n\t        return read_only_media_attributes.has(this.name);\n\t    }\n\t}\n\n\tclass Transition extends Node$1 {\n\t    constructor(component, parent, scope, info) {\n\t        super(component, parent, scope, info);\n\t        component.warn_if_undefined(info.name, info, scope);\n\t        this.name = info.name;\n\t        component.add_reference(info.name.split('.')[0]);\n\t        this.directive = info.intro && info.outro ? 'transition' : info.intro ? 'in' : 'out';\n\t        this.is_local = info.modifiers.includes('local');\n\t        if ((info.intro && parent.intro) || (info.outro && parent.outro)) {\n\t            const parent_transition = (parent.intro || parent.outro);\n\t            const message = this.directive === parent_transition.directive\n\t                ? `An element can only have one '${this.directive}' directive`\n\t                : `An element cannot have both ${describe(parent_transition)} directive and ${describe(this)} directive`;\n\t            component.error(info, {\n\t                code: `duplicate-transition`,\n\t                message\n\t            });\n\t        }\n\t        this.expression = info.expression\n\t            ? new Expression(component, this, scope, info.expression, true)\n\t            : null;\n\t    }\n\t}\n\tfunction describe(transition) {\n\t    return transition.directive === 'transition'\n\t        ? `a 'transition'`\n\t        : `an '${transition.directive}'`;\n\t}\n\n\tclass Animation extends Node$1 {\n\t    constructor(component, parent, scope, info) {\n\t        super(component, parent, scope, info);\n\t        component.warn_if_undefined(info.name, info, scope);\n\t        this.name = info.name;\n\t        component.add_reference(info.name.split('.')[0]);\n\t        if (parent.animation) {\n\t            component.error(this, {\n\t                code: `duplicate-animation`,\n\t                message: `An element can only have one 'animate' directive`\n\t            });\n\t        }\n\t        const block = parent.parent;\n\t        if (!block || block.type !== 'EachBlock' || !block.key) {\n\t            // TODO can we relax the 'immediate child' rule?\n\t            component.error(this, {\n\t                code: `invalid-animation`,\n\t                message: `An element that use the animate directive must be the immediate child of a keyed each block`\n\t            });\n\t        }\n\t        block.has_animation = true;\n\t        this.expression = info.expression\n\t            ? new Expression(component, this, scope, info.expression, true)\n\t            : null;\n\t    }\n\t}\n\n\tclass Class extends Node$1 {\n\t    constructor(component, parent, scope, info) {\n\t        super(component, parent, scope, info);\n\t        this.name = info.name;\n\t        this.expression = info.expression\n\t            ? new Expression(component, this, scope, info.expression)\n\t            : null;\n\t    }\n\t}\n\n\t// Whitespace inside one of these elements will not result in\n\t// a whitespace node being created in any circumstances. (This\n\t// list is almost certainly very incomplete)\n\tconst elements_without_text = new Set([\n\t    'audio',\n\t    'datalist',\n\t    'dl',\n\t    'optgroup',\n\t    'select',\n\t    'video',\n\t]);\n\tclass Text$1 extends Node$1 {\n\t    constructor(component, parent, scope, info) {\n\t        super(component, parent, scope, info);\n\t        this.data = info.data;\n\t        this.synthetic = info.synthetic || false;\n\t    }\n\t    should_skip() {\n\t        if (/\\S/.test(this.data))\n\t            return false;\n\t        const parent_element = this.find_nearest(/(?:Element|InlineComponent|Head)/);\n\t        if (!parent_element)\n\t            return false;\n\t        if (parent_element.type === 'Head')\n\t            return true;\n\t        if (parent_element.type === 'InlineComponent')\n\t            return parent_element.children.length === 1 && this === parent_element.children[0];\n\t        // svg namespace exclusions\n\t        if (/svg$/.test(parent_element.namespace)) {\n\t            if (this.prev && this.prev.type === \"Element\" && this.prev.name === \"tspan\")\n\t                return false;\n\t        }\n\t        return parent_element.namespace || elements_without_text.has(parent_element.name);\n\t    }\n\t}\n\n\tconst applicable = new Set(['Identifier', 'ObjectExpression', 'ArrayExpression', 'Property']);\n\tclass Let extends Node$1 {\n\t    constructor(component, parent, scope, info) {\n\t        super(component, parent, scope, info);\n\t        this.names = [];\n\t        this.name = { type: 'Identifier', name: info.name };\n\t        const { names } = this;\n\t        if (info.expression) {\n\t            this.value = info.expression;\n\t            walk(info.expression, {\n\t                enter(node) {\n\t                    if (!applicable.has(node.type)) {\n\t                        component.error(node, {\n\t                            code: 'invalid-let',\n\t                            message: `let directive value must be an identifier or an object/array pattern`\n\t                        });\n\t                    }\n\t                    if (node.type === 'Identifier') {\n\t                        names.push(node.name);\n\t                    }\n\t                    // slightly unfortunate hack\n\t                    if (node.type === 'ArrayExpression') {\n\t                        node.type = 'ArrayPattern';\n\t                    }\n\t                    if (node.type === 'ObjectExpression') {\n\t                        node.type = 'ObjectPattern';\n\t                    }\n\t                }\n\t            });\n\t        }\n\t        else {\n\t            names.push(this.name.name);\n\t        }\n\t    }\n\t}\n\n\tconst svg$1 = /^(?:altGlyph|altGlyphDef|altGlyphItem|animate|animateColor|animateMotion|animateTransform|circle|clipPath|color-profile|cursor|defs|desc|discard|ellipse|feBlend|feColorMatrix|feComponentTransfer|feComposite|feConvolveMatrix|feDiffuseLighting|feDisplacementMap|feDistantLight|feDropShadow|feFlood|feFuncA|feFuncB|feFuncG|feFuncR|feGaussianBlur|feImage|feMerge|feMergeNode|feMorphology|feOffset|fePointLight|feSpecularLighting|feSpotLight|feTile|feTurbulence|filter|font|font-face|font-face-format|font-face-name|font-face-src|font-face-uri|foreignObject|g|glyph|glyphRef|hatch|hatchpath|hkern|image|line|linearGradient|marker|mask|mesh|meshgradient|meshpatch|meshrow|metadata|missing-glyph|mpath|path|pattern|polygon|polyline|radialGradient|rect|set|solidcolor|stop|svg|switch|symbol|text|textPath|tref|tspan|unknown|use|view|vkern)$/;\n\tconst aria_attributes = 'activedescendant atomic autocomplete busy checked colcount colindex colspan controls current describedby details disabled dropeffect errormessage expanded flowto grabbed haspopup hidden invalid keyshortcuts label labelledby level live modal multiline multiselectable orientation owns placeholder posinset pressed readonly relevant required roledescription rowcount rowindex rowspan selected setsize sort valuemax valuemin valuenow valuetext'.split(' ');\n\tconst aria_attribute_set = new Set(aria_attributes);\n\tconst aria_roles = 'alert alertdialog application article banner blockquote button caption cell checkbox code columnheader combobox complementary contentinfo definition deletion dialog directory document emphasis feed figure form generic grid gridcell group heading img link list listbox listitem log main marquee math meter menu menubar menuitem menuitemcheckbox menuitemradio navigation none note option paragraph presentation progressbar radio radiogroup region row rowgroup rowheader scrollbar search searchbox separator slider spinbutton status strong subscript superscript switch tab table tablist tabpanel term textbox time timer toolbar tooltip tree treegrid treeitem'.split(' ');\n\tconst aria_role_set = new Set(aria_roles);\n\tconst a11y_required_attributes = {\n\t    a: ['href'],\n\t    area: ['alt', 'aria-label', 'aria-labelledby'],\n\t    // html-has-lang\n\t    html: ['lang'],\n\t    // iframe-has-title\n\t    iframe: ['title'],\n\t    img: ['alt'],\n\t    object: ['title', 'aria-label', 'aria-labelledby']\n\t};\n\tconst a11y_distracting_elements = new Set([\n\t    'blink',\n\t    'marquee'\n\t]);\n\tconst a11y_required_content = new Set([\n\t    // anchor-has-content\n\t    'a',\n\t    // heading-has-content\n\t    'h1',\n\t    'h2',\n\t    'h3',\n\t    'h4',\n\t    'h5',\n\t    'h6'\n\t]);\n\tconst a11y_no_onchange = new Set([\n\t    'select',\n\t    'option'\n\t]);\n\tconst invisible_elements = new Set(['meta', 'html', 'script', 'style']);\n\tconst valid_modifiers = new Set([\n\t    'preventDefault',\n\t    'stopPropagation',\n\t    'capture',\n\t    'once',\n\t    'passive',\n\t    'self'\n\t]);\n\tconst passive_events = new Set([\n\t    'wheel',\n\t    'touchstart',\n\t    'touchmove',\n\t    'touchend',\n\t    'touchcancel'\n\t]);\n\tfunction get_namespace(parent, element, explicit_namespace) {\n\t    const parent_element = parent.find_nearest(/^Element/);\n\t    if (!parent_element) {\n\t        return explicit_namespace || (svg$1.test(element.name)\n\t            ? namespaces.svg\n\t            : null);\n\t    }\n\t    if (svg$1.test(element.name.toLowerCase()))\n\t        return namespaces.svg;\n\t    if (parent_element.name.toLowerCase() === 'foreignobject')\n\t        return null;\n\t    return parent_element.namespace;\n\t}\n\tclass Element$1 extends Node$1 {\n\t    constructor(component, parent, scope, info) {\n\t        super(component, parent, scope, info);\n\t        this.attributes = [];\n\t        this.actions = [];\n\t        this.bindings = [];\n\t        this.classes = [];\n\t        this.handlers = [];\n\t        this.lets = [];\n\t        this.intro = null;\n\t        this.outro = null;\n\t        this.animation = null;\n\t        this.name = info.name;\n\t        this.namespace = get_namespace(parent, this, component.namespace);\n\t        if (this.name === 'textarea') {\n\t            if (info.children.length > 0) {\n\t                const value_attribute = info.attributes.find(node => node.name === 'value');\n\t                if (value_attribute) {\n\t                    component.error(value_attribute, {\n\t                        code: `textarea-duplicate-value`,\n\t                        message: `A <textarea> can have either a value attribute or (equivalently) child content, but not both`\n\t                    });\n\t                }\n\t                // this is an egregious hack, but it's the easiest way to get <textarea>\n\t                // children treated the same way as a value attribute\n\t                info.attributes.push({\n\t                    type: 'Attribute',\n\t                    name: 'value',\n\t                    value: info.children\n\t                });\n\t                info.children = [];\n\t            }\n\t        }\n\t        if (this.name === 'option') {\n\t            // Special case \u2014 treat these the same way:\n\t            //   <option>{foo}</option>\n\t            //   <option value={foo}>{foo}</option>\n\t            const value_attribute = info.attributes.find(attribute => attribute.name === 'value');\n\t            if (!value_attribute) {\n\t                info.attributes.push({\n\t                    type: 'Attribute',\n\t                    name: 'value',\n\t                    value: info.children,\n\t                    synthetic: true\n\t                });\n\t            }\n\t        }\n\t        const has_let = info.attributes.some(node => node.type === 'Let');\n\t        if (has_let) {\n\t            scope = scope.child();\n\t        }\n\t        // Binding relies on Attribute, defer its evaluation\n\t        const order = ['Binding']; // everything else is -1\n\t        info.attributes.sort((a, b) => order.indexOf(a.type) - order.indexOf(b.type));\n\t        info.attributes.forEach(node => {\n\t            switch (node.type) {\n\t                case 'Action':\n\t                    this.actions.push(new Action(component, this, scope, node));\n\t                    break;\n\t                case 'Attribute':\n\t                case 'Spread':\n\t                    // special case\n\t                    if (node.name === 'xmlns')\n\t                        this.namespace = node.value[0].data;\n\t                    this.attributes.push(new Attribute(component, this, scope, node));\n\t                    break;\n\t                case 'Binding':\n\t                    this.bindings.push(new Binding(component, this, scope, node));\n\t                    break;\n\t                case 'Class':\n\t                    this.classes.push(new Class(component, this, scope, node));\n\t                    break;\n\t                case 'EventHandler':\n\t                    this.handlers.push(new EventHandler(component, this, scope, node));\n\t                    break;\n\t                case 'Let': {\n\t                    const l = new Let(component, this, scope, node);\n\t                    this.lets.push(l);\n\t                    const dependencies = new Set([l.name.name]);\n\t                    l.names.forEach(name => {\n\t                        scope.add(name, dependencies, this);\n\t                    });\n\t                    break;\n\t                }\n\t                case 'Transition':\n\t                    {\n\t                        const transition = new Transition(component, this, scope, node);\n\t                        if (node.intro)\n\t                            this.intro = transition;\n\t                        if (node.outro)\n\t                            this.outro = transition;\n\t                        break;\n\t                    }\n\t                case 'Animation':\n\t                    this.animation = new Animation(component, this, scope, node);\n\t                    break;\n\t                default:\n\t                    throw new Error(`Not implemented: ${node.type}`);\n\t            }\n\t        });\n\t        this.scope = scope;\n\t        this.children = map_children(component, this, this.scope, info.children);\n\t        this.validate();\n\t        component.stylesheet.apply(this);\n\t    }\n\t    validate() {\n\t        if (a11y_distracting_elements.has(this.name)) {\n\t            // no-distracting-elements\n\t            this.component.warn(this, {\n\t                code: `a11y-distracting-elements`,\n\t                message: `A11y: Avoid <${this.name}> elements`\n\t            });\n\t        }\n\t        if (this.name === 'figcaption') {\n\t            let { parent } = this;\n\t            let is_figure_parent = false;\n\t            while (parent) {\n\t                if (parent.name === 'figure') {\n\t                    is_figure_parent = true;\n\t                    break;\n\t                }\n\t                if (parent.type === 'Element') {\n\t                    break;\n\t                }\n\t                parent = parent.parent;\n\t            }\n\t            if (!is_figure_parent) {\n\t                this.component.warn(this, {\n\t                    code: `a11y-structure`,\n\t                    message: `A11y: <figcaption> must be an immediate child of <figure>`\n\t                });\n\t            }\n\t        }\n\t        if (this.name === 'figure') {\n\t            const children = this.children.filter(node => {\n\t                if (node.type === 'Comment')\n\t                    return false;\n\t                if (node.type === 'Text')\n\t                    return /\\S/.test(node.data);\n\t                return true;\n\t            });\n\t            const index = children.findIndex(child => child.name === 'figcaption');\n\t            if (index !== -1 && (index !== 0 && index !== children.length - 1)) {\n\t                this.component.warn(children[index], {\n\t                    code: `a11y-structure`,\n\t                    message: `A11y: <figcaption> must be first or last child of <figure>`\n\t                });\n\t            }\n\t        }\n\t        this.validate_attributes();\n\t        this.validate_special_cases();\n\t        this.validate_bindings();\n\t        this.validate_content();\n\t        this.validate_event_handlers();\n\t    }\n\t    validate_attributes() {\n\t        const { component, parent } = this;\n\t        const attribute_map = new Map();\n\t        this.attributes.forEach(attribute => {\n\t            if (attribute.is_spread)\n\t                return;\n\t            const name = attribute.name.toLowerCase();\n\t            // aria-props\n\t            if (name.startsWith('aria-')) {\n\t                if (invisible_elements.has(this.name)) {\n\t                    // aria-unsupported-elements\n\t                    component.warn(attribute, {\n\t                        code: `a11y-aria-attributes`,\n\t                        message: `A11y: <${this.name}> should not have aria-* attributes`\n\t                    });\n\t                }\n\t                const type = name.slice(5);\n\t                if (!aria_attribute_set.has(type)) {\n\t                    const match = fuzzymatch(type, aria_attributes);\n\t                    let message = `A11y: Unknown aria attribute 'aria-${type}'`;\n\t                    if (match)\n\t                        message += ` (did you mean '${match}'?)`;\n\t                    component.warn(attribute, {\n\t                        code: `a11y-unknown-aria-attribute`,\n\t                        message\n\t                    });\n\t                }\n\t                if (name === 'aria-hidden' && /^h[1-6]$/.test(this.name)) {\n\t                    component.warn(attribute, {\n\t                        code: `a11y-hidden`,\n\t                        message: `A11y: <${this.name}> element should not be hidden`\n\t                    });\n\t                }\n\t            }\n\t            // aria-role\n\t            if (name === 'role') {\n\t                if (invisible_elements.has(this.name)) {\n\t                    // aria-unsupported-elements\n\t                    component.warn(attribute, {\n\t                        code: `a11y-misplaced-role`,\n\t                        message: `A11y: <${this.name}> should not have role attribute`\n\t                    });\n\t                }\n\t                const value = attribute.get_static_value();\n\t                // @ts-ignore\n\t                if (value && !aria_role_set.has(value)) {\n\t                    // @ts-ignore\n\t                    const match = fuzzymatch(value, aria_roles);\n\t                    let message = `A11y: Unknown role '${value}'`;\n\t                    if (match)\n\t                        message += ` (did you mean '${match}'?)`;\n\t                    component.warn(attribute, {\n\t                        code: `a11y-unknown-role`,\n\t                        message\n\t                    });\n\t                }\n\t            }\n\t            // no-access-key\n\t            if (name === 'accesskey') {\n\t                component.warn(attribute, {\n\t                    code: `a11y-accesskey`,\n\t                    message: `A11y: Avoid using accesskey`\n\t                });\n\t            }\n\t            // no-autofocus\n\t            if (name === 'autofocus') {\n\t                component.warn(attribute, {\n\t                    code: `a11y-autofocus`,\n\t                    message: `A11y: Avoid using autofocus`\n\t                });\n\t            }\n\t            // scope\n\t            if (name === 'scope' && this.name !== 'th') {\n\t                component.warn(attribute, {\n\t                    code: `a11y-misplaced-scope`,\n\t                    message: `A11y: The scope attribute should only be used with <th> elements`\n\t                });\n\t            }\n\t            // tabindex-no-positive\n\t            if (name === 'tabindex') {\n\t                const value = attribute.get_static_value();\n\t                // @ts-ignore todo is tabindex=true correct case?\n\t                if (!isNaN(value) && +value > 0) {\n\t                    component.warn(attribute, {\n\t                        code: `a11y-positive-tabindex`,\n\t                        message: `A11y: avoid tabindex values above zero`\n\t                    });\n\t                }\n\t            }\n\t            if (/(^[0-9-.])|[\\^$@%&#?!|()[\\]{}^*+~;]/.test(name)) {\n\t                component.error(attribute, {\n\t                    code: `illegal-attribute`,\n\t                    message: `'${name}' is not a valid attribute name`,\n\t                });\n\t            }\n\t            if (name === 'slot') {\n\t                if (!attribute.is_static) {\n\t                    component.error(attribute, {\n\t                        code: `invalid-slot-attribute`,\n\t                        message: `slot attribute cannot have a dynamic value`\n\t                    });\n\t                }\n\t                if (component.slot_outlets.has(name)) {\n\t                    component.error(attribute, {\n\t                        code: `duplicate-slot-attribute`,\n\t                        message: `Duplicate '${name}' slot`\n\t                    });\n\t                    component.slot_outlets.add(name);\n\t                }\n\t                if (!(parent.type === 'InlineComponent' || within_custom_element(parent))) {\n\t                    component.error(attribute, {\n\t                        code: `invalid-slotted-content`,\n\t                        message: `Element with a slot='...' attribute must be a child of a component or a descendant of a custom element`,\n\t                    });\n\t                }\n\t            }\n\t            if (name === 'is') {\n\t                component.warn(attribute, {\n\t                    code: 'avoid-is',\n\t                    message: `The 'is' attribute is not supported cross-browser and should be avoided`\n\t                });\n\t            }\n\t            attribute_map.set(attribute.name, attribute);\n\t        });\n\t    }\n\t    validate_special_cases() {\n\t        const { component, attributes, handlers } = this;\n\t        const attribute_map = new Map();\n\t        const handlers_map = new Map();\n\t        attributes.forEach(attribute => (attribute_map.set(attribute.name, attribute)));\n\t        handlers.forEach(handler => (handlers_map.set(handler.name, handler)));\n\t        if (this.name === 'a') {\n\t            const href_attribute = attribute_map.get('href') || attribute_map.get('xlink:href');\n\t            const id_attribute = attribute_map.get('id');\n\t            const name_attribute = attribute_map.get('name');\n\t            if (href_attribute) {\n\t                const href_value = href_attribute.get_static_value();\n\t                if (href_value === '' || href_value === '#' || /^\\W*javascript:/i.test(href_value)) {\n\t                    component.warn(href_attribute, {\n\t                        code: `a11y-invalid-attribute`,\n\t                        message: `A11y: '${href_value}' is not a valid ${href_attribute.name} attribute`\n\t                    });\n\t                }\n\t            }\n\t            else {\n\t                const id_attribute_valid = id_attribute && id_attribute.get_static_value() !== '';\n\t                const name_attribute_valid = name_attribute && name_attribute.get_static_value() !== '';\n\t                if (!id_attribute_valid && !name_attribute_valid) {\n\t                    component.warn(this, {\n\t                        code: `a11y-missing-attribute`,\n\t                        message: `A11y: <a> element should have an href attribute`\n\t                    });\n\t                }\n\t            }\n\t        }\n\t        else {\n\t            const required_attributes = a11y_required_attributes[this.name];\n\t            if (required_attributes) {\n\t                const has_attribute = required_attributes.some(name => attribute_map.has(name));\n\t                if (!has_attribute) {\n\t                    should_have_attribute(this, required_attributes);\n\t                }\n\t            }\n\t        }\n\t        if (this.name === 'input') {\n\t            const type = attribute_map.get('type');\n\t            if (type && type.get_static_value() === 'image') {\n\t                const required_attributes = ['alt', 'aria-label', 'aria-labelledby'];\n\t                const has_attribute = required_attributes.some(name => attribute_map.has(name));\n\t                if (!has_attribute) {\n\t                    should_have_attribute(this, required_attributes, 'input type=\"image\"');\n\t                }\n\t            }\n\t        }\n\t        if (this.name === 'img') {\n\t            const alt_attribute = attribute_map.get('alt');\n\t            const aria_hidden_attribute = attribute_map.get('aria-hidden');\n\t            const aria_hidden_exist = aria_hidden_attribute && aria_hidden_attribute.get_static_value();\n\t            if (alt_attribute && !aria_hidden_exist) {\n\t                const alt_value = alt_attribute.get_static_value();\n\t                if (/\\b(image|picture|photo)\\b/i.test(alt_value)) {\n\t                    component.warn(this, {\n\t                        code: `a11y-img-redundant-alt`,\n\t                        message: `A11y: Screenreaders already announce <img> elements as an image.`\n\t                    });\n\t                }\n\t            }\n\t        }\n\t        if (a11y_no_onchange.has(this.name)) {\n\t            if (handlers_map.has('change') && !handlers_map.has('blur')) {\n\t                component.warn(this, {\n\t                    code: `a11y-no-onchange`,\n\t                    message: `A11y: on:blur must be used instead of on:change, unless absolutely necessary and it causes no negative consequences for keyboard only or screen reader users.`\n\t                });\n\t            }\n\t        }\n\t    }\n\t    validate_bindings() {\n\t        const { component } = this;\n\t        const check_type_attribute = () => {\n\t            const attribute = this.attributes.find((attribute) => attribute.name === 'type');\n\t            if (!attribute)\n\t                return null;\n\t            if (!attribute.is_static) {\n\t                component.error(attribute, {\n\t                    code: `invalid-type`,\n\t                    message: `'type' attribute cannot be dynamic if input uses two-way binding`\n\t                });\n\t            }\n\t            const value = attribute.get_static_value();\n\t            if (value === true) {\n\t                component.error(attribute, {\n\t                    code: `missing-type`,\n\t                    message: `'type' attribute must be specified`\n\t                });\n\t            }\n\t            return value;\n\t        };\n\t        this.bindings.forEach(binding => {\n\t            const { name } = binding;\n\t            if (name === 'value') {\n\t                if (this.name !== 'input' &&\n\t                    this.name !== 'textarea' &&\n\t                    this.name !== 'select') {\n\t                    component.error(binding, {\n\t                        code: `invalid-binding`,\n\t                        message: `'value' is not a valid binding on <${this.name}> elements`\n\t                    });\n\t                }\n\t                if (this.name === 'select') {\n\t                    const attribute = this.attributes.find((attribute) => attribute.name === 'multiple');\n\t                    if (attribute && !attribute.is_static) {\n\t                        component.error(attribute, {\n\t                            code: `dynamic-multiple-attribute`,\n\t                            message: `'multiple' attribute cannot be dynamic if select uses two-way binding`\n\t                        });\n\t                    }\n\t                }\n\t                else {\n\t                    check_type_attribute();\n\t                }\n\t            }\n\t            else if (name === 'checked' || name === 'indeterminate') {\n\t                if (this.name !== 'input') {\n\t                    component.error(binding, {\n\t                        code: `invalid-binding`,\n\t                        message: `'${name}' is not a valid binding on <${this.name}> elements`\n\t                    });\n\t                }\n\t                const type = check_type_attribute();\n\t                if (type !== 'checkbox') {\n\t                    let message = `'${name}' binding can only be used with <input type=\"checkbox\">`;\n\t                    if (type === 'radio')\n\t                        message += ` \u2014 for <input type=\"radio\">, use 'group' binding`;\n\t                    component.error(binding, { code: `invalid-binding`, message });\n\t                }\n\t            }\n\t            else if (name === 'group') {\n\t                if (this.name !== 'input') {\n\t                    component.error(binding, {\n\t                        code: `invalid-binding`,\n\t                        message: `'group' is not a valid binding on <${this.name}> elements`\n\t                    });\n\t                }\n\t                const type = check_type_attribute();\n\t                if (type !== 'checkbox' && type !== 'radio') {\n\t                    component.error(binding, {\n\t                        code: `invalid-binding`,\n\t                        message: `'group' binding can only be used with <input type=\"checkbox\"> or <input type=\"radio\">`\n\t                    });\n\t                }\n\t            }\n\t            else if (name === 'files') {\n\t                if (this.name !== 'input') {\n\t                    component.error(binding, {\n\t                        code: `invalid-binding`,\n\t                        message: `'files' is not a valid binding on <${this.name}> elements`\n\t                    });\n\t                }\n\t                const type = check_type_attribute();\n\t                if (type !== 'file') {\n\t                    component.error(binding, {\n\t                        code: `invalid-binding`,\n\t                        message: `'files' binding can only be used with <input type=\"file\">`\n\t                    });\n\t                }\n\t            }\n\t            else if (name === 'open') {\n\t                if (this.name !== 'details') {\n\t                    component.error(binding, {\n\t                        code: `invalid-binding`,\n\t                        message: `'${name}' binding can only be used with <details>`\n\t                    });\n\t                }\n\t            }\n\t            else if (name === 'currentTime' ||\n\t                name === 'duration' ||\n\t                name === 'paused' ||\n\t                name === 'buffered' ||\n\t                name === 'seekable' ||\n\t                name === 'played' ||\n\t                name === 'volume' ||\n\t                name === 'muted' ||\n\t                name === 'playbackRate' ||\n\t                name === 'seeking' ||\n\t                name === 'ended') {\n\t                if (this.name !== 'audio' && this.name !== 'video') {\n\t                    component.error(binding, {\n\t                        code: `invalid-binding`,\n\t                        message: `'${name}' binding can only be used with <audio> or <video>`\n\t                    });\n\t                }\n\t            }\n\t            else if (name === 'videoHeight' ||\n\t                name === 'videoWidth') {\n\t                if (this.name !== 'video') {\n\t                    component.error(binding, {\n\t                        code: `invalid-binding`,\n\t                        message: `'${name}' binding can only be used with <video>`\n\t                    });\n\t                }\n\t            }\n\t            else if (dimensions.test(name)) {\n\t                if (this.name === 'svg' && (name === 'offsetWidth' || name === 'offsetHeight')) {\n\t                    component.error(binding, {\n\t                        code: 'invalid-binding',\n\t                        message: `'${binding.name}' is not a valid binding on <svg>. Use '${name.replace('offset', 'client')}' instead`\n\t                    });\n\t                }\n\t                else if (svg$1.test(this.name)) {\n\t                    component.error(binding, {\n\t                        code: 'invalid-binding',\n\t                        message: `'${binding.name}' is not a valid binding on SVG elements`\n\t                    });\n\t                }\n\t                else if (is_void(this.name)) {\n\t                    component.error(binding, {\n\t                        code: 'invalid-binding',\n\t                        message: `'${binding.name}' is not a valid binding on void elements like <${this.name}>. Use a wrapper element instead`\n\t                    });\n\t                }\n\t            }\n\t            else if (name === 'textContent' ||\n\t                name === 'innerHTML') {\n\t                const contenteditable = this.attributes.find((attribute) => attribute.name === 'contenteditable');\n\t                if (!contenteditable) {\n\t                    component.error(binding, {\n\t                        code: `missing-contenteditable-attribute`,\n\t                        message: `'contenteditable' attribute is required for textContent and innerHTML two-way bindings`\n\t                    });\n\t                }\n\t                else if (contenteditable && !contenteditable.is_static) {\n\t                    component.error(contenteditable, {\n\t                        code: `dynamic-contenteditable-attribute`,\n\t                        message: `'contenteditable' attribute cannot be dynamic if element uses two-way binding`\n\t                    });\n\t                }\n\t            }\n\t            else if (name !== 'this') {\n\t                component.error(binding, {\n\t                    code: `invalid-binding`,\n\t                    message: `'${binding.name}' is not a valid binding`\n\t                });\n\t            }\n\t        });\n\t    }\n\t    validate_content() {\n\t        if (!a11y_required_content.has(this.name))\n\t            return;\n\t        if (this.bindings\n\t            .some((binding) => ['textContent', 'innerHTML'].includes(binding.name)))\n\t            return;\n\t        if (this.children.length === 0) {\n\t            this.component.warn(this, {\n\t                code: `a11y-missing-content`,\n\t                message: `A11y: <${this.name}> element should have child content`\n\t            });\n\t        }\n\t    }\n\t    validate_event_handlers() {\n\t        const { component } = this;\n\t        this.handlers.forEach(handler => {\n\t            if (handler.modifiers.has('passive') && handler.modifiers.has('preventDefault')) {\n\t                component.error(handler, {\n\t                    code: 'invalid-event-modifier',\n\t                    message: `The 'passive' and 'preventDefault' modifiers cannot be used together`\n\t                });\n\t            }\n\t            handler.modifiers.forEach(modifier => {\n\t                if (!valid_modifiers.has(modifier)) {\n\t                    component.error(handler, {\n\t                        code: 'invalid-event-modifier',\n\t                        message: `Valid event modifiers are ${list$1(Array.from(valid_modifiers))}`\n\t                    });\n\t                }\n\t                if (modifier === 'passive') {\n\t                    if (passive_events.has(handler.name)) {\n\t                        if (handler.can_make_passive) {\n\t                            component.warn(handler, {\n\t                                code: 'redundant-event-modifier',\n\t                                message: `Touch event handlers that don't use the 'event' object are passive by default`\n\t                            });\n\t                        }\n\t                    }\n\t                    else {\n\t                        component.warn(handler, {\n\t                            code: 'redundant-event-modifier',\n\t                            message: `The passive modifier only works with wheel and touch events`\n\t                        });\n\t                    }\n\t                }\n\t                if (component.compile_options.legacy && (modifier === 'once' || modifier === 'passive')) {\n\t                    // TODO this could be supported, but it would need a few changes to\n\t                    // how event listeners work\n\t                    component.error(handler, {\n\t                        code: 'invalid-event-modifier',\n\t                        message: `The '${modifier}' modifier cannot be used in legacy mode`\n\t                    });\n\t                }\n\t            });\n\t            if (passive_events.has(handler.name) && handler.can_make_passive && !handler.modifiers.has('preventDefault')) {\n\t                // touch/wheel events should be passive by default\n\t                handler.modifiers.add('passive');\n\t            }\n\t        });\n\t    }\n\t    is_media_node() {\n\t        return this.name === 'audio' || this.name === 'video';\n\t    }\n\t    add_css_class() {\n\t        if (this.attributes.some(attr => attr.is_spread)) {\n\t            this.needs_manual_style_scoping = true;\n\t            return;\n\t        }\n\t        const { id } = this.component.stylesheet;\n\t        const class_attribute = this.attributes.find(a => a.name === 'class');\n\t        if (class_attribute && !class_attribute.is_true) {\n\t            if (class_attribute.chunks.length === 1 && class_attribute.chunks[0].type === 'Text') {\n\t                class_attribute.chunks[0].data += ` ${id}`;\n\t            }\n\t            else {\n\t                class_attribute.chunks.push(new Text$1(this.component, this, this.scope, {\n\t                    type: 'Text',\n\t                    data: ` ${id}`,\n\t                    synthetic: true\n\t                }));\n\t            }\n\t        }\n\t        else {\n\t            this.attributes.push(new Attribute(this.component, this, this.scope, {\n\t                type: 'Attribute',\n\t                name: 'class',\n\t                value: [{ type: 'Text', data: id, synthetic: true }]\n\t            }));\n\t        }\n\t    }\n\t}\n\tfunction should_have_attribute(node, attributes, name = node.name) {\n\t    const article = /^[aeiou]/.test(attributes[0]) ? 'an' : 'a';\n\t    const sequence = attributes.length > 1 ?\n\t        attributes.slice(0, -1).join(', ') + ` or ${attributes[attributes.length - 1]}` :\n\t        attributes[0];\n\t    node.component.warn(node, {\n\t        code: `a11y-missing-attribute`,\n\t        message: `A11y: <${name}> element should have ${article} ${sequence} attribute`\n\t    });\n\t}\n\tfunction within_custom_element(parent) {\n\t    while (parent) {\n\t        if (parent.type === 'InlineComponent')\n\t            return false;\n\t        if (parent.type === 'Element' && /-/.test(parent.name))\n\t            return true;\n\t        parent = parent.parent;\n\t    }\n\t    return false;\n\t}\n\n\tclass Head$1 extends Node$1 {\n\t    constructor(component, parent, scope, info) {\n\t        super(component, parent, scope, info);\n\t        if (info.attributes.length) {\n\t            component.error(info.attributes[0], {\n\t                code: `invalid-attribute`,\n\t                message: `<svelte:head> should not have any attributes or directives`\n\t            });\n\t        }\n\t        this.children = map_children(component, parent, scope, info.children.filter(child => {\n\t            return (child.type !== 'Text' || /\\S/.test(child.data));\n\t        }));\n\t        if (this.children.length > 0) {\n\t            this.id = `svelte-${hash(this.component.source.slice(this.start, this.end))}`;\n\t        }\n\t    }\n\t}\n\n\tclass IfBlock$1 extends AbstractBlock {\n\t    constructor(component, parent, scope, info) {\n\t        super(component, parent, scope, info);\n\t        this.expression = new Expression(component, this, scope, info.expression);\n\t        this.children = map_children(component, this, scope, info.children);\n\t        this.else = info.else\n\t            ? new ElseBlock(component, this, scope, info.else)\n\t            : null;\n\t        this.warn_if_empty_block();\n\t    }\n\t}\n\n\tclass InlineComponent$1 extends Node$1 {\n\t    constructor(component, parent, scope, info) {\n\t        super(component, parent, scope, info);\n\t        this.attributes = [];\n\t        this.bindings = [];\n\t        this.handlers = [];\n\t        this.lets = [];\n\t        if (info.name !== 'svelte:component' && info.name !== 'svelte:self') {\n\t            const name = info.name.split('.')[0]; // accommodate namespaces\n\t            component.warn_if_undefined(name, info, scope);\n\t            component.add_reference(name);\n\t        }\n\t        this.name = info.name;\n\t        this.expression = this.name === 'svelte:component'\n\t            ? new Expression(component, this, scope, info.expression)\n\t            : null;\n\t        info.attributes.forEach(node => {\n\t            /* eslint-disable no-fallthrough */\n\t            switch (node.type) {\n\t                case 'Action':\n\t                    component.error(node, {\n\t                        code: `invalid-action`,\n\t                        message: `Actions can only be applied to DOM elements, not components`\n\t                    });\n\t                case 'Attribute':\n\t                    if (node.name === 'slot') {\n\t                        component.error(node, {\n\t                            code: `invalid-prop`,\n\t                            message: `'slot' is reserved for future use in named slots`\n\t                        });\n\t                    }\n\t                // fallthrough\n\t                case 'Spread':\n\t                    this.attributes.push(new Attribute(component, this, scope, node));\n\t                    break;\n\t                case 'Binding':\n\t                    this.bindings.push(new Binding(component, this, scope, node));\n\t                    break;\n\t                case 'Class':\n\t                    component.error(node, {\n\t                        code: `invalid-class`,\n\t                        message: `Classes can only be applied to DOM elements, not components`\n\t                    });\n\t                case 'EventHandler':\n\t                    this.handlers.push(new EventHandler(component, this, scope, node));\n\t                    break;\n\t                case 'Let':\n\t                    this.lets.push(new Let(component, this, scope, node));\n\t                    break;\n\t                case 'Transition':\n\t                    component.error(node, {\n\t                        code: `invalid-transition`,\n\t                        message: `Transitions can only be applied to DOM elements, not components`\n\t                    });\n\t                default:\n\t                    throw new Error(`Not implemented: ${node.type}`);\n\t            }\n\t            /* eslint-enable no-fallthrough */\n\t        });\n\t        if (this.lets.length > 0) {\n\t            this.scope = scope.child();\n\t            this.lets.forEach(l => {\n\t                const dependencies = new Set([l.name.name]);\n\t                l.names.forEach(name => {\n\t                    this.scope.add(name, dependencies, this);\n\t                });\n\t            });\n\t        }\n\t        else {\n\t            this.scope = scope;\n\t        }\n\t        this.handlers.forEach(handler => {\n\t            handler.modifiers.forEach(modifier => {\n\t                if (modifier !== 'once') {\n\t                    component.error(handler, {\n\t                        code: 'invalid-event-modifier',\n\t                        message: `Event modifiers other than 'once' can only be used on DOM elements`\n\t                    });\n\t                }\n\t            });\n\t        });\n\t        this.children = map_children(component, this, this.scope, info.children);\n\t    }\n\t}\n\n\tclass Tag$2 extends Node$1 {\n\t    constructor(component, parent, scope, info) {\n\t        super(component, parent, scope, info);\n\t        this.expression = new Expression(component, this, scope, info.expression);\n\t        this.should_cache = (info.expression.type !== 'Identifier' ||\n\t            (this.expression.dependencies.size && scope.names.has(info.expression.name)));\n\t    }\n\t}\n\n\tclass MustacheTag extends Tag$2 {\n\t}\n\n\tclass Options extends Node$1 {\n\t}\n\n\tclass RawMustacheTag extends Tag$2 {\n\t}\n\n\tclass DebugTag$1 extends Node$1 {\n\t    constructor(component, parent, scope, info) {\n\t        super(component, parent, scope, info);\n\t        this.expressions = info.identifiers.map(node => {\n\t            return new Expression(component, parent, scope, node);\n\t        });\n\t    }\n\t}\n\n\tclass Slot$1 extends Element$1 {\n\t    constructor(component, parent, scope, info) {\n\t        super(component, parent, scope, info);\n\t        this.values = new Map();\n\t        info.attributes.forEach(attr => {\n\t            if (attr.type !== 'Attribute') {\n\t                component.error(attr, {\n\t                    code: `invalid-slot-directive`,\n\t                    message: `<slot> cannot have directives`\n\t                });\n\t            }\n\t            if (attr.name === 'name') {\n\t                if (attr.value.length !== 1 || attr.value[0].type !== 'Text') {\n\t                    component.error(attr, {\n\t                        code: `dynamic-slot-name`,\n\t                        message: `<slot> name cannot be dynamic`\n\t                    });\n\t                }\n\t                this.slot_name = attr.value[0].data;\n\t                if (this.slot_name === 'default') {\n\t                    component.error(attr, {\n\t                        code: `invalid-slot-name`,\n\t                        message: `default is a reserved word \u2014 it cannot be used as a slot name`\n\t                    });\n\t                }\n\t            }\n\t            this.values.set(attr.name, new Attribute(component, this, scope, attr));\n\t        });\n\t        if (!this.slot_name)\n\t            this.slot_name = 'default';\n\t        if (this.slot_name === 'default') {\n\t            // if this is the default slot, add our dependencies to any\n\t            // other slots (which inherit our slot values) that were\n\t            // previously encountered\n\t            component.slots.forEach((slot) => {\n\t                this.values.forEach((attribute, name) => {\n\t                    if (!slot.values.has(name)) {\n\t                        slot.values.set(name, attribute);\n\t                    }\n\t                });\n\t            });\n\t        }\n\t        else if (component.slots.has('default')) {\n\t            // otherwise, go the other way \u2014 inherit values from\n\t            // a previously encountered default slot\n\t            const default_slot = component.slots.get('default');\n\t            default_slot.values.forEach((attribute, name) => {\n\t                if (!this.values.has(name)) {\n\t                    this.values.set(name, attribute);\n\t                }\n\t            });\n\t        }\n\t        component.slots.set(this.slot_name, this);\n\t    }\n\t}\n\n\tclass Title$1 extends Node$1 {\n\t    constructor(component, parent, scope, info) {\n\t        super(component, parent, scope, info);\n\t        this.children = map_children(component, parent, scope, info.children);\n\t        if (info.attributes.length > 0) {\n\t            component.error(info.attributes[0], {\n\t                code: `illegal-attribute`,\n\t                message: `<title> cannot have attributes`\n\t            });\n\t        }\n\t        info.children.forEach(child => {\n\t            if (child.type !== 'Text' && child.type !== 'MustacheTag') {\n\t                component.error(child, {\n\t                    code: 'illegal-structure',\n\t                    message: `<title> can only contain text and {tags}`\n\t                });\n\t            }\n\t        });\n\t        this.should_cache = info.children.length === 1\n\t            ? (info.children[0].type !== 'Identifier' ||\n\t                scope.names.has(info.children[0].name))\n\t            : true;\n\t    }\n\t}\n\n\tconst valid_bindings = [\n\t    'innerWidth',\n\t    'innerHeight',\n\t    'outerWidth',\n\t    'outerHeight',\n\t    'scrollX',\n\t    'scrollY',\n\t    'online'\n\t];\n\tclass Window extends Node$1 {\n\t    constructor(component, parent, scope, info) {\n\t        super(component, parent, scope, info);\n\t        this.handlers = [];\n\t        this.bindings = [];\n\t        this.actions = [];\n\t        info.attributes.forEach(node => {\n\t            if (node.type === 'EventHandler') {\n\t                this.handlers.push(new EventHandler(component, this, scope, node));\n\t            }\n\t            else if (node.type === 'Binding') {\n\t                if (node.expression.type !== 'Identifier') {\n\t                    const { parts } = flatten_reference(node.expression);\n\t                    // TODO is this constraint necessary?\n\t                    component.error(node.expression, {\n\t                        code: `invalid-binding`,\n\t                        message: `Bindings on <svelte:window> must be to top-level properties, e.g. '${parts[parts.length - 1]}' rather than '${parts.join('.')}'`\n\t                    });\n\t                }\n\t                if (!~valid_bindings.indexOf(node.name)) {\n\t                    const match = (node.name === 'width' ? 'innerWidth' :\n\t                        node.name === 'height' ? 'innerHeight' :\n\t                            fuzzymatch(node.name, valid_bindings));\n\t                    const message = `'${node.name}' is not a valid binding on <svelte:window>`;\n\t                    if (match) {\n\t                        component.error(node, {\n\t                            code: `invalid-binding`,\n\t                            message: `${message} (did you mean '${match}'?)`\n\t                        });\n\t                    }\n\t                    else {\n\t                        component.error(node, {\n\t                            code: `invalid-binding`,\n\t                            message: `${message} \u2014 valid bindings are ${list$1(valid_bindings)}`\n\t                        });\n\t                    }\n\t                }\n\t                this.bindings.push(new Binding(component, this, scope, node));\n\t            }\n\t            else if (node.type === 'Action') {\n\t                this.actions.push(new Action(component, this, scope, node));\n\t            }\n\t        });\n\t    }\n\t}\n\n\tfunction get_constructor(type) {\n\t    switch (type) {\n\t        case 'AwaitBlock': return AwaitBlock$1;\n\t        case 'Body': return Body;\n\t        case 'Comment': return Comment$2;\n\t        case 'EachBlock': return EachBlock$1;\n\t        case 'Element': return Element$1;\n\t        case 'Head': return Head$1;\n\t        case 'IfBlock': return IfBlock$1;\n\t        case 'InlineComponent': return InlineComponent$1;\n\t        case 'MustacheTag': return MustacheTag;\n\t        case 'Options': return Options;\n\t        case 'RawMustacheTag': return RawMustacheTag;\n\t        case 'DebugTag': return DebugTag$1;\n\t        case 'Slot': return Slot$1;\n\t        case 'Text': return Text$1;\n\t        case 'Title': return Title$1;\n\t        case 'Window': return Window;\n\t        default: throw new Error(`Not implemented: ${type}`);\n\t    }\n\t}\n\tfunction map_children(component, parent, scope, children) {\n\t    let last = null;\n\t    let ignores = [];\n\t    return children.map(child => {\n\t        const constructor = get_constructor(child.type);\n\t        const use_ignores = child.type !== 'Text' && child.type !== 'Comment' && ignores.length;\n\t        if (use_ignores)\n\t            component.push_ignores(ignores);\n\t        const node = new constructor(component, parent, scope, child);\n\t        if (use_ignores)\n\t            component.pop_ignores(), ignores = [];\n\t        if (node.type === 'Comment' && node.ignores.length) {\n\t            ignores.push(...node.ignores);\n\t        }\n\t        if (last)\n\t            last.next = node;\n\t        node.prev = last;\n\t        last = node;\n\t        return node;\n\t    });\n\t}\n\n\tclass TemplateScope {\n\t    constructor(parent) {\n\t        this.owners = new Map();\n\t        this.parent = parent;\n\t        this.names = new Set(parent ? parent.names : []);\n\t        this.dependencies_for_name = new Map(parent ? parent.dependencies_for_name : []);\n\t    }\n\t    add(name, dependencies, owner) {\n\t        this.names.add(name);\n\t        this.dependencies_for_name.set(name, dependencies);\n\t        this.owners.set(name, owner);\n\t        return this;\n\t    }\n\t    child() {\n\t        const child = new TemplateScope(this);\n\t        return child;\n\t    }\n\t    is_top_level(name) {\n\t        return !this.parent || !this.names.has(name) && this.parent.is_top_level(name);\n\t    }\n\t    get_owner(name) {\n\t        return this.owners.get(name) || (this.parent && this.parent.get_owner(name));\n\t    }\n\t    is_let(name) {\n\t        const owner = this.get_owner(name);\n\t        return owner && (owner.type === 'Element' || owner.type === 'InlineComponent');\n\t    }\n\t    is_await(name) {\n\t        const owner = this.get_owner(name);\n\t        return owner && (owner.type === 'ThenBlock' || owner.type === 'CatchBlock');\n\t    }\n\t}\n\n\tclass Fragment extends Node$1 {\n\t    constructor(component, info) {\n\t        const scope = new TemplateScope();\n\t        super(component, null, scope, info);\n\t        this.scope = scope;\n\t        this.children = map_children(component, this, scope, info.children);\n\t    }\n\t}\n\n\t// This file is automatically generated\n\tvar internal_exports = new Set([\"HtmlTag\", \"SvelteComponent\", \"SvelteComponentDev\", \"SvelteElement\", \"action_destroyer\", \"add_attribute\", \"add_classes\", \"add_flush_callback\", \"add_location\", \"add_render_callback\", \"add_resize_listener\", \"add_transform\", \"afterUpdate\", \"append\", \"append_dev\", \"assign\", \"attr\", \"attr_dev\", \"beforeUpdate\", \"bind\", \"binding_callbacks\", \"blank_object\", \"bubble\", \"check_outros\", \"children\", \"claim_component\", \"claim_element\", \"claim_space\", \"claim_text\", \"clear_loops\", \"component_subscribe\", \"compute_rest_props\", \"createEventDispatcher\", \"create_animation\", \"create_bidirectional_transition\", \"create_component\", \"create_in_transition\", \"create_out_transition\", \"create_slot\", \"create_ssr_component\", \"current_component\", \"custom_event\", \"dataset_dev\", \"debug\", \"destroy_block\", \"destroy_component\", \"destroy_each\", \"detach\", \"detach_after_dev\", \"detach_before_dev\", \"detach_between_dev\", \"detach_dev\", \"dirty_components\", \"dispatch_dev\", \"each\", \"element\", \"element_is\", \"empty\", \"escape\", \"escaped\", \"exclude_internal_props\", \"fix_and_destroy_block\", \"fix_and_outro_and_destroy_block\", \"fix_position\", \"flush\", \"getContext\", \"get_binding_group_value\", \"get_current_component\", \"get_slot_changes\", \"get_slot_context\", \"get_spread_object\", \"get_spread_update\", \"get_store_value\", \"globals\", \"group_outros\", \"handle_promise\", \"has_prop\", \"identity\", \"init\", \"insert\", \"insert_dev\", \"intros\", \"invalid_attribute_name_character\", \"is_client\", \"is_crossorigin\", \"is_function\", \"is_promise\", \"listen\", \"listen_dev\", \"loop\", \"loop_guard\", \"missing_component\", \"mount_component\", \"noop\", \"not_equal\", \"now\", \"null_to_empty\", \"object_without_properties\", \"onDestroy\", \"onMount\", \"once\", \"outro_and_destroy_block\", \"prevent_default\", \"prop_dev\", \"query_selector_all\", \"raf\", \"run\", \"run_all\", \"safe_not_equal\", \"schedule_update\", \"select_multiple_value\", \"select_option\", \"select_options\", \"select_value\", \"self\", \"setContext\", \"set_attributes\", \"set_current_component\", \"set_custom_element_data\", \"set_data\", \"set_data_dev\", \"set_input_type\", \"set_input_value\", \"set_now\", \"set_raf\", \"set_store_value\", \"set_style\", \"set_svg_attributes\", \"space\", \"spread\", \"stop_propagation\", \"subscribe\", \"svg_element\", \"text\", \"tick\", \"time_ranges_to_array\", \"to_number\", \"toggle_class\", \"transition_in\", \"transition_out\", \"update_keyed_each\", \"update_slot\", \"validate_component\", \"validate_each_argument\", \"validate_each_keys\", \"validate_slots\", \"validate_store\", \"xlink_attr\"]);\n\n\tfunction is_used_as_reference(node, parent) {\n\t    if (!isReference(node, parent)) {\n\t        return false;\n\t    }\n\t    if (!parent) {\n\t        return true;\n\t    }\n\t    /* eslint-disable no-fallthrough */\n\t    switch (parent.type) {\n\t        // disregard the `foo` in `const foo = bar`\n\t        case 'VariableDeclarator':\n\t            return node !== parent.id;\n\t        // disregard the `foo`, `bar` in `function foo(bar){}`\n\t        case 'FunctionDeclaration':\n\t        // disregard the `foo` in `import { foo } from 'foo'`\n\t        case 'ImportSpecifier':\n\t        // disregard the `foo` in `import foo from 'foo'`\n\t        case 'ImportDefaultSpecifier':\n\t        // disregard the `foo` in `import * as foo from 'foo'`\n\t        case 'ImportNamespaceSpecifier':\n\t        // disregard the `foo` in `export { foo }`\n\t        case 'ExportSpecifier':\n\t            return false;\n\t        default:\n\t            return true;\n\t    }\n\t}\n\n\tfunction check_graph_for_cycles(edges) {\n\t    const graph = edges.reduce((g, edge) => {\n\t        const [u, v] = edge;\n\t        if (!g.has(u))\n\t            g.set(u, []);\n\t        if (!g.has(v))\n\t            g.set(v, []);\n\t        g.get(u).push(v);\n\t        return g;\n\t    }, new Map());\n\t    const visited = new Set();\n\t    const on_stack = new Set();\n\t    const cycles = [];\n\t    function visit(v) {\n\t        visited.add(v);\n\t        on_stack.add(v);\n\t        graph.get(v).forEach(w => {\n\t            if (!visited.has(w)) {\n\t                visit(w);\n\t            }\n\t            else if (on_stack.has(w)) {\n\t                cycles.push([...on_stack, w]);\n\t            }\n\t        });\n\t        on_stack.delete(v);\n\t    }\n\t    graph.forEach((_, v) => {\n\t        if (!visited.has(v)) {\n\t            visit(v);\n\t        }\n\t    });\n\t    return cycles[0];\n\t}\n\n\tclass Component {\n\t    constructor(ast, source, name, compile_options, stats, warnings) {\n\t        this.ignore_stack = [];\n\t        this.vars = [];\n\t        this.var_lookup = new Map();\n\t        this.imports = [];\n\t        this.hoistable_nodes = new Set();\n\t        this.node_for_declaration = new Map();\n\t        this.partly_hoisted = [];\n\t        this.fully_hoisted = [];\n\t        this.reactive_declarations = [];\n\t        this.reactive_declaration_nodes = new Set();\n\t        this.has_reactive_assignments = false;\n\t        this.injected_reactive_declaration_vars = new Set();\n\t        this.helpers = new Map();\n\t        this.globals = new Map();\n\t        this.indirect_dependencies = new Map();\n\t        this.aliases = new Map();\n\t        this.used_names = new Set();\n\t        this.globally_used_names = new Set();\n\t        this.slots = new Map();\n\t        this.slot_outlets = new Set();\n\t        this.name = { type: 'Identifier', name };\n\t        this.stats = stats;\n\t        this.warnings = warnings;\n\t        this.ast = ast;\n\t        this.source = source;\n\t        this.compile_options = compile_options;\n\t        // the instance JS gets mutated, so we park\n\t        // a copy here for later. TODO this feels gross\n\t        this.original_ast = {\n\t            html: ast.html,\n\t            css: ast.css,\n\t            instance: ast.instance && JSON.parse(JSON.stringify(ast.instance)),\n\t            module: ast.module\n\t        };\n\t        this.file =\n\t            compile_options.filename &&\n\t                (typeof process !== 'undefined'\n\t                    ? compile_options.filename\n\t                        .replace(process.cwd(), '')\n\t                        .replace(/^[/\\\\]/, '')\n\t                    : compile_options.filename);\n\t        this.locate = getLocator(this.source, { offsetLine: 1 });\n\t        // styles\n\t        this.stylesheet = new Stylesheet(source, ast, compile_options.filename, compile_options.dev);\n\t        this.stylesheet.validate(this);\n\t        this.component_options = process_component_options(this, this.ast.html.children);\n\t        this.namespace =\n\t            namespaces[this.component_options.namespace] ||\n\t                this.component_options.namespace;\n\t        if (compile_options.customElement) {\n\t            if (this.component_options.tag === undefined &&\n\t                compile_options.tag === undefined) {\n\t                const svelteOptions = ast.html.children.find(child => child.name === 'svelte:options') || { start: 0, end: 0 };\n\t                this.warn(svelteOptions, {\n\t                    code: 'custom-element-no-tag',\n\t                    message: `No custom element 'tag' option was specified. To automatically register a custom element, specify a name with a hyphen in it, e.g. <svelte:options tag=\"my-thing\"/>. To hide this warning, use <svelte:options tag={null}/>`,\n\t                });\n\t            }\n\t            this.tag = this.component_options.tag || compile_options.tag;\n\t        }\n\t        else {\n\t            this.tag = this.name.name;\n\t        }\n\t        this.walk_module_js();\n\t        this.walk_instance_js_pre_template();\n\t        this.fragment = new Fragment(this, ast.html);\n\t        this.name = this.get_unique_name(name);\n\t        this.walk_instance_js_post_template();\n\t        if (!compile_options.customElement)\n\t            this.stylesheet.reify();\n\t        this.stylesheet.warn_on_unused_selectors(this);\n\t    }\n\t    add_var(variable) {\n\t        this.vars.push(variable);\n\t        this.var_lookup.set(variable.name, variable);\n\t    }\n\t    add_reference(name) {\n\t        const variable = this.var_lookup.get(name);\n\t        if (variable) {\n\t            variable.referenced = true;\n\t        }\n\t        else if (is_reserved_keyword(name)) {\n\t            this.add_var({\n\t                name,\n\t                injected: true,\n\t                referenced: true,\n\t            });\n\t        }\n\t        else if (name[0] === '$') {\n\t            this.add_var({\n\t                name,\n\t                injected: true,\n\t                referenced: true,\n\t                mutated: true,\n\t                writable: true,\n\t            });\n\t            const subscribable_name = name.slice(1);\n\t            const variable = this.var_lookup.get(subscribable_name);\n\t            if (variable) {\n\t                variable.referenced = true;\n\t                variable.subscribable = true;\n\t            }\n\t        }\n\t        else {\n\t            this.used_names.add(name);\n\t        }\n\t    }\n\t    alias(name) {\n\t        if (!this.aliases.has(name)) {\n\t            this.aliases.set(name, this.get_unique_name(name));\n\t        }\n\t        return this.aliases.get(name);\n\t    }\n\t    global(name) {\n\t        const alias = this.alias(name);\n\t        this.globals.set(name, alias);\n\t        return alias;\n\t    }\n\t    generate(result) {\n\t        let js = null;\n\t        let css = null;\n\t        if (result) {\n\t            const { compile_options, name } = this;\n\t            const { format = 'esm' } = compile_options;\n\t            const banner = `${this.file ? `${this.file} ` : ``}generated by Svelte v${'3.24.0'}`;\n\t            const program = { type: 'Program', body: result.js };\n\t            walk(program, {\n\t                enter: (node, parent, key) => {\n\t                    if (node.type === 'Identifier') {\n\t                        if (node.name[0] === '@') {\n\t                            if (node.name[1] === '_') {\n\t                                const alias = this.global(node.name.slice(2));\n\t                                node.name = alias.name;\n\t                            }\n\t                            else {\n\t                                let name = node.name.slice(1);\n\t                                if (compile_options.dev) {\n\t                                    if (internal_exports.has(`${name}_dev`)) {\n\t                                        name += '_dev';\n\t                                    }\n\t                                    else if (internal_exports.has(`${name}Dev`)) {\n\t                                        name += 'Dev';\n\t                                    }\n\t                                }\n\t                                const alias = this.alias(name);\n\t                                this.helpers.set(name, alias);\n\t                                node.name = alias.name;\n\t                            }\n\t                        }\n\t                        else if (node.name[0] !== '#' && !is_valid(node.name)) {\n\t                            // this hack allows x`foo.${bar}` where bar could be invalid\n\t                            const literal = { type: 'Literal', value: node.name };\n\t                            if (parent.type === 'Property' && key === 'key') {\n\t                                parent.key = literal;\n\t                            }\n\t                            else if (parent.type === 'MemberExpression' && key === 'property') {\n\t                                parent.property = literal;\n\t                                parent.computed = true;\n\t                            }\n\t                        }\n\t                    }\n\t                }\n\t            });\n\t            const referenced_globals = Array.from(this.globals, ([name, alias]) => name !== alias.name && { name, alias }).filter(Boolean);\n\t            if (referenced_globals.length) {\n\t                this.helpers.set('globals', this.alias('globals'));\n\t            }\n\t            const imported_helpers = Array.from(this.helpers, ([name, alias]) => ({\n\t                name,\n\t                alias,\n\t            }));\n\t            create_module(program, format, name, banner, compile_options.sveltePath, imported_helpers, referenced_globals, this.imports, this.vars\n\t                .filter(variable => variable.module && variable.export_name)\n\t                .map(variable => ({\n\t                name: variable.name,\n\t                as: variable.export_name,\n\t            })));\n\t            css = compile_options.customElement\n\t                ? { code: null, map: null }\n\t                : result.css;\n\t            js = print(program, {\n\t                sourceMapSource: compile_options.filename\n\t            });\n\t            js.map.sources = [\n\t                compile_options.filename ? get_relative_path(compile_options.outputFilename || '', compile_options.filename) : null\n\t            ];\n\t            js.map.sourcesContent = [\n\t                this.source\n\t            ];\n\t        }\n\t        return {\n\t            js,\n\t            css,\n\t            ast: this.original_ast,\n\t            warnings: this.warnings,\n\t            vars: this.vars\n\t                .filter(v => !v.global && !v.internal)\n\t                .map(v => ({\n\t                name: v.name,\n\t                export_name: v.export_name || null,\n\t                injected: v.injected || false,\n\t                module: v.module || false,\n\t                mutated: v.mutated || false,\n\t                reassigned: v.reassigned || false,\n\t                referenced: v.referenced || false,\n\t                writable: v.writable || false,\n\t                referenced_from_script: v.referenced_from_script || false,\n\t            })),\n\t            stats: this.stats.render(),\n\t        };\n\t    }\n\t    get_unique_name(name, scope) {\n\t        if (test)\n\t            name = `${name}$`;\n\t        let alias = name;\n\t        for (let i = 1; reserved.has(alias) ||\n\t            this.var_lookup.has(alias) ||\n\t            this.used_names.has(alias) ||\n\t            this.globally_used_names.has(alias) ||\n\t            (scope && scope.has(alias)); alias = `${name}_${i++}`)\n\t            ;\n\t        this.used_names.add(alias);\n\t        return { type: 'Identifier', name: alias };\n\t    }\n\t    get_unique_name_maker() {\n\t        const local_used_names = new Set();\n\t        function add(name) {\n\t            local_used_names.add(name);\n\t        }\n\t        reserved.forEach(add);\n\t        internal_exports.forEach(add);\n\t        this.var_lookup.forEach((_value, key) => add(key));\n\t        return (name) => {\n\t            if (test)\n\t                name = `${name}$`;\n\t            let alias = name;\n\t            for (let i = 1; this.used_names.has(alias) || local_used_names.has(alias); alias = `${name}_${i++}`)\n\t                ;\n\t            local_used_names.add(alias);\n\t            this.globally_used_names.add(alias);\n\t            return {\n\t                type: 'Identifier',\n\t                name: alias\n\t            };\n\t        };\n\t    }\n\t    error(pos, e) {\n\t        error$1(e.message, {\n\t            name: 'ValidationError',\n\t            code: e.code,\n\t            source: this.source,\n\t            start: pos.start,\n\t            end: pos.end,\n\t            filename: this.compile_options.filename,\n\t        });\n\t    }\n\t    warn(pos, warning) {\n\t        if (this.ignores && this.ignores.has(warning.code)) {\n\t            return;\n\t        }\n\t        const start = this.locate(pos.start);\n\t        const end = this.locate(pos.end);\n\t        const frame = get_code_frame(this.source, start.line - 1, start.column);\n\t        this.warnings.push({\n\t            code: warning.code,\n\t            message: warning.message,\n\t            frame,\n\t            start,\n\t            end,\n\t            pos: pos.start,\n\t            filename: this.compile_options.filename,\n\t            toString: () => `${warning.message} (${start.line}:${start.column})\\n${frame}`,\n\t        });\n\t    }\n\t    extract_imports(node) {\n\t        this.imports.push(node);\n\t    }\n\t    extract_exports(node) {\n\t        if (node.type === 'ExportDefaultDeclaration') {\n\t            this.error(node, {\n\t                code: `default-export`,\n\t                message: `A component cannot have a default export`,\n\t            });\n\t        }\n\t        if (node.type === 'ExportNamedDeclaration') {\n\t            if (node.source) {\n\t                this.error(node, {\n\t                    code: `not-implemented`,\n\t                    message: `A component currently cannot have an export ... from`,\n\t                });\n\t            }\n\t            if (node.declaration) {\n\t                if (node.declaration.type === 'VariableDeclaration') {\n\t                    node.declaration.declarations.forEach(declarator => {\n\t                        extract_names(declarator.id).forEach(name => {\n\t                            const variable = this.var_lookup.get(name);\n\t                            variable.export_name = name;\n\t                            if (variable.writable && !(variable.referenced || variable.referenced_from_script || variable.subscribable)) {\n\t                                this.warn(declarator, {\n\t                                    code: `unused-export-let`,\n\t                                    message: `${this.name.name} has unused export property '${name}'. If it is for external reference only, please consider using \\`export const ${name}\\``\n\t                                });\n\t                            }\n\t                        });\n\t                    });\n\t                }\n\t                else {\n\t                    const { name } = node.declaration.id;\n\t                    const variable = this.var_lookup.get(name);\n\t                    variable.export_name = name;\n\t                }\n\t                return node.declaration;\n\t            }\n\t            else {\n\t                node.specifiers.forEach(specifier => {\n\t                    const variable = this.var_lookup.get(specifier.local.name);\n\t                    if (variable) {\n\t                        variable.export_name = specifier.exported.name;\n\t                        if (variable.writable && !(variable.referenced || variable.referenced_from_script || variable.subscribable)) {\n\t                            this.warn(specifier, {\n\t                                code: `unused-export-let`,\n\t                                message: `${this.name.name} has unused export property '${specifier.exported.name}'. If it is for external reference only, please consider using \\`export const ${specifier.exported.name}\\``\n\t                            });\n\t                        }\n\t                    }\n\t                });\n\t                return null;\n\t            }\n\t        }\n\t    }\n\t    extract_javascript(script) {\n\t        if (!script)\n\t            return null;\n\t        return script.content.body.filter(node => {\n\t            if (!node)\n\t                return false;\n\t            if (this.hoistable_nodes.has(node))\n\t                return false;\n\t            if (this.reactive_declaration_nodes.has(node))\n\t                return false;\n\t            if (node.type === 'ImportDeclaration')\n\t                return false;\n\t            if (node.type === 'ExportDeclaration' && node.specifiers.length > 0)\n\t                return false;\n\t            return true;\n\t        });\n\t    }\n\t    walk_module_js() {\n\t        const component = this;\n\t        const script = this.ast.module;\n\t        if (!script)\n\t            return;\n\t        walk(script.content, {\n\t            enter(node) {\n\t                if (node.type === 'LabeledStatement' && node.label.name === '$') {\n\t                    component.warn(node, {\n\t                        code: 'module-script-reactive-declaration',\n\t                        message: '$: has no effect in a module script',\n\t                    });\n\t                }\n\t            },\n\t        });\n\t        const { scope, globals } = create_scopes(script.content);\n\t        this.module_scope = scope;\n\t        scope.declarations.forEach((node, name) => {\n\t            if (name[0] === '$') {\n\t                this.error(node, {\n\t                    code: 'illegal-declaration',\n\t                    message: `The $ prefix is reserved, and cannot be used for variable and import names`,\n\t                });\n\t            }\n\t            const writable = node.type === 'VariableDeclaration' && (node.kind === 'var' || node.kind === 'let');\n\t            this.add_var({\n\t                name,\n\t                module: true,\n\t                hoistable: true,\n\t                writable\n\t            });\n\t        });\n\t        globals.forEach((node, name) => {\n\t            if (name[0] === '$') {\n\t                this.error(node, {\n\t                    code: 'illegal-subscription',\n\t                    message: `Cannot reference store value inside <script context=\"module\">`,\n\t                });\n\t            }\n\t            else {\n\t                this.add_var({\n\t                    name,\n\t                    global: true,\n\t                    hoistable: true\n\t                });\n\t            }\n\t        });\n\t        const { body } = script.content;\n\t        let i = body.length;\n\t        while (--i >= 0) {\n\t            const node = body[i];\n\t            if (node.type === 'ImportDeclaration') {\n\t                this.extract_imports(node);\n\t                body.splice(i, 1);\n\t            }\n\t            if (/^Export/.test(node.type)) {\n\t                const replacement = this.extract_exports(node);\n\t                if (replacement) {\n\t                    body[i] = replacement;\n\t                }\n\t                else {\n\t                    body.splice(i, 1);\n\t                }\n\t            }\n\t        }\n\t    }\n\t    walk_instance_js_pre_template() {\n\t        const script = this.ast.instance;\n\t        if (!script)\n\t            return;\n\t        // inject vars for reactive declarations\n\t        script.content.body.forEach(node => {\n\t            if (node.type !== 'LabeledStatement')\n\t                return;\n\t            if (node.body.type !== 'ExpressionStatement')\n\t                return;\n\t            const { expression } = node.body;\n\t            if (expression.type !== 'AssignmentExpression')\n\t                return;\n\t            if (expression.left.type === 'MemberExpression')\n\t                return;\n\t            extract_names(expression.left).forEach(name => {\n\t                if (!this.var_lookup.has(name) && name[0] !== '$') {\n\t                    this.injected_reactive_declaration_vars.add(name);\n\t                }\n\t            });\n\t        });\n\t        const { scope: instance_scope, map, globals } = create_scopes(script.content);\n\t        this.instance_scope = instance_scope;\n\t        this.instance_scope_map = map;\n\t        instance_scope.declarations.forEach((node, name) => {\n\t            if (name[0] === '$') {\n\t                this.error(node, {\n\t                    code: 'illegal-declaration',\n\t                    message: `The $ prefix is reserved, and cannot be used for variable and import names`,\n\t                });\n\t            }\n\t            const writable = node.type === 'VariableDeclaration' && (node.kind === 'var' || node.kind === 'let');\n\t            this.add_var({\n\t                name,\n\t                initialised: instance_scope.initialised_declarations.has(name),\n\t                writable\n\t            });\n\t            this.node_for_declaration.set(name, node);\n\t        });\n\t        globals.forEach((node, name) => {\n\t            if (this.var_lookup.has(name))\n\t                return;\n\t            if (this.injected_reactive_declaration_vars.has(name)) {\n\t                this.add_var({\n\t                    name,\n\t                    injected: true,\n\t                    writable: true,\n\t                    reassigned: true,\n\t                    initialised: true,\n\t                });\n\t            }\n\t            else if (is_reserved_keyword(name)) {\n\t                this.add_var({\n\t                    name,\n\t                    injected: true,\n\t                });\n\t            }\n\t            else if (name[0] === '$') {\n\t                if (name === '$' || name[1] === '$') {\n\t                    this.error(node, {\n\t                        code: 'illegal-global',\n\t                        message: `${name} is an illegal variable name`\n\t                    });\n\t                }\n\t                this.add_var({\n\t                    name,\n\t                    injected: true,\n\t                    mutated: true,\n\t                    writable: true,\n\t                });\n\t                this.add_reference(name.slice(1));\n\t                const variable = this.var_lookup.get(name.slice(1));\n\t                if (variable) {\n\t                    variable.subscribable = true;\n\t                    variable.referenced_from_script = true;\n\t                }\n\t            }\n\t            else {\n\t                this.add_var({\n\t                    name,\n\t                    global: true,\n\t                    hoistable: true\n\t                });\n\t            }\n\t        });\n\t        this.track_references_and_mutations();\n\t    }\n\t    walk_instance_js_post_template() {\n\t        const script = this.ast.instance;\n\t        if (!script)\n\t            return;\n\t        this.post_template_walk();\n\t        this.hoist_instance_declarations();\n\t        this.extract_reactive_declarations();\n\t    }\n\t    post_template_walk() {\n\t        const script = this.ast.instance;\n\t        if (!script)\n\t            return;\n\t        const component = this;\n\t        const { content } = script;\n\t        const { instance_scope, instance_scope_map: map } = this;\n\t        let scope = instance_scope;\n\t        const to_remove = [];\n\t        const remove = (parent, prop, index) => {\n\t            to_remove.unshift([parent, prop, index]);\n\t        };\n\t        let scope_updated = false;\n\t        let generator_count = 0;\n\t        walk(content, {\n\t            enter(node, parent, prop, index) {\n\t                if ((node.type === 'FunctionDeclaration' || node.type === 'FunctionExpression') && node.generator === true) {\n\t                    generator_count++;\n\t                }\n\t                if (map.has(node)) {\n\t                    scope = map.get(node);\n\t                }\n\t                if (node.type === 'ImportDeclaration') {\n\t                    component.extract_imports(node);\n\t                    // TODO: to use actual remove\n\t                    remove(parent, prop, index);\n\t                    return this.skip();\n\t                }\n\t                if (/^Export/.test(node.type)) {\n\t                    const replacement = component.extract_exports(node);\n\t                    if (replacement) {\n\t                        this.replace(replacement);\n\t                    }\n\t                    else {\n\t                        // TODO: to use actual remove\n\t                        remove(parent, prop, index);\n\t                    }\n\t                    return this.skip();\n\t                }\n\t                component.warn_on_undefined_store_value_references(node, parent, scope);\n\t            },\n\t            leave(node) {\n\t                if ((node.type === 'FunctionDeclaration' || node.type === 'FunctionExpression') && node.generator === true) {\n\t                    generator_count--;\n\t                }\n\t                // do it on leave, to prevent infinite loop\n\t                if (component.compile_options.dev && component.compile_options.loopGuardTimeout > 0 && generator_count <= 0) {\n\t                    const to_replace_for_loop_protect = component.loop_protect(node, scope, component.compile_options.loopGuardTimeout);\n\t                    if (to_replace_for_loop_protect) {\n\t                        this.replace(to_replace_for_loop_protect);\n\t                        scope_updated = true;\n\t                    }\n\t                }\n\t                if (map.has(node)) {\n\t                    scope = scope.parent;\n\t                }\n\t            },\n\t        });\n\t        for (const [parent, prop, index] of to_remove) {\n\t            if (parent) {\n\t                if (index !== null) {\n\t                    parent[prop].splice(index, 1);\n\t                }\n\t                else {\n\t                    delete parent[prop];\n\t                }\n\t            }\n\t        }\n\t        if (scope_updated) {\n\t            const { scope, map } = create_scopes(script.content);\n\t            this.instance_scope = scope;\n\t            this.instance_scope_map = map;\n\t        }\n\t    }\n\t    track_references_and_mutations() {\n\t        const script = this.ast.instance;\n\t        if (!script)\n\t            return;\n\t        const component = this;\n\t        const { content } = script;\n\t        const { instance_scope, module_scope, instance_scope_map: map } = this;\n\t        let scope = instance_scope;\n\t        walk(content, {\n\t            enter(node, parent) {\n\t                if (map.has(node)) {\n\t                    scope = map.get(node);\n\t                }\n\t                if (node.type === 'AssignmentExpression' || node.type === 'UpdateExpression') {\n\t                    const assignee = node.type === 'AssignmentExpression' ? node.left : node.argument;\n\t                    const names = extract_names(assignee);\n\t                    const deep = assignee.type === 'MemberExpression';\n\t                    names.forEach(name => {\n\t                        const scope_owner = scope.find_owner(name);\n\t                        if (scope_owner !== null\n\t                            ? scope_owner === instance_scope\n\t                            : module_scope && module_scope.has(name)) {\n\t                            const variable = component.var_lookup.get(name);\n\t                            variable[deep ? 'mutated' : 'reassigned'] = true;\n\t                        }\n\t                    });\n\t                }\n\t                if (is_used_as_reference(node, parent)) {\n\t                    const object = get_object(node);\n\t                    if (scope.find_owner(object.name) === instance_scope) {\n\t                        const variable = component.var_lookup.get(object.name);\n\t                        variable.referenced_from_script = true;\n\t                    }\n\t                }\n\t            },\n\t            leave(node) {\n\t                if (map.has(node)) {\n\t                    scope = scope.parent;\n\t                }\n\t            },\n\t        });\n\t    }\n\t    warn_on_undefined_store_value_references(node, parent, scope) {\n\t        if (node.type === 'LabeledStatement' &&\n\t            node.label.name === '$' &&\n\t            parent.type !== 'Program') {\n\t            this.warn(node, {\n\t                code: 'non-top-level-reactive-declaration',\n\t                message: '$: has no effect outside of the top-level',\n\t            });\n\t        }\n\t        if (isReference(node, parent)) {\n\t            const object = get_object(node);\n\t            const { name } = object;\n\t            if (name[0] === '$') {\n\t                if (!scope.has(name)) {\n\t                    this.warn_if_undefined(name, object, null);\n\t                }\n\t                if (name[1] !== '$' && scope.has(name.slice(1)) && scope.find_owner(name.slice(1)) !== this.instance_scope) {\n\t                    this.error(node, {\n\t                        code: `contextual-store`,\n\t                        message: `Stores must be declared at the top level of the component (this may change in a future version of Svelte)`\n\t                    });\n\t                }\n\t            }\n\t        }\n\t    }\n\t    loop_protect(node, scope, timeout) {\n\t        if (node.type === 'WhileStatement' ||\n\t            node.type === 'ForStatement' ||\n\t            node.type === 'DoWhileStatement') {\n\t            const guard = this.get_unique_name('guard', scope);\n\t            this.used_names.add(guard.name);\n\t            const before = b `const ${guard} = @loop_guard(${timeout})`;\n\t            const inside = b `${guard}();`;\n\t            // wrap expression statement with BlockStatement\n\t            if (node.body.type !== 'BlockStatement') {\n\t                node.body = {\n\t                    type: 'BlockStatement',\n\t                    body: [node.body],\n\t                };\n\t            }\n\t            node.body.body.push(inside[0]);\n\t            return {\n\t                type: 'BlockStatement',\n\t                body: [\n\t                    before[0],\n\t                    node,\n\t                ],\n\t            };\n\t        }\n\t        return null;\n\t    }\n\t    rewrite_props(get_insert) {\n\t        if (!this.ast.instance)\n\t            return;\n\t        const component = this;\n\t        const { instance_scope, instance_scope_map: map } = this;\n\t        let scope = instance_scope;\n\t        walk(this.ast.instance.content, {\n\t            enter(node, parent, key, index) {\n\t                if (/Function/.test(node.type)) {\n\t                    return this.skip();\n\t                }\n\t                if (map.has(node)) {\n\t                    scope = map.get(node);\n\t                }\n\t                if (node.type === 'VariableDeclaration') {\n\t                    if (node.kind === 'var' || scope === instance_scope) {\n\t                        node.declarations.forEach(declarator => {\n\t                            if (declarator.id.type !== 'Identifier') {\n\t                                const inserts = [];\n\t                                extract_names(declarator.id).forEach(name => {\n\t                                    const variable = component.var_lookup.get(name);\n\t                                    if (variable.export_name) {\n\t                                        // TODO is this still true post-#3539?\n\t                                        component.error(declarator, {\n\t                                            code: 'destructured-prop',\n\t                                            message: `Cannot declare props in destructured declaration`,\n\t                                        });\n\t                                    }\n\t                                    if (variable.subscribable) {\n\t                                        inserts.push(get_insert(variable));\n\t                                    }\n\t                                });\n\t                                if (inserts.length) {\n\t                                    parent[key].splice(index + 1, 0, ...inserts);\n\t                                }\n\t                                return;\n\t                            }\n\t                            const { name } = declarator.id;\n\t                            const variable = component.var_lookup.get(name);\n\t                            if (variable.export_name && variable.writable) {\n\t                                const insert = variable.subscribable\n\t                                    ? get_insert(variable)\n\t                                    : null;\n\t                                parent[key].splice(index + 1, 0, insert);\n\t                                declarator.id = {\n\t                                    type: 'ObjectPattern',\n\t                                    properties: [{\n\t                                            type: 'Property',\n\t                                            method: false,\n\t                                            shorthand: false,\n\t                                            computed: false,\n\t                                            kind: 'init',\n\t                                            key: { type: 'Identifier', name: variable.export_name },\n\t                                            value: declarator.init\n\t                                                ? {\n\t                                                    type: 'AssignmentPattern',\n\t                                                    left: declarator.id,\n\t                                                    right: declarator.init\n\t                                                }\n\t                                                : declarator.id\n\t                                        }]\n\t                                };\n\t                                declarator.init = x `$$props`;\n\t                            }\n\t                            else if (variable.subscribable) {\n\t                                const insert = get_insert(variable);\n\t                                parent[key].splice(index + 1, 0, ...insert);\n\t                            }\n\t                        });\n\t                    }\n\t                }\n\t            },\n\t            leave(node, parent, _key, index) {\n\t                if (map.has(node)) {\n\t                    scope = scope.parent;\n\t                }\n\t                if (node.type === 'ExportNamedDeclaration' && node.declaration) {\n\t                    parent.body[index] = node.declaration;\n\t                }\n\t            },\n\t        });\n\t    }\n\t    hoist_instance_declarations() {\n\t        // we can safely hoist variable declarations that are\n\t        // initialised to literals, and functions that don't\n\t        // reference instance variables other than other\n\t        // hoistable functions. TODO others?\n\t        const { hoistable_nodes, var_lookup, injected_reactive_declaration_vars, imports, } = this;\n\t        const top_level_function_declarations = new Map();\n\t        const { body } = this.ast.instance.content;\n\t        for (let i = 0; i < body.length; i += 1) {\n\t            const node = body[i];\n\t            if (node.type === 'VariableDeclaration') {\n\t                const all_hoistable = node.declarations.every(d => {\n\t                    if (!d.init)\n\t                        return false;\n\t                    if (d.init.type !== 'Literal')\n\t                        return false;\n\t                    // everything except const values can be changed by e.g. svelte devtools\n\t                    // which means we can't hoist it\n\t                    if (node.kind !== 'const' && this.compile_options.dev)\n\t                        return false;\n\t                    const { name } = d.id;\n\t                    const v = this.var_lookup.get(name);\n\t                    if (v.reassigned)\n\t                        return false;\n\t                    if (v.export_name)\n\t                        return false;\n\t                    if (this.var_lookup.get(name).reassigned)\n\t                        return false;\n\t                    if (this.vars.find(variable => variable.name === name && variable.module))\n\t                        return false;\n\t                    return true;\n\t                });\n\t                if (all_hoistable) {\n\t                    node.declarations.forEach(d => {\n\t                        const variable = this.var_lookup.get(d.id.name);\n\t                        variable.hoistable = true;\n\t                    });\n\t                    hoistable_nodes.add(node);\n\t                    body.splice(i--, 1);\n\t                    this.fully_hoisted.push(node);\n\t                }\n\t            }\n\t            if (node.type === 'ExportNamedDeclaration' &&\n\t                node.declaration &&\n\t                node.declaration.type === 'FunctionDeclaration') {\n\t                top_level_function_declarations.set(node.declaration.id.name, node);\n\t            }\n\t            if (node.type === 'FunctionDeclaration') {\n\t                top_level_function_declarations.set(node.id.name, node);\n\t            }\n\t        }\n\t        const checked = new Set();\n\t        const walking = new Set();\n\t        const is_hoistable = fn_declaration => {\n\t            if (fn_declaration.type === 'ExportNamedDeclaration') {\n\t                fn_declaration = fn_declaration.declaration;\n\t            }\n\t            const instance_scope = this.instance_scope;\n\t            let scope = this.instance_scope;\n\t            const map = this.instance_scope_map;\n\t            let hoistable = true;\n\t            // handle cycles\n\t            walking.add(fn_declaration);\n\t            walk(fn_declaration, {\n\t                enter(node, parent) {\n\t                    if (!hoistable)\n\t                        return this.skip();\n\t                    if (map.has(node)) {\n\t                        scope = map.get(node);\n\t                    }\n\t                    if (isReference(node, parent)) {\n\t                        const { name } = flatten_reference(node);\n\t                        const owner = scope.find_owner(name);\n\t                        if (injected_reactive_declaration_vars.has(name)) {\n\t                            hoistable = false;\n\t                        }\n\t                        else if (name[0] === '$' && !owner) {\n\t                            hoistable = false;\n\t                        }\n\t                        else if (owner === instance_scope) {\n\t                            const variable = var_lookup.get(name);\n\t                            if (variable.reassigned || variable.mutated)\n\t                                hoistable = false;\n\t                            if (name === fn_declaration.id.name)\n\t                                return;\n\t                            if (variable.hoistable)\n\t                                return;\n\t                            if (top_level_function_declarations.has(name)) {\n\t                                const other_declaration = top_level_function_declarations.get(name);\n\t                                if (walking.has(other_declaration)) {\n\t                                    hoistable = false;\n\t                                }\n\t                                else if (other_declaration.type === 'ExportNamedDeclaration' &&\n\t                                    walking.has(other_declaration.declaration)) {\n\t                                    hoistable = false;\n\t                                }\n\t                                else if (!is_hoistable(other_declaration)) {\n\t                                    hoistable = false;\n\t                                }\n\t                            }\n\t                            else {\n\t                                hoistable = false;\n\t                            }\n\t                        }\n\t                        this.skip();\n\t                    }\n\t                },\n\t                leave(node) {\n\t                    if (map.has(node)) {\n\t                        scope = scope.parent;\n\t                    }\n\t                },\n\t            });\n\t            checked.add(fn_declaration);\n\t            walking.delete(fn_declaration);\n\t            return hoistable;\n\t        };\n\t        for (const [name, node] of top_level_function_declarations) {\n\t            if (is_hoistable(node)) {\n\t                const variable = this.var_lookup.get(name);\n\t                variable.hoistable = true;\n\t                hoistable_nodes.add(node);\n\t                const i = body.indexOf(node);\n\t                body.splice(i, 1);\n\t                this.fully_hoisted.push(node);\n\t            }\n\t        }\n\t        for (const { specifiers } of imports) {\n\t            for (const specifier of specifiers) {\n\t                const variable = var_lookup.get(specifier.local.name);\n\t                if (!variable.mutated || variable.subscribable) {\n\t                    variable.hoistable = true;\n\t                }\n\t            }\n\t        }\n\t    }\n\t    extract_reactive_declarations() {\n\t        const component = this;\n\t        const unsorted_reactive_declarations = [];\n\t        this.ast.instance.content.body.forEach(node => {\n\t            if (node.type === 'LabeledStatement' && node.label.name === '$') {\n\t                this.reactive_declaration_nodes.add(node);\n\t                const assignees = new Set();\n\t                const assignee_nodes = new Set();\n\t                const dependencies = new Set();\n\t                let scope = this.instance_scope;\n\t                const map = this.instance_scope_map;\n\t                walk(node.body, {\n\t                    enter(node, parent) {\n\t                        if (map.has(node)) {\n\t                            scope = map.get(node);\n\t                        }\n\t                        if (node.type === 'AssignmentExpression') {\n\t                            const left = get_object(node.left);\n\t                            extract_identifiers(left).forEach(node => {\n\t                                assignee_nodes.add(node);\n\t                                assignees.add(node.name);\n\t                            });\n\t                            if (node.operator !== '=') {\n\t                                dependencies.add(left.name);\n\t                            }\n\t                        }\n\t                        else if (node.type === 'UpdateExpression') {\n\t                            const identifier = get_object(node.argument);\n\t                            assignees.add(identifier.name);\n\t                        }\n\t                        else if (isReference(node, parent)) {\n\t                            const identifier = get_object(node);\n\t                            if (!assignee_nodes.has(identifier)) {\n\t                                const { name } = identifier;\n\t                                const owner = scope.find_owner(name);\n\t                                const variable = component.var_lookup.get(name);\n\t                                if (variable)\n\t                                    variable.is_reactive_dependency = true;\n\t                                const is_writable_or_mutated = variable && (variable.writable || variable.mutated);\n\t                                if ((!owner || owner === component.instance_scope) &&\n\t                                    (name[0] === '$' || is_writable_or_mutated)) {\n\t                                    dependencies.add(name);\n\t                                }\n\t                            }\n\t                            this.skip();\n\t                        }\n\t                    },\n\t                    leave(node) {\n\t                        if (map.has(node)) {\n\t                            scope = scope.parent;\n\t                        }\n\t                    },\n\t                });\n\t                const { expression } = node.body;\n\t                const declaration = expression && expression.left;\n\t                unsorted_reactive_declarations.push({\n\t                    assignees,\n\t                    dependencies,\n\t                    node,\n\t                    declaration,\n\t                });\n\t            }\n\t        });\n\t        const lookup = new Map();\n\t        unsorted_reactive_declarations.forEach(declaration => {\n\t            declaration.assignees.forEach(name => {\n\t                if (!lookup.has(name)) {\n\t                    lookup.set(name, []);\n\t                }\n\t                // TODO warn or error if a name is assigned to in\n\t                // multiple reactive declarations?\n\t                lookup.get(name).push(declaration);\n\t            });\n\t        });\n\t        const cycle = check_graph_for_cycles(unsorted_reactive_declarations.reduce((acc, declaration) => {\n\t            declaration.assignees.forEach(v => {\n\t                declaration.dependencies.forEach(w => {\n\t                    if (!declaration.assignees.has(w)) {\n\t                        acc.push([v, w]);\n\t                    }\n\t                });\n\t            });\n\t            return acc;\n\t        }, []));\n\t        if (cycle && cycle.length) {\n\t            const declarationList = lookup.get(cycle[0]);\n\t            const declaration = declarationList[0];\n\t            this.error(declaration.node, {\n\t                code: 'cyclical-reactive-declaration',\n\t                message: `Cyclical dependency detected: ${cycle.join(' \u2192 ')}`\n\t            });\n\t        }\n\t        const add_declaration = declaration => {\n\t            if (this.reactive_declarations.includes(declaration))\n\t                return;\n\t            declaration.dependencies.forEach(name => {\n\t                if (declaration.assignees.has(name))\n\t                    return;\n\t                const earlier_declarations = lookup.get(name);\n\t                if (earlier_declarations)\n\t                    earlier_declarations.forEach(add_declaration);\n\t            });\n\t            this.reactive_declarations.push(declaration);\n\t        };\n\t        unsorted_reactive_declarations.forEach(add_declaration);\n\t    }\n\t    warn_if_undefined(name, node, template_scope) {\n\t        if (name[0] === '$') {\n\t            if (name === '$' || name[1] === '$' && !is_reserved_keyword(name)) {\n\t                this.error(node, {\n\t                    code: 'illegal-global',\n\t                    message: `${name} is an illegal variable name`\n\t                });\n\t            }\n\t            this.has_reactive_assignments = true; // TODO does this belong here?\n\t            if (is_reserved_keyword(name))\n\t                return;\n\t            name = name.slice(1);\n\t        }\n\t        if (this.var_lookup.has(name) && !this.var_lookup.get(name).global)\n\t            return;\n\t        if (template_scope && template_scope.names.has(name))\n\t            return;\n\t        if (globals.has(name) && node.type !== 'InlineComponent')\n\t            return;\n\t        let message = `'${name}' is not defined`;\n\t        if (!this.ast.instance)\n\t            message += `. Consider adding a <script> block with 'export let ${name}' to declare a prop`;\n\t        this.warn(node, {\n\t            code: 'missing-declaration',\n\t            message,\n\t        });\n\t    }\n\t    push_ignores(ignores) {\n\t        this.ignores = new Set(this.ignores || []);\n\t        add_to_set(this.ignores, ignores);\n\t        this.ignore_stack.push(this.ignores);\n\t    }\n\t    pop_ignores() {\n\t        this.ignore_stack.pop();\n\t        this.ignores = this.ignore_stack[this.ignore_stack.length - 1];\n\t    }\n\t}\n\tfunction process_component_options(component, nodes) {\n\t    const component_options = {\n\t        immutable: component.compile_options.immutable || false,\n\t        accessors: 'accessors' in component.compile_options\n\t            ? component.compile_options.accessors\n\t            : !!component.compile_options.customElement,\n\t        preserveWhitespace: !!component.compile_options.preserveWhitespace,\n\t    };\n\t    const node = nodes.find(node => node.name === 'svelte:options');\n\t    function get_value(attribute, code, message) {\n\t        const { value } = attribute;\n\t        const chunk = value[0];\n\t        if (!chunk)\n\t            return true;\n\t        if (value.length > 1) {\n\t            component.error(attribute, { code, message });\n\t        }\n\t        if (chunk.type === 'Text')\n\t            return chunk.data;\n\t        if (chunk.expression.type !== 'Literal') {\n\t            component.error(attribute, { code, message });\n\t        }\n\t        return chunk.expression.value;\n\t    }\n\t    if (node) {\n\t        node.attributes.forEach(attribute => {\n\t            if (attribute.type === 'Attribute') {\n\t                const { name } = attribute;\n\t                switch (name) {\n\t                    case 'tag': {\n\t                        const code = 'invalid-tag-attribute';\n\t                        const message = `'tag' must be a string literal`;\n\t                        const tag = get_value(attribute, code, message);\n\t                        if (typeof tag !== 'string' && tag !== null)\n\t                            component.error(attribute, { code, message });\n\t                        if (tag && !/^[a-zA-Z][a-zA-Z0-9]*-[a-zA-Z0-9-]+$/.test(tag)) {\n\t                            component.error(attribute, {\n\t                                code: `invalid-tag-property`,\n\t                                message: `tag name must be two or more words joined by the '-' character`,\n\t                            });\n\t                        }\n\t                        if (tag && !component.compile_options.customElement) {\n\t                            component.warn(attribute, {\n\t                                code: 'missing-custom-element-compile-options',\n\t                                message: `The 'tag' option is used when generating a custom element. Did you forget the 'customElement: true' compile option?`\n\t                            });\n\t                        }\n\t                        component_options.tag = tag;\n\t                        break;\n\t                    }\n\t                    case 'namespace': {\n\t                        const code = 'invalid-namespace-attribute';\n\t                        const message = `The 'namespace' attribute must be a string literal representing a valid namespace`;\n\t                        const ns = get_value(attribute, code, message);\n\t                        if (typeof ns !== 'string')\n\t                            component.error(attribute, { code, message });\n\t                        if (valid_namespaces.indexOf(ns) === -1) {\n\t                            const match = fuzzymatch(ns, valid_namespaces);\n\t                            if (match) {\n\t                                component.error(attribute, {\n\t                                    code: `invalid-namespace-property`,\n\t                                    message: `Invalid namespace '${ns}' (did you mean '${match}'?)`,\n\t                                });\n\t                            }\n\t                            else {\n\t                                component.error(attribute, {\n\t                                    code: `invalid-namespace-property`,\n\t                                    message: `Invalid namespace '${ns}'`,\n\t                                });\n\t                            }\n\t                        }\n\t                        component_options.namespace = ns;\n\t                        break;\n\t                    }\n\t                    case 'accessors':\n\t                    case 'immutable':\n\t                    case 'preserveWhitespace': {\n\t                        const code = `invalid-${name}-value`;\n\t                        const message = `${name} attribute must be true or false`;\n\t                        const value = get_value(attribute, code, message);\n\t                        if (typeof value !== 'boolean')\n\t                            component.error(attribute, { code, message });\n\t                        component_options[name] = value;\n\t                        break;\n\t                    }\n\t                    default:\n\t                        component.error(attribute, {\n\t                            code: `invalid-options-attribute`,\n\t                            message: `<svelte:options> unknown attribute`,\n\t                        });\n\t                }\n\t            }\n\t            else {\n\t                component.error(attribute, {\n\t                    code: `invalid-options-attribute`,\n\t                    message: `<svelte:options> can only have static 'tag', 'namespace', 'accessors', 'immutable' and 'preserveWhitespace' attributes`,\n\t                });\n\t            }\n\t        });\n\t    }\n\t    return component_options;\n\t}\n\tfunction get_relative_path(from, to) {\n\t    const from_parts = from.split(/[/\\\\]/);\n\t    const to_parts = to.split(/[/\\\\]/);\n\t    from_parts.pop(); // get dirname\n\t    while (from_parts[0] === to_parts[0]) {\n\t        from_parts.shift();\n\t        to_parts.shift();\n\t    }\n\t    if (from_parts.length) {\n\t        let i = from_parts.length;\n\t        while (i--)\n\t            from_parts[i] = '..';\n\t    }\n\t    return from_parts.concat(to_parts).join('/');\n\t}\n\n\tfunction get_name_from_filename(filename) {\n\t    if (!filename)\n\t        return null;\n\t    const parts = filename.split(/[/\\\\]/).map(encodeURI);\n\t    if (parts.length > 1) {\n\t        const index_match = parts[parts.length - 1].match(/^index(\\.\\w+)/);\n\t        if (index_match) {\n\t            parts.pop();\n\t            parts[parts.length - 1] += index_match[1];\n\t        }\n\t    }\n\t    const base = parts.pop()\n\t        .replace(/%/g, 'u')\n\t        .replace(/\\.[^.]+$/, \"\")\n\t        .replace(/[^a-zA-Z_$0-9]+/g, '_')\n\t        .replace(/^_/, '')\n\t        .replace(/_$/, '')\n\t        .replace(/^(\\d)/, '_$1');\n\t    if (!base) {\n\t        throw new Error(`Could not derive component name from file ${filename}`);\n\t    }\n\t    return base[0].toUpperCase() + base.slice(1);\n\t}\n\n\tconst valid_options = [\n\t    'format',\n\t    'name',\n\t    'filename',\n\t    'generate',\n\t    'outputFilename',\n\t    'cssOutputFilename',\n\t    'sveltePath',\n\t    'dev',\n\t    'accessors',\n\t    'immutable',\n\t    'hydratable',\n\t    'legacy',\n\t    'customElement',\n\t    'tag',\n\t    'css',\n\t    'loopGuardTimeout',\n\t    'preserveComments',\n\t    'preserveWhitespace'\n\t];\n\tfunction validate_options(options, warnings) {\n\t    const { name, filename, loopGuardTimeout, dev } = options;\n\t    Object.keys(options).forEach(key => {\n\t        if (!valid_options.includes(key)) {\n\t            const match = fuzzymatch(key, valid_options);\n\t            let message = `Unrecognized option '${key}'`;\n\t            if (match)\n\t                message += ` (did you mean '${match}'?)`;\n\t            throw new Error(message);\n\t        }\n\t    });\n\t    if (name && !/^[a-zA-Z_$][a-zA-Z_$0-9]*$/.test(name)) {\n\t        throw new Error(`options.name must be a valid identifier (got '${name}')`);\n\t    }\n\t    if (name && /^[a-z]/.test(name)) {\n\t        const message = `options.name should be capitalised`;\n\t        warnings.push({\n\t            code: `options-lowercase-name`,\n\t            message,\n\t            filename,\n\t            toString: () => message,\n\t        });\n\t    }\n\t    if (loopGuardTimeout && !dev) {\n\t        const message = 'options.loopGuardTimeout is for options.dev = true only';\n\t        warnings.push({\n\t            code: `options-loop-guard-timeout`,\n\t            message,\n\t            filename,\n\t            toString: () => message,\n\t        });\n\t    }\n\t}\n\tfunction compile(source, options = {}) {\n\t    options = assign({ generate: 'dom', dev: false }, options);\n\t    const stats = new Stats();\n\t    const warnings = [];\n\t    validate_options(options, warnings);\n\t    stats.start('parse');\n\t    const ast = parse$3(source, options);\n\t    stats.stop('parse');\n\t    stats.start('create component');\n\t    const component = new Component(ast, source, options.name || get_name_from_filename(options.filename) || 'Component', options, stats, warnings);\n\t    stats.stop('create component');\n\t    const result = options.generate === false\n\t        ? null\n\t        : options.generate === 'ssr'\n\t            ? ssr(component, options)\n\t            : dom(component, options);\n\t    return component.generate(result);\n\t}\n\n\tfunction parse_attributes(str) {\n\t    const attrs = {};\n\t    str.split(/\\s+/).filter(Boolean).forEach(attr => {\n\t        const p = attr.indexOf('=');\n\t        if (p === -1) {\n\t            attrs[attr] = true;\n\t        }\n\t        else {\n\t            attrs[attr.slice(0, p)] = `'\"`.includes(attr[p + 1]) ?\n\t                attr.slice(p + 2, -1) :\n\t                attr.slice(p + 1);\n\t        }\n\t    });\n\t    return attrs;\n\t}\n\tasync function replace_async(str, re, func) {\n\t    const replacements = [];\n\t    str.replace(re, (...args) => {\n\t        replacements.push(func(...args).then(res => ({\n\t            offset: args[args.length - 2],\n\t            length: args[0].length,\n\t            replacement: res,\n\t        })));\n\t        return '';\n\t    });\n\t    let out = '';\n\t    let last_end = 0;\n\t    for (const { offset, length, replacement } of await Promise.all(replacements)) {\n\t        out += str.slice(last_end, offset) + replacement;\n\t        last_end = offset + length;\n\t    }\n\t    out += str.slice(last_end);\n\t    return out;\n\t}\n\tasync function preprocess(source, preprocessor, options) {\n\t    // @ts-ignore todo: doublecheck\n\t    const filename = (options && options.filename) || preprocessor.filename; // legacy\n\t    const dependencies = [];\n\t    const preprocessors = Array.isArray(preprocessor) ? preprocessor : [preprocessor];\n\t    const markup = preprocessors.map(p => p.markup).filter(Boolean);\n\t    const script = preprocessors.map(p => p.script).filter(Boolean);\n\t    const style = preprocessors.map(p => p.style).filter(Boolean);\n\t    for (const fn of markup) {\n\t        const processed = await fn({\n\t            content: source,\n\t            filename\n\t        });\n\t        if (processed && processed.dependencies)\n\t            dependencies.push(...processed.dependencies);\n\t        source = processed ? processed.code : source;\n\t    }\n\t    for (const fn of script) {\n\t        source = await replace_async(source, /<!--[^]*?-->|<script(\\s[^]*?)?(?:>([^]*?)<\\/script>|\\/>)/gi, async (match, attributes = '', content = '') => {\n\t            if (!attributes && !content) {\n\t                return match;\n\t            }\n\t            attributes = attributes || '';\n\t            const processed = await fn({\n\t                content,\n\t                attributes: parse_attributes(attributes),\n\t                filename\n\t            });\n\t            if (processed && processed.dependencies)\n\t                dependencies.push(...processed.dependencies);\n\t            return processed ? `<script${attributes}>${processed.code}</script>` : match;\n\t        });\n\t    }\n\t    for (const fn of style) {\n\t        source = await replace_async(source, /<!--[^]*?-->|<style(\\s[^]*?)?(?:>([^]*?)<\\/style>|\\/>)/gi, async (match, attributes = '', content = '') => {\n\t            if (!attributes && !content) {\n\t                return match;\n\t            }\n\t            const processed = await fn({\n\t                content,\n\t                attributes: parse_attributes(attributes),\n\t                filename\n\t            });\n\t            if (processed && processed.dependencies)\n\t                dependencies.push(...processed.dependencies);\n\t            return processed ? `<style${attributes}>${processed.code}</style>` : match;\n\t        });\n\t    }\n\t    return {\n\t        // TODO return separated output, in future version where svelte.compile supports it:\n\t        // style: { code: styleCode, map: styleMap },\n\t        // script { code: scriptCode, map: scriptMap },\n\t        // markup { code: markupCode, map: markupMap },\n\t        code: source,\n\t        dependencies: [...new Set(dependencies)],\n\t        toString() {\n\t            return source;\n\t        }\n\t    };\n\t}\n\n\tconst VERSION = '3.24.0';\n\n\texports.VERSION = VERSION;\n\texports.compile = compile;\n\texports.parse = parse$3;\n\texports.preprocess = preprocess;\n\texports.walk = walk;\n\n\tObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceMappingURL=compiler.js.map\n", "export * as types from './types';\n\nimport './worker';\n", "import * as z from 'zod';\n\nexport const FileCreateEvent = z.object({\n  event: z.literal('file_create'),\n  content: z.string(),\n  href: z.string(),\n});\nexport type FileCreateEvent = z.infer<typeof FileCreateEvent>;\n\nexport const FileRemoveEvent = z.object({\n  event: z.literal('file_remove'),\n  href: z.string(),\n});\nexport type FileRemoveEvent = z.infer<typeof FileRemoveEvent>;\n\nexport const FileUpdateEvent = z.object({\n  event: z.literal('file_update'),\n  content: z.string(),\n  href: z.string(),\n});\nexport type FileUpdateEvent = z.infer<typeof FileUpdateEvent>;\n\nexport const EditorEvent = z.union([FileCreateEvent, FileRemoveEvent, FileUpdateEvent]);\nexport type EditorEvent = z.infer<typeof EditorEvent>;\n\nexport const EditorEvents = z.array(EditorEvent);\nexport type EditorEvents = z.infer<typeof EditorEvents>;\n\nexport const BuiltState = z.object({\n  state: z.literal('built'),\n  href: z.string(),\n  start: z.number().int(),\n  end: z.number().int(),\n});\nexport type BuiltState = z.infer<typeof BuiltState>;\n\nexport const BuildingState = z.object({\n  state: z.literal('building'),\n  completed: z.number(),\n  pending: z.number(),\n});\nexport type BuildingState = z.infer<typeof BuildingState>;\n\nexport const ErrorState = z.object({\n  state: z.literal('error'),\n  error: z.object({\n    message: z.string(),\n  }),\n});\nexport type ErrorState = z.infer<typeof ErrorState>;\n\nexport const InitialState = z.object({\n  state: z.literal('initial'),\n});\nexport type InitialState = z.infer<typeof InitialState>;\n\nexport const WorkerState = z.union([BuildingState, BuiltState, ErrorState, InitialState]);\nexport type WorkerState = z.infer<typeof WorkerState>;\n", "abstract class BaseError extends Error {\n  readonly name = this.constructor.name;\n}\n\nexport class GraphBuildError extends BaseError {\n  constructor(readonly errors: Error[]) {\n    super(\n      `Graph building failed with errors:\\n${errors.map((err) => `  ${err.message}`).join('\\n')}`\n    );\n  }\n}\n", "import type { Uri } from './uri';\n\nabstract class BaseError extends Error {\n  readonly name = this.constructor.name;\n}\n\nexport class AmbiguousModuleError extends BaseError {}\n\nexport class CanceledError extends BaseError {}\n\nexport class EntryExcludedError extends BaseError {\n  constructor(uri: { toString(): string }) {\n    super(`Entry was excluded by current configuration '${uri.toString()}'`);\n  }\n}\n\nexport class EntryNotFoundError extends BaseError {\n  constructor(uri: { toString(): string }) {\n    super(`Unable to resolve '${uri.toString()}'`);\n  }\n}\n\nexport class DependencyNotFoundError extends EntryNotFoundError {\n  constructor(spec: string, parentUri: { toString(): string }) {\n    super(`The dependency '${spec}' of '${parentUri.toString()}' was not found`);\n  }\n}\n\nexport class NotResolvableError extends BaseError {}\n\nexport class ParseError extends BaseError {\n  constructor(readonly uri: Uri, message: string) {\n    super(`Parsing failed for '${uri.toString()}': ${message}`);\n  }\n}\n\nexport function isCanceledError(err: unknown): err is CanceledError {\n  return err instanceof CanceledError || (err && (err as any).name === 'CanceledError');\n}\n", "import type { CancellationToken } from 'ts-primitives';\nimport { CanceledError } from './error';\n\nexport type Awaited<T> = T extends Thenable<infer U> ? U : T;\n\nexport interface Thenable<T> {\n  /**\n   * Attaches callbacks for the resolution and/or rejection of the Promise.\n   * @param onfulfilled The callback to execute when the Promise is resolved.\n   * @param onrejected The callback to execute when the Promise is rejected.\n   * @returns A Promise for the completion of which ever callback is executed.\n   */\n  then<TResult>(\n    onfulfilled?: (value: T) => TResult | Thenable<TResult>,\n    onrejected?: (reason: any) => TResult | Thenable<TResult>\n  ): Thenable<TResult>;\n  then<TResult>(\n    onfulfilled?: (value: T) => TResult | Thenable<TResult>,\n    onrejected?: (reason: any) => void\n  ): Thenable<TResult>;\n}\n\n// See: https://github.com/microsoft/TypeScript/pull/26063#issuecomment-461576933\nexport function all<T extends [unknown] | unknown[]>(values: T, token: CancellationToken) {\n  let shouldAwait = false;\n\n  const result = values.map((element) => {\n    if (isThenable(element)) {\n      shouldAwait = true;\n\n      return checkCancellation(element, token);\n    }\n\n    return element;\n  }) as T;\n\n  if (shouldAwait) {\n    return (Promise.all(result) as unknown) as Promise<{ [P in keyof T]: Awaited<T[P]> }>;\n  }\n\n  return values as { [P in keyof T]: Awaited<T[P]> };\n}\n\nexport async function checkCancellation<T>(promise: Thenable<T>, token: CancellationToken) {\n  try {\n    const result = await promise;\n    if (token.isCancellationRequested) {\n      return Promise.reject(new CanceledError());\n    }\n\n    return result;\n  } catch (err) {\n    if (token.isCancellationRequested) {\n      return Promise.reject(new CanceledError());\n    }\n\n    throw err;\n  }\n}\n\nexport function isThenable<T = unknown>(object: unknown): object is Thenable<T> {\n  return (\n    object &&\n    // Detection of 'normal' thenable\n    (typeof (object as any).then === 'function' ||\n      // Detection for regenerator runtime state\n      (typeof (object as any).done === 'boolean' &&\n        typeof (object as any).next === 'number' &&\n        typeof (object as any).pre === 'number'))\n  );\n}\n", "type Buffer = {\n  from(\n    buf: BufferSource | string,\n    encoding?: 'base64'\n  ): {\n    toString(encoding: 'base64' | 'utf-8'): string;\n  };\n};\n\nexport namespace Base64 {\n  export const decode =\n    typeof global === 'object' && typeof global['Buffer'] === 'function'\n      ? (data: string) => (global['Buffer'] as Buffer).from(data, 'base64').toString('utf-8')\n      : typeof atob === 'function'\n      ? (data: string) => decodeURIComponent(escape(atob(data)))\n      : (_data: string) => {\n          throw new Error(\n            'The environment has neither the Buffer nor btoa functions. Please consider polyfilling one of these apis.'\n          );\n        };\n\n  export const encode =\n    typeof global === 'object' && typeof global['Buffer'] === 'function'\n      ? (data: string) => (global['Buffer'] as Buffer).from(data).toString('base64')\n      : typeof btoa === 'function'\n      ? (data: string) => btoa(unescape(encodeURIComponent(data)))\n      : (_data: string) => {\n          throw new Error(\n            'The environment has neither the Buffer nor btoa functions. Please consider polyfilling one of these apis.'\n          );\n        };\n}\n", "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n// Avoid circular dependency on EventEmitter by implementing a subset of the interface.\nclass ErrorHandler {\n    constructor() {\n        this.listeners = [];\n        this.unexpectedErrorHandler = function (e) {\n            setTimeout(() => {\n                if (e.stack) {\n                    throw new Error(e.message + '\\n\\n' + e.stack);\n                }\n                throw e;\n            }, 0);\n        };\n    }\n    addListener(listener) {\n        this.listeners.push(listener);\n        return () => {\n            this._removeListener(listener);\n        };\n    }\n    emit(e) {\n        this.listeners.forEach((listener) => {\n            listener(e);\n        });\n    }\n    _removeListener(listener) {\n        this.listeners.splice(this.listeners.indexOf(listener), 1);\n    }\n    setUnexpectedErrorHandler(newUnexpectedErrorHandler) {\n        this.unexpectedErrorHandler = newUnexpectedErrorHandler;\n    }\n    getUnexpectedErrorHandler() {\n        return this.unexpectedErrorHandler;\n    }\n    onUnexpectedError(e) {\n        this.unexpectedErrorHandler(e);\n        this.emit(e);\n    }\n    // For external errors, we don't want the listeners to be called\n    onUnexpectedExternalError(e) {\n        this.unexpectedErrorHandler(e);\n    }\n}\nconst errorHandler = new ErrorHandler();\nfunction onUnexpectedError(e) {\n    // ignore errors from cancelled promises\n    if (!isPromiseCanceledError(e)) {\n        errorHandler.onUnexpectedError(e);\n    }\n    return undefined;\n}\nconst canceledName = 'Canceled';\n/**\n * Checks if the given error is a promise in canceled state\n */\nfunction isPromiseCanceledError(error) {\n    return error instanceof Error && error.name === canceledName && error.message === canceledName;\n}\n/**\n * Returns an error that signals cancellation.\n */\nfunction canceled() {\n    const error = new Error(canceledName);\n    error.name = error.message;\n    return error;\n}\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nfunction once(fn) {\n    const _this = this;\n    let didCall = false;\n    let result;\n    return function () {\n        if (didCall) {\n            return result;\n        }\n        didCall = true;\n        result = fn.apply(_this, arguments);\n        return result;\n    };\n}\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar Iterable;\n(function (Iterable) {\n    function is(thing) {\n        return thing && typeof thing === 'object' && typeof thing[Symbol.iterator] === 'function';\n    }\n    Iterable.is = is;\n    const _empty = Object.freeze([]);\n    function empty() {\n        return _empty;\n    }\n    Iterable.empty = empty;\n    function* single(element) {\n        yield element;\n    }\n    Iterable.single = single;\n    function from(iterable) {\n        return iterable || _empty;\n    }\n    Iterable.from = from;\n    function first(iterable) {\n        return iterable[Symbol.iterator]().next().value;\n    }\n    Iterable.first = first;\n    function some(iterable, predicate) {\n        for (const element of iterable) {\n            if (predicate(element)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    Iterable.some = some;\n    function* filter(iterable, predicate) {\n        for (const element of iterable) {\n            if (predicate(element)) {\n                yield element;\n            }\n        }\n    }\n    Iterable.filter = filter;\n    function* map(iterable, fn) {\n        for (const element of iterable) {\n            yield fn(element);\n        }\n    }\n    Iterable.map = map;\n    function* concat(...iterables) {\n        for (const iterable of iterables) {\n            for (const element of iterable) {\n                yield element;\n            }\n        }\n    }\n    Iterable.concat = concat;\n    /**\n     * Consumes `atMost` elements from iterable and returns the consumed elements,\n     * and an iterable for the rest of the elements.\n     */\n    function consume(iterable, atMost = Number.POSITIVE_INFINITY) {\n        const consumed = [];\n        if (atMost === 0) {\n            return [consumed, iterable];\n        }\n        const iterator = iterable[Symbol.iterator]();\n        for (let i = 0; i < atMost; i++) {\n            const next = iterator.next();\n            if (next.done) {\n                return [consumed, Iterable.empty()];\n            }\n            consumed.push(next.value);\n        }\n        return [consumed, { [Symbol.iterator]() { return iterator; } }];\n    }\n    Iterable.consume = consume;\n})(Iterable || (Iterable = {}));\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nfunction markTracked(x) {\n    {\n        return;\n    }\n}\nfunction trackDisposable(x) {\n    {\n        return x;\n    }\n}\nfunction isDisposable(thing) {\n    return typeof thing.dispose === 'function' && thing.dispose.length === 0;\n}\nfunction dispose(arg) {\n    if (Iterable.is(arg)) {\n        for (let d of arg) {\n            if (d) {\n                d.dispose();\n            }\n        }\n        return Array.isArray(arg) ? [] : arg;\n    }\n    else if (arg) {\n        arg.dispose();\n        return arg;\n    }\n}\nfunction combinedDisposable(...disposables) {\n    disposables.forEach(markTracked);\n    return trackDisposable({ dispose: () => dispose(disposables) });\n}\nfunction toDisposable(fn) {\n    const self = trackDisposable({\n        dispose: () => {\n            fn();\n        }\n    });\n    return self;\n}\nclass DisposableStore {\n    constructor() {\n        this._toDispose = new Set();\n        this._isDisposed = false;\n    }\n    /**\n     * Dispose of all registered disposables and mark this object as disposed.\n     *\n     * Any future disposables added to this object will be disposed of on `add`.\n     */\n    dispose() {\n        if (this._isDisposed) {\n            return;\n        }\n        this._isDisposed = true;\n        this.clear();\n    }\n    /**\n     * Dispose of all registered disposables but do not mark this object as disposed.\n     */\n    clear() {\n        this._toDispose.forEach(item => item.dispose());\n        this._toDispose.clear();\n    }\n    add(t) {\n        if (!t) {\n            return t;\n        }\n        if (t === this) {\n            throw new Error('Cannot register a disposable on itself!');\n        }\n        if (this._isDisposed) {\n            if (!DisposableStore.DISABLE_DISPOSED_WARNING) {\n                console.warn(new Error('Trying to add a disposable to a DisposableStore that has already been disposed of. The added object will be leaked!').stack);\n            }\n        }\n        else {\n            this._toDispose.add(t);\n        }\n        return t;\n    }\n}\nDisposableStore.DISABLE_DISPOSED_WARNING = false;\nclass Disposable {\n    constructor() {\n        this._store = new DisposableStore();\n    }\n    dispose() {\n        this._store.dispose();\n    }\n    _register(t) {\n        if (t === this) {\n            throw new Error('Cannot register a disposable on itself!');\n        }\n        return this._store.add(t);\n    }\n}\nDisposable.None = Object.freeze({ dispose() { } });\n/**\n * Manages the lifecycle of a disposable value that may be changed.\n *\n * This ensures that when the disposable value is changed, the previously held disposable is disposed of. You can\n * also register a `MutableDisposable` on a `Disposable` to ensure it is automatically cleaned up.\n */\nclass MutableDisposable {\n    constructor() {\n        this._isDisposed = false;\n    }\n    get value() {\n        return this._isDisposed ? undefined : this._value;\n    }\n    set value(value) {\n        if (this._isDisposed || value === this._value) {\n            return;\n        }\n        if (this._value) {\n            this._value.dispose();\n        }\n        this._value = value;\n    }\n    clear() {\n        this.value = undefined;\n    }\n    dispose() {\n        this._isDisposed = true;\n        if (this._value) {\n            this._value.dispose();\n        }\n        this._value = undefined;\n    }\n}\nclass ReferenceCollection {\n    constructor() {\n        this.references = new Map();\n    }\n    acquire(key, ...args) {\n        let reference = this.references.get(key);\n        if (!reference) {\n            reference = { counter: 0, object: this.createReferencedObject(key, ...args) };\n            this.references.set(key, reference);\n        }\n        const { object } = reference;\n        const dispose = once(() => {\n            if (--reference.counter === 0) {\n                this.destroyReferencedObject(key, reference.object);\n                this.references.delete(key);\n            }\n        });\n        reference.counter++;\n        return { object, dispose };\n    }\n}\nclass ImmortalReference {\n    constructor(object) {\n        this.object = object;\n    }\n    dispose() { }\n}\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nclass Node {\n    constructor(element) {\n        this.element = element;\n        this.next = Node.Undefined;\n        this.prev = Node.Undefined;\n    }\n}\nNode.Undefined = new Node(undefined);\nclass LinkedList {\n    constructor() {\n        this._first = Node.Undefined;\n        this._last = Node.Undefined;\n        this._size = 0;\n    }\n    get size() {\n        return this._size;\n    }\n    isEmpty() {\n        return this._first === Node.Undefined;\n    }\n    clear() {\n        this._first = Node.Undefined;\n        this._last = Node.Undefined;\n        this._size = 0;\n    }\n    unshift(element) {\n        return this._insert(element, false);\n    }\n    push(element) {\n        return this._insert(element, true);\n    }\n    _insert(element, atTheEnd) {\n        const newNode = new Node(element);\n        if (this._first === Node.Undefined) {\n            this._first = newNode;\n            this._last = newNode;\n        }\n        else if (atTheEnd) {\n            // push\n            const oldLast = this._last;\n            this._last = newNode;\n            newNode.prev = oldLast;\n            oldLast.next = newNode;\n        }\n        else {\n            // unshift\n            const oldFirst = this._first;\n            this._first = newNode;\n            newNode.next = oldFirst;\n            oldFirst.prev = newNode;\n        }\n        this._size += 1;\n        let didRemove = false;\n        return () => {\n            if (!didRemove) {\n                didRemove = true;\n                this._remove(newNode);\n            }\n        };\n    }\n    shift() {\n        if (this._first === Node.Undefined) {\n            return undefined;\n        }\n        else {\n            const res = this._first.element;\n            this._remove(this._first);\n            return res;\n        }\n    }\n    pop() {\n        if (this._last === Node.Undefined) {\n            return undefined;\n        }\n        else {\n            const res = this._last.element;\n            this._remove(this._last);\n            return res;\n        }\n    }\n    _remove(node) {\n        if (node.prev !== Node.Undefined && node.next !== Node.Undefined) {\n            // middle\n            const anchor = node.prev;\n            anchor.next = node.next;\n            node.next.prev = anchor;\n        }\n        else if (node.prev === Node.Undefined && node.next === Node.Undefined) {\n            // only node\n            this._first = Node.Undefined;\n            this._last = Node.Undefined;\n        }\n        else if (node.next === Node.Undefined) {\n            // last\n            this._last = this._last.prev;\n            this._last.next = Node.Undefined;\n        }\n        else if (node.prev === Node.Undefined) {\n            // first\n            this._first = this._first.next;\n            this._first.prev = Node.Undefined;\n        }\n        // done\n        this._size -= 1;\n    }\n    *[Symbol.iterator]() {\n        let node = this._first;\n        while (node !== Node.Undefined) {\n            yield node.element;\n            node = node.next;\n        }\n    }\n    toArray() {\n        const result = [];\n        for (let node = this._first; node !== Node.Undefined; node = node.next) {\n            result.push(node.element);\n        }\n        return result;\n    }\n}\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar Event;\n(function (Event) {\n    Event.None = () => Disposable.None;\n    /**\n     * Given an event, returns another event which only fires once.\n     */\n    function once(event) {\n        return (listener, thisArgs = null, disposables) => {\n            // we need this, in case the event fires during the listener call\n            let didFire = false;\n            let result;\n            result = event(e => {\n                if (didFire) {\n                    return;\n                }\n                else if (result) {\n                    result.dispose();\n                }\n                else {\n                    didFire = true;\n                }\n                return listener.call(thisArgs, e);\n            }, null, disposables);\n            if (didFire) {\n                result.dispose();\n            }\n            return result;\n        };\n    }\n    Event.once = once;\n    /**\n     * Given an event and a `map` function, returns another event which maps each element\n     * through the mapping function.\n     */\n    function map(event, map) {\n        return snapshot((listener, thisArgs = null, disposables) => event(i => listener.call(thisArgs, map(i)), null, disposables));\n    }\n    Event.map = map;\n    /**\n     * Given an event and an `each` function, returns another identical event and calls\n     * the `each` function per each element.\n     */\n    function forEach(event, each) {\n        return snapshot((listener, thisArgs = null, disposables) => event(i => { each(i); listener.call(thisArgs, i); }, null, disposables));\n    }\n    Event.forEach = forEach;\n    function filter(event, filter) {\n        return snapshot((listener, thisArgs = null, disposables) => event(e => filter(e) && listener.call(thisArgs, e), null, disposables));\n    }\n    Event.filter = filter;\n    /**\n     * Given an event, returns the same event but typed as `Event<void>`.\n     */\n    function signal(event) {\n        return event;\n    }\n    Event.signal = signal;\n    function any(...events) {\n        return (listener, thisArgs = null, disposables) => combinedDisposable(...events.map(event => event(e => listener.call(thisArgs, e), null, disposables)));\n    }\n    Event.any = any;\n    /**\n     * Given an event and a `merge` function, returns another event which maps each element\n     * and the cumulative result through the `merge` function. Similar to `map`, but with memory.\n     */\n    function reduce(event, merge, initial) {\n        let output = initial;\n        return map(event, e => {\n            output = merge(output, e);\n            return output;\n        });\n    }\n    Event.reduce = reduce;\n    /**\n     * Given a chain of event processing functions (filter, map, etc), each\n     * function will be invoked per event & per listener. Snapshotting an event\n     * chain allows each function to be invoked just once per event.\n     */\n    function snapshot(event) {\n        let listener;\n        const emitter = new Emitter({\n            onFirstListenerAdd() {\n                listener = event(emitter.fire, emitter);\n            },\n            onLastListenerRemove() {\n                listener.dispose();\n            }\n        });\n        return emitter.event;\n    }\n    Event.snapshot = snapshot;\n    function debounce(event, merge, delay = 100, leading = false, leakWarningThreshold) {\n        let subscription;\n        let output = undefined;\n        let handle = undefined;\n        let numDebouncedCalls = 0;\n        const emitter = new Emitter({\n            leakWarningThreshold,\n            onFirstListenerAdd() {\n                subscription = event(cur => {\n                    numDebouncedCalls++;\n                    output = merge(output, cur);\n                    if (leading && !handle) {\n                        emitter.fire(output);\n                        output = undefined;\n                    }\n                    clearTimeout(handle);\n                    handle = setTimeout(() => {\n                        const _output = output;\n                        output = undefined;\n                        handle = undefined;\n                        if (!leading || numDebouncedCalls > 1) {\n                            emitter.fire(_output);\n                        }\n                        numDebouncedCalls = 0;\n                    }, delay);\n                });\n            },\n            onLastListenerRemove() {\n                subscription.dispose();\n            }\n        });\n        return emitter.event;\n    }\n    Event.debounce = debounce;\n    /**\n     * Given an event, it returns another event which fires only once and as soon as\n     * the input event emits. The event data is the number of millis it took for the\n     * event to fire.\n     */\n    function stopwatch(event) {\n        const start = new Date().getTime();\n        return map(once(event), _ => new Date().getTime() - start);\n    }\n    Event.stopwatch = stopwatch;\n    /**\n     * Given an event, it returns another event which fires only when the event\n     * element changes.\n     */\n    function latch(event) {\n        let firstCall = true;\n        let cache;\n        return filter(event, value => {\n            const shouldEmit = firstCall || value !== cache;\n            firstCall = false;\n            cache = value;\n            return shouldEmit;\n        });\n    }\n    Event.latch = latch;\n    /**\n     * Buffers the provided event until a first listener comes\n     * along, at which point fire all the events at once and\n     * pipe the event from then on.\n     *\n     * ```typescript\n     * const emitter = new Emitter<number>();\n     * const event = emitter.event;\n     * const bufferedEvent = buffer(event);\n     *\n     * emitter.fire(1);\n     * emitter.fire(2);\n     * emitter.fire(3);\n     * // nothing...\n     *\n     * const listener = bufferedEvent(num => console.log(num));\n     * // 1, 2, 3\n     *\n     * emitter.fire(4);\n     * // 4\n     * ```\n     */\n    function buffer(event, nextTick = false, _buffer = []) {\n        let buffer = _buffer.slice();\n        let listener = event(e => {\n            if (buffer) {\n                buffer.push(e);\n            }\n            else {\n                emitter.fire(e);\n            }\n        });\n        const flush = () => {\n            if (buffer) {\n                buffer.forEach(e => emitter.fire(e));\n            }\n            buffer = null;\n        };\n        const emitter = new Emitter({\n            onFirstListenerAdd() {\n                if (!listener) {\n                    listener = event(e => emitter.fire(e));\n                }\n            },\n            onFirstListenerDidAdd() {\n                if (buffer) {\n                    if (nextTick) {\n                        setTimeout(flush);\n                    }\n                    else {\n                        flush();\n                    }\n                }\n            },\n            onLastListenerRemove() {\n                if (listener) {\n                    listener.dispose();\n                }\n                listener = null;\n            }\n        });\n        return emitter.event;\n    }\n    Event.buffer = buffer;\n    class ChainableEvent {\n        constructor(event) {\n            this.event = event;\n        }\n        map(fn) {\n            return new ChainableEvent(map(this.event, fn));\n        }\n        forEach(fn) {\n            return new ChainableEvent(forEach(this.event, fn));\n        }\n        filter(fn) {\n            return new ChainableEvent(filter(this.event, fn));\n        }\n        reduce(merge, initial) {\n            return new ChainableEvent(reduce(this.event, merge, initial));\n        }\n        latch() {\n            return new ChainableEvent(latch(this.event));\n        }\n        debounce(merge, delay = 100, leading = false, leakWarningThreshold) {\n            return new ChainableEvent(debounce(this.event, merge, delay, leading, leakWarningThreshold));\n        }\n        on(listener, thisArgs, disposables) {\n            return this.event(listener, thisArgs, disposables);\n        }\n        once(listener, thisArgs, disposables) {\n            return once(this.event)(listener, thisArgs, disposables);\n        }\n    }\n    function chain(event) {\n        return new ChainableEvent(event);\n    }\n    Event.chain = chain;\n    function fromNodeEventEmitter(emitter, eventName, map = id => id) {\n        const fn = (...args) => result.fire(map(...args));\n        const onFirstListenerAdd = () => emitter.on(eventName, fn);\n        const onLastListenerRemove = () => emitter.removeListener(eventName, fn);\n        const result = new Emitter({ onFirstListenerAdd, onLastListenerRemove });\n        return result.event;\n    }\n    Event.fromNodeEventEmitter = fromNodeEventEmitter;\n    function fromDOMEventEmitter(emitter, eventName, map = id => id) {\n        const fn = (...args) => result.fire(map(...args));\n        const onFirstListenerAdd = () => emitter.addEventListener(eventName, fn);\n        const onLastListenerRemove = () => emitter.removeEventListener(eventName, fn);\n        const result = new Emitter({ onFirstListenerAdd, onLastListenerRemove });\n        return result.event;\n    }\n    Event.fromDOMEventEmitter = fromDOMEventEmitter;\n    function fromPromise(promise) {\n        const emitter = new Emitter();\n        let shouldEmit = false;\n        promise\n            .then(undefined, () => null)\n            .then(() => {\n            if (!shouldEmit) {\n                setTimeout(() => emitter.fire(undefined), 0);\n            }\n            else {\n                emitter.fire(undefined);\n            }\n        });\n        shouldEmit = true;\n        return emitter.event;\n    }\n    Event.fromPromise = fromPromise;\n    function toPromise(event) {\n        return new Promise(c => once(event)(c));\n    }\n    Event.toPromise = toPromise;\n})(Event || (Event = {}));\nlet _globalLeakWarningThreshold = -1;\nfunction setGlobalLeakWarningThreshold(n) {\n    const oldValue = _globalLeakWarningThreshold;\n    _globalLeakWarningThreshold = n;\n    return {\n        dispose() {\n            _globalLeakWarningThreshold = oldValue;\n        }\n    };\n}\nclass LeakageMonitor {\n    constructor(customThreshold, name = Math.random().toString(18).slice(2, 5)) {\n        this.customThreshold = customThreshold;\n        this.name = name;\n        this._warnCountdown = 0;\n    }\n    dispose() {\n        if (this._stacks) {\n            this._stacks.clear();\n        }\n    }\n    check(listenerCount) {\n        let threshold = _globalLeakWarningThreshold;\n        if (typeof this.customThreshold === 'number') {\n            threshold = this.customThreshold;\n        }\n        if (threshold <= 0 || listenerCount < threshold) {\n            return undefined;\n        }\n        if (!this._stacks) {\n            this._stacks = new Map();\n        }\n        const stack = new Error().stack.split('\\n').slice(3).join('\\n');\n        const count = (this._stacks.get(stack) || 0);\n        this._stacks.set(stack, count + 1);\n        this._warnCountdown -= 1;\n        if (this._warnCountdown <= 0) {\n            // only warn on first exceed and then every time the limit\n            // is exceeded by 50% again\n            this._warnCountdown = threshold * 0.5;\n            // find most frequent listener and print warning\n            let topStack;\n            let topCount = 0;\n            for (const [stack, count] of this._stacks) {\n                if (!topStack || topCount < count) {\n                    topStack = stack;\n                    topCount = count;\n                }\n            }\n            console.warn(`[${this.name}] potential listener LEAK detected, having ${listenerCount} listeners already. MOST frequent listener (${topCount}):`);\n            console.warn(topStack);\n        }\n        return () => {\n            const count = (this._stacks.get(stack) || 0);\n            this._stacks.set(stack, count - 1);\n        };\n    }\n}\n/**\n * The Emitter can be used to expose an Event to the public\n * to fire it from the insides.\n * Sample:\n    class Document {\n\n        private readonly _onDidChange = new Emitter<(value:string)=>any>();\n\n        public onDidChange = this._onDidChange.event;\n\n        // getter-style\n        // get onDidChange(): Event<(value:string)=>any> {\n        // \treturn this._onDidChange.event;\n        // }\n\n        private _doIt() {\n            //...\n            this._onDidChange.fire(value);\n        }\n    }\n */\nclass Emitter {\n    constructor(options) {\n        this._disposed = false;\n        this._options = options;\n        this._leakageMon = _globalLeakWarningThreshold > 0\n            ? new LeakageMonitor(this._options && this._options.leakWarningThreshold)\n            : undefined;\n    }\n    /**\n     * For the public to allow to subscribe\n     * to events from this Emitter\n     */\n    get event() {\n        if (!this._event) {\n            this._event = (listener, thisArgs, disposables) => {\n                if (!this._listeners) {\n                    this._listeners = new LinkedList();\n                }\n                const firstListener = this._listeners.isEmpty();\n                if (firstListener && this._options && this._options.onFirstListenerAdd) {\n                    this._options.onFirstListenerAdd(this);\n                }\n                const remove = this._listeners.push(!thisArgs ? listener : [listener, thisArgs]);\n                if (firstListener && this._options && this._options.onFirstListenerDidAdd) {\n                    this._options.onFirstListenerDidAdd(this);\n                }\n                if (this._options && this._options.onListenerDidAdd) {\n                    this._options.onListenerDidAdd(this, listener, thisArgs);\n                }\n                // check and record this emitter for potential leakage\n                let removeMonitor;\n                if (this._leakageMon) {\n                    removeMonitor = this._leakageMon.check(this._listeners.size);\n                }\n                let result;\n                result = {\n                    dispose: () => {\n                        if (removeMonitor) {\n                            removeMonitor();\n                        }\n                        result.dispose = Emitter._noop;\n                        if (!this._disposed) {\n                            remove();\n                            if (this._options && this._options.onLastListenerRemove) {\n                                const hasListeners = (this._listeners && !this._listeners.isEmpty());\n                                if (!hasListeners) {\n                                    this._options.onLastListenerRemove(this);\n                                }\n                            }\n                        }\n                    }\n                };\n                if (disposables instanceof DisposableStore) {\n                    disposables.add(result);\n                }\n                else if (Array.isArray(disposables)) {\n                    disposables.push(result);\n                }\n                return result;\n            };\n        }\n        return this._event;\n    }\n    /**\n     * To be kept private to fire an event to\n     * subscribers\n     */\n    fire(event) {\n        if (this._listeners) {\n            // put all [listener,event]-pairs into delivery queue\n            // then emit all event. an inner/nested event might be\n            // the driver of this\n            if (!this._deliveryQueue) {\n                this._deliveryQueue = new LinkedList();\n            }\n            for (let listener of this._listeners) {\n                this._deliveryQueue.push([listener, event]);\n            }\n            while (this._deliveryQueue.size > 0) {\n                const [listener, event] = this._deliveryQueue.shift();\n                try {\n                    if (typeof listener === 'function') {\n                        listener.call(undefined, event);\n                    }\n                    else {\n                        listener[0].call(listener[1], event);\n                    }\n                }\n                catch (e) {\n                    onUnexpectedError(e);\n                }\n            }\n        }\n    }\n    dispose() {\n        if (this._listeners) {\n            this._listeners.clear();\n        }\n        if (this._deliveryQueue) {\n            this._deliveryQueue.clear();\n        }\n        if (this._leakageMon) {\n            this._leakageMon.dispose();\n        }\n        this._disposed = true;\n    }\n}\nEmitter._noop = function () { };\nclass PauseableEmitter extends Emitter {\n    constructor(options) {\n        super(options);\n        this._isPaused = 0;\n        this._eventQueue = new LinkedList();\n        this._mergeFn = options && options.merge;\n    }\n    pause() {\n        this._isPaused++;\n    }\n    resume() {\n        if (this._isPaused !== 0 && --this._isPaused === 0) {\n            if (this._mergeFn) {\n                // use the merge function to create a single composite\n                // event. make a copy in case firing pauses this emitter\n                const events = this._eventQueue.toArray();\n                this._eventQueue.clear();\n                super.fire(this._mergeFn(events));\n            }\n            else {\n                // no merging, fire each event individually and test\n                // that this emitter isn't paused halfway through\n                while (!this._isPaused && this._eventQueue.size !== 0) {\n                    super.fire(this._eventQueue.shift());\n                }\n            }\n        }\n    }\n    fire(event) {\n        if (this._listeners) {\n            if (this._isPaused !== 0) {\n                this._eventQueue.push(event);\n            }\n            else {\n                super.fire(event);\n            }\n        }\n    }\n}\nclass AsyncEmitter extends Emitter {\n    async fireAsync(data, token, promiseJoin) {\n        if (!this._listeners) {\n            return;\n        }\n        if (!this._asyncDeliveryQueue) {\n            this._asyncDeliveryQueue = new LinkedList();\n        }\n        for (const listener of this._listeners) {\n            this._asyncDeliveryQueue.push([listener, data]);\n        }\n        while (this._asyncDeliveryQueue.size > 0 && !token.isCancellationRequested) {\n            const [listener, data] = this._asyncDeliveryQueue.shift();\n            const thenables = [];\n            const event = {\n                ...data,\n                waitUntil: (p) => {\n                    if (Object.isFrozen(thenables)) {\n                        throw new Error('waitUntil can NOT be called asynchronous');\n                    }\n                    if (promiseJoin) {\n                        p = promiseJoin(p, typeof listener === 'function' ? listener : listener[0]);\n                    }\n                    thenables.push(p);\n                }\n            };\n            try {\n                if (typeof listener === 'function') {\n                    listener.call(undefined, event);\n                }\n                else {\n                    listener[0].call(listener[1], event);\n                }\n            }\n            catch (e) {\n                onUnexpectedError(e);\n                continue;\n            }\n            // freeze thenables-collection to enforce sync-calls to\n            // wait until and then wait for all thenables to resolve\n            Object.freeze(thenables);\n            await Promise.all(thenables).catch(e => onUnexpectedError(e));\n        }\n    }\n}\nclass EventMultiplexer {\n    constructor() {\n        this.hasListeners = false;\n        this.events = [];\n        this.emitter = new Emitter({\n            onFirstListenerAdd: () => this.onFirstListenerAdd(),\n            onLastListenerRemove: () => this.onLastListenerRemove()\n        });\n    }\n    get event() {\n        return this.emitter.event;\n    }\n    add(event) {\n        const e = { event: event, listener: null };\n        this.events.push(e);\n        if (this.hasListeners) {\n            this.hook(e);\n        }\n        const dispose = () => {\n            if (this.hasListeners) {\n                this.unhook(e);\n            }\n            const idx = this.events.indexOf(e);\n            this.events.splice(idx, 1);\n        };\n        return toDisposable(once(dispose));\n    }\n    onFirstListenerAdd() {\n        this.hasListeners = true;\n        this.events.forEach(e => this.hook(e));\n    }\n    onLastListenerRemove() {\n        this.hasListeners = false;\n        this.events.forEach(e => this.unhook(e));\n    }\n    hook(e) {\n        e.listener = e.event(r => this.emitter.fire(r));\n    }\n    unhook(e) {\n        if (e.listener) {\n            e.listener.dispose();\n        }\n        e.listener = null;\n    }\n    dispose() {\n        this.emitter.dispose();\n    }\n}\n/**\n * The EventBufferer is useful in situations in which you want\n * to delay firing your events during some code.\n * You can wrap that code and be sure that the event will not\n * be fired during that wrap.\n *\n * ```\n * const emitter: Emitter;\n * const delayer = new EventDelayer();\n * const delayedEvent = delayer.wrapEvent(emitter.event);\n *\n * delayedEvent(console.log);\n *\n * delayer.bufferEvents(() => {\n *   emitter.fire(); // event will not be fired yet\n * });\n *\n * // event will only be fired at this point\n * ```\n */\nclass EventBufferer {\n    constructor() {\n        this.buffers = [];\n    }\n    wrapEvent(event) {\n        return (listener, thisArgs, disposables) => {\n            return event(i => {\n                const buffer = this.buffers[this.buffers.length - 1];\n                if (buffer) {\n                    buffer.push(() => listener.call(thisArgs, i));\n                }\n                else {\n                    listener.call(thisArgs, i);\n                }\n            }, undefined, disposables);\n        };\n    }\n    bufferEvents(fn) {\n        const buffer = [];\n        this.buffers.push(buffer);\n        const r = fn();\n        this.buffers.pop();\n        buffer.forEach(flush => flush());\n        return r;\n    }\n}\n/**\n * A Relay is an event forwarder which functions as a replugabble event pipe.\n * Once created, you can connect an input event to it and it will simply forward\n * events from that input event through its own `event` property. The `input`\n * can be changed at any point in time.\n */\nclass Relay {\n    constructor() {\n        this.listening = false;\n        this.inputEvent = Event.None;\n        this.inputEventListener = Disposable.None;\n        this.emitter = new Emitter({\n            onFirstListenerDidAdd: () => {\n                this.listening = true;\n                this.inputEventListener = this.inputEvent(this.emitter.fire, this.emitter);\n            },\n            onLastListenerRemove: () => {\n                this.listening = false;\n                this.inputEventListener.dispose();\n            }\n        });\n        this.event = this.emitter.event;\n    }\n    set input(event) {\n        this.inputEvent = event;\n        if (this.listening) {\n            this.inputEventListener.dispose();\n            this.inputEventListener = event(this.emitter.fire, this.emitter);\n        }\n    }\n    dispose() {\n        this.inputEventListener.dispose();\n        this.emitter.dispose();\n    }\n}\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nconst shortcutEvent = Object.freeze(function (callback, context) {\n    const handle = setTimeout(callback.bind(context), 0);\n    return { dispose() { clearTimeout(handle); } };\n});\nvar CancellationToken;\n(function (CancellationToken) {\n    function isCancellationToken(thing) {\n        if (thing === CancellationToken.None || thing === CancellationToken.Cancelled) {\n            return true;\n        }\n        if (thing instanceof MutableToken) {\n            return true;\n        }\n        if (!thing || typeof thing !== 'object') {\n            return false;\n        }\n        return typeof thing.isCancellationRequested === 'boolean'\n            && typeof thing.onCancellationRequested === 'function';\n    }\n    CancellationToken.isCancellationToken = isCancellationToken;\n    CancellationToken.None = Object.freeze({\n        isCancellationRequested: false,\n        onCancellationRequested: Event.None\n    });\n    CancellationToken.Cancelled = Object.freeze({\n        isCancellationRequested: true,\n        onCancellationRequested: shortcutEvent\n    });\n})(CancellationToken || (CancellationToken = {}));\nclass MutableToken {\n    constructor() {\n        this._isCancelled = false;\n        this._emitter = null;\n    }\n    cancel() {\n        if (!this._isCancelled) {\n            this._isCancelled = true;\n            if (this._emitter) {\n                this._emitter.fire(undefined);\n                this.dispose();\n            }\n        }\n    }\n    get isCancellationRequested() {\n        return this._isCancelled;\n    }\n    get onCancellationRequested() {\n        if (this._isCancelled) {\n            return shortcutEvent;\n        }\n        if (!this._emitter) {\n            this._emitter = new Emitter();\n        }\n        return this._emitter.event;\n    }\n    dispose() {\n        if (this._emitter) {\n            this._emitter.dispose();\n            this._emitter = null;\n        }\n    }\n}\nclass CancellationTokenSource {\n    constructor(parent) {\n        this._token = undefined;\n        this._parentListener = undefined;\n        this._parentListener = parent && parent.onCancellationRequested(this.cancel, this);\n    }\n    get token() {\n        if (!this._token) {\n            // be lazy and create the token only when\n            // actually needed\n            this._token = new MutableToken();\n        }\n        return this._token;\n    }\n    cancel() {\n        if (!this._token) {\n            // save an object by returning the default\n            // cancelled token when cancellation happens\n            // before someone asks for the token\n            this._token = CancellationToken.Cancelled;\n        }\n        else if (this._token instanceof MutableToken) {\n            // actually cancel\n            this._token.cancel();\n        }\n    }\n    dispose(cancel = false) {\n        if (cancel) {\n            this.cancel();\n        }\n        if (this._parentListener) {\n            this._parentListener.dispose();\n        }\n        if (!this._token) {\n            // ensure to initialize with an empty token if we had none\n            this._token = CancellationToken.None;\n        }\n        else if (this._token instanceof MutableToken) {\n            // actually dispose\n            this._token.dispose();\n        }\n    }\n}\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nfunction isThenable(obj) {\n    return obj && typeof obj.then === 'function';\n}\nfunction createCancelablePromise(callback) {\n    const source = new CancellationTokenSource();\n    const thenable = callback(source.token);\n    const promise = new Promise((resolve, reject) => {\n        source.token.onCancellationRequested(() => {\n            reject(canceled());\n        });\n        Promise.resolve(thenable).then(value => {\n            source.dispose();\n            resolve(value);\n        }, err => {\n            source.dispose();\n            reject(err);\n        });\n    });\n    return new class {\n        cancel() {\n            source.cancel();\n        }\n        then(resolve, reject) {\n            return promise.then(resolve, reject);\n        }\n        catch(reject) {\n            return this.then(undefined, reject);\n        }\n        finally(onfinally) {\n            return promise.finally(onfinally);\n        }\n    };\n}\nfunction raceCancellation(promise, token, defaultValue) {\n    return Promise.race([promise, new Promise(resolve => token.onCancellationRequested(() => resolve(defaultValue)))]);\n}\nfunction asPromise(callback) {\n    return new Promise((resolve, reject) => {\n        const item = callback();\n        if (isThenable(item)) {\n            item.then(resolve, reject);\n        }\n        else {\n            resolve(item);\n        }\n    });\n}\n/**\n * A helper to prevent accumulation of sequential async tasks.\n *\n * Imagine a mail man with the sole task of delivering letters. As soon as\n * a letter submitted for delivery, he drives to the destination, delivers it\n * and returns to his base. Imagine that during the trip, N more letters were submitted.\n * When the mail man returns, he picks those N letters and delivers them all in a\n * single trip. Even though N+1 submissions occurred, only 2 deliveries were made.\n *\n * The throttler implements this via the queue() method, by providing it a task\n * factory. Following the example:\n *\n * \t\tconst throttler = new Throttler();\n * \t\tconst letters = [];\n *\n * \t\tfunction deliver() {\n * \t\t\tconst lettersToDeliver = letters;\n * \t\t\tletters = [];\n * \t\t\treturn makeTheTrip(lettersToDeliver);\n * \t\t}\n *\n * \t\tfunction onLetterReceived(l) {\n * \t\t\tletters.push(l);\n * \t\t\tthrottler.queue(deliver);\n * \t\t}\n */\nclass Throttler {\n    constructor() {\n        this.activePromise = null;\n        this.queuedPromise = null;\n        this.queuedPromiseFactory = null;\n    }\n    queue(promiseFactory) {\n        if (this.activePromise) {\n            this.queuedPromiseFactory = promiseFactory;\n            if (!this.queuedPromise) {\n                const onComplete = () => {\n                    this.queuedPromise = null;\n                    const result = this.queue(this.queuedPromiseFactory);\n                    this.queuedPromiseFactory = null;\n                    return result;\n                };\n                this.queuedPromise = new Promise(c => {\n                    this.activePromise.then(onComplete, onComplete).then(c);\n                });\n            }\n            return new Promise((c, e) => {\n                this.queuedPromise.then(c, e);\n            });\n        }\n        this.activePromise = promiseFactory();\n        return new Promise((c, e) => {\n            this.activePromise.then((result) => {\n                this.activePromise = null;\n                c(result);\n            }, (err) => {\n                this.activePromise = null;\n                e(err);\n            });\n        });\n    }\n}\nclass Sequencer {\n    constructor() {\n        this.current = Promise.resolve(null);\n    }\n    queue(promiseTask) {\n        return this.current = this.current.then(() => promiseTask());\n    }\n}\n/**\n * A helper to delay execution of a task that is being requested often.\n *\n * Following the throttler, now imagine the mail man wants to optimize the number of\n * trips proactively. The trip itself can be long, so he decides not to make the trip\n * as soon as a letter is submitted. Instead he waits a while, in case more\n * letters are submitted. After said waiting period, if no letters were submitted, he\n * decides to make the trip. Imagine that N more letters were submitted after the first\n * one, all within a short period of time between each other. Even though N+1\n * submissions occurred, only 1 delivery was made.\n *\n * The delayer offers this behavior via the trigger() method, into which both the task\n * to be executed and the waiting period (delay) must be passed in as arguments. Following\n * the example:\n *\n * \t\tconst delayer = new Delayer(WAITING_PERIOD);\n * \t\tconst letters = [];\n *\n * \t\tfunction letterReceived(l) {\n * \t\t\tletters.push(l);\n * \t\t\tdelayer.trigger(() => { return makeTheTrip(); });\n * \t\t}\n */\nclass Delayer {\n    constructor(defaultDelay) {\n        this.defaultDelay = defaultDelay;\n        this.timeout = null;\n        this.completionPromise = null;\n        this.doResolve = null;\n        this.doReject = null;\n        this.task = null;\n    }\n    trigger(task, delay = this.defaultDelay) {\n        this.task = task;\n        this.cancelTimeout();\n        if (!this.completionPromise) {\n            this.completionPromise = new Promise((c, e) => {\n                this.doResolve = c;\n                this.doReject = e;\n            }).then(() => {\n                this.completionPromise = null;\n                this.doResolve = null;\n                if (this.task) {\n                    const task = this.task;\n                    this.task = null;\n                    return task();\n                }\n                return undefined;\n            });\n        }\n        this.timeout = setTimeout(() => {\n            this.timeout = null;\n            if (this.doResolve) {\n                this.doResolve(null);\n            }\n        }, delay);\n        return this.completionPromise;\n    }\n    isTriggered() {\n        return this.timeout !== null;\n    }\n    cancel() {\n        this.cancelTimeout();\n        if (this.completionPromise) {\n            if (this.doReject) {\n                this.doReject(canceled());\n            }\n            this.completionPromise = null;\n        }\n    }\n    cancelTimeout() {\n        if (this.timeout !== null) {\n            clearTimeout(this.timeout);\n            this.timeout = null;\n        }\n    }\n    dispose() {\n        this.cancelTimeout();\n    }\n}\n/**\n * A helper to delay execution of a task that is being requested often, while\n * preventing accumulation of consecutive executions, while the task runs.\n *\n * The mail man is clever and waits for a certain amount of time, before going\n * out to deliver letters. While the mail man is going out, more letters arrive\n * and can only be delivered once he is back. Once he is back the mail man will\n * do one more trip to deliver the letters that have accumulated while he was out.\n */\nclass ThrottledDelayer {\n    constructor(defaultDelay) {\n        this.delayer = new Delayer(defaultDelay);\n        this.throttler = new Throttler();\n    }\n    trigger(promiseFactory, delay) {\n        return this.delayer.trigger(() => this.throttler.queue(promiseFactory), delay);\n    }\n    isTriggered() {\n        return this.delayer.isTriggered();\n    }\n    cancel() {\n        this.delayer.cancel();\n    }\n    dispose() {\n        this.delayer.dispose();\n    }\n}\n/**\n * A barrier that is initially closed and then becomes opened permanently.\n */\nclass Barrier {\n    constructor() {\n        this._isOpen = false;\n        this._promise = new Promise((c, e) => {\n            this._completePromise = c;\n        });\n    }\n    isOpen() {\n        return this._isOpen;\n    }\n    open() {\n        this._isOpen = true;\n        this._completePromise(true);\n    }\n    wait() {\n        return this._promise;\n    }\n}\nfunction timeout(millis, token) {\n    if (!token) {\n        return createCancelablePromise(token => timeout(millis, token));\n    }\n    return new Promise((resolve, reject) => {\n        const handle = setTimeout(resolve, millis);\n        token.onCancellationRequested(() => {\n            clearTimeout(handle);\n            reject(canceled());\n        });\n    });\n}\nfunction disposableTimeout(handler, timeout = 0) {\n    const timer = setTimeout(handler, timeout);\n    return toDisposable(() => clearTimeout(timer));\n}\nfunction ignoreErrors(promise) {\n    return promise.then(undefined, _ => undefined);\n}\n/**\n * Runs the provided list of promise factories in sequential order. The returned\n * promise will complete to an array of results from each promise.\n */\nfunction sequence(promiseFactories) {\n    const results = [];\n    let index = 0;\n    const len = promiseFactories.length;\n    function next() {\n        return index < len ? promiseFactories[index++]() : null;\n    }\n    function thenHandler(result) {\n        if (result !== undefined && result !== null) {\n            results.push(result);\n        }\n        const n = next();\n        if (n) {\n            return n.then(thenHandler);\n        }\n        return Promise.resolve(results);\n    }\n    return Promise.resolve(null).then(thenHandler);\n}\nfunction first(promiseFactories, shouldStop = t => !!t, defaultValue = null) {\n    let index = 0;\n    const len = promiseFactories.length;\n    const loop = () => {\n        if (index >= len) {\n            return Promise.resolve(defaultValue);\n        }\n        const factory = promiseFactories[index++];\n        const promise = Promise.resolve(factory());\n        return promise.then(result => {\n            if (shouldStop(result)) {\n                return Promise.resolve(result);\n            }\n            return loop();\n        });\n    };\n    return loop();\n}\n/**\n * A helper to queue N promises and run them all with a max degree of parallelism. The helper\n * ensures that at any time no more than M promises are running at the same time.\n */\nclass Limiter {\n    constructor(maxDegreeOfParalellism) {\n        this._size = 0;\n        this.maxDegreeOfParalellism = maxDegreeOfParalellism;\n        this.outstandingPromises = [];\n        this.runningPromises = 0;\n        this._onFinished = new Emitter();\n    }\n    get onFinished() {\n        return this._onFinished.event;\n    }\n    get size() {\n        return this._size;\n        // return this.runningPromises + this.outstandingPromises.length;\n    }\n    queue(factory) {\n        this._size++;\n        return new Promise((c, e) => {\n            this.outstandingPromises.push({ factory, c, e });\n            this.consume();\n        });\n    }\n    consume() {\n        while (this.outstandingPromises.length && this.runningPromises < this.maxDegreeOfParalellism) {\n            const iLimitedTask = this.outstandingPromises.shift();\n            this.runningPromises++;\n            const promise = iLimitedTask.factory();\n            promise.then(iLimitedTask.c, iLimitedTask.e);\n            promise.then(() => this.consumed(), () => this.consumed());\n        }\n    }\n    consumed() {\n        this._size--;\n        this.runningPromises--;\n        if (this.outstandingPromises.length > 0) {\n            this.consume();\n        }\n        else {\n            this._onFinished.fire();\n        }\n    }\n    dispose() {\n        this._onFinished.dispose();\n    }\n}\n/**\n * A queue is handles one promise at a time and guarantees that at any time only one promise is executing.\n */\nclass Queue extends Limiter {\n    constructor() {\n        super(1);\n    }\n}\n(function () {\n    if (typeof requestIdleCallback !== 'function' || typeof cancelIdleCallback !== 'function') {\n        const dummyIdle = Object.freeze({\n            didTimeout: true,\n            timeRemaining() { return 15; }\n        });\n    }\n})();\n//#endregion\nasync function retry(task, delay, retries) {\n    let lastError;\n    for (let i = 0; i < retries; i++) {\n        try {\n            return await task();\n        }\n        catch (error) {\n            lastError = error;\n            await timeout(delay);\n        }\n    }\n    throw lastError;\n}\n//#endregion\n\nconst _globals = (typeof self === 'object' ? self : typeof global === 'object' ? global : {});\nconst globals = _globals;\nconst setImmediate = (function defineSetImmediate() {\n    if (globals.setImmediate) {\n        return globals.setImmediate.bind(globals);\n    }\n    if (typeof globals.postMessage === 'function' && !globals.importScripts) {\n        let pending = [];\n        globals.addEventListener('message', (e) => {\n            if (e.data && e.data.vscodeSetImmediateId) {\n                for (let i = 0, len = pending.length; i < len; i++) {\n                    const candidate = pending[i];\n                    if (candidate.id === e.data.vscodeSetImmediateId) {\n                        pending.splice(i, 1);\n                        candidate.callback();\n                        return;\n                    }\n                }\n            }\n        });\n        let lastId = 0;\n        return (callback) => {\n            const myId = ++lastId;\n            pending.push({\n                id: myId,\n                callback: callback\n            });\n            globals.postMessage({ vscodeSetImmediateId: myId }, '*');\n        };\n    }\n    if (typeof process !== 'undefined' && typeof process.nextTick === 'function') {\n        return process.nextTick.bind(process);\n    }\n    const _promise = Promise.resolve();\n    return (callback) => _promise.then(callback);\n})();\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nconst safeProcess = (typeof process === 'undefined') ? {\n    cwd() { return '/'; },\n    env: Object.create(null),\n    get platform() { return   'linux'; },\n    nextTick(callback) { return setImmediate(callback); }\n} : process;\nconst cwd = safeProcess.cwd;\nconst env = safeProcess.env;\nconst platform = safeProcess.platform;\nconst nextTick = safeProcess.nextTick;\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nconst CHAR_UPPERCASE_A = 65; /* A */\nconst CHAR_LOWERCASE_A = 97; /* a */\nconst CHAR_UPPERCASE_Z = 90; /* Z */\nconst CHAR_LOWERCASE_Z = 122; /* z */\nconst CHAR_DOT = 46; /* . */\nconst CHAR_FORWARD_SLASH = 47; /* / */\nconst CHAR_BACKWARD_SLASH = 92; /* \\ */\nconst CHAR_COLON = 58; /* : */\nconst CHAR_QUESTION_MARK = 63; /* ? */\nclass ErrorInvalidArgType extends Error {\n    constructor(name, expected, actual) {\n        // determiner: 'must be' or 'must not be'\n        let determiner;\n        if (typeof expected === 'string' && expected.indexOf('not ') === 0) {\n            determiner = 'must not be';\n            expected = expected.replace(/^not /, '');\n        }\n        else {\n            determiner = 'must be';\n        }\n        const type = name.indexOf('.') !== -1 ? 'property' : 'argument';\n        let msg = `The \"${name}\" ${type} ${determiner} of type ${expected}`;\n        msg += `. Received type ${typeof actual}`;\n        super(msg);\n        this.code = 'ERR_INVALID_ARG_TYPE';\n    }\n}\nfunction validateString(value, name) {\n    if (typeof value !== 'string') {\n        throw new ErrorInvalidArgType(name, 'string', value);\n    }\n}\nfunction isPathSeparator(code) {\n    return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;\n}\nfunction isPosixPathSeparator(code) {\n    return code === CHAR_FORWARD_SLASH;\n}\nfunction isWindowsDeviceRoot(code) {\n    return code >= CHAR_UPPERCASE_A && code <= CHAR_UPPERCASE_Z ||\n        code >= CHAR_LOWERCASE_A && code <= CHAR_LOWERCASE_Z;\n}\n// Resolves . and .. elements in a path with directory names\nfunction normalizeString(path, allowAboveRoot, separator, isPathSeparator) {\n    let res = '';\n    let lastSegmentLength = 0;\n    let lastSlash = -1;\n    let dots = 0;\n    let code = 0;\n    for (let i = 0; i <= path.length; ++i) {\n        if (i < path.length) {\n            code = path.charCodeAt(i);\n        }\n        else if (isPathSeparator(code)) {\n            break;\n        }\n        else {\n            code = CHAR_FORWARD_SLASH;\n        }\n        if (isPathSeparator(code)) {\n            if (lastSlash === i - 1 || dots === 1) ;\n            else if (dots === 2) {\n                if (res.length < 2 || lastSegmentLength !== 2 ||\n                    res.charCodeAt(res.length - 1) !== CHAR_DOT ||\n                    res.charCodeAt(res.length - 2) !== CHAR_DOT) {\n                    if (res.length > 2) {\n                        const lastSlashIndex = res.lastIndexOf(separator);\n                        if (lastSlashIndex === -1) {\n                            res = '';\n                            lastSegmentLength = 0;\n                        }\n                        else {\n                            res = res.slice(0, lastSlashIndex);\n                            lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);\n                        }\n                        lastSlash = i;\n                        dots = 0;\n                        continue;\n                    }\n                    else if (res.length !== 0) {\n                        res = '';\n                        lastSegmentLength = 0;\n                        lastSlash = i;\n                        dots = 0;\n                        continue;\n                    }\n                }\n                if (allowAboveRoot) {\n                    res += res.length > 0 ? `${separator}..` : '..';\n                    lastSegmentLength = 2;\n                }\n            }\n            else {\n                if (res.length > 0) {\n                    res += `${separator}${path.slice(lastSlash + 1, i)}`;\n                }\n                else {\n                    res = path.slice(lastSlash + 1, i);\n                }\n                lastSegmentLength = i - lastSlash - 1;\n            }\n            lastSlash = i;\n            dots = 0;\n        }\n        else if (code === CHAR_DOT && dots !== -1) {\n            ++dots;\n        }\n        else {\n            dots = -1;\n        }\n    }\n    return res;\n}\nfunction _format(sep, pathObject) {\n    if (pathObject === null || typeof pathObject !== 'object') {\n        throw new ErrorInvalidArgType('pathObject', 'Object', pathObject);\n    }\n    const dir = pathObject.dir || pathObject.root;\n    const base = pathObject.base ||\n        `${pathObject.name || ''}${pathObject.ext || ''}`;\n    if (!dir) {\n        return base;\n    }\n    return dir === pathObject.root ? `${dir}${base}` : `${dir}${sep}${base}`;\n}\nconst win32 = {\n    // path.resolve([from ...], to)\n    resolve(...pathSegments) {\n        let resolvedDevice = '';\n        let resolvedTail = '';\n        let resolvedAbsolute = false;\n        for (let i = pathSegments.length - 1; i >= -1; i--) {\n            let path;\n            if (i >= 0) {\n                path = pathSegments[i];\n                validateString(path, 'path');\n                // Skip empty entries\n                if (path.length === 0) {\n                    continue;\n                }\n            }\n            else if (resolvedDevice.length === 0) {\n                path = cwd();\n            }\n            else {\n                // Windows has the concept of drive-specific current working\n                // directories. If we've resolved a drive letter but not yet an\n                // absolute path, get cwd for that drive, or the process cwd if\n                // the drive cwd is not available. We're sure the device is not\n                // a UNC path at this points, because UNC paths are always absolute.\n                path = env[`=${resolvedDevice}`] || cwd();\n                // Verify that a cwd was found and that it actually points\n                // to our drive. If not, default to the drive's root.\n                if (path === undefined ||\n                    path.slice(0, 2).toLowerCase() !== resolvedDevice.toLowerCase() &&\n                        path.charCodeAt(2) === CHAR_BACKWARD_SLASH) {\n                    path = `${resolvedDevice}\\\\`;\n                }\n            }\n            const len = path.length;\n            let rootEnd = 0;\n            let device = '';\n            let isAbsolute = false;\n            const code = path.charCodeAt(0);\n            // Try to match a root\n            if (len === 1) {\n                if (isPathSeparator(code)) {\n                    // `path` contains just a path separator\n                    rootEnd = 1;\n                    isAbsolute = true;\n                }\n            }\n            else if (isPathSeparator(code)) {\n                // Possible UNC root\n                // If we started with a separator, we know we at least have an\n                // absolute path of some kind (UNC or otherwise)\n                isAbsolute = true;\n                if (isPathSeparator(path.charCodeAt(1))) {\n                    // Matched double path separator at beginning\n                    let j = 2;\n                    let last = j;\n                    // Match 1 or more non-path separators\n                    while (j < len && !isPathSeparator(path.charCodeAt(j))) {\n                        j++;\n                    }\n                    if (j < len && j !== last) {\n                        const firstPart = path.slice(last, j);\n                        // Matched!\n                        last = j;\n                        // Match 1 or more path separators\n                        while (j < len && isPathSeparator(path.charCodeAt(j))) {\n                            j++;\n                        }\n                        if (j < len && j !== last) {\n                            // Matched!\n                            last = j;\n                            // Match 1 or more non-path separators\n                            while (j < len && !isPathSeparator(path.charCodeAt(j))) {\n                                j++;\n                            }\n                            if (j === len || j !== last) {\n                                // We matched a UNC root\n                                device = `\\\\\\\\${firstPart}\\\\${path.slice(last, j)}`;\n                                rootEnd = j;\n                            }\n                        }\n                    }\n                }\n                else {\n                    rootEnd = 1;\n                }\n            }\n            else if (isWindowsDeviceRoot(code) &&\n                path.charCodeAt(1) === CHAR_COLON) {\n                // Possible device root\n                device = path.slice(0, 2);\n                rootEnd = 2;\n                if (len > 2 && isPathSeparator(path.charCodeAt(2))) {\n                    // Treat separator following drive name as an absolute path\n                    // indicator\n                    isAbsolute = true;\n                    rootEnd = 3;\n                }\n            }\n            if (device.length > 0) {\n                if (resolvedDevice.length > 0) {\n                    if (device.toLowerCase() !== resolvedDevice.toLowerCase()) {\n                        // This path points to another device so it is not applicable\n                        continue;\n                    }\n                }\n                else {\n                    resolvedDevice = device;\n                }\n            }\n            if (resolvedAbsolute) {\n                if (resolvedDevice.length > 0) {\n                    break;\n                }\n            }\n            else {\n                resolvedTail = `${path.slice(rootEnd)}\\\\${resolvedTail}`;\n                resolvedAbsolute = isAbsolute;\n                if (isAbsolute && resolvedDevice.length > 0) {\n                    break;\n                }\n            }\n        }\n        // At this point the path should be resolved to a full absolute path,\n        // but handle relative paths to be safe (might happen when process.cwd()\n        // fails)\n        // Normalize the tail path\n        resolvedTail = normalizeString(resolvedTail, !resolvedAbsolute, '\\\\', isPathSeparator);\n        return resolvedAbsolute ?\n            `${resolvedDevice}\\\\${resolvedTail}` :\n            `${resolvedDevice}${resolvedTail}` || '.';\n    },\n    normalize(path) {\n        validateString(path, 'path');\n        const len = path.length;\n        if (len === 0) {\n            return '.';\n        }\n        let rootEnd = 0;\n        let device;\n        let isAbsolute = false;\n        const code = path.charCodeAt(0);\n        // Try to match a root\n        if (len === 1) {\n            // `path` contains just a single char, exit early to avoid\n            // unnecessary work\n            return isPosixPathSeparator(code) ? '\\\\' : path;\n        }\n        if (isPathSeparator(code)) {\n            // Possible UNC root\n            // If we started with a separator, we know we at least have an absolute\n            // path of some kind (UNC or otherwise)\n            isAbsolute = true;\n            if (isPathSeparator(path.charCodeAt(1))) {\n                // Matched double path separator at beginning\n                let j = 2;\n                let last = j;\n                // Match 1 or more non-path separators\n                while (j < len && !isPathSeparator(path.charCodeAt(j))) {\n                    j++;\n                }\n                if (j < len && j !== last) {\n                    const firstPart = path.slice(last, j);\n                    // Matched!\n                    last = j;\n                    // Match 1 or more path separators\n                    while (j < len && isPathSeparator(path.charCodeAt(j))) {\n                        j++;\n                    }\n                    if (j < len && j !== last) {\n                        // Matched!\n                        last = j;\n                        // Match 1 or more non-path separators\n                        while (j < len && !isPathSeparator(path.charCodeAt(j))) {\n                            j++;\n                        }\n                        if (j === len) {\n                            // We matched a UNC root only\n                            // Return the normalized version of the UNC root since there\n                            // is nothing left to process\n                            return `\\\\\\\\${firstPart}\\\\${path.slice(last)}\\\\`;\n                        }\n                        if (j !== last) {\n                            // We matched a UNC root with leftovers\n                            device = `\\\\\\\\${firstPart}\\\\${path.slice(last, j)}`;\n                            rootEnd = j;\n                        }\n                    }\n                }\n            }\n            else {\n                rootEnd = 1;\n            }\n        }\n        else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {\n            // Possible device root\n            device = path.slice(0, 2);\n            rootEnd = 2;\n            if (len > 2 && isPathSeparator(path.charCodeAt(2))) {\n                // Treat separator following drive name as an absolute path\n                // indicator\n                isAbsolute = true;\n                rootEnd = 3;\n            }\n        }\n        let tail = rootEnd < len ?\n            normalizeString(path.slice(rootEnd), !isAbsolute, '\\\\', isPathSeparator) :\n            '';\n        if (tail.length === 0 && !isAbsolute) {\n            tail = '.';\n        }\n        if (tail.length > 0 && isPathSeparator(path.charCodeAt(len - 1))) {\n            tail += '\\\\';\n        }\n        if (device === undefined) {\n            return isAbsolute ? `\\\\${tail}` : tail;\n        }\n        return isAbsolute ? `${device}\\\\${tail}` : `${device}${tail}`;\n    },\n    isAbsolute(path) {\n        validateString(path, 'path');\n        const len = path.length;\n        if (len === 0) {\n            return false;\n        }\n        const code = path.charCodeAt(0);\n        return isPathSeparator(code) ||\n            // Possible device root\n            len > 2 &&\n                isWindowsDeviceRoot(code) &&\n                path.charCodeAt(1) === CHAR_COLON &&\n                isPathSeparator(path.charCodeAt(2));\n    },\n    join(...paths) {\n        if (paths.length === 0) {\n            return '.';\n        }\n        let joined;\n        let firstPart;\n        for (let i = 0; i < paths.length; ++i) {\n            const arg = paths[i];\n            validateString(arg, 'path');\n            if (arg.length > 0) {\n                if (joined === undefined) {\n                    joined = firstPart = arg;\n                }\n                else {\n                    joined += `\\\\${arg}`;\n                }\n            }\n        }\n        if (joined === undefined) {\n            return '.';\n        }\n        // Make sure that the joined path doesn't start with two slashes, because\n        // normalize() will mistake it for an UNC path then.\n        //\n        // This step is skipped when it is very clear that the user actually\n        // intended to point at an UNC path. This is assumed when the first\n        // non-empty string arguments starts with exactly two slashes followed by\n        // at least one more non-slash character.\n        //\n        // Note that for normalize() to treat a path as an UNC path it needs to\n        // have at least 2 components, so we don't filter for that here.\n        // This means that the user can use join to construct UNC paths from\n        // a server name and a share name; for example:\n        //   path.join('//server', 'share') -> '\\\\\\\\server\\\\share\\\\')\n        let needsReplace = true;\n        let slashCount = 0;\n        if (typeof firstPart === 'string' && isPathSeparator(firstPart.charCodeAt(0))) {\n            ++slashCount;\n            const firstLen = firstPart.length;\n            if (firstLen > 1 && isPathSeparator(firstPart.charCodeAt(1))) {\n                ++slashCount;\n                if (firstLen > 2) {\n                    if (isPathSeparator(firstPart.charCodeAt(2))) {\n                        ++slashCount;\n                    }\n                    else {\n                        // We matched a UNC path in the first part\n                        needsReplace = false;\n                    }\n                }\n            }\n        }\n        if (needsReplace) {\n            // Find any more consecutive slashes we need to replace\n            while (slashCount < joined.length &&\n                isPathSeparator(joined.charCodeAt(slashCount))) {\n                slashCount++;\n            }\n            // Replace the slashes if needed\n            if (slashCount >= 2) {\n                joined = `\\\\${joined.slice(slashCount)}`;\n            }\n        }\n        return win32.normalize(joined);\n    },\n    // It will solve the relative path from `from` to `to`, for instance:\n    //  from = 'C:\\\\orandea\\\\test\\\\aaa'\n    //  to = 'C:\\\\orandea\\\\impl\\\\bbb'\n    // The output of the function should be: '..\\\\..\\\\impl\\\\bbb'\n    relative(from, to) {\n        validateString(from, 'from');\n        validateString(to, 'to');\n        if (from === to) {\n            return '';\n        }\n        const fromOrig = win32.resolve(from);\n        const toOrig = win32.resolve(to);\n        if (fromOrig === toOrig) {\n            return '';\n        }\n        from = fromOrig.toLowerCase();\n        to = toOrig.toLowerCase();\n        if (from === to) {\n            return '';\n        }\n        // Trim any leading backslashes\n        let fromStart = 0;\n        while (fromStart < from.length &&\n            from.charCodeAt(fromStart) === CHAR_BACKWARD_SLASH) {\n            fromStart++;\n        }\n        // Trim trailing backslashes (applicable to UNC paths only)\n        let fromEnd = from.length;\n        while (fromEnd - 1 > fromStart &&\n            from.charCodeAt(fromEnd - 1) === CHAR_BACKWARD_SLASH) {\n            fromEnd--;\n        }\n        const fromLen = fromEnd - fromStart;\n        // Trim any leading backslashes\n        let toStart = 0;\n        while (toStart < to.length &&\n            to.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {\n            toStart++;\n        }\n        // Trim trailing backslashes (applicable to UNC paths only)\n        let toEnd = to.length;\n        while (toEnd - 1 > toStart &&\n            to.charCodeAt(toEnd - 1) === CHAR_BACKWARD_SLASH) {\n            toEnd--;\n        }\n        const toLen = toEnd - toStart;\n        // Compare paths to find the longest common path from root\n        const length = fromLen < toLen ? fromLen : toLen;\n        let lastCommonSep = -1;\n        let i = 0;\n        for (; i < length; i++) {\n            const fromCode = from.charCodeAt(fromStart + i);\n            if (fromCode !== to.charCodeAt(toStart + i)) {\n                break;\n            }\n            else if (fromCode === CHAR_BACKWARD_SLASH) {\n                lastCommonSep = i;\n            }\n        }\n        // We found a mismatch before the first common path separator was seen, so\n        // return the original `to`.\n        if (i !== length) {\n            if (lastCommonSep === -1) {\n                return toOrig;\n            }\n        }\n        else {\n            if (toLen > length) {\n                if (to.charCodeAt(toStart + i) === CHAR_BACKWARD_SLASH) {\n                    // We get here if `from` is the exact base path for `to`.\n                    // For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo\\\\bar\\\\baz'\n                    return toOrig.slice(toStart + i + 1);\n                }\n                if (i === 2) {\n                    // We get here if `from` is the device root.\n                    // For example: from='C:\\\\'; to='C:\\\\foo'\n                    return toOrig.slice(toStart + i);\n                }\n            }\n            if (fromLen > length) {\n                if (from.charCodeAt(fromStart + i) === CHAR_BACKWARD_SLASH) {\n                    // We get here if `to` is the exact base path for `from`.\n                    // For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo'\n                    lastCommonSep = i;\n                }\n                else if (i === 2) {\n                    // We get here if `to` is the device root.\n                    // For example: from='C:\\\\foo\\\\bar'; to='C:\\\\'\n                    lastCommonSep = 3;\n                }\n            }\n            if (lastCommonSep === -1) {\n                lastCommonSep = 0;\n            }\n        }\n        let out = '';\n        // Generate the relative path based on the path difference between `to` and\n        // `from`\n        for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n            if (i === fromEnd || from.charCodeAt(i) === CHAR_BACKWARD_SLASH) {\n                out += out.length === 0 ? '..' : '\\\\..';\n            }\n        }\n        toStart += lastCommonSep;\n        // Lastly, append the rest of the destination (`to`) path that comes after\n        // the common path parts\n        if (out.length > 0) {\n            return `${out}${toOrig.slice(toStart, toEnd)}`;\n        }\n        if (toOrig.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {\n            ++toStart;\n        }\n        return toOrig.slice(toStart, toEnd);\n    },\n    toNamespacedPath(path) {\n        // Note: this will *probably* throw somewhere.\n        if (typeof path !== 'string') {\n            return path;\n        }\n        if (path.length === 0) {\n            return '';\n        }\n        const resolvedPath = win32.resolve(path);\n        if (resolvedPath.length <= 2) {\n            return path;\n        }\n        if (resolvedPath.charCodeAt(0) === CHAR_BACKWARD_SLASH) {\n            // Possible UNC root\n            if (resolvedPath.charCodeAt(1) === CHAR_BACKWARD_SLASH) {\n                const code = resolvedPath.charCodeAt(2);\n                if (code !== CHAR_QUESTION_MARK && code !== CHAR_DOT) {\n                    // Matched non-long UNC root, convert the path to a long UNC path\n                    return `\\\\\\\\?\\\\UNC\\\\${resolvedPath.slice(2)}`;\n                }\n            }\n        }\n        else if (isWindowsDeviceRoot(resolvedPath.charCodeAt(0)) &&\n            resolvedPath.charCodeAt(1) === CHAR_COLON &&\n            resolvedPath.charCodeAt(2) === CHAR_BACKWARD_SLASH) {\n            // Matched device root, convert the path to a long UNC path\n            return `\\\\\\\\?\\\\${resolvedPath}`;\n        }\n        return path;\n    },\n    dirname(path) {\n        validateString(path, 'path');\n        const len = path.length;\n        if (len === 0) {\n            return '.';\n        }\n        let rootEnd = -1;\n        let offset = 0;\n        const code = path.charCodeAt(0);\n        if (len === 1) {\n            // `path` contains just a path separator, exit early to avoid\n            // unnecessary work or a dot.\n            return isPathSeparator(code) ? path : '.';\n        }\n        // Try to match a root\n        if (isPathSeparator(code)) {\n            // Possible UNC root\n            rootEnd = offset = 1;\n            if (isPathSeparator(path.charCodeAt(1))) {\n                // Matched double path separator at beginning\n                let j = 2;\n                let last = j;\n                // Match 1 or more non-path separators\n                while (j < len && !isPathSeparator(path.charCodeAt(j))) {\n                    j++;\n                }\n                if (j < len && j !== last) {\n                    // Matched!\n                    last = j;\n                    // Match 1 or more path separators\n                    while (j < len && isPathSeparator(path.charCodeAt(j))) {\n                        j++;\n                    }\n                    if (j < len && j !== last) {\n                        // Matched!\n                        last = j;\n                        // Match 1 or more non-path separators\n                        while (j < len && !isPathSeparator(path.charCodeAt(j))) {\n                            j++;\n                        }\n                        if (j === len) {\n                            // We matched a UNC root only\n                            return path;\n                        }\n                        if (j !== last) {\n                            // We matched a UNC root with leftovers\n                            // Offset by 1 to include the separator after the UNC root to\n                            // treat it as a \"normal root\" on top of a (UNC) root\n                            rootEnd = offset = j + 1;\n                        }\n                    }\n                }\n            }\n            // Possible device root\n        }\n        else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {\n            rootEnd = len > 2 && isPathSeparator(path.charCodeAt(2)) ? 3 : 2;\n            offset = rootEnd;\n        }\n        let end = -1;\n        let matchedSlash = true;\n        for (let i = len - 1; i >= offset; --i) {\n            if (isPathSeparator(path.charCodeAt(i))) {\n                if (!matchedSlash) {\n                    end = i;\n                    break;\n                }\n            }\n            else {\n                // We saw the first non-path separator\n                matchedSlash = false;\n            }\n        }\n        if (end === -1) {\n            if (rootEnd === -1) {\n                return '.';\n            }\n            end = rootEnd;\n        }\n        return path.slice(0, end);\n    },\n    basename(path, ext) {\n        if (ext !== undefined) {\n            validateString(ext, 'ext');\n        }\n        validateString(path, 'path');\n        let start = 0;\n        let end = -1;\n        let matchedSlash = true;\n        let i;\n        // Check for a drive letter prefix so as not to mistake the following\n        // path separator as an extra separator at the end of the path that can be\n        // disregarded\n        if (path.length >= 2 &&\n            isWindowsDeviceRoot(path.charCodeAt(0)) &&\n            path.charCodeAt(1) === CHAR_COLON) {\n            start = 2;\n        }\n        if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n            if (ext === path) {\n                return '';\n            }\n            let extIdx = ext.length - 1;\n            let firstNonSlashEnd = -1;\n            for (i = path.length - 1; i >= start; --i) {\n                const code = path.charCodeAt(i);\n                if (isPathSeparator(code)) {\n                    // If we reached a path separator that was not part of a set of path\n                    // separators at the end of the string, stop now\n                    if (!matchedSlash) {\n                        start = i + 1;\n                        break;\n                    }\n                }\n                else {\n                    if (firstNonSlashEnd === -1) {\n                        // We saw the first non-path separator, remember this index in case\n                        // we need it if the extension ends up not matching\n                        matchedSlash = false;\n                        firstNonSlashEnd = i + 1;\n                    }\n                    if (extIdx >= 0) {\n                        // Try to match the explicit extension\n                        if (code === ext.charCodeAt(extIdx)) {\n                            if (--extIdx === -1) {\n                                // We matched the extension, so mark this as the end of our path\n                                // component\n                                end = i;\n                            }\n                        }\n                        else {\n                            // Extension does not match, so our result is the entire path\n                            // component\n                            extIdx = -1;\n                            end = firstNonSlashEnd;\n                        }\n                    }\n                }\n            }\n            if (start === end) {\n                end = firstNonSlashEnd;\n            }\n            else if (end === -1) {\n                end = path.length;\n            }\n            return path.slice(start, end);\n        }\n        for (i = path.length - 1; i >= start; --i) {\n            if (isPathSeparator(path.charCodeAt(i))) {\n                // If we reached a path separator that was not part of a set of path\n                // separators at the end of the string, stop now\n                if (!matchedSlash) {\n                    start = i + 1;\n                    break;\n                }\n            }\n            else if (end === -1) {\n                // We saw the first non-path separator, mark this as the end of our\n                // path component\n                matchedSlash = false;\n                end = i + 1;\n            }\n        }\n        if (end === -1) {\n            return '';\n        }\n        return path.slice(start, end);\n    },\n    extname(path) {\n        validateString(path, 'path');\n        let start = 0;\n        let startDot = -1;\n        let startPart = 0;\n        let end = -1;\n        let matchedSlash = true;\n        // Track the state of characters (if any) we see before our first dot and\n        // after any path separator we find\n        let preDotState = 0;\n        // Check for a drive letter prefix so as not to mistake the following\n        // path separator as an extra separator at the end of the path that can be\n        // disregarded\n        if (path.length >= 2 &&\n            path.charCodeAt(1) === CHAR_COLON &&\n            isWindowsDeviceRoot(path.charCodeAt(0))) {\n            start = startPart = 2;\n        }\n        for (let i = path.length - 1; i >= start; --i) {\n            const code = path.charCodeAt(i);\n            if (isPathSeparator(code)) {\n                // If we reached a path separator that was not part of a set of path\n                // separators at the end of the string, stop now\n                if (!matchedSlash) {\n                    startPart = i + 1;\n                    break;\n                }\n                continue;\n            }\n            if (end === -1) {\n                // We saw the first non-path separator, mark this as the end of our\n                // extension\n                matchedSlash = false;\n                end = i + 1;\n            }\n            if (code === CHAR_DOT) {\n                // If this is our first dot, mark it as the start of our extension\n                if (startDot === -1) {\n                    startDot = i;\n                }\n                else if (preDotState !== 1) {\n                    preDotState = 1;\n                }\n            }\n            else if (startDot !== -1) {\n                // We saw a non-dot and non-path separator before our dot, so we should\n                // have a good chance at having a non-empty extension\n                preDotState = -1;\n            }\n        }\n        if (startDot === -1 ||\n            end === -1 ||\n            // We saw a non-dot character immediately before the dot\n            preDotState === 0 ||\n            // The (right-most) trimmed path component is exactly '..'\n            (preDotState === 1 &&\n                startDot === end - 1 &&\n                startDot === startPart + 1)) {\n            return '';\n        }\n        return path.slice(startDot, end);\n    },\n    format: _format.bind(null, '\\\\'),\n    parse(path) {\n        validateString(path, 'path');\n        const ret = { root: '', dir: '', base: '', ext: '', name: '' };\n        if (path.length === 0) {\n            return ret;\n        }\n        const len = path.length;\n        let rootEnd = 0;\n        let code = path.charCodeAt(0);\n        if (len === 1) {\n            if (isPathSeparator(code)) {\n                // `path` contains just a path separator, exit early to avoid\n                // unnecessary work\n                ret.root = ret.dir = path;\n                return ret;\n            }\n            ret.base = ret.name = path;\n            return ret;\n        }\n        // Try to match a root\n        if (isPathSeparator(code)) {\n            // Possible UNC root\n            rootEnd = 1;\n            if (isPathSeparator(path.charCodeAt(1))) {\n                // Matched double path separator at beginning\n                let j = 2;\n                let last = j;\n                // Match 1 or more non-path separators\n                while (j < len && !isPathSeparator(path.charCodeAt(j))) {\n                    j++;\n                }\n                if (j < len && j !== last) {\n                    // Matched!\n                    last = j;\n                    // Match 1 or more path separators\n                    while (j < len && isPathSeparator(path.charCodeAt(j))) {\n                        j++;\n                    }\n                    if (j < len && j !== last) {\n                        // Matched!\n                        last = j;\n                        // Match 1 or more non-path separators\n                        while (j < len && !isPathSeparator(path.charCodeAt(j))) {\n                            j++;\n                        }\n                        if (j === len) {\n                            // We matched a UNC root only\n                            rootEnd = j;\n                        }\n                        else if (j !== last) {\n                            // We matched a UNC root with leftovers\n                            rootEnd = j + 1;\n                        }\n                    }\n                }\n            }\n        }\n        else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {\n            // Possible device root\n            if (len <= 2) {\n                // `path` contains just a drive root, exit early to avoid\n                // unnecessary work\n                ret.root = ret.dir = path;\n                return ret;\n            }\n            rootEnd = 2;\n            if (isPathSeparator(path.charCodeAt(2))) {\n                if (len === 3) {\n                    // `path` contains just a drive root, exit early to avoid\n                    // unnecessary work\n                    ret.root = ret.dir = path;\n                    return ret;\n                }\n                rootEnd = 3;\n            }\n        }\n        if (rootEnd > 0) {\n            ret.root = path.slice(0, rootEnd);\n        }\n        let startDot = -1;\n        let startPart = rootEnd;\n        let end = -1;\n        let matchedSlash = true;\n        let i = path.length - 1;\n        // Track the state of characters (if any) we see before our first dot and\n        // after any path separator we find\n        let preDotState = 0;\n        // Get non-dir info\n        for (; i >= rootEnd; --i) {\n            code = path.charCodeAt(i);\n            if (isPathSeparator(code)) {\n                // If we reached a path separator that was not part of a set of path\n                // separators at the end of the string, stop now\n                if (!matchedSlash) {\n                    startPart = i + 1;\n                    break;\n                }\n                continue;\n            }\n            if (end === -1) {\n                // We saw the first non-path separator, mark this as the end of our\n                // extension\n                matchedSlash = false;\n                end = i + 1;\n            }\n            if (code === CHAR_DOT) {\n                // If this is our first dot, mark it as the start of our extension\n                if (startDot === -1) {\n                    startDot = i;\n                }\n                else if (preDotState !== 1) {\n                    preDotState = 1;\n                }\n            }\n            else if (startDot !== -1) {\n                // We saw a non-dot and non-path separator before our dot, so we should\n                // have a good chance at having a non-empty extension\n                preDotState = -1;\n            }\n        }\n        if (end !== -1) {\n            if (startDot === -1 ||\n                // We saw a non-dot character immediately before the dot\n                preDotState === 0 ||\n                // The (right-most) trimmed path component is exactly '..'\n                (preDotState === 1 &&\n                    startDot === end - 1 &&\n                    startDot === startPart + 1)) {\n                ret.base = ret.name = path.slice(startPart, end);\n            }\n            else {\n                ret.name = path.slice(startPart, startDot);\n                ret.base = path.slice(startPart, end);\n                ret.ext = path.slice(startDot, end);\n            }\n        }\n        // If the directory is the root, use the entire root as the `dir` including\n        // the trailing slash if any (`C:\\abc` -> `C:\\`). Otherwise, strip out the\n        // trailing slash (`C:\\abc\\def` -> `C:\\abc`).\n        if (startPart > 0 && startPart !== rootEnd) {\n            ret.dir = path.slice(0, startPart - 1);\n        }\n        else {\n            ret.dir = ret.root;\n        }\n        return ret;\n    },\n    sep: '\\\\',\n    delimiter: ';',\n    win32: null,\n    posix: null\n};\nconst posix = {\n    // path.resolve([from ...], to)\n    resolve(...pathSegments) {\n        let resolvedPath = '';\n        let resolvedAbsolute = false;\n        for (let i = pathSegments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n            const path = i >= 0 ? pathSegments[i] : cwd();\n            validateString(path, 'path');\n            // Skip empty entries\n            if (path.length === 0) {\n                continue;\n            }\n            resolvedPath = `${path}/${resolvedPath}`;\n            resolvedAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n        }\n        // At this point the path should be resolved to a full absolute path, but\n        // handle relative paths to be safe (might happen when process.cwd() fails)\n        // Normalize the path\n        resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute, '/', isPosixPathSeparator);\n        if (resolvedAbsolute) {\n            return `/${resolvedPath}`;\n        }\n        return resolvedPath.length > 0 ? resolvedPath : '.';\n    },\n    normalize(path) {\n        validateString(path, 'path');\n        if (path.length === 0) {\n            return '.';\n        }\n        const isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n        const trailingSeparator = path.charCodeAt(path.length - 1) === CHAR_FORWARD_SLASH;\n        // Normalize the path\n        path = normalizeString(path, !isAbsolute, '/', isPosixPathSeparator);\n        if (path.length === 0) {\n            if (isAbsolute) {\n                return '/';\n            }\n            return trailingSeparator ? './' : '.';\n        }\n        if (trailingSeparator) {\n            path += '/';\n        }\n        return isAbsolute ? `/${path}` : path;\n    },\n    isAbsolute(path) {\n        validateString(path, 'path');\n        return path.length > 0 && path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n    },\n    join(...paths) {\n        if (paths.length === 0) {\n            return '.';\n        }\n        let joined;\n        for (let i = 0; i < paths.length; ++i) {\n            const arg = paths[i];\n            validateString(arg, 'path');\n            if (arg.length > 0) {\n                if (joined === undefined) {\n                    joined = arg;\n                }\n                else {\n                    joined += `/${arg}`;\n                }\n            }\n        }\n        if (joined === undefined) {\n            return '.';\n        }\n        return posix.normalize(joined);\n    },\n    relative(from, to) {\n        validateString(from, 'from');\n        validateString(to, 'to');\n        if (from === to) {\n            return '';\n        }\n        // Trim leading forward slashes.\n        from = posix.resolve(from);\n        to = posix.resolve(to);\n        if (from === to) {\n            return '';\n        }\n        const fromStart = 1;\n        const fromEnd = from.length;\n        const fromLen = fromEnd - fromStart;\n        const toStart = 1;\n        const toLen = to.length - toStart;\n        // Compare paths to find the longest common path from root\n        const length = (fromLen < toLen ? fromLen : toLen);\n        let lastCommonSep = -1;\n        let i = 0;\n        for (; i < length; i++) {\n            const fromCode = from.charCodeAt(fromStart + i);\n            if (fromCode !== to.charCodeAt(toStart + i)) {\n                break;\n            }\n            else if (fromCode === CHAR_FORWARD_SLASH) {\n                lastCommonSep = i;\n            }\n        }\n        if (i === length) {\n            if (toLen > length) {\n                if (to.charCodeAt(toStart + i) === CHAR_FORWARD_SLASH) {\n                    // We get here if `from` is the exact base path for `to`.\n                    // For example: from='/foo/bar'; to='/foo/bar/baz'\n                    return to.slice(toStart + i + 1);\n                }\n                if (i === 0) {\n                    // We get here if `from` is the root\n                    // For example: from='/'; to='/foo'\n                    return to.slice(toStart + i);\n                }\n            }\n            else if (fromLen > length) {\n                if (from.charCodeAt(fromStart + i) === CHAR_FORWARD_SLASH) {\n                    // We get here if `to` is the exact base path for `from`.\n                    // For example: from='/foo/bar/baz'; to='/foo/bar'\n                    lastCommonSep = i;\n                }\n                else if (i === 0) {\n                    // We get here if `to` is the root.\n                    // For example: from='/foo/bar'; to='/'\n                    lastCommonSep = 0;\n                }\n            }\n        }\n        let out = '';\n        // Generate the relative path based on the path difference between `to`\n        // and `from`.\n        for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n            if (i === fromEnd || from.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n                out += out.length === 0 ? '..' : '/..';\n            }\n        }\n        // Lastly, append the rest of the destination (`to`) path that comes after\n        // the common path parts.\n        return `${out}${to.slice(toStart + lastCommonSep)}`;\n    },\n    toNamespacedPath(path) {\n        // Non-op on posix systems\n        return path;\n    },\n    dirname(path) {\n        validateString(path, 'path');\n        if (path.length === 0) {\n            return '.';\n        }\n        const hasRoot = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n        let end = -1;\n        let matchedSlash = true;\n        for (let i = path.length - 1; i >= 1; --i) {\n            if (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n                if (!matchedSlash) {\n                    end = i;\n                    break;\n                }\n            }\n            else {\n                // We saw the first non-path separator\n                matchedSlash = false;\n            }\n        }\n        if (end === -1) {\n            return hasRoot ? '/' : '.';\n        }\n        if (hasRoot && end === 1) {\n            return '//';\n        }\n        return path.slice(0, end);\n    },\n    basename(path, ext) {\n        if (ext !== undefined) {\n            validateString(ext, 'ext');\n        }\n        validateString(path, 'path');\n        let start = 0;\n        let end = -1;\n        let matchedSlash = true;\n        let i;\n        if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n            if (ext === path) {\n                return '';\n            }\n            let extIdx = ext.length - 1;\n            let firstNonSlashEnd = -1;\n            for (i = path.length - 1; i >= 0; --i) {\n                const code = path.charCodeAt(i);\n                if (code === CHAR_FORWARD_SLASH) {\n                    // If we reached a path separator that was not part of a set of path\n                    // separators at the end of the string, stop now\n                    if (!matchedSlash) {\n                        start = i + 1;\n                        break;\n                    }\n                }\n                else {\n                    if (firstNonSlashEnd === -1) {\n                        // We saw the first non-path separator, remember this index in case\n                        // we need it if the extension ends up not matching\n                        matchedSlash = false;\n                        firstNonSlashEnd = i + 1;\n                    }\n                    if (extIdx >= 0) {\n                        // Try to match the explicit extension\n                        if (code === ext.charCodeAt(extIdx)) {\n                            if (--extIdx === -1) {\n                                // We matched the extension, so mark this as the end of our path\n                                // component\n                                end = i;\n                            }\n                        }\n                        else {\n                            // Extension does not match, so our result is the entire path\n                            // component\n                            extIdx = -1;\n                            end = firstNonSlashEnd;\n                        }\n                    }\n                }\n            }\n            if (start === end) {\n                end = firstNonSlashEnd;\n            }\n            else if (end === -1) {\n                end = path.length;\n            }\n            return path.slice(start, end);\n        }\n        for (i = path.length - 1; i >= 0; --i) {\n            if (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n                // If we reached a path separator that was not part of a set of path\n                // separators at the end of the string, stop now\n                if (!matchedSlash) {\n                    start = i + 1;\n                    break;\n                }\n            }\n            else if (end === -1) {\n                // We saw the first non-path separator, mark this as the end of our\n                // path component\n                matchedSlash = false;\n                end = i + 1;\n            }\n        }\n        if (end === -1) {\n            return '';\n        }\n        return path.slice(start, end);\n    },\n    extname(path) {\n        validateString(path, 'path');\n        let startDot = -1;\n        let startPart = 0;\n        let end = -1;\n        let matchedSlash = true;\n        // Track the state of characters (if any) we see before our first dot and\n        // after any path separator we find\n        let preDotState = 0;\n        for (let i = path.length - 1; i >= 0; --i) {\n            const code = path.charCodeAt(i);\n            if (code === CHAR_FORWARD_SLASH) {\n                // If we reached a path separator that was not part of a set of path\n                // separators at the end of the string, stop now\n                if (!matchedSlash) {\n                    startPart = i + 1;\n                    break;\n                }\n                continue;\n            }\n            if (end === -1) {\n                // We saw the first non-path separator, mark this as the end of our\n                // extension\n                matchedSlash = false;\n                end = i + 1;\n            }\n            if (code === CHAR_DOT) {\n                // If this is our first dot, mark it as the start of our extension\n                if (startDot === -1) {\n                    startDot = i;\n                }\n                else if (preDotState !== 1) {\n                    preDotState = 1;\n                }\n            }\n            else if (startDot !== -1) {\n                // We saw a non-dot and non-path separator before our dot, so we should\n                // have a good chance at having a non-empty extension\n                preDotState = -1;\n            }\n        }\n        if (startDot === -1 ||\n            end === -1 ||\n            // We saw a non-dot character immediately before the dot\n            preDotState === 0 ||\n            // The (right-most) trimmed path component is exactly '..'\n            (preDotState === 1 &&\n                startDot === end - 1 &&\n                startDot === startPart + 1)) {\n            return '';\n        }\n        return path.slice(startDot, end);\n    },\n    format: _format.bind(null, '/'),\n    parse(path) {\n        validateString(path, 'path');\n        const ret = { root: '', dir: '', base: '', ext: '', name: '' };\n        if (path.length === 0) {\n            return ret;\n        }\n        const isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n        let start;\n        if (isAbsolute) {\n            ret.root = '/';\n            start = 1;\n        }\n        else {\n            start = 0;\n        }\n        let startDot = -1;\n        let startPart = 0;\n        let end = -1;\n        let matchedSlash = true;\n        let i = path.length - 1;\n        // Track the state of characters (if any) we see before our first dot and\n        // after any path separator we find\n        let preDotState = 0;\n        // Get non-dir info\n        for (; i >= start; --i) {\n            const code = path.charCodeAt(i);\n            if (code === CHAR_FORWARD_SLASH) {\n                // If we reached a path separator that was not part of a set of path\n                // separators at the end of the string, stop now\n                if (!matchedSlash) {\n                    startPart = i + 1;\n                    break;\n                }\n                continue;\n            }\n            if (end === -1) {\n                // We saw the first non-path separator, mark this as the end of our\n                // extension\n                matchedSlash = false;\n                end = i + 1;\n            }\n            if (code === CHAR_DOT) {\n                // If this is our first dot, mark it as the start of our extension\n                if (startDot === -1) {\n                    startDot = i;\n                }\n                else if (preDotState !== 1) {\n                    preDotState = 1;\n                }\n            }\n            else if (startDot !== -1) {\n                // We saw a non-dot and non-path separator before our dot, so we should\n                // have a good chance at having a non-empty extension\n                preDotState = -1;\n            }\n        }\n        if (end !== -1) {\n            const start = startPart === 0 && isAbsolute ? 1 : startPart;\n            if (startDot === -1 ||\n                // We saw a non-dot character immediately before the dot\n                preDotState === 0 ||\n                // The (right-most) trimmed path component is exactly '..'\n                (preDotState === 1 &&\n                    startDot === end - 1 &&\n                    startDot === startPart + 1)) {\n                ret.base = ret.name = path.slice(start, end);\n            }\n            else {\n                ret.name = path.slice(start, startDot);\n                ret.base = path.slice(start, end);\n                ret.ext = path.slice(startDot, end);\n            }\n        }\n        if (startPart > 0) {\n            ret.dir = path.slice(0, startPart - 1);\n        }\n        else if (isAbsolute) {\n            ret.dir = '/';\n        }\n        return ret;\n    },\n    sep: '/',\n    delimiter: ':',\n    win32: null,\n    posix: null\n};\nposix.win32 = win32.win32 = win32;\nposix.posix = win32.posix = posix;\nconst normalize = (platform === 'win32' ? win32.normalize : posix.normalize);\nconst isAbsolute = (platform === 'win32' ? win32.isAbsolute : posix.isAbsolute);\nconst join = (platform === 'win32' ? win32.join : posix.join);\nconst resolve = (platform === 'win32' ? win32.resolve : posix.resolve);\nconst relative = (platform === 'win32' ? win32.relative : posix.relative);\nconst dirname = (platform === 'win32' ? win32.dirname : posix.dirname);\nconst basename = (platform === 'win32' ? win32.basename : posix.basename);\nconst extname = (platform === 'win32' ? win32.extname : posix.extname);\nconst format = (platform === 'win32' ? win32.format : posix.format);\nconst parse = (platform === 'win32' ? win32.parse : posix.parse);\nconst toNamespacedPath = (platform === 'win32' ? win32.toNamespacedPath : posix.toNamespacedPath);\nconst sep = (platform === 'win32' ? win32.sep : posix.sep);\nconst delimiter = (platform === 'win32' ? win32.delimiter : posix.delimiter);\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nconst _schemePattern = /^\\w[\\w\\d+.-]*$/;\nconst _singleSlashStart = /^\\//;\nconst _doubleSlashStart = /^\\/\\//;\nfunction _validateUri(ret, _strict) {\n    // scheme, must be set\n    if (!ret.scheme && _strict) {\n        throw new Error(`[UriError]: Scheme is missing: {scheme: \"\", authority: \"${ret.authority}\", path: \"${ret.path}\", query: \"${ret.query}\", fragment: \"${ret.fragment}\"}`);\n    }\n    // scheme, https://tools.ietf.org/html/rfc3986#section-3.1\n    // ALPHA *( ALPHA / DIGIT / \"+\" / \"-\" / \".\" )\n    if (ret.scheme && !_schemePattern.test(ret.scheme)) {\n        throw new Error('[UriError]: Scheme contains illegal characters.');\n    }\n    // path, http://tools.ietf.org/html/rfc3986#section-3.3\n    // If a URI contains an authority component, then the path component\n    // must either be empty or begin with a slash (\"/\") character.  If a URI\n    // does not contain an authority component, then the path cannot begin\n    // with two slash characters (\"//\").\n    if (ret.path) {\n        if (ret.authority) {\n            if (!_singleSlashStart.test(ret.path)) {\n                throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash (\"/\") character');\n            }\n        }\n        else {\n            if (_doubleSlashStart.test(ret.path)) {\n                throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters (\"//\")');\n            }\n        }\n    }\n}\n// for a while we allowed uris *without* schemes and this is the migration\n// for them, e.g. an uri without scheme and without strict-mode warns and falls\n// back to the file-scheme. that should cause the least carnage and still be a\n// clear warning\nfunction _schemeFix(scheme, _strict) {\n    if (!scheme && !_strict) {\n        return 'file';\n    }\n    return scheme;\n}\n// implements a bit of https://tools.ietf.org/html/rfc3986#section-5\nfunction _referenceResolution(scheme, path) {\n    // the slash-character is our 'default base' as we don't\n    // support constructing URIs relative to other URIs. This\n    // also means that we alter and potentially break paths.\n    // see https://tools.ietf.org/html/rfc3986#section-5.1.4\n    switch (scheme) {\n        case 'https':\n        case 'http':\n        case 'file':\n            if (!path) {\n                path = _slash;\n            }\n            else if (path[0] !== _slash) {\n                path = _slash + path;\n            }\n            break;\n    }\n    return path;\n}\nconst _empty = '';\nconst _slash = '/';\nconst _regexp = /^(([^:/?#]+?):)?(\\/\\/([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?/;\n/**\n * Uniform Resource Identifier (URI) http://tools.ietf.org/html/rfc3986.\n * This class is a simple parser which creates the basic component parts\n * (http://tools.ietf.org/html/rfc3986#section-3) with minimal validation\n * and encoding.\n *\n * ```txt\n *       foo://example.com:8042/over/there?name=ferret#nose\n *       \\_/   \\______________/\\_________/ \\_________/ \\__/\n *        |           |            |            |        |\n *     scheme     authority       path        query   fragment\n *        |   _____________________|__\n *       / \\ /                        \\\n *       urn:example:animal:ferret:nose\n * ```\n */\nclass URI {\n    /**\n     * @internal\n     */\n    constructor(schemeOrData, authority, path, query, fragment, _strict = false) {\n        if (typeof schemeOrData === 'object') {\n            this.scheme = schemeOrData.scheme || _empty;\n            this.authority = schemeOrData.authority || _empty;\n            this.path = schemeOrData.path || _empty;\n            this.query = schemeOrData.query || _empty;\n            this.fragment = schemeOrData.fragment || _empty;\n            // no validation because it's this URI\n            // that creates uri components.\n            // _validateUri(this);\n        }\n        else {\n            this.scheme = _schemeFix(schemeOrData, _strict);\n            this.authority = authority || _empty;\n            this.path = _referenceResolution(this.scheme, path || _empty);\n            this.query = query || _empty;\n            this.fragment = fragment || _empty;\n            _validateUri(this, _strict);\n        }\n    }\n    static isUri(thing) {\n        if (thing instanceof URI) {\n            return true;\n        }\n        if (!thing) {\n            return false;\n        }\n        return typeof thing.authority === 'string'\n            && typeof thing.fragment === 'string'\n            && typeof thing.path === 'string'\n            && typeof thing.query === 'string'\n            && typeof thing.scheme === 'string'\n            && typeof thing.fsPath === 'function'\n            && typeof thing.with === 'function'\n            && typeof thing.toString === 'function';\n    }\n    // ---- filesystem path -----------------------\n    /**\n     * Returns a string representing the corresponding file system path of this URI.\n     * Will handle UNC paths, normalizes windows drive letters to lower-case, and uses the\n     * platform specific path separator.\n     *\n     * * Will *not* validate the path for invalid characters and semantics.\n     * * Will *not* look at the scheme of this URI.\n     * * The result shall *not* be used for display purposes but for accessing a file on disk.\n     *\n     *\n     * The *difference* to `URI#path` is the use of the platform specific separator and the handling\n     * of UNC paths. See the below sample of a file-uri with an authority (UNC path).\n     *\n     * ```ts\n        const u = URI.parse('file://server/c$/folder/file.txt')\n        u.authority === 'server'\n        u.path === '/shares/c$/file.txt'\n        u.fsPath === '\\\\server\\c$\\folder\\file.txt'\n    ```\n     *\n     * Using `URI#path` to read a file (using fs-apis) would not be enough because parts of the path,\n     * namely the server name, would be missing. Therefore `URI#fsPath` exists - it's sugar to ease working\n     * with URIs that represent files on disk (`file` scheme).\n     */\n    get fsPath() {\n        // if (this.scheme !== 'file') {\n        // \tconsole.warn(`[UriError] calling fsPath with scheme ${this.scheme}`);\n        // }\n        return uriToFsPath(this, false);\n    }\n    // ---- modify to new -------------------------\n    with(change) {\n        if (!change) {\n            return this;\n        }\n        let { scheme, authority, path, query, fragment } = change;\n        if (scheme === undefined) {\n            scheme = this.scheme;\n        }\n        else if (scheme === null) {\n            scheme = _empty;\n        }\n        if (authority === undefined) {\n            authority = this.authority;\n        }\n        else if (authority === null) {\n            authority = _empty;\n        }\n        if (path === undefined) {\n            path = this.path;\n        }\n        else if (path === null) {\n            path = _empty;\n        }\n        if (query === undefined) {\n            query = this.query;\n        }\n        else if (query === null) {\n            query = _empty;\n        }\n        if (fragment === undefined) {\n            fragment = this.fragment;\n        }\n        else if (fragment === null) {\n            fragment = _empty;\n        }\n        if (scheme === this.scheme\n            && authority === this.authority\n            && path === this.path\n            && query === this.query\n            && fragment === this.fragment) {\n            return this;\n        }\n        return new _URI(scheme, authority, path, query, fragment);\n    }\n    // ---- parse & validate ------------------------\n    /**\n     * Creates a new URI from a string, e.g. `http://www.msft.com/some/path`,\n     * `file:///usr/home`, or `scheme:with/path`.\n     *\n     * @param value A string which represents an URI (see `URI#toString`).\n     */\n    static parse(value, _strict = false) {\n        const match = _regexp.exec(value);\n        if (!match) {\n            return new _URI(_empty, _empty, _empty, _empty, _empty);\n        }\n        return new _URI(match[2] || _empty, percentDecode(match[4] || _empty), percentDecode(match[5] || _empty), percentDecode(match[7] || _empty), percentDecode(match[9] || _empty), _strict);\n    }\n    /**\n     * Creates a new URI from a file system path, e.g. `c:\\my\\files`,\n     * `/usr/home`, or `\\\\server\\share\\some\\path`.\n     *\n     * The *difference* between `URI#parse` and `URI#file` is that the latter treats the argument\n     * as path, not as stringified-uri. E.g. `URI.file(path)` is **not the same as**\n     * `URI.parse('file://' + path)` because the path might contain characters that are\n     * interpreted (# and ?). See the following sample:\n     * ```ts\n    const good = URI.file('/coding/c#/project1');\n    good.scheme === 'file';\n    good.path === '/coding/c#/project1';\n    good.fragment === '';\n    const bad = URI.parse('file://' + '/coding/c#/project1');\n    bad.scheme === 'file';\n    bad.path === '/coding/c'; // path is now broken\n    bad.fragment === '/project1';\n    ```\n     *\n     * @param path A file system path (see `URI#fsPath`)\n     */\n    static file(path) {\n        let authority = _empty;\n        // check for authority as used in UNC shares\n        // or use the path as given\n        if (path[0] === _slash && path[1] === _slash) {\n            const idx = path.indexOf(_slash, 2);\n            if (idx === -1) {\n                authority = path.substring(2);\n                path = _slash;\n            }\n            else {\n                authority = path.substring(2, idx);\n                path = path.substring(idx) || _slash;\n            }\n        }\n        return new _URI('file', authority, path, _empty, _empty);\n    }\n    static from(components) {\n        return new _URI(components.scheme, components.authority, components.path, components.query, components.fragment);\n    }\n    /**\n     * Join a URI path with path fragments and normalizes the resulting path.\n     *\n     * @param uri The input URI.\n     * @param pathFragment The path fragment to add to the URI path.\n     * @returns The resulting URI.\n     */\n    static joinPath(uri, ...pathFragment) {\n        if (!uri.path) {\n            throw new Error(`[UriError]: cannot call joinPaths on URI without path`);\n        }\n        let newPath;\n        {\n            newPath = posix.join(uri.path, ...pathFragment);\n        }\n        return uri.with({ path: newPath });\n    }\n    // ---- printing/externalize ---------------------------\n    /**\n     * Creates a string representation for this URI. It's guaranteed that calling\n     * `URI.parse` with the result of this function creates an URI which is equal\n     * to this URI.\n     *\n     * * The result shall *not* be used for display purposes but for externalization or transport.\n     * * The result will be encoded using the percentage encoding and encoding happens mostly\n     * ignore the scheme-specific encoding rules.\n     *\n     * @param skipEncoding Do not encode the result, default is `false`\n     */\n    toString(skipEncoding = false) {\n        return _asFormatted(this, skipEncoding);\n    }\n    toJSON() {\n        return this;\n    }\n    static revive(data) {\n        if (!data) {\n            return data;\n        }\n        else if (data instanceof URI) {\n            return data;\n        }\n        else {\n            const result = new _URI(data);\n            result._formatted = data.external;\n            result._fsPath = data._sep === _pathSepMarker ? data.fsPath : null;\n            return result;\n        }\n    }\n}\nconst _pathSepMarker =  undefined;\n// eslint-disable-next-line @typescript-eslint/naming-convention\nclass _URI extends URI {\n    constructor() {\n        super(...arguments);\n        this._formatted = null;\n        this._fsPath = null;\n    }\n    get fsPath() {\n        if (!this._fsPath) {\n            this._fsPath = uriToFsPath(this, false);\n        }\n        return this._fsPath;\n    }\n    toString(skipEncoding = false) {\n        if (!skipEncoding) {\n            if (!this._formatted) {\n                this._formatted = _asFormatted(this, false);\n            }\n            return this._formatted;\n        }\n        else {\n            // we don't cache that\n            return _asFormatted(this, true);\n        }\n    }\n    toJSON() {\n        const res = {\n            $mid: 1\n        };\n        // cached state\n        if (this._fsPath) {\n            res.fsPath = this._fsPath;\n            res._sep = _pathSepMarker;\n        }\n        if (this._formatted) {\n            res.external = this._formatted;\n        }\n        // uri components\n        if (this.path) {\n            res.path = this.path;\n        }\n        if (this.scheme) {\n            res.scheme = this.scheme;\n        }\n        if (this.authority) {\n            res.authority = this.authority;\n        }\n        if (this.query) {\n            res.query = this.query;\n        }\n        if (this.fragment) {\n            res.fragment = this.fragment;\n        }\n        return res;\n    }\n}\n// reserved characters: https://tools.ietf.org/html/rfc3986#section-2.2\nconst encodeTable = {\n    [58 /* Colon */]: '%3A',\n    [47 /* Slash */]: '%2F',\n    [63 /* QuestionMark */]: '%3F',\n    [35 /* Hash */]: '%23',\n    [91 /* OpenSquareBracket */]: '%5B',\n    [93 /* CloseSquareBracket */]: '%5D',\n    [64 /* AtSign */]: '%40',\n    [33 /* ExclamationMark */]: '%21',\n    [36 /* DollarSign */]: '%24',\n    [38 /* Ampersand */]: '%26',\n    [39 /* SingleQuote */]: '%27',\n    [40 /* OpenParen */]: '%28',\n    [41 /* CloseParen */]: '%29',\n    [42 /* Asterisk */]: '%2A',\n    [43 /* Plus */]: '%2B',\n    [44 /* Comma */]: '%2C',\n    [59 /* Semicolon */]: '%3B',\n    [61 /* Equals */]: '%3D',\n    [32 /* Space */]: '%20',\n};\nfunction encodeURIComponentFast(uriComponent, allowSlash) {\n    let res = undefined;\n    let nativeEncodePos = -1;\n    for (let pos = 0; pos < uriComponent.length; pos++) {\n        const code = uriComponent.charCodeAt(pos);\n        // unreserved characters: https://tools.ietf.org/html/rfc3986#section-2.3\n        if ((code >= 97 /* a */ && code <= 122 /* z */)\n            || (code >= 65 /* A */ && code <= 90 /* Z */)\n            || (code >= 48 /* Digit0 */ && code <= 57 /* Digit9 */)\n            || code === 45 /* Dash */\n            || code === 46 /* Period */\n            || code === 95 /* Underline */\n            || code === 126 /* Tilde */\n            || (allowSlash && code === 47 /* Slash */)) {\n            // check if we are delaying native encode\n            if (nativeEncodePos !== -1) {\n                res += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));\n                nativeEncodePos = -1;\n            }\n            // check if we write into a new string (by default we try to return the param)\n            if (res !== undefined) {\n                res += uriComponent.charAt(pos);\n            }\n        }\n        else {\n            // encoding needed, we need to allocate a new string\n            if (res === undefined) {\n                res = uriComponent.substr(0, pos);\n            }\n            // check with default table first\n            const escaped = encodeTable[code];\n            if (escaped !== undefined) {\n                // check if we are delaying native encode\n                if (nativeEncodePos !== -1) {\n                    res += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));\n                    nativeEncodePos = -1;\n                }\n                // append escaped variant to result\n                res += escaped;\n            }\n            else if (nativeEncodePos === -1) {\n                // use native encode only when needed\n                nativeEncodePos = pos;\n            }\n        }\n    }\n    if (nativeEncodePos !== -1) {\n        res += encodeURIComponent(uriComponent.substring(nativeEncodePos));\n    }\n    return res !== undefined ? res : uriComponent;\n}\nfunction encodeURIComponentMinimal(path) {\n    let res = undefined;\n    for (let pos = 0; pos < path.length; pos++) {\n        const code = path.charCodeAt(pos);\n        if (code === 35 /* Hash */ || code === 63 /* QuestionMark */) {\n            if (res === undefined) {\n                res = path.substr(0, pos);\n            }\n            res += encodeTable[code];\n        }\n        else {\n            if (res !== undefined) {\n                res += path[pos];\n            }\n        }\n    }\n    return res !== undefined ? res : path;\n}\n/**\n * Compute `fsPath` for the given uri\n */\nfunction uriToFsPath(uri, keepDriveLetterCasing) {\n    let value;\n    if (uri.authority && uri.path.length > 1 && uri.scheme === 'file') {\n        // unc path: file://shares/c$/far/boo\n        value = `//${uri.authority}${uri.path}`;\n    }\n    else if (uri.path.charCodeAt(0) === 47 /* Slash */\n        && (uri.path.charCodeAt(1) >= 65 /* A */ && uri.path.charCodeAt(1) <= 90 /* Z */ || uri.path.charCodeAt(1) >= 97 /* a */ && uri.path.charCodeAt(1) <= 122 /* z */)\n        && uri.path.charCodeAt(2) === 58 /* Colon */) {\n        if (!keepDriveLetterCasing) {\n            // windows drive letter: file:///c:/far/boo\n            value = uri.path[1].toLowerCase() + uri.path.substr(2);\n        }\n        else {\n            value = uri.path.substr(1);\n        }\n    }\n    else {\n        // other path\n        value = uri.path;\n    }\n    return value;\n}\n/**\n * Create the external version of a uri\n */\nfunction _asFormatted(uri, skipEncoding) {\n    const encoder = !skipEncoding\n        ? encodeURIComponentFast\n        : encodeURIComponentMinimal;\n    let res = '';\n    let { scheme, authority, path, query, fragment } = uri;\n    if (scheme) {\n        res += scheme;\n        res += ':';\n    }\n    if (authority || scheme === 'file') {\n        res += _slash;\n        res += _slash;\n    }\n    if (authority) {\n        let idx = authority.indexOf('@');\n        if (idx !== -1) {\n            // <user>@<auth>\n            const userinfo = authority.substr(0, idx);\n            authority = authority.substr(idx + 1);\n            idx = userinfo.indexOf(':');\n            if (idx === -1) {\n                res += encoder(userinfo, false);\n            }\n            else {\n                // <user>:<pass>@<auth>\n                res += encoder(userinfo.substr(0, idx), false);\n                res += ':';\n                res += encoder(userinfo.substr(idx + 1), false);\n            }\n            res += '@';\n        }\n        authority = authority.toLowerCase();\n        idx = authority.indexOf(':');\n        if (idx === -1) {\n            res += encoder(authority, false);\n        }\n        else {\n            // <auth>:<port>\n            res += encoder(authority.substr(0, idx), false);\n            res += authority.substr(idx);\n        }\n    }\n    if (path) {\n        // lower-case windows drive letters in /C:/fff or C:/fff\n        if (path.length >= 3 && path.charCodeAt(0) === 47 /* Slash */ && path.charCodeAt(2) === 58 /* Colon */) {\n            const code = path.charCodeAt(1);\n            if (code >= 65 /* A */ && code <= 90 /* Z */) {\n                path = `/${String.fromCharCode(code + 32)}:${path.substr(3)}`; // \"/c:\".length === 3\n            }\n        }\n        else if (path.length >= 2 && path.charCodeAt(1) === 58 /* Colon */) {\n            const code = path.charCodeAt(0);\n            if (code >= 65 /* A */ && code <= 90 /* Z */) {\n                path = `${String.fromCharCode(code + 32)}:${path.substr(2)}`; // \"/c:\".length === 3\n            }\n        }\n        // encode the rest of the path\n        res += encoder(path, true);\n    }\n    if (query) {\n        res += '?';\n        res += encoder(query, false);\n    }\n    if (fragment) {\n        res += '#';\n        res += !skipEncoding ? encodeURIComponentFast(fragment, false) : fragment;\n    }\n    return res;\n}\n// --- decode\nfunction decodeURIComponentGraceful(str) {\n    try {\n        return decodeURIComponent(str);\n    }\n    catch (_a) {\n        if (str.length > 3) {\n            return str.substr(0, 3) + decodeURIComponentGraceful(str.substr(3));\n        }\n        else {\n            return str;\n        }\n    }\n}\nconst _rEncodedAsHex = /(%[0-9A-Za-z][0-9A-Za-z])+/g;\nfunction percentDecode(str) {\n    if (!str.match(_rEncodedAsHex)) {\n        return str;\n    }\n    return str.replace(_rEncodedAsHex, (match) => decodeURIComponentGraceful(match));\n}\n\nexport { AsyncEmitter, Barrier, CancellationToken, CancellationTokenSource, Delayer, Disposable, DisposableStore, Emitter, Event, EventBufferer, EventMultiplexer, ImmortalReference, Limiter, MutableDisposable, PauseableEmitter, Queue, ReferenceCollection, Relay, Sequencer, ThrottledDelayer, Throttler, URI, asPromise, basename, combinedDisposable, createCancelablePromise, delimiter, dirname, disposableTimeout, dispose, extname, first, format, ignoreErrors, isAbsolute, isDisposable, isThenable, join, normalize, parse, posix, raceCancellation, relative, resolve, retry, sep, sequence, setGlobalLeakWarningThreshold, timeout, toDisposable, toNamespacedPath, uriToFsPath, win32 };\n//# sourceMappingURL=index.esm.js.map\n", "export { CancellationToken, CancellationTokenSource } from 'ts-primitives';\n", "export class Decoder {\n  private readonly decoder: TextDecoder | undefined;\n\n  constructor() {\n    if (typeof TextDecoder !== 'undefined') {\n      this.decoder = new TextDecoder();\n    } else if (typeof Buffer !== 'function' || typeof Buffer['from'] !== 'function') {\n      throw new Error(\n        'The environment supports neither the TextDecoder nor Buffer API. Please consider polyfilling one of these.'\n      );\n    }\n  }\n\n  decode(buf: BufferSource): string {\n    const str = this.decoder\n      ? this.decoder.decode(buf)\n      : (Buffer as any).from(buf).toString('utf-8');\n\n    return str.charCodeAt(0) === 0xfeff ? str.slice(1) : str;\n  }\n}\n", "export { Emitter, Event } from 'ts-primitives';\n", "export { DisposableStore } from 'ts-primitives';\nexport type { IDisposable } from 'ts-primitives';\n", "export class MapSet<K, V> {\n  private readonly _data = new Map<K, Set<V>>();\n\n  get size() {\n    return this._data.size;\n  }\n\n  add(key: K, value: V) {\n    let values = this._data.get(key);\n\n    if (!values) {\n      values = new Set();\n      this._data.set(key, values);\n    }\n\n    values.add(value);\n\n    return this;\n  }\n\n  clear() {\n    this._data.clear();\n  }\n\n  delete(key: K, value: V) {\n    const values = this._data.get(key);\n\n    if (values) {\n      const ret = values.delete(value);\n\n      if (!values.size) {\n        this._data.delete(key);\n      }\n\n      return ret;\n    }\n\n    return false;\n  }\n\n  deleteAll(key: K) {\n    return this._data.delete(key);\n  }\n\n  get(key: K) {\n    return this._data.get(key);\n  }\n\n  has(key: K) {\n    return this._data.has(key);\n  }\n\n  hasValue(key: K, value: V) {\n    const values = this._data.get(key);\n\n    return values ? values.has(value) : false;\n  }\n\n  *entries(): IterableIterator<[K, V]> {\n    for (const [key, values] of this._data.entries()) {\n      for (const value of values) {\n        yield [key, value];\n      }\n    }\n  }\n\n  *values(): IterableIterator<V> {\n    for (const values of this._data.values()) {\n      yield* values.values();\n    }\n  }\n}\n", "import { Decoder } from './decoder';\n\nexport type PackageMainField = 'browser' | 'module' | 'jsnext:main' | 'main' | 'unpkg';\n\nexport interface PartialPackageJson {\n  name?: string;\n  version?: string;\n  browser?: string | { [key: string]: false | string };\n  main?: string;\n  module?: string;\n  'jsnext:main'?: string;\n  dependencies?: { [key: string]: string };\n  devDependencies?: { [key: string]: string };\n  peerDependencies?: { [key: string]: string };\n  unpkg?: string;\n}\nexport interface PackageJson extends PartialPackageJson {\n  name: string;\n  version: string;\n}\n\nexport function isValidPartialPackageJson(json: unknown): json is PartialPackageJson {\n  return (\n    typeof json === 'object' &&\n    json !== null &&\n    !hasInvalidOptionalStringField(json as any, 'name') &&\n    !hasInvalidOptionalStringField(json as any, 'version') &&\n    !hasInvalidBrowserField(json as any) &&\n    !hasInvalidOptionalStringField(json as any, 'main') &&\n    !hasInvalidOptionalStringField(json as any, 'module') &&\n    !hasInvalidOptionalStringField(json as any, 'jsnext:main') &&\n    !hasInvalidOptionalStringField(json as any, 'unpkg') &&\n    !hasInvalidDependenciesField(json as any, 'dependencies') &&\n    !hasInvalidDependenciesField(json as any, 'devDependencies') &&\n    !hasInvalidDependenciesField(json as any, 'peerDependencies')\n  );\n}\n\nexport function isValidPackageJson(json: unknown): json is PackageJson {\n  return (\n    typeof json === 'object' &&\n    json !== null &&\n    !hasInvalidRequiredStringField(json as any, 'name') &&\n    !hasInvalidRequiredStringField(json as any, 'version') &&\n    !hasInvalidBrowserField(json as any) &&\n    !hasInvalidOptionalStringField(json as any, 'main') &&\n    !hasInvalidOptionalStringField(json as any, 'module') &&\n    !hasInvalidOptionalStringField(json as any, 'jsnext:main') &&\n    !hasInvalidOptionalStringField(json as any, 'unpkg') &&\n    !hasInvalidDependenciesField(json as any, 'dependencies') &&\n    !hasInvalidDependenciesField(json as any, 'devDependencies') &&\n    !hasInvalidDependenciesField(json as any, 'peerDependencies')\n  );\n}\n\nfunction hasInvalidBrowserField(json: any) {\n  let error = '';\n\n  const browser = json.browser;\n  if (browser) {\n    if (typeof browser === 'object') {\n      for (const key in browser) {\n        if (typeof key !== 'string') {\n          error = `The key ${key} of .browser must be a string`;\n          break;\n        }\n        if (typeof browser[key] !== 'string' && browser[key] !== false) {\n          error = `The value ${key} of .browser must be a string or false`;\n          break;\n        }\n      }\n    }\n  }\n\n  return error;\n}\n\nfunction hasInvalidRequiredStringField(json: any, field: string) {\n  return typeof json[field] !== 'string';\n}\n\nfunction hasInvalidOptionalStringField(json: any, field: string) {\n  return json[field] !== undefined && typeof json[field] !== 'string';\n}\n\nfunction hasInvalidDependenciesField(json: any, field: string) {\n  return (\n    json[field] !== undefined &&\n    typeof json[field] === 'object' &&\n    json[field] !== null &&\n    !Object.keys(json[field]).every(\n      (key) => typeof key === 'string' && typeof json[field][key] === 'string'\n    )\n  );\n}\n\nexport function parseBufferAsPartialPackageJson(\n  decoder: Decoder,\n  content: ArrayBuffer,\n  spec: string\n): PartialPackageJson {\n  try {\n    const text = decoder.decode(content);\n\n    return parseTextAsPartialPackageJson(text, spec);\n  } catch (err) {\n    throw new Error(`Error decoding manifest buffer for package ${spec}: ${err.message}`);\n  }\n}\n\nexport function parseBufferAsPackageJson(\n  decoder: Decoder,\n  content: ArrayBuffer,\n  spec: string\n): PackageJson {\n  try {\n    const text = decoder.decode(content);\n\n    return parseTextAsPackageJson(text, spec);\n  } catch (err) {\n    throw new Error(`Error decoding manifest buffer for package ${spec}: ${err.message}`);\n  }\n}\n\nfunction parseTextAsPartialPackageJson(text: string, spec: string): PartialPackageJson {\n  let json: unknown;\n\n  try {\n    json = JSON.parse(text);\n  } catch (err) {\n    throw new Error(`Error parsing manifest as json for package ${spec}: ${err.message}`);\n  }\n\n  if (!isValidPartialPackageJson(json)) {\n    throw new Error(`Invalid manifest for the package ${spec}`);\n  }\n\n  return json;\n}\n\nfunction parseTextAsPackageJson(text: string, spec: string): PackageJson {\n  const json = parseTextAsPartialPackageJson(text, spec);\n\n  if (!isValidPackageJson(json)) {\n    throw new Error(`Invalid manifest for the package ${spec}`);\n  }\n\n  return json;\n}\n", "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n// NOTE: VSCode's copy of nodejs path library to be usable in common (non-node) namespace\n// Copied from: https://github.com/nodejs/node/blob/v12.8.1/lib/path.js\n\n/**\n * Copyright Joyent, Inc. and other Node contributors.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to permit\n * persons to whom the Software is furnished to do so, subject to the\n * following conditions:\n *\n * The above copyright notice and this permission notice shall be included\n * in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n * NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n * USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\nconst CHAR_DOT = 46; /* . */\nconst CHAR_FORWARD_SLASH = 47; /* / */\n\nclass ErrorInvalidArgType extends Error {\n  code: 'ERR_INVALID_ARG_TYPE';\n  constructor(name: string, expected: string, actual: any) {\n    // determiner: 'must be' or 'must not be'\n    let determiner;\n    if (typeof expected === 'string' && expected.indexOf('not ') === 0) {\n      determiner = 'must not be';\n      expected = expected.replace(/^not /, '');\n    } else {\n      determiner = 'must be';\n    }\n\n    const type = name.indexOf('.') !== -1 ? 'property' : 'argument';\n    let msg = `The \"${name}\" ${type} ${determiner} of type ${expected}`;\n\n    msg += `. Received type ${typeof actual}`;\n    super(msg);\n\n    this.code = 'ERR_INVALID_ARG_TYPE';\n  }\n}\n\nfunction validateString(value: string, name: string) {\n  if (typeof value !== 'string') {\n    throw new ErrorInvalidArgType(name, 'string', value);\n  }\n}\n\nfunction isPosixPathSeparator(code: number | undefined) {\n  return code === CHAR_FORWARD_SLASH;\n}\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeString(\n  path: string,\n  allowAboveRoot: boolean,\n  separator: string,\n  isPathSeparator: (code?: number) => boolean\n) {\n  let res = '';\n  let lastSegmentLength = 0;\n  let lastSlash = -1;\n  let dots = 0;\n  let code = 0;\n  for (let i = 0; i <= path.length; ++i) {\n    if (i < path.length) {\n      code = path.charCodeAt(i);\n    } else if (isPathSeparator(code)) {\n      break;\n    } else {\n      code = CHAR_FORWARD_SLASH;\n    }\n\n    if (isPathSeparator(code)) {\n      if (lastSlash === i - 1 || dots === 1) {\n        // NOOP\n      } else if (dots === 2) {\n        if (\n          res.length < 2 ||\n          lastSegmentLength !== 2 ||\n          res.charCodeAt(res.length - 1) !== CHAR_DOT ||\n          res.charCodeAt(res.length - 2) !== CHAR_DOT\n        ) {\n          if (res.length > 2) {\n            const lastSlashIndex = res.lastIndexOf(separator);\n            if (lastSlashIndex === -1) {\n              res = '';\n              lastSegmentLength = 0;\n            } else {\n              res = res.slice(0, lastSlashIndex);\n              lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);\n            }\n            lastSlash = i;\n            dots = 0;\n            continue;\n          } else if (res.length !== 0) {\n            res = '';\n            lastSegmentLength = 0;\n            lastSlash = i;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          res += res.length > 0 ? `${separator}..` : '..';\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (res.length > 0) {\n          res += `${separator}${path.slice(lastSlash + 1, i)}`;\n        } else {\n          res = path.slice(lastSlash + 1, i);\n        }\n        lastSegmentLength = i - lastSlash - 1;\n      }\n      lastSlash = i;\n      dots = 0;\n    } else if (code === CHAR_DOT && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\n\nfunction _format(sep: string, pathObject: ParsedPath) {\n  if (pathObject === null || typeof pathObject !== 'object') {\n    throw new ErrorInvalidArgType('pathObject', 'Object', pathObject);\n  }\n  const dir = pathObject.dir || pathObject.root;\n  const base = pathObject.base || `${pathObject.name || ''}${pathObject.ext || ''}`;\n  if (!dir) {\n    return base;\n  }\n  return dir === pathObject.root ? `${dir}${base}` : `${dir}${sep}${base}`;\n}\n\nexport interface ParsedPath {\n  root: string;\n  dir: string;\n  base: string;\n  ext: string;\n  name: string;\n}\n\nexport interface IPath {\n  normalize(path: string): string;\n  isAbsolute(path: string): boolean;\n  join(...paths: string[]): string;\n  resolve(...pathSegments: string[]): string;\n  relative(from: string, to: string): string;\n  dirname(path: string): string;\n  basename(path: string, ext?: string): string;\n  extname(path: string): string;\n  format(pathObject: ParsedPath): string;\n  parse(path: string): ParsedPath;\n  toNamespacedPath(path: string): string;\n  sep: '\\\\' | '/';\n  delimiter: string;\n  win32: IPath | null;\n  posix: IPath | null;\n}\n\n// export const win32: IPath = {\n// \t// path.resolve([from ...], to)\n// \tresolve(...pathSegments: string[]): string {\n// \t\tlet resolvedDevice = '';\n// \t\tlet resolvedTail = '';\n// \t\tlet resolvedAbsolute = false;\n\n// \t\tfor (let i = pathSegments.length - 1; i >= -1; i--) {\n// \t\t\tlet path;\n// \t\t\tif (i >= 0) {\n// \t\t\t\tpath = pathSegments[i];\n// \t\t\t\tvalidateString(path, 'path');\n\n// \t\t\t\t// Skip empty entries\n// \t\t\t\tif (path.length === 0) {\n// \t\t\t\t\tcontinue;\n// \t\t\t\t}\n// \t\t\t} else if (resolvedDevice.length === 0) {\n// \t\t\t\tpath = process.cwd();\n// \t\t\t} else {\n// \t\t\t\t// Windows has the concept of drive-specific current working\n// \t\t\t\t// directories. If we've resolved a drive letter but not yet an\n// \t\t\t\t// absolute path, get cwd for that drive, or the process cwd if\n// \t\t\t\t// the drive cwd is not available. We're sure the device is not\n// \t\t\t\t// a UNC path at this points, because UNC paths are always absolute.\n// \t\t\t\tpath = (process.env as any)[`=${resolvedDevice}`] || process.cwd();\n\n// \t\t\t\t// Verify that a cwd was found and that it actually points\n// \t\t\t\t// to our drive. If not, default to the drive's root.\n// \t\t\t\tif (path === undefined ||\n// \t\t\t\t\tpath.slice(0, 2).toLowerCase() !== resolvedDevice.toLowerCase() &&\n// \t\t\t\t\tpath.charCodeAt(2) === CHAR_BACKWARD_SLASH) {\n// \t\t\t\t\tpath = `${resolvedDevice}\\\\`;\n// \t\t\t\t}\n// \t\t\t}\n\n// \t\t\tconst len = path.length;\n// \t\t\tlet rootEnd = 0;\n// \t\t\tlet device = '';\n// \t\t\tlet isAbsolute = false;\n// \t\t\tconst code = path.charCodeAt(0);\n\n// \t\t\t// Try to match a root\n// \t\t\tif (len === 1) {\n// \t\t\t\tif (isPathSeparator(code)) {\n// \t\t\t\t\t// `path` contains just a path separator\n// \t\t\t\t\trootEnd = 1;\n// \t\t\t\t\tisAbsolute = true;\n// \t\t\t\t}\n// \t\t\t} else if (isPathSeparator(code)) {\n// \t\t\t\t// Possible UNC root\n\n// \t\t\t\t// If we started with a separator, we know we at least have an\n// \t\t\t\t// absolute path of some kind (UNC or otherwise)\n// \t\t\t\tisAbsolute = true;\n\n// \t\t\t\tif (isPathSeparator(path.charCodeAt(1))) {\n// \t\t\t\t\t// Matched double path separator at beginning\n// \t\t\t\t\tlet j = 2;\n// \t\t\t\t\tlet last = j;\n// \t\t\t\t\t// Match 1 or more non-path separators\n// \t\t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n// \t\t\t\t\t\tj++;\n// \t\t\t\t\t}\n// \t\t\t\t\tif (j < len && j !== last) {\n// \t\t\t\t\t\tconst firstPart = path.slice(last, j);\n// \t\t\t\t\t\t// Matched!\n// \t\t\t\t\t\tlast = j;\n// \t\t\t\t\t\t// Match 1 or more path separators\n// \t\t\t\t\t\twhile (j < len && isPathSeparator(path.charCodeAt(j))) {\n// \t\t\t\t\t\t\tj++;\n// \t\t\t\t\t\t}\n// \t\t\t\t\t\tif (j < len && j !== last) {\n// \t\t\t\t\t\t\t// Matched!\n// \t\t\t\t\t\t\tlast = j;\n// \t\t\t\t\t\t\t// Match 1 or more non-path separators\n// \t\t\t\t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n// \t\t\t\t\t\t\t\tj++;\n// \t\t\t\t\t\t\t}\n// \t\t\t\t\t\t\tif (j === len || j !== last) {\n// \t\t\t\t\t\t\t\t// We matched a UNC root\n// \t\t\t\t\t\t\t\tdevice = `\\\\\\\\${firstPart}\\\\${path.slice(last, j)}`;\n// \t\t\t\t\t\t\t\trootEnd = j;\n// \t\t\t\t\t\t\t}\n// \t\t\t\t\t\t}\n// \t\t\t\t\t}\n// \t\t\t\t} else {\n// \t\t\t\t\trootEnd = 1;\n// \t\t\t\t}\n// \t\t\t} else if (isWindowsDeviceRoot(code) &&\n// \t\t\t\tpath.charCodeAt(1) === CHAR_COLON) {\n// \t\t\t\t// Possible device root\n// \t\t\t\tdevice = path.slice(0, 2);\n// \t\t\t\trootEnd = 2;\n// \t\t\t\tif (len > 2 && isPathSeparator(path.charCodeAt(2))) {\n// \t\t\t\t\t// Treat separator following drive name as an absolute path\n// \t\t\t\t\t// indicator\n// \t\t\t\t\tisAbsolute = true;\n// \t\t\t\t\trootEnd = 3;\n// \t\t\t\t}\n// \t\t\t}\n\n// \t\t\tif (device.length > 0) {\n// \t\t\t\tif (resolvedDevice.length > 0) {\n// \t\t\t\t\tif (device.toLowerCase() !== resolvedDevice.toLowerCase()) {\n// \t\t\t\t\t\t// This path points to another device so it is not applicable\n// \t\t\t\t\t\tcontinue;\n// \t\t\t\t\t}\n// \t\t\t\t} else {\n// \t\t\t\t\tresolvedDevice = device;\n// \t\t\t\t}\n// \t\t\t}\n\n// \t\t\tif (resolvedAbsolute) {\n// \t\t\t\tif (resolvedDevice.length > 0) {\n// \t\t\t\t\tbreak;\n// \t\t\t\t}\n// \t\t\t} else {\n// \t\t\t\tresolvedTail = `${path.slice(rootEnd)}\\\\${resolvedTail}`;\n// \t\t\t\tresolvedAbsolute = isAbsolute;\n// \t\t\t\tif (isAbsolute && resolvedDevice.length > 0) {\n// \t\t\t\t\tbreak;\n// \t\t\t\t}\n// \t\t\t}\n// \t\t}\n\n// \t\t// At this point the path should be resolved to a full absolute path,\n// \t\t// but handle relative paths to be safe (might happen when process.cwd()\n// \t\t// fails)\n\n// \t\t// Normalize the tail path\n// \t\tresolvedTail = normalizeString(resolvedTail, !resolvedAbsolute, '\\\\',\n// \t\t\tisPathSeparator);\n\n// \t\treturn resolvedAbsolute ?\n// \t\t\t`${resolvedDevice}\\\\${resolvedTail}` :\n// \t\t\t`${resolvedDevice}${resolvedTail}` || '.';\n// \t},\n\n// \tnormalize(path: string): string {\n// \t\tvalidateString(path, 'path');\n// \t\tconst len = path.length;\n// \t\tif (len === 0) {\n// \t\t\treturn '.';\n// \t\t}\n// \t\tlet rootEnd = 0;\n// \t\tlet device;\n// \t\tlet isAbsolute = false;\n// \t\tconst code = path.charCodeAt(0);\n\n// \t\t// Try to match a root\n// \t\tif (len === 1) {\n// \t\t\t// `path` contains just a single char, exit early to avoid\n// \t\t\t// unnecessary work\n// \t\t\treturn isPosixPathSeparator(code) ? '\\\\' : path;\n// \t\t}\n// \t\tif (isPathSeparator(code)) {\n// \t\t\t// Possible UNC root\n\n// \t\t\t// If we started with a separator, we know we at least have an absolute\n// \t\t\t// path of some kind (UNC or otherwise)\n// \t\t\tisAbsolute = true;\n\n// \t\t\tif (isPathSeparator(path.charCodeAt(1))) {\n// \t\t\t\t// Matched double path separator at beginning\n// \t\t\t\tlet j = 2;\n// \t\t\t\tlet last = j;\n// \t\t\t\t// Match 1 or more non-path separators\n// \t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n// \t\t\t\t\tj++;\n// \t\t\t\t}\n// \t\t\t\tif (j < len && j !== last) {\n// \t\t\t\t\tconst firstPart = path.slice(last, j);\n// \t\t\t\t\t// Matched!\n// \t\t\t\t\tlast = j;\n// \t\t\t\t\t// Match 1 or more path separators\n// \t\t\t\t\twhile (j < len && isPathSeparator(path.charCodeAt(j))) {\n// \t\t\t\t\t\tj++;\n// \t\t\t\t\t}\n// \t\t\t\t\tif (j < len && j !== last) {\n// \t\t\t\t\t\t// Matched!\n// \t\t\t\t\t\tlast = j;\n// \t\t\t\t\t\t// Match 1 or more non-path separators\n// \t\t\t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n// \t\t\t\t\t\t\tj++;\n// \t\t\t\t\t\t}\n// \t\t\t\t\t\tif (j === len) {\n// \t\t\t\t\t\t\t// We matched a UNC root only\n// \t\t\t\t\t\t\t// Return the normalized version of the UNC root since there\n// \t\t\t\t\t\t\t// is nothing left to process\n// \t\t\t\t\t\t\treturn `\\\\\\\\${firstPart}\\\\${path.slice(last)}\\\\`;\n// \t\t\t\t\t\t}\n// \t\t\t\t\t\tif (j !== last) {\n// \t\t\t\t\t\t\t// We matched a UNC root with leftovers\n// \t\t\t\t\t\t\tdevice = `\\\\\\\\${firstPart}\\\\${path.slice(last, j)}`;\n// \t\t\t\t\t\t\trootEnd = j;\n// \t\t\t\t\t\t}\n// \t\t\t\t\t}\n// \t\t\t\t}\n// \t\t\t} else {\n// \t\t\t\trootEnd = 1;\n// \t\t\t}\n// \t\t} else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {\n// \t\t\t// Possible device root\n// \t\t\tdevice = path.slice(0, 2);\n// \t\t\trootEnd = 2;\n// \t\t\tif (len > 2 && isPathSeparator(path.charCodeAt(2))) {\n// \t\t\t\t// Treat separator following drive name as an absolute path\n// \t\t\t\t// indicator\n// \t\t\t\tisAbsolute = true;\n// \t\t\t\trootEnd = 3;\n// \t\t\t}\n// \t\t}\n\n// \t\tlet tail = rootEnd < len ?\n// \t\t\tnormalizeString(path.slice(rootEnd), !isAbsolute, '\\\\', isPathSeparator) :\n// \t\t\t'';\n// \t\tif (tail.length === 0 && !isAbsolute) {\n// \t\t\ttail = '.';\n// \t\t}\n// \t\tif (tail.length > 0 && isPathSeparator(path.charCodeAt(len - 1))) {\n// \t\t\ttail += '\\\\';\n// \t\t}\n// \t\tif (device === undefined) {\n// \t\t\treturn isAbsolute ? `\\\\${tail}` : tail;\n// \t\t}\n// \t\treturn isAbsolute ? `${device}\\\\${tail}` : `${device}${tail}`;\n// \t},\n\n// \tisAbsolute(path: string): boolean {\n// \t\tvalidateString(path, 'path');\n// \t\tconst len = path.length;\n// \t\tif (len === 0) {\n// \t\t\treturn false;\n// \t\t}\n\n// \t\tconst code = path.charCodeAt(0);\n// \t\treturn isPathSeparator(code) ||\n// \t\t\t// Possible device root\n// \t\t\tlen > 2 &&\n// \t\t\tisWindowsDeviceRoot(code) &&\n// \t\t\tpath.charCodeAt(1) === CHAR_COLON &&\n// \t\t\tisPathSeparator(path.charCodeAt(2));\n// \t},\n\n// \tjoin(...paths: string[]): string {\n// \t\tif (paths.length === 0) {\n// \t\t\treturn '.';\n// \t\t}\n\n// \t\tlet joined;\n// \t\tlet firstPart: string | undefined;\n// \t\tfor (let i = 0; i < paths.length; ++i) {\n// \t\t\tconst arg = paths[i];\n// \t\t\tvalidateString(arg, 'path');\n// \t\t\tif (arg.length > 0) {\n// \t\t\t\tif (joined === undefined) {\n// \t\t\t\t\tjoined = firstPart = arg;\n// \t\t\t\t}\n// \t\t\t\telse {\n// \t\t\t\t\tjoined += `\\\\${arg}`;\n// \t\t\t\t}\n// \t\t\t}\n// \t\t}\n\n// \t\tif (joined === undefined) {\n// \t\t\treturn '.';\n// \t\t}\n\n// \t\t// Make sure that the joined path doesn't start with two slashes, because\n// \t\t// normalize() will mistake it for an UNC path then.\n// \t\t//\n// \t\t// This step is skipped when it is very clear that the user actually\n// \t\t// intended to point at an UNC path. This is assumed when the first\n// \t\t// non-empty string arguments starts with exactly two slashes followed by\n// \t\t// at least one more non-slash character.\n// \t\t//\n// \t\t// Note that for normalize() to treat a path as an UNC path it needs to\n// \t\t// have at least 2 components, so we don't filter for that here.\n// \t\t// This means that the user can use join to construct UNC paths from\n// \t\t// a server name and a share name; for example:\n// \t\t//   path.join('//server', 'share') -> '\\\\\\\\server\\\\share\\\\')\n// \t\tlet needsReplace = true;\n// \t\tlet slashCount = 0;\n// \t\tif (typeof firstPart === 'string' && isPathSeparator(firstPart.charCodeAt(0))) {\n// \t\t\t++slashCount;\n// \t\t\tconst firstLen = firstPart.length;\n// \t\t\tif (firstLen > 1 && isPathSeparator(firstPart.charCodeAt(1))) {\n// \t\t\t\t++slashCount;\n// \t\t\t\tif (firstLen > 2) {\n// \t\t\t\t\tif (isPathSeparator(firstPart.charCodeAt(2))) {\n// \t\t\t\t\t\t++slashCount;\n// \t\t\t\t\t} else {\n// \t\t\t\t\t\t// We matched a UNC path in the first part\n// \t\t\t\t\t\tneedsReplace = false;\n// \t\t\t\t\t}\n// \t\t\t\t}\n// \t\t\t}\n// \t\t}\n// \t\tif (needsReplace) {\n// \t\t\t// Find any more consecutive slashes we need to replace\n// \t\t\twhile (slashCount < joined.length &&\n// \t\t\t\tisPathSeparator(joined.charCodeAt(slashCount))) {\n// \t\t\t\tslashCount++;\n// \t\t\t}\n\n// \t\t\t// Replace the slashes if needed\n// \t\t\tif (slashCount >= 2) {\n// \t\t\t\tjoined = `\\\\${joined.slice(slashCount)}`;\n// \t\t\t}\n// \t\t}\n\n// \t\treturn win32.normalize(joined);\n// \t},\n\n// \t// It will solve the relative path from `from` to `to`, for instance:\n// \t//  from = 'C:\\\\orandea\\\\test\\\\aaa'\n// \t//  to = 'C:\\\\orandea\\\\impl\\\\bbb'\n// \t// The output of the function should be: '..\\\\..\\\\impl\\\\bbb'\n// \trelative(from: string, to: string): string {\n// \t\tvalidateString(from, 'from');\n// \t\tvalidateString(to, 'to');\n\n// \t\tif (from === to) {\n// \t\t\treturn '';\n// \t\t}\n\n// \t\tconst fromOrig = win32.resolve(from);\n// \t\tconst toOrig = win32.resolve(to);\n\n// \t\tif (fromOrig === toOrig) {\n// \t\t\treturn '';\n// \t\t}\n\n// \t\tfrom = fromOrig.toLowerCase();\n// \t\tto = toOrig.toLowerCase();\n\n// \t\tif (from === to) {\n// \t\t\treturn '';\n// \t\t}\n\n// \t\t// Trim any leading backslashes\n// \t\tlet fromStart = 0;\n// \t\twhile (fromStart < from.length &&\n// \t\t\tfrom.charCodeAt(fromStart) === CHAR_BACKWARD_SLASH) {\n// \t\t\tfromStart++;\n// \t\t}\n// \t\t// Trim trailing backslashes (applicable to UNC paths only)\n// \t\tlet fromEnd = from.length;\n// \t\twhile (fromEnd - 1 > fromStart &&\n// \t\t\tfrom.charCodeAt(fromEnd - 1) === CHAR_BACKWARD_SLASH) {\n// \t\t\tfromEnd--;\n// \t\t}\n// \t\tconst fromLen = fromEnd - fromStart;\n\n// \t\t// Trim any leading backslashes\n// \t\tlet toStart = 0;\n// \t\twhile (toStart < to.length &&\n// \t\t\tto.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {\n// \t\t\ttoStart++;\n// \t\t}\n// \t\t// Trim trailing backslashes (applicable to UNC paths only)\n// \t\tlet toEnd = to.length;\n// \t\twhile (toEnd - 1 > toStart &&\n// \t\t\tto.charCodeAt(toEnd - 1) === CHAR_BACKWARD_SLASH) {\n// \t\t\ttoEnd--;\n// \t\t}\n// \t\tconst toLen = toEnd - toStart;\n\n// \t\t// Compare paths to find the longest common path from root\n// \t\tconst length = fromLen < toLen ? fromLen : toLen;\n// \t\tlet lastCommonSep = -1;\n// \t\tlet i = 0;\n// \t\tfor (; i < length; i++) {\n// \t\t\tconst fromCode = from.charCodeAt(fromStart + i);\n// \t\t\tif (fromCode !== to.charCodeAt(toStart + i)) {\n// \t\t\t\tbreak;\n// \t\t\t} else if (fromCode === CHAR_BACKWARD_SLASH) {\n// \t\t\t\tlastCommonSep = i;\n// \t\t\t}\n// \t\t}\n\n// \t\t// We found a mismatch before the first common path separator was seen, so\n// \t\t// return the original `to`.\n// \t\tif (i !== length) {\n// \t\t\tif (lastCommonSep === -1) {\n// \t\t\t\treturn toOrig;\n// \t\t\t}\n// \t\t} else {\n// \t\t\tif (toLen > length) {\n// \t\t\t\tif (to.charCodeAt(toStart + i) === CHAR_BACKWARD_SLASH) {\n// \t\t\t\t\t// We get here if `from` is the exact base path for `to`.\n// \t\t\t\t\t// For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo\\\\bar\\\\baz'\n// \t\t\t\t\treturn toOrig.slice(toStart + i + 1);\n// \t\t\t\t}\n// \t\t\t\tif (i === 2) {\n// \t\t\t\t\t// We get here if `from` is the device root.\n// \t\t\t\t\t// For example: from='C:\\\\'; to='C:\\\\foo'\n// \t\t\t\t\treturn toOrig.slice(toStart + i);\n// \t\t\t\t}\n// \t\t\t}\n// \t\t\tif (fromLen > length) {\n// \t\t\t\tif (from.charCodeAt(fromStart + i) === CHAR_BACKWARD_SLASH) {\n// \t\t\t\t\t// We get here if `to` is the exact base path for `from`.\n// \t\t\t\t\t// For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo'\n// \t\t\t\t\tlastCommonSep = i;\n// \t\t\t\t} else if (i === 2) {\n// \t\t\t\t\t// We get here if `to` is the device root.\n// \t\t\t\t\t// For example: from='C:\\\\foo\\\\bar'; to='C:\\\\'\n// \t\t\t\t\tlastCommonSep = 3;\n// \t\t\t\t}\n// \t\t\t}\n// \t\t\tif (lastCommonSep === -1) {\n// \t\t\t\tlastCommonSep = 0;\n// \t\t\t}\n// \t\t}\n\n// \t\tlet out = '';\n// \t\t// Generate the relative path based on the path difference between `to` and\n// \t\t// `from`\n// \t\tfor (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n// \t\t\tif (i === fromEnd || from.charCodeAt(i) === CHAR_BACKWARD_SLASH) {\n// \t\t\t\tout += out.length === 0 ? '..' : '\\\\..';\n// \t\t\t}\n// \t\t}\n\n// \t\ttoStart += lastCommonSep;\n\n// \t\t// Lastly, append the rest of the destination (`to`) path that comes after\n// \t\t// the common path parts\n// \t\tif (out.length > 0) {\n// \t\t\treturn `${out}${toOrig.slice(toStart, toEnd)}`;\n// \t\t}\n\n// \t\tif (toOrig.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {\n// \t\t\t++toStart;\n// \t\t}\n\n// \t\treturn toOrig.slice(toStart, toEnd);\n// \t},\n\n// \ttoNamespacedPath(path: string): string {\n// \t\t// Note: this will *probably* throw somewhere.\n// \t\tif (typeof path !== 'string') {\n// \t\t\treturn path;\n// \t\t}\n\n// \t\tif (path.length === 0) {\n// \t\t\treturn '';\n// \t\t}\n\n// \t\tconst resolvedPath = win32.resolve(path);\n\n// \t\tif (resolvedPath.length <= 2) {\n// \t\t\treturn path;\n// \t\t}\n\n// \t\tif (resolvedPath.charCodeAt(0) === CHAR_BACKWARD_SLASH) {\n// \t\t\t// Possible UNC root\n// \t\t\tif (resolvedPath.charCodeAt(1) === CHAR_BACKWARD_SLASH) {\n// \t\t\t\tconst code = resolvedPath.charCodeAt(2);\n// \t\t\t\tif (code !== CHAR_QUESTION_MARK && code !== CHAR_DOT) {\n// \t\t\t\t\t// Matched non-long UNC root, convert the path to a long UNC path\n// \t\t\t\t\treturn `\\\\\\\\?\\\\UNC\\\\${resolvedPath.slice(2)}`;\n// \t\t\t\t}\n// \t\t\t}\n// \t\t} else if (isWindowsDeviceRoot(resolvedPath.charCodeAt(0)) &&\n// \t\t\tresolvedPath.charCodeAt(1) === CHAR_COLON &&\n// \t\t\tresolvedPath.charCodeAt(2) === CHAR_BACKWARD_SLASH) {\n// \t\t\t// Matched device root, convert the path to a long UNC path\n// \t\t\treturn `\\\\\\\\?\\\\${resolvedPath}`;\n// \t\t}\n\n// \t\treturn path;\n// \t},\n\n// \tdirname(path: string): string {\n// \t\tvalidateString(path, 'path');\n// \t\tconst len = path.length;\n// \t\tif (len === 0) {\n// \t\t\treturn '.';\n// \t\t}\n// \t\tlet rootEnd = -1;\n// \t\tlet offset = 0;\n// \t\tconst code = path.charCodeAt(0);\n\n// \t\tif (len === 1) {\n// \t\t\t// `path` contains just a path separator, exit early to avoid\n// \t\t\t// unnecessary work or a dot.\n// \t\t\treturn isPathSeparator(code) ? path : '.';\n// \t\t}\n\n// \t\t// Try to match a root\n// \t\tif (isPathSeparator(code)) {\n// \t\t\t// Possible UNC root\n\n// \t\t\trootEnd = offset = 1;\n\n// \t\t\tif (isPathSeparator(path.charCodeAt(1))) {\n// \t\t\t\t// Matched double path separator at beginning\n// \t\t\t\tlet j = 2;\n// \t\t\t\tlet last = j;\n// \t\t\t\t// Match 1 or more non-path separators\n// \t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n// \t\t\t\t\tj++;\n// \t\t\t\t}\n// \t\t\t\tif (j < len && j !== last) {\n// \t\t\t\t\t// Matched!\n// \t\t\t\t\tlast = j;\n// \t\t\t\t\t// Match 1 or more path separators\n// \t\t\t\t\twhile (j < len && isPathSeparator(path.charCodeAt(j))) {\n// \t\t\t\t\t\tj++;\n// \t\t\t\t\t}\n// \t\t\t\t\tif (j < len && j !== last) {\n// \t\t\t\t\t\t// Matched!\n// \t\t\t\t\t\tlast = j;\n// \t\t\t\t\t\t// Match 1 or more non-path separators\n// \t\t\t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n// \t\t\t\t\t\t\tj++;\n// \t\t\t\t\t\t}\n// \t\t\t\t\t\tif (j === len) {\n// \t\t\t\t\t\t\t// We matched a UNC root only\n// \t\t\t\t\t\t\treturn path;\n// \t\t\t\t\t\t}\n// \t\t\t\t\t\tif (j !== last) {\n// \t\t\t\t\t\t\t// We matched a UNC root with leftovers\n\n// \t\t\t\t\t\t\t// Offset by 1 to include the separator after the UNC root to\n// \t\t\t\t\t\t\t// treat it as a \"normal root\" on top of a (UNC) root\n// \t\t\t\t\t\t\trootEnd = offset = j + 1;\n// \t\t\t\t\t\t}\n// \t\t\t\t\t}\n// \t\t\t\t}\n// \t\t\t}\n// \t\t\t// Possible device root\n// \t\t} else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {\n// \t\t\trootEnd = len > 2 && isPathSeparator(path.charCodeAt(2)) ? 3 : 2;\n// \t\t\toffset = rootEnd;\n// \t\t}\n\n// \t\tlet end = -1;\n// \t\tlet matchedSlash = true;\n// \t\tfor (let i = len - 1; i >= offset; --i) {\n// \t\t\tif (isPathSeparator(path.charCodeAt(i))) {\n// \t\t\t\tif (!matchedSlash) {\n// \t\t\t\t\tend = i;\n// \t\t\t\t\tbreak;\n// \t\t\t\t}\n// \t\t\t} else {\n// \t\t\t\t// We saw the first non-path separator\n// \t\t\t\tmatchedSlash = false;\n// \t\t\t}\n// \t\t}\n\n// \t\tif (end === -1) {\n// \t\t\tif (rootEnd === -1) {\n// \t\t\t\treturn '.';\n// \t\t\t}\n\n// \t\t\tend = rootEnd;\n// \t\t}\n// \t\treturn path.slice(0, end);\n// \t},\n\n// \tbasename(path: string, ext?: string): string {\n// \t\tif (ext !== undefined) {\n// \t\t\tvalidateString(ext, 'ext');\n// \t\t}\n// \t\tvalidateString(path, 'path');\n// \t\tlet start = 0;\n// \t\tlet end = -1;\n// \t\tlet matchedSlash = true;\n// \t\tlet i;\n\n// \t\t// Check for a drive letter prefix so as not to mistake the following\n// \t\t// path separator as an extra separator at the end of the path that can be\n// \t\t// disregarded\n// \t\tif (path.length >= 2 &&\n// \t\t\tisWindowsDeviceRoot(path.charCodeAt(0)) &&\n// \t\t\tpath.charCodeAt(1) === CHAR_COLON) {\n// \t\t\tstart = 2;\n// \t\t}\n\n// \t\tif (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n// \t\t\tif (ext === path) {\n// \t\t\t\treturn '';\n// \t\t\t}\n// \t\t\tlet extIdx = ext.length - 1;\n// \t\t\tlet firstNonSlashEnd = -1;\n// \t\t\tfor (i = path.length - 1; i >= start; --i) {\n// \t\t\t\tconst code = path.charCodeAt(i);\n// \t\t\t\tif (isPathSeparator(code)) {\n// \t\t\t\t\t// If we reached a path separator that was not part of a set of path\n// \t\t\t\t\t// separators at the end of the string, stop now\n// \t\t\t\t\tif (!matchedSlash) {\n// \t\t\t\t\t\tstart = i + 1;\n// \t\t\t\t\t\tbreak;\n// \t\t\t\t\t}\n// \t\t\t\t} else {\n// \t\t\t\t\tif (firstNonSlashEnd === -1) {\n// \t\t\t\t\t\t// We saw the first non-path separator, remember this index in case\n// \t\t\t\t\t\t// we need it if the extension ends up not matching\n// \t\t\t\t\t\tmatchedSlash = false;\n// \t\t\t\t\t\tfirstNonSlashEnd = i + 1;\n// \t\t\t\t\t}\n// \t\t\t\t\tif (extIdx >= 0) {\n// \t\t\t\t\t\t// Try to match the explicit extension\n// \t\t\t\t\t\tif (code === ext.charCodeAt(extIdx)) {\n// \t\t\t\t\t\t\tif (--extIdx === -1) {\n// \t\t\t\t\t\t\t\t// We matched the extension, so mark this as the end of our path\n// \t\t\t\t\t\t\t\t// component\n// \t\t\t\t\t\t\t\tend = i;\n// \t\t\t\t\t\t\t}\n// \t\t\t\t\t\t} else {\n// \t\t\t\t\t\t\t// Extension does not match, so our result is the entire path\n// \t\t\t\t\t\t\t// component\n// \t\t\t\t\t\t\textIdx = -1;\n// \t\t\t\t\t\t\tend = firstNonSlashEnd;\n// \t\t\t\t\t\t}\n// \t\t\t\t\t}\n// \t\t\t\t}\n// \t\t\t}\n\n// \t\t\tif (start === end) {\n// \t\t\t\tend = firstNonSlashEnd;\n// \t\t\t} else if (end === -1) {\n// \t\t\t\tend = path.length;\n// \t\t\t}\n// \t\t\treturn path.slice(start, end);\n// \t\t}\n// \t\tfor (i = path.length - 1; i >= start; --i) {\n// \t\t\tif (isPathSeparator(path.charCodeAt(i))) {\n// \t\t\t\t// If we reached a path separator that was not part of a set of path\n// \t\t\t\t// separators at the end of the string, stop now\n// \t\t\t\tif (!matchedSlash) {\n// \t\t\t\t\tstart = i + 1;\n// \t\t\t\t\tbreak;\n// \t\t\t\t}\n// \t\t\t} else if (end === -1) {\n// \t\t\t\t// We saw the first non-path separator, mark this as the end of our\n// \t\t\t\t// path component\n// \t\t\t\tmatchedSlash = false;\n// \t\t\t\tend = i + 1;\n// \t\t\t}\n// \t\t}\n\n// \t\tif (end === -1) {\n// \t\t\treturn '';\n// \t\t}\n// \t\treturn path.slice(start, end);\n// \t},\n\n// \textname(path: string): string {\n// \t\tvalidateString(path, 'path');\n// \t\tlet start = 0;\n// \t\tlet startDot = -1;\n// \t\tlet startPart = 0;\n// \t\tlet end = -1;\n// \t\tlet matchedSlash = true;\n// \t\t// Track the state of characters (if any) we see before our first dot and\n// \t\t// after any path separator we find\n// \t\tlet preDotState = 0;\n\n// \t\t// Check for a drive letter prefix so as not to mistake the following\n// \t\t// path separator as an extra separator at the end of the path that can be\n// \t\t// disregarded\n\n// \t\tif (path.length >= 2 &&\n// \t\t\tpath.charCodeAt(1) === CHAR_COLON &&\n// \t\t\tisWindowsDeviceRoot(path.charCodeAt(0))) {\n// \t\t\tstart = startPart = 2;\n// \t\t}\n\n// \t\tfor (let i = path.length - 1; i >= start; --i) {\n// \t\t\tconst code = path.charCodeAt(i);\n// \t\t\tif (isPathSeparator(code)) {\n// \t\t\t\t// If we reached a path separator that was not part of a set of path\n// \t\t\t\t// separators at the end of the string, stop now\n// \t\t\t\tif (!matchedSlash) {\n// \t\t\t\t\tstartPart = i + 1;\n// \t\t\t\t\tbreak;\n// \t\t\t\t}\n// \t\t\t\tcontinue;\n// \t\t\t}\n// \t\t\tif (end === -1) {\n// \t\t\t\t// We saw the first non-path separator, mark this as the end of our\n// \t\t\t\t// extension\n// \t\t\t\tmatchedSlash = false;\n// \t\t\t\tend = i + 1;\n// \t\t\t}\n// \t\t\tif (code === CHAR_DOT) {\n// \t\t\t\t// If this is our first dot, mark it as the start of our extension\n// \t\t\t\tif (startDot === -1) {\n// \t\t\t\t\tstartDot = i;\n// \t\t\t\t}\n// \t\t\t\telse if (preDotState !== 1) {\n// \t\t\t\t\tpreDotState = 1;\n// \t\t\t\t}\n// \t\t\t} else if (startDot !== -1) {\n// \t\t\t\t// We saw a non-dot and non-path separator before our dot, so we should\n// \t\t\t\t// have a good chance at having a non-empty extension\n// \t\t\t\tpreDotState = -1;\n// \t\t\t}\n// \t\t}\n\n// \t\tif (startDot === -1 ||\n// \t\t\tend === -1 ||\n// \t\t\t// We saw a non-dot character immediately before the dot\n// \t\t\tpreDotState === 0 ||\n// \t\t\t// The (right-most) trimmed path component is exactly '..'\n// \t\t\t(preDotState === 1 &&\n// \t\t\t\tstartDot === end - 1 &&\n// \t\t\t\tstartDot === startPart + 1)) {\n// \t\t\treturn '';\n// \t\t}\n// \t\treturn path.slice(startDot, end);\n// \t},\n\n// \tformat: _format.bind(null, '\\\\'),\n\n// \tparse(path) {\n// \t\tvalidateString(path, 'path');\n\n// \t\tconst ret = { root: '', dir: '', base: '', ext: '', name: '' };\n// \t\tif (path.length === 0) {\n// \t\t\treturn ret;\n// \t\t}\n\n// \t\tconst len = path.length;\n// \t\tlet rootEnd = 0;\n// \t\tlet code = path.charCodeAt(0);\n\n// \t\tif (len === 1) {\n// \t\t\tif (isPathSeparator(code)) {\n// \t\t\t\t// `path` contains just a path separator, exit early to avoid\n// \t\t\t\t// unnecessary work\n// \t\t\t\tret.root = ret.dir = path;\n// \t\t\t\treturn ret;\n// \t\t\t}\n// \t\t\tret.base = ret.name = path;\n// \t\t\treturn ret;\n// \t\t}\n// \t\t// Try to match a root\n// \t\tif (isPathSeparator(code)) {\n// \t\t\t// Possible UNC root\n\n// \t\t\trootEnd = 1;\n// \t\t\tif (isPathSeparator(path.charCodeAt(1))) {\n// \t\t\t\t// Matched double path separator at beginning\n// \t\t\t\tlet j = 2;\n// \t\t\t\tlet last = j;\n// \t\t\t\t// Match 1 or more non-path separators\n// \t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n// \t\t\t\t\tj++;\n// \t\t\t\t}\n// \t\t\t\tif (j < len && j !== last) {\n// \t\t\t\t\t// Matched!\n// \t\t\t\t\tlast = j;\n// \t\t\t\t\t// Match 1 or more path separators\n// \t\t\t\t\twhile (j < len && isPathSeparator(path.charCodeAt(j))) {\n// \t\t\t\t\t\tj++;\n// \t\t\t\t\t}\n// \t\t\t\t\tif (j < len && j !== last) {\n// \t\t\t\t\t\t// Matched!\n// \t\t\t\t\t\tlast = j;\n// \t\t\t\t\t\t// Match 1 or more non-path separators\n// \t\t\t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n// \t\t\t\t\t\t\tj++;\n// \t\t\t\t\t\t}\n// \t\t\t\t\t\tif (j === len) {\n// \t\t\t\t\t\t\t// We matched a UNC root only\n// \t\t\t\t\t\t\trootEnd = j;\n// \t\t\t\t\t\t} else if (j !== last) {\n// \t\t\t\t\t\t\t// We matched a UNC root with leftovers\n// \t\t\t\t\t\t\trootEnd = j + 1;\n// \t\t\t\t\t\t}\n// \t\t\t\t\t}\n// \t\t\t\t}\n// \t\t\t}\n// \t\t} else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {\n// \t\t\t// Possible device root\n// \t\t\tif (len <= 2) {\n// \t\t\t\t// `path` contains just a drive root, exit early to avoid\n// \t\t\t\t// unnecessary work\n// \t\t\t\tret.root = ret.dir = path;\n// \t\t\t\treturn ret;\n// \t\t\t}\n// \t\t\trootEnd = 2;\n// \t\t\tif (isPathSeparator(path.charCodeAt(2))) {\n// \t\t\t\tif (len === 3) {\n// \t\t\t\t\t// `path` contains just a drive root, exit early to avoid\n// \t\t\t\t\t// unnecessary work\n// \t\t\t\t\tret.root = ret.dir = path;\n// \t\t\t\t\treturn ret;\n// \t\t\t\t}\n// \t\t\t\trootEnd = 3;\n// \t\t\t}\n// \t\t}\n// \t\tif (rootEnd > 0) {\n// \t\t\tret.root = path.slice(0, rootEnd);\n// \t\t}\n\n// \t\tlet startDot = -1;\n// \t\tlet startPart = rootEnd;\n// \t\tlet end = -1;\n// \t\tlet matchedSlash = true;\n// \t\tlet i = path.length - 1;\n\n// \t\t// Track the state of characters (if any) we see before our first dot and\n// \t\t// after any path separator we find\n// \t\tlet preDotState = 0;\n\n// \t\t// Get non-dir info\n// \t\tfor (; i >= rootEnd; --i) {\n// \t\t\tcode = path.charCodeAt(i);\n// \t\t\tif (isPathSeparator(code)) {\n// \t\t\t\t// If we reached a path separator that was not part of a set of path\n// \t\t\t\t// separators at the end of the string, stop now\n// \t\t\t\tif (!matchedSlash) {\n// \t\t\t\t\tstartPart = i + 1;\n// \t\t\t\t\tbreak;\n// \t\t\t\t}\n// \t\t\t\tcontinue;\n// \t\t\t}\n// \t\t\tif (end === -1) {\n// \t\t\t\t// We saw the first non-path separator, mark this as the end of our\n// \t\t\t\t// extension\n// \t\t\t\tmatchedSlash = false;\n// \t\t\t\tend = i + 1;\n// \t\t\t}\n// \t\t\tif (code === CHAR_DOT) {\n// \t\t\t\t// If this is our first dot, mark it as the start of our extension\n// \t\t\t\tif (startDot === -1) {\n// \t\t\t\t\tstartDot = i;\n// \t\t\t\t} else if (preDotState !== 1) {\n// \t\t\t\t\tpreDotState = 1;\n// \t\t\t\t}\n// \t\t\t} else if (startDot !== -1) {\n// \t\t\t\t// We saw a non-dot and non-path separator before our dot, so we should\n// \t\t\t\t// have a good chance at having a non-empty extension\n// \t\t\t\tpreDotState = -1;\n// \t\t\t}\n// \t\t}\n\n// \t\tif (end !== -1) {\n// \t\t\tif (startDot === -1 ||\n// \t\t\t\t// We saw a non-dot character immediately before the dot\n// \t\t\t\tpreDotState === 0 ||\n// \t\t\t\t// The (right-most) trimmed path component is exactly '..'\n// \t\t\t\t(preDotState === 1 &&\n// \t\t\t\t\tstartDot === end - 1 &&\n// \t\t\t\t\tstartDot === startPart + 1)) {\n// \t\t\t\tret.base = ret.name = path.slice(startPart, end);\n// \t\t\t} else {\n// \t\t\t\tret.name = path.slice(startPart, startDot);\n// \t\t\t\tret.base = path.slice(startPart, end);\n// \t\t\t\tret.ext = path.slice(startDot, end);\n// \t\t\t}\n// \t\t}\n\n// \t\t// If the directory is the root, use the entire root as the `dir` including\n// \t\t// the trailing slash if any (`C:\\abc` -> `C:\\`). Otherwise, strip out the\n// \t\t// trailing slash (`C:\\abc\\def` -> `C:\\abc`).\n// \t\tif (startPart > 0 && startPart !== rootEnd) {\n// \t\t\tret.dir = path.slice(0, startPart - 1);\n// \t\t} else {\n// \t\t\tret.dir = ret.root;\n// \t\t}\n\n// \t\treturn ret;\n// \t},\n\n// \tsep: '\\\\',\n// \tdelimiter: ';',\n// \twin32: null,\n// \tposix: null\n// };\n\nexport const posix: IPath = {\n  // path.resolve([from ...], to)\n  resolve(...pathSegments: string[]): string {\n    let resolvedPath = '';\n    let resolvedAbsolute = false;\n\n    for (let i = pathSegments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n      const path = i >= 0 ? pathSegments[i] : process.cwd();\n\n      validateString(path, 'path');\n\n      // Skip empty entries\n      if (path.length === 0) {\n        continue;\n      }\n\n      resolvedPath = `${path}/${resolvedPath}`;\n      resolvedAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n    }\n\n    // At this point the path should be resolved to a full absolute path, but\n    // handle relative paths to be safe (might happen when process.cwd() fails)\n\n    // Normalize the path\n    resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute, '/', isPosixPathSeparator);\n\n    if (resolvedAbsolute) {\n      return `/${resolvedPath}`;\n    }\n    return resolvedPath.length > 0 ? resolvedPath : '.';\n  },\n\n  normalize(path: string): string {\n    validateString(path, 'path');\n\n    if (path.length === 0) {\n      return '.';\n    }\n\n    const isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n    const trailingSeparator = path.charCodeAt(path.length - 1) === CHAR_FORWARD_SLASH;\n\n    // Normalize the path\n    path = normalizeString(path, !isAbsolute, '/', isPosixPathSeparator);\n\n    if (path.length === 0) {\n      if (isAbsolute) {\n        return '/';\n      }\n      return trailingSeparator ? './' : '.';\n    }\n    if (trailingSeparator) {\n      path += '/';\n    }\n\n    return isAbsolute ? `/${path}` : path;\n  },\n\n  isAbsolute(path: string): boolean {\n    validateString(path, 'path');\n    return path.length > 0 && path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n  },\n\n  join(...paths: string[]): string {\n    if (paths.length === 0) {\n      return '.';\n    }\n    let joined;\n    for (let i = 0; i < paths.length; ++i) {\n      const arg = paths[i];\n      validateString(arg, 'path');\n      if (arg.length > 0) {\n        if (joined === undefined) {\n          joined = arg;\n        } else {\n          joined += `/${arg}`;\n        }\n      }\n    }\n    if (joined === undefined) {\n      return '.';\n    }\n    return posix.normalize(joined);\n  },\n\n  relative(from: string, to: string): string {\n    validateString(from, 'from');\n    validateString(to, 'to');\n\n    if (from === to) {\n      return '';\n    }\n\n    // Trim leading forward slashes.\n    from = posix.resolve(from);\n    to = posix.resolve(to);\n\n    if (from === to) {\n      return '';\n    }\n\n    const fromStart = 1;\n    const fromEnd = from.length;\n    const fromLen = fromEnd - fromStart;\n    const toStart = 1;\n    const toLen = to.length - toStart;\n\n    // Compare paths to find the longest common path from root\n    const length = fromLen < toLen ? fromLen : toLen;\n    let lastCommonSep = -1;\n    let i = 0;\n    for (; i < length; i++) {\n      const fromCode = from.charCodeAt(fromStart + i);\n      if (fromCode !== to.charCodeAt(toStart + i)) {\n        break;\n      } else if (fromCode === CHAR_FORWARD_SLASH) {\n        lastCommonSep = i;\n      }\n    }\n    if (i === length) {\n      if (toLen > length) {\n        if (to.charCodeAt(toStart + i) === CHAR_FORWARD_SLASH) {\n          // We get here if `from` is the exact base path for `to`.\n          // For example: from='/foo/bar'; to='/foo/bar/baz'\n          return to.slice(toStart + i + 1);\n        }\n        if (i === 0) {\n          // We get here if `from` is the root\n          // For example: from='/'; to='/foo'\n          return to.slice(toStart + i);\n        }\n      } else if (fromLen > length) {\n        if (from.charCodeAt(fromStart + i) === CHAR_FORWARD_SLASH) {\n          // We get here if `to` is the exact base path for `from`.\n          // For example: from='/foo/bar/baz'; to='/foo/bar'\n          lastCommonSep = i;\n        } else if (i === 0) {\n          // We get here if `to` is the root.\n          // For example: from='/foo/bar'; to='/'\n          lastCommonSep = 0;\n        }\n      }\n    }\n\n    let out = '';\n    // Generate the relative path based on the path difference between `to`\n    // and `from`.\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n      if (i === fromEnd || from.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n        out += out.length === 0 ? '..' : '/..';\n      }\n    }\n\n    // Lastly, append the rest of the destination (`to`) path that comes after\n    // the common path parts.\n    return `${out}${to.slice(toStart + lastCommonSep)}`;\n  },\n\n  toNamespacedPath(path: string): string {\n    // Non-op on posix systems\n    return path;\n  },\n\n  dirname(path: string): string {\n    validateString(path, 'path');\n    if (path.length === 0) {\n      return '.';\n    }\n    const hasRoot = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n    let end = -1;\n    let matchedSlash = true;\n    for (let i = path.length - 1; i >= 1; --i) {\n      if (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n        if (!matchedSlash) {\n          end = i;\n          break;\n        }\n      } else {\n        // We saw the first non-path separator\n        matchedSlash = false;\n      }\n    }\n\n    if (end === -1) {\n      return hasRoot ? '/' : '.';\n    }\n    if (hasRoot && end === 1) {\n      return '//';\n    }\n    return path.slice(0, end);\n  },\n\n  basename(path: string, ext?: string): string {\n    if (ext !== undefined) {\n      validateString(ext, 'ext');\n    }\n    validateString(path, 'path');\n\n    let start = 0;\n    let end = -1;\n    let matchedSlash = true;\n    let i;\n\n    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n      if (ext === path) {\n        return '';\n      }\n      let extIdx = ext.length - 1;\n      let firstNonSlashEnd = -1;\n      for (i = path.length - 1; i >= 0; --i) {\n        const code = path.charCodeAt(i);\n        if (code === CHAR_FORWARD_SLASH) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            start = i + 1;\n            break;\n          }\n        } else {\n          if (firstNonSlashEnd === -1) {\n            // We saw the first non-path separator, remember this index in case\n            // we need it if the extension ends up not matching\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            // Try to match the explicit extension\n            if (code === ext.charCodeAt(extIdx)) {\n              if (--extIdx === -1) {\n                // We matched the extension, so mark this as the end of our path\n                // component\n                end = i;\n              }\n            } else {\n              // Extension does not match, so our result is the entire path\n              // component\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n\n      if (start === end) {\n        end = firstNonSlashEnd;\n      } else if (end === -1) {\n        end = path.length;\n      }\n      return path.slice(start, end);\n    }\n    for (i = path.length - 1; i >= 0; --i) {\n      if (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          start = i + 1;\n          break;\n        }\n      } else if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // path component\n        matchedSlash = false;\n        end = i + 1;\n      }\n    }\n\n    if (end === -1) {\n      return '';\n    }\n    return path.slice(start, end);\n  },\n\n  extname(path: string): string {\n    validateString(path, 'path');\n    let startDot = -1;\n    let startPart = 0;\n    let end = -1;\n    let matchedSlash = true;\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    let preDotState = 0;\n    for (let i = path.length - 1; i >= 0; --i) {\n      const code = path.charCodeAt(i);\n      if (code === CHAR_FORWARD_SLASH) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === CHAR_DOT) {\n        // If this is our first dot, mark it as the start of our extension\n        if (startDot === -1) {\n          startDot = i;\n        } else if (preDotState !== 1) {\n          preDotState = 1;\n        }\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (\n      startDot === -1 ||\n      end === -1 ||\n      // We saw a non-dot character immediately before the dot\n      preDotState === 0 ||\n      // The (right-most) trimmed path component is exactly '..'\n      (preDotState === 1 && startDot === end - 1 && startDot === startPart + 1)\n    ) {\n      return '';\n    }\n    return path.slice(startDot, end);\n  },\n\n  format: _format.bind(null, '/'),\n\n  parse(path: string): ParsedPath {\n    validateString(path, 'path');\n\n    const ret = { root: '', dir: '', base: '', ext: '', name: '' };\n    if (path.length === 0) {\n      return ret;\n    }\n    const isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n    let start;\n    if (isAbsolute) {\n      ret.root = '/';\n      start = 1;\n    } else {\n      start = 0;\n    }\n    let startDot = -1;\n    let startPart = 0;\n    let end = -1;\n    let matchedSlash = true;\n    let i = path.length - 1;\n\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    let preDotState = 0;\n\n    // Get non-dir info\n    for (; i >= start; --i) {\n      const code = path.charCodeAt(i);\n      if (code === CHAR_FORWARD_SLASH) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === CHAR_DOT) {\n        // If this is our first dot, mark it as the start of our extension\n        if (startDot === -1) {\n          startDot = i;\n        } else if (preDotState !== 1) {\n          preDotState = 1;\n        }\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (end !== -1) {\n      const start = startPart === 0 && isAbsolute ? 1 : startPart;\n      if (\n        startDot === -1 ||\n        // We saw a non-dot character immediately before the dot\n        preDotState === 0 ||\n        // The (right-most) trimmed path component is exactly '..'\n        (preDotState === 1 && startDot === end - 1 && startDot === startPart + 1)\n      ) {\n        ret.base = ret.name = path.slice(start, end);\n      } else {\n        ret.name = path.slice(start, startDot);\n        ret.base = path.slice(start, end);\n        ret.ext = path.slice(startDot, end);\n      }\n    }\n\n    if (startPart > 0) {\n      ret.dir = path.slice(0, startPart - 1);\n    } else if (isAbsolute) {\n      ret.dir = '/';\n    }\n\n    return ret;\n  },\n\n  sep: '/',\n  delimiter: ':',\n  win32: null,\n  posix: null,\n};\n\nexport const normalize = posix.normalize;\nexport const isAbsolute = posix.isAbsolute;\nexport const join = posix.join;\nexport const resolve = posix.resolve;\nexport const relative = posix.relative;\nexport const dirname = posix.dirname;\nexport const basename = posix.basename;\nexport const extname = posix.extname;\nexport const format = posix.format;\nexport const parse = posix.parse;\nexport const toNamespacedPath = posix.toNamespacedPath;\nexport const sep = posix.sep;\nexport const delimiter = posix.delimiter;\n", "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n// Names from https://blog.codinghorror.com/ascii-pronunciation-rules-for-programmers/\n\n/**\n * An inlined enum containing useful character codes (to be used with String.charCodeAt).\n * Please leave the const keyword such that it gets inlined when compiled to JavaScript!\n */\nexport const enum CharCode {\n  Null = 0,\n  /**\n   * The `\\b` character.\n   */\n  Backspace = 8,\n  /**\n   * The `\\t` character.\n   */\n  Tab = 9,\n  /**\n   * The `\\n` character.\n   */\n  LineFeed = 10,\n  /**\n   * The `\\r` character.\n   */\n  CarriageReturn = 13,\n  Space = 32,\n  /**\n   * The `!` character.\n   */\n  ExclamationMark = 33,\n  /**\n   * The `\"` character.\n   */\n  DoubleQuote = 34,\n  /**\n   * The `#` character.\n   */\n  Hash = 35,\n  /**\n   * The `$` character.\n   */\n  DollarSign = 36,\n  /**\n   * The `%` character.\n   */\n  PercentSign = 37,\n  /**\n   * The `&` character.\n   */\n  Ampersand = 38,\n  /**\n   * The `'` character.\n   */\n  SingleQuote = 39,\n  /**\n   * The `(` character.\n   */\n  OpenParen = 40,\n  /**\n   * The `)` character.\n   */\n  CloseParen = 41,\n  /**\n   * The `*` character.\n   */\n  Asterisk = 42,\n  /**\n   * The `+` character.\n   */\n  Plus = 43,\n  /**\n   * The `,` character.\n   */\n  Comma = 44,\n  /**\n   * The `-` character.\n   */\n  Dash = 45,\n  /**\n   * The `.` character.\n   */\n  Period = 46,\n  /**\n   * The `/` character.\n   */\n  Slash = 47,\n\n  Digit0 = 48,\n  Digit1 = 49,\n  Digit2 = 50,\n  Digit3 = 51,\n  Digit4 = 52,\n  Digit5 = 53,\n  Digit6 = 54,\n  Digit7 = 55,\n  Digit8 = 56,\n  Digit9 = 57,\n\n  /**\n   * The `:` character.\n   */\n  Colon = 58,\n  /**\n   * The `;` character.\n   */\n  Semicolon = 59,\n  /**\n   * The `<` character.\n   */\n  LessThan = 60,\n  /**\n   * The `=` character.\n   */\n  Equals = 61,\n  /**\n   * The `>` character.\n   */\n  GreaterThan = 62,\n  /**\n   * The `?` character.\n   */\n  QuestionMark = 63,\n  /**\n   * The `@` character.\n   */\n  AtSign = 64,\n\n  A = 65,\n  B = 66,\n  C = 67,\n  D = 68,\n  E = 69,\n  F = 70,\n  G = 71,\n  H = 72,\n  I = 73,\n  J = 74,\n  K = 75,\n  L = 76,\n  M = 77,\n  N = 78,\n  O = 79,\n  P = 80,\n  Q = 81,\n  R = 82,\n  S = 83,\n  T = 84,\n  U = 85,\n  V = 86,\n  W = 87,\n  X = 88,\n  Y = 89,\n  Z = 90,\n\n  /**\n   * The `[` character.\n   */\n  OpenSquareBracket = 91,\n  /**\n   * The `\\` character.\n   */\n  Backslash = 92,\n  /**\n   * The `]` character.\n   */\n  CloseSquareBracket = 93,\n  /**\n   * The `^` character.\n   */\n  Caret = 94,\n  /**\n   * The `_` character.\n   */\n  Underline = 95,\n  /**\n   * The ``(`)`` character.\n   */\n  BackTick = 96,\n\n  a = 97,\n  b = 98,\n  c = 99,\n  d = 100,\n  e = 101,\n  f = 102,\n  g = 103,\n  h = 104,\n  i = 105,\n  j = 106,\n  k = 107,\n  l = 108,\n  m = 109,\n  n = 110,\n  o = 111,\n  p = 112,\n  q = 113,\n  r = 114,\n  s = 115,\n  t = 116,\n  u = 117,\n  v = 118,\n  w = 119,\n  x = 120,\n  y = 121,\n  z = 122,\n\n  /**\n   * The `{` character.\n   */\n  OpenCurlyBrace = 123,\n  /**\n   * The `|` character.\n   */\n  Pipe = 124,\n  /**\n   * The `}` character.\n   */\n  CloseCurlyBrace = 125,\n  /**\n   * The `~` character.\n   */\n  Tilde = 126,\n\n  U_Combining_Grave_Accent = 0x0300, //\tU+0300\tCombining Grave Accent\n  U_Combining_Acute_Accent = 0x0301, //\tU+0301\tCombining Acute Accent\n  U_Combining_Circumflex_Accent = 0x0302, //\tU+0302\tCombining Circumflex Accent\n  U_Combining_Tilde = 0x0303, //\tU+0303\tCombining Tilde\n  U_Combining_Macron = 0x0304, //\tU+0304\tCombining Macron\n  U_Combining_Overline = 0x0305, //\tU+0305\tCombining Overline\n  U_Combining_Breve = 0x0306, //\tU+0306\tCombining Breve\n  U_Combining_Dot_Above = 0x0307, //\tU+0307\tCombining Dot Above\n  U_Combining_Diaeresis = 0x0308, //\tU+0308\tCombining Diaeresis\n  U_Combining_Hook_Above = 0x0309, //\tU+0309\tCombining Hook Above\n  U_Combining_Ring_Above = 0x030a, //\tU+030A\tCombining Ring Above\n  U_Combining_Double_Acute_Accent = 0x030b, //\tU+030B\tCombining Double Acute Accent\n  U_Combining_Caron = 0x030c, //\tU+030C\tCombining Caron\n  U_Combining_Vertical_Line_Above = 0x030d, //\tU+030D\tCombining Vertical Line Above\n  U_Combining_Double_Vertical_Line_Above = 0x030e, //\tU+030E\tCombining Double Vertical Line Above\n  U_Combining_Double_Grave_Accent = 0x030f, //\tU+030F\tCombining Double Grave Accent\n  U_Combining_Candrabindu = 0x0310, //\tU+0310\tCombining Candrabindu\n  U_Combining_Inverted_Breve = 0x0311, //\tU+0311\tCombining Inverted Breve\n  U_Combining_Turned_Comma_Above = 0x0312, //\tU+0312\tCombining Turned Comma Above\n  U_Combining_Comma_Above = 0x0313, //\tU+0313\tCombining Comma Above\n  U_Combining_Reversed_Comma_Above = 0x0314, //\tU+0314\tCombining Reversed Comma Above\n  U_Combining_Comma_Above_Right = 0x0315, //\tU+0315\tCombining Comma Above Right\n  U_Combining_Grave_Accent_Below = 0x0316, //\tU+0316\tCombining Grave Accent Below\n  U_Combining_Acute_Accent_Below = 0x0317, //\tU+0317\tCombining Acute Accent Below\n  U_Combining_Left_Tack_Below = 0x0318, //\tU+0318\tCombining Left Tack Below\n  U_Combining_Right_Tack_Below = 0x0319, //\tU+0319\tCombining Right Tack Below\n  U_Combining_Left_Angle_Above = 0x031a, //\tU+031A\tCombining Left Angle Above\n  U_Combining_Horn = 0x031b, //\tU+031B\tCombining Horn\n  U_Combining_Left_Half_Ring_Below = 0x031c, //\tU+031C\tCombining Left Half Ring Below\n  U_Combining_Up_Tack_Below = 0x031d, //\tU+031D\tCombining Up Tack Below\n  U_Combining_Down_Tack_Below = 0x031e, //\tU+031E\tCombining Down Tack Below\n  U_Combining_Plus_Sign_Below = 0x031f, //\tU+031F\tCombining Plus Sign Below\n  U_Combining_Minus_Sign_Below = 0x0320, //\tU+0320\tCombining Minus Sign Below\n  U_Combining_Palatalized_Hook_Below = 0x0321, //\tU+0321\tCombining Palatalized Hook Below\n  U_Combining_Retroflex_Hook_Below = 0x0322, //\tU+0322\tCombining Retroflex Hook Below\n  U_Combining_Dot_Below = 0x0323, //\tU+0323\tCombining Dot Below\n  U_Combining_Diaeresis_Below = 0x0324, //\tU+0324\tCombining Diaeresis Below\n  U_Combining_Ring_Below = 0x0325, //\tU+0325\tCombining Ring Below\n  U_Combining_Comma_Below = 0x0326, //\tU+0326\tCombining Comma Below\n  U_Combining_Cedilla = 0x0327, //\tU+0327\tCombining Cedilla\n  U_Combining_Ogonek = 0x0328, //\tU+0328\tCombining Ogonek\n  U_Combining_Vertical_Line_Below = 0x0329, //\tU+0329\tCombining Vertical Line Below\n  U_Combining_Bridge_Below = 0x032a, //\tU+032A\tCombining Bridge Below\n  U_Combining_Inverted_Double_Arch_Below = 0x032b, //\tU+032B\tCombining Inverted Double Arch Below\n  U_Combining_Caron_Below = 0x032c, //\tU+032C\tCombining Caron Below\n  U_Combining_Circumflex_Accent_Below = 0x032d, //\tU+032D\tCombining Circumflex Accent Below\n  U_Combining_Breve_Below = 0x032e, //\tU+032E\tCombining Breve Below\n  U_Combining_Inverted_Breve_Below = 0x032f, //\tU+032F\tCombining Inverted Breve Below\n  U_Combining_Tilde_Below = 0x0330, //\tU+0330\tCombining Tilde Below\n  U_Combining_Macron_Below = 0x0331, //\tU+0331\tCombining Macron Below\n  U_Combining_Low_Line = 0x0332, //\tU+0332\tCombining Low Line\n  U_Combining_Double_Low_Line = 0x0333, //\tU+0333\tCombining Double Low Line\n  U_Combining_Tilde_Overlay = 0x0334, //\tU+0334\tCombining Tilde Overlay\n  U_Combining_Short_Stroke_Overlay = 0x0335, //\tU+0335\tCombining Short Stroke Overlay\n  U_Combining_Long_Stroke_Overlay = 0x0336, //\tU+0336\tCombining Long Stroke Overlay\n  U_Combining_Short_Solidus_Overlay = 0x0337, //\tU+0337\tCombining Short Solidus Overlay\n  U_Combining_Long_Solidus_Overlay = 0x0338, //\tU+0338\tCombining Long Solidus Overlay\n  U_Combining_Right_Half_Ring_Below = 0x0339, //\tU+0339\tCombining Right Half Ring Below\n  U_Combining_Inverted_Bridge_Below = 0x033a, //\tU+033A\tCombining Inverted Bridge Below\n  U_Combining_Square_Below = 0x033b, //\tU+033B\tCombining Square Below\n  U_Combining_Seagull_Below = 0x033c, //\tU+033C\tCombining Seagull Below\n  U_Combining_X_Above = 0x033d, //\tU+033D\tCombining X Above\n  U_Combining_Vertical_Tilde = 0x033e, //\tU+033E\tCombining Vertical Tilde\n  U_Combining_Double_Overline = 0x033f, //\tU+033F\tCombining Double Overline\n  U_Combining_Grave_Tone_Mark = 0x0340, //\tU+0340\tCombining Grave Tone Mark\n  U_Combining_Acute_Tone_Mark = 0x0341, //\tU+0341\tCombining Acute Tone Mark\n  U_Combining_Greek_Perispomeni = 0x0342, //\tU+0342\tCombining Greek Perispomeni\n  U_Combining_Greek_Koronis = 0x0343, //\tU+0343\tCombining Greek Koronis\n  U_Combining_Greek_Dialytika_Tonos = 0x0344, //\tU+0344\tCombining Greek Dialytika Tonos\n  U_Combining_Greek_Ypogegrammeni = 0x0345, //\tU+0345\tCombining Greek Ypogegrammeni\n  U_Combining_Bridge_Above = 0x0346, //\tU+0346\tCombining Bridge Above\n  U_Combining_Equals_Sign_Below = 0x0347, //\tU+0347\tCombining Equals Sign Below\n  U_Combining_Double_Vertical_Line_Below = 0x0348, //\tU+0348\tCombining Double Vertical Line Below\n  U_Combining_Left_Angle_Below = 0x0349, //\tU+0349\tCombining Left Angle Below\n  U_Combining_Not_Tilde_Above = 0x034a, //\tU+034A\tCombining Not Tilde Above\n  U_Combining_Homothetic_Above = 0x034b, //\tU+034B\tCombining Homothetic Above\n  U_Combining_Almost_Equal_To_Above = 0x034c, //\tU+034C\tCombining Almost Equal To Above\n  U_Combining_Left_Right_Arrow_Below = 0x034d, //\tU+034D\tCombining Left Right Arrow Below\n  U_Combining_Upwards_Arrow_Below = 0x034e, //\tU+034E\tCombining Upwards Arrow Below\n  U_Combining_Grapheme_Joiner = 0x034f, //\tU+034F\tCombining Grapheme Joiner\n  U_Combining_Right_Arrowhead_Above = 0x0350, //\tU+0350\tCombining Right Arrowhead Above\n  U_Combining_Left_Half_Ring_Above = 0x0351, //\tU+0351\tCombining Left Half Ring Above\n  U_Combining_Fermata = 0x0352, //\tU+0352\tCombining Fermata\n  U_Combining_X_Below = 0x0353, //\tU+0353\tCombining X Below\n  U_Combining_Left_Arrowhead_Below = 0x0354, //\tU+0354\tCombining Left Arrowhead Below\n  U_Combining_Right_Arrowhead_Below = 0x0355, //\tU+0355\tCombining Right Arrowhead Below\n  U_Combining_Right_Arrowhead_And_Up_Arrowhead_Below = 0x0356, //\tU+0356\tCombining Right Arrowhead And Up Arrowhead Below\n  U_Combining_Right_Half_Ring_Above = 0x0357, //\tU+0357\tCombining Right Half Ring Above\n  U_Combining_Dot_Above_Right = 0x0358, //\tU+0358\tCombining Dot Above Right\n  U_Combining_Asterisk_Below = 0x0359, //\tU+0359\tCombining Asterisk Below\n  U_Combining_Double_Ring_Below = 0x035a, //\tU+035A\tCombining Double Ring Below\n  U_Combining_Zigzag_Above = 0x035b, //\tU+035B\tCombining Zigzag Above\n  U_Combining_Double_Breve_Below = 0x035c, //\tU+035C\tCombining Double Breve Below\n  U_Combining_Double_Breve = 0x035d, //\tU+035D\tCombining Double Breve\n  U_Combining_Double_Macron = 0x035e, //\tU+035E\tCombining Double Macron\n  U_Combining_Double_Macron_Below = 0x035f, //\tU+035F\tCombining Double Macron Below\n  U_Combining_Double_Tilde = 0x0360, //\tU+0360\tCombining Double Tilde\n  U_Combining_Double_Inverted_Breve = 0x0361, //\tU+0361\tCombining Double Inverted Breve\n  U_Combining_Double_Rightwards_Arrow_Below = 0x0362, //\tU+0362\tCombining Double Rightwards Arrow Below\n  U_Combining_Latin_Small_Letter_A = 0x0363, //\tU+0363\tCombining Latin Small Letter A\n  U_Combining_Latin_Small_Letter_E = 0x0364, //\tU+0364\tCombining Latin Small Letter E\n  U_Combining_Latin_Small_Letter_I = 0x0365, //\tU+0365\tCombining Latin Small Letter I\n  U_Combining_Latin_Small_Letter_O = 0x0366, //\tU+0366\tCombining Latin Small Letter O\n  U_Combining_Latin_Small_Letter_U = 0x0367, //\tU+0367\tCombining Latin Small Letter U\n  U_Combining_Latin_Small_Letter_C = 0x0368, //\tU+0368\tCombining Latin Small Letter C\n  U_Combining_Latin_Small_Letter_D = 0x0369, //\tU+0369\tCombining Latin Small Letter D\n  U_Combining_Latin_Small_Letter_H = 0x036a, //\tU+036A\tCombining Latin Small Letter H\n  U_Combining_Latin_Small_Letter_M = 0x036b, //\tU+036B\tCombining Latin Small Letter M\n  U_Combining_Latin_Small_Letter_R = 0x036c, //\tU+036C\tCombining Latin Small Letter R\n  U_Combining_Latin_Small_Letter_T = 0x036d, //\tU+036D\tCombining Latin Small Letter T\n  U_Combining_Latin_Small_Letter_V = 0x036e, //\tU+036E\tCombining Latin Small Letter V\n  U_Combining_Latin_Small_Letter_X = 0x036f, //\tU+036F\tCombining Latin Small Letter X\n\n  /**\n   * Unicode Character 'LINE SEPARATOR' (U+2028)\n   * http://www.fileformat.info/info/unicode/char/2028/index.htm\n   */\n  LINE_SEPARATOR = 0x2028,\n  /**\n   * Unicode Character 'PARAGRAPH SEPARATOR' (U+2029)\n   * http://www.fileformat.info/info/unicode/char/2029/index.htm\n   */\n  PARAGRAPH_SEPARATOR = 0x2029,\n  /**\n   * Unicode Character 'NEXT LINE' (U+0085)\n   * http://www.fileformat.info/info/unicode/char/0085/index.htm\n   */\n  NEXT_LINE = 0x0085,\n\n  // http://www.fileformat.info/info/unicode/category/Sk/list.htm\n  U_CIRCUMFLEX = 0x005e, // U+005E\tCIRCUMFLEX\n  U_GRAVE_ACCENT = 0x0060, // U+0060\tGRAVE ACCENT\n  U_DIAERESIS = 0x00a8, // U+00A8\tDIAERESIS\n  U_MACRON = 0x00af, // U+00AF\tMACRON\n  U_ACUTE_ACCENT = 0x00b4, // U+00B4\tACUTE ACCENT\n  U_CEDILLA = 0x00b8, // U+00B8\tCEDILLA\n  U_MODIFIER_LETTER_LEFT_ARROWHEAD = 0x02c2, // U+02C2\tMODIFIER LETTER LEFT ARROWHEAD\n  U_MODIFIER_LETTER_RIGHT_ARROWHEAD = 0x02c3, // U+02C3\tMODIFIER LETTER RIGHT ARROWHEAD\n  U_MODIFIER_LETTER_UP_ARROWHEAD = 0x02c4, // U+02C4\tMODIFIER LETTER UP ARROWHEAD\n  U_MODIFIER_LETTER_DOWN_ARROWHEAD = 0x02c5, // U+02C5\tMODIFIER LETTER DOWN ARROWHEAD\n  U_MODIFIER_LETTER_CENTRED_RIGHT_HALF_RING = 0x02d2, // U+02D2\tMODIFIER LETTER CENTRED RIGHT HALF RING\n  U_MODIFIER_LETTER_CENTRED_LEFT_HALF_RING = 0x02d3, // U+02D3\tMODIFIER LETTER CENTRED LEFT HALF RING\n  U_MODIFIER_LETTER_UP_TACK = 0x02d4, // U+02D4\tMODIFIER LETTER UP TACK\n  U_MODIFIER_LETTER_DOWN_TACK = 0x02d5, // U+02D5\tMODIFIER LETTER DOWN TACK\n  U_MODIFIER_LETTER_PLUS_SIGN = 0x02d6, // U+02D6\tMODIFIER LETTER PLUS SIGN\n  U_MODIFIER_LETTER_MINUS_SIGN = 0x02d7, // U+02D7\tMODIFIER LETTER MINUS SIGN\n  U_BREVE = 0x02d8, // U+02D8\tBREVE\n  U_DOT_ABOVE = 0x02d9, // U+02D9\tDOT ABOVE\n  U_RING_ABOVE = 0x02da, // U+02DA\tRING ABOVE\n  U_OGONEK = 0x02db, // U+02DB\tOGONEK\n  U_SMALL_TILDE = 0x02dc, // U+02DC\tSMALL TILDE\n  U_DOUBLE_ACUTE_ACCENT = 0x02dd, // U+02DD\tDOUBLE ACUTE ACCENT\n  U_MODIFIER_LETTER_RHOTIC_HOOK = 0x02de, // U+02DE\tMODIFIER LETTER RHOTIC HOOK\n  U_MODIFIER_LETTER_CROSS_ACCENT = 0x02df, // U+02DF\tMODIFIER LETTER CROSS ACCENT\n  U_MODIFIER_LETTER_EXTRA_HIGH_TONE_BAR = 0x02e5, // U+02E5\tMODIFIER LETTER EXTRA-HIGH TONE BAR\n  U_MODIFIER_LETTER_HIGH_TONE_BAR = 0x02e6, // U+02E6\tMODIFIER LETTER HIGH TONE BAR\n  U_MODIFIER_LETTER_MID_TONE_BAR = 0x02e7, // U+02E7\tMODIFIER LETTER MID TONE BAR\n  U_MODIFIER_LETTER_LOW_TONE_BAR = 0x02e8, // U+02E8\tMODIFIER LETTER LOW TONE BAR\n  U_MODIFIER_LETTER_EXTRA_LOW_TONE_BAR = 0x02e9, // U+02E9\tMODIFIER LETTER EXTRA-LOW TONE BAR\n  U_MODIFIER_LETTER_YIN_DEPARTING_TONE_MARK = 0x02ea, // U+02EA\tMODIFIER LETTER YIN DEPARTING TONE MARK\n  U_MODIFIER_LETTER_YANG_DEPARTING_TONE_MARK = 0x02eb, // U+02EB\tMODIFIER LETTER YANG DEPARTING TONE MARK\n  U_MODIFIER_LETTER_UNASPIRATED = 0x02ed, // U+02ED\tMODIFIER LETTER UNASPIRATED\n  U_MODIFIER_LETTER_LOW_DOWN_ARROWHEAD = 0x02ef, // U+02EF\tMODIFIER LETTER LOW DOWN ARROWHEAD\n  U_MODIFIER_LETTER_LOW_UP_ARROWHEAD = 0x02f0, // U+02F0\tMODIFIER LETTER LOW UP ARROWHEAD\n  U_MODIFIER_LETTER_LOW_LEFT_ARROWHEAD = 0x02f1, // U+02F1\tMODIFIER LETTER LOW LEFT ARROWHEAD\n  U_MODIFIER_LETTER_LOW_RIGHT_ARROWHEAD = 0x02f2, // U+02F2\tMODIFIER LETTER LOW RIGHT ARROWHEAD\n  U_MODIFIER_LETTER_LOW_RING = 0x02f3, // U+02F3\tMODIFIER LETTER LOW RING\n  U_MODIFIER_LETTER_MIDDLE_GRAVE_ACCENT = 0x02f4, // U+02F4\tMODIFIER LETTER MIDDLE GRAVE ACCENT\n  U_MODIFIER_LETTER_MIDDLE_DOUBLE_GRAVE_ACCENT = 0x02f5, // U+02F5\tMODIFIER LETTER MIDDLE DOUBLE GRAVE ACCENT\n  U_MODIFIER_LETTER_MIDDLE_DOUBLE_ACUTE_ACCENT = 0x02f6, // U+02F6\tMODIFIER LETTER MIDDLE DOUBLE ACUTE ACCENT\n  U_MODIFIER_LETTER_LOW_TILDE = 0x02f7, // U+02F7\tMODIFIER LETTER LOW TILDE\n  U_MODIFIER_LETTER_RAISED_COLON = 0x02f8, // U+02F8\tMODIFIER LETTER RAISED COLON\n  U_MODIFIER_LETTER_BEGIN_HIGH_TONE = 0x02f9, // U+02F9\tMODIFIER LETTER BEGIN HIGH TONE\n  U_MODIFIER_LETTER_END_HIGH_TONE = 0x02fa, // U+02FA\tMODIFIER LETTER END HIGH TONE\n  U_MODIFIER_LETTER_BEGIN_LOW_TONE = 0x02fb, // U+02FB\tMODIFIER LETTER BEGIN LOW TONE\n  U_MODIFIER_LETTER_END_LOW_TONE = 0x02fc, // U+02FC\tMODIFIER LETTER END LOW TONE\n  U_MODIFIER_LETTER_SHELF = 0x02fd, // U+02FD\tMODIFIER LETTER SHELF\n  U_MODIFIER_LETTER_OPEN_SHELF = 0x02fe, // U+02FE\tMODIFIER LETTER OPEN SHELF\n  U_MODIFIER_LETTER_LOW_LEFT_ARROW = 0x02ff, // U+02FF\tMODIFIER LETTER LOW LEFT ARROW\n  U_GREEK_LOWER_NUMERAL_SIGN = 0x0375, // U+0375\tGREEK LOWER NUMERAL SIGN\n  U_GREEK_TONOS = 0x0384, // U+0384\tGREEK TONOS\n  U_GREEK_DIALYTIKA_TONOS = 0x0385, // U+0385\tGREEK DIALYTIKA TONOS\n  U_GREEK_KORONIS = 0x1fbd, // U+1FBD\tGREEK KORONIS\n  U_GREEK_PSILI = 0x1fbf, // U+1FBF\tGREEK PSILI\n  U_GREEK_PERISPOMENI = 0x1fc0, // U+1FC0\tGREEK PERISPOMENI\n  U_GREEK_DIALYTIKA_AND_PERISPOMENI = 0x1fc1, // U+1FC1\tGREEK DIALYTIKA AND PERISPOMENI\n  U_GREEK_PSILI_AND_VARIA = 0x1fcd, // U+1FCD\tGREEK PSILI AND VARIA\n  U_GREEK_PSILI_AND_OXIA = 0x1fce, // U+1FCE\tGREEK PSILI AND OXIA\n  U_GREEK_PSILI_AND_PERISPOMENI = 0x1fcf, // U+1FCF\tGREEK PSILI AND PERISPOMENI\n  U_GREEK_DASIA_AND_VARIA = 0x1fdd, // U+1FDD\tGREEK DASIA AND VARIA\n  U_GREEK_DASIA_AND_OXIA = 0x1fde, // U+1FDE\tGREEK DASIA AND OXIA\n  U_GREEK_DASIA_AND_PERISPOMENI = 0x1fdf, // U+1FDF\tGREEK DASIA AND PERISPOMENI\n  U_GREEK_DIALYTIKA_AND_VARIA = 0x1fed, // U+1FED\tGREEK DIALYTIKA AND VARIA\n  U_GREEK_DIALYTIKA_AND_OXIA = 0x1fee, // U+1FEE\tGREEK DIALYTIKA AND OXIA\n  U_GREEK_VARIA = 0x1fef, // U+1FEF\tGREEK VARIA\n  U_GREEK_OXIA = 0x1ffd, // U+1FFD\tGREEK OXIA\n  U_GREEK_DASIA = 0x1ffe, // U+1FFE\tGREEK DASIA\n\n  U_OVERLINE = 0x203e, // Unicode Character 'OVERLINE'\n\n  /**\n   * UTF-8 BOM\n   * Unicode Character 'ZERO WIDTH NO-BREAK SPACE' (U+FEFF)\n   * http://www.fileformat.info/info/unicode/char/feff/index.htm\n   */\n  UTF8_BOM = 65279,\n}\n", "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from './charCode';\nimport { join } from './path';\n\nconst _schemePattern = /^\\w[\\w\\d+.-]*$/;\nconst _singleSlashStart = /^\\//;\nconst _doubleSlashStart = /^\\/\\//;\n\nfunction _validateUri(ret: Uri, _strict?: boolean): void {\n  // scheme, must be set\n  if (!ret.scheme && _strict) {\n    throw new Error(\n      `[UriError]: Scheme is missing: {scheme: \"\", authority: \"${ret.authority}\", path: \"${ret.path}\", query: \"${ret.query}\", fragment: \"${ret.fragment}\"}`\n    );\n  }\n\n  // scheme, https://tools.ietf.org/html/rfc3986#section-3.1\n  // ALPHA *( ALPHA / DIGIT / \"+\" / \"-\" / \".\" )\n  if (ret.scheme && !_schemePattern.test(ret.scheme)) {\n    throw new Error('[UriError]: Scheme contains illegal characters.');\n  }\n\n  // path, http://tools.ietf.org/html/rfc3986#section-3.3\n  // If a URI contains an authority component, then the path component\n  // must either be empty or begin with a slash (\"/\") character.  If a URI\n  // does not contain an authority component, then the path cannot begin\n  // with two slash characters (\"//\").\n  if (ret.path) {\n    if (ret.authority) {\n      if (!_singleSlashStart.test(ret.path)) {\n        throw new Error(\n          '[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash (\"/\") character'\n        );\n      }\n    } else {\n      if (_doubleSlashStart.test(ret.path)) {\n        throw new Error(\n          '[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters (\"//\")'\n        );\n      }\n    }\n  }\n}\n\n// for a while we allowed uris *without* schemes and this is the migration\n// for them, e.g. an uri without scheme and without strict-mode warns and falls\n// back to the file-scheme. that should cause the least carnage and still be a\n// clear warning\nfunction _schemeFix(scheme: string, _strict: boolean): string {\n  if (!scheme && !_strict) {\n    return 'file';\n  }\n  return scheme;\n}\n\n// implements a bit of https://tools.ietf.org/html/rfc3986#section-5\nfunction _referenceResolution(scheme: string, path: string): string {\n  // the slash-character is our 'default base' as we don't\n  // support constructing URIs relative to other URIs. This\n  // see https://tools.ietf.org/html/rfc3986#section-5.1.4\n  switch (scheme) {\n    case 'https':\n    case 'http':\n    case 'file':\n      if (!path) {\n        path = _slash;\n      } else if (path[0] !== _slash) {\n        path = _slash + path;\n      }\n      break;\n  }\n  return path;\n}\n\nconst _empty = '';\nconst _slash = '/';\nconst _regexp = /^(([^:/?#]+?):)?(\\/\\/([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?/;\n\n/**\n * Uniform Resource Identifier (URI) http://tools.ietf.org/html/rfc3986.\n * This class is a simple parser which creates the basic component parts\n * (http://tools.ietf.org/html/rfc3986#section-3) with minimal validation\n * and encoding.\n *\n * ```txt\n *       foo://example.com:8042/over/there?name=ferret#nose\n *       \\_/   \\______________/\\_________/ \\_________/ \\__/\n *        |           |            |            |        |\n *     scheme     authority       path        query   fragment\n *        |   _____________________|__\n *       / \\ /                        \\\n *       urn:example:animal:ferret:nose\n * ```\n */\nexport class Uri implements UriComponents {\n  static ensureTrailingSlash(uri: Uri, trailingSlash = '/') {\n    return uri.with({\n      path: uri.path.replace(TRAILING_SLASH_RX, trailingSlash),\n    });\n  }\n\n  static equals(l: Uri, r: Uri) {\n    return (\n      l.authority === r.authority &&\n      l.fragment === r.fragment &&\n      l.path === r.path &&\n      l.query === r.query &&\n      l.scheme === r.scheme\n    );\n  }\n\n  static getFirstPathSegmentAfterPrefix(child: Uri, parent: Uri): string {\n    const childHref = child.path;\n    const parentHref = parent.path;\n    const parentOffset = parentHref.charAt(parentHref.length - 1) === '/' ? -1 : 0;\n\n    for (let i = 0; i <= childHref.length; i++) {\n      if (i < parentHref.length) {\n        if (childHref.charAt(i) !== parentHref.charAt(i)) {\n          throw new Error(\n            `The child entry ${child.toString()} does not have the pathname of ${parent.toString()} as a prefix`\n          );\n        }\n      } else if (i === parentHref.length + parentOffset) {\n        if (childHref.charAt(i) !== '/') {\n          throw new Error(\n            `The child entry ${child.toString()} does not have the pathname of ${parent.toString()} as a prefix`\n          );\n        }\n      } else if (childHref.charAt(i) === '/') {\n        return childHref.slice(parentHref.length + 1 + parentOffset, i);\n      }\n    }\n\n    return childHref.slice(parentHref.length + 1 + parentOffset);\n  }\n\n  static isPrefixOf(prefix: Uri, uri: Uri) {\n    return (\n      prefix.authority === uri.authority &&\n      prefix.fragment === uri.fragment &&\n      prefix.query === uri.query &&\n      prefix.scheme === uri.scheme &&\n      uri.path.startsWith(prefix.path)\n    );\n  }\n\n  static isUri(thing: any): thing is Uri {\n    if (thing instanceof Uri) {\n      return true;\n    }\n    if (!thing) {\n      return false;\n    }\n    return (\n      typeof (<Uri>thing).authority === 'string' &&\n      typeof (<Uri>thing).fragment === 'string' &&\n      typeof (<Uri>thing).path === 'string' &&\n      typeof (<Uri>thing).query === 'string' &&\n      typeof (<Uri>thing).scheme === 'string' &&\n      typeof (<Uri>thing).fsPath === 'function' &&\n      typeof (<Uri>thing).with === 'function' &&\n      typeof (<Uri>thing).toString === 'function'\n    );\n  }\n\n  /**\n   * scheme is the 'http' part of 'http://www.msft.com/some/path?query#fragment'.\n   * The part before the first colon.\n   */\n  readonly scheme: string;\n\n  /**\n   * authority is the 'www.msft.com' part of 'http://www.msft.com/some/path?query#fragment'.\n   * The part between the first double slashes and the next slash.\n   */\n  readonly authority: string;\n\n  /**\n   * path is the '/some/path' part of 'http://www.msft.com/some/path?query#fragment'.\n   */\n  readonly path: string;\n\n  /**\n   * query is the 'query' part of 'http://www.msft.com/some/path?query#fragment'.\n   */\n  readonly query: string;\n\n  /**\n   * fragment is the 'fragment' part of 'http://www.msft.com/some/path?query#fragment'.\n   */\n  readonly fragment: string;\n\n  /**\n   * @internal\n   */\n  protected constructor(\n    scheme: string,\n    authority?: string,\n    path?: string,\n    query?: string,\n    fragment?: string,\n    _strict?: boolean\n  );\n\n  /**\n   * @internal\n   */\n  protected constructor(components: UriComponents);\n\n  /**\n   * @internal\n   */\n  protected constructor(\n    schemeOrData: string | UriComponents,\n    authority?: string,\n    path?: string,\n    query?: string,\n    fragment?: string,\n    _strict: boolean = false\n  ) {\n    if (typeof schemeOrData === 'object') {\n      this.scheme = schemeOrData.scheme || _empty;\n      this.authority = schemeOrData.authority || _empty;\n      this.path = schemeOrData.path || _empty;\n      this.query = schemeOrData.query || _empty;\n      this.fragment = schemeOrData.fragment || _empty;\n      // no validation because it's this URI\n      // that creates uri components.\n      // _validateUri(this);\n    } else {\n      this.scheme = _schemeFix(schemeOrData, _strict);\n      this.authority = authority || _empty;\n      this.path = _referenceResolution(this.scheme, path || _empty);\n      this.query = query || _empty;\n      this.fragment = fragment || _empty;\n\n      _validateUri(this, _strict);\n    }\n  }\n\n  // ---- filesystem path -----------------------\n\n  /**\n\t * Returns a string representing the corresponding file system path of this URI.\n\t * platform specific path separator.\n\t *\n\t * * Will *not* validate the path for invalid characters and semantics.\n\t * * Will *not* look at the scheme of this URI.\n\t * * The result shall *not* be used for display purposes but for accessing a file on disk.\n\t *\n\t *\n\t * The *difference* to `URI#path` is the use of the platform specific separator and the handling\n\t *\n\t * ```ts\n\t\tconst u = URI.parse('file://server/c$/folder/file.txt')\n\t\tu.authority === 'server'\n\t\tu.path === '/shares/c$/file.txt'\n\t\tu.fsPath === '\\\\server\\c$\\folder\\file.txt'\n\t```\n\t *\n\t * Using `URI#path` to read a file (using fs-apis) would not be enough because parts of the path,\n\t * namely the server name, would be missing. Therefore `URI#fsPath` exists - it's sugar to ease working\n\t * with URIs that represent files on disk (`file` scheme).\n\t */\n  get fsPath(): string {\n    // if (this.scheme !== 'file') {\n    // \tconsole.warn(`[UriError] calling fsPath with scheme ${this.scheme}`);\n    // }\n    return uriToFsPath(this, false);\n  }\n\n  // ---- modify to new -------------------------\n\n  with(change: {\n    scheme?: string;\n    authority?: string | null;\n    path?: string | null;\n    query?: string | null;\n    fragment?: string | null;\n  }): Uri {\n    if (!change) {\n      return this;\n    }\n\n    let { scheme, authority, path, query, fragment } = change;\n    if (scheme === undefined) {\n      scheme = this.scheme;\n    } else if (scheme === null) {\n      scheme = _empty;\n    }\n    if (authority === undefined) {\n      authority = this.authority;\n    } else if (authority === null) {\n      authority = _empty;\n    }\n    if (path === undefined) {\n      path = this.path;\n    } else if (path === null) {\n      path = _empty;\n    }\n    if (query === undefined) {\n      query = this.query;\n    } else if (query === null) {\n      query = _empty;\n    }\n    if (fragment === undefined) {\n      fragment = this.fragment;\n    } else if (fragment === null) {\n      fragment = _empty;\n    }\n\n    if (\n      scheme === this.scheme &&\n      authority === this.authority &&\n      path === this.path &&\n      query === this.query &&\n      fragment === this.fragment\n    ) {\n      return this;\n    }\n\n    return new _URI(scheme, authority, path, query, fragment);\n  }\n\n  // ---- parse & validate ------------------------\n\n  /**\n   * Creates a new URI from a string, e.g. `http://www.msft.com/some/path`,\n   * `file:///usr/home`, or `scheme:with/path`.\n   *\n   * @param value A string which represents an URI (see `URI#toString`).\n   */\n  static parse(value: string, _strict: boolean = false): Uri {\n    const match = _regexp.exec(value);\n    if (!match) {\n      return new _URI(_empty, _empty, _empty, _empty, _empty);\n    }\n    return new _URI(\n      match[2] || _empty,\n      percentDecode(match[4] || _empty),\n      percentDecode(match[5] || _empty),\n      percentDecode(match[7] || _empty),\n      percentDecode(match[9] || _empty),\n      _strict\n    );\n  }\n\n  /**\n\t * Creates a new URI from a file system path, e.g. `c:\\my\\files`,\n\t * `/usr/home`, or `\\\\server\\share\\some\\path`.\n\t *\n\t * The *difference* between `URI#parse` and `URI#file` is that the latter treats the argument\n\t * as path, not as stringified-uri. E.g. `URI.file(path)` is **not the same as**\n\t * `URI.parse('file://' + path)` because the path might contain characters that are\n\t * interpreted (# and ?). See the following sample:\n\t * ```ts\n\tconst good = URI.file('/coding/c#/project1');\n\tgood.scheme === 'file';\n\tgood.path === '/coding/c#/project1';\n\tgood.fragment === '';\n\tconst bad = URI.parse('file://' + '/coding/c#/project1');\n\tbad.scheme === 'file';\n\tbad.path === '/coding/c'; // path is now broken\n\tbad.fragment === '/project1';\n\t```\n\t *\n\t * @param path A file system path (see `URI#fsPath`)\n\t */\n  static file(path: string): Uri {\n    let authority = _empty;\n\n    // check for authority as used in UNC shares\n    // or use the path as given\n    if (path[0] === _slash && path[1] === _slash) {\n      const idx = path.indexOf(_slash, 2);\n      if (idx === -1) {\n        authority = path.substring(2);\n        path = _slash;\n      } else {\n        authority = path.substring(2, idx);\n        path = path.substring(idx) || _slash;\n      }\n    }\n\n    return new _URI('file', authority, path, _empty, _empty);\n  }\n\n  static from(components: {\n    scheme: string;\n    authority?: string;\n    path?: string;\n    query?: string;\n    fragment?: string;\n  }): Uri {\n    return new _URI(\n      components.scheme,\n      components.authority,\n      components.path,\n      components.query,\n      components.fragment\n    );\n  }\n\n  /**\n   * Join a URI path with path fragments and normalizes the resulting path.\n   *\n   * @param uri The input URI.\n   * @param pathFragment The path fragment to add to the URI path.\n   * @returns The resulting URI.\n   */\n  static joinPath(uri: Uri, ...pathFragment: string[]): Uri {\n    if (!uri.path) {\n      throw new Error(`[UriError]: cannot call joinPaths on URI without path`);\n    }\n    const newPath = join(uri.path, ...pathFragment);\n    return uri.with({ path: newPath });\n  }\n\n  // ---- printing/externalize ---------------------------\n\n  /**\n   * Creates a string representation for this URI. It's guaranteed that calling\n   * `URI.parse` with the result of this function creates an URI which is equal\n   * to this URI.\n   *\n   * * The result shall *not* be used for display purposes but for externalization or transport.\n   * * The result will be encoded using the percentage encoding and encoding happens mostly\n   * ignore the scheme-specific encoding rules.\n   *\n   * @param skipEncoding Do not encode the result, default is `false`\n   */\n  toString(skipEncoding: boolean = true): string {\n    return _asFormatted(this, skipEncoding);\n  }\n\n  toJSON(): UriComponents {\n    return this;\n  }\n\n  static revive(data: UriComponents | Uri): Uri;\n  static revive(data: UriComponents | Uri | undefined): Uri | undefined;\n  static revive(data: UriComponents | Uri | null): Uri | null;\n  static revive(data: UriComponents | Uri | undefined | null): Uri | undefined | null;\n  static revive(data: UriComponents | Uri | undefined | null): Uri | undefined | null {\n    if (!data) {\n      return data;\n    } else if (data instanceof Uri) {\n      return data;\n    } else {\n      const result = new _URI(data);\n      result._formatted = (<UriState>data).external;\n      result._fsPath = (<UriState>data)._sep === _pathSepMarker ? (<UriState>data).fsPath : null;\n      return result;\n    }\n  }\n}\n\nexport interface UriComponents {\n  scheme: string;\n  authority: string;\n  path: string;\n  query: string;\n  fragment: string;\n}\n\ninterface UriState extends UriComponents {\n  $mid: number;\n  external: string;\n  fsPath: string;\n  _sep: 1 | undefined;\n}\n\nconst _pathSepMarker = undefined;\n\n// eslint-disable-next-line @typescript-eslint/naming-convention\nclass _URI extends Uri {\n  _formatted: string | null = null;\n  _fsPath: string | null = null;\n\n  get fsPath(): string {\n    if (!this._fsPath) {\n      this._fsPath = uriToFsPath(this, false);\n    }\n    return this._fsPath;\n  }\n\n  toString(skipEncoding: boolean = true): string {\n    if (!skipEncoding) {\n      // we don't cache that\n      return _asFormatted(this, false);\n    } else {\n      if (!this._formatted) {\n        this._formatted = _asFormatted(this, true);\n      }\n      return this._formatted;\n    }\n  }\n\n  toJSON(): UriComponents {\n    const res = <UriState>{\n      $mid: 1,\n    };\n    // cached state\n    if (this._fsPath) {\n      res.fsPath = this._fsPath;\n      res._sep = _pathSepMarker;\n    }\n    if (this._formatted) {\n      res.external = this._formatted;\n    }\n    // uri components\n    if (this.path) {\n      res.path = this.path;\n    }\n    if (this.scheme) {\n      res.scheme = this.scheme;\n    }\n    if (this.authority) {\n      res.authority = this.authority;\n    }\n    if (this.query) {\n      res.query = this.query;\n    }\n    if (this.fragment) {\n      res.fragment = this.fragment;\n    }\n    return res;\n  }\n}\n\n// reserved characters: https://tools.ietf.org/html/rfc3986#section-2.2\nconst encodeTable: { [ch: number]: string } = {\n  [CharCode.Colon]: '%3A', // gen-delims\n  [CharCode.Slash]: '%2F',\n  [CharCode.QuestionMark]: '%3F',\n  [CharCode.Hash]: '%23',\n  [CharCode.OpenSquareBracket]: '%5B',\n  [CharCode.CloseSquareBracket]: '%5D',\n  [CharCode.AtSign]: '%40',\n\n  [CharCode.ExclamationMark]: '%21', // sub-delims\n  [CharCode.DollarSign]: '%24',\n  [CharCode.Ampersand]: '%26',\n  [CharCode.SingleQuote]: '%27',\n  [CharCode.OpenParen]: '%28',\n  [CharCode.CloseParen]: '%29',\n  [CharCode.Asterisk]: '%2A',\n  [CharCode.Plus]: '%2B',\n  [CharCode.Comma]: '%2C',\n  [CharCode.Semicolon]: '%3B',\n  [CharCode.Equals]: '%3D',\n\n  [CharCode.Space]: '%20',\n};\n\nfunction encodeURIComponentFast(uriComponent: string, allowSlash: boolean): string {\n  let res: string | undefined = undefined;\n  let nativeEncodePos = -1;\n\n  for (let pos = 0; pos < uriComponent.length; pos++) {\n    const code = uriComponent.charCodeAt(pos);\n\n    // unreserved characters: https://tools.ietf.org/html/rfc3986#section-2.3\n    if (\n      (code >= CharCode.a && code <= CharCode.z) ||\n      (code >= CharCode.A && code <= CharCode.Z) ||\n      (code >= CharCode.Digit0 && code <= CharCode.Digit9) ||\n      code === CharCode.Dash ||\n      code === CharCode.Period ||\n      code === CharCode.Underline ||\n      code === CharCode.Tilde ||\n      (allowSlash && code === CharCode.Slash)\n    ) {\n      // check if we are delaying native encode\n      if (nativeEncodePos !== -1) {\n        res += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));\n        nativeEncodePos = -1;\n      }\n      // check if we write into a new string (by default we try to return the param)\n      if (res !== undefined) {\n        res += uriComponent.charAt(pos);\n      }\n    } else {\n      // encoding needed, we need to allocate a new string\n      if (res === undefined) {\n        res = uriComponent.substr(0, pos);\n      }\n\n      // check with default table first\n      const escaped = encodeTable[code];\n      if (escaped !== undefined) {\n        // check if we are delaying native encode\n        if (nativeEncodePos !== -1) {\n          res += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));\n          nativeEncodePos = -1;\n        }\n\n        // append escaped variant to result\n        res += escaped;\n      } else if (nativeEncodePos === -1) {\n        // use native encode only when needed\n        nativeEncodePos = pos;\n      }\n    }\n  }\n\n  if (nativeEncodePos !== -1) {\n    res += encodeURIComponent(uriComponent.substring(nativeEncodePos));\n  }\n\n  return res !== undefined ? res : uriComponent;\n}\n\nfunction encodeURIComponentMinimal(path: string): string {\n  let res: string | undefined = undefined;\n  for (let pos = 0; pos < path.length; pos++) {\n    const code = path.charCodeAt(pos);\n    if (code === CharCode.Hash || code === CharCode.QuestionMark) {\n      if (res === undefined) {\n        res = path.substr(0, pos);\n      }\n      res += encodeTable[code];\n    } else {\n      if (res !== undefined) {\n        res += path[pos];\n      }\n    }\n  }\n  return res !== undefined ? res : path;\n}\n\n/**\n * Compute `fsPath` for the given uri\n */\nexport function uriToFsPath(uri: Uri, keepDriveLetterCasing: boolean): string {\n  let value: string;\n  if (uri.authority && uri.path.length > 1 && uri.scheme === 'file') {\n    // unc path: file://shares/c$/far/boo\n    value = `//${uri.authority}${uri.path}`;\n  } else if (\n    uri.path.charCodeAt(0) === CharCode.Slash &&\n    ((uri.path.charCodeAt(1) >= CharCode.A && uri.path.charCodeAt(1) <= CharCode.Z) ||\n      (uri.path.charCodeAt(1) >= CharCode.a && uri.path.charCodeAt(1) <= CharCode.z)) &&\n    uri.path.charCodeAt(2) === CharCode.Colon\n  ) {\n    if (!keepDriveLetterCasing) {\n      // windows drive letter: file:///c:/far/boo\n      value = uri.path[1].toLowerCase() + uri.path.substr(2);\n    } else {\n      value = uri.path.substr(1);\n    }\n  } else {\n    // other path\n    value = uri.path;\n  }\n  return value;\n}\n\n/**\n * Create the external version of a uri\n */\nfunction _asFormatted(uri: Uri, skipEncoding: boolean): string {\n  const encoder = !skipEncoding ? encodeURIComponentFast : encodeURIComponentMinimal;\n\n  let res = '';\n  let { scheme, authority, path, query, fragment } = uri;\n  if (scheme) {\n    res += scheme;\n    res += ':';\n  }\n  if (authority || scheme === 'file') {\n    res += _slash;\n    res += _slash;\n  }\n  if (authority) {\n    let idx = authority.indexOf('@');\n    if (idx !== -1) {\n      // <user>@<auth>\n      const userinfo = authority.substr(0, idx);\n      authority = authority.substr(idx + 1);\n      idx = userinfo.indexOf(':');\n      if (idx === -1) {\n        res += encoder(userinfo, false);\n      } else {\n        // <user>:<pass>@<auth>\n        res += encoder(userinfo.substr(0, idx), false);\n        res += ':';\n        res += encoder(userinfo.substr(idx + 1), false);\n      }\n      res += '@';\n    }\n    authority = authority.toLowerCase();\n    idx = authority.indexOf(':');\n    if (idx === -1) {\n      res += encoder(authority, false);\n    } else {\n      // <auth>:<port>\n      res += encoder(authority.substr(0, idx), false);\n      res += authority.substr(idx);\n    }\n  }\n  if (path) {\n    // lower-case windows drive letters in /C:/fff or C:/fff\n    if (\n      path.length >= 3 &&\n      path.charCodeAt(0) === CharCode.Slash &&\n      path.charCodeAt(2) === CharCode.Colon\n    ) {\n      const code = path.charCodeAt(1);\n      if (code >= CharCode.A && code <= CharCode.Z) {\n        path = `/${String.fromCharCode(code + 32)}:${path.substr(3)}`; // \"/c:\".length === 3\n      }\n    } else if (path.length >= 2 && path.charCodeAt(1) === CharCode.Colon) {\n      const code = path.charCodeAt(0);\n      if (code >= CharCode.A && code <= CharCode.Z) {\n        path = `${String.fromCharCode(code + 32)}:${path.substr(2)}`; // \"/c:\".length === 3\n      }\n    }\n    // encode the rest of the path\n    res += encoder(path, true);\n  }\n  if (query) {\n    res += '?';\n    res += encoder(query, false);\n  }\n  if (fragment) {\n    res += '#';\n    res += !skipEncoding ? encodeURIComponentFast(fragment, false) : fragment;\n  }\n  return res;\n}\n\n// --- decode\n\nfunction decodeURIComponentGraceful(str: string): string {\n  try {\n    return decodeURIComponent(str);\n  } catch {\n    if (str.length > 3) {\n      return str.substr(0, 3) + decodeURIComponentGraceful(str.substr(3));\n    } else {\n      return str;\n    }\n  }\n}\n\nconst _rEncodedAsHex = /(%[0-9A-Za-z][0-9A-Za-z])+/g;\n\nfunction percentDecode(str: string): string {\n  if (!str.match(_rEncodedAsHex)) {\n    return str;\n  }\n  return str.replace(_rEncodedAsHex, (match) => decodeURIComponentGraceful(match));\n}\n\nconst TRAILING_SLASH_RX = /\\/?$/;\n", "export const version = '__VERSION__';\nexport * from './async';\nexport * from './base64';\nexport * from './cancellation';\nexport * from './decoder';\nexport * from './error';\nexport * from './event';\nexport * from './lifecycle';\nexport * from './mapSet';\nexport * from './packageJson';\nexport * from './path';\nexport * from './uri';\n", "import { CancellationToken, Thenable, Uri } from '@velcro/common';\nimport { Resolver, ResolverContext } from '@velcro/resolver';\nimport MagicString, { SourceMapSegment } from 'magic-string';\nimport { SourceModule, SourceModuleDependency } from '../graph';\n\ntype MaybeThenable<T> = T | Thenable<T>;\n\nexport interface Plugin {\n  name: string;\n  load?(ctx: PluginLoadContext, id: string): MaybeThenable<PluginLoadResult | undefined>;\n  resolveDependency?(\n    ctx: PluginResolveDependencyContext,\n    dependency: SourceModuleDependency,\n    fromModule: SourceModule\n  ): MaybeThenable<PluginResolveDependencyResult | undefined>;\n  resolveEntrypoint?(\n    ctx: PluginResolveEntrypointContext,\n    uri: Uri\n  ): MaybeThenable<PluginResolveEntrypointResult | undefined>;\n  transform?(\n    ctx: PluginTransformContext,\n    id: Uri,\n    code: string\n  ): MaybeThenable<PluginTransformResult | undefined>;\n}\n\nexport interface PluginLoadContext {\n  nodeEnv: string;\n  resolver: Resolver;\n  token: CancellationToken;\n}\n\nexport type PluginLoadResult = {\n  code: string;\n  visited?: ResolverContext.Visit[];\n};\n\nexport interface PluginResolveDependencyContext {\n  nodeEnv: string;\n  resolver: Resolver;\n  token: CancellationToken;\n}\n\nexport type PluginResolveDependencyResult = {\n  uri: Uri;\n  rootUri: Uri;\n  visited?: ResolverContext.Visit[];\n};\n\nexport interface PluginResolveEntrypointContext {\n  nodeEnv: string;\n  resolver: Resolver;\n  token: CancellationToken;\n}\n\nexport type PluginResolveEntrypointResult = {\n  uri: Uri;\n  rootUri: Uri;\n  visited?: ResolverContext.Visit[];\n};\n\nexport interface PluginTransformContext {\n  nodeEnv: string;\n  resolver: Resolver;\n  token: CancellationToken;\n\n  createMagicString(): MagicString;\n}\n\nexport type PluginTransformResult = {\n  code: string;\n  sourceMap?: {\n    mappings: SourceMapSegment[][] | string;\n    names: string[];\n  };\n  visited?: ResolverContext.Visit[];\n};\n", "var charToInteger = {};\nvar chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\nfor (var i = 0; i < chars.length; i++) {\n    charToInteger[chars.charCodeAt(i)] = i;\n}\nfunction decode(mappings) {\n    var decoded = [];\n    var line = [];\n    var segment = [\n        0,\n        0,\n        0,\n        0,\n        0,\n    ];\n    var j = 0;\n    for (var i = 0, shift = 0, value = 0; i < mappings.length; i++) {\n        var c = mappings.charCodeAt(i);\n        if (c === 44) { // \",\"\n            segmentify(line, segment, j);\n            j = 0;\n        }\n        else if (c === 59) { // \";\"\n            segmentify(line, segment, j);\n            j = 0;\n            decoded.push(line);\n            line = [];\n            segment[0] = 0;\n        }\n        else {\n            var integer = charToInteger[c];\n            if (integer === undefined) {\n                throw new Error('Invalid character (' + String.fromCharCode(c) + ')');\n            }\n            var hasContinuationBit = integer & 32;\n            integer &= 31;\n            value += integer << shift;\n            if (hasContinuationBit) {\n                shift += 5;\n            }\n            else {\n                var shouldNegate = value & 1;\n                value >>>= 1;\n                if (shouldNegate) {\n                    value = value === 0 ? -0x80000000 : -value;\n                }\n                segment[j] += value;\n                j++;\n                value = shift = 0; // reset\n            }\n        }\n    }\n    segmentify(line, segment, j);\n    decoded.push(line);\n    return decoded;\n}\nfunction segmentify(line, segment, j) {\n    // This looks ugly, but we're creating specialized arrays with a specific\n    // length. This is much faster than creating a new array (which v8 expands to\n    // a capacity of 17 after pushing the first item), or slicing out a subarray\n    // (which is slow). Length 4 is assumed to be the most frequent, followed by\n    // length 5 (since not everything will have an associated name), followed by\n    // length 1 (it's probably rare for a source substring to not have an\n    // associated segment data).\n    if (j === 4)\n        line.push([segment[0], segment[1], segment[2], segment[3]]);\n    else if (j === 5)\n        line.push([segment[0], segment[1], segment[2], segment[3], segment[4]]);\n    else if (j === 1)\n        line.push([segment[0]]);\n}\nfunction encode(decoded) {\n    var sourceFileIndex = 0; // second field\n    var sourceCodeLine = 0; // third field\n    var sourceCodeColumn = 0; // fourth field\n    var nameIndex = 0; // fifth field\n    var mappings = '';\n    for (var i = 0; i < decoded.length; i++) {\n        var line = decoded[i];\n        if (i > 0)\n            mappings += ';';\n        if (line.length === 0)\n            continue;\n        var generatedCodeColumn = 0; // first field\n        var lineMappings = [];\n        for (var _i = 0, line_1 = line; _i < line_1.length; _i++) {\n            var segment = line_1[_i];\n            var segmentMappings = encodeInteger(segment[0] - generatedCodeColumn);\n            generatedCodeColumn = segment[0];\n            if (segment.length > 1) {\n                segmentMappings +=\n                    encodeInteger(segment[1] - sourceFileIndex) +\n                        encodeInteger(segment[2] - sourceCodeLine) +\n                        encodeInteger(segment[3] - sourceCodeColumn);\n                sourceFileIndex = segment[1];\n                sourceCodeLine = segment[2];\n                sourceCodeColumn = segment[3];\n            }\n            if (segment.length === 5) {\n                segmentMappings += encodeInteger(segment[4] - nameIndex);\n                nameIndex = segment[4];\n            }\n            lineMappings.push(segmentMappings);\n        }\n        mappings += lineMappings.join(',');\n    }\n    return mappings;\n}\nfunction encodeInteger(num) {\n    var result = '';\n    num = num < 0 ? (-num << 1) | 1 : num << 1;\n    do {\n        var clamped = num & 31;\n        num >>>= 5;\n        if (num > 0) {\n            clamped |= 32;\n        }\n        result += chars[clamped];\n    } while (num > 0);\n    return result;\n}\n\nexport { decode, encode };\n//# sourceMappingURL=sourcemap-codec.es.js.map\n", "import { encode } from 'sourcemap-codec';\n\nvar BitSet = function BitSet(arg) {\n\tthis.bits = arg instanceof BitSet ? arg.bits.slice() : [];\n};\n\nBitSet.prototype.add = function add (n) {\n\tthis.bits[n >> 5] |= 1 << (n & 31);\n};\n\nBitSet.prototype.has = function has (n) {\n\treturn !!(this.bits[n >> 5] & (1 << (n & 31)));\n};\n\nvar Chunk = function Chunk(start, end, content) {\n\tthis.start = start;\n\tthis.end = end;\n\tthis.original = content;\n\n\tthis.intro = '';\n\tthis.outro = '';\n\n\tthis.content = content;\n\tthis.storeName = false;\n\tthis.edited = false;\n\n\t// we make these non-enumerable, for sanity while debugging\n\tObject.defineProperties(this, {\n\t\tprevious: { writable: true, value: null },\n\t\tnext:     { writable: true, value: null }\n\t});\n};\n\nChunk.prototype.appendLeft = function appendLeft (content) {\n\tthis.outro += content;\n};\n\nChunk.prototype.appendRight = function appendRight (content) {\n\tthis.intro = this.intro + content;\n};\n\nChunk.prototype.clone = function clone () {\n\tvar chunk = new Chunk(this.start, this.end, this.original);\n\n\tchunk.intro = this.intro;\n\tchunk.outro = this.outro;\n\tchunk.content = this.content;\n\tchunk.storeName = this.storeName;\n\tchunk.edited = this.edited;\n\n\treturn chunk;\n};\n\nChunk.prototype.contains = function contains (index) {\n\treturn this.start < index && index < this.end;\n};\n\nChunk.prototype.eachNext = function eachNext (fn) {\n\tvar chunk = this;\n\twhile (chunk) {\n\t\tfn(chunk);\n\t\tchunk = chunk.next;\n\t}\n};\n\nChunk.prototype.eachPrevious = function eachPrevious (fn) {\n\tvar chunk = this;\n\twhile (chunk) {\n\t\tfn(chunk);\n\t\tchunk = chunk.previous;\n\t}\n};\n\nChunk.prototype.edit = function edit (content, storeName, contentOnly) {\n\tthis.content = content;\n\tif (!contentOnly) {\n\t\tthis.intro = '';\n\t\tthis.outro = '';\n\t}\n\tthis.storeName = storeName;\n\n\tthis.edited = true;\n\n\treturn this;\n};\n\nChunk.prototype.prependLeft = function prependLeft (content) {\n\tthis.outro = content + this.outro;\n};\n\nChunk.prototype.prependRight = function prependRight (content) {\n\tthis.intro = content + this.intro;\n};\n\nChunk.prototype.split = function split (index) {\n\tvar sliceIndex = index - this.start;\n\n\tvar originalBefore = this.original.slice(0, sliceIndex);\n\tvar originalAfter = this.original.slice(sliceIndex);\n\n\tthis.original = originalBefore;\n\n\tvar newChunk = new Chunk(index, this.end, originalAfter);\n\tnewChunk.outro = this.outro;\n\tthis.outro = '';\n\n\tthis.end = index;\n\n\tif (this.edited) {\n\t\t// TODO is this block necessary?...\n\t\tnewChunk.edit('', false);\n\t\tthis.content = '';\n\t} else {\n\t\tthis.content = originalBefore;\n\t}\n\n\tnewChunk.next = this.next;\n\tif (newChunk.next) { newChunk.next.previous = newChunk; }\n\tnewChunk.previous = this;\n\tthis.next = newChunk;\n\n\treturn newChunk;\n};\n\nChunk.prototype.toString = function toString () {\n\treturn this.intro + this.content + this.outro;\n};\n\nChunk.prototype.trimEnd = function trimEnd (rx) {\n\tthis.outro = this.outro.replace(rx, '');\n\tif (this.outro.length) { return true; }\n\n\tvar trimmed = this.content.replace(rx, '');\n\n\tif (trimmed.length) {\n\t\tif (trimmed !== this.content) {\n\t\t\tthis.split(this.start + trimmed.length).edit('', undefined, true);\n\t\t}\n\t\treturn true;\n\n\t} else {\n\t\tthis.edit('', undefined, true);\n\n\t\tthis.intro = this.intro.replace(rx, '');\n\t\tif (this.intro.length) { return true; }\n\t}\n};\n\nChunk.prototype.trimStart = function trimStart (rx) {\n\tthis.intro = this.intro.replace(rx, '');\n\tif (this.intro.length) { return true; }\n\n\tvar trimmed = this.content.replace(rx, '');\n\n\tif (trimmed.length) {\n\t\tif (trimmed !== this.content) {\n\t\t\tthis.split(this.end - trimmed.length);\n\t\t\tthis.edit('', undefined, true);\n\t\t}\n\t\treturn true;\n\n\t} else {\n\t\tthis.edit('', undefined, true);\n\n\t\tthis.outro = this.outro.replace(rx, '');\n\t\tif (this.outro.length) { return true; }\n\t}\n};\n\nvar btoa = function () {\n\tthrow new Error('Unsupported environment: `window.btoa` or `Buffer` should be supported.');\n};\nif (typeof window !== 'undefined' && typeof window.btoa === 'function') {\n\tbtoa = function (str) { return window.btoa(unescape(encodeURIComponent(str))); };\n} else if (typeof Buffer === 'function') {\n\tbtoa = function (str) { return Buffer.from(str, 'utf-8').toString('base64'); };\n}\n\nvar SourceMap = function SourceMap(properties) {\n\tthis.version = 3;\n\tthis.file = properties.file;\n\tthis.sources = properties.sources;\n\tthis.sourcesContent = properties.sourcesContent;\n\tthis.names = properties.names;\n\tthis.mappings = encode(properties.mappings);\n};\n\nSourceMap.prototype.toString = function toString () {\n\treturn JSON.stringify(this);\n};\n\nSourceMap.prototype.toUrl = function toUrl () {\n\treturn 'data:application/json;charset=utf-8;base64,' + btoa(this.toString());\n};\n\nfunction guessIndent(code) {\n\tvar lines = code.split('\\n');\n\n\tvar tabbed = lines.filter(function (line) { return /^\\t+/.test(line); });\n\tvar spaced = lines.filter(function (line) { return /^ {2,}/.test(line); });\n\n\tif (tabbed.length === 0 && spaced.length === 0) {\n\t\treturn null;\n\t}\n\n\t// More lines tabbed than spaced? Assume tabs, and\n\t// default to tabs in the case of a tie (or nothing\n\t// to go on)\n\tif (tabbed.length >= spaced.length) {\n\t\treturn '\\t';\n\t}\n\n\t// Otherwise, we need to guess the multiple\n\tvar min = spaced.reduce(function (previous, current) {\n\t\tvar numSpaces = /^ +/.exec(current)[0].length;\n\t\treturn Math.min(numSpaces, previous);\n\t}, Infinity);\n\n\treturn new Array(min + 1).join(' ');\n}\n\nfunction getRelativePath(from, to) {\n\tvar fromParts = from.split(/[/\\\\]/);\n\tvar toParts = to.split(/[/\\\\]/);\n\n\tfromParts.pop(); // get dirname\n\n\twhile (fromParts[0] === toParts[0]) {\n\t\tfromParts.shift();\n\t\ttoParts.shift();\n\t}\n\n\tif (fromParts.length) {\n\t\tvar i = fromParts.length;\n\t\twhile (i--) { fromParts[i] = '..'; }\n\t}\n\n\treturn fromParts.concat(toParts).join('/');\n}\n\nvar toString = Object.prototype.toString;\n\nfunction isObject(thing) {\n\treturn toString.call(thing) === '[object Object]';\n}\n\nfunction getLocator(source) {\n\tvar originalLines = source.split('\\n');\n\tvar lineOffsets = [];\n\n\tfor (var i = 0, pos = 0; i < originalLines.length; i++) {\n\t\tlineOffsets.push(pos);\n\t\tpos += originalLines[i].length + 1;\n\t}\n\n\treturn function locate(index) {\n\t\tvar i = 0;\n\t\tvar j = lineOffsets.length;\n\t\twhile (i < j) {\n\t\t\tvar m = (i + j) >> 1;\n\t\t\tif (index < lineOffsets[m]) {\n\t\t\t\tj = m;\n\t\t\t} else {\n\t\t\t\ti = m + 1;\n\t\t\t}\n\t\t}\n\t\tvar line = i - 1;\n\t\tvar column = index - lineOffsets[line];\n\t\treturn { line: line, column: column };\n\t};\n}\n\nvar Mappings = function Mappings(hires) {\n\tthis.hires = hires;\n\tthis.generatedCodeLine = 0;\n\tthis.generatedCodeColumn = 0;\n\tthis.raw = [];\n\tthis.rawSegments = this.raw[this.generatedCodeLine] = [];\n\tthis.pending = null;\n};\n\nMappings.prototype.addEdit = function addEdit (sourceIndex, content, loc, nameIndex) {\n\tif (content.length) {\n\t\tvar segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];\n\t\tif (nameIndex >= 0) {\n\t\t\tsegment.push(nameIndex);\n\t\t}\n\t\tthis.rawSegments.push(segment);\n\t} else if (this.pending) {\n\t\tthis.rawSegments.push(this.pending);\n\t}\n\n\tthis.advance(content);\n\tthis.pending = null;\n};\n\nMappings.prototype.addUneditedChunk = function addUneditedChunk (sourceIndex, chunk, original, loc, sourcemapLocations) {\n\tvar originalCharIndex = chunk.start;\n\tvar first = true;\n\n\twhile (originalCharIndex < chunk.end) {\n\t\tif (this.hires || first || sourcemapLocations.has(originalCharIndex)) {\n\t\t\tthis.rawSegments.push([this.generatedCodeColumn, sourceIndex, loc.line, loc.column]);\n\t\t}\n\n\t\tif (original[originalCharIndex] === '\\n') {\n\t\t\tloc.line += 1;\n\t\t\tloc.column = 0;\n\t\t\tthis.generatedCodeLine += 1;\n\t\t\tthis.raw[this.generatedCodeLine] = this.rawSegments = [];\n\t\t\tthis.generatedCodeColumn = 0;\n\t\t\tfirst = true;\n\t\t} else {\n\t\t\tloc.column += 1;\n\t\t\tthis.generatedCodeColumn += 1;\n\t\t\tfirst = false;\n\t\t}\n\n\t\toriginalCharIndex += 1;\n\t}\n\n\tthis.pending = null;\n};\n\nMappings.prototype.advance = function advance (str) {\n\tif (!str) { return; }\n\n\tvar lines = str.split('\\n');\n\n\tif (lines.length > 1) {\n\t\tfor (var i = 0; i < lines.length - 1; i++) {\n\t\t\tthis.generatedCodeLine++;\n\t\t\tthis.raw[this.generatedCodeLine] = this.rawSegments = [];\n\t\t}\n\t\tthis.generatedCodeColumn = 0;\n\t}\n\n\tthis.generatedCodeColumn += lines[lines.length - 1].length;\n};\n\nvar n = '\\n';\n\nvar warned = {\n\tinsertLeft: false,\n\tinsertRight: false,\n\tstoreName: false\n};\n\nvar MagicString = function MagicString(string, options) {\n\tif ( options === void 0 ) options = {};\n\n\tvar chunk = new Chunk(0, string.length, string);\n\n\tObject.defineProperties(this, {\n\t\toriginal:              { writable: true, value: string },\n\t\toutro:                 { writable: true, value: '' },\n\t\tintro:                 { writable: true, value: '' },\n\t\tfirstChunk:            { writable: true, value: chunk },\n\t\tlastChunk:             { writable: true, value: chunk },\n\t\tlastSearchedChunk:     { writable: true, value: chunk },\n\t\tbyStart:               { writable: true, value: {} },\n\t\tbyEnd:                 { writable: true, value: {} },\n\t\tfilename:              { writable: true, value: options.filename },\n\t\tindentExclusionRanges: { writable: true, value: options.indentExclusionRanges },\n\t\tsourcemapLocations:    { writable: true, value: new BitSet() },\n\t\tstoredNames:           { writable: true, value: {} },\n\t\tindentStr:             { writable: true, value: guessIndent(string) }\n\t});\n\n\tthis.byStart[0] = chunk;\n\tthis.byEnd[string.length] = chunk;\n};\n\nMagicString.prototype.addSourcemapLocation = function addSourcemapLocation (char) {\n\tthis.sourcemapLocations.add(char);\n};\n\nMagicString.prototype.append = function append (content) {\n\tif (typeof content !== 'string') { throw new TypeError('outro content must be a string'); }\n\n\tthis.outro += content;\n\treturn this;\n};\n\nMagicString.prototype.appendLeft = function appendLeft (index, content) {\n\tif (typeof content !== 'string') { throw new TypeError('inserted content must be a string'); }\n\n\tthis._split(index);\n\n\tvar chunk = this.byEnd[index];\n\n\tif (chunk) {\n\t\tchunk.appendLeft(content);\n\t} else {\n\t\tthis.intro += content;\n\t}\n\treturn this;\n};\n\nMagicString.prototype.appendRight = function appendRight (index, content) {\n\tif (typeof content !== 'string') { throw new TypeError('inserted content must be a string'); }\n\n\tthis._split(index);\n\n\tvar chunk = this.byStart[index];\n\n\tif (chunk) {\n\t\tchunk.appendRight(content);\n\t} else {\n\t\tthis.outro += content;\n\t}\n\treturn this;\n};\n\nMagicString.prototype.clone = function clone () {\n\tvar cloned = new MagicString(this.original, { filename: this.filename });\n\n\tvar originalChunk = this.firstChunk;\n\tvar clonedChunk = (cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone());\n\n\twhile (originalChunk) {\n\t\tcloned.byStart[clonedChunk.start] = clonedChunk;\n\t\tcloned.byEnd[clonedChunk.end] = clonedChunk;\n\n\t\tvar nextOriginalChunk = originalChunk.next;\n\t\tvar nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();\n\n\t\tif (nextClonedChunk) {\n\t\t\tclonedChunk.next = nextClonedChunk;\n\t\t\tnextClonedChunk.previous = clonedChunk;\n\n\t\t\tclonedChunk = nextClonedChunk;\n\t\t}\n\n\t\toriginalChunk = nextOriginalChunk;\n\t}\n\n\tcloned.lastChunk = clonedChunk;\n\n\tif (this.indentExclusionRanges) {\n\t\tcloned.indentExclusionRanges = this.indentExclusionRanges.slice();\n\t}\n\n\tcloned.sourcemapLocations = new BitSet(this.sourcemapLocations);\n\n\tcloned.intro = this.intro;\n\tcloned.outro = this.outro;\n\n\treturn cloned;\n};\n\nMagicString.prototype.generateDecodedMap = function generateDecodedMap (options) {\n\t\tvar this$1 = this;\n\n\toptions = options || {};\n\n\tvar sourceIndex = 0;\n\tvar names = Object.keys(this.storedNames);\n\tvar mappings = new Mappings(options.hires);\n\n\tvar locate = getLocator(this.original);\n\n\tif (this.intro) {\n\t\tmappings.advance(this.intro);\n\t}\n\n\tthis.firstChunk.eachNext(function (chunk) {\n\t\tvar loc = locate(chunk.start);\n\n\t\tif (chunk.intro.length) { mappings.advance(chunk.intro); }\n\n\t\tif (chunk.edited) {\n\t\t\tmappings.addEdit(\n\t\t\t\tsourceIndex,\n\t\t\t\tchunk.content,\n\t\t\t\tloc,\n\t\t\t\tchunk.storeName ? names.indexOf(chunk.original) : -1\n\t\t\t);\n\t\t} else {\n\t\t\tmappings.addUneditedChunk(sourceIndex, chunk, this$1.original, loc, this$1.sourcemapLocations);\n\t\t}\n\n\t\tif (chunk.outro.length) { mappings.advance(chunk.outro); }\n\t});\n\n\treturn {\n\t\tfile: options.file ? options.file.split(/[/\\\\]/).pop() : null,\n\t\tsources: [options.source ? getRelativePath(options.file || '', options.source) : null],\n\t\tsourcesContent: options.includeContent ? [this.original] : [null],\n\t\tnames: names,\n\t\tmappings: mappings.raw\n\t};\n};\n\nMagicString.prototype.generateMap = function generateMap (options) {\n\treturn new SourceMap(this.generateDecodedMap(options));\n};\n\nMagicString.prototype.getIndentString = function getIndentString () {\n\treturn this.indentStr === null ? '\\t' : this.indentStr;\n};\n\nMagicString.prototype.indent = function indent (indentStr, options) {\n\tvar pattern = /^[^\\r\\n]/gm;\n\n\tif (isObject(indentStr)) {\n\t\toptions = indentStr;\n\t\tindentStr = undefined;\n\t}\n\n\tindentStr = indentStr !== undefined ? indentStr : this.indentStr || '\\t';\n\n\tif (indentStr === '') { return this; } // noop\n\n\toptions = options || {};\n\n\t// Process exclusion ranges\n\tvar isExcluded = {};\n\n\tif (options.exclude) {\n\t\tvar exclusions =\n\t\t\ttypeof options.exclude[0] === 'number' ? [options.exclude] : options.exclude;\n\t\texclusions.forEach(function (exclusion) {\n\t\t\tfor (var i = exclusion[0]; i < exclusion[1]; i += 1) {\n\t\t\t\tisExcluded[i] = true;\n\t\t\t}\n\t\t});\n\t}\n\n\tvar shouldIndentNextCharacter = options.indentStart !== false;\n\tvar replacer = function (match) {\n\t\tif (shouldIndentNextCharacter) { return (\"\" + indentStr + match); }\n\t\tshouldIndentNextCharacter = true;\n\t\treturn match;\n\t};\n\n\tthis.intro = this.intro.replace(pattern, replacer);\n\n\tvar charIndex = 0;\n\tvar chunk = this.firstChunk;\n\n\twhile (chunk) {\n\t\tvar end = chunk.end;\n\n\t\tif (chunk.edited) {\n\t\t\tif (!isExcluded[charIndex]) {\n\t\t\t\tchunk.content = chunk.content.replace(pattern, replacer);\n\n\t\t\t\tif (chunk.content.length) {\n\t\t\t\t\tshouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === '\\n';\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tcharIndex = chunk.start;\n\n\t\t\twhile (charIndex < end) {\n\t\t\t\tif (!isExcluded[charIndex]) {\n\t\t\t\t\tvar char = this.original[charIndex];\n\n\t\t\t\t\tif (char === '\\n') {\n\t\t\t\t\t\tshouldIndentNextCharacter = true;\n\t\t\t\t\t} else if (char !== '\\r' && shouldIndentNextCharacter) {\n\t\t\t\t\t\tshouldIndentNextCharacter = false;\n\n\t\t\t\t\t\tif (charIndex === chunk.start) {\n\t\t\t\t\t\t\tchunk.prependRight(indentStr);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis._splitChunk(chunk, charIndex);\n\t\t\t\t\t\t\tchunk = chunk.next;\n\t\t\t\t\t\t\tchunk.prependRight(indentStr);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tcharIndex += 1;\n\t\t\t}\n\t\t}\n\n\t\tcharIndex = chunk.end;\n\t\tchunk = chunk.next;\n\t}\n\n\tthis.outro = this.outro.replace(pattern, replacer);\n\n\treturn this;\n};\n\nMagicString.prototype.insert = function insert () {\n\tthrow new Error('magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)');\n};\n\nMagicString.prototype.insertLeft = function insertLeft (index, content) {\n\tif (!warned.insertLeft) {\n\t\tconsole.warn('magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead'); // eslint-disable-line no-console\n\t\twarned.insertLeft = true;\n\t}\n\n\treturn this.appendLeft(index, content);\n};\n\nMagicString.prototype.insertRight = function insertRight (index, content) {\n\tif (!warned.insertRight) {\n\t\tconsole.warn('magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead'); // eslint-disable-line no-console\n\t\twarned.insertRight = true;\n\t}\n\n\treturn this.prependRight(index, content);\n};\n\nMagicString.prototype.move = function move (start, end, index) {\n\tif (index >= start && index <= end) { throw new Error('Cannot move a selection inside itself'); }\n\n\tthis._split(start);\n\tthis._split(end);\n\tthis._split(index);\n\n\tvar first = this.byStart[start];\n\tvar last = this.byEnd[end];\n\n\tvar oldLeft = first.previous;\n\tvar oldRight = last.next;\n\n\tvar newRight = this.byStart[index];\n\tif (!newRight && last === this.lastChunk) { return this; }\n\tvar newLeft = newRight ? newRight.previous : this.lastChunk;\n\n\tif (oldLeft) { oldLeft.next = oldRight; }\n\tif (oldRight) { oldRight.previous = oldLeft; }\n\n\tif (newLeft) { newLeft.next = first; }\n\tif (newRight) { newRight.previous = last; }\n\n\tif (!first.previous) { this.firstChunk = last.next; }\n\tif (!last.next) {\n\t\tthis.lastChunk = first.previous;\n\t\tthis.lastChunk.next = null;\n\t}\n\n\tfirst.previous = newLeft;\n\tlast.next = newRight || null;\n\n\tif (!newLeft) { this.firstChunk = first; }\n\tif (!newRight) { this.lastChunk = last; }\n\treturn this;\n};\n\nMagicString.prototype.overwrite = function overwrite (start, end, content, options) {\n\tif (typeof content !== 'string') { throw new TypeError('replacement content must be a string'); }\n\n\twhile (start < 0) { start += this.original.length; }\n\twhile (end < 0) { end += this.original.length; }\n\n\tif (end > this.original.length) { throw new Error('end is out of bounds'); }\n\tif (start === end)\n\t\t{ throw new Error('Cannot overwrite a zero-length range \u2013 use appendLeft or prependRight instead'); }\n\n\tthis._split(start);\n\tthis._split(end);\n\n\tif (options === true) {\n\t\tif (!warned.storeName) {\n\t\t\tconsole.warn('The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string'); // eslint-disable-line no-console\n\t\t\twarned.storeName = true;\n\t\t}\n\n\t\toptions = { storeName: true };\n\t}\n\tvar storeName = options !== undefined ? options.storeName : false;\n\tvar contentOnly = options !== undefined ? options.contentOnly : false;\n\n\tif (storeName) {\n\t\tvar original = this.original.slice(start, end);\n\t\tthis.storedNames[original] = true;\n\t}\n\n\tvar first = this.byStart[start];\n\tvar last = this.byEnd[end];\n\n\tif (first) {\n\t\tif (end > first.end && first.next !== this.byStart[first.end]) {\n\t\t\tthrow new Error('Cannot overwrite across a split point');\n\t\t}\n\n\t\tfirst.edit(content, storeName, contentOnly);\n\n\t\tif (first !== last) {\n\t\t\tvar chunk = first.next;\n\t\t\twhile (chunk !== last) {\n\t\t\t\tchunk.edit('', false);\n\t\t\t\tchunk = chunk.next;\n\t\t\t}\n\n\t\t\tchunk.edit('', false);\n\t\t}\n\t} else {\n\t\t// must be inserting at the end\n\t\tvar newChunk = new Chunk(start, end, '').edit(content, storeName);\n\n\t\t// TODO last chunk in the array may not be the last chunk, if it's moved...\n\t\tlast.next = newChunk;\n\t\tnewChunk.previous = last;\n\t}\n\treturn this;\n};\n\nMagicString.prototype.prepend = function prepend (content) {\n\tif (typeof content !== 'string') { throw new TypeError('outro content must be a string'); }\n\n\tthis.intro = content + this.intro;\n\treturn this;\n};\n\nMagicString.prototype.prependLeft = function prependLeft (index, content) {\n\tif (typeof content !== 'string') { throw new TypeError('inserted content must be a string'); }\n\n\tthis._split(index);\n\n\tvar chunk = this.byEnd[index];\n\n\tif (chunk) {\n\t\tchunk.prependLeft(content);\n\t} else {\n\t\tthis.intro = content + this.intro;\n\t}\n\treturn this;\n};\n\nMagicString.prototype.prependRight = function prependRight (index, content) {\n\tif (typeof content !== 'string') { throw new TypeError('inserted content must be a string'); }\n\n\tthis._split(index);\n\n\tvar chunk = this.byStart[index];\n\n\tif (chunk) {\n\t\tchunk.prependRight(content);\n\t} else {\n\t\tthis.outro = content + this.outro;\n\t}\n\treturn this;\n};\n\nMagicString.prototype.remove = function remove (start, end) {\n\twhile (start < 0) { start += this.original.length; }\n\twhile (end < 0) { end += this.original.length; }\n\n\tif (start === end) { return this; }\n\n\tif (start < 0 || end > this.original.length) { throw new Error('Character is out of bounds'); }\n\tif (start > end) { throw new Error('end must be greater than start'); }\n\n\tthis._split(start);\n\tthis._split(end);\n\n\tvar chunk = this.byStart[start];\n\n\twhile (chunk) {\n\t\tchunk.intro = '';\n\t\tchunk.outro = '';\n\t\tchunk.edit('');\n\n\t\tchunk = end > chunk.end ? this.byStart[chunk.end] : null;\n\t}\n\treturn this;\n};\n\nMagicString.prototype.lastChar = function lastChar () {\n\tif (this.outro.length)\n\t\t{ return this.outro[this.outro.length - 1]; }\n\tvar chunk = this.lastChunk;\n\tdo {\n\t\tif (chunk.outro.length)\n\t\t\t{ return chunk.outro[chunk.outro.length - 1]; }\n\t\tif (chunk.content.length)\n\t\t\t{ return chunk.content[chunk.content.length - 1]; }\n\t\tif (chunk.intro.length)\n\t\t\t{ return chunk.intro[chunk.intro.length - 1]; }\n\t} while (chunk = chunk.previous);\n\tif (this.intro.length)\n\t\t{ return this.intro[this.intro.length - 1]; }\n\treturn '';\n};\n\nMagicString.prototype.lastLine = function lastLine () {\n\tvar lineIndex = this.outro.lastIndexOf(n);\n\tif (lineIndex !== -1)\n\t\t{ return this.outro.substr(lineIndex + 1); }\n\tvar lineStr = this.outro;\n\tvar chunk = this.lastChunk;\n\tdo {\n\t\tif (chunk.outro.length > 0) {\n\t\t\tlineIndex = chunk.outro.lastIndexOf(n);\n\t\t\tif (lineIndex !== -1)\n\t\t\t\t{ return chunk.outro.substr(lineIndex + 1) + lineStr; }\n\t\t\tlineStr = chunk.outro + lineStr;\n\t\t}\n\n\t\tif (chunk.content.length > 0) {\n\t\t\tlineIndex = chunk.content.lastIndexOf(n);\n\t\t\tif (lineIndex !== -1)\n\t\t\t\t{ return chunk.content.substr(lineIndex + 1) + lineStr; }\n\t\t\tlineStr = chunk.content + lineStr;\n\t\t}\n\n\t\tif (chunk.intro.length > 0) {\n\t\t\tlineIndex = chunk.intro.lastIndexOf(n);\n\t\t\tif (lineIndex !== -1)\n\t\t\t\t{ return chunk.intro.substr(lineIndex + 1) + lineStr; }\n\t\t\tlineStr = chunk.intro + lineStr;\n\t\t}\n\t} while (chunk = chunk.previous);\n\tlineIndex = this.intro.lastIndexOf(n);\n\tif (lineIndex !== -1)\n\t\t{ return this.intro.substr(lineIndex + 1) + lineStr; }\n\treturn this.intro + lineStr;\n};\n\nMagicString.prototype.slice = function slice (start, end) {\n\t\tif ( start === void 0 ) start = 0;\n\t\tif ( end === void 0 ) end = this.original.length;\n\n\twhile (start < 0) { start += this.original.length; }\n\twhile (end < 0) { end += this.original.length; }\n\n\tvar result = '';\n\n\t// find start chunk\n\tvar chunk = this.firstChunk;\n\twhile (chunk && (chunk.start > start || chunk.end <= start)) {\n\t\t// found end chunk before start\n\t\tif (chunk.start < end && chunk.end >= end) {\n\t\t\treturn result;\n\t\t}\n\n\t\tchunk = chunk.next;\n\t}\n\n\tif (chunk && chunk.edited && chunk.start !== start)\n\t\t{ throw new Error((\"Cannot use replaced character \" + start + \" as slice start anchor.\")); }\n\n\tvar startChunk = chunk;\n\twhile (chunk) {\n\t\tif (chunk.intro && (startChunk !== chunk || chunk.start === start)) {\n\t\t\tresult += chunk.intro;\n\t\t}\n\n\t\tvar containsEnd = chunk.start < end && chunk.end >= end;\n\t\tif (containsEnd && chunk.edited && chunk.end !== end)\n\t\t\t{ throw new Error((\"Cannot use replaced character \" + end + \" as slice end anchor.\")); }\n\n\t\tvar sliceStart = startChunk === chunk ? start - chunk.start : 0;\n\t\tvar sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;\n\n\t\tresult += chunk.content.slice(sliceStart, sliceEnd);\n\n\t\tif (chunk.outro && (!containsEnd || chunk.end === end)) {\n\t\t\tresult += chunk.outro;\n\t\t}\n\n\t\tif (containsEnd) {\n\t\t\tbreak;\n\t\t}\n\n\t\tchunk = chunk.next;\n\t}\n\n\treturn result;\n};\n\n// TODO deprecate this? not really very useful\nMagicString.prototype.snip = function snip (start, end) {\n\tvar clone = this.clone();\n\tclone.remove(0, start);\n\tclone.remove(end, clone.original.length);\n\n\treturn clone;\n};\n\nMagicString.prototype._split = function _split (index) {\n\tif (this.byStart[index] || this.byEnd[index]) { return; }\n\n\tvar chunk = this.lastSearchedChunk;\n\tvar searchForward = index > chunk.end;\n\n\twhile (chunk) {\n\t\tif (chunk.contains(index)) { return this._splitChunk(chunk, index); }\n\n\t\tchunk = searchForward ? this.byStart[chunk.end] : this.byEnd[chunk.start];\n\t}\n};\n\nMagicString.prototype._splitChunk = function _splitChunk (chunk, index) {\n\tif (chunk.edited && chunk.content.length) {\n\t\t// zero-length edited chunks are a special case (overlapping replacements)\n\t\tvar loc = getLocator(this.original)(index);\n\t\tthrow new Error(\n\t\t\t(\"Cannot split a chunk that has already been edited (\" + (loc.line) + \":\" + (loc.column) + \" \u2013 \\\"\" + (chunk.original) + \"\\\")\")\n\t\t);\n\t}\n\n\tvar newChunk = chunk.split(index);\n\n\tthis.byEnd[index] = chunk;\n\tthis.byStart[index] = newChunk;\n\tthis.byEnd[newChunk.end] = newChunk;\n\n\tif (chunk === this.lastChunk) { this.lastChunk = newChunk; }\n\n\tthis.lastSearchedChunk = chunk;\n\treturn true;\n};\n\nMagicString.prototype.toString = function toString () {\n\tvar str = this.intro;\n\n\tvar chunk = this.firstChunk;\n\twhile (chunk) {\n\t\tstr += chunk.toString();\n\t\tchunk = chunk.next;\n\t}\n\n\treturn str + this.outro;\n};\n\nMagicString.prototype.isEmpty = function isEmpty () {\n\tvar chunk = this.firstChunk;\n\tdo {\n\t\tif (chunk.intro.length && chunk.intro.trim() ||\n\t\t\t\tchunk.content.length && chunk.content.trim() ||\n\t\t\t\tchunk.outro.length && chunk.outro.trim())\n\t\t\t{ return false; }\n\t} while (chunk = chunk.next);\n\treturn true;\n};\n\nMagicString.prototype.length = function length () {\n\tvar chunk = this.firstChunk;\n\tvar length = 0;\n\tdo {\n\t\tlength += chunk.intro.length + chunk.content.length + chunk.outro.length;\n\t} while (chunk = chunk.next);\n\treturn length;\n};\n\nMagicString.prototype.trimLines = function trimLines () {\n\treturn this.trim('[\\\\r\\\\n]');\n};\n\nMagicString.prototype.trim = function trim (charType) {\n\treturn this.trimStart(charType).trimEnd(charType);\n};\n\nMagicString.prototype.trimEndAborted = function trimEndAborted (charType) {\n\tvar rx = new RegExp((charType || '\\\\s') + '+$');\n\n\tthis.outro = this.outro.replace(rx, '');\n\tif (this.outro.length) { return true; }\n\n\tvar chunk = this.lastChunk;\n\n\tdo {\n\t\tvar end = chunk.end;\n\t\tvar aborted = chunk.trimEnd(rx);\n\n\t\t// if chunk was trimmed, we have a new lastChunk\n\t\tif (chunk.end !== end) {\n\t\t\tif (this.lastChunk === chunk) {\n\t\t\t\tthis.lastChunk = chunk.next;\n\t\t\t}\n\n\t\t\tthis.byEnd[chunk.end] = chunk;\n\t\t\tthis.byStart[chunk.next.start] = chunk.next;\n\t\t\tthis.byEnd[chunk.next.end] = chunk.next;\n\t\t}\n\n\t\tif (aborted) { return true; }\n\t\tchunk = chunk.previous;\n\t} while (chunk);\n\n\treturn false;\n};\n\nMagicString.prototype.trimEnd = function trimEnd (charType) {\n\tthis.trimEndAborted(charType);\n\treturn this;\n};\nMagicString.prototype.trimStartAborted = function trimStartAborted (charType) {\n\tvar rx = new RegExp('^' + (charType || '\\\\s') + '+');\n\n\tthis.intro = this.intro.replace(rx, '');\n\tif (this.intro.length) { return true; }\n\n\tvar chunk = this.firstChunk;\n\n\tdo {\n\t\tvar end = chunk.end;\n\t\tvar aborted = chunk.trimStart(rx);\n\n\t\tif (chunk.end !== end) {\n\t\t\t// special case...\n\t\t\tif (chunk === this.lastChunk) { this.lastChunk = chunk.next; }\n\n\t\t\tthis.byEnd[chunk.end] = chunk;\n\t\t\tthis.byStart[chunk.next.start] = chunk.next;\n\t\t\tthis.byEnd[chunk.next.end] = chunk.next;\n\t\t}\n\n\t\tif (aborted) { return true; }\n\t\tchunk = chunk.next;\n\t} while (chunk);\n\n\treturn false;\n};\n\nMagicString.prototype.trimStart = function trimStart (charType) {\n\tthis.trimStartAborted(charType);\n\treturn this;\n};\n\nvar hasOwnProp = Object.prototype.hasOwnProperty;\n\nvar Bundle = function Bundle(options) {\n\tif ( options === void 0 ) options = {};\n\n\tthis.intro = options.intro || '';\n\tthis.separator = options.separator !== undefined ? options.separator : '\\n';\n\tthis.sources = [];\n\tthis.uniqueSources = [];\n\tthis.uniqueSourceIndexByFilename = {};\n};\n\nBundle.prototype.addSource = function addSource (source) {\n\tif (source instanceof MagicString) {\n\t\treturn this.addSource({\n\t\t\tcontent: source,\n\t\t\tfilename: source.filename,\n\t\t\tseparator: this.separator\n\t\t});\n\t}\n\n\tif (!isObject(source) || !source.content) {\n\t\tthrow new Error('bundle.addSource() takes an object with a `content` property, which should be an instance of MagicString, and an optional `filename`');\n\t}\n\n\t['filename', 'indentExclusionRanges', 'separator'].forEach(function (option) {\n\t\tif (!hasOwnProp.call(source, option)) { source[option] = source.content[option]; }\n\t});\n\n\tif (source.separator === undefined) {\n\t\t// TODO there's a bunch of this sort of thing, needs cleaning up\n\t\tsource.separator = this.separator;\n\t}\n\n\tif (source.filename) {\n\t\tif (!hasOwnProp.call(this.uniqueSourceIndexByFilename, source.filename)) {\n\t\t\tthis.uniqueSourceIndexByFilename[source.filename] = this.uniqueSources.length;\n\t\t\tthis.uniqueSources.push({ filename: source.filename, content: source.content.original });\n\t\t} else {\n\t\t\tvar uniqueSource = this.uniqueSources[this.uniqueSourceIndexByFilename[source.filename]];\n\t\t\tif (source.content.original !== uniqueSource.content) {\n\t\t\t\tthrow new Error((\"Illegal source: same filename (\" + (source.filename) + \"), different contents\"));\n\t\t\t}\n\t\t}\n\t}\n\n\tthis.sources.push(source);\n\treturn this;\n};\n\nBundle.prototype.append = function append (str, options) {\n\tthis.addSource({\n\t\tcontent: new MagicString(str),\n\t\tseparator: (options && options.separator) || ''\n\t});\n\n\treturn this;\n};\n\nBundle.prototype.clone = function clone () {\n\tvar bundle = new Bundle({\n\t\tintro: this.intro,\n\t\tseparator: this.separator\n\t});\n\n\tthis.sources.forEach(function (source) {\n\t\tbundle.addSource({\n\t\t\tfilename: source.filename,\n\t\t\tcontent: source.content.clone(),\n\t\t\tseparator: source.separator\n\t\t});\n\t});\n\n\treturn bundle;\n};\n\nBundle.prototype.generateDecodedMap = function generateDecodedMap (options) {\n\t\tvar this$1 = this;\n\t\tif ( options === void 0 ) options = {};\n\n\tvar names = [];\n\tthis.sources.forEach(function (source) {\n\t\tObject.keys(source.content.storedNames).forEach(function (name) {\n\t\t\tif (!~names.indexOf(name)) { names.push(name); }\n\t\t});\n\t});\n\n\tvar mappings = new Mappings(options.hires);\n\n\tif (this.intro) {\n\t\tmappings.advance(this.intro);\n\t}\n\n\tthis.sources.forEach(function (source, i) {\n\t\tif (i > 0) {\n\t\t\tmappings.advance(this$1.separator);\n\t\t}\n\n\t\tvar sourceIndex = source.filename ? this$1.uniqueSourceIndexByFilename[source.filename] : -1;\n\t\tvar magicString = source.content;\n\t\tvar locate = getLocator(magicString.original);\n\n\t\tif (magicString.intro) {\n\t\t\tmappings.advance(magicString.intro);\n\t\t}\n\n\t\tmagicString.firstChunk.eachNext(function (chunk) {\n\t\t\tvar loc = locate(chunk.start);\n\n\t\t\tif (chunk.intro.length) { mappings.advance(chunk.intro); }\n\n\t\t\tif (source.filename) {\n\t\t\t\tif (chunk.edited) {\n\t\t\t\t\tmappings.addEdit(\n\t\t\t\t\t\tsourceIndex,\n\t\t\t\t\t\tchunk.content,\n\t\t\t\t\t\tloc,\n\t\t\t\t\t\tchunk.storeName ? names.indexOf(chunk.original) : -1\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tmappings.addUneditedChunk(\n\t\t\t\t\t\tsourceIndex,\n\t\t\t\t\t\tchunk,\n\t\t\t\t\t\tmagicString.original,\n\t\t\t\t\t\tloc,\n\t\t\t\t\t\tmagicString.sourcemapLocations\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tmappings.advance(chunk.content);\n\t\t\t}\n\n\t\t\tif (chunk.outro.length) { mappings.advance(chunk.outro); }\n\t\t});\n\n\t\tif (magicString.outro) {\n\t\t\tmappings.advance(magicString.outro);\n\t\t}\n\t});\n\n\treturn {\n\t\tfile: options.file ? options.file.split(/[/\\\\]/).pop() : null,\n\t\tsources: this.uniqueSources.map(function (source) {\n\t\t\treturn options.file ? getRelativePath(options.file, source.filename) : source.filename;\n\t\t}),\n\t\tsourcesContent: this.uniqueSources.map(function (source) {\n\t\t\treturn options.includeContent ? source.content : null;\n\t\t}),\n\t\tnames: names,\n\t\tmappings: mappings.raw\n\t};\n};\n\nBundle.prototype.generateMap = function generateMap (options) {\n\treturn new SourceMap(this.generateDecodedMap(options));\n};\n\nBundle.prototype.getIndentString = function getIndentString () {\n\tvar indentStringCounts = {};\n\n\tthis.sources.forEach(function (source) {\n\t\tvar indentStr = source.content.indentStr;\n\n\t\tif (indentStr === null) { return; }\n\n\t\tif (!indentStringCounts[indentStr]) { indentStringCounts[indentStr] = 0; }\n\t\tindentStringCounts[indentStr] += 1;\n\t});\n\n\treturn (\n\t\tObject.keys(indentStringCounts).sort(function (a, b) {\n\t\t\treturn indentStringCounts[a] - indentStringCounts[b];\n\t\t})[0] || '\\t'\n\t);\n};\n\nBundle.prototype.indent = function indent (indentStr) {\n\t\tvar this$1 = this;\n\n\tif (!arguments.length) {\n\t\tindentStr = this.getIndentString();\n\t}\n\n\tif (indentStr === '') { return this; } // noop\n\n\tvar trailingNewline = !this.intro || this.intro.slice(-1) === '\\n';\n\n\tthis.sources.forEach(function (source, i) {\n\t\tvar separator = source.separator !== undefined ? source.separator : this$1.separator;\n\t\tvar indentStart = trailingNewline || (i > 0 && /\\r?\\n$/.test(separator));\n\n\t\tsource.content.indent(indentStr, {\n\t\t\texclude: source.indentExclusionRanges,\n\t\t\tindentStart: indentStart //: trailingNewline || /\\r?\\n$/.test( separator )  //true///\\r?\\n/.test( separator )\n\t\t});\n\n\t\ttrailingNewline = source.content.lastChar() === '\\n';\n\t});\n\n\tif (this.intro) {\n\t\tthis.intro =\n\t\t\tindentStr +\n\t\t\tthis.intro.replace(/^[^\\n]/gm, function (match, index) {\n\t\t\t\treturn index > 0 ? indentStr + match : match;\n\t\t\t});\n\t}\n\n\treturn this;\n};\n\nBundle.prototype.prepend = function prepend (str) {\n\tthis.intro = str + this.intro;\n\treturn this;\n};\n\nBundle.prototype.toString = function toString () {\n\t\tvar this$1 = this;\n\n\tvar body = this.sources\n\t\t.map(function (source, i) {\n\t\t\tvar separator = source.separator !== undefined ? source.separator : this$1.separator;\n\t\t\tvar str = (i > 0 ? separator : '') + source.content.toString();\n\n\t\t\treturn str;\n\t\t})\n\t\t.join('');\n\n\treturn this.intro + body;\n};\n\nBundle.prototype.isEmpty = function isEmpty () {\n\tif (this.intro.length && this.intro.trim())\n\t\t{ return false; }\n\tif (this.sources.some(function (source) { return !source.content.isEmpty(); }))\n\t\t{ return false; }\n\treturn true;\n};\n\nBundle.prototype.length = function length () {\n\treturn this.sources.reduce(function (length, source) { return length + source.content.length(); }, this.intro.length);\n};\n\nBundle.prototype.trimLines = function trimLines () {\n\treturn this.trim('[\\\\r\\\\n]');\n};\n\nBundle.prototype.trim = function trim (charType) {\n\treturn this.trimStart(charType).trimEnd(charType);\n};\n\nBundle.prototype.trimStart = function trimStart (charType) {\n\tvar rx = new RegExp('^' + (charType || '\\\\s') + '+');\n\tthis.intro = this.intro.replace(rx, '');\n\n\tif (!this.intro) {\n\t\tvar source;\n\t\tvar i = 0;\n\n\t\tdo {\n\t\t\tsource = this.sources[i++];\n\t\t\tif (!source) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (!source.content.trimStartAborted(charType));\n\t}\n\n\treturn this;\n};\n\nBundle.prototype.trimEnd = function trimEnd (charType) {\n\tvar rx = new RegExp((charType || '\\\\s') + '+$');\n\n\tvar source;\n\tvar i = this.sources.length - 1;\n\n\tdo {\n\t\tsource = this.sources[i--];\n\t\tif (!source) {\n\t\t\tthis.intro = this.intro.replace(rx, '');\n\t\t\tbreak;\n\t\t}\n\t} while (!source.content.trimEndAborted(charType));\n\n\treturn this;\n};\n\nexport default MagicString;\nexport { Bundle, SourceMap };\n//# sourceMappingURL=magic-string.es.js.map\n", "import { Base64 } from '@velcro/common';\nimport { DecodedSourceMap } from 'magic-string';\nimport { decode } from 'sourcemap-codec';\n\nexport class SourceMap {\n  readonly file?: string;\n  readonly mappings: string;\n  readonly sourceRoot?: string;\n  readonly names: string[];\n  readonly sources: (string | null)[];\n  readonly sourcesContent?: (string | null)[];\n  readonly version: number;\n\n  constructor(input: {\n    file?: string;\n    mappings: string;\n    sourceRoot?: string;\n    names: string[];\n    sources: (string | null)[];\n    sourcesContent?: (string | null)[];\n    version: string | number;\n  }) {\n    this.file = input.file;\n    this.mappings = input.mappings;\n    this.sourceRoot = input.sourceRoot;\n    this.names = input.names;\n    this.sources = input.sources;\n    this.sourcesContent = input.sourcesContent;\n    this.version = input.version as number | 0;\n  }\n\n  toString() {\n    return JSON.stringify(this);\n  }\n\n  toDataUri() {\n    return `data:application/json;charset=utf-8;base64,${Base64.encode(this.toString())}`;\n  }\n}\n\nfunction getSourceMappingUrlMatch(str: string) {\n  const re = /(?:(?:\\/\\/|\\/\\*)[@#][\\s]*(?:source)MappingURL=([^\\s'\"]+)[\\s]*$)|(?:\\/\\*[@#][\\s]*(?:source)MappingURL=([^\\s*'\"]+)[\\s]*(?:\\*\\/)[\\s]*$)/gm;\n  // Keep executing the search to find the *last* sourceMappingURL to avoid\n  // picking up sourceMappingURLs from comments, strings, etc.\n  let lastMatch: RegExpExecArray | null = null;\n  let match: RegExpExecArray | null;\n\n  while ((match = re.exec(str))) lastMatch = match;\n\n  return lastMatch;\n}\n\nexport function getSourceMappingUrl(str: string) {\n  const lastMatch = getSourceMappingUrlMatch(str);\n\n  if (!lastMatch) return '';\n\n  return lastMatch[1];\n}\n\nexport function updateSourceMappingUrl(str: string, url: string) {\n  const lastMatch = getSourceMappingUrlMatch(str);\n\n  if (!lastMatch) return str;\n\n  return str.slice(0, lastMatch.index) + str.slice(lastMatch.index).replace(lastMatch[1], url);\n}\n\nexport function decodeDataUriAsSourceMap(href: string): DecodedSourceMap | null {\n  const match = href.match(/^data:application\\/json;(?:charset=([^;]+);)?base64,(.*)$/);\n\n  if (match) {\n    if (match[1] && match[1] !== 'utf-8') {\n      return null;\n    }\n\n    try {\n      const decoded = JSON.parse(Base64.decode(match[2]));\n\n      if (decoded.mappings === '') {\n        return {\n          file: '',\n          mappings: [],\n          names: [],\n          sources: [],\n          sourcesContent: [],\n        };\n      }\n\n      if (typeof decoded.mappings === 'string') {\n        decoded.mappings = decode(decoded.mappings);\n      }\n\n      return decoded;\n    } catch (err) {\n      return null;\n    }\n  }\n\n  return null;\n}\n", "import { SourceMapSegment } from 'magic-string';\nimport { decode } from 'sourcemap-codec';\n\nexport interface ISourceMapper {\n  traceMappings(): ReturnType<typeof traceMappings>;\n}\n\n/**\n * Copyright (c) Rollup 2020 authors: https://github.com/rollup/rollup/graphs/contributors)\n *\n * Copied with light modifications from:\n * https://github.com/rollup/rollup/blob/36a4527473ea1fe678ed866c9f8dfd3c2542cd22/src/utils/collapseSourcemaps.ts\n */\n\nexport class Source {\n  content: string | null;\n  filename: string;\n\n  constructor(filename: string, content: string | null) {\n    this.filename = filename;\n    this.content = content;\n  }\n\n  traceSegment(line: number, column: number, name?: string): SourceMapSegmentObject {\n    return { line, column, name, source: this };\n  }\n}\n\ninterface SourceMapSegmentObject {\n  column: number;\n  line: number;\n  name?: string;\n  source: Source;\n}\n\nexport class Link {\n  mappings: SourceMapSegment[][];\n  names: string[];\n  sources: (Source | Link)[];\n\n  constructor(\n    map: { mappings: SourceMapSegment[][] | string; names: string[] },\n    sources: (Source | Link)[]\n  ) {\n    this.sources = sources;\n    this.names = map.names;\n    this.mappings = typeof map.mappings === 'string' ? decode(map.mappings) : map.mappings;\n  }\n\n  traceMappings() {\n    return traceMappings(this);\n  }\n\n  traceSegment(line: number, column: number, name: string): SourceMapSegmentObject | null {\n    return traceSegment(this, line, column, name);\n  }\n}\n\nexport class LazyLink {\n  private link?: Link = undefined;\n\n  constructor(private readonly loadLink: () => Link) {}\n\n  private getLink() {\n    let link = this.link;\n\n    if (!link) {\n      link = this.loadLink();\n      this.link = link;\n    }\n\n    return link;\n  }\n\n  traceMappings() {\n    return traceMappings(this.getLink());\n  }\n\n  traceSegment(line: number, column: number, name: string): SourceMapSegmentObject | null {\n    return traceSegment(this.getLink(), line, column, name);\n  }\n}\n\nfunction traceMappings(\n  this: void,\n  map: { mappings: SourceMapSegment[][]; names: string[]; sources: (Link | Source)[] }\n) {\n  const sources: string[] = [];\n  const sourcesContent: (string | null)[] = [];\n  const names: string[] = [];\n  const mappings = [];\n\n  for (const line of map.mappings) {\n    const tracedLine: SourceMapSegment[] = [];\n\n    for (const segment of line) {\n      if (segment.length == 1) continue;\n      const source = map.sources[segment[1]];\n      if (!source) continue;\n\n      const traced = source.traceSegment(\n        segment[2],\n        segment[3],\n        segment.length === 5 ? map.names[segment[4]] : ''\n      );\n\n      if (traced) {\n        // newer sources are more likely to be used, so search backwards.\n        let sourceIndex = sources.lastIndexOf(traced.source.filename);\n        if (sourceIndex === -1) {\n          sourceIndex = sources.length;\n          sources.push(traced.source.filename);\n          sourcesContent[sourceIndex] = traced.source.content;\n        } else if (sourcesContent[sourceIndex] == null) {\n          sourcesContent[sourceIndex] = traced.source.content;\n        } else if (\n          traced.source.content != null &&\n          sourcesContent[sourceIndex] !== traced.source.content\n        ) {\n          return new Error(\n            `Multiple conflicting contents for sourcemap source ${traced.source.filename}`\n          );\n        }\n\n        const tracedSegment: SourceMapSegment = [\n          segment[0],\n          sourceIndex,\n          traced.line,\n          traced.column,\n        ];\n\n        if (traced.name) {\n          let nameIndex = names.indexOf(traced.name);\n          if (nameIndex === -1) {\n            nameIndex = names.length;\n            names.push(traced.name);\n          }\n\n          (tracedSegment as SourceMapSegment)[4] = nameIndex;\n        }\n\n        tracedLine.push(tracedSegment);\n      }\n    }\n\n    mappings.push(tracedLine);\n  }\n\n  return { sources, sourcesContent, names, mappings };\n}\n\nfunction traceSegment(\n  this: void,\n  map: { mappings: SourceMapSegment[][]; names: string[]; sources: (Link | Source)[] },\n  line: number,\n  column: number,\n  name: string\n): SourceMapSegmentObject | null {\n  const segments = map.mappings[line];\n  if (!segments) return null;\n\n  // binary search through segments for the given column\n  let i = 0;\n  let j = segments.length - 1;\n\n  const checks = [];\n\n  while (i <= j) {\n    const m = (i + j) >> 1;\n    const segment = segments[m];\n    checks.push(segment);\n    if (segment[0] === column) {\n      if (segment.length == 1) return null;\n      const source = map.sources[segment[1]];\n      if (!source) return null;\n\n      return source.traceSegment(\n        segment[2],\n        segment[3],\n        segment.length === 5 ? map.names[segment[4]] : name\n      );\n    }\n    if (segment[0] > column) {\n      j = m - 1;\n    } else {\n      i = m + 1;\n    }\n  }\n\n  return null;\n}\n/**\n * This function attempts to compensate for the loss of precision when lower\n * layers of source maps have higher precision than upper layers, leading to\n * a loss of fidelity.\n *\n * The code was lifted from [Alec Larson](https://github.com/aleclarson)'s\n * [fork of sorcery](https://github.com/aleclarson/sorcery/blob/3934a3f38a6d8604fc9dbaa576cbb6e4d733040f/src/blend.js).\n *\n * NOTE: This function mutates the given node.\n *\n * @copyright [Alec Larson](https://github.com/aleclarson) 2018\n */\n// function blend(node: Link) {\n//   let mappings: SourceMapSegment[][] = []; // traced lines\n//   let sources: (Link | Source)[] = []; // traced sources\n//   let names: string[] = []; // traced symbols\n\n//   // Precompute which source/line/column triples are mapped by the given node.\n//   // These references are useful when interweaving old segments.\n//   const refs: number[][][] = Object.keys(node.sources).map(() => []);\n\n//   for (const segments of node.mappings) {\n//     let segment: SourceMapSegment;\n//     let lines: number[][];\n//     let columns: number[];\n//     for (let i = 0; i < segments.length; i++) {\n//       segment = segments[i];\n\n//       if (segment.length === 4 || segment.length === 5) {\n//         lines = refs[segment[1]];\n//         if (!lines) refs[segment[1]] = lines = [];\n\n//         columns = lines[segment[2]];\n//         if (columns) {\n//           uniqueAscendingInsert(columns, segment[3]);\n//         } else {\n//           lines[segment[2]] = [segment[3]];\n//         }\n//       }\n//     }\n//   }\n\n//   let traced: SourceMapSegment[] | undefined = undefined; // the traced line mapping\n//   let untraced: SourceMapSegment[] | undefined = undefined; // the untraced line mapping\n\n//   function addSegment(\n//     segment: SourceMapSegment,\n//     source?: { names: string[]; sources: (Link | Source)[] }\n//   ) {\n//     if (source) {\n//       segment[1] = uniq<Link | Source>(sources, source.sources[segment[1]!]);\n//       if (segment.length === 5) {\n//         segment[4] = uniq(names, source.names[segment[4]]);\n//       }\n//     } else if (segment.length === 5) {\n//       segment[4] = uniq(names, node.names[segment[4]]);\n//     }\n//     traced!.push(segment);\n//   }\n\n//   let tracedLine: number; // the last traced line\n//   let generatedLine = -1; // the current line\n//   let sourceIndex: number | undefined = -1; // source of last traced segment\n//   let sourceLine: number | undefined = undefined; // source line of last traced segment\n\n//   // Find the next line with segments.\n//   function nextLine() {\n//     tracedLine = generatedLine;\n//     while (++generatedLine < node.mappings.length) {\n//       untraced = node.mappings[generatedLine];\n//       if (untraced.length) return true;\n//     }\n//   }\n\n//   // Provide mappings for lines between the\n//   // last traced line and the current line.\n//   function fillSkippedLines() {\n//     const skipped = generatedLine - (tracedLine + 1);\n//     if (skipped !== 0) {\n//       let line = tracedLine;\n\n//       // Take line mappings from the current source.\n//       if (sourceIndex !== -1) {\n//         const source = node.sources[sourceIndex!];\n//         if (source instanceof Link) {\n//           while (line < generatedLine - 1) {\n//             if (++sourceLine! !== source.mappings.length) {\n//               mappings[++line] = traced = [];\n\n//               // Check referenced columns to avoid duplicate segments.\n//               const columns = refs[sourceIndex!][sourceLine!] || [];\n//               let prevColumn = -1;\n\n//               // Interweave old segments from the current source.\n//               const segments = source.mappings[sourceLine!];\n//               for (let i = 0; i < segments.length; i++) {\n//                 const segment = segments[i];\n//                 if (!hasValueBetween(columns, prevColumn, segment[0] + 1)) {\n//                   addSegment([...segment] as SourceMapSegment, source);\n//                   prevColumn = segment[0];\n//                 } else break;\n//               }\n//             } else {\n//               // End of source file.\n//               sourceIndex = -1;\n//               break;\n//             }\n//           }\n//         }\n//       }\n\n//       // Default to empty arrays for unmapped lines.\n//       while (++line < generatedLine) {\n//         mappings[line] = [];\n//       }\n//     }\n//   }\n\n//   while (nextLine()) {\n//     fillSkippedLines();\n\n//     // Trace the segments of this generated line.\n//     mappings[generatedLine] = traced = [];\n\n//     // Interweave old segments before the first mapped column of each line.\n//     const sourceColumn = untraced![0][3];\n//     if (sourceIndex !== -1 && sourceColumn !== 0) {\n//       const source = node.sources[sourceIndex];\n//       if (source instanceof Link) {\n//         const segments =\n//           sourceLine! < source.mappings.length - 1 ? source.mappings[++sourceLine!] : [];\n\n//         for (let i = 0; i < segments.length; i++) {\n//           const segment = segments[i];\n//           if (segment[0] < sourceColumn!) {\n//             addSegment(segment.slice(0) as SourceMapSegment, source);\n//           } else break;\n//         }\n//       }\n//     }\n\n//     const last = untraced!.length - 1;\n//     untraced!.forEach((curr: SourceMapSegment | null, i) => {\n//       [, sourceIndex, sourceLine] = curr!;\n\n//       const source = node.sources[sourceIndex!];\n//       if (source === null) {\n//         curr![1] = uniq(sources, null);\n//         return addSegment(curr!);\n//       }\n//       if (!(source instanceof Link)) {\n//         curr![1] = uniq(sources, source);\n//         return addSegment(curr!);\n//       }\n\n//       const next = i !== last ? untraced![i + 1] : null;\n//       const sourceColumn = curr![3];\n//       const generatedColumn = curr![0];\n\n//       // Find the first segment with a greater column.\n//       const segments = source.mappings[sourceLine!] || [];\n//       let j = findGreaterColumn(segments, sourceColumn!);\n\n//       // A \"base segment\" is required for tracing to a grand-parent.\n//       let base;\n//       if (--j !== -1) {\n//         base = segments[j];\n//         curr![1] = uniq(sources, source.sources[base[1]!]);\n//         curr![2] = base[2];\n//         curr![3] = base[3]! + sourceColumn! - base[0];\n//         if (base.length === 5) {\n//           // Inherit the names of aligned base segments.\n//           if (base[0] === sourceColumn) {\n//             curr![4] = uniq(names, source.names[base[4]!]);\n//           }\n//         } else if (curr!.length === 5) {\n//           // When our segment is named and the base segment is not,\n//           // assume this segment cannot be traced to its original source.\n//           if (base[0] !== sourceColumn) curr = null;\n//         }\n//       } else {\n//         curr![1] = uniq(sources, null);\n//       }\n\n//       curr && addSegment(curr);\n\n//       // Check referenced columns to avoid duplicate segments.\n//       const columns = refs[sourceIndex!][sourceLine!] || [];\n//       let baseColumn = base ? base[0] : -1;\n\n//       // Interweave old segments between our current and next segments.\n//       const nextColumn = next ? next[0] : 1 / 0;\n//       while (++j < segments.length) {\n//         let segment = segments[j];\n\n//         // The generated column is shifted to fit into the root source map.\n//         const column = segment[0] + generatedColumn - sourceColumn!;\n//         if (column >= nextColumn) break;\n\n//         // Avoid duplicates by checking if this segment goes elsewhere.\n//         if (!hasValueBetween(columns, baseColumn, segment[0] + 1)) {\n//           baseColumn = segment[0];\n//           segment = segment.slice(0) as SourceMapSegment;\n//           segment[0] = column;\n//           addSegment(segment, source);\n//         } else break;\n//       }\n//     });\n//   }\n//   fillSkippedLines();\n\n//   node.mappings = mappings;\n//   node.sources = sources;\n//   node.names = names;\n//   return node;\n// }\n\n// // Check if a value exists before pushing it to an array.\n// // Return the new or existing index of the value.\n// function uniq<T>(arr: T[], val: T): number {\n//   const i = arr.indexOf(val);\n//   return ~i ? i : arr.push(val) - 1;\n// }\n\n// // Get the first segment with a greater column.\n// function findGreaterColumn(segments: SourceMapSegment[], column: number) {\n//   let low = 0,\n//     high = segments.length;\n//   while (low < high) {\n//     const mid = (low + high) >>> 1;\n//     segments[mid][0] <= column ? (low = mid + 1) : (high = mid);\n//   }\n//   return low;\n// }\n\n// // The range is exclusive.\n// function hasValueBetween(arr: number[], start: number, end: number) {\n//   let low = 0,\n//     high = arr.length;\n//   while (low < high) {\n//     const mid = (low + high) >>> 1;\n//     const val = arr[mid];\n//     if (val <= start) {\n//       low = mid + 1;\n//     } else if (val >= end) {\n//       high = mid;\n//     } else {\n//       return true;\n//     }\n//   }\n//   return false;\n// }\n\n// // Insert unique values in ascending order.\n// function uniqueAscendingInsert(arr: number[], val: number) {\n//   let low = 0,\n//     high = arr.length;\n//   while (low < high) {\n//     const mid = (low + high) >>> 1;\n//     const x = arr[mid];\n//     if (x === val) return;\n//     if (x < val) {\n//       low = mid + 1;\n//     } else {\n//       high = mid;\n//     }\n//   }\n//   arr.splice(low, 0, val);\n// }\n", "import {\n  checkCancellation,\n  DependencyNotFoundError,\n  EntryExcludedError,\n  EntryNotFoundError,\n  isThenable,\n  Uri,\n} from '@velcro/common';\nimport { ResolverContext } from '@velcro/resolver';\nimport MagicString, { DecodedSourceMap, SourceMap } from 'magic-string';\nimport {\n  decodeDataUriAsSourceMap,\n  getSourceMappingUrl,\n  updateSourceMappingUrl,\n} from '../build/sourceMap';\nimport { Link, Source } from '../build/sourceMapTree';\nimport { SourceModule, SourceModuleDependency } from '../graph';\nimport {\n  Plugin,\n  PluginLoadContext,\n  PluginResolveDependencyContext,\n  PluginResolveEntrypointContext,\n  PluginTransformContext,\n} from './plugin';\n\nexport class PluginManager {\n  constructor(private readonly plugins: Plugin[]) {\n    this.plugins.push({\n      name: 'builtIn',\n      load: async (ctx, id) => {\n        const uri = Uri.parse(id);\n        const readReturn = ctx.resolver.readFileContent(uri);\n        const readResult = isThenable(readReturn)\n          ? await checkCancellation(readReturn, ctx.token)\n          : readReturn;\n\n        return {\n          code: ctx.resolver.decode(readResult.content),\n          visited: readResult.visited,\n        };\n      },\n      resolveDependency: async (ctx, dependency, fromSourceModule) => {\n        const resolveReturn = ctx.resolver.resolve(dependency.spec, fromSourceModule.uri);\n        const resolveResult = isThenable(resolveReturn)\n          ? await checkCancellation(resolveReturn, ctx.token)\n          : resolveReturn;\n\n        if (!resolveResult.found) {\n          throw new DependencyNotFoundError(dependency.spec, fromSourceModule);\n        }\n\n        if (!resolveResult.uri) {\n          // TODO: Inject empty module\n          throw new EntryExcludedError(dependency.spec);\n        }\n\n        return {\n          uri: resolveResult.uri,\n          rootUri: resolveResult.rootUri,\n          visited: resolveResult.visited,\n        };\n      },\n      resolveEntrypoint: async (ctx, uri) => {\n        const resolveResult = await ctx.resolver.resolve(uri);\n\n        if (!resolveResult.found) {\n          throw new EntryNotFoundError(`Entry point not found: ${uri}`);\n        }\n\n        if (!resolveResult.uri) {\n          throw new EntryExcludedError(uri);\n        }\n\n        return resolveResult;\n      },\n      transform: async ({ createMagicString }, id) => {\n        if (id.path.endsWith('.json')) {\n          const magicString = createMagicString();\n          magicString.prepend('module.exports = ');\n\n          return {\n            code: magicString.toString(),\n            sourceMap: magicString.generateDecodedMap(),\n          };\n        }\n      },\n    });\n  }\n\n  async executeLoad(ctx: PluginLoadContext, uri: Uri) {\n    for (const plugin of this.plugins) {\n      if (typeof plugin.load === 'function') {\n        const loadReturn = plugin.load(ctx, uri.toString());\n        const loadResult = isThenable(loadReturn)\n          ? await checkCancellation(loadReturn, ctx.token)\n          : loadReturn;\n\n        if (!loadResult) {\n          continue;\n        }\n\n        return {\n          code: loadResult.code,\n          visited: loadResult.visited || [],\n        };\n      }\n    }\n\n    throw new Error(`No plugin was found that was able to load the uri ${uri.toString()}`);\n  }\n\n  async executeResolveDependency(\n    ctx: PluginResolveDependencyContext,\n    dependency: SourceModuleDependency,\n    fromModule: SourceModule\n  ) {\n    for (const plugin of this.plugins) {\n      if (typeof plugin.resolveDependency === 'function') {\n        const loadReturn = plugin.resolveDependency(ctx, dependency, fromModule);\n        const loadResult = isThenable(loadReturn)\n          ? await checkCancellation(loadReturn, ctx.token)\n          : loadReturn;\n\n        if (!loadResult) {\n          continue;\n        }\n\n        return {\n          uri: loadResult.uri,\n          rootUri: loadResult.rootUri,\n          visited: loadResult.visited || [],\n        };\n      }\n    }\n\n    throw new Error(\n      `No plugin was able to resolve the '${dependency.kind}' dependency, '${dependency.spec}' from '${fromModule.href}'`\n    );\n  }\n\n  async executeResolveEntrypoint(ctx: PluginResolveEntrypointContext, uri: Uri) {\n    for (const plugin of this.plugins) {\n      if (typeof plugin.resolveEntrypoint === 'function') {\n        const loadReturn = plugin.resolveEntrypoint(ctx, uri);\n        const loadResult = isThenable(loadReturn)\n          ? await checkCancellation(loadReturn, ctx.token)\n          : loadReturn;\n\n        if (!loadResult) {\n          continue;\n        }\n\n        return {\n          uri: loadResult.uri,\n          rootUri: loadResult.rootUri,\n          visited: loadResult.visited || [],\n        };\n      }\n    }\n\n    throw new Error(`No plugin was able to resolve the entrypoint '${uri.toString()}'`);\n  }\n\n  async executeTransform(\n    ctx: Omit<PluginTransformContext, 'createMagicString'>,\n    uri: Uri,\n    code: string | ArrayBuffer\n  ) {\n    if (typeof code !== 'string') {\n      code = ctx.resolver.decode(code);\n    }\n\n    const pluginCtx: PluginTransformContext = Object.assign(ctx, {\n      createMagicString() {\n        return new MagicString(code as string);\n      },\n    });\n\n    let sourceMapTree: Source | Link = new Source(uri.toString(), code);\n\n    // Figure out if our original code, itself has a sourcemap.\n    // For now, we will not recurse beyond that depth.\n    const sourceMapRef = getSourceMappingUrl(code);\n    if (sourceMapRef) {\n      let sourceMap: DecodedSourceMap | SourceMap | null = decodeDataUriAsSourceMap(sourceMapRef);\n\n      if (!sourceMap) {\n        const sourceMapUri = Uri.joinPath(uri, `../${sourceMapRef}`);\n\n        code = updateSourceMappingUrl(code, sourceMapUri.toString());\n      }\n\n      if (sourceMap) {\n        const sources = sourceMap.sources;\n        const sourcesContent = sourceMap.sourcesContent || [];\n        const baseSources = [] as Source[];\n\n        for (const idx in sources) {\n          if (sources[idx] && sourcesContent[idx]) {\n            baseSources.push(new Source(sources[idx]!, sourcesContent[idx]!));\n          }\n        }\n\n        sourceMapTree = new Link(sourceMap, baseSources);\n      }\n    }\n\n    const visited = [] as ResolverContext.Visit[];\n\n    for (const plugin of this.plugins) {\n      if (typeof plugin.transform === 'function') {\n        const transformReturn = plugin.transform(pluginCtx, uri, code);\n        const transformResult = isThenable(transformReturn)\n          ? await checkCancellation(transformReturn, ctx.token)\n          : transformReturn;\n\n        if (transformResult === null || transformResult === undefined) {\n          continue;\n        }\n\n        if (transformResult.sourceMap) {\n          sourceMapTree = new Link(transformResult.sourceMap, [sourceMapTree]);\n        }\n\n        code = transformResult.code;\n\n        if (transformResult.visited) {\n          visited.push(...transformResult.visited);\n        }\n      }\n    }\n\n    return {\n      code,\n      sourceMapTree,\n      visited,\n    };\n  }\n}\n", "export * from './plugin';\nexport * from './pluginManager';\n", "import { Uri } from '@velcro/common';\n\nexport enum SourceModuleDependencyKind {\n  Entrypoint = 'Entrypoint',\n  Require = 'Require',\n  RequireResolve = 'RequireResolve',\n  GlobalObject = 'GlobalObject',\n}\n\ninterface SourceModuleOptions {\n  exportName?: string;\n}\n\ntype SourceLocation = { start: number; end: number };\n\nexport class SourceModuleDependency {\n  locator?: { name: string; spec: string; path: string; version?: string };\n\n  private constructor(\n    readonly kind: SourceModuleDependencyKind,\n    readonly spec: string,\n    readonly locations: ReadonlyArray<SourceLocation>,\n    readonly options: SourceModuleOptions = {}\n  ) {}\n\n  static areIdentical(l: SourceModuleDependency, r: SourceModuleDependency) {\n    return l.kind === r.kind && l.spec === r.spec;\n  }\n\n  static fromEntrypoint(uri: Uri) {\n    return new SourceModuleDependency(SourceModuleDependencyKind.Entrypoint, uri.toString(), []);\n  }\n\n  static fromGlobalObject(spec: string, locations: SourceLocation[], exportName?: string) {\n    return new SourceModuleDependency(SourceModuleDependencyKind.GlobalObject, spec, locations, {\n      exportName,\n    });\n  }\n\n  static fromRequire(spec: string, locations: SourceLocation[]) {\n    return new SourceModuleDependency(SourceModuleDependencyKind.Require, spec, locations);\n  }\n\n  static fromRequireResolve(spec: string, locations: SourceLocation[]) {\n    return new SourceModuleDependency(SourceModuleDependencyKind.RequireResolve, spec, locations);\n  }\n}\n", "// Reserved word lists for various dialects of the language\n\nvar reservedWords = {\n  3: \"abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile\",\n  5: \"class enum extends super const export import\",\n  6: \"enum\",\n  strict: \"implements interface let package private protected public static yield\",\n  strictBind: \"eval arguments\"\n};\n\n// And the keywords\n\nvar ecma5AndLessKeywords = \"break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this\";\n\nvar keywords = {\n  5: ecma5AndLessKeywords,\n  \"5module\": ecma5AndLessKeywords + \" export import\",\n  6: ecma5AndLessKeywords + \" const class extends export import super\"\n};\n\nvar keywordRelationalOperator = /^in(stanceof)?$/;\n\n// ## Character categories\n\n// Big ugly regular expressions that match characters in the\n// whitespace, identifier, and identifier-start categories. These\n// are only applied when a character is found to actually have a\n// code point above 128.\n// Generated by `bin/generate-identifier-regex.js`.\nvar nonASCIIidentifierStartChars = \"\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u037f\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u052f\\u0531-\\u0556\\u0559\\u0560-\\u0588\\u05d0-\\u05ea\\u05ef-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u0860-\\u086a\\u08a0-\\u08b4\\u08b6-\\u08c7\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u09fc\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0af9\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c39\\u0c3d\\u0c58-\\u0c5a\\u0c60\\u0c61\\u0c80\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d04-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d54-\\u0d56\\u0d5f-\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e86-\\u0e8a\\u0e8c-\\u0ea3\\u0ea5\\u0ea7-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f5\\u13f8-\\u13fd\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f8\\u1700-\\u170c\\u170e-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1878\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191e\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19b0-\\u19c9\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4b\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1c80-\\u1c88\\u1c90-\\u1cba\\u1cbd-\\u1cbf\\u1ce9-\\u1cec\\u1cee-\\u1cf3\\u1cf5\\u1cf6\\u1cfa\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2118-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309b-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312f\\u3131-\\u318e\\u31a0-\\u31bf\\u31f0-\\u31ff\\u3400-\\u4dbf\\u4e00-\\u9ffc\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua69d\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua7bf\\ua7c2-\\ua7ca\\ua7f5-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua8fd\\ua8fe\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\ua9e0-\\ua9e4\\ua9e6-\\ua9ef\\ua9fa-\\ua9fe\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa7e-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uab30-\\uab5a\\uab5c-\\uab69\\uab70-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc\";\nvar nonASCIIidentifierChars = \"\\u200c\\u200d\\xb7\\u0300-\\u036f\\u0387\\u0483-\\u0487\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u0669\\u0670\\u06d6-\\u06dc\\u06df-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u06f0-\\u06f9\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07c0-\\u07c9\\u07eb-\\u07f3\\u07fd\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0859-\\u085b\\u08d3-\\u08e1\\u08e3-\\u0903\\u093a-\\u093c\\u093e-\\u094f\\u0951-\\u0957\\u0962\\u0963\\u0966-\\u096f\\u0981-\\u0983\\u09bc\\u09be-\\u09c4\\u09c7\\u09c8\\u09cb-\\u09cd\\u09d7\\u09e2\\u09e3\\u09e6-\\u09ef\\u09fe\\u0a01-\\u0a03\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a66-\\u0a71\\u0a75\\u0a81-\\u0a83\\u0abc\\u0abe-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ae2\\u0ae3\\u0ae6-\\u0aef\\u0afa-\\u0aff\\u0b01-\\u0b03\\u0b3c\\u0b3e-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b55-\\u0b57\\u0b62\\u0b63\\u0b66-\\u0b6f\\u0b82\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd7\\u0be6-\\u0bef\\u0c00-\\u0c04\\u0c3e-\\u0c44\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0c66-\\u0c6f\\u0c81-\\u0c83\\u0cbc\\u0cbe-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0ce6-\\u0cef\\u0d00-\\u0d03\\u0d3b\\u0d3c\\u0d3e-\\u0d44\\u0d46-\\u0d48\\u0d4a-\\u0d4d\\u0d57\\u0d62\\u0d63\\u0d66-\\u0d6f\\u0d81-\\u0d83\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0de6-\\u0def\\u0df2\\u0df3\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0e50-\\u0e59\\u0eb1\\u0eb4-\\u0ebc\\u0ec8-\\u0ecd\\u0ed0-\\u0ed9\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f3e\\u0f3f\\u0f71-\\u0f84\\u0f86\\u0f87\\u0f8d-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102b-\\u103e\\u1040-\\u1049\\u1056-\\u1059\\u105e-\\u1060\\u1062-\\u1064\\u1067-\\u106d\\u1071-\\u1074\\u1082-\\u108d\\u108f-\\u109d\\u135d-\\u135f\\u1369-\\u1371\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b4-\\u17d3\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u1810-\\u1819\\u18a9\\u1920-\\u192b\\u1930-\\u193b\\u1946-\\u194f\\u19d0-\\u19da\\u1a17-\\u1a1b\\u1a55-\\u1a5e\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1ab0-\\u1abd\\u1abf\\u1ac0\\u1b00-\\u1b04\\u1b34-\\u1b44\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1b80-\\u1b82\\u1ba1-\\u1bad\\u1bb0-\\u1bb9\\u1be6-\\u1bf3\\u1c24-\\u1c37\\u1c40-\\u1c49\\u1c50-\\u1c59\\u1cd0-\\u1cd2\\u1cd4-\\u1ce8\\u1ced\\u1cf4\\u1cf7-\\u1cf9\\u1dc0-\\u1df9\\u1dfb-\\u1dff\\u203f\\u2040\\u2054\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2cef-\\u2cf1\\u2d7f\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua620-\\ua629\\ua66f\\ua674-\\ua67d\\ua69e\\ua69f\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua823-\\ua827\\ua82c\\ua880\\ua881\\ua8b4-\\ua8c5\\ua8d0-\\ua8d9\\ua8e0-\\ua8f1\\ua8ff-\\ua909\\ua926-\\ua92d\\ua947-\\ua953\\ua980-\\ua983\\ua9b3-\\ua9c0\\ua9d0-\\ua9d9\\ua9e5\\ua9f0-\\ua9f9\\uaa29-\\uaa36\\uaa43\\uaa4c\\uaa4d\\uaa50-\\uaa59\\uaa7b-\\uaa7d\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uaaeb-\\uaaef\\uaaf5\\uaaf6\\uabe3-\\uabea\\uabec\\uabed\\uabf0-\\uabf9\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe2f\\ufe33\\ufe34\\ufe4d-\\ufe4f\\uff10-\\uff19\\uff3f\";\n\nvar nonASCIIidentifierStart = new RegExp(\"[\" + nonASCIIidentifierStartChars + \"]\");\nvar nonASCIIidentifier = new RegExp(\"[\" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \"]\");\n\nnonASCIIidentifierStartChars = nonASCIIidentifierChars = null;\n\n// These are a run-length and offset encoded representation of the\n// >0xffff code points that are a valid part of identifiers. The\n// offset starts at 0x10000, and each pair of numbers represents an\n// offset to the next range, and then a size of the range. They were\n// generated by bin/generate-identifier-regex.js\n\n// eslint-disable-next-line comma-spacing\nvar astralIdentifierStartCodes = [0,11,2,25,2,18,2,1,2,14,3,13,35,122,70,52,268,28,4,48,48,31,14,29,6,37,11,29,3,35,5,7,2,4,43,157,19,35,5,35,5,39,9,51,157,310,10,21,11,7,153,5,3,0,2,43,2,1,4,0,3,22,11,22,10,30,66,18,2,1,11,21,11,25,71,55,7,1,65,0,16,3,2,2,2,28,43,28,4,28,36,7,2,27,28,53,11,21,11,18,14,17,111,72,56,50,14,50,14,35,349,41,7,1,79,28,11,0,9,21,107,20,28,22,13,52,76,44,33,24,27,35,30,0,3,0,9,34,4,0,13,47,15,3,22,0,2,0,36,17,2,24,85,6,2,0,2,3,2,14,2,9,8,46,39,7,3,1,3,21,2,6,2,1,2,4,4,0,19,0,13,4,159,52,19,3,21,2,31,47,21,1,2,0,185,46,42,3,37,47,21,0,60,42,14,0,72,26,230,43,117,63,32,7,3,0,3,7,2,1,2,23,16,0,2,0,95,7,3,38,17,0,2,0,29,0,11,39,8,0,22,0,12,45,20,0,35,56,264,8,2,36,18,0,50,29,113,6,2,1,2,37,22,0,26,5,2,1,2,31,15,0,328,18,190,0,80,921,103,110,18,195,2749,1070,4050,582,8634,568,8,30,114,29,19,47,17,3,32,20,6,18,689,63,129,74,6,0,67,12,65,1,2,0,29,6135,9,1237,43,8,8952,286,50,2,18,3,9,395,2309,106,6,12,4,8,8,9,5991,84,2,70,2,1,3,0,3,1,3,3,2,11,2,0,2,6,2,64,2,3,3,7,2,6,2,27,2,3,2,4,2,0,4,6,2,339,3,24,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,7,2357,44,11,6,17,0,370,43,1301,196,60,67,8,0,1205,3,2,26,2,1,2,0,3,0,2,9,2,3,2,0,2,0,7,0,5,0,2,0,2,0,2,2,2,1,2,0,3,0,2,0,2,0,2,0,2,0,2,1,2,0,3,3,2,6,2,3,2,3,2,0,2,9,2,16,6,2,2,4,2,16,4421,42717,35,4148,12,221,3,5761,15,7472,3104,541,1507,4938];\n\n// eslint-disable-next-line comma-spacing\nvar astralIdentifierCodes = [509,0,227,0,150,4,294,9,1368,2,2,1,6,3,41,2,5,0,166,1,574,3,9,9,370,1,154,10,176,2,54,14,32,9,16,3,46,10,54,9,7,2,37,13,2,9,6,1,45,0,13,2,49,13,9,3,2,11,83,11,7,0,161,11,6,9,7,3,56,1,2,6,3,1,3,2,10,0,11,1,3,6,4,4,193,17,10,9,5,0,82,19,13,9,214,6,3,8,28,1,83,16,16,9,82,12,9,9,84,14,5,9,243,14,166,9,71,5,2,1,3,3,2,0,2,1,13,9,120,6,3,6,4,0,29,9,41,6,2,3,9,0,10,10,47,15,406,7,2,7,17,9,57,21,2,13,123,5,4,0,2,1,2,6,2,0,9,9,49,4,2,1,2,4,9,9,330,3,19306,9,135,4,60,6,26,9,1014,0,2,54,8,3,82,0,12,1,19628,1,5319,4,4,5,9,7,3,6,31,3,149,2,1418,49,513,54,5,49,9,0,15,0,23,4,2,14,1361,6,2,16,3,6,2,1,2,4,262,6,10,9,419,13,1495,6,110,6,6,9,4759,9,787719,239];\n\n// This has a complexity linear to the value of the code. The\n// assumption is that looking up astral identifier characters is\n// rare.\nfunction isInAstralSet(code, set) {\n  var pos = 0x10000;\n  for (var i = 0; i < set.length; i += 2) {\n    pos += set[i];\n    if (pos > code) { return false }\n    pos += set[i + 1];\n    if (pos >= code) { return true }\n  }\n}\n\n// Test whether a given character code starts an identifier.\n\nfunction isIdentifierStart(code, astral) {\n  if (code < 65) { return code === 36 }\n  if (code < 91) { return true }\n  if (code < 97) { return code === 95 }\n  if (code < 123) { return true }\n  if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code)) }\n  if (astral === false) { return false }\n  return isInAstralSet(code, astralIdentifierStartCodes)\n}\n\n// Test whether a given character is part of an identifier.\n\nfunction isIdentifierChar(code, astral) {\n  if (code < 48) { return code === 36 }\n  if (code < 58) { return true }\n  if (code < 65) { return false }\n  if (code < 91) { return true }\n  if (code < 97) { return code === 95 }\n  if (code < 123) { return true }\n  if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code)) }\n  if (astral === false) { return false }\n  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes)\n}\n\n// ## Token types\n\n// The assignment of fine-grained, information-carrying type objects\n// allows the tokenizer to store the information it has about a\n// token in a way that is very cheap for the parser to look up.\n\n// All token type variables start with an underscore, to make them\n// easy to recognize.\n\n// The `beforeExpr` property is used to disambiguate between regular\n// expressions and divisions. It is set on all token types that can\n// be followed by an expression (thus, a slash after them would be a\n// regular expression).\n//\n// The `startsExpr` property is used to check if the token ends a\n// `yield` expression. It is set on all token types that either can\n// directly start an expression (like a quotation mark) or can\n// continue an expression (like the body of a string).\n//\n// `isLoop` marks a keyword as starting a loop, which is important\n// to know when parsing a label, in order to allow or disallow\n// continue jumps to that label.\n\nvar TokenType = function TokenType(label, conf) {\n  if ( conf === void 0 ) conf = {};\n\n  this.label = label;\n  this.keyword = conf.keyword;\n  this.beforeExpr = !!conf.beforeExpr;\n  this.startsExpr = !!conf.startsExpr;\n  this.isLoop = !!conf.isLoop;\n  this.isAssign = !!conf.isAssign;\n  this.prefix = !!conf.prefix;\n  this.postfix = !!conf.postfix;\n  this.binop = conf.binop || null;\n  this.updateContext = null;\n};\n\nfunction binop(name, prec) {\n  return new TokenType(name, {beforeExpr: true, binop: prec})\n}\nvar beforeExpr = {beforeExpr: true}, startsExpr = {startsExpr: true};\n\n// Map keyword names to token types.\n\nvar keywords$1 = {};\n\n// Succinct definitions of keyword token types\nfunction kw(name, options) {\n  if ( options === void 0 ) options = {};\n\n  options.keyword = name;\n  return keywords$1[name] = new TokenType(name, options)\n}\n\nvar types = {\n  num: new TokenType(\"num\", startsExpr),\n  regexp: new TokenType(\"regexp\", startsExpr),\n  string: new TokenType(\"string\", startsExpr),\n  name: new TokenType(\"name\", startsExpr),\n  eof: new TokenType(\"eof\"),\n\n  // Punctuation token types.\n  bracketL: new TokenType(\"[\", {beforeExpr: true, startsExpr: true}),\n  bracketR: new TokenType(\"]\"),\n  braceL: new TokenType(\"{\", {beforeExpr: true, startsExpr: true}),\n  braceR: new TokenType(\"}\"),\n  parenL: new TokenType(\"(\", {beforeExpr: true, startsExpr: true}),\n  parenR: new TokenType(\")\"),\n  comma: new TokenType(\",\", beforeExpr),\n  semi: new TokenType(\";\", beforeExpr),\n  colon: new TokenType(\":\", beforeExpr),\n  dot: new TokenType(\".\"),\n  question: new TokenType(\"?\", beforeExpr),\n  questionDot: new TokenType(\"?.\"),\n  arrow: new TokenType(\"=>\", beforeExpr),\n  template: new TokenType(\"template\"),\n  invalidTemplate: new TokenType(\"invalidTemplate\"),\n  ellipsis: new TokenType(\"...\", beforeExpr),\n  backQuote: new TokenType(\"`\", startsExpr),\n  dollarBraceL: new TokenType(\"${\", {beforeExpr: true, startsExpr: true}),\n\n  // Operators. These carry several kinds of properties to help the\n  // parser use them properly (the presence of these properties is\n  // what categorizes them as operators).\n  //\n  // `binop`, when present, specifies that this operator is a binary\n  // operator, and will refer to its precedence.\n  //\n  // `prefix` and `postfix` mark the operator as a prefix or postfix\n  // unary operator.\n  //\n  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as\n  // binary operators with a very low precedence, that should result\n  // in AssignmentExpression nodes.\n\n  eq: new TokenType(\"=\", {beforeExpr: true, isAssign: true}),\n  assign: new TokenType(\"_=\", {beforeExpr: true, isAssign: true}),\n  incDec: new TokenType(\"++/--\", {prefix: true, postfix: true, startsExpr: true}),\n  prefix: new TokenType(\"!/~\", {beforeExpr: true, prefix: true, startsExpr: true}),\n  logicalOR: binop(\"||\", 1),\n  logicalAND: binop(\"&&\", 2),\n  bitwiseOR: binop(\"|\", 3),\n  bitwiseXOR: binop(\"^\", 4),\n  bitwiseAND: binop(\"&\", 5),\n  equality: binop(\"==/!=/===/!==\", 6),\n  relational: binop(\"</>/<=/>=\", 7),\n  bitShift: binop(\"<</>>/>>>\", 8),\n  plusMin: new TokenType(\"+/-\", {beforeExpr: true, binop: 9, prefix: true, startsExpr: true}),\n  modulo: binop(\"%\", 10),\n  star: binop(\"*\", 10),\n  slash: binop(\"/\", 10),\n  starstar: new TokenType(\"**\", {beforeExpr: true}),\n  coalesce: binop(\"??\", 1),\n\n  // Keyword token types.\n  _break: kw(\"break\"),\n  _case: kw(\"case\", beforeExpr),\n  _catch: kw(\"catch\"),\n  _continue: kw(\"continue\"),\n  _debugger: kw(\"debugger\"),\n  _default: kw(\"default\", beforeExpr),\n  _do: kw(\"do\", {isLoop: true, beforeExpr: true}),\n  _else: kw(\"else\", beforeExpr),\n  _finally: kw(\"finally\"),\n  _for: kw(\"for\", {isLoop: true}),\n  _function: kw(\"function\", startsExpr),\n  _if: kw(\"if\"),\n  _return: kw(\"return\", beforeExpr),\n  _switch: kw(\"switch\"),\n  _throw: kw(\"throw\", beforeExpr),\n  _try: kw(\"try\"),\n  _var: kw(\"var\"),\n  _const: kw(\"const\"),\n  _while: kw(\"while\", {isLoop: true}),\n  _with: kw(\"with\"),\n  _new: kw(\"new\", {beforeExpr: true, startsExpr: true}),\n  _this: kw(\"this\", startsExpr),\n  _super: kw(\"super\", startsExpr),\n  _class: kw(\"class\", startsExpr),\n  _extends: kw(\"extends\", beforeExpr),\n  _export: kw(\"export\"),\n  _import: kw(\"import\", startsExpr),\n  _null: kw(\"null\", startsExpr),\n  _true: kw(\"true\", startsExpr),\n  _false: kw(\"false\", startsExpr),\n  _in: kw(\"in\", {beforeExpr: true, binop: 7}),\n  _instanceof: kw(\"instanceof\", {beforeExpr: true, binop: 7}),\n  _typeof: kw(\"typeof\", {beforeExpr: true, prefix: true, startsExpr: true}),\n  _void: kw(\"void\", {beforeExpr: true, prefix: true, startsExpr: true}),\n  _delete: kw(\"delete\", {beforeExpr: true, prefix: true, startsExpr: true})\n};\n\n// Matches a whole line break (where CRLF is considered a single\n// line break). Used to count lines.\n\nvar lineBreak = /\\r\\n?|\\n|\\u2028|\\u2029/;\nvar lineBreakG = new RegExp(lineBreak.source, \"g\");\n\nfunction isNewLine(code, ecma2019String) {\n  return code === 10 || code === 13 || (!ecma2019String && (code === 0x2028 || code === 0x2029))\n}\n\nvar nonASCIIwhitespace = /[\\u1680\\u2000-\\u200a\\u202f\\u205f\\u3000\\ufeff]/;\n\nvar skipWhiteSpace = /(?:\\s|\\/\\/.*|\\/\\*[^]*?\\*\\/)*/g;\n\nvar ref = Object.prototype;\nvar hasOwnProperty = ref.hasOwnProperty;\nvar toString = ref.toString;\n\n// Checks if an object has a property.\n\nfunction has(obj, propName) {\n  return hasOwnProperty.call(obj, propName)\n}\n\nvar isArray = Array.isArray || (function (obj) { return (\n  toString.call(obj) === \"[object Array]\"\n); });\n\nfunction wordsRegexp(words) {\n  return new RegExp(\"^(?:\" + words.replace(/ /g, \"|\") + \")$\")\n}\n\n// These are used when `options.locations` is on, for the\n// `startLoc` and `endLoc` properties.\n\nvar Position = function Position(line, col) {\n  this.line = line;\n  this.column = col;\n};\n\nPosition.prototype.offset = function offset (n) {\n  return new Position(this.line, this.column + n)\n};\n\nvar SourceLocation = function SourceLocation(p, start, end) {\n  this.start = start;\n  this.end = end;\n  if (p.sourceFile !== null) { this.source = p.sourceFile; }\n};\n\n// The `getLineInfo` function is mostly useful when the\n// `locations` option is off (for performance reasons) and you\n// want to find the line/column position for a given character\n// offset. `input` should be the code string that the offset refers\n// into.\n\nfunction getLineInfo(input, offset) {\n  for (var line = 1, cur = 0;;) {\n    lineBreakG.lastIndex = cur;\n    var match = lineBreakG.exec(input);\n    if (match && match.index < offset) {\n      ++line;\n      cur = match.index + match[0].length;\n    } else {\n      return new Position(line, offset - cur)\n    }\n  }\n}\n\n// A second optional argument can be given to further configure\n// the parser process. These options are recognized:\n\nvar defaultOptions = {\n  // `ecmaVersion` indicates the ECMAScript version to parse. Must be\n  // either 3, 5, 6 (2015), 7 (2016), 8 (2017), 9 (2018), or 10\n  // (2019). This influences support for strict mode, the set of\n  // reserved words, and support for new syntax features. The default\n  // is 10.\n  ecmaVersion: 10,\n  // `sourceType` indicates the mode the code should be parsed in.\n  // Can be either `\"script\"` or `\"module\"`. This influences global\n  // strict mode and parsing of `import` and `export` declarations.\n  sourceType: \"script\",\n  // `onInsertedSemicolon` can be a callback that will be called\n  // when a semicolon is automatically inserted. It will be passed\n  // the position of the comma as an offset, and if `locations` is\n  // enabled, it is given the location as a `{line, column}` object\n  // as second argument.\n  onInsertedSemicolon: null,\n  // `onTrailingComma` is similar to `onInsertedSemicolon`, but for\n  // trailing commas.\n  onTrailingComma: null,\n  // By default, reserved words are only enforced if ecmaVersion >= 5.\n  // Set `allowReserved` to a boolean value to explicitly turn this on\n  // an off. When this option has the value \"never\", reserved words\n  // and keywords can also not be used as property names.\n  allowReserved: null,\n  // When enabled, a return at the top level is not considered an\n  // error.\n  allowReturnOutsideFunction: false,\n  // When enabled, import/export statements are not constrained to\n  // appearing at the top of the program.\n  allowImportExportEverywhere: false,\n  // When enabled, await identifiers are allowed to appear at the top-level scope,\n  // but they are still not allowed in non-async functions.\n  allowAwaitOutsideFunction: false,\n  // When enabled, hashbang directive in the beginning of file\n  // is allowed and treated as a line comment.\n  allowHashBang: false,\n  // When `locations` is on, `loc` properties holding objects with\n  // `start` and `end` properties in `{line, column}` form (with\n  // line being 1-based and column 0-based) will be attached to the\n  // nodes.\n  locations: false,\n  // A function can be passed as `onToken` option, which will\n  // cause Acorn to call that function with object in the same\n  // format as tokens returned from `tokenizer().getToken()`. Note\n  // that you are not allowed to call the parser from the\n  // callback\u2014that will corrupt its internal state.\n  onToken: null,\n  // A function can be passed as `onComment` option, which will\n  // cause Acorn to call that function with `(block, text, start,\n  // end)` parameters whenever a comment is skipped. `block` is a\n  // boolean indicating whether this is a block (`/* */`) comment,\n  // `text` is the content of the comment, and `start` and `end` are\n  // character offsets that denote the start and end of the comment.\n  // When the `locations` option is on, two more parameters are\n  // passed, the full `{line, column}` locations of the start and\n  // end of the comments. Note that you are not allowed to call the\n  // parser from the callback\u2014that will corrupt its internal state.\n  onComment: null,\n  // Nodes have their start and end characters offsets recorded in\n  // `start` and `end` properties (directly on the node, rather than\n  // the `loc` object, which holds line/column data. To also add a\n  // [semi-standardized][range] `range` property holding a `[start,\n  // end]` array with the same numbers, set the `ranges` option to\n  // `true`.\n  //\n  // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678\n  ranges: false,\n  // It is possible to parse multiple files into a single AST by\n  // passing the tree produced by parsing the first file as\n  // `program` option in subsequent parses. This will add the\n  // toplevel forms of the parsed file to the `Program` (top) node\n  // of an existing parse tree.\n  program: null,\n  // When `locations` is on, you can pass this to record the source\n  // file in every node's `loc` object.\n  sourceFile: null,\n  // This value, if given, is stored in every node, whether\n  // `locations` is on or off.\n  directSourceFile: null,\n  // When enabled, parenthesized expressions are represented by\n  // (non-standard) ParenthesizedExpression nodes\n  preserveParens: false\n};\n\n// Interpret and default an options object\n\nfunction getOptions(opts) {\n  var options = {};\n\n  for (var opt in defaultOptions)\n    { options[opt] = opts && has(opts, opt) ? opts[opt] : defaultOptions[opt]; }\n\n  if (options.ecmaVersion >= 2015)\n    { options.ecmaVersion -= 2009; }\n\n  if (options.allowReserved == null)\n    { options.allowReserved = options.ecmaVersion < 5; }\n\n  if (isArray(options.onToken)) {\n    var tokens = options.onToken;\n    options.onToken = function (token) { return tokens.push(token); };\n  }\n  if (isArray(options.onComment))\n    { options.onComment = pushComment(options, options.onComment); }\n\n  return options\n}\n\nfunction pushComment(options, array) {\n  return function(block, text, start, end, startLoc, endLoc) {\n    var comment = {\n      type: block ? \"Block\" : \"Line\",\n      value: text,\n      start: start,\n      end: end\n    };\n    if (options.locations)\n      { comment.loc = new SourceLocation(this, startLoc, endLoc); }\n    if (options.ranges)\n      { comment.range = [start, end]; }\n    array.push(comment);\n  }\n}\n\n// Each scope gets a bitset that may contain these flags\nvar\n    SCOPE_TOP = 1,\n    SCOPE_FUNCTION = 2,\n    SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION,\n    SCOPE_ASYNC = 4,\n    SCOPE_GENERATOR = 8,\n    SCOPE_ARROW = 16,\n    SCOPE_SIMPLE_CATCH = 32,\n    SCOPE_SUPER = 64,\n    SCOPE_DIRECT_SUPER = 128;\n\nfunction functionFlags(async, generator) {\n  return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0)\n}\n\n// Used in checkLVal and declareName to determine the type of a binding\nvar\n    BIND_NONE = 0, // Not a binding\n    BIND_VAR = 1, // Var-style binding\n    BIND_LEXICAL = 2, // Let- or const-style binding\n    BIND_FUNCTION = 3, // Function declaration\n    BIND_SIMPLE_CATCH = 4, // Simple (identifier pattern) catch binding\n    BIND_OUTSIDE = 5; // Special case for function names as bound inside the function\n\nvar Parser = function Parser(options, input, startPos) {\n  this.options = options = getOptions(options);\n  this.sourceFile = options.sourceFile;\n  this.keywords = wordsRegexp(keywords[options.ecmaVersion >= 6 ? 6 : options.sourceType === \"module\" ? \"5module\" : 5]);\n  var reserved = \"\";\n  if (options.allowReserved !== true) {\n    for (var v = options.ecmaVersion;; v--)\n      { if (reserved = reservedWords[v]) { break } }\n    if (options.sourceType === \"module\") { reserved += \" await\"; }\n  }\n  this.reservedWords = wordsRegexp(reserved);\n  var reservedStrict = (reserved ? reserved + \" \" : \"\") + reservedWords.strict;\n  this.reservedWordsStrict = wordsRegexp(reservedStrict);\n  this.reservedWordsStrictBind = wordsRegexp(reservedStrict + \" \" + reservedWords.strictBind);\n  this.input = String(input);\n\n  // Used to signal to callers of `readWord1` whether the word\n  // contained any escape sequences. This is needed because words with\n  // escape sequences must not be interpreted as keywords.\n  this.containsEsc = false;\n\n  // Set up token state\n\n  // The current position of the tokenizer in the input.\n  if (startPos) {\n    this.pos = startPos;\n    this.lineStart = this.input.lastIndexOf(\"\\n\", startPos - 1) + 1;\n    this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;\n  } else {\n    this.pos = this.lineStart = 0;\n    this.curLine = 1;\n  }\n\n  // Properties of the current token:\n  // Its type\n  this.type = types.eof;\n  // For tokens that include more information than their type, the value\n  this.value = null;\n  // Its start and end offset\n  this.start = this.end = this.pos;\n  // And, if locations are used, the {line, column} object\n  // corresponding to those offsets\n  this.startLoc = this.endLoc = this.curPosition();\n\n  // Position information for the previous token\n  this.lastTokEndLoc = this.lastTokStartLoc = null;\n  this.lastTokStart = this.lastTokEnd = this.pos;\n\n  // The context stack is used to superficially track syntactic\n  // context to predict whether a regular expression is allowed in a\n  // given position.\n  this.context = this.initialContext();\n  this.exprAllowed = true;\n\n  // Figure out if it's a module code.\n  this.inModule = options.sourceType === \"module\";\n  this.strict = this.inModule || this.strictDirective(this.pos);\n\n  // Used to signify the start of a potential arrow function\n  this.potentialArrowAt = -1;\n\n  // Positions to delayed-check that yield/await does not exist in default parameters.\n  this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;\n  // Labels in scope.\n  this.labels = [];\n  // Thus-far undefined exports.\n  this.undefinedExports = {};\n\n  // If enabled, skip leading hashbang line.\n  if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === \"#!\")\n    { this.skipLineComment(2); }\n\n  // Scope tracking for duplicate variable names (see scope.js)\n  this.scopeStack = [];\n  this.enterScope(SCOPE_TOP);\n\n  // For RegExp validation\n  this.regexpState = null;\n};\n\nvar prototypeAccessors = { inFunction: { configurable: true },inGenerator: { configurable: true },inAsync: { configurable: true },allowSuper: { configurable: true },allowDirectSuper: { configurable: true },treatFunctionsAsVar: { configurable: true } };\n\nParser.prototype.parse = function parse () {\n  var node = this.options.program || this.startNode();\n  this.nextToken();\n  return this.parseTopLevel(node)\n};\n\nprototypeAccessors.inFunction.get = function () { return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0 };\nprototypeAccessors.inGenerator.get = function () { return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0 };\nprototypeAccessors.inAsync.get = function () { return (this.currentVarScope().flags & SCOPE_ASYNC) > 0 };\nprototypeAccessors.allowSuper.get = function () { return (this.currentThisScope().flags & SCOPE_SUPER) > 0 };\nprototypeAccessors.allowDirectSuper.get = function () { return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0 };\nprototypeAccessors.treatFunctionsAsVar.get = function () { return this.treatFunctionsAsVarInScope(this.currentScope()) };\n\n// Switch to a getter for 7.0.0.\nParser.prototype.inNonArrowFunction = function inNonArrowFunction () { return (this.currentThisScope().flags & SCOPE_FUNCTION) > 0 };\n\nParser.extend = function extend () {\n    var plugins = [], len = arguments.length;\n    while ( len-- ) plugins[ len ] = arguments[ len ];\n\n  var cls = this;\n  for (var i = 0; i < plugins.length; i++) { cls = plugins[i](cls); }\n  return cls\n};\n\nParser.parse = function parse (input, options) {\n  return new this(options, input).parse()\n};\n\nParser.parseExpressionAt = function parseExpressionAt (input, pos, options) {\n  var parser = new this(options, input, pos);\n  parser.nextToken();\n  return parser.parseExpression()\n};\n\nParser.tokenizer = function tokenizer (input, options) {\n  return new this(options, input)\n};\n\nObject.defineProperties( Parser.prototype, prototypeAccessors );\n\nvar pp = Parser.prototype;\n\n// ## Parser utilities\n\nvar literal = /^(?:'((?:\\\\.|[^'])*?)'|\"((?:\\\\.|[^\"])*?)\")/;\npp.strictDirective = function(start) {\n  for (;;) {\n    // Try to find string literal.\n    skipWhiteSpace.lastIndex = start;\n    start += skipWhiteSpace.exec(this.input)[0].length;\n    var match = literal.exec(this.input.slice(start));\n    if (!match) { return false }\n    if ((match[1] || match[2]) === \"use strict\") {\n      skipWhiteSpace.lastIndex = start + match[0].length;\n      var spaceAfter = skipWhiteSpace.exec(this.input), end = spaceAfter.index + spaceAfter[0].length;\n      var next = this.input.charAt(end);\n      return next === \";\" || next === \"}\" ||\n        (lineBreak.test(spaceAfter[0]) &&\n         !(/[(`.[+\\-/*%<>=,?^&]/.test(next) || next === \"!\" && this.input.charAt(end + 1) === \"=\"))\n    }\n    start += match[0].length;\n\n    // Skip semicolon, if any.\n    skipWhiteSpace.lastIndex = start;\n    start += skipWhiteSpace.exec(this.input)[0].length;\n    if (this.input[start] === \";\")\n      { start++; }\n  }\n};\n\n// Predicate that tests whether the next token is of the given\n// type, and if yes, consumes it as a side effect.\n\npp.eat = function(type) {\n  if (this.type === type) {\n    this.next();\n    return true\n  } else {\n    return false\n  }\n};\n\n// Tests whether parsed token is a contextual keyword.\n\npp.isContextual = function(name) {\n  return this.type === types.name && this.value === name && !this.containsEsc\n};\n\n// Consumes contextual keyword if possible.\n\npp.eatContextual = function(name) {\n  if (!this.isContextual(name)) { return false }\n  this.next();\n  return true\n};\n\n// Asserts that following token is given contextual keyword.\n\npp.expectContextual = function(name) {\n  if (!this.eatContextual(name)) { this.unexpected(); }\n};\n\n// Test whether a semicolon can be inserted at the current position.\n\npp.canInsertSemicolon = function() {\n  return this.type === types.eof ||\n    this.type === types.braceR ||\n    lineBreak.test(this.input.slice(this.lastTokEnd, this.start))\n};\n\npp.insertSemicolon = function() {\n  if (this.canInsertSemicolon()) {\n    if (this.options.onInsertedSemicolon)\n      { this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc); }\n    return true\n  }\n};\n\n// Consume a semicolon, or, failing that, see if we are allowed to\n// pretend that there is a semicolon at this position.\n\npp.semicolon = function() {\n  if (!this.eat(types.semi) && !this.insertSemicolon()) { this.unexpected(); }\n};\n\npp.afterTrailingComma = function(tokType, notNext) {\n  if (this.type === tokType) {\n    if (this.options.onTrailingComma)\n      { this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc); }\n    if (!notNext)\n      { this.next(); }\n    return true\n  }\n};\n\n// Expect a token of a given type. If found, consume it, otherwise,\n// raise an unexpected token error.\n\npp.expect = function(type) {\n  this.eat(type) || this.unexpected();\n};\n\n// Raise an unexpected token error.\n\npp.unexpected = function(pos) {\n  this.raise(pos != null ? pos : this.start, \"Unexpected token\");\n};\n\nfunction DestructuringErrors() {\n  this.shorthandAssign =\n  this.trailingComma =\n  this.parenthesizedAssign =\n  this.parenthesizedBind =\n  this.doubleProto =\n    -1;\n}\n\npp.checkPatternErrors = function(refDestructuringErrors, isAssign) {\n  if (!refDestructuringErrors) { return }\n  if (refDestructuringErrors.trailingComma > -1)\n    { this.raiseRecoverable(refDestructuringErrors.trailingComma, \"Comma is not permitted after the rest element\"); }\n  var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;\n  if (parens > -1) { this.raiseRecoverable(parens, \"Parenthesized pattern\"); }\n};\n\npp.checkExpressionErrors = function(refDestructuringErrors, andThrow) {\n  if (!refDestructuringErrors) { return false }\n  var shorthandAssign = refDestructuringErrors.shorthandAssign;\n  var doubleProto = refDestructuringErrors.doubleProto;\n  if (!andThrow) { return shorthandAssign >= 0 || doubleProto >= 0 }\n  if (shorthandAssign >= 0)\n    { this.raise(shorthandAssign, \"Shorthand property assignments are valid only in destructuring patterns\"); }\n  if (doubleProto >= 0)\n    { this.raiseRecoverable(doubleProto, \"Redefinition of __proto__ property\"); }\n};\n\npp.checkYieldAwaitInDefaultParams = function() {\n  if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos))\n    { this.raise(this.yieldPos, \"Yield expression cannot be a default value\"); }\n  if (this.awaitPos)\n    { this.raise(this.awaitPos, \"Await expression cannot be a default value\"); }\n};\n\npp.isSimpleAssignTarget = function(expr) {\n  if (expr.type === \"ParenthesizedExpression\")\n    { return this.isSimpleAssignTarget(expr.expression) }\n  return expr.type === \"Identifier\" || expr.type === \"MemberExpression\"\n};\n\nvar pp$1 = Parser.prototype;\n\n// ### Statement parsing\n\n// Parse a program. Initializes the parser, reads any number of\n// statements, and wraps them in a Program node.  Optionally takes a\n// `program` argument.  If present, the statements will be appended\n// to its body instead of creating a new node.\n\npp$1.parseTopLevel = function(node) {\n  var exports = {};\n  if (!node.body) { node.body = []; }\n  while (this.type !== types.eof) {\n    var stmt = this.parseStatement(null, true, exports);\n    node.body.push(stmt);\n  }\n  if (this.inModule)\n    { for (var i = 0, list = Object.keys(this.undefinedExports); i < list.length; i += 1)\n      {\n        var name = list[i];\n\n        this.raiseRecoverable(this.undefinedExports[name].start, (\"Export '\" + name + \"' is not defined\"));\n      } }\n  this.adaptDirectivePrologue(node.body);\n  this.next();\n  node.sourceType = this.options.sourceType;\n  return this.finishNode(node, \"Program\")\n};\n\nvar loopLabel = {kind: \"loop\"}, switchLabel = {kind: \"switch\"};\n\npp$1.isLet = function(context) {\n  if (this.options.ecmaVersion < 6 || !this.isContextual(\"let\")) { return false }\n  skipWhiteSpace.lastIndex = this.pos;\n  var skip = skipWhiteSpace.exec(this.input);\n  var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);\n  // For ambiguous cases, determine if a LexicalDeclaration (or only a\n  // Statement) is allowed here. If context is not empty then only a Statement\n  // is allowed. However, `let [` is an explicit negative lookahead for\n  // ExpressionStatement, so special-case it first.\n  if (nextCh === 91) { return true } // '['\n  if (context) { return false }\n\n  if (nextCh === 123) { return true } // '{'\n  if (isIdentifierStart(nextCh, true)) {\n    var pos = next + 1;\n    while (isIdentifierChar(this.input.charCodeAt(pos), true)) { ++pos; }\n    var ident = this.input.slice(next, pos);\n    if (!keywordRelationalOperator.test(ident)) { return true }\n  }\n  return false\n};\n\n// check 'async [no LineTerminator here] function'\n// - 'async /*foo*/ function' is OK.\n// - 'async /*\\n*/ function' is invalid.\npp$1.isAsyncFunction = function() {\n  if (this.options.ecmaVersion < 8 || !this.isContextual(\"async\"))\n    { return false }\n\n  skipWhiteSpace.lastIndex = this.pos;\n  var skip = skipWhiteSpace.exec(this.input);\n  var next = this.pos + skip[0].length;\n  return !lineBreak.test(this.input.slice(this.pos, next)) &&\n    this.input.slice(next, next + 8) === \"function\" &&\n    (next + 8 === this.input.length || !isIdentifierChar(this.input.charAt(next + 8)))\n};\n\n// Parse a single statement.\n//\n// If expecting a statement and finding a slash operator, parse a\n// regular expression literal. This is to handle cases like\n// `if (foo) /blah/.exec(foo)`, where looking at the previous token\n// does not help.\n\npp$1.parseStatement = function(context, topLevel, exports) {\n  var starttype = this.type, node = this.startNode(), kind;\n\n  if (this.isLet(context)) {\n    starttype = types._var;\n    kind = \"let\";\n  }\n\n  // Most types of statements are recognized by the keyword they\n  // start with. Many are trivial to parse, some require a bit of\n  // complexity.\n\n  switch (starttype) {\n  case types._break: case types._continue: return this.parseBreakContinueStatement(node, starttype.keyword)\n  case types._debugger: return this.parseDebuggerStatement(node)\n  case types._do: return this.parseDoStatement(node)\n  case types._for: return this.parseForStatement(node)\n  case types._function:\n    // Function as sole body of either an if statement or a labeled statement\n    // works, but not when it is part of a labeled statement that is the sole\n    // body of an if statement.\n    if ((context && (this.strict || context !== \"if\" && context !== \"label\")) && this.options.ecmaVersion >= 6) { this.unexpected(); }\n    return this.parseFunctionStatement(node, false, !context)\n  case types._class:\n    if (context) { this.unexpected(); }\n    return this.parseClass(node, true)\n  case types._if: return this.parseIfStatement(node)\n  case types._return: return this.parseReturnStatement(node)\n  case types._switch: return this.parseSwitchStatement(node)\n  case types._throw: return this.parseThrowStatement(node)\n  case types._try: return this.parseTryStatement(node)\n  case types._const: case types._var:\n    kind = kind || this.value;\n    if (context && kind !== \"var\") { this.unexpected(); }\n    return this.parseVarStatement(node, kind)\n  case types._while: return this.parseWhileStatement(node)\n  case types._with: return this.parseWithStatement(node)\n  case types.braceL: return this.parseBlock(true, node)\n  case types.semi: return this.parseEmptyStatement(node)\n  case types._export:\n  case types._import:\n    if (this.options.ecmaVersion > 10 && starttype === types._import) {\n      skipWhiteSpace.lastIndex = this.pos;\n      var skip = skipWhiteSpace.exec(this.input);\n      var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);\n      if (nextCh === 40 || nextCh === 46) // '(' or '.'\n        { return this.parseExpressionStatement(node, this.parseExpression()) }\n    }\n\n    if (!this.options.allowImportExportEverywhere) {\n      if (!topLevel)\n        { this.raise(this.start, \"'import' and 'export' may only appear at the top level\"); }\n      if (!this.inModule)\n        { this.raise(this.start, \"'import' and 'export' may appear only with 'sourceType: module'\"); }\n    }\n    return starttype === types._import ? this.parseImport(node) : this.parseExport(node, exports)\n\n    // If the statement does not start with a statement keyword or a\n    // brace, it's an ExpressionStatement or LabeledStatement. We\n    // simply start parsing an expression, and afterwards, if the\n    // next token is a colon and the expression was a simple\n    // Identifier node, we switch to interpreting it as a label.\n  default:\n    if (this.isAsyncFunction()) {\n      if (context) { this.unexpected(); }\n      this.next();\n      return this.parseFunctionStatement(node, true, !context)\n    }\n\n    var maybeName = this.value, expr = this.parseExpression();\n    if (starttype === types.name && expr.type === \"Identifier\" && this.eat(types.colon))\n      { return this.parseLabeledStatement(node, maybeName, expr, context) }\n    else { return this.parseExpressionStatement(node, expr) }\n  }\n};\n\npp$1.parseBreakContinueStatement = function(node, keyword) {\n  var isBreak = keyword === \"break\";\n  this.next();\n  if (this.eat(types.semi) || this.insertSemicolon()) { node.label = null; }\n  else if (this.type !== types.name) { this.unexpected(); }\n  else {\n    node.label = this.parseIdent();\n    this.semicolon();\n  }\n\n  // Verify that there is an actual destination to break or\n  // continue to.\n  var i = 0;\n  for (; i < this.labels.length; ++i) {\n    var lab = this.labels[i];\n    if (node.label == null || lab.name === node.label.name) {\n      if (lab.kind != null && (isBreak || lab.kind === \"loop\")) { break }\n      if (node.label && isBreak) { break }\n    }\n  }\n  if (i === this.labels.length) { this.raise(node.start, \"Unsyntactic \" + keyword); }\n  return this.finishNode(node, isBreak ? \"BreakStatement\" : \"ContinueStatement\")\n};\n\npp$1.parseDebuggerStatement = function(node) {\n  this.next();\n  this.semicolon();\n  return this.finishNode(node, \"DebuggerStatement\")\n};\n\npp$1.parseDoStatement = function(node) {\n  this.next();\n  this.labels.push(loopLabel);\n  node.body = this.parseStatement(\"do\");\n  this.labels.pop();\n  this.expect(types._while);\n  node.test = this.parseParenExpression();\n  if (this.options.ecmaVersion >= 6)\n    { this.eat(types.semi); }\n  else\n    { this.semicolon(); }\n  return this.finishNode(node, \"DoWhileStatement\")\n};\n\n// Disambiguating between a `for` and a `for`/`in` or `for`/`of`\n// loop is non-trivial. Basically, we have to parse the init `var`\n// statement or expression, disallowing the `in` operator (see\n// the second parameter to `parseExpression`), and then check\n// whether the next token is `in` or `of`. When there is no init\n// part (semicolon immediately after the opening parenthesis), it\n// is a regular `for` loop.\n\npp$1.parseForStatement = function(node) {\n  this.next();\n  var awaitAt = (this.options.ecmaVersion >= 9 && (this.inAsync || (!this.inFunction && this.options.allowAwaitOutsideFunction)) && this.eatContextual(\"await\")) ? this.lastTokStart : -1;\n  this.labels.push(loopLabel);\n  this.enterScope(0);\n  this.expect(types.parenL);\n  if (this.type === types.semi) {\n    if (awaitAt > -1) { this.unexpected(awaitAt); }\n    return this.parseFor(node, null)\n  }\n  var isLet = this.isLet();\n  if (this.type === types._var || this.type === types._const || isLet) {\n    var init$1 = this.startNode(), kind = isLet ? \"let\" : this.value;\n    this.next();\n    this.parseVar(init$1, true, kind);\n    this.finishNode(init$1, \"VariableDeclaration\");\n    if ((this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual(\"of\"))) && init$1.declarations.length === 1) {\n      if (this.options.ecmaVersion >= 9) {\n        if (this.type === types._in) {\n          if (awaitAt > -1) { this.unexpected(awaitAt); }\n        } else { node.await = awaitAt > -1; }\n      }\n      return this.parseForIn(node, init$1)\n    }\n    if (awaitAt > -1) { this.unexpected(awaitAt); }\n    return this.parseFor(node, init$1)\n  }\n  var refDestructuringErrors = new DestructuringErrors;\n  var init = this.parseExpression(true, refDestructuringErrors);\n  if (this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual(\"of\"))) {\n    if (this.options.ecmaVersion >= 9) {\n      if (this.type === types._in) {\n        if (awaitAt > -1) { this.unexpected(awaitAt); }\n      } else { node.await = awaitAt > -1; }\n    }\n    this.toAssignable(init, false, refDestructuringErrors);\n    this.checkLVal(init);\n    return this.parseForIn(node, init)\n  } else {\n    this.checkExpressionErrors(refDestructuringErrors, true);\n  }\n  if (awaitAt > -1) { this.unexpected(awaitAt); }\n  return this.parseFor(node, init)\n};\n\npp$1.parseFunctionStatement = function(node, isAsync, declarationPosition) {\n  this.next();\n  return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync)\n};\n\npp$1.parseIfStatement = function(node) {\n  this.next();\n  node.test = this.parseParenExpression();\n  // allow function declarations in branches, but only in non-strict mode\n  node.consequent = this.parseStatement(\"if\");\n  node.alternate = this.eat(types._else) ? this.parseStatement(\"if\") : null;\n  return this.finishNode(node, \"IfStatement\")\n};\n\npp$1.parseReturnStatement = function(node) {\n  if (!this.inFunction && !this.options.allowReturnOutsideFunction)\n    { this.raise(this.start, \"'return' outside of function\"); }\n  this.next();\n\n  // In `return` (and `break`/`continue`), the keywords with\n  // optional arguments, we eagerly look for a semicolon or the\n  // possibility to insert one.\n\n  if (this.eat(types.semi) || this.insertSemicolon()) { node.argument = null; }\n  else { node.argument = this.parseExpression(); this.semicolon(); }\n  return this.finishNode(node, \"ReturnStatement\")\n};\n\npp$1.parseSwitchStatement = function(node) {\n  this.next();\n  node.discriminant = this.parseParenExpression();\n  node.cases = [];\n  this.expect(types.braceL);\n  this.labels.push(switchLabel);\n  this.enterScope(0);\n\n  // Statements under must be grouped (by label) in SwitchCase\n  // nodes. `cur` is used to keep the node that we are currently\n  // adding statements to.\n\n  var cur;\n  for (var sawDefault = false; this.type !== types.braceR;) {\n    if (this.type === types._case || this.type === types._default) {\n      var isCase = this.type === types._case;\n      if (cur) { this.finishNode(cur, \"SwitchCase\"); }\n      node.cases.push(cur = this.startNode());\n      cur.consequent = [];\n      this.next();\n      if (isCase) {\n        cur.test = this.parseExpression();\n      } else {\n        if (sawDefault) { this.raiseRecoverable(this.lastTokStart, \"Multiple default clauses\"); }\n        sawDefault = true;\n        cur.test = null;\n      }\n      this.expect(types.colon);\n    } else {\n      if (!cur) { this.unexpected(); }\n      cur.consequent.push(this.parseStatement(null));\n    }\n  }\n  this.exitScope();\n  if (cur) { this.finishNode(cur, \"SwitchCase\"); }\n  this.next(); // Closing brace\n  this.labels.pop();\n  return this.finishNode(node, \"SwitchStatement\")\n};\n\npp$1.parseThrowStatement = function(node) {\n  this.next();\n  if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start)))\n    { this.raise(this.lastTokEnd, \"Illegal newline after throw\"); }\n  node.argument = this.parseExpression();\n  this.semicolon();\n  return this.finishNode(node, \"ThrowStatement\")\n};\n\n// Reused empty array added for node fields that are always empty.\n\nvar empty = [];\n\npp$1.parseTryStatement = function(node) {\n  this.next();\n  node.block = this.parseBlock();\n  node.handler = null;\n  if (this.type === types._catch) {\n    var clause = this.startNode();\n    this.next();\n    if (this.eat(types.parenL)) {\n      clause.param = this.parseBindingAtom();\n      var simple = clause.param.type === \"Identifier\";\n      this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);\n      this.checkLVal(clause.param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);\n      this.expect(types.parenR);\n    } else {\n      if (this.options.ecmaVersion < 10) { this.unexpected(); }\n      clause.param = null;\n      this.enterScope(0);\n    }\n    clause.body = this.parseBlock(false);\n    this.exitScope();\n    node.handler = this.finishNode(clause, \"CatchClause\");\n  }\n  node.finalizer = this.eat(types._finally) ? this.parseBlock() : null;\n  if (!node.handler && !node.finalizer)\n    { this.raise(node.start, \"Missing catch or finally clause\"); }\n  return this.finishNode(node, \"TryStatement\")\n};\n\npp$1.parseVarStatement = function(node, kind) {\n  this.next();\n  this.parseVar(node, false, kind);\n  this.semicolon();\n  return this.finishNode(node, \"VariableDeclaration\")\n};\n\npp$1.parseWhileStatement = function(node) {\n  this.next();\n  node.test = this.parseParenExpression();\n  this.labels.push(loopLabel);\n  node.body = this.parseStatement(\"while\");\n  this.labels.pop();\n  return this.finishNode(node, \"WhileStatement\")\n};\n\npp$1.parseWithStatement = function(node) {\n  if (this.strict) { this.raise(this.start, \"'with' in strict mode\"); }\n  this.next();\n  node.object = this.parseParenExpression();\n  node.body = this.parseStatement(\"with\");\n  return this.finishNode(node, \"WithStatement\")\n};\n\npp$1.parseEmptyStatement = function(node) {\n  this.next();\n  return this.finishNode(node, \"EmptyStatement\")\n};\n\npp$1.parseLabeledStatement = function(node, maybeName, expr, context) {\n  for (var i$1 = 0, list = this.labels; i$1 < list.length; i$1 += 1)\n    {\n    var label = list[i$1];\n\n    if (label.name === maybeName)\n      { this.raise(expr.start, \"Label '\" + maybeName + \"' is already declared\");\n  } }\n  var kind = this.type.isLoop ? \"loop\" : this.type === types._switch ? \"switch\" : null;\n  for (var i = this.labels.length - 1; i >= 0; i--) {\n    var label$1 = this.labels[i];\n    if (label$1.statementStart === node.start) {\n      // Update information about previous labels on this node\n      label$1.statementStart = this.start;\n      label$1.kind = kind;\n    } else { break }\n  }\n  this.labels.push({name: maybeName, kind: kind, statementStart: this.start});\n  node.body = this.parseStatement(context ? context.indexOf(\"label\") === -1 ? context + \"label\" : context : \"label\");\n  this.labels.pop();\n  node.label = expr;\n  return this.finishNode(node, \"LabeledStatement\")\n};\n\npp$1.parseExpressionStatement = function(node, expr) {\n  node.expression = expr;\n  this.semicolon();\n  return this.finishNode(node, \"ExpressionStatement\")\n};\n\n// Parse a semicolon-enclosed block of statements, handling `\"use\n// strict\"` declarations when `allowStrict` is true (used for\n// function bodies).\n\npp$1.parseBlock = function(createNewLexicalScope, node, exitStrict) {\n  if ( createNewLexicalScope === void 0 ) createNewLexicalScope = true;\n  if ( node === void 0 ) node = this.startNode();\n\n  node.body = [];\n  this.expect(types.braceL);\n  if (createNewLexicalScope) { this.enterScope(0); }\n  while (this.type !== types.braceR) {\n    var stmt = this.parseStatement(null);\n    node.body.push(stmt);\n  }\n  if (exitStrict) { this.strict = false; }\n  this.next();\n  if (createNewLexicalScope) { this.exitScope(); }\n  return this.finishNode(node, \"BlockStatement\")\n};\n\n// Parse a regular `for` loop. The disambiguation code in\n// `parseStatement` will already have parsed the init statement or\n// expression.\n\npp$1.parseFor = function(node, init) {\n  node.init = init;\n  this.expect(types.semi);\n  node.test = this.type === types.semi ? null : this.parseExpression();\n  this.expect(types.semi);\n  node.update = this.type === types.parenR ? null : this.parseExpression();\n  this.expect(types.parenR);\n  node.body = this.parseStatement(\"for\");\n  this.exitScope();\n  this.labels.pop();\n  return this.finishNode(node, \"ForStatement\")\n};\n\n// Parse a `for`/`in` and `for`/`of` loop, which are almost\n// same from parser's perspective.\n\npp$1.parseForIn = function(node, init) {\n  var isForIn = this.type === types._in;\n  this.next();\n\n  if (\n    init.type === \"VariableDeclaration\" &&\n    init.declarations[0].init != null &&\n    (\n      !isForIn ||\n      this.options.ecmaVersion < 8 ||\n      this.strict ||\n      init.kind !== \"var\" ||\n      init.declarations[0].id.type !== \"Identifier\"\n    )\n  ) {\n    this.raise(\n      init.start,\n      ((isForIn ? \"for-in\" : \"for-of\") + \" loop variable declaration may not have an initializer\")\n    );\n  } else if (init.type === \"AssignmentPattern\") {\n    this.raise(init.start, \"Invalid left-hand side in for-loop\");\n  }\n  node.left = init;\n  node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();\n  this.expect(types.parenR);\n  node.body = this.parseStatement(\"for\");\n  this.exitScope();\n  this.labels.pop();\n  return this.finishNode(node, isForIn ? \"ForInStatement\" : \"ForOfStatement\")\n};\n\n// Parse a list of variable declarations.\n\npp$1.parseVar = function(node, isFor, kind) {\n  node.declarations = [];\n  node.kind = kind;\n  for (;;) {\n    var decl = this.startNode();\n    this.parseVarId(decl, kind);\n    if (this.eat(types.eq)) {\n      decl.init = this.parseMaybeAssign(isFor);\n    } else if (kind === \"const\" && !(this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual(\"of\")))) {\n      this.unexpected();\n    } else if (decl.id.type !== \"Identifier\" && !(isFor && (this.type === types._in || this.isContextual(\"of\")))) {\n      this.raise(this.lastTokEnd, \"Complex binding patterns require an initialization value\");\n    } else {\n      decl.init = null;\n    }\n    node.declarations.push(this.finishNode(decl, \"VariableDeclarator\"));\n    if (!this.eat(types.comma)) { break }\n  }\n  return node\n};\n\npp$1.parseVarId = function(decl, kind) {\n  decl.id = this.parseBindingAtom();\n  this.checkLVal(decl.id, kind === \"var\" ? BIND_VAR : BIND_LEXICAL, false);\n};\n\nvar FUNC_STATEMENT = 1, FUNC_HANGING_STATEMENT = 2, FUNC_NULLABLE_ID = 4;\n\n// Parse a function declaration or literal (depending on the\n// `statement & FUNC_STATEMENT`).\n\n// Remove `allowExpressionBody` for 7.0.0, as it is only called with false\npp$1.parseFunction = function(node, statement, allowExpressionBody, isAsync) {\n  this.initFunction(node);\n  if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {\n    if (this.type === types.star && (statement & FUNC_HANGING_STATEMENT))\n      { this.unexpected(); }\n    node.generator = this.eat(types.star);\n  }\n  if (this.options.ecmaVersion >= 8)\n    { node.async = !!isAsync; }\n\n  if (statement & FUNC_STATEMENT) {\n    node.id = (statement & FUNC_NULLABLE_ID) && this.type !== types.name ? null : this.parseIdent();\n    if (node.id && !(statement & FUNC_HANGING_STATEMENT))\n      // If it is a regular function declaration in sloppy mode, then it is\n      // subject to Annex B semantics (BIND_FUNCTION). Otherwise, the binding\n      // mode depends on properties of the current scope (see\n      // treatFunctionsAsVar).\n      { this.checkLVal(node.id, (this.strict || node.generator || node.async) ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION); }\n  }\n\n  var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\n  this.yieldPos = 0;\n  this.awaitPos = 0;\n  this.awaitIdentPos = 0;\n  this.enterScope(functionFlags(node.async, node.generator));\n\n  if (!(statement & FUNC_STATEMENT))\n    { node.id = this.type === types.name ? this.parseIdent() : null; }\n\n  this.parseFunctionParams(node);\n  this.parseFunctionBody(node, allowExpressionBody, false);\n\n  this.yieldPos = oldYieldPos;\n  this.awaitPos = oldAwaitPos;\n  this.awaitIdentPos = oldAwaitIdentPos;\n  return this.finishNode(node, (statement & FUNC_STATEMENT) ? \"FunctionDeclaration\" : \"FunctionExpression\")\n};\n\npp$1.parseFunctionParams = function(node) {\n  this.expect(types.parenL);\n  node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);\n  this.checkYieldAwaitInDefaultParams();\n};\n\n// Parse a class declaration or literal (depending on the\n// `isStatement` parameter).\n\npp$1.parseClass = function(node, isStatement) {\n  this.next();\n\n  // ecma-262 14.6 Class Definitions\n  // A class definition is always strict mode code.\n  var oldStrict = this.strict;\n  this.strict = true;\n\n  this.parseClassId(node, isStatement);\n  this.parseClassSuper(node);\n  var classBody = this.startNode();\n  var hadConstructor = false;\n  classBody.body = [];\n  this.expect(types.braceL);\n  while (this.type !== types.braceR) {\n    var element = this.parseClassElement(node.superClass !== null);\n    if (element) {\n      classBody.body.push(element);\n      if (element.type === \"MethodDefinition\" && element.kind === \"constructor\") {\n        if (hadConstructor) { this.raise(element.start, \"Duplicate constructor in the same class\"); }\n        hadConstructor = true;\n      }\n    }\n  }\n  this.strict = oldStrict;\n  this.next();\n  node.body = this.finishNode(classBody, \"ClassBody\");\n  return this.finishNode(node, isStatement ? \"ClassDeclaration\" : \"ClassExpression\")\n};\n\npp$1.parseClassElement = function(constructorAllowsSuper) {\n  var this$1 = this;\n\n  if (this.eat(types.semi)) { return null }\n\n  var method = this.startNode();\n  var tryContextual = function (k, noLineBreak) {\n    if ( noLineBreak === void 0 ) noLineBreak = false;\n\n    var start = this$1.start, startLoc = this$1.startLoc;\n    if (!this$1.eatContextual(k)) { return false }\n    if (this$1.type !== types.parenL && (!noLineBreak || !this$1.canInsertSemicolon())) { return true }\n    if (method.key) { this$1.unexpected(); }\n    method.computed = false;\n    method.key = this$1.startNodeAt(start, startLoc);\n    method.key.name = k;\n    this$1.finishNode(method.key, \"Identifier\");\n    return false\n  };\n\n  method.kind = \"method\";\n  method.static = tryContextual(\"static\");\n  var isGenerator = this.eat(types.star);\n  var isAsync = false;\n  if (!isGenerator) {\n    if (this.options.ecmaVersion >= 8 && tryContextual(\"async\", true)) {\n      isAsync = true;\n      isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);\n    } else if (tryContextual(\"get\")) {\n      method.kind = \"get\";\n    } else if (tryContextual(\"set\")) {\n      method.kind = \"set\";\n    }\n  }\n  if (!method.key) { this.parsePropertyName(method); }\n  var key = method.key;\n  var allowsDirectSuper = false;\n  if (!method.computed && !method.static && (key.type === \"Identifier\" && key.name === \"constructor\" ||\n      key.type === \"Literal\" && key.value === \"constructor\")) {\n    if (method.kind !== \"method\") { this.raise(key.start, \"Constructor can't have get/set modifier\"); }\n    if (isGenerator) { this.raise(key.start, \"Constructor can't be a generator\"); }\n    if (isAsync) { this.raise(key.start, \"Constructor can't be an async method\"); }\n    method.kind = \"constructor\";\n    allowsDirectSuper = constructorAllowsSuper;\n  } else if (method.static && key.type === \"Identifier\" && key.name === \"prototype\") {\n    this.raise(key.start, \"Classes may not have a static property named prototype\");\n  }\n  this.parseClassMethod(method, isGenerator, isAsync, allowsDirectSuper);\n  if (method.kind === \"get\" && method.value.params.length !== 0)\n    { this.raiseRecoverable(method.value.start, \"getter should have no params\"); }\n  if (method.kind === \"set\" && method.value.params.length !== 1)\n    { this.raiseRecoverable(method.value.start, \"setter should have exactly one param\"); }\n  if (method.kind === \"set\" && method.value.params[0].type === \"RestElement\")\n    { this.raiseRecoverable(method.value.params[0].start, \"Setter cannot use rest params\"); }\n  return method\n};\n\npp$1.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {\n  method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);\n  return this.finishNode(method, \"MethodDefinition\")\n};\n\npp$1.parseClassId = function(node, isStatement) {\n  if (this.type === types.name) {\n    node.id = this.parseIdent();\n    if (isStatement)\n      { this.checkLVal(node.id, BIND_LEXICAL, false); }\n  } else {\n    if (isStatement === true)\n      { this.unexpected(); }\n    node.id = null;\n  }\n};\n\npp$1.parseClassSuper = function(node) {\n  node.superClass = this.eat(types._extends) ? this.parseExprSubscripts() : null;\n};\n\n// Parses module export declaration.\n\npp$1.parseExport = function(node, exports) {\n  this.next();\n  // export * from '...'\n  if (this.eat(types.star)) {\n    if (this.options.ecmaVersion >= 11) {\n      if (this.eatContextual(\"as\")) {\n        node.exported = this.parseIdent(true);\n        this.checkExport(exports, node.exported.name, this.lastTokStart);\n      } else {\n        node.exported = null;\n      }\n    }\n    this.expectContextual(\"from\");\n    if (this.type !== types.string) { this.unexpected(); }\n    node.source = this.parseExprAtom();\n    this.semicolon();\n    return this.finishNode(node, \"ExportAllDeclaration\")\n  }\n  if (this.eat(types._default)) { // export default ...\n    this.checkExport(exports, \"default\", this.lastTokStart);\n    var isAsync;\n    if (this.type === types._function || (isAsync = this.isAsyncFunction())) {\n      var fNode = this.startNode();\n      this.next();\n      if (isAsync) { this.next(); }\n      node.declaration = this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);\n    } else if (this.type === types._class) {\n      var cNode = this.startNode();\n      node.declaration = this.parseClass(cNode, \"nullableID\");\n    } else {\n      node.declaration = this.parseMaybeAssign();\n      this.semicolon();\n    }\n    return this.finishNode(node, \"ExportDefaultDeclaration\")\n  }\n  // export var|const|let|function|class ...\n  if (this.shouldParseExportStatement()) {\n    node.declaration = this.parseStatement(null);\n    if (node.declaration.type === \"VariableDeclaration\")\n      { this.checkVariableExport(exports, node.declaration.declarations); }\n    else\n      { this.checkExport(exports, node.declaration.id.name, node.declaration.id.start); }\n    node.specifiers = [];\n    node.source = null;\n  } else { // export { x, y as z } [from '...']\n    node.declaration = null;\n    node.specifiers = this.parseExportSpecifiers(exports);\n    if (this.eatContextual(\"from\")) {\n      if (this.type !== types.string) { this.unexpected(); }\n      node.source = this.parseExprAtom();\n    } else {\n      for (var i = 0, list = node.specifiers; i < list.length; i += 1) {\n        // check for keywords used as local names\n        var spec = list[i];\n\n        this.checkUnreserved(spec.local);\n        // check if export is defined\n        this.checkLocalExport(spec.local);\n      }\n\n      node.source = null;\n    }\n    this.semicolon();\n  }\n  return this.finishNode(node, \"ExportNamedDeclaration\")\n};\n\npp$1.checkExport = function(exports, name, pos) {\n  if (!exports) { return }\n  if (has(exports, name))\n    { this.raiseRecoverable(pos, \"Duplicate export '\" + name + \"'\"); }\n  exports[name] = true;\n};\n\npp$1.checkPatternExport = function(exports, pat) {\n  var type = pat.type;\n  if (type === \"Identifier\")\n    { this.checkExport(exports, pat.name, pat.start); }\n  else if (type === \"ObjectPattern\")\n    { for (var i = 0, list = pat.properties; i < list.length; i += 1)\n      {\n        var prop = list[i];\n\n        this.checkPatternExport(exports, prop);\n      } }\n  else if (type === \"ArrayPattern\")\n    { for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {\n      var elt = list$1[i$1];\n\n        if (elt) { this.checkPatternExport(exports, elt); }\n    } }\n  else if (type === \"Property\")\n    { this.checkPatternExport(exports, pat.value); }\n  else if (type === \"AssignmentPattern\")\n    { this.checkPatternExport(exports, pat.left); }\n  else if (type === \"RestElement\")\n    { this.checkPatternExport(exports, pat.argument); }\n  else if (type === \"ParenthesizedExpression\")\n    { this.checkPatternExport(exports, pat.expression); }\n};\n\npp$1.checkVariableExport = function(exports, decls) {\n  if (!exports) { return }\n  for (var i = 0, list = decls; i < list.length; i += 1)\n    {\n    var decl = list[i];\n\n    this.checkPatternExport(exports, decl.id);\n  }\n};\n\npp$1.shouldParseExportStatement = function() {\n  return this.type.keyword === \"var\" ||\n    this.type.keyword === \"const\" ||\n    this.type.keyword === \"class\" ||\n    this.type.keyword === \"function\" ||\n    this.isLet() ||\n    this.isAsyncFunction()\n};\n\n// Parses a comma-separated list of module exports.\n\npp$1.parseExportSpecifiers = function(exports) {\n  var nodes = [], first = true;\n  // export { x, y as z } [from '...']\n  this.expect(types.braceL);\n  while (!this.eat(types.braceR)) {\n    if (!first) {\n      this.expect(types.comma);\n      if (this.afterTrailingComma(types.braceR)) { break }\n    } else { first = false; }\n\n    var node = this.startNode();\n    node.local = this.parseIdent(true);\n    node.exported = this.eatContextual(\"as\") ? this.parseIdent(true) : node.local;\n    this.checkExport(exports, node.exported.name, node.exported.start);\n    nodes.push(this.finishNode(node, \"ExportSpecifier\"));\n  }\n  return nodes\n};\n\n// Parses import declaration.\n\npp$1.parseImport = function(node) {\n  this.next();\n  // import '...'\n  if (this.type === types.string) {\n    node.specifiers = empty;\n    node.source = this.parseExprAtom();\n  } else {\n    node.specifiers = this.parseImportSpecifiers();\n    this.expectContextual(\"from\");\n    node.source = this.type === types.string ? this.parseExprAtom() : this.unexpected();\n  }\n  this.semicolon();\n  return this.finishNode(node, \"ImportDeclaration\")\n};\n\n// Parses a comma-separated list of module imports.\n\npp$1.parseImportSpecifiers = function() {\n  var nodes = [], first = true;\n  if (this.type === types.name) {\n    // import defaultObj, { x, y as z } from '...'\n    var node = this.startNode();\n    node.local = this.parseIdent();\n    this.checkLVal(node.local, BIND_LEXICAL);\n    nodes.push(this.finishNode(node, \"ImportDefaultSpecifier\"));\n    if (!this.eat(types.comma)) { return nodes }\n  }\n  if (this.type === types.star) {\n    var node$1 = this.startNode();\n    this.next();\n    this.expectContextual(\"as\");\n    node$1.local = this.parseIdent();\n    this.checkLVal(node$1.local, BIND_LEXICAL);\n    nodes.push(this.finishNode(node$1, \"ImportNamespaceSpecifier\"));\n    return nodes\n  }\n  this.expect(types.braceL);\n  while (!this.eat(types.braceR)) {\n    if (!first) {\n      this.expect(types.comma);\n      if (this.afterTrailingComma(types.braceR)) { break }\n    } else { first = false; }\n\n    var node$2 = this.startNode();\n    node$2.imported = this.parseIdent(true);\n    if (this.eatContextual(\"as\")) {\n      node$2.local = this.parseIdent();\n    } else {\n      this.checkUnreserved(node$2.imported);\n      node$2.local = node$2.imported;\n    }\n    this.checkLVal(node$2.local, BIND_LEXICAL);\n    nodes.push(this.finishNode(node$2, \"ImportSpecifier\"));\n  }\n  return nodes\n};\n\n// Set `ExpressionStatement#directive` property for directive prologues.\npp$1.adaptDirectivePrologue = function(statements) {\n  for (var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i) {\n    statements[i].directive = statements[i].expression.raw.slice(1, -1);\n  }\n};\npp$1.isDirectiveCandidate = function(statement) {\n  return (\n    statement.type === \"ExpressionStatement\" &&\n    statement.expression.type === \"Literal\" &&\n    typeof statement.expression.value === \"string\" &&\n    // Reject parenthesized strings.\n    (this.input[statement.start] === \"\\\"\" || this.input[statement.start] === \"'\")\n  )\n};\n\nvar pp$2 = Parser.prototype;\n\n// Convert existing expression atom to assignable pattern\n// if possible.\n\npp$2.toAssignable = function(node, isBinding, refDestructuringErrors) {\n  if (this.options.ecmaVersion >= 6 && node) {\n    switch (node.type) {\n    case \"Identifier\":\n      if (this.inAsync && node.name === \"await\")\n        { this.raise(node.start, \"Cannot use 'await' as identifier inside an async function\"); }\n      break\n\n    case \"ObjectPattern\":\n    case \"ArrayPattern\":\n    case \"RestElement\":\n      break\n\n    case \"ObjectExpression\":\n      node.type = \"ObjectPattern\";\n      if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }\n      for (var i = 0, list = node.properties; i < list.length; i += 1) {\n        var prop = list[i];\n\n      this.toAssignable(prop, isBinding);\n        // Early error:\n        //   AssignmentRestProperty[Yield, Await] :\n        //     `...` DestructuringAssignmentTarget[Yield, Await]\n        //\n        //   It is a Syntax Error if |DestructuringAssignmentTarget| is an |ArrayLiteral| or an |ObjectLiteral|.\n        if (\n          prop.type === \"RestElement\" &&\n          (prop.argument.type === \"ArrayPattern\" || prop.argument.type === \"ObjectPattern\")\n        ) {\n          this.raise(prop.argument.start, \"Unexpected token\");\n        }\n      }\n      break\n\n    case \"Property\":\n      // AssignmentProperty has type === \"Property\"\n      if (node.kind !== \"init\") { this.raise(node.key.start, \"Object pattern can't contain getter or setter\"); }\n      this.toAssignable(node.value, isBinding);\n      break\n\n    case \"ArrayExpression\":\n      node.type = \"ArrayPattern\";\n      if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }\n      this.toAssignableList(node.elements, isBinding);\n      break\n\n    case \"SpreadElement\":\n      node.type = \"RestElement\";\n      this.toAssignable(node.argument, isBinding);\n      if (node.argument.type === \"AssignmentPattern\")\n        { this.raise(node.argument.start, \"Rest elements cannot have a default value\"); }\n      break\n\n    case \"AssignmentExpression\":\n      if (node.operator !== \"=\") { this.raise(node.left.end, \"Only '=' operator can be used for specifying default value.\"); }\n      node.type = \"AssignmentPattern\";\n      delete node.operator;\n      this.toAssignable(node.left, isBinding);\n      // falls through to AssignmentPattern\n\n    case \"AssignmentPattern\":\n      break\n\n    case \"ParenthesizedExpression\":\n      this.toAssignable(node.expression, isBinding, refDestructuringErrors);\n      break\n\n    case \"ChainExpression\":\n      this.raiseRecoverable(node.start, \"Optional chaining cannot appear in left-hand side\");\n      break\n\n    case \"MemberExpression\":\n      if (!isBinding) { break }\n\n    default:\n      this.raise(node.start, \"Assigning to rvalue\");\n    }\n  } else if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }\n  return node\n};\n\n// Convert list of expression atoms to binding list.\n\npp$2.toAssignableList = function(exprList, isBinding) {\n  var end = exprList.length;\n  for (var i = 0; i < end; i++) {\n    var elt = exprList[i];\n    if (elt) { this.toAssignable(elt, isBinding); }\n  }\n  if (end) {\n    var last = exprList[end - 1];\n    if (this.options.ecmaVersion === 6 && isBinding && last && last.type === \"RestElement\" && last.argument.type !== \"Identifier\")\n      { this.unexpected(last.argument.start); }\n  }\n  return exprList\n};\n\n// Parses spread element.\n\npp$2.parseSpread = function(refDestructuringErrors) {\n  var node = this.startNode();\n  this.next();\n  node.argument = this.parseMaybeAssign(false, refDestructuringErrors);\n  return this.finishNode(node, \"SpreadElement\")\n};\n\npp$2.parseRestBinding = function() {\n  var node = this.startNode();\n  this.next();\n\n  // RestElement inside of a function parameter must be an identifier\n  if (this.options.ecmaVersion === 6 && this.type !== types.name)\n    { this.unexpected(); }\n\n  node.argument = this.parseBindingAtom();\n\n  return this.finishNode(node, \"RestElement\")\n};\n\n// Parses lvalue (assignable) atom.\n\npp$2.parseBindingAtom = function() {\n  if (this.options.ecmaVersion >= 6) {\n    switch (this.type) {\n    case types.bracketL:\n      var node = this.startNode();\n      this.next();\n      node.elements = this.parseBindingList(types.bracketR, true, true);\n      return this.finishNode(node, \"ArrayPattern\")\n\n    case types.braceL:\n      return this.parseObj(true)\n    }\n  }\n  return this.parseIdent()\n};\n\npp$2.parseBindingList = function(close, allowEmpty, allowTrailingComma) {\n  var elts = [], first = true;\n  while (!this.eat(close)) {\n    if (first) { first = false; }\n    else { this.expect(types.comma); }\n    if (allowEmpty && this.type === types.comma) {\n      elts.push(null);\n    } else if (allowTrailingComma && this.afterTrailingComma(close)) {\n      break\n    } else if (this.type === types.ellipsis) {\n      var rest = this.parseRestBinding();\n      this.parseBindingListItem(rest);\n      elts.push(rest);\n      if (this.type === types.comma) { this.raise(this.start, \"Comma is not permitted after the rest element\"); }\n      this.expect(close);\n      break\n    } else {\n      var elem = this.parseMaybeDefault(this.start, this.startLoc);\n      this.parseBindingListItem(elem);\n      elts.push(elem);\n    }\n  }\n  return elts\n};\n\npp$2.parseBindingListItem = function(param) {\n  return param\n};\n\n// Parses assignment pattern around given atom if possible.\n\npp$2.parseMaybeDefault = function(startPos, startLoc, left) {\n  left = left || this.parseBindingAtom();\n  if (this.options.ecmaVersion < 6 || !this.eat(types.eq)) { return left }\n  var node = this.startNodeAt(startPos, startLoc);\n  node.left = left;\n  node.right = this.parseMaybeAssign();\n  return this.finishNode(node, \"AssignmentPattern\")\n};\n\n// Verify that a node is an lval \u2014 something that can be assigned\n// to.\n// bindingType can be either:\n// 'var' indicating that the lval creates a 'var' binding\n// 'let' indicating that the lval creates a lexical ('let' or 'const') binding\n// 'none' indicating that the binding should be checked for illegal identifiers, but not for duplicate references\n\npp$2.checkLVal = function(expr, bindingType, checkClashes) {\n  if ( bindingType === void 0 ) bindingType = BIND_NONE;\n\n  switch (expr.type) {\n  case \"Identifier\":\n    if (bindingType === BIND_LEXICAL && expr.name === \"let\")\n      { this.raiseRecoverable(expr.start, \"let is disallowed as a lexically bound name\"); }\n    if (this.strict && this.reservedWordsStrictBind.test(expr.name))\n      { this.raiseRecoverable(expr.start, (bindingType ? \"Binding \" : \"Assigning to \") + expr.name + \" in strict mode\"); }\n    if (checkClashes) {\n      if (has(checkClashes, expr.name))\n        { this.raiseRecoverable(expr.start, \"Argument name clash\"); }\n      checkClashes[expr.name] = true;\n    }\n    if (bindingType !== BIND_NONE && bindingType !== BIND_OUTSIDE) { this.declareName(expr.name, bindingType, expr.start); }\n    break\n\n  case \"ChainExpression\":\n    this.raiseRecoverable(expr.start, \"Optional chaining cannot appear in left-hand side\");\n    break\n\n  case \"MemberExpression\":\n    if (bindingType) { this.raiseRecoverable(expr.start, \"Binding member expression\"); }\n    break\n\n  case \"ObjectPattern\":\n    for (var i = 0, list = expr.properties; i < list.length; i += 1)\n      {\n    var prop = list[i];\n\n    this.checkLVal(prop, bindingType, checkClashes);\n  }\n    break\n\n  case \"Property\":\n    // AssignmentProperty has type === \"Property\"\n    this.checkLVal(expr.value, bindingType, checkClashes);\n    break\n\n  case \"ArrayPattern\":\n    for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {\n      var elem = list$1[i$1];\n\n    if (elem) { this.checkLVal(elem, bindingType, checkClashes); }\n    }\n    break\n\n  case \"AssignmentPattern\":\n    this.checkLVal(expr.left, bindingType, checkClashes);\n    break\n\n  case \"RestElement\":\n    this.checkLVal(expr.argument, bindingType, checkClashes);\n    break\n\n  case \"ParenthesizedExpression\":\n    this.checkLVal(expr.expression, bindingType, checkClashes);\n    break\n\n  default:\n    this.raise(expr.start, (bindingType ? \"Binding\" : \"Assigning to\") + \" rvalue\");\n  }\n};\n\n// A recursive descent parser operates by defining functions for all\n\nvar pp$3 = Parser.prototype;\n\n// Check if property name clashes with already added.\n// Object/class getters and setters are not allowed to clash \u2014\n// either with each other or with an init property \u2014 and in\n// strict mode, init properties are also not allowed to be repeated.\n\npp$3.checkPropClash = function(prop, propHash, refDestructuringErrors) {\n  if (this.options.ecmaVersion >= 9 && prop.type === \"SpreadElement\")\n    { return }\n  if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand))\n    { return }\n  var key = prop.key;\n  var name;\n  switch (key.type) {\n  case \"Identifier\": name = key.name; break\n  case \"Literal\": name = String(key.value); break\n  default: return\n  }\n  var kind = prop.kind;\n  if (this.options.ecmaVersion >= 6) {\n    if (name === \"__proto__\" && kind === \"init\") {\n      if (propHash.proto) {\n        if (refDestructuringErrors) {\n          if (refDestructuringErrors.doubleProto < 0)\n            { refDestructuringErrors.doubleProto = key.start; }\n          // Backwards-compat kludge. Can be removed in version 6.0\n        } else { this.raiseRecoverable(key.start, \"Redefinition of __proto__ property\"); }\n      }\n      propHash.proto = true;\n    }\n    return\n  }\n  name = \"$\" + name;\n  var other = propHash[name];\n  if (other) {\n    var redefinition;\n    if (kind === \"init\") {\n      redefinition = this.strict && other.init || other.get || other.set;\n    } else {\n      redefinition = other.init || other[kind];\n    }\n    if (redefinition)\n      { this.raiseRecoverable(key.start, \"Redefinition of property\"); }\n  } else {\n    other = propHash[name] = {\n      init: false,\n      get: false,\n      set: false\n    };\n  }\n  other[kind] = true;\n};\n\n// ### Expression parsing\n\n// These nest, from the most general expression type at the top to\n// 'atomic', nondivisible expression types at the bottom. Most of\n// the functions will simply let the function(s) below them parse,\n// and, *if* the syntactic construct they handle is present, wrap\n// the AST node that the inner parser gave them in another node.\n\n// Parse a full expression. The optional arguments are used to\n// forbid the `in` operator (in for loops initalization expressions)\n// and provide reference for storing '=' operator inside shorthand\n// property assignment in contexts where both object expression\n// and object pattern might appear (so it's possible to raise\n// delayed syntax error at correct position).\n\npp$3.parseExpression = function(noIn, refDestructuringErrors) {\n  var startPos = this.start, startLoc = this.startLoc;\n  var expr = this.parseMaybeAssign(noIn, refDestructuringErrors);\n  if (this.type === types.comma) {\n    var node = this.startNodeAt(startPos, startLoc);\n    node.expressions = [expr];\n    while (this.eat(types.comma)) { node.expressions.push(this.parseMaybeAssign(noIn, refDestructuringErrors)); }\n    return this.finishNode(node, \"SequenceExpression\")\n  }\n  return expr\n};\n\n// Parse an assignment expression. This includes applications of\n// operators like `+=`.\n\npp$3.parseMaybeAssign = function(noIn, refDestructuringErrors, afterLeftParse) {\n  if (this.isContextual(\"yield\")) {\n    if (this.inGenerator) { return this.parseYield(noIn) }\n    // The tokenizer will assume an expression is allowed after\n    // `yield`, but this isn't that kind of yield\n    else { this.exprAllowed = false; }\n  }\n\n  var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1;\n  if (refDestructuringErrors) {\n    oldParenAssign = refDestructuringErrors.parenthesizedAssign;\n    oldTrailingComma = refDestructuringErrors.trailingComma;\n    refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;\n  } else {\n    refDestructuringErrors = new DestructuringErrors;\n    ownDestructuringErrors = true;\n  }\n\n  var startPos = this.start, startLoc = this.startLoc;\n  if (this.type === types.parenL || this.type === types.name)\n    { this.potentialArrowAt = this.start; }\n  var left = this.parseMaybeConditional(noIn, refDestructuringErrors);\n  if (afterLeftParse) { left = afterLeftParse.call(this, left, startPos, startLoc); }\n  if (this.type.isAssign) {\n    var node = this.startNodeAt(startPos, startLoc);\n    node.operator = this.value;\n    node.left = this.type === types.eq ? this.toAssignable(left, false, refDestructuringErrors) : left;\n    if (!ownDestructuringErrors) {\n      refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;\n    }\n    if (refDestructuringErrors.shorthandAssign >= node.left.start)\n      { refDestructuringErrors.shorthandAssign = -1; } // reset because shorthand default was used correctly\n    this.checkLVal(left);\n    this.next();\n    node.right = this.parseMaybeAssign(noIn);\n    return this.finishNode(node, \"AssignmentExpression\")\n  } else {\n    if (ownDestructuringErrors) { this.checkExpressionErrors(refDestructuringErrors, true); }\n  }\n  if (oldParenAssign > -1) { refDestructuringErrors.parenthesizedAssign = oldParenAssign; }\n  if (oldTrailingComma > -1) { refDestructuringErrors.trailingComma = oldTrailingComma; }\n  return left\n};\n\n// Parse a ternary conditional (`?:`) operator.\n\npp$3.parseMaybeConditional = function(noIn, refDestructuringErrors) {\n  var startPos = this.start, startLoc = this.startLoc;\n  var expr = this.parseExprOps(noIn, refDestructuringErrors);\n  if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }\n  if (this.eat(types.question)) {\n    var node = this.startNodeAt(startPos, startLoc);\n    node.test = expr;\n    node.consequent = this.parseMaybeAssign();\n    this.expect(types.colon);\n    node.alternate = this.parseMaybeAssign(noIn);\n    return this.finishNode(node, \"ConditionalExpression\")\n  }\n  return expr\n};\n\n// Start the precedence parser.\n\npp$3.parseExprOps = function(noIn, refDestructuringErrors) {\n  var startPos = this.start, startLoc = this.startLoc;\n  var expr = this.parseMaybeUnary(refDestructuringErrors, false);\n  if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }\n  return expr.start === startPos && expr.type === \"ArrowFunctionExpression\" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, noIn)\n};\n\n// Parse binary operators with the operator precedence parsing\n// algorithm. `left` is the left-hand side of the operator.\n// `minPrec` provides context that allows the function to stop and\n// defer further parser to one of its callers when it encounters an\n// operator that has a lower precedence than the set it is parsing.\n\npp$3.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, noIn) {\n  var prec = this.type.binop;\n  if (prec != null && (!noIn || this.type !== types._in)) {\n    if (prec > minPrec) {\n      var logical = this.type === types.logicalOR || this.type === types.logicalAND;\n      var coalesce = this.type === types.coalesce;\n      if (coalesce) {\n        // Handle the precedence of `tt.coalesce` as equal to the range of logical expressions.\n        // In other words, `node.right` shouldn't contain logical expressions in order to check the mixed error.\n        prec = types.logicalAND.binop;\n      }\n      var op = this.value;\n      this.next();\n      var startPos = this.start, startLoc = this.startLoc;\n      var right = this.parseExprOp(this.parseMaybeUnary(null, false), startPos, startLoc, prec, noIn);\n      var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical || coalesce);\n      if ((logical && this.type === types.coalesce) || (coalesce && (this.type === types.logicalOR || this.type === types.logicalAND))) {\n        this.raiseRecoverable(this.start, \"Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses\");\n      }\n      return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn)\n    }\n  }\n  return left\n};\n\npp$3.buildBinary = function(startPos, startLoc, left, right, op, logical) {\n  var node = this.startNodeAt(startPos, startLoc);\n  node.left = left;\n  node.operator = op;\n  node.right = right;\n  return this.finishNode(node, logical ? \"LogicalExpression\" : \"BinaryExpression\")\n};\n\n// Parse unary operators, both prefix and postfix.\n\npp$3.parseMaybeUnary = function(refDestructuringErrors, sawUnary) {\n  var startPos = this.start, startLoc = this.startLoc, expr;\n  if (this.isContextual(\"await\") && (this.inAsync || (!this.inFunction && this.options.allowAwaitOutsideFunction))) {\n    expr = this.parseAwait();\n    sawUnary = true;\n  } else if (this.type.prefix) {\n    var node = this.startNode(), update = this.type === types.incDec;\n    node.operator = this.value;\n    node.prefix = true;\n    this.next();\n    node.argument = this.parseMaybeUnary(null, true);\n    this.checkExpressionErrors(refDestructuringErrors, true);\n    if (update) { this.checkLVal(node.argument); }\n    else if (this.strict && node.operator === \"delete\" &&\n             node.argument.type === \"Identifier\")\n      { this.raiseRecoverable(node.start, \"Deleting local variable in strict mode\"); }\n    else { sawUnary = true; }\n    expr = this.finishNode(node, update ? \"UpdateExpression\" : \"UnaryExpression\");\n  } else {\n    expr = this.parseExprSubscripts(refDestructuringErrors);\n    if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }\n    while (this.type.postfix && !this.canInsertSemicolon()) {\n      var node$1 = this.startNodeAt(startPos, startLoc);\n      node$1.operator = this.value;\n      node$1.prefix = false;\n      node$1.argument = expr;\n      this.checkLVal(expr);\n      this.next();\n      expr = this.finishNode(node$1, \"UpdateExpression\");\n    }\n  }\n\n  if (!sawUnary && this.eat(types.starstar))\n    { return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false), \"**\", false) }\n  else\n    { return expr }\n};\n\n// Parse call, dot, and `[]`-subscript expressions.\n\npp$3.parseExprSubscripts = function(refDestructuringErrors) {\n  var startPos = this.start, startLoc = this.startLoc;\n  var expr = this.parseExprAtom(refDestructuringErrors);\n  if (expr.type === \"ArrowFunctionExpression\" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== \")\")\n    { return expr }\n  var result = this.parseSubscripts(expr, startPos, startLoc);\n  if (refDestructuringErrors && result.type === \"MemberExpression\") {\n    if (refDestructuringErrors.parenthesizedAssign >= result.start) { refDestructuringErrors.parenthesizedAssign = -1; }\n    if (refDestructuringErrors.parenthesizedBind >= result.start) { refDestructuringErrors.parenthesizedBind = -1; }\n  }\n  return result\n};\n\npp$3.parseSubscripts = function(base, startPos, startLoc, noCalls) {\n  var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === \"Identifier\" && base.name === \"async\" &&\n      this.lastTokEnd === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 &&\n      this.potentialArrowAt === base.start;\n  var optionalChained = false;\n\n  while (true) {\n    var element = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained);\n\n    if (element.optional) { optionalChained = true; }\n    if (element === base || element.type === \"ArrowFunctionExpression\") {\n      if (optionalChained) {\n        var chainNode = this.startNodeAt(startPos, startLoc);\n        chainNode.expression = element;\n        element = this.finishNode(chainNode, \"ChainExpression\");\n      }\n      return element\n    }\n\n    base = element;\n  }\n};\n\npp$3.parseSubscript = function(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained) {\n  var optionalSupported = this.options.ecmaVersion >= 11;\n  var optional = optionalSupported && this.eat(types.questionDot);\n  if (noCalls && optional) { this.raise(this.lastTokStart, \"Optional chaining cannot appear in the callee of new expressions\"); }\n\n  var computed = this.eat(types.bracketL);\n  if (computed || (optional && this.type !== types.parenL && this.type !== types.backQuote) || this.eat(types.dot)) {\n    var node = this.startNodeAt(startPos, startLoc);\n    node.object = base;\n    node.property = computed ? this.parseExpression() : this.parseIdent(this.options.allowReserved !== \"never\");\n    node.computed = !!computed;\n    if (computed) { this.expect(types.bracketR); }\n    if (optionalSupported) {\n      node.optional = optional;\n    }\n    base = this.finishNode(node, \"MemberExpression\");\n  } else if (!noCalls && this.eat(types.parenL)) {\n    var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\n    this.yieldPos = 0;\n    this.awaitPos = 0;\n    this.awaitIdentPos = 0;\n    var exprList = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);\n    if (maybeAsyncArrow && !optional && !this.canInsertSemicolon() && this.eat(types.arrow)) {\n      this.checkPatternErrors(refDestructuringErrors, false);\n      this.checkYieldAwaitInDefaultParams();\n      if (this.awaitIdentPos > 0)\n        { this.raise(this.awaitIdentPos, \"Cannot use 'await' as identifier inside an async function\"); }\n      this.yieldPos = oldYieldPos;\n      this.awaitPos = oldAwaitPos;\n      this.awaitIdentPos = oldAwaitIdentPos;\n      return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true)\n    }\n    this.checkExpressionErrors(refDestructuringErrors, true);\n    this.yieldPos = oldYieldPos || this.yieldPos;\n    this.awaitPos = oldAwaitPos || this.awaitPos;\n    this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;\n    var node$1 = this.startNodeAt(startPos, startLoc);\n    node$1.callee = base;\n    node$1.arguments = exprList;\n    if (optionalSupported) {\n      node$1.optional = optional;\n    }\n    base = this.finishNode(node$1, \"CallExpression\");\n  } else if (this.type === types.backQuote) {\n    if (optional || optionalChained) {\n      this.raise(this.start, \"Optional chaining cannot appear in the tag of tagged template expressions\");\n    }\n    var node$2 = this.startNodeAt(startPos, startLoc);\n    node$2.tag = base;\n    node$2.quasi = this.parseTemplate({isTagged: true});\n    base = this.finishNode(node$2, \"TaggedTemplateExpression\");\n  }\n  return base\n};\n\n// Parse an atomic expression \u2014 either a single token that is an\n// expression, an expression started by a keyword like `function` or\n// `new`, or an expression wrapped in punctuation like `()`, `[]`,\n// or `{}`.\n\npp$3.parseExprAtom = function(refDestructuringErrors) {\n  // If a division operator appears in an expression position, the\n  // tokenizer got confused, and we force it to read a regexp instead.\n  if (this.type === types.slash) { this.readRegexp(); }\n\n  var node, canBeArrow = this.potentialArrowAt === this.start;\n  switch (this.type) {\n  case types._super:\n    if (!this.allowSuper)\n      { this.raise(this.start, \"'super' keyword outside a method\"); }\n    node = this.startNode();\n    this.next();\n    if (this.type === types.parenL && !this.allowDirectSuper)\n      { this.raise(node.start, \"super() call outside constructor of a subclass\"); }\n    // The `super` keyword can appear at below:\n    // SuperProperty:\n    //     super [ Expression ]\n    //     super . IdentifierName\n    // SuperCall:\n    //     super ( Arguments )\n    if (this.type !== types.dot && this.type !== types.bracketL && this.type !== types.parenL)\n      { this.unexpected(); }\n    return this.finishNode(node, \"Super\")\n\n  case types._this:\n    node = this.startNode();\n    this.next();\n    return this.finishNode(node, \"ThisExpression\")\n\n  case types.name:\n    var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;\n    var id = this.parseIdent(false);\n    if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === \"async\" && !this.canInsertSemicolon() && this.eat(types._function))\n      { return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true) }\n    if (canBeArrow && !this.canInsertSemicolon()) {\n      if (this.eat(types.arrow))\n        { return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false) }\n      if (this.options.ecmaVersion >= 8 && id.name === \"async\" && this.type === types.name && !containsEsc) {\n        id = this.parseIdent(false);\n        if (this.canInsertSemicolon() || !this.eat(types.arrow))\n          { this.unexpected(); }\n        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true)\n      }\n    }\n    return id\n\n  case types.regexp:\n    var value = this.value;\n    node = this.parseLiteral(value.value);\n    node.regex = {pattern: value.pattern, flags: value.flags};\n    return node\n\n  case types.num: case types.string:\n    return this.parseLiteral(this.value)\n\n  case types._null: case types._true: case types._false:\n    node = this.startNode();\n    node.value = this.type === types._null ? null : this.type === types._true;\n    node.raw = this.type.keyword;\n    this.next();\n    return this.finishNode(node, \"Literal\")\n\n  case types.parenL:\n    var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow);\n    if (refDestructuringErrors) {\n      if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr))\n        { refDestructuringErrors.parenthesizedAssign = start; }\n      if (refDestructuringErrors.parenthesizedBind < 0)\n        { refDestructuringErrors.parenthesizedBind = start; }\n    }\n    return expr\n\n  case types.bracketL:\n    node = this.startNode();\n    this.next();\n    node.elements = this.parseExprList(types.bracketR, true, true, refDestructuringErrors);\n    return this.finishNode(node, \"ArrayExpression\")\n\n  case types.braceL:\n    return this.parseObj(false, refDestructuringErrors)\n\n  case types._function:\n    node = this.startNode();\n    this.next();\n    return this.parseFunction(node, 0)\n\n  case types._class:\n    return this.parseClass(this.startNode(), false)\n\n  case types._new:\n    return this.parseNew()\n\n  case types.backQuote:\n    return this.parseTemplate()\n\n  case types._import:\n    if (this.options.ecmaVersion >= 11) {\n      return this.parseExprImport()\n    } else {\n      return this.unexpected()\n    }\n\n  default:\n    this.unexpected();\n  }\n};\n\npp$3.parseExprImport = function() {\n  var node = this.startNode();\n\n  // Consume `import` as an identifier for `import.meta`.\n  // Because `this.parseIdent(true)` doesn't check escape sequences, it needs the check of `this.containsEsc`.\n  if (this.containsEsc) { this.raiseRecoverable(this.start, \"Escape sequence in keyword import\"); }\n  var meta = this.parseIdent(true);\n\n  switch (this.type) {\n  case types.parenL:\n    return this.parseDynamicImport(node)\n  case types.dot:\n    node.meta = meta;\n    return this.parseImportMeta(node)\n  default:\n    this.unexpected();\n  }\n};\n\npp$3.parseDynamicImport = function(node) {\n  this.next(); // skip `(`\n\n  // Parse node.source.\n  node.source = this.parseMaybeAssign();\n\n  // Verify ending.\n  if (!this.eat(types.parenR)) {\n    var errorPos = this.start;\n    if (this.eat(types.comma) && this.eat(types.parenR)) {\n      this.raiseRecoverable(errorPos, \"Trailing comma is not allowed in import()\");\n    } else {\n      this.unexpected(errorPos);\n    }\n  }\n\n  return this.finishNode(node, \"ImportExpression\")\n};\n\npp$3.parseImportMeta = function(node) {\n  this.next(); // skip `.`\n\n  var containsEsc = this.containsEsc;\n  node.property = this.parseIdent(true);\n\n  if (node.property.name !== \"meta\")\n    { this.raiseRecoverable(node.property.start, \"The only valid meta property for import is 'import.meta'\"); }\n  if (containsEsc)\n    { this.raiseRecoverable(node.start, \"'import.meta' must not contain escaped characters\"); }\n  if (this.options.sourceType !== \"module\")\n    { this.raiseRecoverable(node.start, \"Cannot use 'import.meta' outside a module\"); }\n\n  return this.finishNode(node, \"MetaProperty\")\n};\n\npp$3.parseLiteral = function(value) {\n  var node = this.startNode();\n  node.value = value;\n  node.raw = this.input.slice(this.start, this.end);\n  if (node.raw.charCodeAt(node.raw.length - 1) === 110) { node.bigint = node.raw.slice(0, -1); }\n  this.next();\n  return this.finishNode(node, \"Literal\")\n};\n\npp$3.parseParenExpression = function() {\n  this.expect(types.parenL);\n  var val = this.parseExpression();\n  this.expect(types.parenR);\n  return val\n};\n\npp$3.parseParenAndDistinguishExpression = function(canBeArrow) {\n  var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;\n  if (this.options.ecmaVersion >= 6) {\n    this.next();\n\n    var innerStartPos = this.start, innerStartLoc = this.startLoc;\n    var exprList = [], first = true, lastIsComma = false;\n    var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;\n    this.yieldPos = 0;\n    this.awaitPos = 0;\n    // Do not save awaitIdentPos to allow checking awaits nested in parameters\n    while (this.type !== types.parenR) {\n      first ? first = false : this.expect(types.comma);\n      if (allowTrailingComma && this.afterTrailingComma(types.parenR, true)) {\n        lastIsComma = true;\n        break\n      } else if (this.type === types.ellipsis) {\n        spreadStart = this.start;\n        exprList.push(this.parseParenItem(this.parseRestBinding()));\n        if (this.type === types.comma) { this.raise(this.start, \"Comma is not permitted after the rest element\"); }\n        break\n      } else {\n        exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));\n      }\n    }\n    var innerEndPos = this.start, innerEndLoc = this.startLoc;\n    this.expect(types.parenR);\n\n    if (canBeArrow && !this.canInsertSemicolon() && this.eat(types.arrow)) {\n      this.checkPatternErrors(refDestructuringErrors, false);\n      this.checkYieldAwaitInDefaultParams();\n      this.yieldPos = oldYieldPos;\n      this.awaitPos = oldAwaitPos;\n      return this.parseParenArrowList(startPos, startLoc, exprList)\n    }\n\n    if (!exprList.length || lastIsComma) { this.unexpected(this.lastTokStart); }\n    if (spreadStart) { this.unexpected(spreadStart); }\n    this.checkExpressionErrors(refDestructuringErrors, true);\n    this.yieldPos = oldYieldPos || this.yieldPos;\n    this.awaitPos = oldAwaitPos || this.awaitPos;\n\n    if (exprList.length > 1) {\n      val = this.startNodeAt(innerStartPos, innerStartLoc);\n      val.expressions = exprList;\n      this.finishNodeAt(val, \"SequenceExpression\", innerEndPos, innerEndLoc);\n    } else {\n      val = exprList[0];\n    }\n  } else {\n    val = this.parseParenExpression();\n  }\n\n  if (this.options.preserveParens) {\n    var par = this.startNodeAt(startPos, startLoc);\n    par.expression = val;\n    return this.finishNode(par, \"ParenthesizedExpression\")\n  } else {\n    return val\n  }\n};\n\npp$3.parseParenItem = function(item) {\n  return item\n};\n\npp$3.parseParenArrowList = function(startPos, startLoc, exprList) {\n  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList)\n};\n\n// New's precedence is slightly tricky. It must allow its argument to\n// be a `[]` or dot subscript expression, but not a call \u2014 at least,\n// not without wrapping it in parentheses. Thus, it uses the noCalls\n// argument to parseSubscripts to prevent it from consuming the\n// argument list.\n\nvar empty$1 = [];\n\npp$3.parseNew = function() {\n  if (this.containsEsc) { this.raiseRecoverable(this.start, \"Escape sequence in keyword new\"); }\n  var node = this.startNode();\n  var meta = this.parseIdent(true);\n  if (this.options.ecmaVersion >= 6 && this.eat(types.dot)) {\n    node.meta = meta;\n    var containsEsc = this.containsEsc;\n    node.property = this.parseIdent(true);\n    if (node.property.name !== \"target\")\n      { this.raiseRecoverable(node.property.start, \"The only valid meta property for new is 'new.target'\"); }\n    if (containsEsc)\n      { this.raiseRecoverable(node.start, \"'new.target' must not contain escaped characters\"); }\n    if (!this.inNonArrowFunction())\n      { this.raiseRecoverable(node.start, \"'new.target' can only be used in functions\"); }\n    return this.finishNode(node, \"MetaProperty\")\n  }\n  var startPos = this.start, startLoc = this.startLoc, isImport = this.type === types._import;\n  node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);\n  if (isImport && node.callee.type === \"ImportExpression\") {\n    this.raise(startPos, \"Cannot use new with import()\");\n  }\n  if (this.eat(types.parenL)) { node.arguments = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8, false); }\n  else { node.arguments = empty$1; }\n  return this.finishNode(node, \"NewExpression\")\n};\n\n// Parse template expression.\n\npp$3.parseTemplateElement = function(ref) {\n  var isTagged = ref.isTagged;\n\n  var elem = this.startNode();\n  if (this.type === types.invalidTemplate) {\n    if (!isTagged) {\n      this.raiseRecoverable(this.start, \"Bad escape sequence in untagged template literal\");\n    }\n    elem.value = {\n      raw: this.value,\n      cooked: null\n    };\n  } else {\n    elem.value = {\n      raw: this.input.slice(this.start, this.end).replace(/\\r\\n?/g, \"\\n\"),\n      cooked: this.value\n    };\n  }\n  this.next();\n  elem.tail = this.type === types.backQuote;\n  return this.finishNode(elem, \"TemplateElement\")\n};\n\npp$3.parseTemplate = function(ref) {\n  if ( ref === void 0 ) ref = {};\n  var isTagged = ref.isTagged; if ( isTagged === void 0 ) isTagged = false;\n\n  var node = this.startNode();\n  this.next();\n  node.expressions = [];\n  var curElt = this.parseTemplateElement({isTagged: isTagged});\n  node.quasis = [curElt];\n  while (!curElt.tail) {\n    if (this.type === types.eof) { this.raise(this.pos, \"Unterminated template literal\"); }\n    this.expect(types.dollarBraceL);\n    node.expressions.push(this.parseExpression());\n    this.expect(types.braceR);\n    node.quasis.push(curElt = this.parseTemplateElement({isTagged: isTagged}));\n  }\n  this.next();\n  return this.finishNode(node, \"TemplateLiteral\")\n};\n\npp$3.isAsyncProp = function(prop) {\n  return !prop.computed && prop.key.type === \"Identifier\" && prop.key.name === \"async\" &&\n    (this.type === types.name || this.type === types.num || this.type === types.string || this.type === types.bracketL || this.type.keyword || (this.options.ecmaVersion >= 9 && this.type === types.star)) &&\n    !lineBreak.test(this.input.slice(this.lastTokEnd, this.start))\n};\n\n// Parse an object literal or binding pattern.\n\npp$3.parseObj = function(isPattern, refDestructuringErrors) {\n  var node = this.startNode(), first = true, propHash = {};\n  node.properties = [];\n  this.next();\n  while (!this.eat(types.braceR)) {\n    if (!first) {\n      this.expect(types.comma);\n      if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types.braceR)) { break }\n    } else { first = false; }\n\n    var prop = this.parseProperty(isPattern, refDestructuringErrors);\n    if (!isPattern) { this.checkPropClash(prop, propHash, refDestructuringErrors); }\n    node.properties.push(prop);\n  }\n  return this.finishNode(node, isPattern ? \"ObjectPattern\" : \"ObjectExpression\")\n};\n\npp$3.parseProperty = function(isPattern, refDestructuringErrors) {\n  var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;\n  if (this.options.ecmaVersion >= 9 && this.eat(types.ellipsis)) {\n    if (isPattern) {\n      prop.argument = this.parseIdent(false);\n      if (this.type === types.comma) {\n        this.raise(this.start, \"Comma is not permitted after the rest element\");\n      }\n      return this.finishNode(prop, \"RestElement\")\n    }\n    // To disallow parenthesized identifier via `this.toAssignable()`.\n    if (this.type === types.parenL && refDestructuringErrors) {\n      if (refDestructuringErrors.parenthesizedAssign < 0) {\n        refDestructuringErrors.parenthesizedAssign = this.start;\n      }\n      if (refDestructuringErrors.parenthesizedBind < 0) {\n        refDestructuringErrors.parenthesizedBind = this.start;\n      }\n    }\n    // Parse argument.\n    prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);\n    // To disallow trailing comma via `this.toAssignable()`.\n    if (this.type === types.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {\n      refDestructuringErrors.trailingComma = this.start;\n    }\n    // Finish\n    return this.finishNode(prop, \"SpreadElement\")\n  }\n  if (this.options.ecmaVersion >= 6) {\n    prop.method = false;\n    prop.shorthand = false;\n    if (isPattern || refDestructuringErrors) {\n      startPos = this.start;\n      startLoc = this.startLoc;\n    }\n    if (!isPattern)\n      { isGenerator = this.eat(types.star); }\n  }\n  var containsEsc = this.containsEsc;\n  this.parsePropertyName(prop);\n  if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {\n    isAsync = true;\n    isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);\n    this.parsePropertyName(prop, refDestructuringErrors);\n  } else {\n    isAsync = false;\n  }\n  this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);\n  return this.finishNode(prop, \"Property\")\n};\n\npp$3.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {\n  if ((isGenerator || isAsync) && this.type === types.colon)\n    { this.unexpected(); }\n\n  if (this.eat(types.colon)) {\n    prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);\n    prop.kind = \"init\";\n  } else if (this.options.ecmaVersion >= 6 && this.type === types.parenL) {\n    if (isPattern) { this.unexpected(); }\n    prop.kind = \"init\";\n    prop.method = true;\n    prop.value = this.parseMethod(isGenerator, isAsync);\n  } else if (!isPattern && !containsEsc &&\n             this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === \"Identifier\" &&\n             (prop.key.name === \"get\" || prop.key.name === \"set\") &&\n             (this.type !== types.comma && this.type !== types.braceR && this.type !== types.eq)) {\n    if (isGenerator || isAsync) { this.unexpected(); }\n    prop.kind = prop.key.name;\n    this.parsePropertyName(prop);\n    prop.value = this.parseMethod(false);\n    var paramCount = prop.kind === \"get\" ? 0 : 1;\n    if (prop.value.params.length !== paramCount) {\n      var start = prop.value.start;\n      if (prop.kind === \"get\")\n        { this.raiseRecoverable(start, \"getter should have no params\"); }\n      else\n        { this.raiseRecoverable(start, \"setter should have exactly one param\"); }\n    } else {\n      if (prop.kind === \"set\" && prop.value.params[0].type === \"RestElement\")\n        { this.raiseRecoverable(prop.value.params[0].start, \"Setter cannot use rest params\"); }\n    }\n  } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === \"Identifier\") {\n    if (isGenerator || isAsync) { this.unexpected(); }\n    this.checkUnreserved(prop.key);\n    if (prop.key.name === \"await\" && !this.awaitIdentPos)\n      { this.awaitIdentPos = startPos; }\n    prop.kind = \"init\";\n    if (isPattern) {\n      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);\n    } else if (this.type === types.eq && refDestructuringErrors) {\n      if (refDestructuringErrors.shorthandAssign < 0)\n        { refDestructuringErrors.shorthandAssign = this.start; }\n      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);\n    } else {\n      prop.value = prop.key;\n    }\n    prop.shorthand = true;\n  } else { this.unexpected(); }\n};\n\npp$3.parsePropertyName = function(prop) {\n  if (this.options.ecmaVersion >= 6) {\n    if (this.eat(types.bracketL)) {\n      prop.computed = true;\n      prop.key = this.parseMaybeAssign();\n      this.expect(types.bracketR);\n      return prop.key\n    } else {\n      prop.computed = false;\n    }\n  }\n  return prop.key = this.type === types.num || this.type === types.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== \"never\")\n};\n\n// Initialize empty function node.\n\npp$3.initFunction = function(node) {\n  node.id = null;\n  if (this.options.ecmaVersion >= 6) { node.generator = node.expression = false; }\n  if (this.options.ecmaVersion >= 8) { node.async = false; }\n};\n\n// Parse object or class method.\n\npp$3.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {\n  var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\n\n  this.initFunction(node);\n  if (this.options.ecmaVersion >= 6)\n    { node.generator = isGenerator; }\n  if (this.options.ecmaVersion >= 8)\n    { node.async = !!isAsync; }\n\n  this.yieldPos = 0;\n  this.awaitPos = 0;\n  this.awaitIdentPos = 0;\n  this.enterScope(functionFlags(isAsync, node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));\n\n  this.expect(types.parenL);\n  node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);\n  this.checkYieldAwaitInDefaultParams();\n  this.parseFunctionBody(node, false, true);\n\n  this.yieldPos = oldYieldPos;\n  this.awaitPos = oldAwaitPos;\n  this.awaitIdentPos = oldAwaitIdentPos;\n  return this.finishNode(node, \"FunctionExpression\")\n};\n\n// Parse arrow function expression with given parameters.\n\npp$3.parseArrowExpression = function(node, params, isAsync) {\n  var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\n\n  this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);\n  this.initFunction(node);\n  if (this.options.ecmaVersion >= 8) { node.async = !!isAsync; }\n\n  this.yieldPos = 0;\n  this.awaitPos = 0;\n  this.awaitIdentPos = 0;\n\n  node.params = this.toAssignableList(params, true);\n  this.parseFunctionBody(node, true, false);\n\n  this.yieldPos = oldYieldPos;\n  this.awaitPos = oldAwaitPos;\n  this.awaitIdentPos = oldAwaitIdentPos;\n  return this.finishNode(node, \"ArrowFunctionExpression\")\n};\n\n// Parse function body and check parameters.\n\npp$3.parseFunctionBody = function(node, isArrowFunction, isMethod) {\n  var isExpression = isArrowFunction && this.type !== types.braceL;\n  var oldStrict = this.strict, useStrict = false;\n\n  if (isExpression) {\n    node.body = this.parseMaybeAssign();\n    node.expression = true;\n    this.checkParams(node, false);\n  } else {\n    var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);\n    if (!oldStrict || nonSimple) {\n      useStrict = this.strictDirective(this.end);\n      // If this is a strict mode function, verify that argument names\n      // are not repeated, and it does not try to bind the words `eval`\n      // or `arguments`.\n      if (useStrict && nonSimple)\n        { this.raiseRecoverable(node.start, \"Illegal 'use strict' directive in function with non-simple parameter list\"); }\n    }\n    // Start a new scope with regard to labels and the `inFunction`\n    // flag (restore them to their old value afterwards).\n    var oldLabels = this.labels;\n    this.labels = [];\n    if (useStrict) { this.strict = true; }\n\n    // Add the params to varDeclaredNames to ensure that an error is thrown\n    // if a let/const declaration in the function clashes with one of the params.\n    this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node.params));\n    // Ensure the function name isn't a forbidden identifier in strict mode, e.g. 'eval'\n    if (this.strict && node.id) { this.checkLVal(node.id, BIND_OUTSIDE); }\n    node.body = this.parseBlock(false, undefined, useStrict && !oldStrict);\n    node.expression = false;\n    this.adaptDirectivePrologue(node.body.body);\n    this.labels = oldLabels;\n  }\n  this.exitScope();\n};\n\npp$3.isSimpleParamList = function(params) {\n  for (var i = 0, list = params; i < list.length; i += 1)\n    {\n    var param = list[i];\n\n    if (param.type !== \"Identifier\") { return false\n  } }\n  return true\n};\n\n// Checks function params for various disallowed patterns such as using \"eval\"\n// or \"arguments\" and duplicate parameters.\n\npp$3.checkParams = function(node, allowDuplicates) {\n  var nameHash = {};\n  for (var i = 0, list = node.params; i < list.length; i += 1)\n    {\n    var param = list[i];\n\n    this.checkLVal(param, BIND_VAR, allowDuplicates ? null : nameHash);\n  }\n};\n\n// Parses a comma-separated list of expressions, and returns them as\n// an array. `close` is the token type that ends the list, and\n// `allowEmpty` can be turned on to allow subsequent commas with\n// nothing in between them to be parsed as `null` (which is needed\n// for array literals).\n\npp$3.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {\n  var elts = [], first = true;\n  while (!this.eat(close)) {\n    if (!first) {\n      this.expect(types.comma);\n      if (allowTrailingComma && this.afterTrailingComma(close)) { break }\n    } else { first = false; }\n\n    var elt = (void 0);\n    if (allowEmpty && this.type === types.comma)\n      { elt = null; }\n    else if (this.type === types.ellipsis) {\n      elt = this.parseSpread(refDestructuringErrors);\n      if (refDestructuringErrors && this.type === types.comma && refDestructuringErrors.trailingComma < 0)\n        { refDestructuringErrors.trailingComma = this.start; }\n    } else {\n      elt = this.parseMaybeAssign(false, refDestructuringErrors);\n    }\n    elts.push(elt);\n  }\n  return elts\n};\n\npp$3.checkUnreserved = function(ref) {\n  var start = ref.start;\n  var end = ref.end;\n  var name = ref.name;\n\n  if (this.inGenerator && name === \"yield\")\n    { this.raiseRecoverable(start, \"Cannot use 'yield' as identifier inside a generator\"); }\n  if (this.inAsync && name === \"await\")\n    { this.raiseRecoverable(start, \"Cannot use 'await' as identifier inside an async function\"); }\n  if (this.keywords.test(name))\n    { this.raise(start, (\"Unexpected keyword '\" + name + \"'\")); }\n  if (this.options.ecmaVersion < 6 &&\n    this.input.slice(start, end).indexOf(\"\\\\\") !== -1) { return }\n  var re = this.strict ? this.reservedWordsStrict : this.reservedWords;\n  if (re.test(name)) {\n    if (!this.inAsync && name === \"await\")\n      { this.raiseRecoverable(start, \"Cannot use keyword 'await' outside an async function\"); }\n    this.raiseRecoverable(start, (\"The keyword '\" + name + \"' is reserved\"));\n  }\n};\n\n// Parse the next token as an identifier. If `liberal` is true (used\n// when parsing properties), it will also convert keywords into\n// identifiers.\n\npp$3.parseIdent = function(liberal, isBinding) {\n  var node = this.startNode();\n  if (this.type === types.name) {\n    node.name = this.value;\n  } else if (this.type.keyword) {\n    node.name = this.type.keyword;\n\n    // To fix https://github.com/acornjs/acorn/issues/575\n    // `class` and `function` keywords push new context into this.context.\n    // But there is no chance to pop the context if the keyword is consumed as an identifier such as a property name.\n    // If the previous token is a dot, this does not apply because the context-managing code already ignored the keyword\n    if ((node.name === \"class\" || node.name === \"function\") &&\n        (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {\n      this.context.pop();\n    }\n  } else {\n    this.unexpected();\n  }\n  this.next(!!liberal);\n  this.finishNode(node, \"Identifier\");\n  if (!liberal) {\n    this.checkUnreserved(node);\n    if (node.name === \"await\" && !this.awaitIdentPos)\n      { this.awaitIdentPos = node.start; }\n  }\n  return node\n};\n\n// Parses yield expression inside generator.\n\npp$3.parseYield = function(noIn) {\n  if (!this.yieldPos) { this.yieldPos = this.start; }\n\n  var node = this.startNode();\n  this.next();\n  if (this.type === types.semi || this.canInsertSemicolon() || (this.type !== types.star && !this.type.startsExpr)) {\n    node.delegate = false;\n    node.argument = null;\n  } else {\n    node.delegate = this.eat(types.star);\n    node.argument = this.parseMaybeAssign(noIn);\n  }\n  return this.finishNode(node, \"YieldExpression\")\n};\n\npp$3.parseAwait = function() {\n  if (!this.awaitPos) { this.awaitPos = this.start; }\n\n  var node = this.startNode();\n  this.next();\n  node.argument = this.parseMaybeUnary(null, false);\n  return this.finishNode(node, \"AwaitExpression\")\n};\n\nvar pp$4 = Parser.prototype;\n\n// This function is used to raise exceptions on parse errors. It\n// takes an offset integer (into the current `input`) to indicate\n// the location of the error, attaches the position to the end\n// of the error message, and then raises a `SyntaxError` with that\n// message.\n\npp$4.raise = function(pos, message) {\n  var loc = getLineInfo(this.input, pos);\n  message += \" (\" + loc.line + \":\" + loc.column + \")\";\n  var err = new SyntaxError(message);\n  err.pos = pos; err.loc = loc; err.raisedAt = this.pos;\n  throw err\n};\n\npp$4.raiseRecoverable = pp$4.raise;\n\npp$4.curPosition = function() {\n  if (this.options.locations) {\n    return new Position(this.curLine, this.pos - this.lineStart)\n  }\n};\n\nvar pp$5 = Parser.prototype;\n\nvar Scope = function Scope(flags) {\n  this.flags = flags;\n  // A list of var-declared names in the current lexical scope\n  this.var = [];\n  // A list of lexically-declared names in the current lexical scope\n  this.lexical = [];\n  // A list of lexically-declared FunctionDeclaration names in the current lexical scope\n  this.functions = [];\n};\n\n// The functions in this module keep track of declared variables in the current scope in order to detect duplicate variable names.\n\npp$5.enterScope = function(flags) {\n  this.scopeStack.push(new Scope(flags));\n};\n\npp$5.exitScope = function() {\n  this.scopeStack.pop();\n};\n\n// The spec says:\n// > At the top level of a function, or script, function declarations are\n// > treated like var declarations rather than like lexical declarations.\npp$5.treatFunctionsAsVarInScope = function(scope) {\n  return (scope.flags & SCOPE_FUNCTION) || !this.inModule && (scope.flags & SCOPE_TOP)\n};\n\npp$5.declareName = function(name, bindingType, pos) {\n  var redeclared = false;\n  if (bindingType === BIND_LEXICAL) {\n    var scope = this.currentScope();\n    redeclared = scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;\n    scope.lexical.push(name);\n    if (this.inModule && (scope.flags & SCOPE_TOP))\n      { delete this.undefinedExports[name]; }\n  } else if (bindingType === BIND_SIMPLE_CATCH) {\n    var scope$1 = this.currentScope();\n    scope$1.lexical.push(name);\n  } else if (bindingType === BIND_FUNCTION) {\n    var scope$2 = this.currentScope();\n    if (this.treatFunctionsAsVar)\n      { redeclared = scope$2.lexical.indexOf(name) > -1; }\n    else\n      { redeclared = scope$2.lexical.indexOf(name) > -1 || scope$2.var.indexOf(name) > -1; }\n    scope$2.functions.push(name);\n  } else {\n    for (var i = this.scopeStack.length - 1; i >= 0; --i) {\n      var scope$3 = this.scopeStack[i];\n      if (scope$3.lexical.indexOf(name) > -1 && !((scope$3.flags & SCOPE_SIMPLE_CATCH) && scope$3.lexical[0] === name) ||\n          !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {\n        redeclared = true;\n        break\n      }\n      scope$3.var.push(name);\n      if (this.inModule && (scope$3.flags & SCOPE_TOP))\n        { delete this.undefinedExports[name]; }\n      if (scope$3.flags & SCOPE_VAR) { break }\n    }\n  }\n  if (redeclared) { this.raiseRecoverable(pos, (\"Identifier '\" + name + \"' has already been declared\")); }\n};\n\npp$5.checkLocalExport = function(id) {\n  // scope.functions must be empty as Module code is always strict.\n  if (this.scopeStack[0].lexical.indexOf(id.name) === -1 &&\n      this.scopeStack[0].var.indexOf(id.name) === -1) {\n    this.undefinedExports[id.name] = id;\n  }\n};\n\npp$5.currentScope = function() {\n  return this.scopeStack[this.scopeStack.length - 1]\n};\n\npp$5.currentVarScope = function() {\n  for (var i = this.scopeStack.length - 1;; i--) {\n    var scope = this.scopeStack[i];\n    if (scope.flags & SCOPE_VAR) { return scope }\n  }\n};\n\n// Could be useful for `this`, `new.target`, `super()`, `super.property`, and `super[property]`.\npp$5.currentThisScope = function() {\n  for (var i = this.scopeStack.length - 1;; i--) {\n    var scope = this.scopeStack[i];\n    if (scope.flags & SCOPE_VAR && !(scope.flags & SCOPE_ARROW)) { return scope }\n  }\n};\n\nvar Node = function Node(parser, pos, loc) {\n  this.type = \"\";\n  this.start = pos;\n  this.end = 0;\n  if (parser.options.locations)\n    { this.loc = new SourceLocation(parser, loc); }\n  if (parser.options.directSourceFile)\n    { this.sourceFile = parser.options.directSourceFile; }\n  if (parser.options.ranges)\n    { this.range = [pos, 0]; }\n};\n\n// Start an AST node, attaching a start offset.\n\nvar pp$6 = Parser.prototype;\n\npp$6.startNode = function() {\n  return new Node(this, this.start, this.startLoc)\n};\n\npp$6.startNodeAt = function(pos, loc) {\n  return new Node(this, pos, loc)\n};\n\n// Finish an AST node, adding `type` and `end` properties.\n\nfunction finishNodeAt(node, type, pos, loc) {\n  node.type = type;\n  node.end = pos;\n  if (this.options.locations)\n    { node.loc.end = loc; }\n  if (this.options.ranges)\n    { node.range[1] = pos; }\n  return node\n}\n\npp$6.finishNode = function(node, type) {\n  return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc)\n};\n\n// Finish node at given position\n\npp$6.finishNodeAt = function(node, type, pos, loc) {\n  return finishNodeAt.call(this, node, type, pos, loc)\n};\n\n// The algorithm used to determine whether a regexp can appear at a\n\nvar TokContext = function TokContext(token, isExpr, preserveSpace, override, generator) {\n  this.token = token;\n  this.isExpr = !!isExpr;\n  this.preserveSpace = !!preserveSpace;\n  this.override = override;\n  this.generator = !!generator;\n};\n\nvar types$1 = {\n  b_stat: new TokContext(\"{\", false),\n  b_expr: new TokContext(\"{\", true),\n  b_tmpl: new TokContext(\"${\", false),\n  p_stat: new TokContext(\"(\", false),\n  p_expr: new TokContext(\"(\", true),\n  q_tmpl: new TokContext(\"`\", true, true, function (p) { return p.tryReadTemplateToken(); }),\n  f_stat: new TokContext(\"function\", false),\n  f_expr: new TokContext(\"function\", true),\n  f_expr_gen: new TokContext(\"function\", true, false, null, true),\n  f_gen: new TokContext(\"function\", false, false, null, true)\n};\n\nvar pp$7 = Parser.prototype;\n\npp$7.initialContext = function() {\n  return [types$1.b_stat]\n};\n\npp$7.braceIsBlock = function(prevType) {\n  var parent = this.curContext();\n  if (parent === types$1.f_expr || parent === types$1.f_stat)\n    { return true }\n  if (prevType === types.colon && (parent === types$1.b_stat || parent === types$1.b_expr))\n    { return !parent.isExpr }\n\n  // The check for `tt.name && exprAllowed` detects whether we are\n  // after a `yield` or `of` construct. See the `updateContext` for\n  // `tt.name`.\n  if (prevType === types._return || prevType === types.name && this.exprAllowed)\n    { return lineBreak.test(this.input.slice(this.lastTokEnd, this.start)) }\n  if (prevType === types._else || prevType === types.semi || prevType === types.eof || prevType === types.parenR || prevType === types.arrow)\n    { return true }\n  if (prevType === types.braceL)\n    { return parent === types$1.b_stat }\n  if (prevType === types._var || prevType === types._const || prevType === types.name)\n    { return false }\n  return !this.exprAllowed\n};\n\npp$7.inGeneratorContext = function() {\n  for (var i = this.context.length - 1; i >= 1; i--) {\n    var context = this.context[i];\n    if (context.token === \"function\")\n      { return context.generator }\n  }\n  return false\n};\n\npp$7.updateContext = function(prevType) {\n  var update, type = this.type;\n  if (type.keyword && prevType === types.dot)\n    { this.exprAllowed = false; }\n  else if (update = type.updateContext)\n    { update.call(this, prevType); }\n  else\n    { this.exprAllowed = type.beforeExpr; }\n};\n\n// Token-specific context update code\n\ntypes.parenR.updateContext = types.braceR.updateContext = function() {\n  if (this.context.length === 1) {\n    this.exprAllowed = true;\n    return\n  }\n  var out = this.context.pop();\n  if (out === types$1.b_stat && this.curContext().token === \"function\") {\n    out = this.context.pop();\n  }\n  this.exprAllowed = !out.isExpr;\n};\n\ntypes.braceL.updateContext = function(prevType) {\n  this.context.push(this.braceIsBlock(prevType) ? types$1.b_stat : types$1.b_expr);\n  this.exprAllowed = true;\n};\n\ntypes.dollarBraceL.updateContext = function() {\n  this.context.push(types$1.b_tmpl);\n  this.exprAllowed = true;\n};\n\ntypes.parenL.updateContext = function(prevType) {\n  var statementParens = prevType === types._if || prevType === types._for || prevType === types._with || prevType === types._while;\n  this.context.push(statementParens ? types$1.p_stat : types$1.p_expr);\n  this.exprAllowed = true;\n};\n\ntypes.incDec.updateContext = function() {\n  // tokExprAllowed stays unchanged\n};\n\ntypes._function.updateContext = types._class.updateContext = function(prevType) {\n  if (prevType.beforeExpr && prevType !== types.semi && prevType !== types._else &&\n      !(prevType === types._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) &&\n      !((prevType === types.colon || prevType === types.braceL) && this.curContext() === types$1.b_stat))\n    { this.context.push(types$1.f_expr); }\n  else\n    { this.context.push(types$1.f_stat); }\n  this.exprAllowed = false;\n};\n\ntypes.backQuote.updateContext = function() {\n  if (this.curContext() === types$1.q_tmpl)\n    { this.context.pop(); }\n  else\n    { this.context.push(types$1.q_tmpl); }\n  this.exprAllowed = false;\n};\n\ntypes.star.updateContext = function(prevType) {\n  if (prevType === types._function) {\n    var index = this.context.length - 1;\n    if (this.context[index] === types$1.f_expr)\n      { this.context[index] = types$1.f_expr_gen; }\n    else\n      { this.context[index] = types$1.f_gen; }\n  }\n  this.exprAllowed = true;\n};\n\ntypes.name.updateContext = function(prevType) {\n  var allowed = false;\n  if (this.options.ecmaVersion >= 6 && prevType !== types.dot) {\n    if (this.value === \"of\" && !this.exprAllowed ||\n        this.value === \"yield\" && this.inGeneratorContext())\n      { allowed = true; }\n  }\n  this.exprAllowed = allowed;\n};\n\n// This file contains Unicode properties extracted from the ECMAScript\n// specification. The lists are extracted like so:\n// $$('#table-binary-unicode-properties > figure > table > tbody > tr > td:nth-child(1) code').map(el => el.innerText)\n\n// #table-binary-unicode-properties\nvar ecma9BinaryProperties = \"ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS\";\nvar ecma10BinaryProperties = ecma9BinaryProperties + \" Extended_Pictographic\";\nvar ecma11BinaryProperties = ecma10BinaryProperties;\nvar unicodeBinaryProperties = {\n  9: ecma9BinaryProperties,\n  10: ecma10BinaryProperties,\n  11: ecma11BinaryProperties\n};\n\n// #table-unicode-general-category-values\nvar unicodeGeneralCategoryValues = \"Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu\";\n\n// #table-unicode-script-values\nvar ecma9ScriptValues = \"Adlam Adlm Ahom Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb\";\nvar ecma10ScriptValues = ecma9ScriptValues + \" Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd\";\nvar ecma11ScriptValues = ecma10ScriptValues + \" Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho\";\nvar unicodeScriptValues = {\n  9: ecma9ScriptValues,\n  10: ecma10ScriptValues,\n  11: ecma11ScriptValues\n};\n\nvar data = {};\nfunction buildUnicodeData(ecmaVersion) {\n  var d = data[ecmaVersion] = {\n    binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion] + \" \" + unicodeGeneralCategoryValues),\n    nonBinary: {\n      General_Category: wordsRegexp(unicodeGeneralCategoryValues),\n      Script: wordsRegexp(unicodeScriptValues[ecmaVersion])\n    }\n  };\n  d.nonBinary.Script_Extensions = d.nonBinary.Script;\n\n  d.nonBinary.gc = d.nonBinary.General_Category;\n  d.nonBinary.sc = d.nonBinary.Script;\n  d.nonBinary.scx = d.nonBinary.Script_Extensions;\n}\nbuildUnicodeData(9);\nbuildUnicodeData(10);\nbuildUnicodeData(11);\n\nvar pp$8 = Parser.prototype;\n\nvar RegExpValidationState = function RegExpValidationState(parser) {\n  this.parser = parser;\n  this.validFlags = \"gim\" + (parser.options.ecmaVersion >= 6 ? \"uy\" : \"\") + (parser.options.ecmaVersion >= 9 ? \"s\" : \"\");\n  this.unicodeProperties = data[parser.options.ecmaVersion >= 11 ? 11 : parser.options.ecmaVersion];\n  this.source = \"\";\n  this.flags = \"\";\n  this.start = 0;\n  this.switchU = false;\n  this.switchN = false;\n  this.pos = 0;\n  this.lastIntValue = 0;\n  this.lastStringValue = \"\";\n  this.lastAssertionIsQuantifiable = false;\n  this.numCapturingParens = 0;\n  this.maxBackReference = 0;\n  this.groupNames = [];\n  this.backReferenceNames = [];\n};\n\nRegExpValidationState.prototype.reset = function reset (start, pattern, flags) {\n  var unicode = flags.indexOf(\"u\") !== -1;\n  this.start = start | 0;\n  this.source = pattern + \"\";\n  this.flags = flags;\n  this.switchU = unicode && this.parser.options.ecmaVersion >= 6;\n  this.switchN = unicode && this.parser.options.ecmaVersion >= 9;\n};\n\nRegExpValidationState.prototype.raise = function raise (message) {\n  this.parser.raiseRecoverable(this.start, (\"Invalid regular expression: /\" + (this.source) + \"/: \" + message));\n};\n\n// If u flag is given, this returns the code point at the index (it combines a surrogate pair).\n// Otherwise, this returns the code unit of the index (can be a part of a surrogate pair).\nRegExpValidationState.prototype.at = function at (i, forceU) {\n    if ( forceU === void 0 ) forceU = false;\n\n  var s = this.source;\n  var l = s.length;\n  if (i >= l) {\n    return -1\n  }\n  var c = s.charCodeAt(i);\n  if (!(forceU || this.switchU) || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l) {\n    return c\n  }\n  var next = s.charCodeAt(i + 1);\n  return next >= 0xDC00 && next <= 0xDFFF ? (c << 10) + next - 0x35FDC00 : c\n};\n\nRegExpValidationState.prototype.nextIndex = function nextIndex (i, forceU) {\n    if ( forceU === void 0 ) forceU = false;\n\n  var s = this.source;\n  var l = s.length;\n  if (i >= l) {\n    return l\n  }\n  var c = s.charCodeAt(i), next;\n  if (!(forceU || this.switchU) || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l ||\n      (next = s.charCodeAt(i + 1)) < 0xDC00 || next > 0xDFFF) {\n    return i + 1\n  }\n  return i + 2\n};\n\nRegExpValidationState.prototype.current = function current (forceU) {\n    if ( forceU === void 0 ) forceU = false;\n\n  return this.at(this.pos, forceU)\n};\n\nRegExpValidationState.prototype.lookahead = function lookahead (forceU) {\n    if ( forceU === void 0 ) forceU = false;\n\n  return this.at(this.nextIndex(this.pos, forceU), forceU)\n};\n\nRegExpValidationState.prototype.advance = function advance (forceU) {\n    if ( forceU === void 0 ) forceU = false;\n\n  this.pos = this.nextIndex(this.pos, forceU);\n};\n\nRegExpValidationState.prototype.eat = function eat (ch, forceU) {\n    if ( forceU === void 0 ) forceU = false;\n\n  if (this.current(forceU) === ch) {\n    this.advance(forceU);\n    return true\n  }\n  return false\n};\n\nfunction codePointToString(ch) {\n  if (ch <= 0xFFFF) { return String.fromCharCode(ch) }\n  ch -= 0x10000;\n  return String.fromCharCode((ch >> 10) + 0xD800, (ch & 0x03FF) + 0xDC00)\n}\n\n/**\n * Validate the flags part of a given RegExpLiteral.\n *\n * @param {RegExpValidationState} state The state to validate RegExp.\n * @returns {void}\n */\npp$8.validateRegExpFlags = function(state) {\n  var validFlags = state.validFlags;\n  var flags = state.flags;\n\n  for (var i = 0; i < flags.length; i++) {\n    var flag = flags.charAt(i);\n    if (validFlags.indexOf(flag) === -1) {\n      this.raise(state.start, \"Invalid regular expression flag\");\n    }\n    if (flags.indexOf(flag, i + 1) > -1) {\n      this.raise(state.start, \"Duplicate regular expression flag\");\n    }\n  }\n};\n\n/**\n * Validate the pattern part of a given RegExpLiteral.\n *\n * @param {RegExpValidationState} state The state to validate RegExp.\n * @returns {void}\n */\npp$8.validateRegExpPattern = function(state) {\n  this.regexp_pattern(state);\n\n  // The goal symbol for the parse is |Pattern[~U, ~N]|. If the result of\n  // parsing contains a |GroupName|, reparse with the goal symbol\n  // |Pattern[~U, +N]| and use this result instead. Throw a *SyntaxError*\n  // exception if _P_ did not conform to the grammar, if any elements of _P_\n  // were not matched by the parse, or if any Early Error conditions exist.\n  if (!state.switchN && this.options.ecmaVersion >= 9 && state.groupNames.length > 0) {\n    state.switchN = true;\n    this.regexp_pattern(state);\n  }\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-Pattern\npp$8.regexp_pattern = function(state) {\n  state.pos = 0;\n  state.lastIntValue = 0;\n  state.lastStringValue = \"\";\n  state.lastAssertionIsQuantifiable = false;\n  state.numCapturingParens = 0;\n  state.maxBackReference = 0;\n  state.groupNames.length = 0;\n  state.backReferenceNames.length = 0;\n\n  this.regexp_disjunction(state);\n\n  if (state.pos !== state.source.length) {\n    // Make the same messages as V8.\n    if (state.eat(0x29 /* ) */)) {\n      state.raise(\"Unmatched ')'\");\n    }\n    if (state.eat(0x5D /* ] */) || state.eat(0x7D /* } */)) {\n      state.raise(\"Lone quantifier brackets\");\n    }\n  }\n  if (state.maxBackReference > state.numCapturingParens) {\n    state.raise(\"Invalid escape\");\n  }\n  for (var i = 0, list = state.backReferenceNames; i < list.length; i += 1) {\n    var name = list[i];\n\n    if (state.groupNames.indexOf(name) === -1) {\n      state.raise(\"Invalid named capture referenced\");\n    }\n  }\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-Disjunction\npp$8.regexp_disjunction = function(state) {\n  this.regexp_alternative(state);\n  while (state.eat(0x7C /* | */)) {\n    this.regexp_alternative(state);\n  }\n\n  // Make the same message as V8.\n  if (this.regexp_eatQuantifier(state, true)) {\n    state.raise(\"Nothing to repeat\");\n  }\n  if (state.eat(0x7B /* { */)) {\n    state.raise(\"Lone quantifier brackets\");\n  }\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-Alternative\npp$8.regexp_alternative = function(state) {\n  while (state.pos < state.source.length && this.regexp_eatTerm(state))\n    { }\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Term\npp$8.regexp_eatTerm = function(state) {\n  if (this.regexp_eatAssertion(state)) {\n    // Handle `QuantifiableAssertion Quantifier` alternative.\n    // `state.lastAssertionIsQuantifiable` is true if the last eaten Assertion\n    // is a QuantifiableAssertion.\n    if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {\n      // Make the same message as V8.\n      if (state.switchU) {\n        state.raise(\"Invalid quantifier\");\n      }\n    }\n    return true\n  }\n\n  if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {\n    this.regexp_eatQuantifier(state);\n    return true\n  }\n\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Assertion\npp$8.regexp_eatAssertion = function(state) {\n  var start = state.pos;\n  state.lastAssertionIsQuantifiable = false;\n\n  // ^, $\n  if (state.eat(0x5E /* ^ */) || state.eat(0x24 /* $ */)) {\n    return true\n  }\n\n  // \\b \\B\n  if (state.eat(0x5C /* \\ */)) {\n    if (state.eat(0x42 /* B */) || state.eat(0x62 /* b */)) {\n      return true\n    }\n    state.pos = start;\n  }\n\n  // Lookahead / Lookbehind\n  if (state.eat(0x28 /* ( */) && state.eat(0x3F /* ? */)) {\n    var lookbehind = false;\n    if (this.options.ecmaVersion >= 9) {\n      lookbehind = state.eat(0x3C /* < */);\n    }\n    if (state.eat(0x3D /* = */) || state.eat(0x21 /* ! */)) {\n      this.regexp_disjunction(state);\n      if (!state.eat(0x29 /* ) */)) {\n        state.raise(\"Unterminated group\");\n      }\n      state.lastAssertionIsQuantifiable = !lookbehind;\n      return true\n    }\n  }\n\n  state.pos = start;\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-Quantifier\npp$8.regexp_eatQuantifier = function(state, noError) {\n  if ( noError === void 0 ) noError = false;\n\n  if (this.regexp_eatQuantifierPrefix(state, noError)) {\n    state.eat(0x3F /* ? */);\n    return true\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-QuantifierPrefix\npp$8.regexp_eatQuantifierPrefix = function(state, noError) {\n  return (\n    state.eat(0x2A /* * */) ||\n    state.eat(0x2B /* + */) ||\n    state.eat(0x3F /* ? */) ||\n    this.regexp_eatBracedQuantifier(state, noError)\n  )\n};\npp$8.regexp_eatBracedQuantifier = function(state, noError) {\n  var start = state.pos;\n  if (state.eat(0x7B /* { */)) {\n    var min = 0, max = -1;\n    if (this.regexp_eatDecimalDigits(state)) {\n      min = state.lastIntValue;\n      if (state.eat(0x2C /* , */) && this.regexp_eatDecimalDigits(state)) {\n        max = state.lastIntValue;\n      }\n      if (state.eat(0x7D /* } */)) {\n        // SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-term\n        if (max !== -1 && max < min && !noError) {\n          state.raise(\"numbers out of order in {} quantifier\");\n        }\n        return true\n      }\n    }\n    if (state.switchU && !noError) {\n      state.raise(\"Incomplete quantifier\");\n    }\n    state.pos = start;\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-Atom\npp$8.regexp_eatAtom = function(state) {\n  return (\n    this.regexp_eatPatternCharacters(state) ||\n    state.eat(0x2E /* . */) ||\n    this.regexp_eatReverseSolidusAtomEscape(state) ||\n    this.regexp_eatCharacterClass(state) ||\n    this.regexp_eatUncapturingGroup(state) ||\n    this.regexp_eatCapturingGroup(state)\n  )\n};\npp$8.regexp_eatReverseSolidusAtomEscape = function(state) {\n  var start = state.pos;\n  if (state.eat(0x5C /* \\ */)) {\n    if (this.regexp_eatAtomEscape(state)) {\n      return true\n    }\n    state.pos = start;\n  }\n  return false\n};\npp$8.regexp_eatUncapturingGroup = function(state) {\n  var start = state.pos;\n  if (state.eat(0x28 /* ( */)) {\n    if (state.eat(0x3F /* ? */) && state.eat(0x3A /* : */)) {\n      this.regexp_disjunction(state);\n      if (state.eat(0x29 /* ) */)) {\n        return true\n      }\n      state.raise(\"Unterminated group\");\n    }\n    state.pos = start;\n  }\n  return false\n};\npp$8.regexp_eatCapturingGroup = function(state) {\n  if (state.eat(0x28 /* ( */)) {\n    if (this.options.ecmaVersion >= 9) {\n      this.regexp_groupSpecifier(state);\n    } else if (state.current() === 0x3F /* ? */) {\n      state.raise(\"Invalid group\");\n    }\n    this.regexp_disjunction(state);\n    if (state.eat(0x29 /* ) */)) {\n      state.numCapturingParens += 1;\n      return true\n    }\n    state.raise(\"Unterminated group\");\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedAtom\npp$8.regexp_eatExtendedAtom = function(state) {\n  return (\n    state.eat(0x2E /* . */) ||\n    this.regexp_eatReverseSolidusAtomEscape(state) ||\n    this.regexp_eatCharacterClass(state) ||\n    this.regexp_eatUncapturingGroup(state) ||\n    this.regexp_eatCapturingGroup(state) ||\n    this.regexp_eatInvalidBracedQuantifier(state) ||\n    this.regexp_eatExtendedPatternCharacter(state)\n  )\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-InvalidBracedQuantifier\npp$8.regexp_eatInvalidBracedQuantifier = function(state) {\n  if (this.regexp_eatBracedQuantifier(state, true)) {\n    state.raise(\"Nothing to repeat\");\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-SyntaxCharacter\npp$8.regexp_eatSyntaxCharacter = function(state) {\n  var ch = state.current();\n  if (isSyntaxCharacter(ch)) {\n    state.lastIntValue = ch;\n    state.advance();\n    return true\n  }\n  return false\n};\nfunction isSyntaxCharacter(ch) {\n  return (\n    ch === 0x24 /* $ */ ||\n    ch >= 0x28 /* ( */ && ch <= 0x2B /* + */ ||\n    ch === 0x2E /* . */ ||\n    ch === 0x3F /* ? */ ||\n    ch >= 0x5B /* [ */ && ch <= 0x5E /* ^ */ ||\n    ch >= 0x7B /* { */ && ch <= 0x7D /* } */\n  )\n}\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-PatternCharacter\n// But eat eager.\npp$8.regexp_eatPatternCharacters = function(state) {\n  var start = state.pos;\n  var ch = 0;\n  while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) {\n    state.advance();\n  }\n  return state.pos !== start\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedPatternCharacter\npp$8.regexp_eatExtendedPatternCharacter = function(state) {\n  var ch = state.current();\n  if (\n    ch !== -1 &&\n    ch !== 0x24 /* $ */ &&\n    !(ch >= 0x28 /* ( */ && ch <= 0x2B /* + */) &&\n    ch !== 0x2E /* . */ &&\n    ch !== 0x3F /* ? */ &&\n    ch !== 0x5B /* [ */ &&\n    ch !== 0x5E /* ^ */ &&\n    ch !== 0x7C /* | */\n  ) {\n    state.advance();\n    return true\n  }\n  return false\n};\n\n// GroupSpecifier ::\n//   [empty]\n//   `?` GroupName\npp$8.regexp_groupSpecifier = function(state) {\n  if (state.eat(0x3F /* ? */)) {\n    if (this.regexp_eatGroupName(state)) {\n      if (state.groupNames.indexOf(state.lastStringValue) !== -1) {\n        state.raise(\"Duplicate capture group name\");\n      }\n      state.groupNames.push(state.lastStringValue);\n      return\n    }\n    state.raise(\"Invalid group\");\n  }\n};\n\n// GroupName ::\n//   `<` RegExpIdentifierName `>`\n// Note: this updates `state.lastStringValue` property with the eaten name.\npp$8.regexp_eatGroupName = function(state) {\n  state.lastStringValue = \"\";\n  if (state.eat(0x3C /* < */)) {\n    if (this.regexp_eatRegExpIdentifierName(state) && state.eat(0x3E /* > */)) {\n      return true\n    }\n    state.raise(\"Invalid capture group name\");\n  }\n  return false\n};\n\n// RegExpIdentifierName ::\n//   RegExpIdentifierStart\n//   RegExpIdentifierName RegExpIdentifierPart\n// Note: this updates `state.lastStringValue` property with the eaten name.\npp$8.regexp_eatRegExpIdentifierName = function(state) {\n  state.lastStringValue = \"\";\n  if (this.regexp_eatRegExpIdentifierStart(state)) {\n    state.lastStringValue += codePointToString(state.lastIntValue);\n    while (this.regexp_eatRegExpIdentifierPart(state)) {\n      state.lastStringValue += codePointToString(state.lastIntValue);\n    }\n    return true\n  }\n  return false\n};\n\n// RegExpIdentifierStart ::\n//   UnicodeIDStart\n//   `$`\n//   `_`\n//   `\\` RegExpUnicodeEscapeSequence[+U]\npp$8.regexp_eatRegExpIdentifierStart = function(state) {\n  var start = state.pos;\n  var forceU = this.options.ecmaVersion >= 11;\n  var ch = state.current(forceU);\n  state.advance(forceU);\n\n  if (ch === 0x5C /* \\ */ && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {\n    ch = state.lastIntValue;\n  }\n  if (isRegExpIdentifierStart(ch)) {\n    state.lastIntValue = ch;\n    return true\n  }\n\n  state.pos = start;\n  return false\n};\nfunction isRegExpIdentifierStart(ch) {\n  return isIdentifierStart(ch, true) || ch === 0x24 /* $ */ || ch === 0x5F /* _ */\n}\n\n// RegExpIdentifierPart ::\n//   UnicodeIDContinue\n//   `$`\n//   `_`\n//   `\\` RegExpUnicodeEscapeSequence[+U]\n//   <ZWNJ>\n//   <ZWJ>\npp$8.regexp_eatRegExpIdentifierPart = function(state) {\n  var start = state.pos;\n  var forceU = this.options.ecmaVersion >= 11;\n  var ch = state.current(forceU);\n  state.advance(forceU);\n\n  if (ch === 0x5C /* \\ */ && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {\n    ch = state.lastIntValue;\n  }\n  if (isRegExpIdentifierPart(ch)) {\n    state.lastIntValue = ch;\n    return true\n  }\n\n  state.pos = start;\n  return false\n};\nfunction isRegExpIdentifierPart(ch) {\n  return isIdentifierChar(ch, true) || ch === 0x24 /* $ */ || ch === 0x5F /* _ */ || ch === 0x200C /* <ZWNJ> */ || ch === 0x200D /* <ZWJ> */\n}\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-AtomEscape\npp$8.regexp_eatAtomEscape = function(state) {\n  if (\n    this.regexp_eatBackReference(state) ||\n    this.regexp_eatCharacterClassEscape(state) ||\n    this.regexp_eatCharacterEscape(state) ||\n    (state.switchN && this.regexp_eatKGroupName(state))\n  ) {\n    return true\n  }\n  if (state.switchU) {\n    // Make the same message as V8.\n    if (state.current() === 0x63 /* c */) {\n      state.raise(\"Invalid unicode escape\");\n    }\n    state.raise(\"Invalid escape\");\n  }\n  return false\n};\npp$8.regexp_eatBackReference = function(state) {\n  var start = state.pos;\n  if (this.regexp_eatDecimalEscape(state)) {\n    var n = state.lastIntValue;\n    if (state.switchU) {\n      // For SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-atomescape\n      if (n > state.maxBackReference) {\n        state.maxBackReference = n;\n      }\n      return true\n    }\n    if (n <= state.numCapturingParens) {\n      return true\n    }\n    state.pos = start;\n  }\n  return false\n};\npp$8.regexp_eatKGroupName = function(state) {\n  if (state.eat(0x6B /* k */)) {\n    if (this.regexp_eatGroupName(state)) {\n      state.backReferenceNames.push(state.lastStringValue);\n      return true\n    }\n    state.raise(\"Invalid named reference\");\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-CharacterEscape\npp$8.regexp_eatCharacterEscape = function(state) {\n  return (\n    this.regexp_eatControlEscape(state) ||\n    this.regexp_eatCControlLetter(state) ||\n    this.regexp_eatZero(state) ||\n    this.regexp_eatHexEscapeSequence(state) ||\n    this.regexp_eatRegExpUnicodeEscapeSequence(state, false) ||\n    (!state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state)) ||\n    this.regexp_eatIdentityEscape(state)\n  )\n};\npp$8.regexp_eatCControlLetter = function(state) {\n  var start = state.pos;\n  if (state.eat(0x63 /* c */)) {\n    if (this.regexp_eatControlLetter(state)) {\n      return true\n    }\n    state.pos = start;\n  }\n  return false\n};\npp$8.regexp_eatZero = function(state) {\n  if (state.current() === 0x30 /* 0 */ && !isDecimalDigit(state.lookahead())) {\n    state.lastIntValue = 0;\n    state.advance();\n    return true\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-ControlEscape\npp$8.regexp_eatControlEscape = function(state) {\n  var ch = state.current();\n  if (ch === 0x74 /* t */) {\n    state.lastIntValue = 0x09; /* \\t */\n    state.advance();\n    return true\n  }\n  if (ch === 0x6E /* n */) {\n    state.lastIntValue = 0x0A; /* \\n */\n    state.advance();\n    return true\n  }\n  if (ch === 0x76 /* v */) {\n    state.lastIntValue = 0x0B; /* \\v */\n    state.advance();\n    return true\n  }\n  if (ch === 0x66 /* f */) {\n    state.lastIntValue = 0x0C; /* \\f */\n    state.advance();\n    return true\n  }\n  if (ch === 0x72 /* r */) {\n    state.lastIntValue = 0x0D; /* \\r */\n    state.advance();\n    return true\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-ControlLetter\npp$8.regexp_eatControlLetter = function(state) {\n  var ch = state.current();\n  if (isControlLetter(ch)) {\n    state.lastIntValue = ch % 0x20;\n    state.advance();\n    return true\n  }\n  return false\n};\nfunction isControlLetter(ch) {\n  return (\n    (ch >= 0x41 /* A */ && ch <= 0x5A /* Z */) ||\n    (ch >= 0x61 /* a */ && ch <= 0x7A /* z */)\n  )\n}\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-RegExpUnicodeEscapeSequence\npp$8.regexp_eatRegExpUnicodeEscapeSequence = function(state, forceU) {\n  if ( forceU === void 0 ) forceU = false;\n\n  var start = state.pos;\n  var switchU = forceU || state.switchU;\n\n  if (state.eat(0x75 /* u */)) {\n    if (this.regexp_eatFixedHexDigits(state, 4)) {\n      var lead = state.lastIntValue;\n      if (switchU && lead >= 0xD800 && lead <= 0xDBFF) {\n        var leadSurrogateEnd = state.pos;\n        if (state.eat(0x5C /* \\ */) && state.eat(0x75 /* u */) && this.regexp_eatFixedHexDigits(state, 4)) {\n          var trail = state.lastIntValue;\n          if (trail >= 0xDC00 && trail <= 0xDFFF) {\n            state.lastIntValue = (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;\n            return true\n          }\n        }\n        state.pos = leadSurrogateEnd;\n        state.lastIntValue = lead;\n      }\n      return true\n    }\n    if (\n      switchU &&\n      state.eat(0x7B /* { */) &&\n      this.regexp_eatHexDigits(state) &&\n      state.eat(0x7D /* } */) &&\n      isValidUnicode(state.lastIntValue)\n    ) {\n      return true\n    }\n    if (switchU) {\n      state.raise(\"Invalid unicode escape\");\n    }\n    state.pos = start;\n  }\n\n  return false\n};\nfunction isValidUnicode(ch) {\n  return ch >= 0 && ch <= 0x10FFFF\n}\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-IdentityEscape\npp$8.regexp_eatIdentityEscape = function(state) {\n  if (state.switchU) {\n    if (this.regexp_eatSyntaxCharacter(state)) {\n      return true\n    }\n    if (state.eat(0x2F /* / */)) {\n      state.lastIntValue = 0x2F; /* / */\n      return true\n    }\n    return false\n  }\n\n  var ch = state.current();\n  if (ch !== 0x63 /* c */ && (!state.switchN || ch !== 0x6B /* k */)) {\n    state.lastIntValue = ch;\n    state.advance();\n    return true\n  }\n\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalEscape\npp$8.regexp_eatDecimalEscape = function(state) {\n  state.lastIntValue = 0;\n  var ch = state.current();\n  if (ch >= 0x31 /* 1 */ && ch <= 0x39 /* 9 */) {\n    do {\n      state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */);\n      state.advance();\n    } while ((ch = state.current()) >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */)\n    return true\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClassEscape\npp$8.regexp_eatCharacterClassEscape = function(state) {\n  var ch = state.current();\n\n  if (isCharacterClassEscape(ch)) {\n    state.lastIntValue = -1;\n    state.advance();\n    return true\n  }\n\n  if (\n    state.switchU &&\n    this.options.ecmaVersion >= 9 &&\n    (ch === 0x50 /* P */ || ch === 0x70 /* p */)\n  ) {\n    state.lastIntValue = -1;\n    state.advance();\n    if (\n      state.eat(0x7B /* { */) &&\n      this.regexp_eatUnicodePropertyValueExpression(state) &&\n      state.eat(0x7D /* } */)\n    ) {\n      return true\n    }\n    state.raise(\"Invalid property name\");\n  }\n\n  return false\n};\nfunction isCharacterClassEscape(ch) {\n  return (\n    ch === 0x64 /* d */ ||\n    ch === 0x44 /* D */ ||\n    ch === 0x73 /* s */ ||\n    ch === 0x53 /* S */ ||\n    ch === 0x77 /* w */ ||\n    ch === 0x57 /* W */\n  )\n}\n\n// UnicodePropertyValueExpression ::\n//   UnicodePropertyName `=` UnicodePropertyValue\n//   LoneUnicodePropertyNameOrValue\npp$8.regexp_eatUnicodePropertyValueExpression = function(state) {\n  var start = state.pos;\n\n  // UnicodePropertyName `=` UnicodePropertyValue\n  if (this.regexp_eatUnicodePropertyName(state) && state.eat(0x3D /* = */)) {\n    var name = state.lastStringValue;\n    if (this.regexp_eatUnicodePropertyValue(state)) {\n      var value = state.lastStringValue;\n      this.regexp_validateUnicodePropertyNameAndValue(state, name, value);\n      return true\n    }\n  }\n  state.pos = start;\n\n  // LoneUnicodePropertyNameOrValue\n  if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {\n    var nameOrValue = state.lastStringValue;\n    this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);\n    return true\n  }\n  return false\n};\npp$8.regexp_validateUnicodePropertyNameAndValue = function(state, name, value) {\n  if (!has(state.unicodeProperties.nonBinary, name))\n    { state.raise(\"Invalid property name\"); }\n  if (!state.unicodeProperties.nonBinary[name].test(value))\n    { state.raise(\"Invalid property value\"); }\n};\npp$8.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {\n  if (!state.unicodeProperties.binary.test(nameOrValue))\n    { state.raise(\"Invalid property name\"); }\n};\n\n// UnicodePropertyName ::\n//   UnicodePropertyNameCharacters\npp$8.regexp_eatUnicodePropertyName = function(state) {\n  var ch = 0;\n  state.lastStringValue = \"\";\n  while (isUnicodePropertyNameCharacter(ch = state.current())) {\n    state.lastStringValue += codePointToString(ch);\n    state.advance();\n  }\n  return state.lastStringValue !== \"\"\n};\nfunction isUnicodePropertyNameCharacter(ch) {\n  return isControlLetter(ch) || ch === 0x5F /* _ */\n}\n\n// UnicodePropertyValue ::\n//   UnicodePropertyValueCharacters\npp$8.regexp_eatUnicodePropertyValue = function(state) {\n  var ch = 0;\n  state.lastStringValue = \"\";\n  while (isUnicodePropertyValueCharacter(ch = state.current())) {\n    state.lastStringValue += codePointToString(ch);\n    state.advance();\n  }\n  return state.lastStringValue !== \"\"\n};\nfunction isUnicodePropertyValueCharacter(ch) {\n  return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch)\n}\n\n// LoneUnicodePropertyNameOrValue ::\n//   UnicodePropertyValueCharacters\npp$8.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {\n  return this.regexp_eatUnicodePropertyValue(state)\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClass\npp$8.regexp_eatCharacterClass = function(state) {\n  if (state.eat(0x5B /* [ */)) {\n    state.eat(0x5E /* ^ */);\n    this.regexp_classRanges(state);\n    if (state.eat(0x5D /* ] */)) {\n      return true\n    }\n    // Unreachable since it threw \"unterminated regular expression\" error before.\n    state.raise(\"Unterminated character class\");\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassRanges\n// https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRanges\n// https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRangesNoDash\npp$8.regexp_classRanges = function(state) {\n  while (this.regexp_eatClassAtom(state)) {\n    var left = state.lastIntValue;\n    if (state.eat(0x2D /* - */) && this.regexp_eatClassAtom(state)) {\n      var right = state.lastIntValue;\n      if (state.switchU && (left === -1 || right === -1)) {\n        state.raise(\"Invalid character class\");\n      }\n      if (left !== -1 && right !== -1 && left > right) {\n        state.raise(\"Range out of order in character class\");\n      }\n    }\n  }\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtom\n// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtomNoDash\npp$8.regexp_eatClassAtom = function(state) {\n  var start = state.pos;\n\n  if (state.eat(0x5C /* \\ */)) {\n    if (this.regexp_eatClassEscape(state)) {\n      return true\n    }\n    if (state.switchU) {\n      // Make the same message as V8.\n      var ch$1 = state.current();\n      if (ch$1 === 0x63 /* c */ || isOctalDigit(ch$1)) {\n        state.raise(\"Invalid class escape\");\n      }\n      state.raise(\"Invalid escape\");\n    }\n    state.pos = start;\n  }\n\n  var ch = state.current();\n  if (ch !== 0x5D /* ] */) {\n    state.lastIntValue = ch;\n    state.advance();\n    return true\n  }\n\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassEscape\npp$8.regexp_eatClassEscape = function(state) {\n  var start = state.pos;\n\n  if (state.eat(0x62 /* b */)) {\n    state.lastIntValue = 0x08; /* <BS> */\n    return true\n  }\n\n  if (state.switchU && state.eat(0x2D /* - */)) {\n    state.lastIntValue = 0x2D; /* - */\n    return true\n  }\n\n  if (!state.switchU && state.eat(0x63 /* c */)) {\n    if (this.regexp_eatClassControlLetter(state)) {\n      return true\n    }\n    state.pos = start;\n  }\n\n  return (\n    this.regexp_eatCharacterClassEscape(state) ||\n    this.regexp_eatCharacterEscape(state)\n  )\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassControlLetter\npp$8.regexp_eatClassControlLetter = function(state) {\n  var ch = state.current();\n  if (isDecimalDigit(ch) || ch === 0x5F /* _ */) {\n    state.lastIntValue = ch % 0x20;\n    state.advance();\n    return true\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence\npp$8.regexp_eatHexEscapeSequence = function(state) {\n  var start = state.pos;\n  if (state.eat(0x78 /* x */)) {\n    if (this.regexp_eatFixedHexDigits(state, 2)) {\n      return true\n    }\n    if (state.switchU) {\n      state.raise(\"Invalid escape\");\n    }\n    state.pos = start;\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalDigits\npp$8.regexp_eatDecimalDigits = function(state) {\n  var start = state.pos;\n  var ch = 0;\n  state.lastIntValue = 0;\n  while (isDecimalDigit(ch = state.current())) {\n    state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */);\n    state.advance();\n  }\n  return state.pos !== start\n};\nfunction isDecimalDigit(ch) {\n  return ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */\n}\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigits\npp$8.regexp_eatHexDigits = function(state) {\n  var start = state.pos;\n  var ch = 0;\n  state.lastIntValue = 0;\n  while (isHexDigit(ch = state.current())) {\n    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);\n    state.advance();\n  }\n  return state.pos !== start\n};\nfunction isHexDigit(ch) {\n  return (\n    (ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */) ||\n    (ch >= 0x41 /* A */ && ch <= 0x46 /* F */) ||\n    (ch >= 0x61 /* a */ && ch <= 0x66 /* f */)\n  )\n}\nfunction hexToInt(ch) {\n  if (ch >= 0x41 /* A */ && ch <= 0x46 /* F */) {\n    return 10 + (ch - 0x41 /* A */)\n  }\n  if (ch >= 0x61 /* a */ && ch <= 0x66 /* f */) {\n    return 10 + (ch - 0x61 /* a */)\n  }\n  return ch - 0x30 /* 0 */\n}\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-LegacyOctalEscapeSequence\n// Allows only 0-377(octal) i.e. 0-255(decimal).\npp$8.regexp_eatLegacyOctalEscapeSequence = function(state) {\n  if (this.regexp_eatOctalDigit(state)) {\n    var n1 = state.lastIntValue;\n    if (this.regexp_eatOctalDigit(state)) {\n      var n2 = state.lastIntValue;\n      if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {\n        state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;\n      } else {\n        state.lastIntValue = n1 * 8 + n2;\n      }\n    } else {\n      state.lastIntValue = n1;\n    }\n    return true\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-OctalDigit\npp$8.regexp_eatOctalDigit = function(state) {\n  var ch = state.current();\n  if (isOctalDigit(ch)) {\n    state.lastIntValue = ch - 0x30; /* 0 */\n    state.advance();\n    return true\n  }\n  state.lastIntValue = 0;\n  return false\n};\nfunction isOctalDigit(ch) {\n  return ch >= 0x30 /* 0 */ && ch <= 0x37 /* 7 */\n}\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-Hex4Digits\n// https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigit\n// And HexDigit HexDigit in https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence\npp$8.regexp_eatFixedHexDigits = function(state, length) {\n  var start = state.pos;\n  state.lastIntValue = 0;\n  for (var i = 0; i < length; ++i) {\n    var ch = state.current();\n    if (!isHexDigit(ch)) {\n      state.pos = start;\n      return false\n    }\n    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);\n    state.advance();\n  }\n  return true\n};\n\n// Object type used to represent tokens. Note that normally, tokens\n// simply exist as properties on the parser object. This is only\n// used for the onToken callback and the external tokenizer.\n\nvar Token = function Token(p) {\n  this.type = p.type;\n  this.value = p.value;\n  this.start = p.start;\n  this.end = p.end;\n  if (p.options.locations)\n    { this.loc = new SourceLocation(p, p.startLoc, p.endLoc); }\n  if (p.options.ranges)\n    { this.range = [p.start, p.end]; }\n};\n\n// ## Tokenizer\n\nvar pp$9 = Parser.prototype;\n\n// Move to the next token\n\npp$9.next = function(ignoreEscapeSequenceInKeyword) {\n  if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc)\n    { this.raiseRecoverable(this.start, \"Escape sequence in keyword \" + this.type.keyword); }\n  if (this.options.onToken)\n    { this.options.onToken(new Token(this)); }\n\n  this.lastTokEnd = this.end;\n  this.lastTokStart = this.start;\n  this.lastTokEndLoc = this.endLoc;\n  this.lastTokStartLoc = this.startLoc;\n  this.nextToken();\n};\n\npp$9.getToken = function() {\n  this.next();\n  return new Token(this)\n};\n\n// If we're in an ES6 environment, make parsers iterable\nif (typeof Symbol !== \"undefined\")\n  { pp$9[Symbol.iterator] = function() {\n    var this$1 = this;\n\n    return {\n      next: function () {\n        var token = this$1.getToken();\n        return {\n          done: token.type === types.eof,\n          value: token\n        }\n      }\n    }\n  }; }\n\n// Toggle strict mode. Re-reads the next number or string to please\n// pedantic tests (`\"use strict\"; 010;` should fail).\n\npp$9.curContext = function() {\n  return this.context[this.context.length - 1]\n};\n\n// Read a single token, updating the parser object's token-related\n// properties.\n\npp$9.nextToken = function() {\n  var curContext = this.curContext();\n  if (!curContext || !curContext.preserveSpace) { this.skipSpace(); }\n\n  this.start = this.pos;\n  if (this.options.locations) { this.startLoc = this.curPosition(); }\n  if (this.pos >= this.input.length) { return this.finishToken(types.eof) }\n\n  if (curContext.override) { return curContext.override(this) }\n  else { this.readToken(this.fullCharCodeAtPos()); }\n};\n\npp$9.readToken = function(code) {\n  // Identifier or keyword. '\\uXXXX' sequences are allowed in\n  // identifiers, so '\\' also dispatches to that.\n  if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92 /* '\\' */)\n    { return this.readWord() }\n\n  return this.getTokenFromCode(code)\n};\n\npp$9.fullCharCodeAtPos = function() {\n  var code = this.input.charCodeAt(this.pos);\n  if (code <= 0xd7ff || code >= 0xe000) { return code }\n  var next = this.input.charCodeAt(this.pos + 1);\n  return (code << 10) + next - 0x35fdc00\n};\n\npp$9.skipBlockComment = function() {\n  var startLoc = this.options.onComment && this.curPosition();\n  var start = this.pos, end = this.input.indexOf(\"*/\", this.pos += 2);\n  if (end === -1) { this.raise(this.pos - 2, \"Unterminated comment\"); }\n  this.pos = end + 2;\n  if (this.options.locations) {\n    lineBreakG.lastIndex = start;\n    var match;\n    while ((match = lineBreakG.exec(this.input)) && match.index < this.pos) {\n      ++this.curLine;\n      this.lineStart = match.index + match[0].length;\n    }\n  }\n  if (this.options.onComment)\n    { this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos,\n                           startLoc, this.curPosition()); }\n};\n\npp$9.skipLineComment = function(startSkip) {\n  var start = this.pos;\n  var startLoc = this.options.onComment && this.curPosition();\n  var ch = this.input.charCodeAt(this.pos += startSkip);\n  while (this.pos < this.input.length && !isNewLine(ch)) {\n    ch = this.input.charCodeAt(++this.pos);\n  }\n  if (this.options.onComment)\n    { this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos,\n                           startLoc, this.curPosition()); }\n};\n\n// Called at the start of the parse and after every token. Skips\n// whitespace and comments, and.\n\npp$9.skipSpace = function() {\n  loop: while (this.pos < this.input.length) {\n    var ch = this.input.charCodeAt(this.pos);\n    switch (ch) {\n    case 32: case 160: // ' '\n      ++this.pos;\n      break\n    case 13:\n      if (this.input.charCodeAt(this.pos + 1) === 10) {\n        ++this.pos;\n      }\n    case 10: case 8232: case 8233:\n      ++this.pos;\n      if (this.options.locations) {\n        ++this.curLine;\n        this.lineStart = this.pos;\n      }\n      break\n    case 47: // '/'\n      switch (this.input.charCodeAt(this.pos + 1)) {\n      case 42: // '*'\n        this.skipBlockComment();\n        break\n      case 47:\n        this.skipLineComment(2);\n        break\n      default:\n        break loop\n      }\n      break\n    default:\n      if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {\n        ++this.pos;\n      } else {\n        break loop\n      }\n    }\n  }\n};\n\n// Called at the end of every token. Sets `end`, `val`, and\n// maintains `context` and `exprAllowed`, and skips the space after\n// the token, so that the next one's `start` will point at the\n// right position.\n\npp$9.finishToken = function(type, val) {\n  this.end = this.pos;\n  if (this.options.locations) { this.endLoc = this.curPosition(); }\n  var prevType = this.type;\n  this.type = type;\n  this.value = val;\n\n  this.updateContext(prevType);\n};\n\n// ### Token reading\n\n// This is the function that is called to fetch the next token. It\n// is somewhat obscure, because it works in character codes rather\n// than characters, and because operator parsing has been inlined\n// into it.\n//\n// All in the name of speed.\n//\npp$9.readToken_dot = function() {\n  var next = this.input.charCodeAt(this.pos + 1);\n  if (next >= 48 && next <= 57) { return this.readNumber(true) }\n  var next2 = this.input.charCodeAt(this.pos + 2);\n  if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) { // 46 = dot '.'\n    this.pos += 3;\n    return this.finishToken(types.ellipsis)\n  } else {\n    ++this.pos;\n    return this.finishToken(types.dot)\n  }\n};\n\npp$9.readToken_slash = function() { // '/'\n  var next = this.input.charCodeAt(this.pos + 1);\n  if (this.exprAllowed) { ++this.pos; return this.readRegexp() }\n  if (next === 61) { return this.finishOp(types.assign, 2) }\n  return this.finishOp(types.slash, 1)\n};\n\npp$9.readToken_mult_modulo_exp = function(code) { // '%*'\n  var next = this.input.charCodeAt(this.pos + 1);\n  var size = 1;\n  var tokentype = code === 42 ? types.star : types.modulo;\n\n  // exponentiation operator ** and **=\n  if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {\n    ++size;\n    tokentype = types.starstar;\n    next = this.input.charCodeAt(this.pos + 2);\n  }\n\n  if (next === 61) { return this.finishOp(types.assign, size + 1) }\n  return this.finishOp(tokentype, size)\n};\n\npp$9.readToken_pipe_amp = function(code) { // '|&'\n  var next = this.input.charCodeAt(this.pos + 1);\n  if (next === code) { return this.finishOp(code === 124 ? types.logicalOR : types.logicalAND, 2) }\n  if (next === 61) { return this.finishOp(types.assign, 2) }\n  return this.finishOp(code === 124 ? types.bitwiseOR : types.bitwiseAND, 1)\n};\n\npp$9.readToken_caret = function() { // '^'\n  var next = this.input.charCodeAt(this.pos + 1);\n  if (next === 61) { return this.finishOp(types.assign, 2) }\n  return this.finishOp(types.bitwiseXOR, 1)\n};\n\npp$9.readToken_plus_min = function(code) { // '+-'\n  var next = this.input.charCodeAt(this.pos + 1);\n  if (next === code) {\n    if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 &&\n        (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {\n      // A `-->` line comment\n      this.skipLineComment(3);\n      this.skipSpace();\n      return this.nextToken()\n    }\n    return this.finishOp(types.incDec, 2)\n  }\n  if (next === 61) { return this.finishOp(types.assign, 2) }\n  return this.finishOp(types.plusMin, 1)\n};\n\npp$9.readToken_lt_gt = function(code) { // '<>'\n  var next = this.input.charCodeAt(this.pos + 1);\n  var size = 1;\n  if (next === code) {\n    size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;\n    if (this.input.charCodeAt(this.pos + size) === 61) { return this.finishOp(types.assign, size + 1) }\n    return this.finishOp(types.bitShift, size)\n  }\n  if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 &&\n      this.input.charCodeAt(this.pos + 3) === 45) {\n    // `<!--`, an XML-style comment that should be interpreted as a line comment\n    this.skipLineComment(4);\n    this.skipSpace();\n    return this.nextToken()\n  }\n  if (next === 61) { size = 2; }\n  return this.finishOp(types.relational, size)\n};\n\npp$9.readToken_eq_excl = function(code) { // '=!'\n  var next = this.input.charCodeAt(this.pos + 1);\n  if (next === 61) { return this.finishOp(types.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2) }\n  if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) { // '=>'\n    this.pos += 2;\n    return this.finishToken(types.arrow)\n  }\n  return this.finishOp(code === 61 ? types.eq : types.prefix, 1)\n};\n\npp$9.readToken_question = function() { // '?'\n  if (this.options.ecmaVersion >= 11) {\n    var next = this.input.charCodeAt(this.pos + 1);\n    if (next === 46) {\n      var next2 = this.input.charCodeAt(this.pos + 2);\n      if (next2 < 48 || next2 > 57) { return this.finishOp(types.questionDot, 2) }\n    }\n    if (next === 63) { return this.finishOp(types.coalesce, 2) }\n  }\n  return this.finishOp(types.question, 1)\n};\n\npp$9.getTokenFromCode = function(code) {\n  switch (code) {\n  // The interpretation of a dot depends on whether it is followed\n  // by a digit or another two dots.\n  case 46: // '.'\n    return this.readToken_dot()\n\n  // Punctuation tokens.\n  case 40: ++this.pos; return this.finishToken(types.parenL)\n  case 41: ++this.pos; return this.finishToken(types.parenR)\n  case 59: ++this.pos; return this.finishToken(types.semi)\n  case 44: ++this.pos; return this.finishToken(types.comma)\n  case 91: ++this.pos; return this.finishToken(types.bracketL)\n  case 93: ++this.pos; return this.finishToken(types.bracketR)\n  case 123: ++this.pos; return this.finishToken(types.braceL)\n  case 125: ++this.pos; return this.finishToken(types.braceR)\n  case 58: ++this.pos; return this.finishToken(types.colon)\n\n  case 96: // '`'\n    if (this.options.ecmaVersion < 6) { break }\n    ++this.pos;\n    return this.finishToken(types.backQuote)\n\n  case 48: // '0'\n    var next = this.input.charCodeAt(this.pos + 1);\n    if (next === 120 || next === 88) { return this.readRadixNumber(16) } // '0x', '0X' - hex number\n    if (this.options.ecmaVersion >= 6) {\n      if (next === 111 || next === 79) { return this.readRadixNumber(8) } // '0o', '0O' - octal number\n      if (next === 98 || next === 66) { return this.readRadixNumber(2) } // '0b', '0B' - binary number\n    }\n\n  // Anything else beginning with a digit is an integer, octal\n  // number, or float.\n  case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: // 1-9\n    return this.readNumber(false)\n\n  // Quotes produce strings.\n  case 34: case 39: // '\"', \"'\"\n    return this.readString(code)\n\n  // Operators are parsed inline in tiny state machines. '=' (61) is\n  // often referred to. `finishOp` simply skips the amount of\n  // characters it is given as second argument, and returns a token\n  // of the type given by its first argument.\n\n  case 47: // '/'\n    return this.readToken_slash()\n\n  case 37: case 42: // '%*'\n    return this.readToken_mult_modulo_exp(code)\n\n  case 124: case 38: // '|&'\n    return this.readToken_pipe_amp(code)\n\n  case 94: // '^'\n    return this.readToken_caret()\n\n  case 43: case 45: // '+-'\n    return this.readToken_plus_min(code)\n\n  case 60: case 62: // '<>'\n    return this.readToken_lt_gt(code)\n\n  case 61: case 33: // '=!'\n    return this.readToken_eq_excl(code)\n\n  case 63: // '?'\n    return this.readToken_question()\n\n  case 126: // '~'\n    return this.finishOp(types.prefix, 1)\n  }\n\n  this.raise(this.pos, \"Unexpected character '\" + codePointToString$1(code) + \"'\");\n};\n\npp$9.finishOp = function(type, size) {\n  var str = this.input.slice(this.pos, this.pos + size);\n  this.pos += size;\n  return this.finishToken(type, str)\n};\n\npp$9.readRegexp = function() {\n  var escaped, inClass, start = this.pos;\n  for (;;) {\n    if (this.pos >= this.input.length) { this.raise(start, \"Unterminated regular expression\"); }\n    var ch = this.input.charAt(this.pos);\n    if (lineBreak.test(ch)) { this.raise(start, \"Unterminated regular expression\"); }\n    if (!escaped) {\n      if (ch === \"[\") { inClass = true; }\n      else if (ch === \"]\" && inClass) { inClass = false; }\n      else if (ch === \"/\" && !inClass) { break }\n      escaped = ch === \"\\\\\";\n    } else { escaped = false; }\n    ++this.pos;\n  }\n  var pattern = this.input.slice(start, this.pos);\n  ++this.pos;\n  var flagsStart = this.pos;\n  var flags = this.readWord1();\n  if (this.containsEsc) { this.unexpected(flagsStart); }\n\n  // Validate pattern\n  var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));\n  state.reset(start, pattern, flags);\n  this.validateRegExpFlags(state);\n  this.validateRegExpPattern(state);\n\n  // Create Literal#value property value.\n  var value = null;\n  try {\n    value = new RegExp(pattern, flags);\n  } catch (e) {\n    // ESTree requires null if it failed to instantiate RegExp object.\n    // https://github.com/estree/estree/blob/a27003adf4fd7bfad44de9cef372a2eacd527b1c/es5.md#regexpliteral\n  }\n\n  return this.finishToken(types.regexp, {pattern: pattern, flags: flags, value: value})\n};\n\n// Read an integer in the given radix. Return null if zero digits\n// were read, the integer value otherwise. When `len` is given, this\n// will return `null` unless the integer has exactly `len` digits.\n\npp$9.readInt = function(radix, len) {\n  var start = this.pos, total = 0;\n  for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {\n    var code = this.input.charCodeAt(this.pos), val = (void 0);\n    if (code >= 97) { val = code - 97 + 10; } // a\n    else if (code >= 65) { val = code - 65 + 10; } // A\n    else if (code >= 48 && code <= 57) { val = code - 48; } // 0-9\n    else { val = Infinity; }\n    if (val >= radix) { break }\n    ++this.pos;\n    total = total * radix + val;\n  }\n  if (this.pos === start || len != null && this.pos - start !== len) { return null }\n\n  return total\n};\n\npp$9.readRadixNumber = function(radix) {\n  var start = this.pos;\n  this.pos += 2; // 0x\n  var val = this.readInt(radix);\n  if (val == null) { this.raise(this.start + 2, \"Expected number in radix \" + radix); }\n  if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {\n    val = typeof BigInt !== \"undefined\" ? BigInt(this.input.slice(start, this.pos)) : null;\n    ++this.pos;\n  } else if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, \"Identifier directly after number\"); }\n  return this.finishToken(types.num, val)\n};\n\n// Read an integer, octal integer, or floating-point number.\n\npp$9.readNumber = function(startsWithDot) {\n  var start = this.pos;\n  if (!startsWithDot && this.readInt(10) === null) { this.raise(start, \"Invalid number\"); }\n  var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;\n  if (octal && this.strict) { this.raise(start, \"Invalid number\"); }\n  var next = this.input.charCodeAt(this.pos);\n  if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {\n    var str$1 = this.input.slice(start, this.pos);\n    var val$1 = typeof BigInt !== \"undefined\" ? BigInt(str$1) : null;\n    ++this.pos;\n    if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, \"Identifier directly after number\"); }\n    return this.finishToken(types.num, val$1)\n  }\n  if (octal && /[89]/.test(this.input.slice(start, this.pos))) { octal = false; }\n  if (next === 46 && !octal) { // '.'\n    ++this.pos;\n    this.readInt(10);\n    next = this.input.charCodeAt(this.pos);\n  }\n  if ((next === 69 || next === 101) && !octal) { // 'eE'\n    next = this.input.charCodeAt(++this.pos);\n    if (next === 43 || next === 45) { ++this.pos; } // '+-'\n    if (this.readInt(10) === null) { this.raise(start, \"Invalid number\"); }\n  }\n  if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, \"Identifier directly after number\"); }\n\n  var str = this.input.slice(start, this.pos);\n  var val = octal ? parseInt(str, 8) : parseFloat(str);\n  return this.finishToken(types.num, val)\n};\n\n// Read a string value, interpreting backslash-escapes.\n\npp$9.readCodePoint = function() {\n  var ch = this.input.charCodeAt(this.pos), code;\n\n  if (ch === 123) { // '{'\n    if (this.options.ecmaVersion < 6) { this.unexpected(); }\n    var codePos = ++this.pos;\n    code = this.readHexChar(this.input.indexOf(\"}\", this.pos) - this.pos);\n    ++this.pos;\n    if (code > 0x10FFFF) { this.invalidStringToken(codePos, \"Code point out of bounds\"); }\n  } else {\n    code = this.readHexChar(4);\n  }\n  return code\n};\n\nfunction codePointToString$1(code) {\n  // UTF-16 Decoding\n  if (code <= 0xFFFF) { return String.fromCharCode(code) }\n  code -= 0x10000;\n  return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00)\n}\n\npp$9.readString = function(quote) {\n  var out = \"\", chunkStart = ++this.pos;\n  for (;;) {\n    if (this.pos >= this.input.length) { this.raise(this.start, \"Unterminated string constant\"); }\n    var ch = this.input.charCodeAt(this.pos);\n    if (ch === quote) { break }\n    if (ch === 92) { // '\\'\n      out += this.input.slice(chunkStart, this.pos);\n      out += this.readEscapedChar(false);\n      chunkStart = this.pos;\n    } else {\n      if (isNewLine(ch, this.options.ecmaVersion >= 10)) { this.raise(this.start, \"Unterminated string constant\"); }\n      ++this.pos;\n    }\n  }\n  out += this.input.slice(chunkStart, this.pos++);\n  return this.finishToken(types.string, out)\n};\n\n// Reads template string tokens.\n\nvar INVALID_TEMPLATE_ESCAPE_ERROR = {};\n\npp$9.tryReadTemplateToken = function() {\n  this.inTemplateElement = true;\n  try {\n    this.readTmplToken();\n  } catch (err) {\n    if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {\n      this.readInvalidTemplateToken();\n    } else {\n      throw err\n    }\n  }\n\n  this.inTemplateElement = false;\n};\n\npp$9.invalidStringToken = function(position, message) {\n  if (this.inTemplateElement && this.options.ecmaVersion >= 9) {\n    throw INVALID_TEMPLATE_ESCAPE_ERROR\n  } else {\n    this.raise(position, message);\n  }\n};\n\npp$9.readTmplToken = function() {\n  var out = \"\", chunkStart = this.pos;\n  for (;;) {\n    if (this.pos >= this.input.length) { this.raise(this.start, \"Unterminated template\"); }\n    var ch = this.input.charCodeAt(this.pos);\n    if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) { // '`', '${'\n      if (this.pos === this.start && (this.type === types.template || this.type === types.invalidTemplate)) {\n        if (ch === 36) {\n          this.pos += 2;\n          return this.finishToken(types.dollarBraceL)\n        } else {\n          ++this.pos;\n          return this.finishToken(types.backQuote)\n        }\n      }\n      out += this.input.slice(chunkStart, this.pos);\n      return this.finishToken(types.template, out)\n    }\n    if (ch === 92) { // '\\'\n      out += this.input.slice(chunkStart, this.pos);\n      out += this.readEscapedChar(true);\n      chunkStart = this.pos;\n    } else if (isNewLine(ch)) {\n      out += this.input.slice(chunkStart, this.pos);\n      ++this.pos;\n      switch (ch) {\n      case 13:\n        if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; }\n      case 10:\n        out += \"\\n\";\n        break\n      default:\n        out += String.fromCharCode(ch);\n        break\n      }\n      if (this.options.locations) {\n        ++this.curLine;\n        this.lineStart = this.pos;\n      }\n      chunkStart = this.pos;\n    } else {\n      ++this.pos;\n    }\n  }\n};\n\n// Reads a template token to search for the end, without validating any escape sequences\npp$9.readInvalidTemplateToken = function() {\n  for (; this.pos < this.input.length; this.pos++) {\n    switch (this.input[this.pos]) {\n    case \"\\\\\":\n      ++this.pos;\n      break\n\n    case \"$\":\n      if (this.input[this.pos + 1] !== \"{\") {\n        break\n      }\n    // falls through\n\n    case \"`\":\n      return this.finishToken(types.invalidTemplate, this.input.slice(this.start, this.pos))\n\n    // no default\n    }\n  }\n  this.raise(this.start, \"Unterminated template\");\n};\n\n// Used to read escaped characters\n\npp$9.readEscapedChar = function(inTemplate) {\n  var ch = this.input.charCodeAt(++this.pos);\n  ++this.pos;\n  switch (ch) {\n  case 110: return \"\\n\" // 'n' -> '\\n'\n  case 114: return \"\\r\" // 'r' -> '\\r'\n  case 120: return String.fromCharCode(this.readHexChar(2)) // 'x'\n  case 117: return codePointToString$1(this.readCodePoint()) // 'u'\n  case 116: return \"\\t\" // 't' -> '\\t'\n  case 98: return \"\\b\" // 'b' -> '\\b'\n  case 118: return \"\\u000b\" // 'v' -> '\\u000b'\n  case 102: return \"\\f\" // 'f' -> '\\f'\n  case 13: if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; } // '\\r\\n'\n  case 10: // ' \\n'\n    if (this.options.locations) { this.lineStart = this.pos; ++this.curLine; }\n    return \"\"\n  case 56:\n  case 57:\n    if (inTemplate) {\n      var codePos = this.pos - 1;\n\n      this.invalidStringToken(\n        codePos,\n        \"Invalid escape sequence in template string\"\n      );\n\n      return null\n    }\n  default:\n    if (ch >= 48 && ch <= 55) {\n      var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];\n      var octal = parseInt(octalStr, 8);\n      if (octal > 255) {\n        octalStr = octalStr.slice(0, -1);\n        octal = parseInt(octalStr, 8);\n      }\n      this.pos += octalStr.length - 1;\n      ch = this.input.charCodeAt(this.pos);\n      if ((octalStr !== \"0\" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {\n        this.invalidStringToken(\n          this.pos - 1 - octalStr.length,\n          inTemplate\n            ? \"Octal literal in template string\"\n            : \"Octal literal in strict mode\"\n        );\n      }\n      return String.fromCharCode(octal)\n    }\n    if (isNewLine(ch)) {\n      // Unicode new line characters after \\ get removed from output in both\n      // template literals and strings\n      return \"\"\n    }\n    return String.fromCharCode(ch)\n  }\n};\n\n// Used to read character escape sequences ('\\x', '\\u', '\\U').\n\npp$9.readHexChar = function(len) {\n  var codePos = this.pos;\n  var n = this.readInt(16, len);\n  if (n === null) { this.invalidStringToken(codePos, \"Bad character escape sequence\"); }\n  return n\n};\n\n// Read an identifier, and return it as a string. Sets `this.containsEsc`\n// to whether the word contained a '\\u' escape.\n//\n// Incrementally adds only escaped chars, adding other chunks as-is\n// as a micro-optimization.\n\npp$9.readWord1 = function() {\n  this.containsEsc = false;\n  var word = \"\", first = true, chunkStart = this.pos;\n  var astral = this.options.ecmaVersion >= 6;\n  while (this.pos < this.input.length) {\n    var ch = this.fullCharCodeAtPos();\n    if (isIdentifierChar(ch, astral)) {\n      this.pos += ch <= 0xffff ? 1 : 2;\n    } else if (ch === 92) { // \"\\\"\n      this.containsEsc = true;\n      word += this.input.slice(chunkStart, this.pos);\n      var escStart = this.pos;\n      if (this.input.charCodeAt(++this.pos) !== 117) // \"u\"\n        { this.invalidStringToken(this.pos, \"Expecting Unicode escape sequence \\\\uXXXX\"); }\n      ++this.pos;\n      var esc = this.readCodePoint();\n      if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral))\n        { this.invalidStringToken(escStart, \"Invalid Unicode escape\"); }\n      word += codePointToString$1(esc);\n      chunkStart = this.pos;\n    } else {\n      break\n    }\n    first = false;\n  }\n  return word + this.input.slice(chunkStart, this.pos)\n};\n\n// Read an identifier or keyword token. Will check for reserved\n// words when necessary.\n\npp$9.readWord = function() {\n  var word = this.readWord1();\n  var type = types.name;\n  if (this.keywords.test(word)) {\n    type = keywords$1[word];\n  }\n  return this.finishToken(type, word)\n};\n\n// Acorn is a tiny, fast JavaScript parser written in JavaScript.\n\nvar version = \"7.3.1\";\n\nParser.acorn = {\n  Parser: Parser,\n  version: version,\n  defaultOptions: defaultOptions,\n  Position: Position,\n  SourceLocation: SourceLocation,\n  getLineInfo: getLineInfo,\n  Node: Node,\n  TokenType: TokenType,\n  tokTypes: types,\n  keywordTypes: keywords$1,\n  TokContext: TokContext,\n  tokContexts: types$1,\n  isIdentifierChar: isIdentifierChar,\n  isIdentifierStart: isIdentifierStart,\n  Token: Token,\n  isNewLine: isNewLine,\n  lineBreak: lineBreak,\n  lineBreakG: lineBreakG,\n  nonASCIIwhitespace: nonASCIIwhitespace\n};\n\n// The main exported interface (under `self.acorn` when in the\n// browser) is a `parse` function that takes a code string and\n// returns an abstract syntax tree as specified by [Mozilla parser\n// API][api].\n//\n// [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API\n\nfunction parse(input, options) {\n  return Parser.parse(input, options)\n}\n\n// This function tries to parse a single expression at a given\n// offset in a string. Useful for parsing mixed-language formats\n// that embed JavaScript expressions.\n\nfunction parseExpressionAt(input, pos, options) {\n  return Parser.parseExpressionAt(input, pos, options)\n}\n\n// Acorn is organized as a tokenizer and a recursive-descent parser.\n// The `tokenizer` export provides an interface to the tokenizer.\n\nfunction tokenizer(input, options) {\n  return Parser.tokenizer(input, options)\n}\n\nexport { Node, Parser, Position, SourceLocation, TokContext, Token, TokenType, defaultOptions, getLineInfo, isIdentifierChar, isIdentifierStart, isNewLine, keywords$1 as keywordTypes, lineBreak, lineBreakG, nonASCIIwhitespace, parse, parseExpressionAt, types$1 as tokContexts, types as tokTypes, tokenizer, version };\n", "import * as Acorn from 'acorn';\nimport {\n  ArrayPattern,\n  ArrowFunctionExpression,\n  AssignmentPattern,\n  BinaryExpression,\n  BlockStatement,\n  CallExpression,\n  ClassDeclaration,\n  Function,\n  FunctionDeclaration,\n  FunctionExpression,\n  Identifier,\n  IfStatement,\n  Literal,\n  MemberExpression,\n  Node,\n  ObjectPattern,\n  Program,\n  Property,\n  RestElement,\n  SimpleLiteral,\n  ThisExpression,\n  TryStatement,\n  VariableDeclaration,\n} from 'estree';\n\nexport type NodeWithParent<TNode = Node> = TNode & {\n  parent: NodeWithParent | null;\n};\n\nexport interface StringLiteral extends SimpleLiteral {\n  value: string;\n}\n\nexport function isArrowFunctionExpression(node: Node): node is ArrowFunctionExpression {\n  return node.type === 'ArrowFunctionExpression';\n}\n\nexport function isArrayPattern(node: Node): node is ArrayPattern {\n  return node.type === 'ArrayPattern';\n}\n\nexport function isAssignmentPattern(node: Node): node is AssignmentPattern {\n  return node.type === 'AssignmentPattern';\n}\n\nexport function isBinaryExpression(node: Node): node is BinaryExpression {\n  return node.type === 'BinaryExpression';\n}\n\nexport function isBlockStatement(node: Node): node is BlockStatement {\n  return node.type === 'BlockStatement';\n}\n\nexport function isCallExpression(node: Node): node is CallExpression {\n  return node.type === 'CallExpression';\n}\n\nexport function isClassDeclaration(node: Node): node is ClassDeclaration {\n  return node.type === 'ClassDeclaration';\n}\n\nexport function isFunctionDeclaration(node: Node): node is FunctionDeclaration {\n  return node.type === 'FunctionDeclaration';\n}\n\nexport function isFunctionExpression(node: Node): node is FunctionExpression {\n  return node.type === 'FunctionExpression';\n}\n\nexport function isIdentifier(node: Node): node is Identifier {\n  return node.type === 'Identifier';\n}\n\nexport function isIfStatement(node: Node): node is IfStatement {\n  return node.type === 'IfStatement';\n}\n\nexport function isLiteral(node: Node): node is Literal {\n  return node.type === 'Literal';\n}\n\nexport function isMemberExpression(node: Node): node is MemberExpression {\n  return node.type === 'MemberExpression';\n}\n\nexport function isObjectPattern(node: Node): node is ObjectPattern {\n  return node.type === 'ObjectPattern';\n}\n\nexport function isProperty(node: Node): node is Property {\n  return node.type === 'Property';\n}\n\nexport function isRestElement(node: Node): node is RestElement {\n  return node.type === 'RestElement';\n}\n\nexport function isProgram(node: Node): node is Program {\n  return node.type === 'Program';\n}\n\nexport function isThisExpression(node: Node): node is ThisExpression {\n  return node.type === 'ThisExpression';\n}\n\nexport function isTryStatement(node: Node): node is TryStatement {\n  return node.type === 'TryStatement';\n}\n\nexport function isVariableDeclaration(node: Node): node is VariableDeclaration {\n  return node.type === 'VariableDeclaration';\n}\n\n// Refinements or groups\nexport function isFunction(node: Node): node is Function {\n  return (\n    isFunctionDeclaration(node) || isFunctionExpression(node) || isArrowFunctionExpression(node)\n  );\n}\n\nexport function isStringLiteral(node: Node): node is StringLiteral {\n  return isLiteral(node) && typeof node.value === 'string';\n}\n\nexport function parse(code: string, options?: acorn.Options) {\n  return (Acorn.parse(code, {\n    ...options,\n    allowReturnOutsideFunction: true,\n    sourceType: 'script',\n  }) as any) as Program;\n}\n", "import { Node } from 'estree';\nimport { NodeWithParent } from './ast';\n\ntype VisitorContext = {\n  skip(): void;\n};\n\ntype EnterFunction<TContext> = (\n  this: VisitorContext,\n  node: NodeWithParent,\n  parent: NodeWithParent | null,\n  ctx: TContext,\n  prop?: string,\n  index?: number\n) => void;\ntype LeaveFunction<TContext> = (\n  node: NodeWithParent,\n  parent: NodeWithParent | null,\n  ctx: TContext,\n  prop?: string,\n  index?: number\n) => void;\n\nexport type Visitor<TContext> = {\n  enter?: EnterFunction<TContext>;\n  leave?: LeaveFunction<TContext>;\n};\n\nexport function traverse<TContext>(ast: Node, ctx: TContext, { enter, leave }: Visitor<TContext>) {\n  visit(ast as NodeWithParent, null, ctx, enter, leave);\n}\n\nlet shouldSkip = false;\nconst context = { skip: () => (shouldSkip = true) };\n\nexport const childKeys: {\n  [key: string]: string[];\n} = {};\n\nfunction visit<TContext>(\n  node: NodeWithParent,\n  parent: NodeWithParent | null,\n  ctx: TContext,\n  enter?: EnterFunction<TContext>,\n  leave?: LeaveFunction<TContext>\n  // prop?: string,\n  // index?: number\n) {\n  if (!node) return;\n\n  node.parent = parent;\n\n  if (enter) {\n    const _shouldSkip = shouldSkip;\n    shouldSkip = false;\n    enter.call(context, node, parent, ctx);\n    const skipped = shouldSkip;\n    shouldSkip = _shouldSkip;\n\n    if (skipped) return;\n  }\n\n  const keys =\n    childKeys[node.type] ||\n    (childKeys[node.type] = Object.keys(node).filter(\n      (key) => key !== 'parent' && typeof (node as any)[key] === 'object'\n    ));\n\n  const children = [] as NodeWithParent[];\n\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    const value = (node as any)[key] as NodeWithParent | NodeWithParent[];\n\n    if (Array.isArray(value)) {\n      children.push(...value);\n      // for (let j = 0; j < value.length; j++) {\n      //   visit(value[j], node, ctx, enter, leave);\n      // }\n    } else if (value && value.type) {\n      children.push(value);\n    }\n  }\n\n  children.sort((a, b) => a.start - b.start);\n\n  for (const child of children) {\n    visit(child, node, ctx, enter, leave);\n  }\n\n  if (leave) {\n    leave(node, parent, ctx);\n  }\n}\n", "import { Uri } from '@velcro/common/src';\nimport type { BinaryOperator, Function, Identifier, MemberExpression, Node, Pattern } from 'estree';\nimport MagicString from 'magic-string';\nimport { ParserFunction } from '../parsing';\nimport { DEFAULT_SHIM_GLOBALS } from '../shims';\nimport { SourceModuleDependency } from '../sourceModuleDependency';\nimport {\n  isArrayPattern,\n  isArrowFunctionExpression,\n  isAssignmentPattern,\n  isBinaryExpression,\n  isBlockStatement,\n  isCallExpression,\n  isClassDeclaration,\n  isFunction,\n  isFunctionDeclaration,\n  isFunctionExpression,\n  isIdentifier,\n  isIfStatement,\n  isMemberExpression,\n  isObjectPattern,\n  isProgram,\n  isProperty,\n  isRestElement,\n  isStringLiteral,\n  isThisExpression,\n  isTryStatement,\n  isVariableDeclaration,\n  NodeWithParent,\n  parse as parseAst,\n} from './ast';\nimport { traverse, Visitor } from './traverse';\n\ndeclare module 'estree' {\n  export interface BaseNodeWithoutComments {\n    start: number;\n    end: number;\n  }\n}\n\nexport const parse = function parseJavaScript(\n  uri: Uri,\n  code: string,\n  options: {\n    globalModules: typeof DEFAULT_SHIM_GLOBALS;\n    nodeEnv: string;\n  }\n): ReturnType<ParserFunction> {\n  const visitorCtx: DependencyVisitorContext = {\n    unboundSymbols: new Map(),\n    locals: new Map(),\n    magicString: new MagicString(code, { filename: uri.toString(), indentExclusionRanges: [] }),\n    nodeEnv: options.nodeEnv,\n    replacedSymbols: new Set<Identifier>(),\n    requires: [],\n    requireResolves: [],\n    skip: new Set(),\n    skipTransform: new Set(),\n  };\n  const dependencies = [] as SourceModuleDependency[];\n\n  try {\n    // let lastToken: Token | undefined;\n    const ast = parseAst(code, {\n      // onComment: (_isBlock, _test, start, end) => {\n      //   result.changes.push({ type: 'remove', start, end });\n      // },\n      // onInsertedSemicolon(lastTokEnd) {\n      //   result.changes.push({ type: 'appendRight', position: lastTokEnd, value: ';' });\n      // },\n      // onToken: (token) => {\n      //   const start = lastToken ? lastToken.end + 1 : 0;\n      //   const end = token.start;\n      //   if (end > start) {\n      //     result.changes.push({ type: 'remove', start, end });\n      //   }\n      //   lastToken = token;\n      // },\n    });\n\n    traverse(ast, visitorCtx, scopingAndRequiresVisitor);\n    traverse(ast, visitorCtx, collectGlobalsVisitor);\n  } catch (err) {\n    // console.debug(code);\n    // console.trace(err);\n    throw new Error(`Error parsing ${uri}: ${err.message}`);\n  }\n\n  // Handle explicit requires\n  const requiresBySpec = new Map<string, Array<{ start: number; end: number }>>();\n  for (const requireDependency of visitorCtx.requires) {\n    let locations = requiresBySpec.get(requireDependency.spec.value);\n    if (!locations) {\n      locations = [];\n      requiresBySpec.set(requireDependency.spec.value, locations);\n    }\n\n    locations.push({ start: requireDependency.spec.start, end: requireDependency.spec.end });\n  }\n  for (const [spec, locations] of requiresBySpec) {\n    dependencies.push(SourceModuleDependency.fromRequire(spec, locations));\n  }\n\n  // Handle require.resolve\n  const requireResolvesBySpec = new Map<string, Array<{ start: number; end: number }>>();\n  for (const requireDependency of visitorCtx.requireResolves) {\n    let locations = requiresBySpec.get(requireDependency.spec.value);\n    if (!locations) {\n      locations = [];\n      requiresBySpec.set(requireDependency.spec.value, locations);\n    }\n\n    locations.push({ start: requireDependency.spec.start, end: requireDependency.spec.end });\n  }\n  for (const [spec, locations] of requireResolvesBySpec) {\n    dependencies.push(SourceModuleDependency.fromRequireResolve(spec, locations));\n  }\n\n  for (const [symbolName, locations] of visitorCtx.unboundSymbols) {\n    const shim = options.globalModules[symbolName];\n\n    if (shim) {\n      dependencies.push(SourceModuleDependency.fromGlobalObject(shim.spec, locations, shim.export));\n\n      for (const location of locations) {\n        visitorCtx.magicString.overwrite(\n          location.start,\n          location.end,\n          `require(${JSON.stringify(`${shim.spec}`)})`\n        );\n      }\n    }\n  }\n\n  return {\n    code: visitorCtx.magicString,\n    dependencies,\n  };\n};\n\nexport type CommonJsRequire = {\n  callee: { start: number; end: number };\n  spec: { start: number; end: number; value: string };\n};\n\nexport type CommonJsRequireResolve = {\n  callee: { start: number; end: number };\n  spec: { start: number; end: number; value: string };\n};\n\nexport type DependencyVisitorContext = {\n  readonly unboundSymbols: Map<string, Node[]>;\n  readonly locals: Map<Node, { [identifier: string]: boolean }>;\n  readonly magicString: MagicString;\n  readonly nodeEnv: string;\n  readonly requires: CommonJsRequire[];\n  readonly replacedSymbols: Set<Identifier>;\n  readonly requireResolves: CommonJsRequireResolve[];\n  readonly skip: Set<Node>;\n  readonly skipTransform: Set<Node>;\n};\n\nexport const scopingAndRequiresVisitor: Visitor<DependencyVisitorContext> = {\n  enter(node, parent, ctx) {\n    // Get AST-node level locations in the source map\n    ctx.magicString.addSourcemapLocation(node.start);\n    ctx.magicString.addSourcemapLocation(node.end);\n\n    if (ctx.skip.has(node)) {\n      return this.skip();\n    }\n\n    visitAndCaptureScoping(node, parent, ctx);\n    visitAndSkipBranches(node, parent, ctx);\n    visitRequires(node, parent, ctx);\n  },\n  leave(node, _parent, ctx) {\n    let skipped = false;\n    let nextCheck: NodeWithParent<Node> | undefined = node;\n\n    while (nextCheck) {\n      if (ctx.skipTransform.has(nextCheck)) {\n        skipped = true;\n        break;\n      }\n\n      nextCheck = nextCheck.parent as NodeWithParent<Node> | undefined;\n    }\n\n    if (\n      !skipped &&\n      isMemberExpression(node) &&\n      memberExpressionMatches(node, 'process.env.NODE_ENV')\n    ) {\n      ctx.magicString.overwrite(node.start, node.end, JSON.stringify(ctx.nodeEnv), {\n        contentOnly: true,\n        storeName: true,\n      });\n      ctx.skip.add(node);\n      ctx.skipTransform.add(node);\n    }\n  },\n};\n\nexport const collectGlobalsVisitor: Visitor<DependencyVisitorContext> = {\n  enter(node, _parent, ctx) {\n    if (ctx.skip.has(node)) {\n      return this.skip();\n    }\n\n    if (isBindingIdentifier(node) && isIdentifier(node)) {\n      var name = node.name;\n      if (name === 'undefined') return;\n      if (ctx.replacedSymbols.has(node)) {\n        return;\n      }\n\n      let foundBinding = false;\n      let nextParent = node.parent;\n\n      while (nextParent) {\n        if (name === 'arguments' && declaresArguments(nextParent)) {\n          foundBinding = true;\n          break;\n        }\n\n        const locals = ctx.locals.get(nextParent);\n\n        if (locals && locals[name]) {\n          foundBinding = true;\n          break;\n        }\n\n        nextParent = nextParent.parent;\n      }\n\n      if (!foundBinding) {\n        let unboundSymbols = ctx.unboundSymbols.get(name);\n        if (!unboundSymbols) {\n          unboundSymbols = [];\n          ctx.unboundSymbols.set(name, unboundSymbols);\n        }\n        unboundSymbols.push(node);\n      }\n    } else if (isThisExpression(node)) {\n      let foundBinding = false;\n      let nextParent = node.parent;\n\n      while (nextParent) {\n        if (declaresThis(nextParent)) {\n          foundBinding = true;\n          break;\n        }\n\n        nextParent = nextParent.parent;\n      }\n\n      if (!foundBinding) {\n        let unboundSymbols = ctx.unboundSymbols.get('this');\n        if (!unboundSymbols) {\n          unboundSymbols = [];\n          ctx.unboundSymbols.set('this', unboundSymbols);\n        }\n        unboundSymbols.push(node);\n      }\n    }\n  },\n};\n\nfunction visitAndCaptureScoping(\n  node: NodeWithParent,\n  _parent: NodeWithParent | null,\n  ctx: DependencyVisitorContext\n) {\n  if (isVariableDeclaration(node)) {\n    let parent: NodeWithParent | undefined;\n    let nextParent = node.parent;\n\n    while (nextParent) {\n      if (node.kind === 'var' ? isScope(nextParent) : isBlockScope(nextParent)) {\n        parent = nextParent;\n        break;\n      }\n\n      nextParent = nextParent.parent;\n    }\n\n    if (!parent) {\n      throw new Error(`Invariant violation: Failed to find a parent`);\n    }\n\n    let locals = ctx.locals.get(parent);\n\n    if (!locals) {\n      locals = {};\n      ctx.locals.set(parent, locals);\n    }\n\n    for (const declaration of node.declarations) {\n      declarePattern(declaration.id, locals);\n    }\n  } else if (isFunctionDeclaration(node)) {\n    let parent: NodeWithParent | undefined;\n    let nextParent = node.parent;\n\n    if (nextParent && nextParent.parent) {\n      nextParent = nextParent.parent;\n    }\n\n    while (nextParent) {\n      if (isScope(nextParent)) {\n        parent = nextParent;\n        break;\n      }\n\n      nextParent = nextParent.parent;\n    }\n\n    if (!parent) {\n      throw new Error(`Invariant violation: Failed to find a parent`);\n    }\n\n    let locals = ctx.locals.get(parent);\n\n    if (!locals) {\n      locals = {};\n      ctx.locals.set(parent, locals);\n    }\n\n    declareFunction(node, locals);\n  } else if (isFunction(node)) {\n    let locals = ctx.locals.get(node);\n\n    if (!locals) {\n      locals = {};\n      ctx.locals.set(node, locals);\n    }\n\n    declareFunction(node, locals);\n  } else if (isClassDeclaration(node) && node.id) {\n    let parent: NodeWithParent | undefined;\n    let nextParent = node.parent;\n\n    if (nextParent && nextParent.parent) {\n      nextParent = nextParent.parent;\n    }\n\n    while (nextParent) {\n      if (isScope(nextParent)) {\n        parent = nextParent;\n        break;\n      }\n\n      nextParent = nextParent.parent;\n    }\n\n    if (!parent) {\n      throw new Error(`Invariant violation: Failed to find a parent`);\n    }\n\n    let locals = ctx.locals.get(parent);\n\n    if (!locals) {\n      locals = {};\n      ctx.locals.set(parent, locals);\n    }\n\n    locals[node.id.name] = true;\n  } else if (isTryStatement(node)) {\n    if (node.handler) {\n      let locals = ctx.locals.get(node.handler);\n\n      if (!locals) {\n        locals = {};\n        ctx.locals.set(node.handler, locals);\n      }\n\n      if (node.handler.param) {\n        declarePattern(node.handler.param, locals);\n      }\n    }\n  }\n}\n\nfunction visitAndSkipBranches(\n  node: NodeWithParent,\n  _parent: NodeWithParent | null,\n  ctx: DependencyVisitorContext\n) {\n  if (isIfStatement(node) && isBinaryExpression(node.test)) {\n    const tests = {\n      '!=': (l: string, r: string) => l != r,\n      '!==': (l: string, r: string) => l !== r,\n      '==': (l: string, r: string) => l == r,\n      '===': (l: string, r: string) => l === r,\n    } as { [key in BinaryOperator]: (l: string, r: string) => boolean };\n    const test = tests[node.test.operator];\n\n    if (test) {\n      if (\n        isStringLiteral(node.test.left) &&\n        isMemberExpression(node.test.right) &&\n        memberExpressionMatches(node.test.right, 'process.env.NODE_ENV')\n      ) {\n        let rootObject = node.test.right;\n        while (isMemberExpression(rootObject.object)) {\n          rootObject = rootObject.object;\n        }\n        if (isIdentifier(rootObject.object)) {\n          ctx.replacedSymbols.add(rootObject.object);\n        }\n\n        ctx.skipTransform.add(node.test.right);\n\n        // if ('development' === process.env.NODE_ENV) {}\n\n        if (!test(node.test.left.value, ctx.nodeEnv)) {\n          ctx.skip.add(node.consequent);\n          // We can blow away the consequent\n          ctx.magicString.remove(\n            node.start,\n            node.alternate ? node.alternate.start : node.consequent.end\n          );\n        } else {\n          // We can blow away the test\n          ctx.magicString.remove(node.start, node.consequent.start - 1);\n\n          if (node.alternate) {\n            ctx.skip.add(node.alternate);\n            // We can blow away the alternate but we need to start and the end of the consequent + 1 char\n            ctx.magicString.remove(node.consequent.end + 1, node.alternate.end);\n          }\n        }\n      } else if (\n        isStringLiteral(node.test.right) &&\n        isMemberExpression(node.test.left) &&\n        memberExpressionMatches(node.test.left, 'process.env.NODE_ENV')\n      ) {\n        let rootObject = node.test.left;\n        while (isMemberExpression(rootObject.object)) {\n          rootObject = rootObject.object;\n        }\n        if (isIdentifier(rootObject.object)) {\n          ctx.replacedSymbols.add(rootObject.object);\n        }\n\n        ctx.skipTransform.add(node.test.left);\n\n        // if (process.env.NODE_ENV === 'development') {}\n\n        if (!test(node.test.right.value, ctx.nodeEnv)) {\n          ctx.skip.add(node.consequent);\n          // We can blow away the consequent\n          ctx.magicString.remove(\n            node.start,\n            node.alternate ? node.alternate.start : node.consequent.end\n          );\n        } else {\n          // We can blow away the test and the alternate\n          ctx.magicString.remove(node.start, node.consequent.start - 1);\n\n          if (node.alternate) {\n            ctx.skip.add(node.alternate);\n            // We can blow away the alternate but we need to start and the end of the consequent + 1 char\n            ctx.magicString.remove(node.consequent.end + 1, node.alternate.end);\n          }\n        }\n      }\n    }\n  }\n}\n\nfunction visitRequires(\n  node: NodeWithParent,\n  _parent: NodeWithParent | null,\n  ctx: DependencyVisitorContext\n) {\n  if (isCallExpression(node)) {\n    const callee = node.callee;\n    if (isIdentifier(callee) && callee.name === 'require') {\n      const firstArg = node.arguments[0];\n\n      if (isStringLiteral(firstArg)) {\n        ctx.requires.push({\n          spec: { start: firstArg.start, end: firstArg.end, value: firstArg.value },\n          callee: { start: callee.start, end: callee.end },\n        });\n      } else {\n        console.warn('Non string-literal first arg to require', firstArg);\n      }\n    } else if (\n      isMemberExpression(callee) &&\n      isIdentifier(callee.object) &&\n      callee.object.name === 'require' &&\n      isIdentifier(callee.property) &&\n      callee.property.name === 'resolve'\n    ) {\n      const firstArg = node.arguments[0];\n\n      if (isStringLiteral(firstArg)) {\n        ctx.requireResolves.push({\n          spec: { start: firstArg.start, end: firstArg.end, value: firstArg.value },\n          callee: { start: callee.start, end: callee.end },\n        });\n      } else {\n        console.warn('Non string-literal first arg to require.resolve', firstArg);\n      }\n    }\n  }\n}\n\nfunction declareFunction(node: Function, locals: { [name: string]: boolean }) {\n  node.params.forEach(function (node) {\n    declarePattern(node, locals);\n  });\n  if ((node as any).id) {\n    locals[(node as any).id.name] = true;\n  }\n}\n\nfunction declarePattern(node: Pattern, locals: { [name: string]: boolean }) {\n  if (isIdentifier(node)) {\n    locals[node.name] = true;\n  } else if (isObjectPattern(node)) {\n    node.properties.forEach((node) =>\n      isRestElement(node)\n        ? declarePattern(node.argument, locals)\n        : declarePattern(node.value, locals)\n    );\n  } else if (isArrayPattern(node)) {\n    node.elements.forEach((node) => node && declarePattern(node, locals));\n  } else if (isRestElement(node)) {\n    declarePattern(node.argument, locals);\n  } else if (isAssignmentPattern(node)) {\n    declarePattern(node.left, locals);\n  } else {\n    throw new Error(`Invariant violation: Unexpected pattern type: ${node.type}`);\n  }\n}\n\nfunction isBindingIdentifier(node: NodeWithParent) {\n  return isIdentifier(node) && !isPropertyOfMemberExpression(node) && !isKeyOfProperty(node);\n}\n\nfunction isKeyOfProperty(node: NodeWithParent) {\n  return node.parent && isProperty(node.parent) && node.parent.key === node;\n}\n\nfunction isPropertyOfMemberExpression(node: NodeWithParent) {\n  return node.parent && isMemberExpression(node.parent) && node.parent.object !== node;\n}\n\nfunction isScope(node: NodeWithParent) {\n  return (\n    isFunctionDeclaration(node) ||\n    isFunctionExpression(node) ||\n    isArrowFunctionExpression(node) ||\n    isProgram(node)\n  );\n}\n\nfunction isBlockScope(node: NodeWithParent) {\n  return isBlockStatement(node) || isScope(node);\n}\n\nfunction declaresArguments(node: NodeWithParent) {\n  return isFunctionDeclaration(node) || isFunctionExpression(node);\n}\n\nfunction declaresThis(node: NodeWithParent) {\n  return isFunctionDeclaration(node) || isFunctionExpression(node);\n}\n\nfunction memberExpressionMatches(node: MemberExpression, pattern: string) {\n  const memberParts = pattern.split('.');\n\n  if (memberParts.length < 2) {\n    return false;\n  }\n\n  const object = memberParts.shift();\n  const property = memberParts.shift();\n\n  for (let i = memberParts.length - 1; i >= 0; i--) {\n    if (!isIdentifier(node.property) || node.property.name !== memberParts[i]) {\n      return false;\n    }\n\n    if (!isMemberExpression(node.object)) {\n      return false;\n    }\n\n    node = node.object;\n  }\n\n  if (!isIdentifier(node.object) || !isIdentifier(node.property)) {\n    return false;\n  }\n\n  return node.object.name === object && node.property.name === property;\n}\n", "export { parse } from './parser';\n", "//@ts-check\n'use strict';\n\n/**\n * @param {import('./types').VelcroStaticRuntime} velcro\n * @returns {import('./runtimeInterface').VelcroRuntime}\n */\nexport function createRuntime(velcro) {\n  if (velcro.runtime) return velcro.runtime;\n\n  /**\n   * @constructor\n   * @param {Runtime} runtime\n   * @param {string} id\n   * @param {import('./types').VelcroImportMap} importMap\n   */\n  function Module(runtime, id, importMap) {\n    this.runtime = runtime;\n    this.id = id;\n    this.importMap = importMap;\n    this.module = { exports: {} };\n    this.require = runtime.createRequire(this);\n  }\n\n  /**\n   * @constructor\n   * @param {import('./types').VelcroStaticRuntime} velcro\n   */\n  function Runtime(velcro) {\n    /** @type {Required<import('./types').VelcroImportMap>} */\n    this.importMap = { imports: {}, scopes: {} };\n    this.defs = velcro.defs;\n    /** @type {Record<string, Module | undefined>} */\n    this.modules = Object.create(null);\n    this.root = new Module(this, 'velcro:/root', {});\n    this.require = this.createRequire(this.root);\n    /** @type {Record<string, Module[] | undefined>} */\n    this.dependents = Object.create(null);\n  }\n\n  Runtime.prototype.createRequire = createRequire;\n  Runtime.prototype.inject = inject;\n  Runtime.prototype.invalidate = invalidate;\n  Runtime.prototype.resolveSpecAgainstImportMap = resolveSpecAgainstImportMap;\n\n  /**\n   *\n   * @this {Runtime}\n   * @param {Module} fromModule\n   */\n  function createRequire(fromModule) {\n    var runtime = this;\n\n    /**\n     * @param {string} spec\n     */\n    function require(spec) {\n      var id = runtime.resolveSpecAgainstImportMap(spec, fromModule);\n\n      var module = runtime.modules[id];\n\n      if (!module) {\n        var moduleDefinition = runtime.defs[id];\n\n        if (!moduleDefinition) {\n          throw new Error(`Unable to locate module '${id}' from '${fromModule.id}`);\n        }\n\n        var factory = moduleDefinition[0];\n        var importMap = moduleDefinition[1];\n\n        module = new Module(runtime, id, importMap);\n        runtime.modules[id] = module;\n\n        var specParts = id.split('/');\n        var __filename = specParts.pop() || spec;\n        var __dirname = specParts.join('/');\n\n        factory.call(\n          module.module.exports,\n          module.module,\n          module.module.exports,\n          module.require.bind(module),\n          __dirname,\n          __filename\n        );\n      }\n\n      (runtime.dependents[id] = runtime.dependents[id] || []).push(fromModule);\n\n      return module.module.exports;\n    }\n\n    /**\n     * @param {string} _spec\n     */\n    function resolve(_spec) {\n      return '';\n    }\n\n    return Object.assign(require, {\n      resolve,\n    });\n  }\n\n  /**\n   * Inject a pre-existing module\n   *\n   * @template T\n   * @this {Runtime}\n   * @param {string} id Identifier of module\n   * @param {T} exports Value that represents the exported interface of the module\n   */\n  function inject(id, exports) {\n    var module = new Module(this, id, Object.create(null));\n\n    module.module.exports = exports;\n\n    this.modules[id] = module;\n\n    return module;\n  }\n\n  /**\n   *\n   * @this {Runtime}\n   * @param {string[]} invalidations\n   */\n  function invalidate(invalidations) {\n    var queue = invalidations.slice();\n\n    while (queue.length) {\n      var id = queue.shift();\n\n      //@ts-expect-error\n      var deleted = delete this.modules[id];\n\n      /** @type {Module[] | undefined} */\n      //@ts-expect-error\n      var dependents = this.dependents[id];\n\n      if (!Array.isArray(dependents)) continue;\n\n      for (var i = 0; i < dependents.length; i++) {\n        queue.push(dependents[i].id);\n      }\n    }\n  }\n\n  /**\n   *\n   * @this {Runtime}\n   * @param {string} spec\n   * @param {Module} module\n   * @private\n   */\n  function resolveSpecAgainstImportMap(spec, module) {\n    var importMap = module.importMap;\n\n    if (!importMap.scopes) {\n      return spec;\n    }\n\n    var scopesForId = importMap.scopes[module.id];\n\n    if (!scopesForId) {\n      return spec;\n    }\n\n    var mappedId = scopesForId[spec];\n\n    if (mappedId) {\n      return mappedId;\n    }\n\n    return spec;\n  }\n\n  var runtime = new Runtime(velcro);\n\n  velcro.runtime = runtime;\n\n  return runtime;\n}\n", "import { Uri } from '@velcro/common';\nimport { Bundle } from 'magic-string';\nimport { encode } from 'sourcemap-codec';\nimport { SourceMap } from './sourceMap';\nimport { ISourceMapper } from './sourceMapTree';\n\nexport class ChunkOutput {\n  private cachedCode?: string;\n  private cachedSourceMap?: SourceMap;\n  private cachedSourceMapDataUri?: string;\n  private cachedSourceMapString?: string;\n\n  constructor(\n    private readonly bundle: Bundle,\n    private readonly sourceMapTree: ISourceMapper,\n    readonly uri: Uri\n  ) {}\n\n  get code() {\n    if (typeof this.cachedCode === 'undefined') {\n      this.cachedCode = this.bundle.toString();\n    }\n\n    return this.cachedCode!;\n  }\n\n  get href() {\n    return this.uri.toString();\n  }\n\n  get sourceMap() {\n    if (typeof this.cachedSourceMap === 'undefined') {\n      this.cachedSourceMap = this.generateSourceMap();\n    }\n\n    return this.cachedSourceMap!;\n  }\n\n  get sourceMapString() {\n    if (typeof this.cachedSourceMapString === 'undefined') {\n      this.cachedSourceMapString = this.sourceMap.toString();\n    }\n\n    return this.cachedSourceMapString!;\n  }\n\n  get sourceMapDataUri() {\n    if (typeof this.cachedSourceMapDataUri === 'undefined') {\n      this.cachedSourceMapDataUri = this.sourceMap.toDataUri();\n    }\n\n    return this.cachedSourceMapDataUri!;\n  }\n\n  private generateSourceMap() {\n    const sourceMapTreeMappings = this.sourceMapTree.traceMappings();\n\n    if (sourceMapTreeMappings instanceof Error) {\n      return new SourceMap({\n        file: this.href,\n        mappings: '',\n        names: [],\n        sources: [],\n        version: 3,\n        sourcesContent: [],\n      });\n    }\n\n    // Loop through generated mappings, removing mappings that are character-by-character increments\n    // from the previous mapping. Since we generated a hires bundle, this will shrink the resolution\n    // back down to something not unnecessarily large.\n    // for (const line of sourceMapTreeMappings.mappings) {\n    //   let lastSegment: SourceMapSegment | null = null;\n    //   const shrinkedLine: SourceMapSegment[] = [];\n\n    //   for (const segment of line) {\n    //     if (lastSegment && lastSegment.length >= 4 && lastSegment.length === segment.length) {\n    //       // We will only push the segment if it is not, effectively a direct cursor move of the\n    //       // last one.\n    //       // For example:\n    //       //   lastSegment = [1, 0, 0, 1] // Generated column 1, original column 1 of the 0th file, 0th line\n    //       //   segment = [2, 0, 0, 2] // Generated column 2, original column 2 of the 0th file, 0th line\n    //       // Given that, we can see that this segment is not adding any _new_ information so we can skip it.\n    //       if (\n    //         lastSegment.length >= 4 &&\n    //         (lastSegment[0] + 1 !== segment[0] ||\n    //           lastSegment[1] !== segment[1] ||\n    //           lastSegment[2] !== segment[2] ||\n    //           lastSegment[3]! + 1 !== segment[3] ||\n    //           lastSegment[4] !== segment[4])\n    //       ) {\n    //         shrinkedLine.push(segment);\n    //       }\n    //     } else {\n    //       shrinkedLine.push(segment);\n    //     }\n\n    //     lastSegment = segment;\n    //   }\n\n    //   // line.splice(0, line.length, ...shrinkedLine);\n    // }\n\n    const sourceMap = new SourceMap({\n      file: this.href,\n      mappings: encode(sourceMapTreeMappings.mappings),\n      names: sourceMapTreeMappings.names,\n      sources: sourceMapTreeMappings.sources,\n      version: 3,\n      sourcesContent: sourceMapTreeMappings.sourcesContent,\n    });\n\n    return sourceMap;\n  }\n}\n", "import { MapSet, Uri } from '@velcro/common';\nimport { Bundle } from 'magic-string';\nimport { DependencyEdge } from '../graph/dependencyEdge';\nimport { SourceModule } from '../graph/sourceModule';\nimport { createRuntime } from '../runtime/runtime';\nimport { VelcroImportMap, VelcroStaticRuntime } from '../runtime/types';\nimport { ChunkOutput } from './chunkOutput';\nimport { LazyLink, Link, Source } from './sourceMapTree';\n\ntype NotUndefined<T> = T extends undefined ? never : T;\n\nexport class Chunk {\n  private readonly edgesFrom = new MapSet<string, DependencyEdge>();\n  private readonly edgesTo = new MapSet<string, DependencyEdge>();\n  //@ts-ignore\n  private readonly rootUri: Uri;\n  private readonly sourceModules = new Map<string, SourceModule>();\n\n  constructor(options: Chunk.Options) {\n    this.rootUri = options.rootUri;\n\n    for (const sourceModule of options.sourceModules) {\n      this.sourceModules.set(sourceModule.href, sourceModule);\n    }\n\n    for (const edge of options.edges) {\n      const fromHref = edge.fromUri.toString();\n      const toHref = edge.toUri.toString();\n\n      this.edgesFrom.add(fromHref, edge);\n      this.edgesTo.add(toHref, edge);\n    }\n  }\n\n  buildForStaticRuntime(options?: Chunk.ToStringOptions) {\n    // const velcroModuleFactoryParts = velcroModuleFactory\n    //   .toString()\n    //   .split(velcroModuleFactory.splitString);\n    // const velcroChunkWrapperParts = velcroChunkWrapper\n    //   .toString()\n    //   .split(velcroChunkWrapper.splitString);\n\n    const bundle = new Bundle({\n      separator: '\\n',\n    });\n\n    for (const sourceModule of this.sourceModules.values()) {\n      const moduleScopes: NotUndefined<NotUndefined<VelcroImportMap['scopes']>[string]> = {};\n      const scopes: NotUndefined<VelcroImportMap['scopes']> = {\n        [sourceModule.href]: moduleScopes,\n      };\n      const importMap: VelcroImportMap = { scopes };\n      const edgesFrom = this.edgesFrom.get(sourceModule.href);\n\n      if (edgesFrom) {\n        for (const edge of edgesFrom) {\n          moduleScopes[edge.dependency.spec] = edge.toUri.toString();\n        }\n      }\n      const sourceModuleCode = sourceModule.source.clone();\n\n      sourceModuleCode.prepend(\n        `velcro.defs[${JSON.stringify(\n          sourceModule.uri.toString()\n        )}] = [function(module,exports,require,__dirname,__filename){\\n`\n      );\n      sourceModuleCode.append(`\\n},${JSON.stringify(importMap)}];`);\n      bundle.addSource(sourceModuleCode);\n    }\n\n    const velcroStaticRuntime: VelcroStaticRuntime = { defs: {} };\n\n    bundle.prepend(`(function(velcro){\\n`);\n    bundle.prepend(\n      `if (typeof Velcro === 'undefined') Velcro = Object.create(null);\\nif (typeof Velcro.registry === 'undefined') Velcro.registry = ${JSON.stringify(\n        velcroStaticRuntime\n      )};\\n`\n    );\n    bundle.append(`\\n})(Velcro.registry);\\n`);\n\n    if (options && options.injectRuntime) {\n      bundle.append(`\\nVelcro.runtime = ${createRuntime.toString()}(Velcro.registry);\\n`);\n    }\n\n    if (options && options.invalidations) {\n      if (!options.injectRuntime) {\n        throw new Error(\n          'Setting injectRuntime to true is required when calling buildForStaticRuntime and specifying invalidations'\n        );\n      }\n\n      bundle.append(`\\nVelcro.runtime.invalidate(${JSON.stringify(options.invalidations)});\\n`);\n    }\n\n    const sourceMapTree = new LazyLink(() => {\n      const inputMap = bundle.generateDecodedMap({\n        includeContent: false,\n        hires: true,\n        source: this.rootUri.toString(),\n      });\n      return new Link(\n        inputMap,\n        inputMap.sources.map((sourceHref) => {\n          const sourceModule = this.sourceModules.get(sourceHref);\n\n          if (!sourceModule) {\n            return new Source(sourceHref, 'SOURCEMAP ERROR');\n          }\n\n          // All of the transformations included in the source module's magicString\n          // were baked into the bundle already. We just need to map these into any\n          // earlier sources.\n          return sourceModule.sourceMapsTree;\n        })\n      );\n    });\n\n    return new ChunkOutput(bundle, sourceMapTree, this.rootUri);\n  }\n}\n\nexport namespace Chunk {\n  export interface Options {\n    edges: Iterable<DependencyEdge>;\n    rootUri: Uri;\n    sourceModules: Iterable<SourceModule>;\n  }\n\n  export interface ToStringOptions {\n    /**\n     * Toggle whether to inject the runtime in the generated code.\n     *\n     * An instance of the runtime is important as it is what will actually schedule\n     * and execute code built for Velcro.\n     *\n     * When `injectRuntime` is `true`, the runtime code will be injected and the\n     * instance of it will be exposed as `Velcro.runtime`.\n     */\n    injectRuntime?: boolean;\n    invalidations?: string[];\n  }\n}\n", "import { MapSet, Uri } from '@velcro/common';\nimport { Chunk } from '../build/chunk';\nimport { DependencyEdge } from './dependencyEdge';\nimport { SourceModule } from './sourceModule';\n\nexport class Graph {\n  private readonly edgesFrom = new MapSet<string, DependencyEdge>();\n  private readonly edgesTo = new MapSet<string, DependencyEdge>();\n  //@ts-ignore\n  private readonly rootUri: Uri;\n  private readonly sourceModules = new Map<string, SourceModule>();\n\n  constructor(options: Graph.Options) {\n    this.rootUri = options.rootUri;\n\n    for (const sourceModule of options.sourceModules) {\n      this.sourceModules.set(sourceModule.href, sourceModule);\n    }\n\n    for (const edge of options.edges) {\n      const fromHref = edge.fromUri.toString();\n      const toHref = edge.toUri.toString();\n\n      this.edgesFrom.add(fromHref, edge);\n      this.edgesTo.add(toHref, edge);\n    }\n  }\n\n  splitChunks(): Iterable<Chunk> {\n    return [\n      new Chunk({\n        edges: this.edgesFrom.values(),\n        rootUri: Uri.joinPath(this.rootUri, './chunk/0.js'),\n        sourceModules: this.sourceModules.values(),\n      }),\n    ];\n  }\n}\n\nexport namespace Graph {\n  export interface Options {\n    edges: Iterable<DependencyEdge>;\n    rootUri: Uri;\n    sourceModules: Iterable<SourceModule>;\n  }\n}\n", "import { version as nodeLibsVersion } from '@velcro/node-libs/package.json';\n\nexport const DEFAULT_SHIM_GLOBALS: Record<\n  string,\n  { spec: string; export?: string } | undefined\n> = Object.assign(Object.create(null), {\n  Buffer: {\n    spec: `@velcro/node-libs@${nodeLibsVersion}/lib/buffer.js`,\n    export: 'Buffer',\n  },\n  global: {\n    spec: `@velcro/node-libs@${nodeLibsVersion}/lib/global.js`,\n  },\n  globalThis: {\n    spec: `@velcro/node-libs@${nodeLibsVersion}/lib/global.js`,\n  },\n  process: {\n    spec: `@velcro/node-libs@${nodeLibsVersion}/lib/process.js`,\n  },\n});\n", "import { Uri } from '@velcro/common';\nimport { ResolverContext } from '@velcro/resolver';\nimport MagicString from 'magic-string';\nimport { Link, Source } from '../build/sourceMapTree';\nimport { SourceModuleDependency } from './sourceModuleDependency';\n\nexport class SourceModule {\n  constructor(\n    readonly uri: Uri,\n    readonly rootUri: Uri,\n    readonly source: MagicString,\n    readonly dependencies: Set<SourceModuleDependency>,\n    readonly sourceMapsTree: Source | Link,\n    readonly visits: ResolverContext.Visit[]\n  ) {}\n\n  get href() {\n    return this.uri.toString();\n  }\n\n  get rootHref() {\n    return this.rootUri.toString();\n  }\n}\n", "import {\n  CancellationToken,\n  CancellationTokenSource,\n  DisposableStore,\n  Emitter,\n  Event,\n  isCanceledError,\n  MapSet,\n  Uri,\n} from '@velcro/common';\nimport { Resolver, ResolverContext } from '@velcro/resolver';\nimport { Plugin, PluginManager } from '../plugins';\nimport { parse } from './commonjs';\nimport { DependencyEdge } from './dependencyEdge';\nimport { Graph } from './graph';\nimport { DEFAULT_SHIM_GLOBALS } from './shims';\nimport { SourceModule } from './sourceModule';\nimport { SourceModuleDependency } from './sourceModuleDependency';\n\ntype ExternalTestFunction = (\n  dependency: SourceModuleDependency,\n  fromSourceModule: SourceModule\n) => boolean;\n\nexport class Build {\n  private readonly disposer = new DisposableStore();\n  private readonly edges = new Set<DependencyEdge>();\n  readonly errors: Error[] = [];\n  readonly seen = new Set<unknown>();\n  private readonly sourceModules = new Map<string, SourceModule>();\n\n  private readonly pendingModuleOperations = new MapSet<string, Promise<unknown>>();\n  private readonly tokenSource: CancellationTokenSource;\n\n  private readonly onCompletedEmitter = new Emitter<{ graph: Graph }>();\n  private readonly onErrorEmitter = new Emitter<{ error: Error }>();\n  private readonly onProgressEmitter = new Emitter<{\n    progress: {\n      completed: number;\n      pending: number;\n    };\n  }>();\n\n  readonly done = new Promise<Graph>((resolve, reject) => {\n    this.disposer.add(this.onCompleted(({ graph }) => resolve(graph)));\n    this.disposer.add(this.onError(({ error }) => reject(error)));\n  });\n\n  constructor(readonly rootUri: Uri, options: { token?: CancellationToken } = {}) {\n    this.tokenSource = new CancellationTokenSource(options.token);\n\n    this.disposer.add(this.tokenSource);\n    this.done.catch(() => {\n      // Prevent uncaught rejection\n    });\n  }\n\n  get onCompleted(): Event<{ graph: Graph }> {\n    return this.onCompletedEmitter.event;\n  }\n\n  get onError(): Event<{ error: Error }> {\n    return this.onErrorEmitter.event;\n  }\n\n  get onProgress(): Event<{\n    progress: {\n      completed: number;\n      pending: number;\n    };\n  }> {\n    return this.onProgressEmitter.event;\n  }\n\n  get token() {\n    return this.tokenSource.token;\n  }\n\n  addEdge(edge: DependencyEdge) {\n    this.edges.add(edge);\n  }\n\n  addSourceModule(sourceModule: SourceModule) {\n    this.sourceModules.set(sourceModule.href, sourceModule);\n  }\n\n  cancel() {\n    this.tokenSource.cancel();\n  }\n\n  dispose() {\n    this.cancel();\n    this.disposer.dispose();\n  }\n\n  hasSourceModule(href: string) {\n    return this.sourceModules.has(href);\n  }\n\n  runAsync(key: string, fn: () => Promise<unknown>): void {\n    if (this.token.isCancellationRequested) {\n      return;\n    }\n\n    const onError = (err: Error) => {\n      if (ret) {\n        this.pendingModuleOperations.delete(key, ret);\n      }\n      this.cancel();\n\n      if (!isCanceledError(err)) {\n        this.errors.push(err);\n\n        this.onErrorEmitter.fire({ error: err });\n      }\n    };\n    const onSuccess = () => {\n      this.pendingModuleOperations.delete(key, ret);\n\n      if (!this.pendingModuleOperations.size) {\n        this.onCompletedEmitter.fire({\n          graph: new Graph({\n            edges: this.edges,\n            rootUri: this.rootUri,\n            sourceModules: this.sourceModules.values(),\n          }),\n        });\n      } else {\n        this.onProgressEmitter.fire({\n          progress: {\n            completed: this.sourceModules.size,\n            pending: this.pendingModuleOperations.size,\n          },\n        });\n      }\n    };\n\n    let ret: ReturnType<typeof fn>;\n\n    try {\n      ret = fn().then(onSuccess, onError);\n      this.pendingModuleOperations.add(key, ret);\n    } catch (err) {\n      onError(err);\n    }\n  }\n}\n\nexport class GraphBuilder {\n  private readonly edgesByDependency = new WeakMap<SourceModuleDependency, DependencyEdge>();\n  private readonly edgesByInvalidation = new MapSet<string, DependencyEdge>();\n  private readonly external?: ExternalTestFunction;\n  private readonly nodeEnv: string;\n  private readonly resolver: Resolver;\n  private readonly pluginManager: PluginManager;\n  private readonly sourceModules = new Map<string, SourceModule>();\n  private readonly sourceModulesByInvalidation = new MapSet<string, SourceModule>();\n\n  constructor(options: GraphBuilder.Options) {\n    this.resolver = options.resolver;\n    this.external = options.external;\n    this.nodeEnv = options.nodeEnv || 'development';\n    this.pluginManager = new PluginManager(options.plugins || []);\n  }\n\n  private loadDependency(build: Build, sourceModule: SourceModule, dep: SourceModuleDependency) {\n    if (build.seen.has(dep)) return;\n    build.seen.add(dep);\n\n    if (this.external && this.external(dep, sourceModule)) {\n      return;\n    }\n\n    // console.debug('loadDependency(%s, %s)', sourceModule.href, dep.spec);\n\n    build.runAsync(`${sourceModule.href}|${dep.spec}`, async () => {\n      const result = await this.pluginManager.executeResolveDependency(\n        {\n          nodeEnv: this.nodeEnv,\n          resolver: this.resolver,\n          token: build.token,\n        },\n        dep,\n        sourceModule\n      );\n      const edge = this.createEdge(\n        sourceModule.uri,\n        sourceModule.rootUri,\n        result.uri,\n        result.rootUri,\n        result.visited,\n        dep\n      );\n\n      build.addEdge(edge);\n\n      this.loadEdge(build, edge);\n    });\n  }\n\n  private loadEdge(build: Build, edge: DependencyEdge) {\n    const href = edge.toUri.toString();\n\n    if (build.hasSourceModule(href)) return;\n\n    const existingSourceModule = this.sourceModules.get(href);\n\n    if (existingSourceModule) {\n      build.addSourceModule(existingSourceModule);\n\n      return this.visitSourceModule(build, existingSourceModule);\n    }\n\n    // console.debug(\n    //   'loadEdge(%s, %s, %s)',\n    //   edge.fromUri.toString(),\n    //   edge.dependency.spec,\n    //   edge.toUri.toString()\n    // );\n\n    build.runAsync(href, async () => {\n      // We need to check again in case another 'thread' already produced this\n      // sourceModule\n      if (build.hasSourceModule(href)) return;\n\n      const loadResult = await this.pluginManager.executeLoad(\n        {\n          nodeEnv: this.nodeEnv,\n          resolver: this.resolver,\n          token: build.token,\n        },\n        edge.toUri\n      );\n\n      // We need to check again in case another 'thread' already produced this\n      // sourceModule\n      if (build.hasSourceModule(href)) return;\n\n      const transformResult = await this.pluginManager.executeTransform(\n        {\n          nodeEnv: this.nodeEnv,\n          resolver: this.resolver,\n          token: build.token,\n        },\n        edge.toUri,\n        loadResult.code\n      );\n\n      // We need to check again in case another 'thread' already produced this\n      // sourceModule\n      if (build.hasSourceModule(href)) return;\n\n      const parseResult = parse(edge.toUri, transformResult.code, {\n        globalModules: DEFAULT_SHIM_GLOBALS,\n        nodeEnv: this.nodeEnv,\n      });\n      const sourceModule = new SourceModule(\n        edge.toUri,\n        edge.toRootUri,\n        parseResult.code,\n        new Set(parseResult.dependencies),\n        transformResult.sourceMapTree,\n        [...transformResult.visited, ...loadResult.visited]\n      );\n\n      build.addSourceModule(sourceModule);\n      this.sourceModules.set(sourceModule.href, sourceModule);\n\n      for (const visit of sourceModule.visits) {\n        this.sourceModulesByInvalidation.add(visit.uri.toString(), sourceModule);\n      }\n\n      this.sourceModulesByInvalidation.add(sourceModule.href, sourceModule);\n\n      this.visitSourceModule(build, sourceModule);\n    });\n  }\n\n  private loadEntrypoint(build: Build, uri: Uri) {\n    const href = uri.toString();\n\n    // console.debug('loadEntrypoint(%s)', href);\n    build.runAsync(href, async () => {\n      const result = await this.pluginManager.executeResolveEntrypoint(\n        {\n          nodeEnv: this.nodeEnv,\n          resolver: this.resolver,\n          token: build.token,\n        },\n        uri\n      );\n      const edge = this.createEdge(\n        build.rootUri,\n        build.rootUri,\n        result.uri,\n        result.rootUri,\n        result.visited,\n        SourceModuleDependency.fromEntrypoint(uri)\n      );\n\n      this.loadEdge(build, edge);\n    });\n  }\n\n  private visitSourceModule(build: Build, sourceModule: SourceModule) {\n    if (build.seen.has(sourceModule)) return;\n    build.seen.add(sourceModule);\n\n    // console.debug('visitSourceModule(%s)', sourceModule.href);\n    for (const dep of sourceModule.dependencies) {\n      const existingEdge = this.edgesByDependency.get(dep);\n\n      if (existingEdge) {\n        build.addEdge(existingEdge);\n\n        this.loadEdge(build, existingEdge);\n      } else {\n        this.loadDependency(build, sourceModule, dep);\n      }\n    }\n  }\n\n  build(\n    entrypoints: (string | Uri)[],\n    options: { incremental?: boolean; token?: CancellationToken } = {}\n  ) {\n    const rootUri = Uri.parse('velcro:/');\n    const build = new Build(rootUri, { token: options.token });\n\n    for (const uri of entrypoints) {\n      this.loadEntrypoint(build, Uri.isUri(uri) ? uri : Uri.parse(uri));\n    }\n\n    return build;\n  }\n\n  invalidate(uri: Uri | string) {\n    const href = Uri.isUri(uri) ? uri.toString() : uri;\n    const sourceModules = this.sourceModulesByInvalidation.get(href);\n\n    if (sourceModules) {\n      for (const sourceModule of sourceModules) {\n        this.sourceModules.delete(sourceModule.href);\n      }\n      this.sourceModulesByInvalidation.deleteAll(href);\n    }\n\n    this.sourceModules.delete(href);\n\n    const edges = this.edgesByInvalidation.get(href);\n\n    if (edges) {\n      for (const edge of edges) {\n        this.edgesByDependency.delete(edge.dependency);\n      }\n      this.edgesByInvalidation.deleteAll(href);\n    }\n\n    this.resolver.invalidate(uri);\n  }\n\n  private createEdge(\n    fromUri: Uri,\n    fromRootUri: Uri,\n    toUri: Uri,\n    toRootUri: Uri,\n    visited: ResolverContext.Visit[],\n    dependency: SourceModuleDependency\n  ) {\n    const edge = { dependency, fromUri, fromRootUri, toUri, toRootUri, visited };\n\n    this.edgesByDependency.set(dependency, edge);\n\n    this.edgesByInvalidation.add(toUri.toString(), edge);\n    for (const visit of visited) {\n      this.edgesByInvalidation.add(visit.uri.toString(), edge);\n    }\n\n    return edge;\n  }\n}\n\nexport namespace GraphBuilder {\n  export interface Options {\n    external?: ExternalTestFunction;\n    nodeEnv?: string;\n    plugins?: Plugin[];\n    resolver: Resolver;\n  }\n}\n", "export * from './errors';\nexport type { Graph } from './graph';\nexport * from './graphBuilder';\nexport type { SourceModule } from './sourceModule';\nexport type { SourceModuleDependency } from './sourceModuleDependency';\n", "export const version = '__VERSION__';\nexport type { Chunk } from './build/chunk';\nexport type { ChunkOutput } from './build/chunkOutput';\nexport * from './graph';\nexport type {\n  Plugin,\n  PluginLoadContext,\n  PluginLoadResult,\n  PluginTransformContext,\n  PluginTransformResult,\n} from './plugins';\nexport type { VelcroRuntime } from './runtime';\n", "import type { Plugin } from '@velcro/bundler';\n\nexport function cssPlugin(): Plugin {\n  return {\n    name: 'cssPlugin',\n    transform(ctx, uri, code) {\n      if (!uri.path.endsWith('.css')) {\n        return;\n      }\n\n      const cssCode = code;\n      const magicString = ctx.createMagicString();\n      const BACKSLASH = '\\\\'.charCodeAt(0);\n      const SINGLE_QUOTE = \"'\".charCodeAt(0);\n      const NL = '\\n'.charCodeAt(0);\n      const CR = '\\r'.charCodeAt(0);\n\n      for (let i = 0; i < cssCode.length; i++) {\n        const char = cssCode.charCodeAt(i);\n        // Escape certain characters (if not already escaped)\n        switch (char) {\n          case CR:\n          case NL:\n            // Break the resulting JavaScript string across new lines\n            // so that original css lines have a 1:1 with JavaScript lines.\n            // This allows the resulting source-map to correct show the\n            // original source whereas if the source had been collapsed to\n            // a JavaScript string on a single line, all the detail is lost.\n            magicString.overwrite(i, i + 1, \"',\\n'\");\n            break;\n          case BACKSLASH:\n          case SINGLE_QUOTE:\n            magicString.prependRight(i, '\\\\');\n            break;\n        }\n      }\n\n      magicString.prepend(`\n        function reload(){\n          var styleTag = document.createElement(\"style\");\n          styleTag.type = \"text/css\";\n          styleTag.innerHTML = ['`);\n      magicString.append(`'].join('\\\\n');\n          document.head.appendChild(styleTag);\n          return {\n            dispose: function() {    \n              if (styleTag && styleTag.parentElement) {\n                styleTag.parentElement.removeChild(styleTag);\n              }\n            },\n            element: styleTag\n          };\n        };\n        var result = reload();\n        module.exports = result.element;\n        if (module.hot && module.hot.dispose) {\n          module.hot.dispose(function() {\n            result.dispose();\n          });\n        }\n      `);\n\n      return {\n        code: magicString.toString(),\n        sourceMap: magicString.generateDecodedMap(),\n      };\n    },\n  };\n}\n", "export const version = '__VERSION__';\nexport * from './css';\n", "export var ContextualKeyword; (function (ContextualKeyword) {\n  const NONE = 0; ContextualKeyword[ContextualKeyword[\"NONE\"] = NONE] = \"NONE\";\n  const _abstract = NONE + 1; ContextualKeyword[ContextualKeyword[\"_abstract\"] = _abstract] = \"_abstract\";\n  const _as = _abstract + 1; ContextualKeyword[ContextualKeyword[\"_as\"] = _as] = \"_as\";\n  const _asserts = _as + 1; ContextualKeyword[ContextualKeyword[\"_asserts\"] = _asserts] = \"_asserts\";\n  const _async = _asserts + 1; ContextualKeyword[ContextualKeyword[\"_async\"] = _async] = \"_async\";\n  const _await = _async + 1; ContextualKeyword[ContextualKeyword[\"_await\"] = _await] = \"_await\";\n  const _checks = _await + 1; ContextualKeyword[ContextualKeyword[\"_checks\"] = _checks] = \"_checks\";\n  const _constructor = _checks + 1; ContextualKeyword[ContextualKeyword[\"_constructor\"] = _constructor] = \"_constructor\";\n  const _declare = _constructor + 1; ContextualKeyword[ContextualKeyword[\"_declare\"] = _declare] = \"_declare\";\n  const _enum = _declare + 1; ContextualKeyword[ContextualKeyword[\"_enum\"] = _enum] = \"_enum\";\n  const _exports = _enum + 1; ContextualKeyword[ContextualKeyword[\"_exports\"] = _exports] = \"_exports\";\n  const _from = _exports + 1; ContextualKeyword[ContextualKeyword[\"_from\"] = _from] = \"_from\";\n  const _get = _from + 1; ContextualKeyword[ContextualKeyword[\"_get\"] = _get] = \"_get\";\n  const _global = _get + 1; ContextualKeyword[ContextualKeyword[\"_global\"] = _global] = \"_global\";\n  const _implements = _global + 1; ContextualKeyword[ContextualKeyword[\"_implements\"] = _implements] = \"_implements\";\n  const _infer = _implements + 1; ContextualKeyword[ContextualKeyword[\"_infer\"] = _infer] = \"_infer\";\n  const _interface = _infer + 1; ContextualKeyword[ContextualKeyword[\"_interface\"] = _interface] = \"_interface\";\n  const _is = _interface + 1; ContextualKeyword[ContextualKeyword[\"_is\"] = _is] = \"_is\";\n  const _keyof = _is + 1; ContextualKeyword[ContextualKeyword[\"_keyof\"] = _keyof] = \"_keyof\";\n  const _mixins = _keyof + 1; ContextualKeyword[ContextualKeyword[\"_mixins\"] = _mixins] = \"_mixins\";\n  const _module = _mixins + 1; ContextualKeyword[ContextualKeyword[\"_module\"] = _module] = \"_module\";\n  const _namespace = _module + 1; ContextualKeyword[ContextualKeyword[\"_namespace\"] = _namespace] = \"_namespace\";\n  const _of = _namespace + 1; ContextualKeyword[ContextualKeyword[\"_of\"] = _of] = \"_of\";\n  const _opaque = _of + 1; ContextualKeyword[ContextualKeyword[\"_opaque\"] = _opaque] = \"_opaque\";\n  const _private = _opaque + 1; ContextualKeyword[ContextualKeyword[\"_private\"] = _private] = \"_private\";\n  const _protected = _private + 1; ContextualKeyword[ContextualKeyword[\"_protected\"] = _protected] = \"_protected\";\n  const _proto = _protected + 1; ContextualKeyword[ContextualKeyword[\"_proto\"] = _proto] = \"_proto\";\n  const _public = _proto + 1; ContextualKeyword[ContextualKeyword[\"_public\"] = _public] = \"_public\";\n  const _readonly = _public + 1; ContextualKeyword[ContextualKeyword[\"_readonly\"] = _readonly] = \"_readonly\";\n  const _require = _readonly + 1; ContextualKeyword[ContextualKeyword[\"_require\"] = _require] = \"_require\";\n  const _set = _require + 1; ContextualKeyword[ContextualKeyword[\"_set\"] = _set] = \"_set\";\n  const _static = _set + 1; ContextualKeyword[ContextualKeyword[\"_static\"] = _static] = \"_static\";\n  const _type = _static + 1; ContextualKeyword[ContextualKeyword[\"_type\"] = _type] = \"_type\";\n  const _unique = _type + 1; ContextualKeyword[ContextualKeyword[\"_unique\"] = _unique] = \"_unique\";\n})(ContextualKeyword || (ContextualKeyword = {}));\n", "// Generated file, do not edit! Run \"yarn generate\" to re-generate this file.\n/**\n * Enum of all token types, with bit fields to signify meaningful properties.\n */\nexport var TokenType; (function (TokenType) {\n  // Precedence 0 means not an operator; otherwise it is a positive number up to 12.\n  const PRECEDENCE_MASK = 0xf; TokenType[TokenType[\"PRECEDENCE_MASK\"] = PRECEDENCE_MASK] = \"PRECEDENCE_MASK\";\n  const IS_KEYWORD = 1 << 4; TokenType[TokenType[\"IS_KEYWORD\"] = IS_KEYWORD] = \"IS_KEYWORD\";\n  const IS_ASSIGN = 1 << 5; TokenType[TokenType[\"IS_ASSIGN\"] = IS_ASSIGN] = \"IS_ASSIGN\";\n  const IS_RIGHT_ASSOCIATIVE = 1 << 6; TokenType[TokenType[\"IS_RIGHT_ASSOCIATIVE\"] = IS_RIGHT_ASSOCIATIVE] = \"IS_RIGHT_ASSOCIATIVE\";\n  const IS_PREFIX = 1 << 7; TokenType[TokenType[\"IS_PREFIX\"] = IS_PREFIX] = \"IS_PREFIX\";\n  const IS_POSTFIX = 1 << 8; TokenType[TokenType[\"IS_POSTFIX\"] = IS_POSTFIX] = \"IS_POSTFIX\";\n\n  const num = 0; TokenType[TokenType[\"num\"] = num] = \"num\"; // num\n  const bigint = 512; TokenType[TokenType[\"bigint\"] = bigint] = \"bigint\"; // bigint\n  const regexp = 1024; TokenType[TokenType[\"regexp\"] = regexp] = \"regexp\"; // regexp\n  const string = 1536; TokenType[TokenType[\"string\"] = string] = \"string\"; // string\n  const name = 2048; TokenType[TokenType[\"name\"] = name] = \"name\"; // name\n  const eof = 2560; TokenType[TokenType[\"eof\"] = eof] = \"eof\"; // eof\n  const bracketL = 3072; TokenType[TokenType[\"bracketL\"] = bracketL] = \"bracketL\"; // [\n  const bracketR = 3584; TokenType[TokenType[\"bracketR\"] = bracketR] = \"bracketR\"; // ]\n  const braceL = 4096; TokenType[TokenType[\"braceL\"] = braceL] = \"braceL\"; // {\n  const braceBarL = 4608; TokenType[TokenType[\"braceBarL\"] = braceBarL] = \"braceBarL\"; // {|\n  const braceR = 5120; TokenType[TokenType[\"braceR\"] = braceR] = \"braceR\"; // }\n  const braceBarR = 5632; TokenType[TokenType[\"braceBarR\"] = braceBarR] = \"braceBarR\"; // |}\n  const parenL = 6144; TokenType[TokenType[\"parenL\"] = parenL] = \"parenL\"; // (\n  const parenR = 6656; TokenType[TokenType[\"parenR\"] = parenR] = \"parenR\"; // )\n  const comma = 7168; TokenType[TokenType[\"comma\"] = comma] = \"comma\"; // ,\n  const semi = 7680; TokenType[TokenType[\"semi\"] = semi] = \"semi\"; // ;\n  const colon = 8192; TokenType[TokenType[\"colon\"] = colon] = \"colon\"; // :\n  const doubleColon = 8704; TokenType[TokenType[\"doubleColon\"] = doubleColon] = \"doubleColon\"; // ::\n  const dot = 9216; TokenType[TokenType[\"dot\"] = dot] = \"dot\"; // .\n  const question = 9728; TokenType[TokenType[\"question\"] = question] = \"question\"; // ?\n  const questionDot = 10240; TokenType[TokenType[\"questionDot\"] = questionDot] = \"questionDot\"; // ?.\n  const arrow = 10752; TokenType[TokenType[\"arrow\"] = arrow] = \"arrow\"; // =>\n  const template = 11264; TokenType[TokenType[\"template\"] = template] = \"template\"; // template\n  const ellipsis = 11776; TokenType[TokenType[\"ellipsis\"] = ellipsis] = \"ellipsis\"; // ...\n  const backQuote = 12288; TokenType[TokenType[\"backQuote\"] = backQuote] = \"backQuote\"; // `\n  const dollarBraceL = 12800; TokenType[TokenType[\"dollarBraceL\"] = dollarBraceL] = \"dollarBraceL\"; // ${\n  const at = 13312; TokenType[TokenType[\"at\"] = at] = \"at\"; // @\n  const hash = 13824; TokenType[TokenType[\"hash\"] = hash] = \"hash\"; // #\n  const eq = 14368; TokenType[TokenType[\"eq\"] = eq] = \"eq\"; // = isAssign\n  const assign = 14880; TokenType[TokenType[\"assign\"] = assign] = \"assign\"; // _= isAssign\n  const preIncDec = 15744; TokenType[TokenType[\"preIncDec\"] = preIncDec] = \"preIncDec\"; // ++/-- prefix postfix\n  const postIncDec = 16256; TokenType[TokenType[\"postIncDec\"] = postIncDec] = \"postIncDec\"; // ++/-- prefix postfix\n  const bang = 16512; TokenType[TokenType[\"bang\"] = bang] = \"bang\"; // ! prefix\n  const tilde = 17024; TokenType[TokenType[\"tilde\"] = tilde] = \"tilde\"; // ~ prefix\n  const pipeline = 17409; TokenType[TokenType[\"pipeline\"] = pipeline] = \"pipeline\"; // |> prec:1\n  const nullishCoalescing = 17922; TokenType[TokenType[\"nullishCoalescing\"] = nullishCoalescing] = \"nullishCoalescing\"; // ?? prec:2\n  const logicalOR = 18434; TokenType[TokenType[\"logicalOR\"] = logicalOR] = \"logicalOR\"; // || prec:2\n  const logicalAND = 18947; TokenType[TokenType[\"logicalAND\"] = logicalAND] = \"logicalAND\"; // && prec:3\n  const bitwiseOR = 19460; TokenType[TokenType[\"bitwiseOR\"] = bitwiseOR] = \"bitwiseOR\"; // | prec:4\n  const bitwiseXOR = 19973; TokenType[TokenType[\"bitwiseXOR\"] = bitwiseXOR] = \"bitwiseXOR\"; // ^ prec:5\n  const bitwiseAND = 20486; TokenType[TokenType[\"bitwiseAND\"] = bitwiseAND] = \"bitwiseAND\"; // & prec:6\n  const equality = 20999; TokenType[TokenType[\"equality\"] = equality] = \"equality\"; // ==/!= prec:7\n  const lessThan = 21512; TokenType[TokenType[\"lessThan\"] = lessThan] = \"lessThan\"; // < prec:8\n  const greaterThan = 22024; TokenType[TokenType[\"greaterThan\"] = greaterThan] = \"greaterThan\"; // > prec:8\n  const relationalOrEqual = 22536; TokenType[TokenType[\"relationalOrEqual\"] = relationalOrEqual] = \"relationalOrEqual\"; // <=/>= prec:8\n  const bitShift = 23049; TokenType[TokenType[\"bitShift\"] = bitShift] = \"bitShift\"; // <</>> prec:9\n  const plus = 23690; TokenType[TokenType[\"plus\"] = plus] = \"plus\"; // + prec:10 prefix\n  const minus = 24202; TokenType[TokenType[\"minus\"] = minus] = \"minus\"; // - prec:10 prefix\n  const modulo = 24587; TokenType[TokenType[\"modulo\"] = modulo] = \"modulo\"; // % prec:11\n  const star = 25099; TokenType[TokenType[\"star\"] = star] = \"star\"; // * prec:11\n  const slash = 25611; TokenType[TokenType[\"slash\"] = slash] = \"slash\"; // / prec:11\n  const exponent = 26188; TokenType[TokenType[\"exponent\"] = exponent] = \"exponent\"; // ** prec:12 rightAssociative\n  const jsxName = 26624; TokenType[TokenType[\"jsxName\"] = jsxName] = \"jsxName\"; // jsxName\n  const jsxText = 27136; TokenType[TokenType[\"jsxText\"] = jsxText] = \"jsxText\"; // jsxText\n  const jsxTagStart = 27648; TokenType[TokenType[\"jsxTagStart\"] = jsxTagStart] = \"jsxTagStart\"; // jsxTagStart\n  const jsxTagEnd = 28160; TokenType[TokenType[\"jsxTagEnd\"] = jsxTagEnd] = \"jsxTagEnd\"; // jsxTagEnd\n  const typeParameterStart = 28672; TokenType[TokenType[\"typeParameterStart\"] = typeParameterStart] = \"typeParameterStart\"; // typeParameterStart\n  const nonNullAssertion = 29184; TokenType[TokenType[\"nonNullAssertion\"] = nonNullAssertion] = \"nonNullAssertion\"; // nonNullAssertion\n  const _break = 29712; TokenType[TokenType[\"_break\"] = _break] = \"_break\"; // break keyword\n  const _case = 30224; TokenType[TokenType[\"_case\"] = _case] = \"_case\"; // case keyword\n  const _catch = 30736; TokenType[TokenType[\"_catch\"] = _catch] = \"_catch\"; // catch keyword\n  const _continue = 31248; TokenType[TokenType[\"_continue\"] = _continue] = \"_continue\"; // continue keyword\n  const _debugger = 31760; TokenType[TokenType[\"_debugger\"] = _debugger] = \"_debugger\"; // debugger keyword\n  const _default = 32272; TokenType[TokenType[\"_default\"] = _default] = \"_default\"; // default keyword\n  const _do = 32784; TokenType[TokenType[\"_do\"] = _do] = \"_do\"; // do keyword\n  const _else = 33296; TokenType[TokenType[\"_else\"] = _else] = \"_else\"; // else keyword\n  const _finally = 33808; TokenType[TokenType[\"_finally\"] = _finally] = \"_finally\"; // finally keyword\n  const _for = 34320; TokenType[TokenType[\"_for\"] = _for] = \"_for\"; // for keyword\n  const _function = 34832; TokenType[TokenType[\"_function\"] = _function] = \"_function\"; // function keyword\n  const _if = 35344; TokenType[TokenType[\"_if\"] = _if] = \"_if\"; // if keyword\n  const _return = 35856; TokenType[TokenType[\"_return\"] = _return] = \"_return\"; // return keyword\n  const _switch = 36368; TokenType[TokenType[\"_switch\"] = _switch] = \"_switch\"; // switch keyword\n  const _throw = 37008; TokenType[TokenType[\"_throw\"] = _throw] = \"_throw\"; // throw keyword prefix\n  const _try = 37392; TokenType[TokenType[\"_try\"] = _try] = \"_try\"; // try keyword\n  const _var = 37904; TokenType[TokenType[\"_var\"] = _var] = \"_var\"; // var keyword\n  const _let = 38416; TokenType[TokenType[\"_let\"] = _let] = \"_let\"; // let keyword\n  const _const = 38928; TokenType[TokenType[\"_const\"] = _const] = \"_const\"; // const keyword\n  const _while = 39440; TokenType[TokenType[\"_while\"] = _while] = \"_while\"; // while keyword\n  const _with = 39952; TokenType[TokenType[\"_with\"] = _with] = \"_with\"; // with keyword\n  const _new = 40464; TokenType[TokenType[\"_new\"] = _new] = \"_new\"; // new keyword\n  const _this = 40976; TokenType[TokenType[\"_this\"] = _this] = \"_this\"; // this keyword\n  const _super = 41488; TokenType[TokenType[\"_super\"] = _super] = \"_super\"; // super keyword\n  const _class = 42000; TokenType[TokenType[\"_class\"] = _class] = \"_class\"; // class keyword\n  const _extends = 42512; TokenType[TokenType[\"_extends\"] = _extends] = \"_extends\"; // extends keyword\n  const _export = 43024; TokenType[TokenType[\"_export\"] = _export] = \"_export\"; // export keyword\n  const _import = 43536; TokenType[TokenType[\"_import\"] = _import] = \"_import\"; // import keyword\n  const _yield = 44048; TokenType[TokenType[\"_yield\"] = _yield] = \"_yield\"; // yield keyword\n  const _null = 44560; TokenType[TokenType[\"_null\"] = _null] = \"_null\"; // null keyword\n  const _true = 45072; TokenType[TokenType[\"_true\"] = _true] = \"_true\"; // true keyword\n  const _false = 45584; TokenType[TokenType[\"_false\"] = _false] = \"_false\"; // false keyword\n  const _in = 46104; TokenType[TokenType[\"_in\"] = _in] = \"_in\"; // in prec:8 keyword\n  const _instanceof = 46616; TokenType[TokenType[\"_instanceof\"] = _instanceof] = \"_instanceof\"; // instanceof prec:8 keyword\n  const _typeof = 47248; TokenType[TokenType[\"_typeof\"] = _typeof] = \"_typeof\"; // typeof keyword prefix\n  const _void = 47760; TokenType[TokenType[\"_void\"] = _void] = \"_void\"; // void keyword prefix\n  const _delete = 48272; TokenType[TokenType[\"_delete\"] = _delete] = \"_delete\"; // delete keyword prefix\n  const _async = 48656; TokenType[TokenType[\"_async\"] = _async] = \"_async\"; // async keyword\n  const _get = 49168; TokenType[TokenType[\"_get\"] = _get] = \"_get\"; // get keyword\n  const _set = 49680; TokenType[TokenType[\"_set\"] = _set] = \"_set\"; // set keyword\n  const _declare = 50192; TokenType[TokenType[\"_declare\"] = _declare] = \"_declare\"; // declare keyword\n  const _readonly = 50704; TokenType[TokenType[\"_readonly\"] = _readonly] = \"_readonly\"; // readonly keyword\n  const _abstract = 51216; TokenType[TokenType[\"_abstract\"] = _abstract] = \"_abstract\"; // abstract keyword\n  const _static = 51728; TokenType[TokenType[\"_static\"] = _static] = \"_static\"; // static keyword\n  const _public = 52240; TokenType[TokenType[\"_public\"] = _public] = \"_public\"; // public keyword\n  const _private = 52752; TokenType[TokenType[\"_private\"] = _private] = \"_private\"; // private keyword\n  const _protected = 53264; TokenType[TokenType[\"_protected\"] = _protected] = \"_protected\"; // protected keyword\n  const _as = 53776; TokenType[TokenType[\"_as\"] = _as] = \"_as\"; // as keyword\n  const _enum = 54288; TokenType[TokenType[\"_enum\"] = _enum] = \"_enum\"; // enum keyword\n  const _type = 54800; TokenType[TokenType[\"_type\"] = _type] = \"_type\"; // type keyword\n  const _implements = 55312; TokenType[TokenType[\"_implements\"] = _implements] = \"_implements\"; // implements keyword\n})(TokenType || (TokenType = {}));\nexport function formatTokenType(tokenType) {\n  switch (tokenType) {\n    case TokenType.num:\n      return \"num\";\n    case TokenType.bigint:\n      return \"bigint\";\n    case TokenType.regexp:\n      return \"regexp\";\n    case TokenType.string:\n      return \"string\";\n    case TokenType.name:\n      return \"name\";\n    case TokenType.eof:\n      return \"eof\";\n    case TokenType.bracketL:\n      return \"[\";\n    case TokenType.bracketR:\n      return \"]\";\n    case TokenType.braceL:\n      return \"{\";\n    case TokenType.braceBarL:\n      return \"{|\";\n    case TokenType.braceR:\n      return \"}\";\n    case TokenType.braceBarR:\n      return \"|}\";\n    case TokenType.parenL:\n      return \"(\";\n    case TokenType.parenR:\n      return \")\";\n    case TokenType.comma:\n      return \",\";\n    case TokenType.semi:\n      return \";\";\n    case TokenType.colon:\n      return \":\";\n    case TokenType.doubleColon:\n      return \"::\";\n    case TokenType.dot:\n      return \".\";\n    case TokenType.question:\n      return \"?\";\n    case TokenType.questionDot:\n      return \"?.\";\n    case TokenType.arrow:\n      return \"=>\";\n    case TokenType.template:\n      return \"template\";\n    case TokenType.ellipsis:\n      return \"...\";\n    case TokenType.backQuote:\n      return \"`\";\n    case TokenType.dollarBraceL:\n      return \"${\";\n    case TokenType.at:\n      return \"@\";\n    case TokenType.hash:\n      return \"#\";\n    case TokenType.eq:\n      return \"=\";\n    case TokenType.assign:\n      return \"_=\";\n    case TokenType.preIncDec:\n      return \"++/--\";\n    case TokenType.postIncDec:\n      return \"++/--\";\n    case TokenType.bang:\n      return \"!\";\n    case TokenType.tilde:\n      return \"~\";\n    case TokenType.pipeline:\n      return \"|>\";\n    case TokenType.nullishCoalescing:\n      return \"??\";\n    case TokenType.logicalOR:\n      return \"||\";\n    case TokenType.logicalAND:\n      return \"&&\";\n    case TokenType.bitwiseOR:\n      return \"|\";\n    case TokenType.bitwiseXOR:\n      return \"^\";\n    case TokenType.bitwiseAND:\n      return \"&\";\n    case TokenType.equality:\n      return \"==/!=\";\n    case TokenType.lessThan:\n      return \"<\";\n    case TokenType.greaterThan:\n      return \">\";\n    case TokenType.relationalOrEqual:\n      return \"<=/>=\";\n    case TokenType.bitShift:\n      return \"<</>>\";\n    case TokenType.plus:\n      return \"+\";\n    case TokenType.minus:\n      return \"-\";\n    case TokenType.modulo:\n      return \"%\";\n    case TokenType.star:\n      return \"*\";\n    case TokenType.slash:\n      return \"/\";\n    case TokenType.exponent:\n      return \"**\";\n    case TokenType.jsxName:\n      return \"jsxName\";\n    case TokenType.jsxText:\n      return \"jsxText\";\n    case TokenType.jsxTagStart:\n      return \"jsxTagStart\";\n    case TokenType.jsxTagEnd:\n      return \"jsxTagEnd\";\n    case TokenType.typeParameterStart:\n      return \"typeParameterStart\";\n    case TokenType.nonNullAssertion:\n      return \"nonNullAssertion\";\n    case TokenType._break:\n      return \"break\";\n    case TokenType._case:\n      return \"case\";\n    case TokenType._catch:\n      return \"catch\";\n    case TokenType._continue:\n      return \"continue\";\n    case TokenType._debugger:\n      return \"debugger\";\n    case TokenType._default:\n      return \"default\";\n    case TokenType._do:\n      return \"do\";\n    case TokenType._else:\n      return \"else\";\n    case TokenType._finally:\n      return \"finally\";\n    case TokenType._for:\n      return \"for\";\n    case TokenType._function:\n      return \"function\";\n    case TokenType._if:\n      return \"if\";\n    case TokenType._return:\n      return \"return\";\n    case TokenType._switch:\n      return \"switch\";\n    case TokenType._throw:\n      return \"throw\";\n    case TokenType._try:\n      return \"try\";\n    case TokenType._var:\n      return \"var\";\n    case TokenType._let:\n      return \"let\";\n    case TokenType._const:\n      return \"const\";\n    case TokenType._while:\n      return \"while\";\n    case TokenType._with:\n      return \"with\";\n    case TokenType._new:\n      return \"new\";\n    case TokenType._this:\n      return \"this\";\n    case TokenType._super:\n      return \"super\";\n    case TokenType._class:\n      return \"class\";\n    case TokenType._extends:\n      return \"extends\";\n    case TokenType._export:\n      return \"export\";\n    case TokenType._import:\n      return \"import\";\n    case TokenType._yield:\n      return \"yield\";\n    case TokenType._null:\n      return \"null\";\n    case TokenType._true:\n      return \"true\";\n    case TokenType._false:\n      return \"false\";\n    case TokenType._in:\n      return \"in\";\n    case TokenType._instanceof:\n      return \"instanceof\";\n    case TokenType._typeof:\n      return \"typeof\";\n    case TokenType._void:\n      return \"void\";\n    case TokenType._delete:\n      return \"delete\";\n    case TokenType._async:\n      return \"async\";\n    case TokenType._get:\n      return \"get\";\n    case TokenType._set:\n      return \"set\";\n    case TokenType._declare:\n      return \"declare\";\n    case TokenType._readonly:\n      return \"readonly\";\n    case TokenType._abstract:\n      return \"abstract\";\n    case TokenType._static:\n      return \"static\";\n    case TokenType._public:\n      return \"public\";\n    case TokenType._private:\n      return \"private\";\n    case TokenType._protected:\n      return \"protected\";\n    case TokenType._as:\n      return \"as\";\n    case TokenType._enum:\n      return \"enum\";\n    case TokenType._type:\n      return \"type\";\n    case TokenType._implements:\n      return \"implements\";\n    default:\n      return \"\";\n  }\n}\n", "\nimport {ContextualKeyword} from \"./keywords\";\nimport { TokenType as tt} from \"./types\";\n\nexport class Scope {\n  \n  \n  \n\n  constructor(startTokenIndex, endTokenIndex, isFunctionScope) {\n    this.startTokenIndex = startTokenIndex;\n    this.endTokenIndex = endTokenIndex;\n    this.isFunctionScope = isFunctionScope;\n  }\n}\n\nexport class StateSnapshot {\n  constructor(\n     potentialArrowAt,\n     noAnonFunctionType,\n     tokensLength,\n     scopesLength,\n     pos,\n     type,\n     contextualKeyword,\n     start,\n     end,\n     isType,\n     scopeDepth,\n     error,\n  ) {;this.potentialArrowAt = potentialArrowAt;this.noAnonFunctionType = noAnonFunctionType;this.tokensLength = tokensLength;this.scopesLength = scopesLength;this.pos = pos;this.type = type;this.contextualKeyword = contextualKeyword;this.start = start;this.end = end;this.isType = isType;this.scopeDepth = scopeDepth;this.error = error;}\n}\n\nexport default class State {constructor() { State.prototype.__init.call(this);State.prototype.__init2.call(this);State.prototype.__init3.call(this);State.prototype.__init4.call(this);State.prototype.__init5.call(this);State.prototype.__init6.call(this);State.prototype.__init7.call(this);State.prototype.__init8.call(this);State.prototype.__init9.call(this);State.prototype.__init10.call(this);State.prototype.__init11.call(this);State.prototype.__init12.call(this); }\n  // Used to signify the start of a potential arrow function\n  __init() {this.potentialArrowAt = -1}\n\n  // Used by Flow to handle an edge case involving function type parsing.\n  __init2() {this.noAnonFunctionType = false}\n\n  // Token store.\n  __init3() {this.tokens = []}\n\n  // Array of all observed scopes, ordered by their ending position.\n  __init4() {this.scopes = []}\n\n  // The current position of the tokenizer in the input.\n  __init5() {this.pos = 0}\n\n  // Information about the current token.\n  __init6() {this.type = tt.eof}\n  __init7() {this.contextualKeyword = ContextualKeyword.NONE}\n  __init8() {this.start = 0}\n  __init9() {this.end = 0}\n\n  __init10() {this.isType = false}\n  __init11() {this.scopeDepth = 0}\n\n  /**\n   * If the parser is in an error state, then the token is always tt.eof and all functions can\n   * keep executing but should be written so they don't get into an infinite loop in this situation.\n   *\n   * This approach, combined with the ability to snapshot and restore state, allows us to implement\n   * backtracking without exceptions and without needing to explicitly propagate error states\n   * everywhere.\n   */\n  __init12() {this.error = null}\n\n  snapshot() {\n    return new StateSnapshot(\n      this.potentialArrowAt,\n      this.noAnonFunctionType,\n      this.tokens.length,\n      this.scopes.length,\n      this.pos,\n      this.type,\n      this.contextualKeyword,\n      this.start,\n      this.end,\n      this.isType,\n      this.scopeDepth,\n      this.error,\n    );\n  }\n\n  restoreFromSnapshot(snapshot) {\n    this.potentialArrowAt = snapshot.potentialArrowAt;\n    this.noAnonFunctionType = snapshot.noAnonFunctionType;\n    this.tokens.length = snapshot.tokensLength;\n    this.scopes.length = snapshot.scopesLength;\n    this.pos = snapshot.pos;\n    this.type = snapshot.type;\n    this.contextualKeyword = snapshot.contextualKeyword;\n    this.start = snapshot.start;\n    this.end = snapshot.end;\n    this.isType = snapshot.isType;\n    this.scopeDepth = snapshot.scopeDepth;\n    this.error = snapshot.error;\n  }\n}\n", "export var charCodes; (function (charCodes) {\n  const backSpace = 8; charCodes[charCodes[\"backSpace\"] = backSpace] = \"backSpace\";\n  const lineFeed = 10; charCodes[charCodes[\"lineFeed\"] = lineFeed] = \"lineFeed\"; //  '\\n'\n  const carriageReturn = 13; charCodes[charCodes[\"carriageReturn\"] = carriageReturn] = \"carriageReturn\"; //  '\\r'\n  const shiftOut = 14; charCodes[charCodes[\"shiftOut\"] = shiftOut] = \"shiftOut\";\n  const space = 32; charCodes[charCodes[\"space\"] = space] = \"space\";\n  const exclamationMark = 33; charCodes[charCodes[\"exclamationMark\"] = exclamationMark] = \"exclamationMark\"; //  '!'\n  const quotationMark = 34; charCodes[charCodes[\"quotationMark\"] = quotationMark] = \"quotationMark\"; //  '\"'\n  const numberSign = 35; charCodes[charCodes[\"numberSign\"] = numberSign] = \"numberSign\"; //  '#'\n  const dollarSign = 36; charCodes[charCodes[\"dollarSign\"] = dollarSign] = \"dollarSign\"; //  '$'\n  const percentSign = 37; charCodes[charCodes[\"percentSign\"] = percentSign] = \"percentSign\"; //  '%'\n  const ampersand = 38; charCodes[charCodes[\"ampersand\"] = ampersand] = \"ampersand\"; //  '&'\n  const apostrophe = 39; charCodes[charCodes[\"apostrophe\"] = apostrophe] = \"apostrophe\"; //  '''\n  const leftParenthesis = 40; charCodes[charCodes[\"leftParenthesis\"] = leftParenthesis] = \"leftParenthesis\"; //  '('\n  const rightParenthesis = 41; charCodes[charCodes[\"rightParenthesis\"] = rightParenthesis] = \"rightParenthesis\"; //  ')'\n  const asterisk = 42; charCodes[charCodes[\"asterisk\"] = asterisk] = \"asterisk\"; //  '*'\n  const plusSign = 43; charCodes[charCodes[\"plusSign\"] = plusSign] = \"plusSign\"; //  '+'\n  const comma = 44; charCodes[charCodes[\"comma\"] = comma] = \"comma\"; //  ','\n  const dash = 45; charCodes[charCodes[\"dash\"] = dash] = \"dash\"; //  '-'\n  const dot = 46; charCodes[charCodes[\"dot\"] = dot] = \"dot\"; //  '.'\n  const slash = 47; charCodes[charCodes[\"slash\"] = slash] = \"slash\"; //  '/'\n  const digit0 = 48; charCodes[charCodes[\"digit0\"] = digit0] = \"digit0\"; //  '0'\n  const digit1 = 49; charCodes[charCodes[\"digit1\"] = digit1] = \"digit1\"; //  '1'\n  const digit2 = 50; charCodes[charCodes[\"digit2\"] = digit2] = \"digit2\"; //  '2'\n  const digit3 = 51; charCodes[charCodes[\"digit3\"] = digit3] = \"digit3\"; //  '3'\n  const digit4 = 52; charCodes[charCodes[\"digit4\"] = digit4] = \"digit4\"; //  '4'\n  const digit5 = 53; charCodes[charCodes[\"digit5\"] = digit5] = \"digit5\"; //  '5'\n  const digit6 = 54; charCodes[charCodes[\"digit6\"] = digit6] = \"digit6\"; //  '6'\n  const digit7 = 55; charCodes[charCodes[\"digit7\"] = digit7] = \"digit7\"; //  '7'\n  const digit8 = 56; charCodes[charCodes[\"digit8\"] = digit8] = \"digit8\"; //  '8'\n  const digit9 = 57; charCodes[charCodes[\"digit9\"] = digit9] = \"digit9\"; //  '9'\n  const colon = 58; charCodes[charCodes[\"colon\"] = colon] = \"colon\"; //  ':'\n  const semicolon = 59; charCodes[charCodes[\"semicolon\"] = semicolon] = \"semicolon\"; //  ';'\n  const lessThan = 60; charCodes[charCodes[\"lessThan\"] = lessThan] = \"lessThan\"; //  '<'\n  const equalsTo = 61; charCodes[charCodes[\"equalsTo\"] = equalsTo] = \"equalsTo\"; //  '='\n  const greaterThan = 62; charCodes[charCodes[\"greaterThan\"] = greaterThan] = \"greaterThan\"; //  '>'\n  const questionMark = 63; charCodes[charCodes[\"questionMark\"] = questionMark] = \"questionMark\"; //  '?'\n  const atSign = 64; charCodes[charCodes[\"atSign\"] = atSign] = \"atSign\"; //  '@'\n  const uppercaseA = 65; charCodes[charCodes[\"uppercaseA\"] = uppercaseA] = \"uppercaseA\"; //  'A'\n  const uppercaseB = 66; charCodes[charCodes[\"uppercaseB\"] = uppercaseB] = \"uppercaseB\"; //  'B'\n  const uppercaseC = 67; charCodes[charCodes[\"uppercaseC\"] = uppercaseC] = \"uppercaseC\"; //  'C'\n  const uppercaseD = 68; charCodes[charCodes[\"uppercaseD\"] = uppercaseD] = \"uppercaseD\"; //  'D'\n  const uppercaseE = 69; charCodes[charCodes[\"uppercaseE\"] = uppercaseE] = \"uppercaseE\"; //  'E'\n  const uppercaseF = 70; charCodes[charCodes[\"uppercaseF\"] = uppercaseF] = \"uppercaseF\"; //  'F'\n  const uppercaseG = 71; charCodes[charCodes[\"uppercaseG\"] = uppercaseG] = \"uppercaseG\"; //  'G'\n  const uppercaseH = 72; charCodes[charCodes[\"uppercaseH\"] = uppercaseH] = \"uppercaseH\"; //  'H'\n  const uppercaseI = 73; charCodes[charCodes[\"uppercaseI\"] = uppercaseI] = \"uppercaseI\"; //  'I'\n  const uppercaseJ = 74; charCodes[charCodes[\"uppercaseJ\"] = uppercaseJ] = \"uppercaseJ\"; //  'J'\n  const uppercaseK = 75; charCodes[charCodes[\"uppercaseK\"] = uppercaseK] = \"uppercaseK\"; //  'K'\n  const uppercaseL = 76; charCodes[charCodes[\"uppercaseL\"] = uppercaseL] = \"uppercaseL\"; //  'L'\n  const uppercaseM = 77; charCodes[charCodes[\"uppercaseM\"] = uppercaseM] = \"uppercaseM\"; //  'M'\n  const uppercaseN = 78; charCodes[charCodes[\"uppercaseN\"] = uppercaseN] = \"uppercaseN\"; //  'N'\n  const uppercaseO = 79; charCodes[charCodes[\"uppercaseO\"] = uppercaseO] = \"uppercaseO\"; //  'O'\n  const uppercaseP = 80; charCodes[charCodes[\"uppercaseP\"] = uppercaseP] = \"uppercaseP\"; //  'P'\n  const uppercaseQ = 81; charCodes[charCodes[\"uppercaseQ\"] = uppercaseQ] = \"uppercaseQ\"; //  'Q'\n  const uppercaseR = 82; charCodes[charCodes[\"uppercaseR\"] = uppercaseR] = \"uppercaseR\"; //  'R'\n  const uppercaseS = 83; charCodes[charCodes[\"uppercaseS\"] = uppercaseS] = \"uppercaseS\"; //  'S'\n  const uppercaseT = 84; charCodes[charCodes[\"uppercaseT\"] = uppercaseT] = \"uppercaseT\"; //  'T'\n  const uppercaseU = 85; charCodes[charCodes[\"uppercaseU\"] = uppercaseU] = \"uppercaseU\"; //  'U'\n  const uppercaseV = 86; charCodes[charCodes[\"uppercaseV\"] = uppercaseV] = \"uppercaseV\"; //  'V'\n  const uppercaseW = 87; charCodes[charCodes[\"uppercaseW\"] = uppercaseW] = \"uppercaseW\"; //  'W'\n  const uppercaseX = 88; charCodes[charCodes[\"uppercaseX\"] = uppercaseX] = \"uppercaseX\"; //  'X'\n  const uppercaseY = 89; charCodes[charCodes[\"uppercaseY\"] = uppercaseY] = \"uppercaseY\"; //  'Y'\n  const uppercaseZ = 90; charCodes[charCodes[\"uppercaseZ\"] = uppercaseZ] = \"uppercaseZ\"; //  'Z'\n  const leftSquareBracket = 91; charCodes[charCodes[\"leftSquareBracket\"] = leftSquareBracket] = \"leftSquareBracket\"; //  '['\n  const backslash = 92; charCodes[charCodes[\"backslash\"] = backslash] = \"backslash\"; //  '\\    '\n  const rightSquareBracket = 93; charCodes[charCodes[\"rightSquareBracket\"] = rightSquareBracket] = \"rightSquareBracket\"; //  ']'\n  const caret = 94; charCodes[charCodes[\"caret\"] = caret] = \"caret\"; //  '^'\n  const underscore = 95; charCodes[charCodes[\"underscore\"] = underscore] = \"underscore\"; //  '_'\n  const graveAccent = 96; charCodes[charCodes[\"graveAccent\"] = graveAccent] = \"graveAccent\"; //  '`'\n  const lowercaseA = 97; charCodes[charCodes[\"lowercaseA\"] = lowercaseA] = \"lowercaseA\"; //  'a'\n  const lowercaseB = 98; charCodes[charCodes[\"lowercaseB\"] = lowercaseB] = \"lowercaseB\"; //  'b'\n  const lowercaseC = 99; charCodes[charCodes[\"lowercaseC\"] = lowercaseC] = \"lowercaseC\"; //  'c'\n  const lowercaseD = 100; charCodes[charCodes[\"lowercaseD\"] = lowercaseD] = \"lowercaseD\"; //  'd'\n  const lowercaseE = 101; charCodes[charCodes[\"lowercaseE\"] = lowercaseE] = \"lowercaseE\"; //  'e'\n  const lowercaseF = 102; charCodes[charCodes[\"lowercaseF\"] = lowercaseF] = \"lowercaseF\"; //  'f'\n  const lowercaseG = 103; charCodes[charCodes[\"lowercaseG\"] = lowercaseG] = \"lowercaseG\"; //  'g'\n  const lowercaseH = 104; charCodes[charCodes[\"lowercaseH\"] = lowercaseH] = \"lowercaseH\"; //  'h'\n  const lowercaseI = 105; charCodes[charCodes[\"lowercaseI\"] = lowercaseI] = \"lowercaseI\"; //  'i'\n  const lowercaseJ = 106; charCodes[charCodes[\"lowercaseJ\"] = lowercaseJ] = \"lowercaseJ\"; //  'j'\n  const lowercaseK = 107; charCodes[charCodes[\"lowercaseK\"] = lowercaseK] = \"lowercaseK\"; //  'k'\n  const lowercaseL = 108; charCodes[charCodes[\"lowercaseL\"] = lowercaseL] = \"lowercaseL\"; //  'l'\n  const lowercaseM = 109; charCodes[charCodes[\"lowercaseM\"] = lowercaseM] = \"lowercaseM\"; //  'm'\n  const lowercaseN = 110; charCodes[charCodes[\"lowercaseN\"] = lowercaseN] = \"lowercaseN\"; //  'n'\n  const lowercaseO = 111; charCodes[charCodes[\"lowercaseO\"] = lowercaseO] = \"lowercaseO\"; //  'o'\n  const lowercaseP = 112; charCodes[charCodes[\"lowercaseP\"] = lowercaseP] = \"lowercaseP\"; //  'p'\n  const lowercaseQ = 113; charCodes[charCodes[\"lowercaseQ\"] = lowercaseQ] = \"lowercaseQ\"; //  'q'\n  const lowercaseR = 114; charCodes[charCodes[\"lowercaseR\"] = lowercaseR] = \"lowercaseR\"; //  'r'\n  const lowercaseS = 115; charCodes[charCodes[\"lowercaseS\"] = lowercaseS] = \"lowercaseS\"; //  's'\n  const lowercaseT = 116; charCodes[charCodes[\"lowercaseT\"] = lowercaseT] = \"lowercaseT\"; //  't'\n  const lowercaseU = 117; charCodes[charCodes[\"lowercaseU\"] = lowercaseU] = \"lowercaseU\"; //  'u'\n  const lowercaseV = 118; charCodes[charCodes[\"lowercaseV\"] = lowercaseV] = \"lowercaseV\"; //  'v'\n  const lowercaseW = 119; charCodes[charCodes[\"lowercaseW\"] = lowercaseW] = \"lowercaseW\"; //  'w'\n  const lowercaseX = 120; charCodes[charCodes[\"lowercaseX\"] = lowercaseX] = \"lowercaseX\"; //  'x'\n  const lowercaseY = 121; charCodes[charCodes[\"lowercaseY\"] = lowercaseY] = \"lowercaseY\"; //  'y'\n  const lowercaseZ = 122; charCodes[charCodes[\"lowercaseZ\"] = lowercaseZ] = \"lowercaseZ\"; //  'z'\n  const leftCurlyBrace = 123; charCodes[charCodes[\"leftCurlyBrace\"] = leftCurlyBrace] = \"leftCurlyBrace\"; //  '{'\n  const verticalBar = 124; charCodes[charCodes[\"verticalBar\"] = verticalBar] = \"verticalBar\"; //  '|'\n  const rightCurlyBrace = 125; charCodes[charCodes[\"rightCurlyBrace\"] = rightCurlyBrace] = \"rightCurlyBrace\"; //  '}'\n  const tilde = 126; charCodes[charCodes[\"tilde\"] = tilde] = \"tilde\"; //  '~'\n  const nonBreakingSpace = 160; charCodes[charCodes[\"nonBreakingSpace\"] = nonBreakingSpace] = \"nonBreakingSpace\";\n  // eslint-disable-next-line no-irregular-whitespace\n  const oghamSpaceMark = 5760; charCodes[charCodes[\"oghamSpaceMark\"] = oghamSpaceMark] = \"oghamSpaceMark\"; // '\u1680'\n  const lineSeparator = 8232; charCodes[charCodes[\"lineSeparator\"] = lineSeparator] = \"lineSeparator\";\n  const paragraphSeparator = 8233; charCodes[charCodes[\"paragraphSeparator\"] = paragraphSeparator] = \"paragraphSeparator\";\n})(charCodes || (charCodes = {}));\n\nexport function isDigit(code) {\n  return (\n    (code >= charCodes.digit0 && code <= charCodes.digit9) ||\n    (code >= charCodes.lowercaseA && code <= charCodes.lowercaseF) ||\n    (code >= charCodes.uppercaseA && code <= charCodes.uppercaseF)\n  );\n}\n", "import State from \"../tokenizer/state\";\nimport {charCodes} from \"../util/charcodes\";\n\nexport let isJSXEnabled;\nexport let isTypeScriptEnabled;\nexport let isFlowEnabled;\nexport let state;\nexport let input;\nexport let nextContextId;\n\nexport function getNextContextId() {\n  return nextContextId++;\n}\n\n// tslint:disable-next-line no-any\nexport function augmentError(error) {\n  if (\"pos\" in error) {\n    const loc = locationForIndex(error.pos);\n    error.message += ` (${loc.line}:${loc.column})`;\n    error.loc = loc;\n  }\n  return error;\n}\n\nexport class Loc {\n  \n  \n  constructor(line, column) {\n    this.line = line;\n    this.column = column;\n  }\n}\n\nexport function locationForIndex(pos) {\n  let line = 1;\n  let column = 1;\n  for (let i = 0; i < pos; i++) {\n    if (input.charCodeAt(i) === charCodes.lineFeed) {\n      line++;\n      column = 1;\n    } else {\n      column++;\n    }\n  }\n  return new Loc(line, column);\n}\n\nexport function initParser(\n  inputCode,\n  isJSXEnabledArg,\n  isTypeScriptEnabledArg,\n  isFlowEnabledArg,\n) {\n  input = inputCode;\n  state = new State();\n  nextContextId = 1;\n  isJSXEnabled = isJSXEnabledArg;\n  isTypeScriptEnabled = isTypeScriptEnabledArg;\n  isFlowEnabled = isFlowEnabledArg;\n}\n", "import {eat, finishToken, lookaheadTypeAndKeyword, match} from \"../tokenizer/index\";\n\nimport {formatTokenType, TokenType as tt} from \"../tokenizer/types\";\nimport {charCodes} from \"../util/charcodes\";\nimport {input, state} from \"./base\";\n\n// ## Parser utilities\n\n// Tests whether parsed token is a contextual keyword.\nexport function isContextual(contextualKeyword) {\n  return state.contextualKeyword === contextualKeyword;\n}\n\nexport function isLookaheadContextual(contextualKeyword) {\n  const l = lookaheadTypeAndKeyword();\n  return l.type === tt.name && l.contextualKeyword === contextualKeyword;\n}\n\n// Consumes contextual keyword if possible.\nexport function eatContextual(contextualKeyword) {\n  return state.contextualKeyword === contextualKeyword && eat(tt.name);\n}\n\n// Asserts that following token is given contextual keyword.\nexport function expectContextual(contextualKeyword) {\n  if (!eatContextual(contextualKeyword)) {\n    unexpected();\n  }\n}\n\n// Test whether a semicolon can be inserted at the current position.\nexport function canInsertSemicolon() {\n  return match(tt.eof) || match(tt.braceR) || hasPrecedingLineBreak();\n}\n\nexport function hasPrecedingLineBreak() {\n  const prevToken = state.tokens[state.tokens.length - 1];\n  const lastTokEnd = prevToken ? prevToken.end : 0;\n  for (let i = lastTokEnd; i < state.start; i++) {\n    const code = input.charCodeAt(i);\n    if (\n      code === charCodes.lineFeed ||\n      code === charCodes.carriageReturn ||\n      code === 0x2028 ||\n      code === 0x2029\n    ) {\n      return true;\n    }\n  }\n  return false;\n}\n\nexport function isLineTerminator() {\n  return eat(tt.semi) || canInsertSemicolon();\n}\n\n// Consume a semicolon, or, failing that, see if we are allowed to\n// pretend that there is a semicolon at this position.\nexport function semicolon() {\n  if (!isLineTerminator()) {\n    unexpected('Unexpected token, expected \";\"');\n  }\n}\n\n// Expect a token of a given type. If found, consume it, otherwise,\n// raise an unexpected token error at given pos.\nexport function expect(type) {\n  const matched = eat(type);\n  if (!matched) {\n    unexpected(`Unexpected token, expected \"${formatTokenType(type)}\"`);\n  }\n}\n\n/**\n * Transition the parser to an error state. All code needs to be written to naturally unwind in this\n * state, which allows us to backtrack without exceptions and without error plumbing everywhere.\n */\nexport function unexpected(message = \"Unexpected token\", pos = state.start) {\n  if (state.error) {\n    return;\n  }\n  // tslint:disable-next-line no-any\n  const err = new SyntaxError(message);\n  err.pos = pos;\n  state.error = err;\n  state.pos = input.length;\n  finishToken(tt.eof);\n}\n", "import {charCodes} from \"./charcodes\";\n\n// https://tc39.github.io/ecma262/#sec-white-space\nexport const WHITESPACE_CHARS = [\n  0x0009,\n  0x000b,\n  0x000c,\n  charCodes.space,\n  charCodes.nonBreakingSpace,\n  charCodes.oghamSpaceMark,\n  0x2000, // EN QUAD\n  0x2001, // EM QUAD\n  0x2002, // EN SPACE\n  0x2003, // EM SPACE\n  0x2004, // THREE-PER-EM SPACE\n  0x2005, // FOUR-PER-EM SPACE\n  0x2006, // SIX-PER-EM SPACE\n  0x2007, // FIGURE SPACE\n  0x2008, // PUNCTUATION SPACE\n  0x2009, // THIN SPACE\n  0x200a, // HAIR SPACE\n  0x202f, // NARROW NO-BREAK SPACE\n  0x205f, // MEDIUM MATHEMATICAL SPACE\n  0x3000, // IDEOGRAPHIC SPACE\n  0xfeff, // ZERO WIDTH NO-BREAK SPACE\n];\n\nexport const IS_WHITESPACE = new Uint8Array(65536);\nfor (const char of WHITESPACE_CHARS) {\n  IS_WHITESPACE[char] = 1;\n}\n", "import {charCodes} from \"./charcodes\";\nimport {WHITESPACE_CHARS} from \"./whitespace\";\n\nfunction computeIsIdentifierChar(code) {\n  if (code < 48) return code === 36;\n  if (code < 58) return true;\n  if (code < 65) return false;\n  if (code < 91) return true;\n  if (code < 97) return code === 95;\n  if (code < 123) return true;\n  if (code < 128) return false;\n  throw new Error(\"Should not be called with non-ASCII char code.\");\n}\n\nexport const IS_IDENTIFIER_CHAR = new Uint8Array(65536);\nfor (let i = 0; i < 128; i++) {\n  IS_IDENTIFIER_CHAR[i] = computeIsIdentifierChar(i) ? 1 : 0;\n}\nfor (let i = 128; i < 65536; i++) {\n  IS_IDENTIFIER_CHAR[i] = 1;\n}\n// Aside from whitespace and newlines, all characters outside the ASCII space are either\n// identifier characters or invalid. Since we're not performing code validation, we can just\n// treat all invalid characters as identifier characters.\nfor (const whitespaceChar of WHITESPACE_CHARS) {\n  IS_IDENTIFIER_CHAR[whitespaceChar] = 0;\n}\nIS_IDENTIFIER_CHAR[0x2028] = 0;\nIS_IDENTIFIER_CHAR[0x2029] = 0;\n\nexport const IS_IDENTIFIER_START = IS_IDENTIFIER_CHAR.slice();\nfor (let numChar = charCodes.digit0; numChar <= charCodes.digit9; numChar++) {\n  IS_IDENTIFIER_START[numChar] = 0;\n}\n", "// Generated file, do not edit! Run \"yarn generate\" to re-generate this file.\nimport {ContextualKeyword} from \"./keywords\";\nimport {TokenType as tt} from \"./types\";\n\n// prettier-ignore\nexport const READ_WORD_TREE = new Int32Array([\n  // \"\"\n  -1, 27, 594, 729, 1566, 2187, 2673, 3294, -1, 3510, -1, 4428, 4563, 4644, 4941, 5319, 5508, -1, 6048, 6507, 6966, 7398, 7560, 7722, -1, 7938, -1,\n  // \"a\"\n  -1, -1, 54, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 243, -1, -1, -1, 486, -1, -1, -1,\n  // \"ab\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 81, -1, -1, -1, -1, -1, -1, -1,\n  // \"abs\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 108, -1, -1, -1, -1, -1, -1,\n  // \"abst\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 135, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"abstr\"\n  -1, 162, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"abstra\"\n  -1, -1, -1, 189, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"abstrac\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 216, -1, -1, -1, -1, -1, -1,\n  // \"abstract\"\n  ContextualKeyword._abstract << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"as\"\n  ContextualKeyword._as << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 270, -1, -1, -1, -1, -1, 405, -1,\n  // \"ass\"\n  -1, -1, -1, -1, -1, 297, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"asse\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 324, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"asser\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 351, -1, -1, -1, -1, -1, -1,\n  // \"assert\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 378, -1, -1, -1, -1, -1, -1, -1,\n  // \"asserts\"\n  ContextualKeyword._asserts << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"asy\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 432, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"asyn\"\n  -1, -1, -1, 459, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"async\"\n  ContextualKeyword._async << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"aw\"\n  -1, 513, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"awa\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, 540, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"awai\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 567, -1, -1, -1, -1, -1, -1,\n  // \"await\"\n  ContextualKeyword._await << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"b\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 621, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"br\"\n  -1, -1, -1, -1, -1, 648, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"bre\"\n  -1, 675, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"brea\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 702, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"break\"\n  (tt._break << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"c\"\n  -1, 756, -1, -1, -1, -1, -1, -1, 918, -1, -1, -1, 1053, -1, -1, 1161, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"ca\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 783, 837, -1, -1, -1, -1, -1, -1,\n  // \"cas\"\n  -1, -1, -1, -1, -1, 810, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"case\"\n  (tt._case << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"cat\"\n  -1, -1, -1, 864, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"catc\"\n  -1, -1, -1, -1, -1, -1, -1, -1, 891, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"catch\"\n  (tt._catch << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"ch\"\n  -1, -1, -1, -1, -1, 945, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"che\"\n  -1, -1, -1, 972, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"chec\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 999, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"check\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1026, -1, -1, -1, -1, -1, -1, -1,\n  // \"checks\"\n  ContextualKeyword._checks << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"cl\"\n  -1, 1080, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"cla\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1107, -1, -1, -1, -1, -1, -1, -1,\n  // \"clas\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1134, -1, -1, -1, -1, -1, -1, -1,\n  // \"class\"\n  (tt._class << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"co\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1188, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"con\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1215, 1431, -1, -1, -1, -1, -1, -1,\n  // \"cons\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1242, -1, -1, -1, -1, -1, -1,\n  // \"const\"\n  (tt._const << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1269, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"constr\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1296, -1, -1, -1, -1, -1,\n  // \"constru\"\n  -1, -1, -1, 1323, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"construc\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1350, -1, -1, -1, -1, -1, -1,\n  // \"construct\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1377, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"constructo\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1404, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"constructor\"\n  ContextualKeyword._constructor << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"cont\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, 1458, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"conti\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1485, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"contin\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1512, -1, -1, -1, -1, -1,\n  // \"continu\"\n  -1, -1, -1, -1, -1, 1539, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"continue\"\n  (tt._continue << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"d\"\n  -1, -1, -1, -1, -1, 1593, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2160, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"de\"\n  -1, -1, 1620, 1782, -1, -1, 1917, -1, -1, -1, -1, -1, 2052, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"deb\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1647, -1, -1, -1, -1, -1,\n  // \"debu\"\n  -1, -1, -1, -1, -1, -1, -1, 1674, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"debug\"\n  -1, -1, -1, -1, -1, -1, -1, 1701, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"debugg\"\n  -1, -1, -1, -1, -1, 1728, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"debugge\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1755, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"debugger\"\n  (tt._debugger << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"dec\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1809, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"decl\"\n  -1, 1836, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"decla\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1863, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"declar\"\n  -1, -1, -1, -1, -1, 1890, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"declare\"\n  ContextualKeyword._declare << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"def\"\n  -1, 1944, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"defa\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1971, -1, -1, -1, -1, -1,\n  // \"defau\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1998, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"defaul\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2025, -1, -1, -1, -1, -1, -1,\n  // \"default\"\n  (tt._default << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"del\"\n  -1, -1, -1, -1, -1, 2079, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"dele\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2106, -1, -1, -1, -1, -1, -1,\n  // \"delet\"\n  -1, -1, -1, -1, -1, 2133, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"delete\"\n  (tt._delete << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"do\"\n  (tt._do << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"e\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2214, -1, 2295, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2376, -1, -1,\n  // \"el\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2241, -1, -1, -1, -1, -1, -1, -1,\n  // \"els\"\n  -1, -1, -1, -1, -1, 2268, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"else\"\n  (tt._else << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"en\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2322, -1, -1, -1, -1, -1,\n  // \"enu\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2349, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"enum\"\n  ContextualKeyword._enum << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"ex\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2403, -1, -1, -1, 2538, -1, -1, -1, -1, -1, -1,\n  // \"exp\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2430, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"expo\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2457, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"expor\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2484, -1, -1, -1, -1, -1, -1,\n  // \"export\"\n  (tt._export << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2511, -1, -1, -1, -1, -1, -1, -1,\n  // \"exports\"\n  ContextualKeyword._exports << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"ext\"\n  -1, -1, -1, -1, -1, 2565, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"exte\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2592, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"exten\"\n  -1, -1, -1, -1, 2619, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"extend\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2646, -1, -1, -1, -1, -1, -1, -1,\n  // \"extends\"\n  (tt._extends << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"f\"\n  -1, 2700, -1, -1, -1, -1, -1, -1, -1, 2808, -1, -1, -1, -1, -1, 2970, -1, -1, 3024, -1, -1, 3105, -1, -1, -1, -1, -1,\n  // \"fa\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2727, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"fal\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2754, -1, -1, -1, -1, -1, -1, -1,\n  // \"fals\"\n  -1, -1, -1, -1, -1, 2781, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"false\"\n  (tt._false << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"fi\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2835, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"fin\"\n  -1, 2862, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"fina\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2889, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"final\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2916, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"finall\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2943, -1,\n  // \"finally\"\n  (tt._finally << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"fo\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2997, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"for\"\n  (tt._for << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"fr\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3051, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"fro\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3078, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"from\"\n  ContextualKeyword._from << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"fu\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3132, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"fun\"\n  -1, -1, -1, 3159, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"func\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3186, -1, -1, -1, -1, -1, -1,\n  // \"funct\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, 3213, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"functi\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3240, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"functio\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3267, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"function\"\n  (tt._function << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"g\"\n  -1, -1, -1, -1, -1, 3321, -1, -1, -1, -1, -1, -1, 3375, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"ge\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3348, -1, -1, -1, -1, -1, -1,\n  // \"get\"\n  ContextualKeyword._get << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"gl\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3402, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"glo\"\n  -1, -1, 3429, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"glob\"\n  -1, 3456, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"globa\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3483, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"global\"\n  ContextualKeyword._global << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"i\"\n  -1, -1, -1, -1, -1, -1, 3537, -1, -1, -1, -1, -1, -1, 3564, 3888, -1, -1, -1, -1, 4401, -1, -1, -1, -1, -1, -1, -1,\n  // \"if\"\n  (tt._if << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"im\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3591, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"imp\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3618, -1, -1, 3807, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"impl\"\n  -1, -1, -1, -1, -1, 3645, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"imple\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3672, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"implem\"\n  -1, -1, -1, -1, -1, 3699, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"impleme\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3726, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"implemen\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3753, -1, -1, -1, -1, -1, -1,\n  // \"implement\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3780, -1, -1, -1, -1, -1, -1, -1,\n  // \"implements\"\n  ContextualKeyword._implements << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"impo\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3834, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"impor\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3861, -1, -1, -1, -1, -1, -1,\n  // \"import\"\n  (tt._import << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"in\"\n  (tt._in << 1) + 1, -1, -1, -1, -1, -1, 3915, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3996, 4212, -1, -1, -1, -1, -1, -1,\n  // \"inf\"\n  -1, -1, -1, -1, -1, 3942, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"infe\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3969, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"infer\"\n  ContextualKeyword._infer << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"ins\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4023, -1, -1, -1, -1, -1, -1,\n  // \"inst\"\n  -1, 4050, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"insta\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4077, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"instan\"\n  -1, -1, -1, 4104, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"instanc\"\n  -1, -1, -1, -1, -1, 4131, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"instance\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4158, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"instanceo\"\n  -1, -1, -1, -1, -1, -1, 4185, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"instanceof\"\n  (tt._instanceof << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"int\"\n  -1, -1, -1, -1, -1, 4239, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"inte\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4266, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"inter\"\n  -1, -1, -1, -1, -1, -1, 4293, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"interf\"\n  -1, 4320, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"interfa\"\n  -1, -1, -1, 4347, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"interfac\"\n  -1, -1, -1, -1, -1, 4374, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"interface\"\n  ContextualKeyword._interface << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"is\"\n  ContextualKeyword._is << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"k\"\n  -1, -1, -1, -1, -1, 4455, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"ke\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4482, -1,\n  // \"key\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4509, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"keyo\"\n  -1, -1, -1, -1, -1, -1, 4536, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"keyof\"\n  ContextualKeyword._keyof << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"l\"\n  -1, -1, -1, -1, -1, 4590, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"le\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4617, -1, -1, -1, -1, -1, -1,\n  // \"let\"\n  (tt._let << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"m\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, 4671, -1, -1, -1, -1, -1, 4806, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"mi\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4698, -1, -1,\n  // \"mix\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, 4725, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"mixi\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4752, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"mixin\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4779, -1, -1, -1, -1, -1, -1, -1,\n  // \"mixins\"\n  ContextualKeyword._mixins << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"mo\"\n  -1, -1, -1, -1, 4833, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"mod\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4860, -1, -1, -1, -1, -1,\n  // \"modu\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4887, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"modul\"\n  -1, -1, -1, -1, -1, 4914, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"module\"\n  ContextualKeyword._module << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"n\"\n  -1, 4968, -1, -1, -1, 5184, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5238, -1, -1, -1, -1, -1,\n  // \"na\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4995, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"nam\"\n  -1, -1, -1, -1, -1, 5022, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"name\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5049, -1, -1, -1, -1, -1, -1, -1,\n  // \"names\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5076, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"namesp\"\n  -1, 5103, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"namespa\"\n  -1, -1, -1, 5130, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"namespac\"\n  -1, -1, -1, -1, -1, 5157, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"namespace\"\n  ContextualKeyword._namespace << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"ne\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5211, -1, -1, -1,\n  // \"new\"\n  (tt._new << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"nu\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5265, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"nul\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5292, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"null\"\n  (tt._null << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"o\"\n  -1, -1, -1, -1, -1, -1, 5346, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5373, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"of\"\n  ContextualKeyword._of << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"op\"\n  -1, 5400, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"opa\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5427, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"opaq\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5454, -1, -1, -1, -1, -1,\n  // \"opaqu\"\n  -1, -1, -1, -1, -1, 5481, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"opaque\"\n  ContextualKeyword._opaque << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"p\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5535, -1, -1, 5913, -1, -1, -1, -1, -1,\n  // \"pr\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, 5562, -1, -1, -1, -1, -1, 5697, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"pri\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5589, -1, -1, -1, -1,\n  // \"priv\"\n  -1, 5616, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"priva\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5643, -1, -1, -1, -1, -1, -1,\n  // \"privat\"\n  -1, -1, -1, -1, -1, 5670, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"private\"\n  ContextualKeyword._private << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"pro\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5724, -1, -1, -1, -1, -1, -1,\n  // \"prot\"\n  -1, -1, -1, -1, -1, 5751, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5886, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"prote\"\n  -1, -1, -1, 5778, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"protec\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5805, -1, -1, -1, -1, -1, -1,\n  // \"protect\"\n  -1, -1, -1, -1, -1, 5832, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"protecte\"\n  -1, -1, -1, -1, 5859, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"protected\"\n  ContextualKeyword._protected << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"proto\"\n  ContextualKeyword._proto << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"pu\"\n  -1, -1, 5940, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"pub\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5967, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"publ\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, 5994, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"publi\"\n  -1, -1, -1, 6021, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"public\"\n  ContextualKeyword._public << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"r\"\n  -1, -1, -1, -1, -1, 6075, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"re\"\n  -1, 6102, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6264, -1, -1, 6399, -1, -1, -1, -1, -1, -1,\n  // \"rea\"\n  -1, -1, -1, -1, 6129, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"read\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6156, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"reado\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6183, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"readon\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6210, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"readonl\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6237, -1,\n  // \"readonly\"\n  ContextualKeyword._readonly << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"req\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6291, -1, -1, -1, -1, -1,\n  // \"requ\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, 6318, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"requi\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6345, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"requir\"\n  -1, -1, -1, -1, -1, 6372, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"require\"\n  ContextualKeyword._require << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"ret\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6426, -1, -1, -1, -1, -1,\n  // \"retu\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6453, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"retur\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6480, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"return\"\n  (tt._return << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"s\"\n  -1, -1, -1, -1, -1, 6534, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6588, 6723, -1, 6831, -1, -1, -1,\n  // \"se\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6561, -1, -1, -1, -1, -1, -1,\n  // \"set\"\n  ContextualKeyword._set << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"st\"\n  -1, 6615, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"sta\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6642, -1, -1, -1, -1, -1, -1,\n  // \"stat\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, 6669, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"stati\"\n  -1, -1, -1, 6696, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"static\"\n  ContextualKeyword._static << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"su\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6750, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"sup\"\n  -1, -1, -1, -1, -1, 6777, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"supe\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6804, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"super\"\n  (tt._super << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"sw\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, 6858, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"swi\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6885, -1, -1, -1, -1, -1, -1,\n  // \"swit\"\n  -1, -1, -1, 6912, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"switc\"\n  -1, -1, -1, -1, -1, -1, -1, -1, 6939, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"switch\"\n  (tt._switch << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"t\"\n  -1, -1, -1, -1, -1, -1, -1, -1, 6993, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7155, -1, -1, -1, -1, -1, -1, 7263, -1,\n  // \"th\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, 7020, -1, -1, -1, -1, -1, -1, -1, -1, 7074, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"thi\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7047, -1, -1, -1, -1, -1, -1, -1,\n  // \"this\"\n  (tt._this << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"thr\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7101, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"thro\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7128, -1, -1, -1,\n  // \"throw\"\n  (tt._throw << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"tr\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7182, -1, -1, -1, 7236, -1,\n  // \"tru\"\n  -1, -1, -1, -1, -1, 7209, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"true\"\n  (tt._true << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"try\"\n  (tt._try << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"ty\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7290, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"typ\"\n  -1, -1, -1, -1, -1, 7317, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"type\"\n  ContextualKeyword._type << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7344, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"typeo\"\n  -1, -1, -1, -1, -1, -1, 7371, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"typeof\"\n  (tt._typeof << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"u\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7425, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"un\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, 7452, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"uni\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7479, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"uniq\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7506, -1, -1, -1, -1, -1,\n  // \"uniqu\"\n  -1, -1, -1, -1, -1, 7533, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"unique\"\n  ContextualKeyword._unique << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"v\"\n  -1, 7587, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7641, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"va\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7614, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"var\"\n  (tt._var << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"vo\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, 7668, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"voi\"\n  -1, -1, -1, -1, 7695, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"void\"\n  (tt._void << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"w\"\n  -1, -1, -1, -1, -1, -1, -1, -1, 7749, 7857, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"wh\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, 7776, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"whi\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7803, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"whil\"\n  -1, -1, -1, -1, -1, 7830, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"while\"\n  (tt._while << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"wi\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7884, -1, -1, -1, -1, -1, -1,\n  // \"wit\"\n  -1, -1, -1, -1, -1, -1, -1, -1, 7911, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"with\"\n  (tt._with << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"y\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, 7965, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"yi\"\n  -1, -1, -1, -1, -1, 7992, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"yie\"\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8019, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"yiel\"\n  -1, -1, -1, -1, 8046, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  // \"yield\"\n  (tt._yield << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n]);\n", "import {input, state} from \"../traverser/base\";\nimport {charCodes} from \"../util/charcodes\";\nimport {IS_IDENTIFIER_CHAR} from \"../util/identifier\";\nimport {finishToken} from \"./index\";\nimport {READ_WORD_TREE} from \"./readWordTree\";\nimport {TokenType as tt} from \"./types\";\n\n/**\n * Read an identifier, producing either a name token or matching on one of the existing keywords.\n * For performance, we pre-generate big decision tree that we traverse. Each node represents a\n * prefix and has 27 values, where the first value is the token or contextual token, if any (-1 if\n * not), and the other 26 values are the transitions to other nodes, or -1 to stop.\n */\nexport default function readWord() {\n  let treePos = 0;\n  let code = 0;\n  let pos = state.pos;\n  while (pos < input.length) {\n    code = input.charCodeAt(pos);\n    if (code < charCodes.lowercaseA || code > charCodes.lowercaseZ) {\n      break;\n    }\n    const next = READ_WORD_TREE[treePos + (code - charCodes.lowercaseA) + 1];\n    if (next === -1) {\n      break;\n    } else {\n      treePos = next;\n      pos++;\n    }\n  }\n\n  const keywordValue = READ_WORD_TREE[treePos];\n  if (keywordValue > -1 && !IS_IDENTIFIER_CHAR[code]) {\n    state.pos = pos;\n    if (keywordValue & 1) {\n      finishToken(keywordValue >>> 1);\n    } else {\n      finishToken(tt.name, keywordValue >>> 1);\n    }\n    return;\n  }\n\n  while (pos < input.length) {\n    const ch = input.charCodeAt(pos);\n    if (IS_IDENTIFIER_CHAR[ch]) {\n      pos++;\n    } else if (ch === charCodes.backslash) {\n      // \\u\n      pos += 2;\n      if (input.charCodeAt(pos) === charCodes.leftCurlyBrace) {\n        while (pos < input.length && input.charCodeAt(pos) !== charCodes.rightCurlyBrace) {\n          pos++;\n        }\n        pos++;\n      }\n    } else if (ch === charCodes.atSign && input.charCodeAt(pos + 1) === charCodes.atSign) {\n      pos += 2;\n    } else {\n      break;\n    }\n  }\n  state.pos = pos;\n  finishToken(tt.name);\n}\n", "/* eslint max-len: 0 */\n\nimport {input, isFlowEnabled, state} from \"../traverser/base\";\nimport {unexpected} from \"../traverser/util\";\nimport {charCodes} from \"../util/charcodes\";\nimport {IS_IDENTIFIER_CHAR, IS_IDENTIFIER_START} from \"../util/identifier\";\nimport {IS_WHITESPACE} from \"../util/whitespace\";\nimport {ContextualKeyword} from \"./keywords\";\nimport readWord from \"./readWord\";\nimport { TokenType as tt} from \"./types\";\n\nexport var IdentifierRole; (function (IdentifierRole) {\n  const Access = 0; IdentifierRole[IdentifierRole[\"Access\"] = Access] = \"Access\";\n  const ExportAccess = Access + 1; IdentifierRole[IdentifierRole[\"ExportAccess\"] = ExportAccess] = \"ExportAccess\";\n  const TopLevelDeclaration = ExportAccess + 1; IdentifierRole[IdentifierRole[\"TopLevelDeclaration\"] = TopLevelDeclaration] = \"TopLevelDeclaration\";\n  const FunctionScopedDeclaration = TopLevelDeclaration + 1; IdentifierRole[IdentifierRole[\"FunctionScopedDeclaration\"] = FunctionScopedDeclaration] = \"FunctionScopedDeclaration\";\n  const BlockScopedDeclaration = FunctionScopedDeclaration + 1; IdentifierRole[IdentifierRole[\"BlockScopedDeclaration\"] = BlockScopedDeclaration] = \"BlockScopedDeclaration\";\n  const ObjectShorthandTopLevelDeclaration = BlockScopedDeclaration + 1; IdentifierRole[IdentifierRole[\"ObjectShorthandTopLevelDeclaration\"] = ObjectShorthandTopLevelDeclaration] = \"ObjectShorthandTopLevelDeclaration\";\n  const ObjectShorthandFunctionScopedDeclaration = ObjectShorthandTopLevelDeclaration + 1; IdentifierRole[IdentifierRole[\"ObjectShorthandFunctionScopedDeclaration\"] = ObjectShorthandFunctionScopedDeclaration] = \"ObjectShorthandFunctionScopedDeclaration\";\n  const ObjectShorthandBlockScopedDeclaration = ObjectShorthandFunctionScopedDeclaration + 1; IdentifierRole[IdentifierRole[\"ObjectShorthandBlockScopedDeclaration\"] = ObjectShorthandBlockScopedDeclaration] = \"ObjectShorthandBlockScopedDeclaration\";\n  const ObjectShorthand = ObjectShorthandBlockScopedDeclaration + 1; IdentifierRole[IdentifierRole[\"ObjectShorthand\"] = ObjectShorthand] = \"ObjectShorthand\";\n  // Any identifier bound in an import statement, e.g. both A and b from\n  // `import A, * as b from 'A';`\n  const ImportDeclaration = ObjectShorthand + 1; IdentifierRole[IdentifierRole[\"ImportDeclaration\"] = ImportDeclaration] = \"ImportDeclaration\";\n  const ObjectKey = ImportDeclaration + 1; IdentifierRole[IdentifierRole[\"ObjectKey\"] = ObjectKey] = \"ObjectKey\";\n  // The `foo` in `import {foo as bar} from \"./abc\";`.\n  const ImportAccess = ObjectKey + 1; IdentifierRole[IdentifierRole[\"ImportAccess\"] = ImportAccess] = \"ImportAccess\";\n})(IdentifierRole || (IdentifierRole = {}));\n\nexport function isDeclaration(token) {\n  const role = token.identifierRole;\n  return (\n    role === IdentifierRole.TopLevelDeclaration ||\n    role === IdentifierRole.FunctionScopedDeclaration ||\n    role === IdentifierRole.BlockScopedDeclaration ||\n    role === IdentifierRole.ObjectShorthandTopLevelDeclaration ||\n    role === IdentifierRole.ObjectShorthandFunctionScopedDeclaration ||\n    role === IdentifierRole.ObjectShorthandBlockScopedDeclaration\n  );\n}\n\nexport function isNonTopLevelDeclaration(token) {\n  const role = token.identifierRole;\n  return (\n    role === IdentifierRole.FunctionScopedDeclaration ||\n    role === IdentifierRole.BlockScopedDeclaration ||\n    role === IdentifierRole.ObjectShorthandFunctionScopedDeclaration ||\n    role === IdentifierRole.ObjectShorthandBlockScopedDeclaration\n  );\n}\n\nexport function isTopLevelDeclaration(token) {\n  const role = token.identifierRole;\n  return (\n    role === IdentifierRole.TopLevelDeclaration ||\n    role === IdentifierRole.ObjectShorthandTopLevelDeclaration ||\n    role === IdentifierRole.ImportDeclaration\n  );\n}\n\nexport function isBlockScopedDeclaration(token) {\n  const role = token.identifierRole;\n  // Treat top-level declarations as block scope since the distinction doesn't matter here.\n  return (\n    role === IdentifierRole.TopLevelDeclaration ||\n    role === IdentifierRole.BlockScopedDeclaration ||\n    role === IdentifierRole.ObjectShorthandTopLevelDeclaration ||\n    role === IdentifierRole.ObjectShorthandBlockScopedDeclaration\n  );\n}\n\nexport function isFunctionScopedDeclaration(token) {\n  const role = token.identifierRole;\n  return (\n    role === IdentifierRole.FunctionScopedDeclaration ||\n    role === IdentifierRole.ObjectShorthandFunctionScopedDeclaration\n  );\n}\n\nexport function isObjectShorthandDeclaration(token) {\n  return (\n    token.identifierRole === IdentifierRole.ObjectShorthandTopLevelDeclaration ||\n    token.identifierRole === IdentifierRole.ObjectShorthandBlockScopedDeclaration ||\n    token.identifierRole === IdentifierRole.ObjectShorthandFunctionScopedDeclaration\n  );\n}\n\n// Object type used to represent tokens. Note that normally, tokens\n// simply exist as properties on the parser object. This is only\n// used for the onToken callback and the external tokenizer.\nexport class Token {\n  constructor() {\n    this.type = state.type;\n    this.contextualKeyword = state.contextualKeyword;\n    this.start = state.start;\n    this.end = state.end;\n    this.scopeDepth = state.scopeDepth;\n    this.isType = state.isType;\n    this.identifierRole = null;\n    this.shadowsGlobal = false;\n    this.contextId = null;\n    this.rhsEndIndex = null;\n    this.isExpression = false;\n    this.numNullishCoalesceStarts = 0;\n    this.numNullishCoalesceEnds = 0;\n    this.isOptionalChainStart = false;\n    this.isOptionalChainEnd = false;\n    this.subscriptStartIndex = null;\n    this.nullishStartIndex = null;\n  }\n\n  \n  \n  \n  \n  \n  \n  \n  // Initially false for all tokens, then may be computed in a follow-up step that does scope\n  // analysis.\n  \n  // Initially false for all tokens, but may be set during transform to mark it as containing an\n  // await operation.\n  \n  \n  // For assignments, the index of the RHS. For export tokens, the end of the export.\n  \n  // For class tokens, records if the class is a class expression or a class statement.\n  \n  // Number of times to insert a `nullishCoalesce(` snippet before this token.\n  \n  // Number of times to insert a `)` snippet after this token.\n  \n  // If true, insert an `optionalChain([` snippet before this token.\n  \n  // If true, insert a `])` snippet after this token.\n  \n  // Tag for `.`, `?.`, `[`, `?.[`, `(`, and `?.(` to denote the \"root\" token for this\n  // subscript chain. This can be used to determine if this chain is an optional chain.\n  \n  // Tag for `??` operators to denote the root token for this nullish coalescing call.\n  \n}\n\n// ## Tokenizer\n\n// Move to the next token\nexport function next() {\n  state.tokens.push(new Token());\n  nextToken();\n}\n\n// Call instead of next when inside a template, since that needs to be handled differently.\nexport function nextTemplateToken() {\n  state.tokens.push(new Token());\n  state.start = state.pos;\n  readTmplToken();\n}\n\n// The tokenizer never parses regexes by default. Instead, the parser is responsible for\n// instructing it to parse a regex when we see a slash at the start of an expression.\nexport function retokenizeSlashAsRegex() {\n  if (state.type === tt.assign) {\n    --state.pos;\n  }\n  readRegexp();\n}\n\nexport function pushTypeContext(existingTokensInType) {\n  for (let i = state.tokens.length - existingTokensInType; i < state.tokens.length; i++) {\n    state.tokens[i].isType = true;\n  }\n  const oldIsType = state.isType;\n  state.isType = true;\n  return oldIsType;\n}\n\nexport function popTypeContext(oldIsType) {\n  state.isType = oldIsType;\n}\n\nexport function eat(type) {\n  if (match(type)) {\n    next();\n    return true;\n  } else {\n    return false;\n  }\n}\n\nexport function match(type) {\n  return state.type === type;\n}\n\nexport function lookaheadType() {\n  const snapshot = state.snapshot();\n  next();\n  const type = state.type;\n  state.restoreFromSnapshot(snapshot);\n  return type;\n}\n\nexport class TypeAndKeyword {\n  \n  \n  constructor(type, contextualKeyword) {\n    this.type = type;\n    this.contextualKeyword = contextualKeyword;\n  }\n}\n\nexport function lookaheadTypeAndKeyword() {\n  const snapshot = state.snapshot();\n  next();\n  const type = state.type;\n  const contextualKeyword = state.contextualKeyword;\n  state.restoreFromSnapshot(snapshot);\n  return new TypeAndKeyword(type, contextualKeyword);\n}\n\n// Read a single token, updating the parser object's token-related\n// properties.\nexport function nextToken() {\n  skipSpace();\n  state.start = state.pos;\n  if (state.pos >= input.length) {\n    const tokens = state.tokens;\n    // We normally run past the end a bit, but if we're way past the end, avoid an infinite loop.\n    // Also check the token positions rather than the types since sometimes we rewrite the token\n    // type to something else.\n    if (\n      tokens.length >= 2 &&\n      tokens[tokens.length - 1].start >= input.length &&\n      tokens[tokens.length - 2].start >= input.length\n    ) {\n      unexpected(\"Unexpectedly reached the end of input.\");\n    }\n    finishToken(tt.eof);\n    return;\n  }\n  readToken(input.charCodeAt(state.pos));\n}\n\nfunction readToken(code) {\n  // Identifier or keyword. '\\uXXXX' sequences are allowed in\n  // identifiers, so '\\' also dispatches to that.\n  if (\n    IS_IDENTIFIER_START[code] ||\n    code === charCodes.backslash ||\n    (code === charCodes.atSign && input.charCodeAt(state.pos + 1) === charCodes.atSign)\n  ) {\n    readWord();\n  } else {\n    getTokenFromCode(code);\n  }\n}\n\nfunction skipBlockComment() {\n  while (\n    input.charCodeAt(state.pos) !== charCodes.asterisk ||\n    input.charCodeAt(state.pos + 1) !== charCodes.slash\n  ) {\n    state.pos++;\n    if (state.pos > input.length) {\n      unexpected(\"Unterminated comment\", state.pos - 2);\n      return;\n    }\n  }\n  state.pos += 2;\n}\n\nexport function skipLineComment(startSkip) {\n  let ch = input.charCodeAt((state.pos += startSkip));\n  if (state.pos < input.length) {\n    while (\n      ch !== charCodes.lineFeed &&\n      ch !== charCodes.carriageReturn &&\n      ch !== charCodes.lineSeparator &&\n      ch !== charCodes.paragraphSeparator &&\n      ++state.pos < input.length\n    ) {\n      ch = input.charCodeAt(state.pos);\n    }\n  }\n}\n\n// Called at the start of the parse and after every token. Skips\n// whitespace and comments.\nexport function skipSpace() {\n  while (state.pos < input.length) {\n    const ch = input.charCodeAt(state.pos);\n    switch (ch) {\n      case charCodes.carriageReturn:\n        if (input.charCodeAt(state.pos + 1) === charCodes.lineFeed) {\n          ++state.pos;\n        }\n\n      case charCodes.lineFeed:\n      case charCodes.lineSeparator:\n      case charCodes.paragraphSeparator:\n        ++state.pos;\n        break;\n\n      case charCodes.slash:\n        switch (input.charCodeAt(state.pos + 1)) {\n          case charCodes.asterisk:\n            state.pos += 2;\n            skipBlockComment();\n            break;\n\n          case charCodes.slash:\n            skipLineComment(2);\n            break;\n\n          default:\n            return;\n        }\n        break;\n\n      default:\n        if (IS_WHITESPACE[ch]) {\n          ++state.pos;\n        } else {\n          return;\n        }\n    }\n  }\n}\n\n// Called at the end of every token. Sets various fields, and skips the space after the token, so\n// that the next one's `start` will point at the right position.\nexport function finishToken(\n  type,\n  contextualKeyword = ContextualKeyword.NONE,\n) {\n  state.end = state.pos;\n  state.type = type;\n  state.contextualKeyword = contextualKeyword;\n}\n\n// ### Token reading\n\n// This is the function that is called to fetch the next token. It\n// is somewhat obscure, because it works in character codes rather\n// than characters, and because operator parsing has been inlined\n// into it.\n//\n// All in the name of speed.\nfunction readToken_dot() {\n  const nextChar = input.charCodeAt(state.pos + 1);\n  if (nextChar >= charCodes.digit0 && nextChar <= charCodes.digit9) {\n    readNumber(true);\n    return;\n  }\n\n  if (nextChar === charCodes.dot && input.charCodeAt(state.pos + 2) === charCodes.dot) {\n    state.pos += 3;\n    finishToken(tt.ellipsis);\n  } else {\n    ++state.pos;\n    finishToken(tt.dot);\n  }\n}\n\nfunction readToken_slash() {\n  const nextChar = input.charCodeAt(state.pos + 1);\n  if (nextChar === charCodes.equalsTo) {\n    finishOp(tt.assign, 2);\n  } else {\n    finishOp(tt.slash, 1);\n  }\n}\n\nfunction readToken_mult_modulo(code) {\n  // '%*'\n  let tokenType = code === charCodes.asterisk ? tt.star : tt.modulo;\n  let width = 1;\n  let nextChar = input.charCodeAt(state.pos + 1);\n\n  // Exponentiation operator **\n  if (code === charCodes.asterisk && nextChar === charCodes.asterisk) {\n    width++;\n    nextChar = input.charCodeAt(state.pos + 2);\n    tokenType = tt.exponent;\n  }\n\n  // Match *= or %=, disallowing *=> which can be valid in flow.\n  if (\n    nextChar === charCodes.equalsTo &&\n    input.charCodeAt(state.pos + 2) !== charCodes.greaterThan\n  ) {\n    width++;\n    tokenType = tt.assign;\n  }\n\n  finishOp(tokenType, width);\n}\n\nfunction readToken_pipe_amp(code) {\n  // '|&'\n  const nextChar = input.charCodeAt(state.pos + 1);\n\n  if (nextChar === code) {\n    if (input.charCodeAt(state.pos + 2) === charCodes.equalsTo) {\n      // ||= or &&=\n      finishOp(tt.assign, 3);\n    } else {\n      // || or &&\n      finishOp(code === charCodes.verticalBar ? tt.logicalOR : tt.logicalAND, 2);\n    }\n    return;\n  }\n\n  if (code === charCodes.verticalBar) {\n    // '|>'\n    if (nextChar === charCodes.greaterThan) {\n      finishOp(tt.pipeline, 2);\n      return;\n    } else if (nextChar === charCodes.rightCurlyBrace && isFlowEnabled) {\n      // '|}'\n      finishOp(tt.braceBarR, 2);\n      return;\n    }\n  }\n\n  if (nextChar === charCodes.equalsTo) {\n    finishOp(tt.assign, 2);\n    return;\n  }\n\n  finishOp(code === charCodes.verticalBar ? tt.bitwiseOR : tt.bitwiseAND, 1);\n}\n\nfunction readToken_caret() {\n  // '^'\n  const nextChar = input.charCodeAt(state.pos + 1);\n  if (nextChar === charCodes.equalsTo) {\n    finishOp(tt.assign, 2);\n  } else {\n    finishOp(tt.bitwiseXOR, 1);\n  }\n}\n\nfunction readToken_plus_min(code) {\n  // '+-'\n  const nextChar = input.charCodeAt(state.pos + 1);\n\n  if (nextChar === code) {\n    // Tentatively call this a prefix operator, but it might be changed to postfix later.\n    finishOp(tt.preIncDec, 2);\n    return;\n  }\n\n  if (nextChar === charCodes.equalsTo) {\n    finishOp(tt.assign, 2);\n  } else if (code === charCodes.plusSign) {\n    finishOp(tt.plus, 1);\n  } else {\n    finishOp(tt.minus, 1);\n  }\n}\n\n// '<>'\nfunction readToken_lt_gt(code) {\n  // Avoid right-shift for things like Array<Array<string>>.\n  if (code === charCodes.greaterThan && state.isType) {\n    finishOp(tt.greaterThan, 1);\n    return;\n  }\n  const nextChar = input.charCodeAt(state.pos + 1);\n\n  if (nextChar === code) {\n    const size =\n      code === charCodes.greaterThan && input.charCodeAt(state.pos + 2) === charCodes.greaterThan\n        ? 3\n        : 2;\n    if (input.charCodeAt(state.pos + size) === charCodes.equalsTo) {\n      finishOp(tt.assign, size + 1);\n      return;\n    }\n    finishOp(tt.bitShift, size);\n    return;\n  }\n\n  if (nextChar === charCodes.equalsTo) {\n    // <= | >=\n    finishOp(tt.relationalOrEqual, 2);\n  } else if (code === charCodes.lessThan) {\n    finishOp(tt.lessThan, 1);\n  } else {\n    finishOp(tt.greaterThan, 1);\n  }\n}\n\nfunction readToken_eq_excl(code) {\n  // '=!'\n  const nextChar = input.charCodeAt(state.pos + 1);\n  if (nextChar === charCodes.equalsTo) {\n    finishOp(tt.equality, input.charCodeAt(state.pos + 2) === charCodes.equalsTo ? 3 : 2);\n    return;\n  }\n  if (code === charCodes.equalsTo && nextChar === charCodes.greaterThan) {\n    // '=>'\n    state.pos += 2;\n    finishToken(tt.arrow);\n    return;\n  }\n  finishOp(code === charCodes.equalsTo ? tt.eq : tt.bang, 1);\n}\n\nfunction readToken_question() {\n  // '?'\n  const nextChar = input.charCodeAt(state.pos + 1);\n  const nextChar2 = input.charCodeAt(state.pos + 2);\n  if (nextChar === charCodes.questionMark && !state.isType) {\n    if (nextChar2 === charCodes.equalsTo) {\n      // '??='\n      finishOp(tt.assign, 3);\n    } else {\n      // '??'\n      finishOp(tt.nullishCoalescing, 2);\n    }\n  } else if (\n    nextChar === charCodes.dot &&\n    !(nextChar2 >= charCodes.digit0 && nextChar2 <= charCodes.digit9)\n  ) {\n    // '.' not followed by a number\n    state.pos += 2;\n    finishToken(tt.questionDot);\n  } else {\n    ++state.pos;\n    finishToken(tt.question);\n  }\n}\n\nexport function getTokenFromCode(code) {\n  switch (code) {\n    case charCodes.numberSign:\n      ++state.pos;\n      finishToken(tt.hash);\n      return;\n\n    // The interpretation of a dot depends on whether it is followed\n    // by a digit or another two dots.\n\n    case charCodes.dot:\n      readToken_dot();\n      return;\n\n    // Punctuation tokens.\n    case charCodes.leftParenthesis:\n      ++state.pos;\n      finishToken(tt.parenL);\n      return;\n    case charCodes.rightParenthesis:\n      ++state.pos;\n      finishToken(tt.parenR);\n      return;\n    case charCodes.semicolon:\n      ++state.pos;\n      finishToken(tt.semi);\n      return;\n    case charCodes.comma:\n      ++state.pos;\n      finishToken(tt.comma);\n      return;\n    case charCodes.leftSquareBracket:\n      ++state.pos;\n      finishToken(tt.bracketL);\n      return;\n    case charCodes.rightSquareBracket:\n      ++state.pos;\n      finishToken(tt.bracketR);\n      return;\n\n    case charCodes.leftCurlyBrace:\n      if (isFlowEnabled && input.charCodeAt(state.pos + 1) === charCodes.verticalBar) {\n        finishOp(tt.braceBarL, 2);\n      } else {\n        ++state.pos;\n        finishToken(tt.braceL);\n      }\n      return;\n\n    case charCodes.rightCurlyBrace:\n      ++state.pos;\n      finishToken(tt.braceR);\n      return;\n\n    case charCodes.colon:\n      if (input.charCodeAt(state.pos + 1) === charCodes.colon) {\n        finishOp(tt.doubleColon, 2);\n      } else {\n        ++state.pos;\n        finishToken(tt.colon);\n      }\n      return;\n\n    case charCodes.questionMark:\n      readToken_question();\n      return;\n    case charCodes.atSign:\n      ++state.pos;\n      finishToken(tt.at);\n      return;\n\n    case charCodes.graveAccent:\n      ++state.pos;\n      finishToken(tt.backQuote);\n      return;\n\n    case charCodes.digit0: {\n      const nextChar = input.charCodeAt(state.pos + 1);\n      // '0x', '0X', '0o', '0O', '0b', '0B'\n      if (\n        nextChar === charCodes.lowercaseX ||\n        nextChar === charCodes.uppercaseX ||\n        nextChar === charCodes.lowercaseO ||\n        nextChar === charCodes.uppercaseO ||\n        nextChar === charCodes.lowercaseB ||\n        nextChar === charCodes.uppercaseB\n      ) {\n        readRadixNumber();\n        return;\n      }\n    }\n    // Anything else beginning with a digit is an integer, octal\n    // number, or float.\n    case charCodes.digit1:\n    case charCodes.digit2:\n    case charCodes.digit3:\n    case charCodes.digit4:\n    case charCodes.digit5:\n    case charCodes.digit6:\n    case charCodes.digit7:\n    case charCodes.digit8:\n    case charCodes.digit9:\n      readNumber(false);\n      return;\n\n    // Quotes produce strings.\n    case charCodes.quotationMark:\n    case charCodes.apostrophe:\n      readString(code);\n      return;\n\n    // Operators are parsed inline in tiny state machines. '=' (charCodes.equalsTo) is\n    // often referred to. `finishOp` simply skips the amount of\n    // characters it is given as second argument, and returns a token\n    // of the type given by its first argument.\n\n    case charCodes.slash:\n      readToken_slash();\n      return;\n\n    case charCodes.percentSign:\n    case charCodes.asterisk:\n      readToken_mult_modulo(code);\n      return;\n\n    case charCodes.verticalBar:\n    case charCodes.ampersand:\n      readToken_pipe_amp(code);\n      return;\n\n    case charCodes.caret:\n      readToken_caret();\n      return;\n\n    case charCodes.plusSign:\n    case charCodes.dash:\n      readToken_plus_min(code);\n      return;\n\n    case charCodes.lessThan:\n    case charCodes.greaterThan:\n      readToken_lt_gt(code);\n      return;\n\n    case charCodes.equalsTo:\n    case charCodes.exclamationMark:\n      readToken_eq_excl(code);\n      return;\n\n    case charCodes.tilde:\n      finishOp(tt.tilde, 1);\n      return;\n\n    default:\n      break;\n  }\n\n  unexpected(`Unexpected character '${String.fromCharCode(code)}'`, state.pos);\n}\n\nfunction finishOp(type, size) {\n  state.pos += size;\n  finishToken(type);\n}\n\nfunction readRegexp() {\n  const start = state.pos;\n  let escaped = false;\n  let inClass = false;\n  for (;;) {\n    if (state.pos >= input.length) {\n      unexpected(\"Unterminated regular expression\", start);\n      return;\n    }\n    const code = input.charCodeAt(state.pos);\n    if (escaped) {\n      escaped = false;\n    } else {\n      if (code === charCodes.leftSquareBracket) {\n        inClass = true;\n      } else if (code === charCodes.rightSquareBracket && inClass) {\n        inClass = false;\n      } else if (code === charCodes.slash && !inClass) {\n        break;\n      }\n      escaped = code === charCodes.backslash;\n    }\n    ++state.pos;\n  }\n  ++state.pos;\n  // Need to use `skipWord` because '\\uXXXX' sequences are allowed here (don't ask).\n  skipWord();\n\n  finishToken(tt.regexp);\n}\n\n// Read an integer. We allow any valid digit, including hex digits, plus numeric separators, and\n// stop at any other character.\nfunction readInt() {\n  while (true) {\n    const code = input.charCodeAt(state.pos);\n    if (\n      (code >= charCodes.digit0 && code <= charCodes.digit9) ||\n      (code >= charCodes.lowercaseA && code <= charCodes.lowercaseF) ||\n      (code >= charCodes.uppercaseA && code <= charCodes.uppercaseF) ||\n      code === charCodes.underscore\n    ) {\n      state.pos++;\n    } else {\n      break;\n    }\n  }\n}\n\nfunction readRadixNumber() {\n  let isBigInt = false;\n\n  state.pos += 2; // 0x\n  readInt();\n\n  if (input.charCodeAt(state.pos) === charCodes.lowercaseN) {\n    ++state.pos;\n    isBigInt = true;\n  }\n\n  if (isBigInt) {\n    finishToken(tt.bigint);\n    return;\n  }\n\n  finishToken(tt.num);\n}\n\n// Read an integer, octal integer, or floating-point number.\nfunction readNumber(startsWithDot) {\n  let isBigInt = false;\n\n  if (!startsWithDot) {\n    readInt();\n  }\n\n  let nextChar = input.charCodeAt(state.pos);\n  if (nextChar === charCodes.dot) {\n    ++state.pos;\n    readInt();\n    nextChar = input.charCodeAt(state.pos);\n  }\n\n  if (nextChar === charCodes.uppercaseE || nextChar === charCodes.lowercaseE) {\n    nextChar = input.charCodeAt(++state.pos);\n    if (nextChar === charCodes.plusSign || nextChar === charCodes.dash) {\n      ++state.pos;\n    }\n    readInt();\n    nextChar = input.charCodeAt(state.pos);\n  }\n\n  if (nextChar === charCodes.lowercaseN) {\n    ++state.pos;\n    isBigInt = true;\n  }\n\n  if (isBigInt) {\n    finishToken(tt.bigint);\n    return;\n  }\n  finishToken(tt.num);\n}\n\nfunction readString(quote) {\n  state.pos++;\n  for (;;) {\n    if (state.pos >= input.length) {\n      unexpected(\"Unterminated string constant\");\n      return;\n    }\n    const ch = input.charCodeAt(state.pos);\n    if (ch === charCodes.backslash) {\n      state.pos++;\n    } else if (ch === quote) {\n      break;\n    }\n    state.pos++;\n  }\n  state.pos++;\n  finishToken(tt.string);\n}\n\n// Reads template string tokens.\nfunction readTmplToken() {\n  for (;;) {\n    if (state.pos >= input.length) {\n      unexpected(\"Unterminated template\");\n      return;\n    }\n    const ch = input.charCodeAt(state.pos);\n    if (\n      ch === charCodes.graveAccent ||\n      (ch === charCodes.dollarSign && input.charCodeAt(state.pos + 1) === charCodes.leftCurlyBrace)\n    ) {\n      if (state.pos === state.start && match(tt.template)) {\n        if (ch === charCodes.dollarSign) {\n          state.pos += 2;\n          finishToken(tt.dollarBraceL);\n          return;\n        } else {\n          ++state.pos;\n          finishToken(tt.backQuote);\n          return;\n        }\n      }\n      finishToken(tt.template);\n      return;\n    }\n    if (ch === charCodes.backslash) {\n      state.pos++;\n    }\n    state.pos++;\n  }\n}\n\n// Skip to the end of the current word. Note that this is the same as the snippet at the end of\n// readWord, but calling skipWord from readWord seems to slightly hurt performance from some rough\n// measurements.\nexport function skipWord() {\n  while (state.pos < input.length) {\n    const ch = input.charCodeAt(state.pos);\n    if (IS_IDENTIFIER_CHAR[ch]) {\n      state.pos++;\n    } else if (ch === charCodes.backslash) {\n      // \\u\n      state.pos += 2;\n      if (input.charCodeAt(state.pos) === charCodes.leftCurlyBrace) {\n        while (\n          state.pos < input.length &&\n          input.charCodeAt(state.pos) !== charCodes.rightCurlyBrace\n        ) {\n          state.pos++;\n        }\n        state.pos++;\n      }\n    } else {\n      break;\n    }\n  }\n}\n", "const entities = {\n  quot: \"\\u0022\",\n  amp: \"&\",\n  apos: \"\\u0027\",\n  lt: \"<\",\n  gt: \">\",\n  nbsp: \"\\u00A0\",\n  iexcl: \"\\u00A1\",\n  cent: \"\\u00A2\",\n  pound: \"\\u00A3\",\n  curren: \"\\u00A4\",\n  yen: \"\\u00A5\",\n  brvbar: \"\\u00A6\",\n  sect: \"\\u00A7\",\n  uml: \"\\u00A8\",\n  copy: \"\\u00A9\",\n  ordf: \"\\u00AA\",\n  laquo: \"\\u00AB\",\n  not: \"\\u00AC\",\n  shy: \"\\u00AD\",\n  reg: \"\\u00AE\",\n  macr: \"\\u00AF\",\n  deg: \"\\u00B0\",\n  plusmn: \"\\u00B1\",\n  sup2: \"\\u00B2\",\n  sup3: \"\\u00B3\",\n  acute: \"\\u00B4\",\n  micro: \"\\u00B5\",\n  para: \"\\u00B6\",\n  middot: \"\\u00B7\",\n  cedil: \"\\u00B8\",\n  sup1: \"\\u00B9\",\n  ordm: \"\\u00BA\",\n  raquo: \"\\u00BB\",\n  frac14: \"\\u00BC\",\n  frac12: \"\\u00BD\",\n  frac34: \"\\u00BE\",\n  iquest: \"\\u00BF\",\n  Agrave: \"\\u00C0\",\n  Aacute: \"\\u00C1\",\n  Acirc: \"\\u00C2\",\n  Atilde: \"\\u00C3\",\n  Auml: \"\\u00C4\",\n  Aring: \"\\u00C5\",\n  AElig: \"\\u00C6\",\n  Ccedil: \"\\u00C7\",\n  Egrave: \"\\u00C8\",\n  Eacute: \"\\u00C9\",\n  Ecirc: \"\\u00CA\",\n  Euml: \"\\u00CB\",\n  Igrave: \"\\u00CC\",\n  Iacute: \"\\u00CD\",\n  Icirc: \"\\u00CE\",\n  Iuml: \"\\u00CF\",\n  ETH: \"\\u00D0\",\n  Ntilde: \"\\u00D1\",\n  Ograve: \"\\u00D2\",\n  Oacute: \"\\u00D3\",\n  Ocirc: \"\\u00D4\",\n  Otilde: \"\\u00D5\",\n  Ouml: \"\\u00D6\",\n  times: \"\\u00D7\",\n  Oslash: \"\\u00D8\",\n  Ugrave: \"\\u00D9\",\n  Uacute: \"\\u00DA\",\n  Ucirc: \"\\u00DB\",\n  Uuml: \"\\u00DC\",\n  Yacute: \"\\u00DD\",\n  THORN: \"\\u00DE\",\n  szlig: \"\\u00DF\",\n  agrave: \"\\u00E0\",\n  aacute: \"\\u00E1\",\n  acirc: \"\\u00E2\",\n  atilde: \"\\u00E3\",\n  auml: \"\\u00E4\",\n  aring: \"\\u00E5\",\n  aelig: \"\\u00E6\",\n  ccedil: \"\\u00E7\",\n  egrave: \"\\u00E8\",\n  eacute: \"\\u00E9\",\n  ecirc: \"\\u00EA\",\n  euml: \"\\u00EB\",\n  igrave: \"\\u00EC\",\n  iacute: \"\\u00ED\",\n  icirc: \"\\u00EE\",\n  iuml: \"\\u00EF\",\n  eth: \"\\u00F0\",\n  ntilde: \"\\u00F1\",\n  ograve: \"\\u00F2\",\n  oacute: \"\\u00F3\",\n  ocirc: \"\\u00F4\",\n  otilde: \"\\u00F5\",\n  ouml: \"\\u00F6\",\n  divide: \"\\u00F7\",\n  oslash: \"\\u00F8\",\n  ugrave: \"\\u00F9\",\n  uacute: \"\\u00FA\",\n  ucirc: \"\\u00FB\",\n  uuml: \"\\u00FC\",\n  yacute: \"\\u00FD\",\n  thorn: \"\\u00FE\",\n  yuml: \"\\u00FF\",\n  OElig: \"\\u0152\",\n  oelig: \"\\u0153\",\n  Scaron: \"\\u0160\",\n  scaron: \"\\u0161\",\n  Yuml: \"\\u0178\",\n  fnof: \"\\u0192\",\n  circ: \"\\u02C6\",\n  tilde: \"\\u02DC\",\n  Alpha: \"\\u0391\",\n  Beta: \"\\u0392\",\n  Gamma: \"\\u0393\",\n  Delta: \"\\u0394\",\n  Epsilon: \"\\u0395\",\n  Zeta: \"\\u0396\",\n  Eta: \"\\u0397\",\n  Theta: \"\\u0398\",\n  Iota: \"\\u0399\",\n  Kappa: \"\\u039A\",\n  Lambda: \"\\u039B\",\n  Mu: \"\\u039C\",\n  Nu: \"\\u039D\",\n  Xi: \"\\u039E\",\n  Omicron: \"\\u039F\",\n  Pi: \"\\u03A0\",\n  Rho: \"\\u03A1\",\n  Sigma: \"\\u03A3\",\n  Tau: \"\\u03A4\",\n  Upsilon: \"\\u03A5\",\n  Phi: \"\\u03A6\",\n  Chi: \"\\u03A7\",\n  Psi: \"\\u03A8\",\n  Omega: \"\\u03A9\",\n  alpha: \"\\u03B1\",\n  beta: \"\\u03B2\",\n  gamma: \"\\u03B3\",\n  delta: \"\\u03B4\",\n  epsilon: \"\\u03B5\",\n  zeta: \"\\u03B6\",\n  eta: \"\\u03B7\",\n  theta: \"\\u03B8\",\n  iota: \"\\u03B9\",\n  kappa: \"\\u03BA\",\n  lambda: \"\\u03BB\",\n  mu: \"\\u03BC\",\n  nu: \"\\u03BD\",\n  xi: \"\\u03BE\",\n  omicron: \"\\u03BF\",\n  pi: \"\\u03C0\",\n  rho: \"\\u03C1\",\n  sigmaf: \"\\u03C2\",\n  sigma: \"\\u03C3\",\n  tau: \"\\u03C4\",\n  upsilon: \"\\u03C5\",\n  phi: \"\\u03C6\",\n  chi: \"\\u03C7\",\n  psi: \"\\u03C8\",\n  omega: \"\\u03C9\",\n  thetasym: \"\\u03D1\",\n  upsih: \"\\u03D2\",\n  piv: \"\\u03D6\",\n  ensp: \"\\u2002\",\n  emsp: \"\\u2003\",\n  thinsp: \"\\u2009\",\n  zwnj: \"\\u200C\",\n  zwj: \"\\u200D\",\n  lrm: \"\\u200E\",\n  rlm: \"\\u200F\",\n  ndash: \"\\u2013\",\n  mdash: \"\\u2014\",\n  lsquo: \"\\u2018\",\n  rsquo: \"\\u2019\",\n  sbquo: \"\\u201A\",\n  ldquo: \"\\u201C\",\n  rdquo: \"\\u201D\",\n  bdquo: \"\\u201E\",\n  dagger: \"\\u2020\",\n  Dagger: \"\\u2021\",\n  bull: \"\\u2022\",\n  hellip: \"\\u2026\",\n  permil: \"\\u2030\",\n  prime: \"\\u2032\",\n  Prime: \"\\u2033\",\n  lsaquo: \"\\u2039\",\n  rsaquo: \"\\u203A\",\n  oline: \"\\u203E\",\n  frasl: \"\\u2044\",\n  euro: \"\\u20AC\",\n  image: \"\\u2111\",\n  weierp: \"\\u2118\",\n  real: \"\\u211C\",\n  trade: \"\\u2122\",\n  alefsym: \"\\u2135\",\n  larr: \"\\u2190\",\n  uarr: \"\\u2191\",\n  rarr: \"\\u2192\",\n  darr: \"\\u2193\",\n  harr: \"\\u2194\",\n  crarr: \"\\u21B5\",\n  lArr: \"\\u21D0\",\n  uArr: \"\\u21D1\",\n  rArr: \"\\u21D2\",\n  dArr: \"\\u21D3\",\n  hArr: \"\\u21D4\",\n  forall: \"\\u2200\",\n  part: \"\\u2202\",\n  exist: \"\\u2203\",\n  empty: \"\\u2205\",\n  nabla: \"\\u2207\",\n  isin: \"\\u2208\",\n  notin: \"\\u2209\",\n  ni: \"\\u220B\",\n  prod: \"\\u220F\",\n  sum: \"\\u2211\",\n  minus: \"\\u2212\",\n  lowast: \"\\u2217\",\n  radic: \"\\u221A\",\n  prop: \"\\u221D\",\n  infin: \"\\u221E\",\n  ang: \"\\u2220\",\n  and: \"\\u2227\",\n  or: \"\\u2228\",\n  cap: \"\\u2229\",\n  cup: \"\\u222A\",\n  int: \"\\u222B\",\n  there4: \"\\u2234\",\n  sim: \"\\u223C\",\n  cong: \"\\u2245\",\n  asymp: \"\\u2248\",\n  ne: \"\\u2260\",\n  equiv: \"\\u2261\",\n  le: \"\\u2264\",\n  ge: \"\\u2265\",\n  sub: \"\\u2282\",\n  sup: \"\\u2283\",\n  nsub: \"\\u2284\",\n  sube: \"\\u2286\",\n  supe: \"\\u2287\",\n  oplus: \"\\u2295\",\n  otimes: \"\\u2297\",\n  perp: \"\\u22A5\",\n  sdot: \"\\u22C5\",\n  lceil: \"\\u2308\",\n  rceil: \"\\u2309\",\n  lfloor: \"\\u230A\",\n  rfloor: \"\\u230B\",\n  lang: \"\\u2329\",\n  rang: \"\\u232A\",\n  loz: \"\\u25CA\",\n  spades: \"\\u2660\",\n  clubs: \"\\u2663\",\n  hearts: \"\\u2665\",\n  diams: \"\\u2666\",\n};\nexport default entities;\n", "\n\n\n\n\n\n\n\n\nexport default function getJSXPragmaInfo(options) {\n  const [base, suffix] = splitPragma(options.jsxPragma || \"React.createElement\");\n  const [fragmentBase, fragmentSuffix] = splitPragma(options.jsxFragmentPragma || \"React.Fragment\");\n  return {base, suffix, fragmentBase, fragmentSuffix};\n}\n\nfunction splitPragma(pragma) {\n  let dotIndex = pragma.indexOf(\".\");\n  if (dotIndex === -1) {\n    dotIndex = pragma.length;\n  }\n  return [pragma.slice(0, dotIndex), pragma.slice(dotIndex)];\n}\n", "export default  class Transformer {\n  // Return true if anything was processed, false otherwise.\n  \n\n  getPrefixCode() {\n    return \"\";\n  }\n\n  getSuffixCode() {\n    return \"\";\n  }\n}\n", "\n\n\nimport XHTMLEntities from \"../parser/plugins/jsx/xhtml\";\nimport {TokenType as tt} from \"../parser/tokenizer/types\";\nimport {charCodes} from \"../parser/util/charcodes\";\n\nimport getJSXPragmaInfo, {} from \"../util/getJSXPragmaInfo\";\n\nimport Transformer from \"./Transformer\";\n\nconst HEX_NUMBER = /^[\\da-fA-F]+$/;\nconst DECIMAL_NUMBER = /^\\d+$/;\n\nexport default class JSXTransformer extends Transformer {\n  __init() {this.lastLineNumber = 1}\n  __init2() {this.lastIndex = 0}\n  __init3() {this.filenameVarName = null}\n  \n\n  constructor(\n     rootTransformer,\n     tokens,\n     importProcessor,\n     nameManager,\n     options,\n  ) {\n    super();this.rootTransformer = rootTransformer;this.tokens = tokens;this.importProcessor = importProcessor;this.nameManager = nameManager;this.options = options;JSXTransformer.prototype.__init.call(this);JSXTransformer.prototype.__init2.call(this);JSXTransformer.prototype.__init3.call(this);;\n    this.jsxPragmaInfo = getJSXPragmaInfo(options);\n  }\n\n  process() {\n    if (this.tokens.matches1(tt.jsxTagStart)) {\n      this.processJSXTag();\n      return true;\n    }\n    return false;\n  }\n\n  getPrefixCode() {\n    if (this.filenameVarName) {\n      return `const ${this.filenameVarName} = ${JSON.stringify(this.options.filePath || \"\")};`;\n    } else {\n      return \"\";\n    }\n  }\n\n  /**\n   * Lazily calculate line numbers to avoid unneeded work. We assume this is always called in\n   * increasing order by index.\n   */\n  getLineNumberForIndex(index) {\n    const code = this.tokens.code;\n    while (this.lastIndex < index && this.lastIndex < code.length) {\n      if (code[this.lastIndex] === \"\\n\") {\n        this.lastLineNumber++;\n      }\n      this.lastIndex++;\n    }\n    return this.lastLineNumber;\n  }\n\n  getFilenameVarName() {\n    if (!this.filenameVarName) {\n      this.filenameVarName = this.nameManager.claimFreeName(\"_jsxFileName\");\n    }\n    return this.filenameVarName;\n  }\n\n  processProps(firstTokenStart) {\n    const lineNumber = this.getLineNumberForIndex(firstTokenStart);\n    const devProps = this.options.production\n      ? \"\"\n      : `__self: this, __source: {fileName: ${this.getFilenameVarName()}, lineNumber: ${lineNumber}}`;\n    if (!this.tokens.matches1(tt.jsxName) && !this.tokens.matches1(tt.braceL)) {\n      if (devProps) {\n        this.tokens.appendCode(`, {${devProps}}`);\n      } else {\n        this.tokens.appendCode(`, null`);\n      }\n      return;\n    }\n    this.tokens.appendCode(`, {`);\n    while (true) {\n      if (this.tokens.matches2(tt.jsxName, tt.eq)) {\n        this.processPropKeyName();\n        this.tokens.replaceToken(\": \");\n        if (this.tokens.matches1(tt.braceL)) {\n          this.tokens.replaceToken(\"\");\n          this.rootTransformer.processBalancedCode();\n          this.tokens.replaceToken(\"\");\n        } else if (this.tokens.matches1(tt.jsxTagStart)) {\n          this.processJSXTag();\n        } else {\n          this.processStringPropValue();\n        }\n      } else if (this.tokens.matches1(tt.jsxName)) {\n        this.processPropKeyName();\n        this.tokens.appendCode(\": true\");\n      } else if (this.tokens.matches1(tt.braceL)) {\n        this.tokens.replaceToken(\"\");\n        this.rootTransformer.processBalancedCode();\n        this.tokens.replaceToken(\"\");\n      } else {\n        break;\n      }\n      this.tokens.appendCode(\",\");\n    }\n    if (devProps) {\n      this.tokens.appendCode(` ${devProps}}`);\n    } else {\n      this.tokens.appendCode(\"}\");\n    }\n  }\n\n  processPropKeyName() {\n    const keyName = this.tokens.identifierName();\n    if (keyName.includes(\"-\")) {\n      this.tokens.replaceToken(`'${keyName}'`);\n    } else {\n      this.tokens.copyToken();\n    }\n  }\n\n  processStringPropValue() {\n    const token = this.tokens.currentToken();\n    const valueCode = this.tokens.code.slice(token.start + 1, token.end - 1);\n    const replacementCode = formatJSXTextReplacement(valueCode);\n    const literalCode = formatJSXStringValueLiteral(valueCode);\n    this.tokens.replaceToken(literalCode + replacementCode);\n  }\n\n  /**\n   * Process the first part of a tag, before any props.\n   */\n  processTagIntro() {\n    // Walk forward until we see one of these patterns:\n    // jsxName to start the first prop, preceded by another jsxName to end the tag name.\n    // jsxName to start the first prop, preceded by greaterThan to end the type argument.\n    // [open brace] to start the first prop.\n    // [jsxTagEnd] to end the open-tag.\n    // [slash, jsxTagEnd] to end the self-closing tag.\n    let introEnd = this.tokens.currentIndex() + 1;\n    while (\n      this.tokens.tokens[introEnd].isType ||\n      (!this.tokens.matches2AtIndex(introEnd - 1, tt.jsxName, tt.jsxName) &&\n        !this.tokens.matches2AtIndex(introEnd - 1, tt.greaterThan, tt.jsxName) &&\n        !this.tokens.matches1AtIndex(introEnd, tt.braceL) &&\n        !this.tokens.matches1AtIndex(introEnd, tt.jsxTagEnd) &&\n        !this.tokens.matches2AtIndex(introEnd, tt.slash, tt.jsxTagEnd))\n    ) {\n      introEnd++;\n    }\n    if (introEnd === this.tokens.currentIndex() + 1) {\n      const tagName = this.tokens.identifierName();\n      if (startsWithLowerCase(tagName)) {\n        this.tokens.replaceToken(`'${tagName}'`);\n      }\n    }\n    while (this.tokens.currentIndex() < introEnd) {\n      this.rootTransformer.processToken();\n    }\n  }\n\n  processChildren() {\n    while (true) {\n      if (this.tokens.matches2(tt.jsxTagStart, tt.slash)) {\n        // Closing tag, so no more children.\n        return;\n      }\n      if (this.tokens.matches1(tt.braceL)) {\n        if (this.tokens.matches2(tt.braceL, tt.braceR)) {\n          // Empty interpolations and comment-only interpolations are allowed\n          // and don't create an extra child arg.\n          this.tokens.replaceToken(\"\");\n          this.tokens.replaceToken(\"\");\n        } else {\n          // Interpolated expression.\n          this.tokens.replaceToken(\", \");\n          this.rootTransformer.processBalancedCode();\n          this.tokens.replaceToken(\"\");\n        }\n      } else if (this.tokens.matches1(tt.jsxTagStart)) {\n        // Child JSX element\n        this.tokens.appendCode(\", \");\n        this.processJSXTag();\n      } else if (this.tokens.matches1(tt.jsxText)) {\n        this.processChildTextElement();\n      } else {\n        throw new Error(\"Unexpected token when processing JSX children.\");\n      }\n    }\n  }\n\n  processChildTextElement() {\n    const token = this.tokens.currentToken();\n    const valueCode = this.tokens.code.slice(token.start, token.end);\n    const replacementCode = formatJSXTextReplacement(valueCode);\n    const literalCode = formatJSXTextLiteral(valueCode);\n    if (literalCode === '\"\"') {\n      this.tokens.replaceToken(replacementCode);\n    } else {\n      this.tokens.replaceToken(`, ${literalCode}${replacementCode}`);\n    }\n  }\n\n  processJSXTag() {\n    const {jsxPragmaInfo} = this;\n    const resolvedPragmaBaseName = this.importProcessor\n      ? this.importProcessor.getIdentifierReplacement(jsxPragmaInfo.base) || jsxPragmaInfo.base\n      : jsxPragmaInfo.base;\n    const firstTokenStart = this.tokens.currentToken().start;\n    // First tag is always jsxTagStart.\n    this.tokens.replaceToken(`${resolvedPragmaBaseName}${jsxPragmaInfo.suffix}(`);\n\n    if (this.tokens.matches1(tt.jsxTagEnd)) {\n      // Fragment syntax.\n      const resolvedFragmentPragmaBaseName = this.importProcessor\n        ? this.importProcessor.getIdentifierReplacement(jsxPragmaInfo.fragmentBase) ||\n          jsxPragmaInfo.fragmentBase\n        : jsxPragmaInfo.fragmentBase;\n      this.tokens.replaceToken(\n        `${resolvedFragmentPragmaBaseName}${jsxPragmaInfo.fragmentSuffix}, null`,\n      );\n      // Tag with children.\n      this.processChildren();\n      while (!this.tokens.matches1(tt.jsxTagEnd)) {\n        this.tokens.replaceToken(\"\");\n      }\n      this.tokens.replaceToken(\")\");\n    } else {\n      // Normal open tag or self-closing tag.\n      this.processTagIntro();\n      this.processProps(firstTokenStart);\n\n      if (this.tokens.matches2(tt.slash, tt.jsxTagEnd)) {\n        // Self-closing tag.\n        this.tokens.replaceToken(\"\");\n        this.tokens.replaceToken(\")\");\n      } else if (this.tokens.matches1(tt.jsxTagEnd)) {\n        this.tokens.replaceToken(\"\");\n        // Tag with children.\n        this.processChildren();\n        while (!this.tokens.matches1(tt.jsxTagEnd)) {\n          this.tokens.replaceToken(\"\");\n        }\n        this.tokens.replaceToken(\")\");\n      } else {\n        throw new Error(\"Expected either /> or > at the end of the tag.\");\n      }\n    }\n  }\n}\n\n/**\n * Spec for identifiers: https://tc39.github.io/ecma262/#prod-IdentifierStart.\n *\n * Really only treat anything starting with a-z as tag names.  `_`, `$`, `\u00E9`\n * should be treated as copmonent names\n */\nexport function startsWithLowerCase(s) {\n  const firstChar = s.charCodeAt(0);\n  return firstChar >= charCodes.lowercaseA && firstChar <= charCodes.lowercaseZ;\n}\n\n/**\n * Turn the given jsxText string into a JS string literal. Leading and trailing\n * whitespace on lines is removed, except immediately after the open-tag and\n * before the close-tag. Empty lines are completely removed, and spaces are\n * added between lines after that.\n *\n * We use JSON.stringify to introduce escape characters as necessary, and trim\n * the start and end of each line and remove blank lines.\n */\nfunction formatJSXTextLiteral(text) {\n  let result = \"\";\n  let whitespace = \"\";\n\n  let isInInitialLineWhitespace = false;\n  let seenNonWhitespace = false;\n  for (let i = 0; i < text.length; i++) {\n    const c = text[i];\n    if (c === \" \" || c === \"\\t\" || c === \"\\r\") {\n      if (!isInInitialLineWhitespace) {\n        whitespace += c;\n      }\n    } else if (c === \"\\n\") {\n      whitespace = \"\";\n      isInInitialLineWhitespace = true;\n    } else {\n      if (seenNonWhitespace && isInInitialLineWhitespace) {\n        result += \" \";\n      }\n      result += whitespace;\n      whitespace = \"\";\n      if (c === \"&\") {\n        const {entity, newI} = processEntity(text, i + 1);\n        i = newI - 1;\n        result += entity;\n      } else {\n        result += c;\n      }\n      seenNonWhitespace = true;\n      isInInitialLineWhitespace = false;\n    }\n  }\n  if (!isInInitialLineWhitespace) {\n    result += whitespace;\n  }\n  return JSON.stringify(result);\n}\n\n/**\n * Produce the code that should be printed after the JSX text string literal,\n * with most content removed, but all newlines preserved and all spacing at the\n * end preserved.\n */\nfunction formatJSXTextReplacement(text) {\n  let numNewlines = 0;\n  let numSpaces = 0;\n  for (const c of text) {\n    if (c === \"\\n\") {\n      numNewlines++;\n      numSpaces = 0;\n    } else if (c === \" \") {\n      numSpaces++;\n    }\n  }\n  return \"\\n\".repeat(numNewlines) + \" \".repeat(numSpaces);\n}\n\n/**\n * Format a string in the value position of a JSX prop.\n *\n * Use the same implementation as convertAttribute from\n * babel-helper-builder-react-jsx.\n */\nfunction formatJSXStringValueLiteral(text) {\n  let result = \"\";\n  for (let i = 0; i < text.length; i++) {\n    const c = text[i];\n    if (c === \"\\n\") {\n      if (/\\s/.test(text[i + 1])) {\n        result += \" \";\n        while (i < text.length && /\\s/.test(text[i + 1])) {\n          i++;\n        }\n      } else {\n        result += \"\\n\";\n      }\n    } else if (c === \"&\") {\n      const {entity, newI} = processEntity(text, i + 1);\n      result += entity;\n      i = newI - 1;\n    } else {\n      result += c;\n    }\n  }\n  return JSON.stringify(result);\n}\n\n/**\n * Modified from jsxReadString in Babylon.\n */\nfunction processEntity(text, indexAfterAmpersand) {\n  let str = \"\";\n  let count = 0;\n  let entity;\n  let i = indexAfterAmpersand;\n\n  while (i < text.length && count++ < 10) {\n    const ch = text[i];\n    i++;\n    if (ch === \";\") {\n      if (str[0] === \"#\") {\n        if (str[1] === \"x\") {\n          str = str.substr(2);\n          if (HEX_NUMBER.test(str)) {\n            entity = String.fromCodePoint(parseInt(str, 16));\n          }\n        } else {\n          str = str.substr(1);\n          if (DECIMAL_NUMBER.test(str)) {\n            entity = String.fromCodePoint(parseInt(str, 10));\n          }\n        }\n      } else {\n        entity = XHTMLEntities[str];\n      }\n      break;\n    }\n    str += ch;\n  }\n  if (!entity) {\n    return {entity: \"&\", newI: indexAfterAmpersand};\n  }\n  return {entity, newI: i};\n}\n", "\nimport {IdentifierRole} from \"../parser/tokenizer\";\nimport {TokenType, TokenType as tt} from \"../parser/tokenizer/types\";\n\nimport {startsWithLowerCase} from \"../transformers/JSXTransformer\";\nimport getJSXPragmaInfo from \"./getJSXPragmaInfo\";\n\nexport function getNonTypeIdentifiers(tokens, options) {\n  const jsxPragmaInfo = getJSXPragmaInfo(options);\n  const nonTypeIdentifiers = new Set();\n  for (let i = 0; i < tokens.tokens.length; i++) {\n    const token = tokens.tokens[i];\n    if (\n      token.type === tt.name &&\n      !token.isType &&\n      (token.identifierRole === IdentifierRole.Access ||\n        token.identifierRole === IdentifierRole.ObjectShorthand ||\n        token.identifierRole === IdentifierRole.ExportAccess) &&\n      !token.shadowsGlobal\n    ) {\n      nonTypeIdentifiers.add(tokens.identifierNameForToken(token));\n    }\n    if (token.type === tt.jsxTagStart) {\n      nonTypeIdentifiers.add(jsxPragmaInfo.base);\n    }\n    if (\n      token.type === tt.jsxTagStart &&\n      i + 1 < tokens.tokens.length &&\n      tokens.tokens[i + 1].type === tt.jsxTagEnd\n    ) {\n      nonTypeIdentifiers.add(jsxPragmaInfo.base);\n      nonTypeIdentifiers.add(jsxPragmaInfo.fragmentBase);\n    }\n    if (token.type === tt.jsxName && token.identifierRole === IdentifierRole.Access) {\n      const identifierName = tokens.identifierNameForToken(token);\n      // Lower-case single-component tag names like \"div\" don't count.\n      if (!startsWithLowerCase(identifierName) || tokens.tokens[i + 1].type === TokenType.dot) {\n        nonTypeIdentifiers.add(tokens.identifierNameForToken(token));\n      }\n    }\n  }\n  return nonTypeIdentifiers;\n}\n", "\n\n\nimport {isDeclaration} from \"./parser/tokenizer\";\nimport {ContextualKeyword} from \"./parser/tokenizer/keywords\";\nimport {TokenType as tt} from \"./parser/tokenizer/types\";\n\nimport {getNonTypeIdentifiers} from \"./util/getNonTypeIdentifiers\";\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Class responsible for preprocessing and bookkeeping import and export declarations within the\n * file.\n *\n * TypeScript uses a simpler mechanism that does not use functions like interopRequireDefault and\n * interopRequireWildcard, so we also allow that mode for compatibility.\n */\nexport default class CJSImportProcessor {\n   __init() {this.nonTypeIdentifiers = new Set()}\n   __init2() {this.importInfoByPath = new Map()}\n   __init3() {this.importsToReplace = new Map()}\n   __init4() {this.identifierReplacements = new Map()}\n   __init5() {this.exportBindingsByLocalName = new Map()}\n\n  constructor(\n     nameManager,\n     tokens,\n     enableLegacyTypeScriptModuleInterop,\n     options,\n     isTypeScriptTransformEnabled,\n     helperManager,\n  ) {;this.nameManager = nameManager;this.tokens = tokens;this.enableLegacyTypeScriptModuleInterop = enableLegacyTypeScriptModuleInterop;this.options = options;this.isTypeScriptTransformEnabled = isTypeScriptTransformEnabled;this.helperManager = helperManager;CJSImportProcessor.prototype.__init.call(this);CJSImportProcessor.prototype.__init2.call(this);CJSImportProcessor.prototype.__init3.call(this);CJSImportProcessor.prototype.__init4.call(this);CJSImportProcessor.prototype.__init5.call(this);}\n\n  preprocessTokens() {\n    for (let i = 0; i < this.tokens.tokens.length; i++) {\n      if (\n        this.tokens.matches1AtIndex(i, tt._import) &&\n        !this.tokens.matches3AtIndex(i, tt._import, tt.name, tt.eq)\n      ) {\n        this.preprocessImportAtIndex(i);\n      }\n      if (\n        this.tokens.matches1AtIndex(i, tt._export) &&\n        !this.tokens.matches2AtIndex(i, tt._export, tt.eq)\n      ) {\n        this.preprocessExportAtIndex(i);\n      }\n    }\n    this.generateImportReplacements();\n  }\n\n  /**\n   * In TypeScript, import statements that only import types should be removed. This does not count\n   * bare imports.\n   */\n  pruneTypeOnlyImports() {\n    this.nonTypeIdentifiers = getNonTypeIdentifiers(this.tokens, this.options);\n    for (const [path, importInfo] of this.importInfoByPath.entries()) {\n      if (\n        importInfo.hasBareImport ||\n        importInfo.hasStarExport ||\n        importInfo.exportStarNames.length > 0 ||\n        importInfo.namedExports.length > 0\n      ) {\n        continue;\n      }\n      const names = [\n        ...importInfo.defaultNames,\n        ...importInfo.wildcardNames,\n        ...importInfo.namedImports.map(({localName}) => localName),\n      ];\n      if (names.every((name) => this.isTypeName(name))) {\n        this.importsToReplace.set(path, \"\");\n      }\n    }\n  }\n\n  isTypeName(name) {\n    return this.isTypeScriptTransformEnabled && !this.nonTypeIdentifiers.has(name);\n  }\n\n   generateImportReplacements() {\n    for (const [path, importInfo] of this.importInfoByPath.entries()) {\n      const {\n        defaultNames,\n        wildcardNames,\n        namedImports,\n        namedExports,\n        exportStarNames,\n        hasStarExport,\n      } = importInfo;\n\n      if (\n        defaultNames.length === 0 &&\n        wildcardNames.length === 0 &&\n        namedImports.length === 0 &&\n        namedExports.length === 0 &&\n        exportStarNames.length === 0 &&\n        !hasStarExport\n      ) {\n        // Import is never used, so don't even assign a name.\n        this.importsToReplace.set(path, `require('${path}');`);\n        continue;\n      }\n\n      const primaryImportName = this.getFreeIdentifierForPath(path);\n      let secondaryImportName;\n      if (this.enableLegacyTypeScriptModuleInterop) {\n        secondaryImportName = primaryImportName;\n      } else {\n        secondaryImportName =\n          wildcardNames.length > 0 ? wildcardNames[0] : this.getFreeIdentifierForPath(path);\n      }\n      let requireCode = `var ${primaryImportName} = require('${path}');`;\n      if (wildcardNames.length > 0) {\n        for (const wildcardName of wildcardNames) {\n          const moduleExpr = this.enableLegacyTypeScriptModuleInterop\n            ? primaryImportName\n            : `${this.helperManager.getHelperName(\"interopRequireWildcard\")}(${primaryImportName})`;\n          requireCode += ` var ${wildcardName} = ${moduleExpr};`;\n        }\n      } else if (exportStarNames.length > 0 && secondaryImportName !== primaryImportName) {\n        requireCode += ` var ${secondaryImportName} = ${this.helperManager.getHelperName(\n          \"interopRequireWildcard\",\n        )}(${primaryImportName});`;\n      } else if (defaultNames.length > 0 && secondaryImportName !== primaryImportName) {\n        requireCode += ` var ${secondaryImportName} = ${this.helperManager.getHelperName(\n          \"interopRequireDefault\",\n        )}(${primaryImportName});`;\n      }\n\n      for (const {importedName, localName} of namedExports) {\n        requireCode += ` ${this.helperManager.getHelperName(\n          \"createNamedExportFrom\",\n        )}(${primaryImportName}, '${localName}', '${importedName}');`;\n      }\n      for (const exportStarName of exportStarNames) {\n        requireCode += ` exports.${exportStarName} = ${secondaryImportName};`;\n      }\n      if (hasStarExport) {\n        requireCode += ` ${this.helperManager.getHelperName(\n          \"createStarExport\",\n        )}(${primaryImportName});`;\n      }\n\n      this.importsToReplace.set(path, requireCode);\n\n      for (const defaultName of defaultNames) {\n        this.identifierReplacements.set(defaultName, `${secondaryImportName}.default`);\n      }\n      for (const {importedName, localName} of namedImports) {\n        this.identifierReplacements.set(localName, `${primaryImportName}.${importedName}`);\n      }\n    }\n  }\n\n   getFreeIdentifierForPath(path) {\n    const components = path.split(\"/\");\n    const lastComponent = components[components.length - 1];\n    const baseName = lastComponent.replace(/\\W/g, \"\");\n    return this.nameManager.claimFreeName(`_${baseName}`);\n  }\n\n   preprocessImportAtIndex(index) {\n    const defaultNames = [];\n    const wildcardNames = [];\n    let namedImports = [];\n\n    index++;\n    if (\n      (this.tokens.matchesContextualAtIndex(index, ContextualKeyword._type) ||\n        this.tokens.matches1AtIndex(index, tt._typeof)) &&\n      !this.tokens.matches1AtIndex(index + 1, tt.comma) &&\n      !this.tokens.matchesContextualAtIndex(index + 1, ContextualKeyword._from)\n    ) {\n      // import type declaration, so no need to process anything.\n      return;\n    }\n\n    if (this.tokens.matches1AtIndex(index, tt.parenL)) {\n      // Dynamic import, so nothing to do\n      return;\n    }\n\n    if (this.tokens.matches1AtIndex(index, tt.name)) {\n      defaultNames.push(this.tokens.identifierNameAtIndex(index));\n      index++;\n      if (this.tokens.matches1AtIndex(index, tt.comma)) {\n        index++;\n      }\n    }\n\n    if (this.tokens.matches1AtIndex(index, tt.star)) {\n      // * as\n      index += 2;\n      wildcardNames.push(this.tokens.identifierNameAtIndex(index));\n      index++;\n    }\n\n    if (this.tokens.matches1AtIndex(index, tt.braceL)) {\n      index++;\n      ({newIndex: index, namedImports} = this.getNamedImports(index));\n    }\n\n    if (this.tokens.matchesContextualAtIndex(index, ContextualKeyword._from)) {\n      index++;\n    }\n\n    if (!this.tokens.matches1AtIndex(index, tt.string)) {\n      throw new Error(\"Expected string token at the end of import statement.\");\n    }\n    const path = this.tokens.stringValueAtIndex(index);\n    const importInfo = this.getImportInfo(path);\n    importInfo.defaultNames.push(...defaultNames);\n    importInfo.wildcardNames.push(...wildcardNames);\n    importInfo.namedImports.push(...namedImports);\n    if (defaultNames.length === 0 && wildcardNames.length === 0 && namedImports.length === 0) {\n      importInfo.hasBareImport = true;\n    }\n  }\n\n   preprocessExportAtIndex(index) {\n    if (\n      this.tokens.matches2AtIndex(index, tt._export, tt._var) ||\n      this.tokens.matches2AtIndex(index, tt._export, tt._let) ||\n      this.tokens.matches2AtIndex(index, tt._export, tt._const)\n    ) {\n      this.preprocessVarExportAtIndex(index);\n    } else if (\n      this.tokens.matches2AtIndex(index, tt._export, tt._function) ||\n      this.tokens.matches2AtIndex(index, tt._export, tt._class)\n    ) {\n      const exportName = this.tokens.identifierNameAtIndex(index + 2);\n      this.addExportBinding(exportName, exportName);\n    } else if (this.tokens.matches3AtIndex(index, tt._export, tt.name, tt._function)) {\n      const exportName = this.tokens.identifierNameAtIndex(index + 3);\n      this.addExportBinding(exportName, exportName);\n    } else if (this.tokens.matches2AtIndex(index, tt._export, tt.braceL)) {\n      this.preprocessNamedExportAtIndex(index);\n    } else if (this.tokens.matches2AtIndex(index, tt._export, tt.star)) {\n      this.preprocessExportStarAtIndex(index);\n    }\n  }\n\n   preprocessVarExportAtIndex(index) {\n    let depth = 0;\n    // Handle cases like `export let {x} = y;`, starting at the open-brace in that case.\n    for (let i = index + 2; ; i++) {\n      if (\n        this.tokens.matches1AtIndex(i, tt.braceL) ||\n        this.tokens.matches1AtIndex(i, tt.dollarBraceL) ||\n        this.tokens.matches1AtIndex(i, tt.bracketL)\n      ) {\n        depth++;\n      } else if (\n        this.tokens.matches1AtIndex(i, tt.braceR) ||\n        this.tokens.matches1AtIndex(i, tt.bracketR)\n      ) {\n        depth--;\n      } else if (depth === 0 && !this.tokens.matches1AtIndex(i, tt.name)) {\n        break;\n      } else if (this.tokens.matches1AtIndex(1, tt.eq)) {\n        const endIndex = this.tokens.currentToken().rhsEndIndex;\n        if (endIndex == null) {\n          throw new Error(\"Expected = token with an end index.\");\n        }\n        i = endIndex - 1;\n      } else {\n        const token = this.tokens.tokens[i];\n        if (isDeclaration(token)) {\n          const exportName = this.tokens.identifierNameAtIndex(i);\n          this.identifierReplacements.set(exportName, `exports.${exportName}`);\n        }\n      }\n    }\n  }\n\n  /**\n   * Walk this export statement just in case it's an export...from statement.\n   * If it is, combine it into the import info for that path. Otherwise, just\n   * bail out; it'll be handled later.\n   */\n   preprocessNamedExportAtIndex(index) {\n    // export {\n    index += 2;\n    const {newIndex, namedImports} = this.getNamedImports(index);\n    index = newIndex;\n\n    if (this.tokens.matchesContextualAtIndex(index, ContextualKeyword._from)) {\n      index++;\n    } else {\n      // Reinterpret \"a as b\" to be local/exported rather than imported/local.\n      for (const {importedName: localName, localName: exportedName} of namedImports) {\n        this.addExportBinding(localName, exportedName);\n      }\n      return;\n    }\n\n    if (!this.tokens.matches1AtIndex(index, tt.string)) {\n      throw new Error(\"Expected string token at the end of import statement.\");\n    }\n    const path = this.tokens.stringValueAtIndex(index);\n    const importInfo = this.getImportInfo(path);\n    importInfo.namedExports.push(...namedImports);\n  }\n\n   preprocessExportStarAtIndex(index) {\n    let exportedName = null;\n    if (this.tokens.matches3AtIndex(index, tt._export, tt.star, tt._as)) {\n      // export * as\n      index += 3;\n      exportedName = this.tokens.identifierNameAtIndex(index);\n      // foo from\n      index += 2;\n    } else {\n      // export * from\n      index += 3;\n    }\n    if (!this.tokens.matches1AtIndex(index, tt.string)) {\n      throw new Error(\"Expected string token at the end of star export statement.\");\n    }\n    const path = this.tokens.stringValueAtIndex(index);\n    const importInfo = this.getImportInfo(path);\n    if (exportedName !== null) {\n      importInfo.exportStarNames.push(exportedName);\n    } else {\n      importInfo.hasStarExport = true;\n    }\n  }\n\n   getNamedImports(index) {\n    const namedImports = [];\n    while (true) {\n      if (this.tokens.matches1AtIndex(index, tt.braceR)) {\n        index++;\n        break;\n      }\n\n      // Flow type imports should just be ignored.\n      let isTypeImport = false;\n      if (\n        (this.tokens.matchesContextualAtIndex(index, ContextualKeyword._type) ||\n          this.tokens.matches1AtIndex(index, tt._typeof)) &&\n        this.tokens.matches1AtIndex(index + 1, tt.name) &&\n        !this.tokens.matchesContextualAtIndex(index + 1, ContextualKeyword._as)\n      ) {\n        isTypeImport = true;\n        index++;\n      }\n\n      const importedName = this.tokens.identifierNameAtIndex(index);\n      let localName;\n      index++;\n      if (this.tokens.matchesContextualAtIndex(index, ContextualKeyword._as)) {\n        index++;\n        localName = this.tokens.identifierNameAtIndex(index);\n        index++;\n      } else {\n        localName = importedName;\n      }\n      if (!isTypeImport) {\n        namedImports.push({importedName, localName});\n      }\n      if (this.tokens.matches2AtIndex(index, tt.comma, tt.braceR)) {\n        index += 2;\n        break;\n      } else if (this.tokens.matches1AtIndex(index, tt.braceR)) {\n        index++;\n        break;\n      } else if (this.tokens.matches1AtIndex(index, tt.comma)) {\n        index++;\n      } else {\n        throw new Error(`Unexpected token: ${JSON.stringify(this.tokens.tokens[index])}`);\n      }\n    }\n    return {newIndex: index, namedImports};\n  }\n\n  /**\n   * Get a mutable import info object for this path, creating one if it doesn't\n   * exist yet.\n   */\n   getImportInfo(path) {\n    const existingInfo = this.importInfoByPath.get(path);\n    if (existingInfo) {\n      return existingInfo;\n    }\n    const newInfo = {\n      defaultNames: [],\n      wildcardNames: [],\n      namedImports: [],\n      namedExports: [],\n      hasBareImport: false,\n      exportStarNames: [],\n      hasStarExport: false,\n    };\n    this.importInfoByPath.set(path, newInfo);\n    return newInfo;\n  }\n\n   addExportBinding(localName, exportedName) {\n    if (!this.exportBindingsByLocalName.has(localName)) {\n      this.exportBindingsByLocalName.set(localName, []);\n    }\n    this.exportBindingsByLocalName.get(localName).push(exportedName);\n  }\n\n  /**\n   * Return the code to use for the import for this path, or the empty string if\n   * the code has already been \"claimed\" by a previous import.\n   */\n  claimImportCode(importPath) {\n    const result = this.importsToReplace.get(importPath);\n    this.importsToReplace.set(importPath, \"\");\n    return result || \"\";\n  }\n\n  getIdentifierReplacement(identifierName) {\n    return this.identifierReplacements.get(identifierName) || null;\n  }\n\n  /**\n   * Return a string like `exports.foo = exports.bar`.\n   */\n  resolveExportBinding(assignedName) {\n    const exportedNames = this.exportBindingsByLocalName.get(assignedName);\n    if (!exportedNames || exportedNames.length === 0) {\n      return null;\n    }\n    return exportedNames.map((exportedName) => `exports.${exportedName}`).join(\" = \");\n  }\n\n  /**\n   * Return all imported/exported names where we might be interested in whether usages of those\n   * names are shadowed.\n   */\n  getGlobalNames() {\n    return new Set([\n      ...this.identifierReplacements.keys(),\n      ...this.exportBindingsByLocalName.keys(),\n    ]);\n  }\n}\n", "\nimport {charCodes} from \"./parser/util/charcodes\";\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Generate a simple source map indicating that each line maps directly to the original line.\n */\nexport default function computeSourceMap(\n  code,\n  filePath,\n  {compiledFilename},\n) {\n  let mappings = \"AAAA\";\n  for (let i = 0; i < code.length; i++) {\n    if (code.charCodeAt(i) === charCodes.lineFeed) {\n      mappings += \";AACA\";\n    }\n  }\n  return {\n    version: 3,\n    file: compiledFilename || \"\",\n    sources: [filePath],\n    mappings,\n    names: [],\n  };\n}\n", "\n\nconst HELPERS = {\n  interopRequireWildcard: `\n    function interopRequireWildcard(obj) {\n      if (obj && obj.__esModule) {\n        return obj;\n      } else {\n        var newObj = {};\n        if (obj != null) {\n          for (var key in obj) {\n            if (Object.prototype.hasOwnProperty.call(obj, key)) {\n              newObj[key] = obj[key];\n            }\n          }\n        }\n        newObj.default = obj;\n        return newObj;\n      }\n    }\n  `,\n  interopRequireDefault: `\n    function interopRequireDefault(obj) {\n      return obj && obj.__esModule ? obj : { default: obj };\n    }\n  `,\n  createNamedExportFrom: `\n    function createNamedExportFrom(obj, localName, importedName) {\n      Object.defineProperty(exports, localName, {enumerable: true, get: () => obj[importedName]});\n    }\n  `,\n  // Note that TypeScript and Babel do this differently; TypeScript does a simple existence\n  // check in the exports object and does a plain assignment, whereas Babel uses\n  // defineProperty and builds an object of explicitly-exported names so that star exports can\n  // always take lower precedence. For now, we do the easier TypeScript thing.\n  createStarExport: `\n    function createStarExport(obj) {\n      Object.keys(obj)\n        .filter((key) => key !== \"default\" && key !== \"__esModule\")\n        .forEach((key) => {\n          if (exports.hasOwnProperty(key)) {\n            return;\n          }\n          Object.defineProperty(exports, key, {enumerable: true, get: () => obj[key]});\n        });\n    }\n  `,\n  nullishCoalesce: `\n    function nullishCoalesce(lhs, rhsFn) {\n      if (lhs != null) {\n        return lhs;\n      } else {\n        return rhsFn();\n      }\n    }\n  `,\n  asyncNullishCoalesce: `\n    async function asyncNullishCoalesce(lhs, rhsFn) {\n      if (lhs != null) {\n        return lhs;\n      } else {\n        return await rhsFn();\n      }\n    }\n  `,\n  optionalChain: `\n    function optionalChain(ops) {\n      let lastAccessLHS = undefined;\n      let value = ops[0];\n      let i = 1;\n      while (i < ops.length) {\n        const op = ops[i];\n        const fn = ops[i + 1];\n        i += 2;\n        if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) {\n          return undefined;\n        }\n        if (op === 'access' || op === 'optionalAccess') {\n          lastAccessLHS = value;\n          value = fn(value);\n        } else if (op === 'call' || op === 'optionalCall') {\n          value = fn((...args) => value.call(lastAccessLHS, ...args));\n          lastAccessLHS = undefined;\n        }\n      }\n      return value;\n    }\n  `,\n  asyncOptionalChain: `\n    async function asyncOptionalChain(ops) {\n      let lastAccessLHS = undefined;\n      let value = ops[0];\n      let i = 1;\n      while (i < ops.length) {\n        const op = ops[i];\n        const fn = ops[i + 1];\n        i += 2;\n        if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) {\n          return undefined;\n        }\n        if (op === 'access' || op === 'optionalAccess') {\n          lastAccessLHS = value;\n          value = await fn(value);\n        } else if (op === 'call' || op === 'optionalCall') {\n          value = await fn((...args) => value.call(lastAccessLHS, ...args));\n          lastAccessLHS = undefined;\n        }\n      }\n      return value;\n    }\n  `,\n  optionalChainDelete: `\n    function optionalChainDelete(ops) {\n      const result = OPTIONAL_CHAIN_NAME(ops);\n      return result == null ? true : result;\n    }\n  `,\n  asyncOptionalChainDelete: `\n    async function asyncOptionalChainDelete(ops) {\n      const result = await ASYNC_OPTIONAL_CHAIN_NAME(ops);\n      return result == null ? true : result;\n    }\n  `,\n};\n\nexport class HelperManager {\n  __init() {this.helperNames = {}}\n  constructor( nameManager) {;this.nameManager = nameManager;HelperManager.prototype.__init.call(this);}\n\n  getHelperName(baseName) {\n    let helperName = this.helperNames[baseName];\n    if (helperName) {\n      return helperName;\n    }\n    helperName = this.nameManager.claimFreeName(`_${baseName}`);\n    this.helperNames[baseName] = helperName;\n    return helperName;\n  }\n\n  emitHelpers() {\n    let resultCode = \"\";\n    if (this.helperNames.optionalChainDelete) {\n      this.getHelperName(\"optionalChain\");\n    }\n    if (this.helperNames.asyncOptionalChainDelete) {\n      this.getHelperName(\"asyncOptionalChain\");\n    }\n    for (const [baseName, helperCodeTemplate] of Object.entries(HELPERS)) {\n      const helperName = this.helperNames[baseName];\n      let helperCode = helperCodeTemplate;\n      if (baseName === \"optionalChainDelete\") {\n        helperCode = helperCode.replace(\"OPTIONAL_CHAIN_NAME\", this.helperNames.optionalChain);\n      } else if (baseName === \"asyncOptionalChainDelete\") {\n        helperCode = helperCode.replace(\n          \"ASYNC_OPTIONAL_CHAIN_NAME\",\n          this.helperNames.asyncOptionalChain,\n        );\n      }\n      if (helperName) {\n        resultCode += \" \";\n        resultCode += helperCode.replace(baseName, helperName).replace(/\\s+/g, \" \").trim();\n      }\n    }\n    return resultCode;\n  }\n}\n", "import {\n  isBlockScopedDeclaration,\n  isFunctionScopedDeclaration,\n  isNonTopLevelDeclaration,\n} from \"./parser/tokenizer\";\n\nimport {TokenType as tt} from \"./parser/tokenizer/types\";\n\n\n/**\n * Traverse the given tokens and modify them if necessary to indicate that some names shadow global\n * variables.\n */\nexport default function identifyShadowedGlobals(\n  tokens,\n  scopes,\n  globalNames,\n) {\n  if (!hasShadowedGlobals(tokens, globalNames)) {\n    return;\n  }\n  markShadowedGlobals(tokens, scopes, globalNames);\n}\n\n/**\n * We can do a fast up-front check to see if there are any declarations to global names. If not,\n * then there's no point in computing scope assignments.\n */\n// Exported for testing.\nexport function hasShadowedGlobals(tokens, globalNames) {\n  for (const token of tokens.tokens) {\n    if (\n      token.type === tt.name &&\n      isNonTopLevelDeclaration(token) &&\n      globalNames.has(tokens.identifierNameForToken(token))\n    ) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction markShadowedGlobals(\n  tokens,\n  scopes,\n  globalNames,\n) {\n  const scopeStack = [];\n  let scopeIndex = scopes.length - 1;\n  // Scopes were generated at completion time, so they're sorted by end index, so we can maintain a\n  // good stack by going backwards through them.\n  for (let i = tokens.tokens.length - 1; ; i--) {\n    while (scopeStack.length > 0 && scopeStack[scopeStack.length - 1].startTokenIndex === i + 1) {\n      scopeStack.pop();\n    }\n    while (scopeIndex >= 0 && scopes[scopeIndex].endTokenIndex === i + 1) {\n      scopeStack.push(scopes[scopeIndex]);\n      scopeIndex--;\n    }\n    // Process scopes after the last iteration so we can make sure we pop all of them.\n    if (i < 0) {\n      break;\n    }\n\n    const token = tokens.tokens[i];\n    const name = tokens.identifierNameForToken(token);\n    if (scopeStack.length > 1 && token.type === tt.name && globalNames.has(name)) {\n      if (isBlockScopedDeclaration(token)) {\n        markShadowedForScope(scopeStack[scopeStack.length - 1], tokens, name);\n      } else if (isFunctionScopedDeclaration(token)) {\n        let stackIndex = scopeStack.length - 1;\n        while (stackIndex > 0 && !scopeStack[stackIndex].isFunctionScope) {\n          stackIndex--;\n        }\n        if (stackIndex < 0) {\n          throw new Error(\"Did not find parent function scope.\");\n        }\n        markShadowedForScope(scopeStack[stackIndex], tokens, name);\n      }\n    }\n  }\n  if (scopeStack.length > 0) {\n    throw new Error(\"Expected empty scope stack after processing file.\");\n  }\n}\n\nfunction markShadowedForScope(scope, tokens, name) {\n  for (let i = scope.startTokenIndex; i < scope.endTokenIndex; i++) {\n    const token = tokens.tokens[i];\n    if (token.type === tt.name && tokens.identifierNameForToken(token) === name) {\n      token.shadowsGlobal = true;\n    }\n  }\n}\n", "\nimport {TokenType as tt} from \"../parser/tokenizer/types\";\n\n/**\n * Get all identifier names in the code, in order, including duplicates.\n */\nexport default function getIdentifierNames(code, tokens) {\n  const names = [];\n  for (const token of tokens) {\n    if (token.type === tt.name) {\n      names.push(code.slice(token.start, token.end));\n    }\n  }\n  return names;\n}\n", "\nimport getIdentifierNames from \"./util/getIdentifierNames\";\n\nexport default class NameManager {\n    __init() {this.usedNames = new Set()}\n\n  constructor(code, tokens) {;NameManager.prototype.__init.call(this);\n    this.usedNames = new Set(getIdentifierNames(code, tokens));\n  }\n\n  claimFreeName(name) {\n    const newName = this.findFreeName(name);\n    this.usedNames.add(newName);\n    return newName;\n  }\n\n  findFreeName(name) {\n    if (!this.usedNames.has(name)) {\n      return name;\n    }\n    let suffixNum = 2;\n    while (this.usedNames.has(name + suffixNum)) {\n      suffixNum++;\n    }\n    return name + suffixNum;\n  }\n}\n", "/**\n * This module was automatically generated by `ts-interface-builder`\n */\nimport * as t from \"ts-interface-checker\";\n// tslint:disable:object-literal-key-quotes\n\nexport const Transform = t.union(\n  t.lit(\"jsx\"),\n  t.lit(\"typescript\"),\n  t.lit(\"flow\"),\n  t.lit(\"imports\"),\n  t.lit(\"react-hot-loader\"),\n);\n\nexport const SourceMapOptions = t.iface([], {\n  compiledFilename: \"string\",\n});\n\nexport const Options = t.iface([], {\n  transforms: t.array(\"Transform\"),\n  jsxPragma: t.opt(\"string\"),\n  jsxFragmentPragma: t.opt(\"string\"),\n  enableLegacyTypeScriptModuleInterop: t.opt(\"boolean\"),\n  enableLegacyBabel5ModuleInterop: t.opt(\"boolean\"),\n  sourceMapOptions: t.opt(\"SourceMapOptions\"),\n  filePath: t.opt(\"string\"),\n  production: t.opt(\"boolean\"),\n});\n\nconst exportedTypeSuite = {\n  Transform,\n  SourceMapOptions,\n  Options,\n};\nexport default exportedTypeSuite;\n", "import {createCheckers} from \"ts-interface-checker\";\nimport OptionsGenTypes from \"./Options-gen-types\";\n\nconst {Options: OptionsChecker} = createCheckers(OptionsGenTypes);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nexport function validateOptions(options) {\n  OptionsChecker.strictCheck(options);\n}\n", "import {flowParseAssignableListItemTypes} from \"../plugins/flow\";\nimport {\n  tsParseAccessModifier,\n  tsParseAssignableListItemTypes,\n  tsParseModifier,\n} from \"../plugins/typescript\";\nimport {\n  eat,\n  IdentifierRole,\n  match,\n  next,\n  popTypeContext,\n  pushTypeContext,\n} from \"../tokenizer/index\";\nimport {ContextualKeyword} from \"../tokenizer/keywords\";\nimport {TokenType, TokenType as tt} from \"../tokenizer/types\";\nimport {isFlowEnabled, isTypeScriptEnabled, state} from \"./base\";\nimport {parseIdentifier, parseMaybeAssign, parseObj} from \"./expression\";\nimport {expect, unexpected} from \"./util\";\n\nexport function parseSpread() {\n  next();\n  parseMaybeAssign(false);\n}\n\nexport function parseRest(isBlockScope) {\n  next();\n  parseBindingAtom(isBlockScope);\n}\n\nexport function parseBindingIdentifier(isBlockScope) {\n  parseIdentifier();\n  markPriorBindingIdentifier(isBlockScope);\n}\n\nexport function parseImportedIdentifier() {\n  parseIdentifier();\n  state.tokens[state.tokens.length - 1].identifierRole = IdentifierRole.ImportDeclaration;\n}\n\nexport function markPriorBindingIdentifier(isBlockScope) {\n  if (state.scopeDepth === 0) {\n    state.tokens[state.tokens.length - 1].identifierRole = IdentifierRole.TopLevelDeclaration;\n  } else {\n    state.tokens[state.tokens.length - 1].identifierRole = isBlockScope\n      ? IdentifierRole.BlockScopedDeclaration\n      : IdentifierRole.FunctionScopedDeclaration;\n  }\n}\n\n// Parses lvalue (assignable) atom.\nexport function parseBindingAtom(isBlockScope) {\n  switch (state.type) {\n    case tt._this: {\n      // In TypeScript, \"this\" may be the name of a parameter, so allow it.\n      const oldIsType = pushTypeContext(0);\n      next();\n      popTypeContext(oldIsType);\n      return;\n    }\n\n    case tt._yield:\n    case tt.name: {\n      state.type = tt.name;\n      parseBindingIdentifier(isBlockScope);\n      return;\n    }\n\n    case tt.bracketL: {\n      next();\n      parseBindingList(tt.bracketR, isBlockScope, true /* allowEmpty */);\n      return;\n    }\n\n    case tt.braceL:\n      parseObj(true, isBlockScope);\n      return;\n\n    default:\n      unexpected();\n  }\n}\n\nexport function parseBindingList(\n  close,\n  isBlockScope,\n  allowEmpty = false,\n  allowModifiers = false,\n  contextId = 0,\n) {\n  let first = true;\n\n  let hasRemovedComma = false;\n  const firstItemTokenIndex = state.tokens.length;\n\n  while (!eat(close) && !state.error) {\n    if (first) {\n      first = false;\n    } else {\n      expect(tt.comma);\n      state.tokens[state.tokens.length - 1].contextId = contextId;\n      // After a \"this\" type in TypeScript, we need to set the following comma (if any) to also be\n      // a type token so that it will be removed.\n      if (!hasRemovedComma && state.tokens[firstItemTokenIndex].isType) {\n        state.tokens[state.tokens.length - 1].isType = true;\n        hasRemovedComma = true;\n      }\n    }\n    if (allowEmpty && match(tt.comma)) {\n      // Empty item; nothing further to parse for this item.\n    } else if (eat(close)) {\n      break;\n    } else if (match(tt.ellipsis)) {\n      parseRest(isBlockScope);\n      parseAssignableListItemTypes();\n      // Support rest element trailing commas allowed by TypeScript <2.9.\n      eat(TokenType.comma);\n      expect(close);\n      break;\n    } else {\n      parseAssignableListItem(allowModifiers, isBlockScope);\n    }\n  }\n}\n\nfunction parseAssignableListItem(allowModifiers, isBlockScope) {\n  if (allowModifiers) {\n    tsParseAccessModifier();\n    tsParseModifier([ContextualKeyword._readonly]);\n  }\n\n  parseMaybeDefault(isBlockScope);\n  parseAssignableListItemTypes();\n  parseMaybeDefault(isBlockScope, true /* leftAlreadyParsed */);\n}\n\nfunction parseAssignableListItemTypes() {\n  if (isFlowEnabled) {\n    flowParseAssignableListItemTypes();\n  } else if (isTypeScriptEnabled) {\n    tsParseAssignableListItemTypes();\n  }\n}\n\n// Parses assignment pattern around given atom if possible.\nexport function parseMaybeDefault(isBlockScope, leftAlreadyParsed = false) {\n  if (!leftAlreadyParsed) {\n    parseBindingAtom(isBlockScope);\n  }\n  if (!eat(tt.eq)) {\n    return;\n  }\n  const eqIndex = state.tokens.length - 1;\n  parseMaybeAssign();\n  state.tokens[eqIndex].rhsEndIndex = state.tokens.length;\n}\n", "import {\n  eat,\n  lookaheadType,\n  lookaheadTypeAndKeyword,\n  match,\n  next,\n  popTypeContext,\n  pushTypeContext,\n} from \"../tokenizer/index\";\nimport {ContextualKeyword} from \"../tokenizer/keywords\";\nimport {TokenType, TokenType as tt} from \"../tokenizer/types\";\nimport {isJSXEnabled, state} from \"../traverser/base\";\nimport {\n  atPossibleAsync,\n  baseParseMaybeAssign,\n  baseParseSubscript,\n  parseCallExpressionArguments,\n  parseExprAtom,\n  parseExpression,\n  parseFunctionBody,\n  parseIdentifier,\n  parseLiteral,\n  parseMaybeAssign,\n  parseMaybeUnary,\n  parsePropertyName,\n  parseTemplate,\n\n} from \"../traverser/expression\";\nimport {parseBindingIdentifier, parseBindingList, parseImportedIdentifier} from \"../traverser/lval\";\nimport {\n  baseParseMaybeDecoratorArguments,\n  parseBlockBody,\n  parseClass,\n  parseClassProperty,\n  parseClassPropertyName,\n  parseFunction,\n  parseFunctionParams,\n  parsePostMemberNameModifiers,\n  parseStatement,\n  parseVarStatement,\n} from \"../traverser/statement\";\nimport {\n  canInsertSemicolon,\n  eatContextual,\n  expect,\n  expectContextual,\n  hasPrecedingLineBreak,\n  isContextual,\n  isLineTerminator,\n  isLookaheadContextual,\n  semicolon,\n  unexpected,\n} from \"../traverser/util\";\nimport {nextJSXTagToken} from \"./jsx\";\n\nfunction tsIsIdentifier() {\n  // TODO: actually a bit more complex in TypeScript, but shouldn't matter.\n  // See https://github.com/Microsoft/TypeScript/issues/15008\n  return match(tt.name);\n}\n\nfunction tsNextTokenCanFollowModifier() {\n  // Note: TypeScript's implementation is much more complicated because\n  // more things are considered modifiers there.\n  // This implementation only handles modifiers not handled by babylon itself. And \"static\".\n  // TODO: Would be nice to avoid lookahead. Want a hasLineBreakUpNext() method...\n  const snapshot = state.snapshot();\n\n  next();\n  const canFollowModifier =\n    !hasPrecedingLineBreak() &&\n    !match(tt.parenL) &&\n    !match(tt.parenR) &&\n    !match(tt.colon) &&\n    !match(tt.eq) &&\n    !match(tt.question) &&\n    !match(tt.bang);\n\n  if (canFollowModifier) {\n    return true;\n  } else {\n    state.restoreFromSnapshot(snapshot);\n    return false;\n  }\n}\n\n/** Parses a modifier matching one the given modifier names. */\nexport function tsParseModifier(\n  allowedModifiers,\n) {\n  if (!match(tt.name)) {\n    return null;\n  }\n\n  const modifier = state.contextualKeyword;\n  if (allowedModifiers.indexOf(modifier) !== -1 && tsNextTokenCanFollowModifier()) {\n    switch (modifier) {\n      case ContextualKeyword._readonly:\n        state.tokens[state.tokens.length - 1].type = tt._readonly;\n        break;\n      case ContextualKeyword._abstract:\n        state.tokens[state.tokens.length - 1].type = tt._abstract;\n        break;\n      case ContextualKeyword._static:\n        state.tokens[state.tokens.length - 1].type = tt._static;\n        break;\n      case ContextualKeyword._public:\n        state.tokens[state.tokens.length - 1].type = tt._public;\n        break;\n      case ContextualKeyword._private:\n        state.tokens[state.tokens.length - 1].type = tt._private;\n        break;\n      case ContextualKeyword._protected:\n        state.tokens[state.tokens.length - 1].type = tt._protected;\n        break;\n      case ContextualKeyword._declare:\n        state.tokens[state.tokens.length - 1].type = tt._declare;\n        break;\n      default:\n        break;\n    }\n    return modifier;\n  }\n  return null;\n}\n\nfunction tsParseEntityName() {\n  parseIdentifier();\n  while (eat(tt.dot)) {\n    parseIdentifier();\n  }\n}\n\nfunction tsParseTypeReference() {\n  tsParseEntityName();\n  if (!hasPrecedingLineBreak() && match(tt.lessThan)) {\n    tsParseTypeArguments();\n  }\n}\n\nfunction tsParseThisTypePredicate() {\n  next();\n  tsParseTypeAnnotation();\n}\n\nfunction tsParseThisTypeNode() {\n  next();\n}\n\nfunction tsParseTypeQuery() {\n  expect(tt._typeof);\n  if (match(tt._import)) {\n    tsParseImportType();\n  } else {\n    tsParseEntityName();\n  }\n}\n\nfunction tsParseImportType() {\n  expect(tt._import);\n  expect(tt.parenL);\n  expect(tt.string);\n  expect(tt.parenR);\n  if (eat(tt.dot)) {\n    tsParseEntityName();\n  }\n  if (match(tt.lessThan)) {\n    tsParseTypeArguments();\n  }\n}\n\nfunction tsParseTypeParameter() {\n  parseIdentifier();\n  if (eat(tt._extends)) {\n    tsParseType();\n  }\n  if (eat(tt.eq)) {\n    tsParseType();\n  }\n}\n\nexport function tsTryParseTypeParameters() {\n  if (match(tt.lessThan)) {\n    tsParseTypeParameters();\n  }\n}\n\nfunction tsParseTypeParameters() {\n  const oldIsType = pushTypeContext(0);\n  if (match(tt.lessThan) || match(tt.typeParameterStart)) {\n    next();\n  } else {\n    unexpected();\n  }\n\n  while (!eat(tt.greaterThan) && !state.error) {\n    tsParseTypeParameter();\n    eat(tt.comma);\n  }\n  popTypeContext(oldIsType);\n}\n\n// Note: In TypeScript implementation we must provide `yieldContext` and `awaitContext`,\n// but here it's always false, because this is only used for types.\nfunction tsFillSignature(returnToken) {\n  // Arrow fns *must* have return token (`=>`). Normal functions can omit it.\n  const returnTokenRequired = returnToken === tt.arrow;\n  tsTryParseTypeParameters();\n  expect(tt.parenL);\n  // Create a scope even though we're doing type parsing so we don't accidentally\n  // treat params as top-level bindings.\n  state.scopeDepth++;\n  tsParseBindingListForSignature(false /* isBlockScope */);\n  state.scopeDepth--;\n  if (returnTokenRequired) {\n    tsParseTypeOrTypePredicateAnnotation(returnToken);\n  } else if (match(returnToken)) {\n    tsParseTypeOrTypePredicateAnnotation(returnToken);\n  }\n}\n\nfunction tsParseBindingListForSignature(isBlockScope) {\n  parseBindingList(tt.parenR, isBlockScope);\n}\n\nfunction tsParseTypeMemberSemicolon() {\n  if (!eat(tt.comma)) {\n    semicolon();\n  }\n}\n\nfunction tsParseSignatureMember() {\n  tsFillSignature(tt.colon);\n  tsParseTypeMemberSemicolon();\n}\n\nfunction tsIsUnambiguouslyIndexSignature() {\n  const snapshot = state.snapshot();\n  next(); // Skip '{'\n  const isIndexSignature = eat(tt.name) && match(tt.colon);\n  state.restoreFromSnapshot(snapshot);\n  return isIndexSignature;\n}\n\nfunction tsTryParseIndexSignature() {\n  if (!(match(tt.bracketL) && tsIsUnambiguouslyIndexSignature())) {\n    return false;\n  }\n\n  const oldIsType = pushTypeContext(0);\n\n  expect(tt.bracketL);\n  parseIdentifier();\n  tsParseTypeAnnotation();\n  expect(tt.bracketR);\n\n  tsTryParseTypeAnnotation();\n  tsParseTypeMemberSemicolon();\n\n  popTypeContext(oldIsType);\n  return true;\n}\n\nfunction tsParsePropertyOrMethodSignature(isReadonly) {\n  eat(tt.question);\n\n  if (!isReadonly && (match(tt.parenL) || match(tt.lessThan))) {\n    tsFillSignature(tt.colon);\n    tsParseTypeMemberSemicolon();\n  } else {\n    tsTryParseTypeAnnotation();\n    tsParseTypeMemberSemicolon();\n  }\n}\n\nfunction tsParseTypeMember() {\n  if (match(tt.parenL) || match(tt.lessThan)) {\n    // call signature\n    tsParseSignatureMember();\n    return;\n  }\n  if (match(tt._new)) {\n    next();\n    if (match(tt.parenL) || match(tt.lessThan)) {\n      // constructor signature\n      tsParseSignatureMember();\n    } else {\n      tsParsePropertyOrMethodSignature(false);\n    }\n    return;\n  }\n  const readonly = !!tsParseModifier([ContextualKeyword._readonly]);\n\n  const found = tsTryParseIndexSignature();\n  if (found) {\n    return;\n  }\n  parsePropertyName(-1 /* Types don't need context IDs. */);\n  tsParsePropertyOrMethodSignature(readonly);\n}\n\nfunction tsParseTypeLiteral() {\n  tsParseObjectTypeMembers();\n}\n\nfunction tsParseObjectTypeMembers() {\n  expect(tt.braceL);\n  while (!eat(tt.braceR) && !state.error) {\n    tsParseTypeMember();\n  }\n}\n\nfunction tsLookaheadIsStartOfMappedType() {\n  const snapshot = state.snapshot();\n  const isStartOfMappedType = tsIsStartOfMappedType();\n  state.restoreFromSnapshot(snapshot);\n  return isStartOfMappedType;\n}\n\nfunction tsIsStartOfMappedType() {\n  next();\n  if (eat(tt.plus) || eat(tt.minus)) {\n    return isContextual(ContextualKeyword._readonly);\n  }\n  if (isContextual(ContextualKeyword._readonly)) {\n    next();\n  }\n  if (!match(tt.bracketL)) {\n    return false;\n  }\n  next();\n  if (!tsIsIdentifier()) {\n    return false;\n  }\n  next();\n  return match(tt._in);\n}\n\nfunction tsParseMappedTypeParameter() {\n  parseIdentifier();\n  expect(tt._in);\n  tsParseType();\n}\n\nfunction tsParseMappedType() {\n  expect(tt.braceL);\n  if (match(tt.plus) || match(tt.minus)) {\n    next();\n    expectContextual(ContextualKeyword._readonly);\n  } else {\n    eatContextual(ContextualKeyword._readonly);\n  }\n  expect(tt.bracketL);\n  tsParseMappedTypeParameter();\n  expect(tt.bracketR);\n  if (match(tt.plus) || match(tt.minus)) {\n    next();\n    expect(tt.question);\n  } else {\n    eat(tt.question);\n  }\n  tsTryParseType();\n  semicolon();\n  expect(tt.braceR);\n}\n\nfunction tsParseTupleType() {\n  expect(tt.bracketL);\n  while (!eat(tt.bracketR) && !state.error) {\n    tsParseTupleElementType();\n    eat(tt.comma);\n  }\n}\n\nfunction tsParseTupleElementType() {\n  // parses `...TsType[]`\n  if (eat(tt.ellipsis)) {\n    tsParseType();\n    return;\n  }\n  // parses `TsType?`\n  tsParseType();\n  eat(tt.question);\n}\n\nfunction tsParseParenthesizedType() {\n  expect(tt.parenL);\n  tsParseType();\n  expect(tt.parenR);\n}\n\nvar FunctionType; (function (FunctionType) {\n  const TSFunctionType = 0; FunctionType[FunctionType[\"TSFunctionType\"] = TSFunctionType] = \"TSFunctionType\";\n  const TSConstructorType = TSFunctionType + 1; FunctionType[FunctionType[\"TSConstructorType\"] = TSConstructorType] = \"TSConstructorType\";\n})(FunctionType || (FunctionType = {}));\n\nfunction tsParseFunctionOrConstructorType(type) {\n  if (type === FunctionType.TSConstructorType) {\n    expect(tt._new);\n  }\n  tsFillSignature(tt.arrow);\n}\n\nfunction tsParseNonArrayType() {\n  switch (state.type) {\n    case tt.name:\n      tsParseTypeReference();\n      return;\n    case tt._void:\n    case tt._null:\n      next();\n      return;\n    case tt.string:\n    case tt.num:\n    case tt._true:\n    case tt._false:\n      parseLiteral();\n      return;\n    case tt.minus:\n      next();\n      parseLiteral();\n      return;\n    case tt._this: {\n      tsParseThisTypeNode();\n      if (isContextual(ContextualKeyword._is) && !hasPrecedingLineBreak()) {\n        tsParseThisTypePredicate();\n      }\n      return;\n    }\n    case tt._typeof:\n      tsParseTypeQuery();\n      return;\n    case tt._import:\n      tsParseImportType();\n      return;\n    case tt.braceL:\n      if (tsLookaheadIsStartOfMappedType()) {\n        tsParseMappedType();\n      } else {\n        tsParseTypeLiteral();\n      }\n      return;\n    case tt.bracketL:\n      tsParseTupleType();\n      return;\n    case tt.parenL:\n      tsParseParenthesizedType();\n      return;\n    case tt.backQuote:\n      parseTemplate();\n      return;\n    default:\n      if (state.type & TokenType.IS_KEYWORD) {\n        next();\n        state.tokens[state.tokens.length - 1].type = tt.name;\n        return;\n      }\n      break;\n  }\n\n  unexpected();\n}\n\nfunction tsParseArrayTypeOrHigher() {\n  tsParseNonArrayType();\n  while (!hasPrecedingLineBreak() && eat(tt.bracketL)) {\n    if (!eat(tt.bracketR)) {\n      // If we hit ] immediately, this is an array type, otherwise it's an indexed access type.\n      tsParseType();\n      expect(tt.bracketR);\n    }\n  }\n}\n\nfunction tsParseInferType() {\n  expectContextual(ContextualKeyword._infer);\n  parseIdentifier();\n}\n\nfunction tsParseTypeOperatorOrHigher() {\n  if (\n    isContextual(ContextualKeyword._keyof) ||\n    isContextual(ContextualKeyword._unique) ||\n    isContextual(ContextualKeyword._readonly)\n  ) {\n    next();\n    tsParseTypeOperatorOrHigher();\n  } else if (isContextual(ContextualKeyword._infer)) {\n    tsParseInferType();\n  } else {\n    tsParseArrayTypeOrHigher();\n  }\n}\n\nfunction tsParseIntersectionTypeOrHigher() {\n  eat(tt.bitwiseAND);\n  tsParseTypeOperatorOrHigher();\n  if (match(tt.bitwiseAND)) {\n    while (eat(tt.bitwiseAND)) {\n      tsParseTypeOperatorOrHigher();\n    }\n  }\n}\n\nfunction tsParseUnionTypeOrHigher() {\n  eat(tt.bitwiseOR);\n  tsParseIntersectionTypeOrHigher();\n  if (match(tt.bitwiseOR)) {\n    while (eat(tt.bitwiseOR)) {\n      tsParseIntersectionTypeOrHigher();\n    }\n  }\n}\n\nfunction tsIsStartOfFunctionType() {\n  if (match(tt.lessThan)) {\n    return true;\n  }\n  return match(tt.parenL) && tsLookaheadIsUnambiguouslyStartOfFunctionType();\n}\n\nfunction tsSkipParameterStart() {\n  if (match(tt.name) || match(tt._this)) {\n    next();\n    return true;\n  }\n  // If this is a possible array/object destructure, walk to the matching bracket/brace.\n  // The next token after will tell us definitively whether this is a function param.\n  if (match(tt.braceL) || match(tt.bracketL)) {\n    let depth = 1;\n    next();\n    while (depth > 0 && !state.error) {\n      if (match(tt.braceL) || match(tt.bracketL)) {\n        depth++;\n      } else if (match(tt.braceR) || match(tt.bracketR)) {\n        depth--;\n      }\n      next();\n    }\n    return true;\n  }\n  return false;\n}\n\nfunction tsLookaheadIsUnambiguouslyStartOfFunctionType() {\n  const snapshot = state.snapshot();\n  const isUnambiguouslyStartOfFunctionType = tsIsUnambiguouslyStartOfFunctionType();\n  state.restoreFromSnapshot(snapshot);\n  return isUnambiguouslyStartOfFunctionType;\n}\n\nfunction tsIsUnambiguouslyStartOfFunctionType() {\n  next();\n  if (match(tt.parenR) || match(tt.ellipsis)) {\n    // ( )\n    // ( ...\n    return true;\n  }\n  if (tsSkipParameterStart()) {\n    if (match(tt.colon) || match(tt.comma) || match(tt.question) || match(tt.eq)) {\n      // ( xxx :\n      // ( xxx ,\n      // ( xxx ?\n      // ( xxx =\n      return true;\n    }\n    if (match(tt.parenR)) {\n      next();\n      if (match(tt.arrow)) {\n        // ( xxx ) =>\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nfunction tsParseTypeOrTypePredicateAnnotation(returnToken) {\n  const oldIsType = pushTypeContext(0);\n  expect(returnToken);\n  const finishedReturn = tsParseTypePredicateOrAssertsPrefix();\n  if (!finishedReturn) {\n    tsParseType();\n  }\n  popTypeContext(oldIsType);\n}\n\nfunction tsTryParseTypeOrTypePredicateAnnotation() {\n  if (match(tt.colon)) {\n    tsParseTypeOrTypePredicateAnnotation(tt.colon);\n  }\n}\n\nexport function tsTryParseTypeAnnotation() {\n  if (match(tt.colon)) {\n    tsParseTypeAnnotation();\n  }\n}\n\nfunction tsTryParseType() {\n  if (eat(tt.colon)) {\n    tsParseType();\n  }\n}\n\n/**\n * Detect a few special return syntax cases: `x is T`, `asserts x`, `asserts x is T`,\n * `asserts this is T`.\n *\n * Returns true if we parsed the return type, false if there's still a type to be parsed.\n */\nfunction tsParseTypePredicateOrAssertsPrefix() {\n  const snapshot = state.snapshot();\n  if (isContextual(ContextualKeyword._asserts) && !hasPrecedingLineBreak()) {\n    // Normally this is `asserts x is T`, but at this point, it might be `asserts is T` (a user-\n    // defined type guard on the `asserts` variable) or just a type called `asserts`.\n    next();\n    if (eatContextual(ContextualKeyword._is)) {\n      // If we see `asserts is`, then this must be of the form `asserts is T`, since\n      // `asserts is is T` isn't valid.\n      tsParseType();\n      return true;\n    } else if (tsIsIdentifier() || match(tt._this)) {\n      next();\n      if (eatContextual(ContextualKeyword._is)) {\n        // If we see `is`, then this is `asserts x is T`. Otherwise, it's `asserts x`.\n        tsParseType();\n      }\n      return true;\n    } else {\n      // Regular type, so bail out and start type parsing from scratch.\n      state.restoreFromSnapshot(snapshot);\n      return false;\n    }\n  } else if (tsIsIdentifier() || match(tt._this)) {\n    // This is a regular identifier, which may or may not have \"is\" after it.\n    next();\n    if (isContextual(ContextualKeyword._is) && !hasPrecedingLineBreak()) {\n      next();\n      tsParseType();\n      return true;\n    } else {\n      // Regular type, so bail out and start type parsing from scratch.\n      state.restoreFromSnapshot(snapshot);\n      return false;\n    }\n  }\n  return false;\n}\n\nexport function tsParseTypeAnnotation() {\n  const oldIsType = pushTypeContext(0);\n  expect(tt.colon);\n  tsParseType();\n  popTypeContext(oldIsType);\n}\n\nexport function tsParseType() {\n  tsParseNonConditionalType();\n  if (hasPrecedingLineBreak() || !eat(tt._extends)) {\n    return;\n  }\n  // extends type\n  tsParseNonConditionalType();\n  expect(tt.question);\n  // true type\n  tsParseType();\n  expect(tt.colon);\n  // false type\n  tsParseType();\n}\n\nexport function tsParseNonConditionalType() {\n  if (tsIsStartOfFunctionType()) {\n    tsParseFunctionOrConstructorType(FunctionType.TSFunctionType);\n    return;\n  }\n  if (match(tt._new)) {\n    // As in `new () => Date`\n    tsParseFunctionOrConstructorType(FunctionType.TSConstructorType);\n    return;\n  }\n  tsParseUnionTypeOrHigher();\n}\n\nexport function tsParseTypeAssertion() {\n  const oldIsType = pushTypeContext(1);\n  tsParseType();\n  expect(tt.greaterThan);\n  popTypeContext(oldIsType);\n  parseMaybeUnary();\n}\n\nexport function tsTryParseJSXTypeArgument() {\n  if (eat(tt.jsxTagStart)) {\n    state.tokens[state.tokens.length - 1].type = tt.typeParameterStart;\n    const oldIsType = pushTypeContext(1);\n    while (!match(tt.greaterThan) && !state.error) {\n      tsParseType();\n      eat(tt.comma);\n    }\n    // Process >, but the one after needs to be parsed JSX-style.\n    nextJSXTagToken();\n    popTypeContext(oldIsType);\n  }\n}\n\nfunction tsParseHeritageClause() {\n  while (!match(tt.braceL) && !state.error) {\n    tsParseExpressionWithTypeArguments();\n    eat(tt.comma);\n  }\n}\n\nfunction tsParseExpressionWithTypeArguments() {\n  // Note: TS uses parseLeftHandSideExpressionOrHigher,\n  // then has grammar errors later if it's not an EntityName.\n  tsParseEntityName();\n  if (match(tt.lessThan)) {\n    tsParseTypeArguments();\n  }\n}\n\nfunction tsParseInterfaceDeclaration() {\n  parseBindingIdentifier(false);\n  tsTryParseTypeParameters();\n  if (eat(tt._extends)) {\n    tsParseHeritageClause();\n  }\n  tsParseObjectTypeMembers();\n}\n\nfunction tsParseTypeAliasDeclaration() {\n  parseBindingIdentifier(false);\n  tsTryParseTypeParameters();\n  expect(tt.eq);\n  tsParseType();\n  semicolon();\n}\n\nfunction tsParseEnumMember() {\n  // Computed property names are grammar errors in an enum, so accept just string literal or identifier.\n  if (match(tt.string)) {\n    parseLiteral();\n  } else {\n    parseIdentifier();\n  }\n  if (eat(tt.eq)) {\n    const eqIndex = state.tokens.length - 1;\n    parseMaybeAssign();\n    state.tokens[eqIndex].rhsEndIndex = state.tokens.length;\n  }\n}\n\nfunction tsParseEnumDeclaration() {\n  parseBindingIdentifier(false);\n  expect(tt.braceL);\n  while (!eat(tt.braceR) && !state.error) {\n    tsParseEnumMember();\n    eat(tt.comma);\n  }\n}\n\nfunction tsParseModuleBlock() {\n  expect(tt.braceL);\n  parseBlockBody(/* end */ tt.braceR);\n}\n\nfunction tsParseModuleOrNamespaceDeclaration() {\n  parseBindingIdentifier(false);\n  if (eat(tt.dot)) {\n    tsParseModuleOrNamespaceDeclaration();\n  } else {\n    tsParseModuleBlock();\n  }\n}\n\nfunction tsParseAmbientExternalModuleDeclaration() {\n  if (isContextual(ContextualKeyword._global)) {\n    parseIdentifier();\n  } else if (match(tt.string)) {\n    parseExprAtom();\n  } else {\n    unexpected();\n  }\n\n  if (match(tt.braceL)) {\n    tsParseModuleBlock();\n  } else {\n    semicolon();\n  }\n}\n\nexport function tsParseImportEqualsDeclaration() {\n  parseImportedIdentifier();\n  expect(tt.eq);\n  tsParseModuleReference();\n  semicolon();\n}\n\nfunction tsIsExternalModuleReference() {\n  return isContextual(ContextualKeyword._require) && lookaheadType() === tt.parenL;\n}\n\nfunction tsParseModuleReference() {\n  if (tsIsExternalModuleReference()) {\n    tsParseExternalModuleReference();\n  } else {\n    tsParseEntityName();\n  }\n}\n\nfunction tsParseExternalModuleReference() {\n  expectContextual(ContextualKeyword._require);\n  expect(tt.parenL);\n  if (!match(tt.string)) {\n    unexpected();\n  }\n  parseLiteral();\n  expect(tt.parenR);\n}\n\n// Utilities\n\n// Returns true if a statement matched.\nfunction tsTryParseDeclare() {\n  if (isLineTerminator()) {\n    return false;\n  }\n  switch (state.type) {\n    case tt._function: {\n      const oldIsType = pushTypeContext(1);\n      next();\n      // We don't need to precisely get the function start here, since it's only used to mark\n      // the function as a type if it's bodiless, and it's already a type here.\n      const functionStart = state.start;\n      parseFunction(functionStart, /* isStatement */ true);\n      popTypeContext(oldIsType);\n      return true;\n    }\n    case tt._class: {\n      const oldIsType = pushTypeContext(1);\n      parseClass(/* isStatement */ true, /* optionalId */ false);\n      popTypeContext(oldIsType);\n      return true;\n    }\n    case tt._const: {\n      if (match(tt._const) && isLookaheadContextual(ContextualKeyword._enum)) {\n        const oldIsType = pushTypeContext(1);\n        // `const enum = 0;` not allowed because \"enum\" is a strict mode reserved word.\n        expect(tt._const);\n        expectContextual(ContextualKeyword._enum);\n        state.tokens[state.tokens.length - 1].type = tt._enum;\n        tsParseEnumDeclaration();\n        popTypeContext(oldIsType);\n        return true;\n      }\n    }\n    // falls through\n    case tt._var:\n    case tt._let: {\n      const oldIsType = pushTypeContext(1);\n      parseVarStatement(state.type);\n      popTypeContext(oldIsType);\n      return true;\n    }\n    case tt.name: {\n      const oldIsType = pushTypeContext(1);\n      const contextualKeyword = state.contextualKeyword;\n      let matched = false;\n      if (contextualKeyword === ContextualKeyword._global) {\n        tsParseAmbientExternalModuleDeclaration();\n        matched = true;\n      } else {\n        matched = tsParseDeclaration(contextualKeyword, /* isBeforeToken */ true);\n      }\n      popTypeContext(oldIsType);\n      return matched;\n    }\n    default:\n      return false;\n  }\n}\n\n// Note: this won't be called unless the keyword is allowed in `shouldParseExportDeclaration`.\n// Returns true if it matched a declaration.\nfunction tsTryParseExportDeclaration() {\n  return tsParseDeclaration(state.contextualKeyword, /* isBeforeToken */ true);\n}\n\n// Returns true if it matched a statement.\nfunction tsParseExpressionStatement(contextualKeyword) {\n  switch (contextualKeyword) {\n    case ContextualKeyword._declare: {\n      const declareTokenIndex = state.tokens.length - 1;\n      const matched = tsTryParseDeclare();\n      if (matched) {\n        state.tokens[declareTokenIndex].type = tt._declare;\n        return true;\n      }\n      break;\n    }\n    case ContextualKeyword._global:\n      // `global { }` (with no `declare`) may appear inside an ambient module declaration.\n      // Would like to use tsParseAmbientExternalModuleDeclaration here, but already ran past \"global\".\n      if (match(tt.braceL)) {\n        tsParseModuleBlock();\n        return true;\n      }\n      break;\n\n    default:\n      return tsParseDeclaration(contextualKeyword, /* isBeforeToken */ false);\n  }\n  return false;\n}\n\n// Common to tsTryParseDeclare, tsTryParseExportDeclaration, and tsParseExpressionStatement.\n// Returns true if it matched a declaration.\nfunction tsParseDeclaration(contextualKeyword, isBeforeToken) {\n  switch (contextualKeyword) {\n    case ContextualKeyword._abstract:\n      if (tsCheckLineTerminatorAndMatch(tt._class, isBeforeToken)) {\n        if (isBeforeToken) next();\n        state.tokens[state.tokens.length - 1].type = tt._abstract;\n        parseClass(/* isStatement */ true, /* optionalId */ false);\n        return true;\n      }\n      break;\n\n    case ContextualKeyword._enum:\n      if (tsCheckLineTerminatorAndMatch(tt.name, isBeforeToken)) {\n        if (isBeforeToken) next();\n        state.tokens[state.tokens.length - 1].type = tt._enum;\n        tsParseEnumDeclaration();\n        return true;\n      }\n      break;\n\n    case ContextualKeyword._interface:\n      if (tsCheckLineTerminatorAndMatch(tt.name, isBeforeToken)) {\n        // `next` is true in \"export\" and \"declare\" contexts, so we want to remove that token\n        // as well.\n        const oldIsType = pushTypeContext(1);\n        if (isBeforeToken) next();\n        tsParseInterfaceDeclaration();\n        popTypeContext(oldIsType);\n        return true;\n      }\n      break;\n\n    case ContextualKeyword._module:\n      if (isBeforeToken) next();\n      if (match(tt.string)) {\n        const oldIsType = pushTypeContext(isBeforeToken ? 2 : 1);\n        tsParseAmbientExternalModuleDeclaration();\n        popTypeContext(oldIsType);\n        return true;\n      } else if (tsCheckLineTerminatorAndMatch(tt.name, isBeforeToken)) {\n        const oldIsType = pushTypeContext(isBeforeToken ? 2 : 1);\n        if (isBeforeToken) next();\n        tsParseModuleOrNamespaceDeclaration();\n        popTypeContext(oldIsType);\n        return true;\n      }\n      break;\n\n    case ContextualKeyword._namespace:\n      if (tsCheckLineTerminatorAndMatch(tt.name, isBeforeToken)) {\n        const oldIsType = pushTypeContext(1);\n        if (isBeforeToken) next();\n        tsParseModuleOrNamespaceDeclaration();\n        popTypeContext(oldIsType);\n        return true;\n      }\n      break;\n\n    case ContextualKeyword._type:\n      if (tsCheckLineTerminatorAndMatch(tt.name, isBeforeToken)) {\n        const oldIsType = pushTypeContext(1);\n        if (isBeforeToken) next();\n        tsParseTypeAliasDeclaration();\n        popTypeContext(oldIsType);\n        return true;\n      }\n      break;\n\n    default:\n      break;\n  }\n  return false;\n}\n\nfunction tsCheckLineTerminatorAndMatch(tokenType, isBeforeToken) {\n  return !isLineTerminator() && (isBeforeToken || match(tokenType));\n}\n\n// Returns true if there was a generic async arrow function.\nfunction tsTryParseGenericAsyncArrowFunction() {\n  const snapshot = state.snapshot();\n\n  tsParseTypeParameters();\n  parseFunctionParams();\n  tsTryParseTypeOrTypePredicateAnnotation();\n  expect(tt.arrow);\n\n  if (state.error) {\n    state.restoreFromSnapshot(snapshot);\n    return false;\n  }\n\n  parseFunctionBody(true);\n  return true;\n}\n\nfunction tsParseTypeArguments() {\n  const oldIsType = pushTypeContext(0);\n  expect(tt.lessThan);\n  while (!eat(tt.greaterThan) && !state.error) {\n    tsParseType();\n    eat(tt.comma);\n  }\n  popTypeContext(oldIsType);\n}\n\nexport function tsIsDeclarationStart() {\n  if (match(tt.name)) {\n    switch (state.contextualKeyword) {\n      case ContextualKeyword._abstract:\n      case ContextualKeyword._declare:\n      case ContextualKeyword._enum:\n      case ContextualKeyword._interface:\n      case ContextualKeyword._module:\n      case ContextualKeyword._namespace:\n      case ContextualKeyword._type:\n        return true;\n      default:\n        break;\n    }\n  }\n\n  return false;\n}\n\n// ======================================================\n// OVERRIDES\n// ======================================================\n\nexport function tsParseFunctionBodyAndFinish(functionStart, funcContextId) {\n  // For arrow functions, `parseArrow` handles the return type itself.\n  if (match(tt.colon)) {\n    tsParseTypeOrTypePredicateAnnotation(tt.colon);\n  }\n\n  // The original code checked the node type to make sure this function type allows a missing\n  // body, but we skip that to avoid sending around the node type. We instead just use the\n  // allowExpressionBody boolean to make sure it's not an arrow function.\n  if (!match(tt.braceL) && isLineTerminator()) {\n    // Retroactively mark the function declaration as a type.\n    let i = state.tokens.length - 1;\n    while (\n      i >= 0 &&\n      (state.tokens[i].start >= functionStart ||\n        state.tokens[i].type === tt._default ||\n        state.tokens[i].type === tt._export)\n    ) {\n      state.tokens[i].isType = true;\n      i--;\n    }\n    return;\n  }\n\n  parseFunctionBody(false, funcContextId);\n}\n\nexport function tsParseSubscript(\n  startTokenIndex,\n  noCalls,\n  stopState,\n) {\n  if (!hasPrecedingLineBreak() && eat(tt.bang)) {\n    state.tokens[state.tokens.length - 1].type = tt.nonNullAssertion;\n    return;\n  }\n\n  if (match(tt.lessThan)) {\n    // There are number of things we are going to \"maybe\" parse, like type arguments on\n    // tagged template expressions. If any of them fail, walk it back and continue.\n    const snapshot = state.snapshot();\n\n    if (!noCalls && atPossibleAsync()) {\n      // Almost certainly this is a generic async function `async <T>() => ...\n      // But it might be a call with a type argument `async<T>();`\n      const asyncArrowFn = tsTryParseGenericAsyncArrowFunction();\n      if (asyncArrowFn) {\n        return;\n      }\n    }\n    tsParseTypeArguments();\n    if (!noCalls && eat(tt.parenL)) {\n      // With f<T>(), the subscriptStartIndex marker is on the ( token.\n      state.tokens[state.tokens.length - 1].subscriptStartIndex = startTokenIndex;\n      parseCallExpressionArguments();\n    } else if (match(tt.backQuote)) {\n      // Tagged template with a type argument.\n      parseTemplate();\n    } else {\n      unexpected();\n    }\n\n    if (state.error) {\n      state.restoreFromSnapshot(snapshot);\n    } else {\n      return;\n    }\n  } else if (!noCalls && match(tt.questionDot) && lookaheadType() === tt.lessThan) {\n    // If we see f?.<, then this must be an optional call with a type argument.\n    next();\n    state.tokens[startTokenIndex].isOptionalChainStart = true;\n    // With f?.<T>(), the subscriptStartIndex marker is on the ?. token.\n    state.tokens[state.tokens.length - 1].subscriptStartIndex = startTokenIndex;\n\n    tsParseTypeArguments();\n    expect(tt.parenL);\n    parseCallExpressionArguments();\n  }\n  baseParseSubscript(startTokenIndex, noCalls, stopState);\n}\n\nexport function tsStartParseNewArguments() {\n  if (match(tt.lessThan)) {\n    // 99% certain this is `new C<T>();`. But may be `new C < T;`, which is also legal.\n    const snapshot = state.snapshot();\n\n    state.type = tt.typeParameterStart;\n    tsParseTypeArguments();\n    if (!match(tt.parenL)) {\n      unexpected();\n    }\n\n    if (state.error) {\n      state.restoreFromSnapshot(snapshot);\n    }\n  }\n}\n\nexport function tsTryParseExport() {\n  if (match(tt._import)) {\n    // `export import A = B;`\n    expect(tt._import);\n    tsParseImportEqualsDeclaration();\n    return true;\n  } else if (eat(tt.eq)) {\n    // `export = x;`\n    parseExpression();\n    semicolon();\n    return true;\n  } else if (eatContextual(ContextualKeyword._as)) {\n    // `export as namespace A;`\n    // See `parseNamespaceExportDeclaration` in TypeScript's own parser\n    expectContextual(ContextualKeyword._namespace);\n    parseIdentifier();\n    semicolon();\n    return true;\n  } else {\n    if (isContextual(ContextualKeyword._type) && lookaheadType() === tt.braceL) {\n      next();\n    }\n    return false;\n  }\n}\n\nexport function tsTryParseExportDefaultExpression() {\n  if (isContextual(ContextualKeyword._abstract) && lookaheadType() === tt._class) {\n    state.type = tt._abstract;\n    next(); // Skip \"abstract\"\n    parseClass(true, true);\n    return true;\n  }\n  if (isContextual(ContextualKeyword._interface)) {\n    // Make sure \"export default\" are considered type tokens so the whole thing is removed.\n    const oldIsType = pushTypeContext(2);\n    tsParseDeclaration(ContextualKeyword._interface, true);\n    popTypeContext(oldIsType);\n    return true;\n  }\n  return false;\n}\n\nexport function tsTryParseStatementContent() {\n  if (state.type === tt._const) {\n    const ahead = lookaheadTypeAndKeyword();\n    if (ahead.type === tt.name && ahead.contextualKeyword === ContextualKeyword._enum) {\n      expect(tt._const);\n      expectContextual(ContextualKeyword._enum);\n      state.tokens[state.tokens.length - 1].type = tt._enum;\n      tsParseEnumDeclaration();\n      return true;\n    }\n  }\n  return false;\n}\n\nexport function tsParseAccessModifier() {\n  tsParseModifier([\n    ContextualKeyword._public,\n    ContextualKeyword._protected,\n    ContextualKeyword._private,\n  ]);\n}\n\nexport function tsTryParseClassMemberWithIsStatic(\n  isStatic,\n  classContextId,\n) {\n  let isAbstract = false;\n  let isReadonly = false;\n\n  while (true) {\n    const mod = tsParseModifier([\n      ContextualKeyword._abstract,\n      ContextualKeyword._readonly,\n      ContextualKeyword._declare,\n    ]);\n    if (mod == null) {\n      break;\n    }\n    if (mod === ContextualKeyword._readonly) {\n      isReadonly = true;\n    }\n    if (mod === ContextualKeyword._abstract) {\n      isAbstract = true;\n    }\n  }\n\n  // We no longer check for public/private/etc, but tsTryParseIndexSignature should just return\n  // false in that case for valid code.\n  if (!isAbstract && !isStatic) {\n    const found = tsTryParseIndexSignature();\n    if (found) {\n      return true;\n    }\n  }\n\n  if (isReadonly) {\n    // Must be a property (if not an index signature).\n    parseClassPropertyName(classContextId);\n    parsePostMemberNameModifiers();\n    parseClassProperty();\n    return true;\n  }\n  return false;\n}\n\n// Note: The reason we do this in `parseIdentifierStatement` and not `parseStatement`\n// is that e.g. `type()` is valid JS, so we must try parsing that first.\n// If it's really a type, we will parse `type` as the statement, and can correct it here\n// by parsing the rest.\nexport function tsParseIdentifierStatement(contextualKeyword) {\n  const matched = tsParseExpressionStatement(contextualKeyword);\n  if (!matched) {\n    semicolon();\n  }\n}\n\nexport function tsParseExportDeclaration() {\n  // \"export declare\" is equivalent to just \"export\".\n  const isDeclare = eatContextual(ContextualKeyword._declare);\n  if (isDeclare) {\n    state.tokens[state.tokens.length - 1].type = tt._declare;\n  }\n\n  let matchedDeclaration = false;\n  if (match(tt.name)) {\n    if (isDeclare) {\n      const oldIsType = pushTypeContext(2);\n      matchedDeclaration = tsTryParseExportDeclaration();\n      popTypeContext(oldIsType);\n    } else {\n      matchedDeclaration = tsTryParseExportDeclaration();\n    }\n  }\n  if (!matchedDeclaration) {\n    if (isDeclare) {\n      const oldIsType = pushTypeContext(2);\n      parseStatement(true);\n      popTypeContext(oldIsType);\n    } else {\n      parseStatement(true);\n    }\n  }\n}\n\nexport function tsAfterParseClassSuper(hasSuper) {\n  if (hasSuper && match(tt.lessThan)) {\n    tsParseTypeArguments();\n  }\n  if (eatContextual(ContextualKeyword._implements)) {\n    state.tokens[state.tokens.length - 1].type = tt._implements;\n    const oldIsType = pushTypeContext(1);\n    tsParseHeritageClause();\n    popTypeContext(oldIsType);\n  }\n}\n\nexport function tsStartParseObjPropValue() {\n  tsTryParseTypeParameters();\n}\n\nexport function tsStartParseFunctionParams() {\n  tsTryParseTypeParameters();\n}\n\n// `let x: number;`\nexport function tsAfterParseVarHead() {\n  const oldIsType = pushTypeContext(0);\n  eat(tt.bang);\n  tsTryParseTypeAnnotation();\n  popTypeContext(oldIsType);\n}\n\n// parse the return type of an async arrow function - let foo = (async (): number => {});\nexport function tsStartParseAsyncArrowFromCallExpression() {\n  if (match(tt.colon)) {\n    tsParseTypeAnnotation();\n  }\n}\n\n// Returns true if the expression was an arrow function.\nexport function tsParseMaybeAssign(noIn, isWithinParens) {\n  // Note: When the JSX plugin is on, type assertions (`<T> x`) aren't valid syntax.\n  if (isJSXEnabled) {\n    return tsParseMaybeAssignWithJSX(noIn, isWithinParens);\n  } else {\n    return tsParseMaybeAssignWithoutJSX(noIn, isWithinParens);\n  }\n}\n\nexport function tsParseMaybeAssignWithJSX(noIn, isWithinParens) {\n  if (!match(tt.lessThan)) {\n    return baseParseMaybeAssign(noIn, isWithinParens);\n  }\n\n  // Prefer to parse JSX if possible. But may be an arrow fn.\n  const snapshot = state.snapshot();\n  let wasArrow = baseParseMaybeAssign(noIn, isWithinParens);\n  if (state.error) {\n    state.restoreFromSnapshot(snapshot);\n  } else {\n    return wasArrow;\n  }\n\n  // Otherwise, try as type-parameterized arrow function.\n  state.type = tt.typeParameterStart;\n  // This is similar to TypeScript's `tryParseParenthesizedArrowFunctionExpression`.\n  tsParseTypeParameters();\n  wasArrow = baseParseMaybeAssign(noIn, isWithinParens);\n  if (!wasArrow) {\n    unexpected();\n  }\n\n  return wasArrow;\n}\n\nexport function tsParseMaybeAssignWithoutJSX(noIn, isWithinParens) {\n  if (!match(tt.lessThan)) {\n    return baseParseMaybeAssign(noIn, isWithinParens);\n  }\n\n  const snapshot = state.snapshot();\n  // This is similar to TypeScript's `tryParseParenthesizedArrowFunctionExpression`.\n  tsParseTypeParameters();\n  const wasArrow = baseParseMaybeAssign(noIn, isWithinParens);\n  if (!wasArrow) {\n    unexpected();\n  }\n  if (state.error) {\n    state.restoreFromSnapshot(snapshot);\n  } else {\n    return wasArrow;\n  }\n\n  // Try parsing a type cast instead of an arrow function.\n  // This will start with a type assertion (via parseMaybeUnary).\n  // But don't directly call `tsParseTypeAssertion` because we want to handle any binary after it.\n  return baseParseMaybeAssign(noIn, isWithinParens);\n}\n\nexport function tsParseArrow() {\n  if (match(tt.colon)) {\n    // This is different from how the TS parser does it.\n    // TS uses lookahead. Babylon parses it as a parenthesized expression and converts.\n    const snapshot = state.snapshot();\n\n    tsParseTypeOrTypePredicateAnnotation(tt.colon);\n    if (canInsertSemicolon()) unexpected();\n    if (!match(tt.arrow)) unexpected();\n\n    if (state.error) {\n      state.restoreFromSnapshot(snapshot);\n    }\n  }\n  return eat(tt.arrow);\n}\n\n// Allow type annotations inside of a parameter list.\nexport function tsParseAssignableListItemTypes() {\n  const oldIsType = pushTypeContext(0);\n  eat(tt.question);\n  tsTryParseTypeAnnotation();\n  popTypeContext(oldIsType);\n}\n\nexport function tsParseMaybeDecoratorArguments() {\n  if (match(tt.lessThan)) {\n    tsParseTypeArguments();\n  }\n  baseParseMaybeDecoratorArguments();\n}\n", "import {\n  eat,\n  finishToken,\n  getTokenFromCode,\n  IdentifierRole,\n  match,\n  next,\n  skipSpace,\n  Token,\n} from \"../../tokenizer/index\";\nimport {TokenType as tt} from \"../../tokenizer/types\";\nimport {input, isTypeScriptEnabled, state} from \"../../traverser/base\";\nimport {parseExpression, parseMaybeAssign} from \"../../traverser/expression\";\nimport {expect, unexpected} from \"../../traverser/util\";\nimport {charCodes} from \"../../util/charcodes\";\nimport {IS_IDENTIFIER_CHAR, IS_IDENTIFIER_START} from \"../../util/identifier\";\nimport {tsTryParseJSXTypeArgument} from \"../typescript\";\n\n// Reads inline JSX contents token.\nfunction jsxReadToken() {\n  for (;;) {\n    if (state.pos >= input.length) {\n      unexpected(\"Unterminated JSX contents\");\n      return;\n    }\n\n    const ch = input.charCodeAt(state.pos);\n\n    switch (ch) {\n      case charCodes.lessThan:\n      case charCodes.leftCurlyBrace:\n        if (state.pos === state.start) {\n          if (ch === charCodes.lessThan) {\n            state.pos++;\n            finishToken(tt.jsxTagStart);\n            return;\n          }\n          getTokenFromCode(ch);\n          return;\n        }\n        finishToken(tt.jsxText);\n        return;\n\n      default:\n        state.pos++;\n    }\n  }\n}\n\nfunction jsxReadString(quote) {\n  state.pos++;\n  for (;;) {\n    if (state.pos >= input.length) {\n      unexpected(\"Unterminated string constant\");\n      return;\n    }\n\n    const ch = input.charCodeAt(state.pos);\n    if (ch === quote) {\n      state.pos++;\n      break;\n    }\n    state.pos++;\n  }\n  finishToken(tt.string);\n}\n\n// Read a JSX identifier (valid tag or attribute name).\n//\n// Optimized version since JSX identifiers can't contain\n// escape characters and so can be read as single slice.\n// Also assumes that first character was already checked\n// by isIdentifierStart in readToken.\n\nfunction jsxReadWord() {\n  let ch;\n  do {\n    if (state.pos > input.length) {\n      unexpected(\"Unexpectedly reached the end of input.\");\n      return;\n    }\n    ch = input.charCodeAt(++state.pos);\n  } while (IS_IDENTIFIER_CHAR[ch] || ch === charCodes.dash);\n  finishToken(tt.jsxName);\n}\n\n// Parse next token as JSX identifier\nfunction jsxParseIdentifier() {\n  nextJSXTagToken();\n}\n\n// Parse namespaced identifier.\nfunction jsxParseNamespacedName(identifierRole) {\n  jsxParseIdentifier();\n  if (!eat(tt.colon)) {\n    // Plain identifier, so this is an access.\n    state.tokens[state.tokens.length - 1].identifierRole = identifierRole;\n    return;\n  }\n  // Process the second half of the namespaced name.\n  jsxParseIdentifier();\n}\n\n// Parses element name in any form - namespaced, member\n// or single identifier.\nfunction jsxParseElementName() {\n  jsxParseNamespacedName(IdentifierRole.Access);\n  while (match(tt.dot)) {\n    nextJSXTagToken();\n    jsxParseIdentifier();\n  }\n}\n\n// Parses any type of JSX attribute value.\nfunction jsxParseAttributeValue() {\n  switch (state.type) {\n    case tt.braceL:\n      next();\n      jsxParseExpressionContainer();\n      nextJSXTagToken();\n      return;\n\n    case tt.jsxTagStart:\n      jsxParseElement();\n      nextJSXTagToken();\n      return;\n\n    case tt.string:\n      nextJSXTagToken();\n      return;\n\n    default:\n      unexpected(\"JSX value should be either an expression or a quoted JSX text\");\n  }\n}\n\nfunction jsxParseEmptyExpression() {\n  // Do nothing.\n}\n\n// Parse JSX spread child, after already processing the {\n// Does not parse the closing }\nfunction jsxParseSpreadChild() {\n  expect(tt.ellipsis);\n  parseExpression();\n}\n\n// Parses JSX expression enclosed into curly brackets, after already processing the {\n// Does not parse the closing }\nfunction jsxParseExpressionContainer() {\n  if (match(tt.braceR)) {\n    jsxParseEmptyExpression();\n  } else {\n    parseExpression();\n  }\n}\n\n// Parses following JSX attribute name-value pair.\nfunction jsxParseAttribute() {\n  if (eat(tt.braceL)) {\n    expect(tt.ellipsis);\n    parseMaybeAssign();\n    // }\n    nextJSXTagToken();\n    return;\n  }\n  jsxParseNamespacedName(IdentifierRole.ObjectKey);\n  if (match(tt.eq)) {\n    nextJSXTagToken();\n    jsxParseAttributeValue();\n  }\n}\n\n// Parses JSX opening tag starting after \"<\".\n// Returns true if the tag was self-closing.\n// Does not parse the last token.\nfunction jsxParseOpeningElement() {\n  if (match(tt.jsxTagEnd)) {\n    // This is an open-fragment.\n    return false;\n  }\n  jsxParseElementName();\n  if (isTypeScriptEnabled) {\n    tsTryParseJSXTypeArgument();\n  }\n  while (!match(tt.slash) && !match(tt.jsxTagEnd) && !state.error) {\n    jsxParseAttribute();\n  }\n  const isSelfClosing = match(tt.slash);\n  if (isSelfClosing) {\n    // /\n    nextJSXTagToken();\n  }\n  return isSelfClosing;\n}\n\n// Parses JSX closing tag starting after \"</\".\n// Does not parse the last token.\nfunction jsxParseClosingElement() {\n  if (match(tt.jsxTagEnd)) {\n    // Fragment syntax, so we immediately have a tag end.\n    return;\n  }\n  jsxParseElementName();\n}\n\n// Parses entire JSX element, including its opening tag\n// (starting after \"<\"), attributes, contents and closing tag.\n// Does not parse the last token.\nfunction jsxParseElementAt() {\n  const isSelfClosing = jsxParseOpeningElement();\n  if (!isSelfClosing) {\n    nextJSXExprToken();\n    while (true) {\n      switch (state.type) {\n        case tt.jsxTagStart:\n          nextJSXTagToken();\n          if (match(tt.slash)) {\n            nextJSXTagToken();\n            jsxParseClosingElement();\n            return;\n          }\n          jsxParseElementAt();\n          nextJSXExprToken();\n          break;\n\n        case tt.jsxText:\n          nextJSXExprToken();\n          break;\n\n        case tt.braceL:\n          next();\n          if (match(tt.ellipsis)) {\n            jsxParseSpreadChild();\n            nextJSXExprToken();\n          } else {\n            jsxParseExpressionContainer();\n            nextJSXExprToken();\n          }\n\n          break;\n\n        // istanbul ignore next - should never happen\n        default:\n          unexpected();\n          return;\n      }\n    }\n  }\n}\n\n// Parses entire JSX element from current position.\n// Does not parse the last token.\nexport function jsxParseElement() {\n  nextJSXTagToken();\n  jsxParseElementAt();\n}\n\n// ==================================\n// Overrides\n// ==================================\n\nexport function nextJSXTagToken() {\n  state.tokens.push(new Token());\n  skipSpace();\n  state.start = state.pos;\n  const code = input.charCodeAt(state.pos);\n\n  if (IS_IDENTIFIER_START[code]) {\n    jsxReadWord();\n  } else if (code === charCodes.quotationMark || code === charCodes.apostrophe) {\n    jsxReadString(code);\n  } else {\n    // The following tokens are just one character each.\n    ++state.pos;\n    switch (code) {\n      case charCodes.greaterThan:\n        finishToken(tt.jsxTagEnd);\n        break;\n      case charCodes.lessThan:\n        finishToken(tt.jsxTagStart);\n        break;\n      case charCodes.slash:\n        finishToken(tt.slash);\n        break;\n      case charCodes.equalsTo:\n        finishToken(tt.eq);\n        break;\n      case charCodes.leftCurlyBrace:\n        finishToken(tt.braceL);\n        break;\n      case charCodes.dot:\n        finishToken(tt.dot);\n        break;\n      case charCodes.colon:\n        finishToken(tt.colon);\n        break;\n      default:\n        unexpected();\n    }\n  }\n}\n\nfunction nextJSXExprToken() {\n  state.tokens.push(new Token());\n  state.start = state.pos;\n  jsxReadToken();\n}\n", "import {eat, lookaheadType, match} from \"../tokenizer/index\";\nimport {TokenType as tt} from \"../tokenizer/types\";\nimport {isFlowEnabled, isTypeScriptEnabled, state} from \"../traverser/base\";\nimport {baseParseConditional} from \"../traverser/expression\";\nimport {flowParseTypeAnnotation} from \"./flow\";\nimport {tsParseTypeAnnotation} from \"./typescript\";\n\n/**\n * Common parser code for TypeScript and Flow.\n */\n\n// An apparent conditional expression could actually be an optional parameter in an arrow function.\nexport function typedParseConditional(noIn) {\n  // If we see ?:, this can't possibly be a valid conditional. typedParseParenItem will be called\n  // later to finish off the arrow parameter. We also need to handle bare ? tokens for optional\n  // parameters without type annotations, i.e. ?, and ?) .\n  if (match(tt.question)) {\n    const nextType = lookaheadType();\n    if (nextType === tt.colon || nextType === tt.comma || nextType === tt.parenR) {\n      return;\n    }\n  }\n  baseParseConditional(noIn);\n}\n\n// Note: These \"type casts\" are *not* valid TS expressions.\n// But we parse them here and change them when completing the arrow function.\nexport function typedParseParenItem() {\n  if (eat(tt.question)) {\n    state.tokens[state.tokens.length - 1].isType = true;\n  }\n  if (match(tt.colon)) {\n    if (isTypeScriptEnabled) {\n      tsParseTypeAnnotation();\n    } else if (isFlowEnabled) {\n      flowParseTypeAnnotation();\n    }\n  }\n}\n", "/* eslint max-len: 0 */\n\n// A recursive descent parser operates by defining functions for all\n// syntactic elements, and recursively calling those, each function\n// advancing the input stream and returning an AST node. Precedence\n// of constructs (for example, the fact that `!x[1]` means `!(x[1])`\n// instead of `(!x)[1]` is handled by the fact that the parser\n// function that parses unary prefix operators is called first, and\n// in turn calls the function that parses `[]` subscripts \u2014 that\n// way, it'll receive the node for `x[1]` already parsed, and wraps\n// *that* in the unary operator node.\n//\n// Acorn uses an [operator precedence parser][opp] to handle binary\n// operator precedence, because it is much more compact than using\n// the technique outlined above, which uses different, nesting\n// functions to specify precedence, for all of the ten binary\n// precedence levels that JavaScript defines.\n//\n// [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser\n\nimport {\n  flowParseArrow,\n  flowParseFunctionBodyAndFinish,\n  flowParseMaybeAssign,\n  flowParseSubscript,\n  flowParseSubscripts,\n  flowParseVariance,\n  flowStartParseAsyncArrowFromCallExpression,\n  flowStartParseNewArguments,\n  flowStartParseObjPropValue,\n} from \"../plugins/flow\";\nimport {jsxParseElement} from \"../plugins/jsx/index\";\nimport {typedParseConditional, typedParseParenItem} from \"../plugins/types\";\nimport {\n  tsParseArrow,\n  tsParseFunctionBodyAndFinish,\n  tsParseMaybeAssign,\n  tsParseSubscript,\n  tsParseType,\n  tsParseTypeAssertion,\n  tsStartParseAsyncArrowFromCallExpression,\n  tsStartParseNewArguments,\n  tsStartParseObjPropValue,\n} from \"../plugins/typescript\";\nimport {\n  eat,\n  IdentifierRole,\n  lookaheadType,\n  match,\n  next,\n  nextTemplateToken,\n  popTypeContext,\n  pushTypeContext,\n  retokenizeSlashAsRegex,\n} from \"../tokenizer/index\";\nimport {ContextualKeyword} from \"../tokenizer/keywords\";\nimport {Scope} from \"../tokenizer/state\";\nimport {TokenType, TokenType as tt} from \"../tokenizer/types\";\nimport {getNextContextId, isFlowEnabled, isJSXEnabled, isTypeScriptEnabled, state} from \"./base\";\nimport {\n  markPriorBindingIdentifier,\n  parseBindingIdentifier,\n  parseMaybeDefault,\n  parseRest,\n  parseSpread,\n} from \"./lval\";\nimport {\n  parseBlock,\n  parseClass,\n  parseDecorators,\n  parseFunction,\n  parseFunctionParams,\n} from \"./statement\";\nimport {\n  canInsertSemicolon,\n  eatContextual,\n  expect,\n  hasPrecedingLineBreak,\n  isContextual,\n  unexpected,\n} from \"./util\";\n\nexport class StopState {\n  \n  constructor(stop) {\n    this.stop = stop;\n  }\n}\n\n// ### Expression parsing\n\n// These nest, from the most general expression type at the top to\n// 'atomic', nondivisible expression types at the bottom. Most of\n// the functions will simply let the function (s) below them parse,\n// and, *if* the syntactic construct they handle is present, wrap\n// the AST node that the inner parser gave them in another node.\nexport function parseExpression(noIn = false) {\n  parseMaybeAssign(noIn);\n  if (match(tt.comma)) {\n    while (eat(tt.comma)) {\n      parseMaybeAssign(noIn);\n    }\n  }\n}\n\n/**\n * noIn is used when parsing a for loop so that we don't interpret a following \"in\" as the binary\n * operatior.\n * isWithinParens is used to indicate that we're parsing something that might be a comma expression\n * or might be an arrow function or might be a Flow type assertion (which requires explicit parens).\n * In these cases, we should allow : and ?: after the initial \"left\" part.\n */\nexport function parseMaybeAssign(noIn = false, isWithinParens = false) {\n  if (isTypeScriptEnabled) {\n    return tsParseMaybeAssign(noIn, isWithinParens);\n  } else if (isFlowEnabled) {\n    return flowParseMaybeAssign(noIn, isWithinParens);\n  } else {\n    return baseParseMaybeAssign(noIn, isWithinParens);\n  }\n}\n\n// Parse an assignment expression. This includes applications of\n// operators like `+=`.\n// Returns true if the expression was an arrow function.\nexport function baseParseMaybeAssign(noIn, isWithinParens) {\n  if (match(tt._yield)) {\n    parseYield();\n    return false;\n  }\n\n  if (match(tt.parenL) || match(tt.name) || match(tt._yield)) {\n    state.potentialArrowAt = state.start;\n  }\n\n  const wasArrow = parseMaybeConditional(noIn);\n  if (isWithinParens) {\n    parseParenItem();\n  }\n  if (state.type & TokenType.IS_ASSIGN) {\n    next();\n    parseMaybeAssign(noIn);\n    return false;\n  }\n  return wasArrow;\n}\n\n// Parse a ternary conditional (`?:`) operator.\n// Returns true if the expression was an arrow function.\nfunction parseMaybeConditional(noIn) {\n  const wasArrow = parseExprOps(noIn);\n  if (wasArrow) {\n    return true;\n  }\n  parseConditional(noIn);\n  return false;\n}\n\nfunction parseConditional(noIn) {\n  if (isTypeScriptEnabled || isFlowEnabled) {\n    typedParseConditional(noIn);\n  } else {\n    baseParseConditional(noIn);\n  }\n}\n\nexport function baseParseConditional(noIn) {\n  if (eat(tt.question)) {\n    parseMaybeAssign();\n    expect(tt.colon);\n    parseMaybeAssign(noIn);\n  }\n}\n\n// Start the precedence parser.\n// Returns true if this was an arrow function\nfunction parseExprOps(noIn) {\n  const startTokenIndex = state.tokens.length;\n  const wasArrow = parseMaybeUnary();\n  if (wasArrow) {\n    return true;\n  }\n  parseExprOp(startTokenIndex, -1, noIn);\n  return false;\n}\n\n// Parse binary operators with the operator precedence parsing\n// algorithm. `left` is the left-hand side of the operator.\n// `minPrec` provides context that allows the function to stop and\n// defer further parser to one of its callers when it encounters an\n// operator that has a lower precedence than the set it is parsing.\nfunction parseExprOp(startTokenIndex, minPrec, noIn) {\n  if (\n    isTypeScriptEnabled &&\n    (tt._in & TokenType.PRECEDENCE_MASK) > minPrec &&\n    !hasPrecedingLineBreak() &&\n    eatContextual(ContextualKeyword._as)\n  ) {\n    state.tokens[state.tokens.length - 1].type = tt._as;\n    const oldIsType = pushTypeContext(1);\n    tsParseType();\n    popTypeContext(oldIsType);\n    parseExprOp(startTokenIndex, minPrec, noIn);\n    return;\n  }\n\n  const prec = state.type & TokenType.PRECEDENCE_MASK;\n  if (prec > 0 && (!noIn || !match(tt._in))) {\n    if (prec > minPrec) {\n      const op = state.type;\n      next();\n      if (op === tt.nullishCoalescing) {\n        state.tokens[state.tokens.length - 1].nullishStartIndex = startTokenIndex;\n      }\n\n      const rhsStartTokenIndex = state.tokens.length;\n      parseMaybeUnary();\n      // Extend the right operand of this operator if possible.\n      parseExprOp(rhsStartTokenIndex, op & TokenType.IS_RIGHT_ASSOCIATIVE ? prec - 1 : prec, noIn);\n      if (op === tt.nullishCoalescing) {\n        state.tokens[startTokenIndex].numNullishCoalesceStarts++;\n        state.tokens[state.tokens.length - 1].numNullishCoalesceEnds++;\n      }\n      // Continue with any future operator holding this expression as the left operand.\n      parseExprOp(startTokenIndex, minPrec, noIn);\n    }\n  }\n}\n\n// Parse unary operators, both prefix and postfix.\n// Returns true if this was an arrow function.\nexport function parseMaybeUnary() {\n  if (isTypeScriptEnabled && !isJSXEnabled && eat(tt.lessThan)) {\n    tsParseTypeAssertion();\n    return false;\n  }\n\n  if (state.type & TokenType.IS_PREFIX) {\n    next();\n    parseMaybeUnary();\n    return false;\n  }\n\n  const wasArrow = parseExprSubscripts();\n  if (wasArrow) {\n    return true;\n  }\n  while (state.type & TokenType.IS_POSTFIX && !canInsertSemicolon()) {\n    // The tokenizer calls everything a preincrement, so make it a postincrement when\n    // we see it in that context.\n    if (state.type === tt.preIncDec) {\n      state.type = tt.postIncDec;\n    }\n    next();\n  }\n  return false;\n}\n\n// Parse call, dot, and `[]`-subscript expressions.\n// Returns true if this was an arrow function.\nexport function parseExprSubscripts() {\n  const startTokenIndex = state.tokens.length;\n  const wasArrow = parseExprAtom();\n  if (wasArrow) {\n    return true;\n  }\n  parseSubscripts(startTokenIndex);\n  // If there was any optional chain operation, the start token would be marked\n  // as such, so also mark the end now.\n  if (state.tokens.length > startTokenIndex && state.tokens[startTokenIndex].isOptionalChainStart) {\n    state.tokens[state.tokens.length - 1].isOptionalChainEnd = true;\n  }\n  return false;\n}\n\nfunction parseSubscripts(startTokenIndex, noCalls = false) {\n  if (isFlowEnabled) {\n    flowParseSubscripts(startTokenIndex, noCalls);\n  } else {\n    baseParseSubscripts(startTokenIndex, noCalls);\n  }\n}\n\nexport function baseParseSubscripts(startTokenIndex, noCalls = false) {\n  const stopState = new StopState(false);\n  do {\n    parseSubscript(startTokenIndex, noCalls, stopState);\n  } while (!stopState.stop && !state.error);\n}\n\nfunction parseSubscript(startTokenIndex, noCalls, stopState) {\n  if (isTypeScriptEnabled) {\n    tsParseSubscript(startTokenIndex, noCalls, stopState);\n  } else if (isFlowEnabled) {\n    flowParseSubscript(startTokenIndex, noCalls, stopState);\n  } else {\n    baseParseSubscript(startTokenIndex, noCalls, stopState);\n  }\n}\n\n/** Set 'state.stop = true' to indicate that we should stop parsing subscripts. */\nexport function baseParseSubscript(\n  startTokenIndex,\n  noCalls,\n  stopState,\n) {\n  if (!noCalls && eat(tt.doubleColon)) {\n    parseNoCallExpr();\n    stopState.stop = true;\n    // Propagate startTokenIndex so that `a::b?.()` will keep `a` as the first token. We may want\n    // to revisit this in the future when fully supporting bind syntax.\n    parseSubscripts(startTokenIndex, noCalls);\n  } else if (match(tt.questionDot)) {\n    state.tokens[startTokenIndex].isOptionalChainStart = true;\n    if (noCalls && lookaheadType() === tt.parenL) {\n      stopState.stop = true;\n      return;\n    }\n    next();\n    state.tokens[state.tokens.length - 1].subscriptStartIndex = startTokenIndex;\n\n    if (eat(tt.bracketL)) {\n      parseExpression();\n      expect(tt.bracketR);\n    } else if (eat(tt.parenL)) {\n      parseCallExpressionArguments();\n    } else {\n      parseIdentifier();\n    }\n  } else if (eat(tt.dot)) {\n    state.tokens[state.tokens.length - 1].subscriptStartIndex = startTokenIndex;\n    parseMaybePrivateName();\n  } else if (eat(tt.bracketL)) {\n    state.tokens[state.tokens.length - 1].subscriptStartIndex = startTokenIndex;\n    parseExpression();\n    expect(tt.bracketR);\n  } else if (!noCalls && match(tt.parenL)) {\n    if (atPossibleAsync()) {\n      // We see \"async\", but it's possible it's a usage of the name \"async\". Parse as if it's a\n      // function call, and if we see an arrow later, backtrack and re-parse as a parameter list.\n      const snapshot = state.snapshot();\n      const asyncStartTokenIndex = state.tokens.length;\n      next();\n      state.tokens[state.tokens.length - 1].subscriptStartIndex = startTokenIndex;\n\n      const callContextId = getNextContextId();\n\n      state.tokens[state.tokens.length - 1].contextId = callContextId;\n      parseCallExpressionArguments();\n      state.tokens[state.tokens.length - 1].contextId = callContextId;\n\n      if (shouldParseAsyncArrow()) {\n        // We hit an arrow, so backtrack and start again parsing function parameters.\n        state.restoreFromSnapshot(snapshot);\n        stopState.stop = true;\n        state.scopeDepth++;\n\n        parseFunctionParams();\n        parseAsyncArrowFromCallExpression(asyncStartTokenIndex);\n      }\n    } else {\n      next();\n      state.tokens[state.tokens.length - 1].subscriptStartIndex = startTokenIndex;\n      const callContextId = getNextContextId();\n      state.tokens[state.tokens.length - 1].contextId = callContextId;\n      parseCallExpressionArguments();\n      state.tokens[state.tokens.length - 1].contextId = callContextId;\n    }\n  } else if (match(tt.backQuote)) {\n    // Tagged template expression.\n    parseTemplate();\n  } else {\n    stopState.stop = true;\n  }\n}\n\nexport function atPossibleAsync() {\n  // This was made less strict than the original version to avoid passing around nodes, but it\n  // should be safe to have rare false positives here.\n  return (\n    state.tokens[state.tokens.length - 1].contextualKeyword === ContextualKeyword._async &&\n    !canInsertSemicolon()\n  );\n}\n\nexport function parseCallExpressionArguments() {\n  let first = true;\n  while (!eat(tt.parenR) && !state.error) {\n    if (first) {\n      first = false;\n    } else {\n      expect(tt.comma);\n      if (eat(tt.parenR)) {\n        break;\n      }\n    }\n\n    parseExprListItem(false);\n  }\n}\n\nfunction shouldParseAsyncArrow() {\n  return match(tt.colon) || match(tt.arrow);\n}\n\nfunction parseAsyncArrowFromCallExpression(startTokenIndex) {\n  if (isTypeScriptEnabled) {\n    tsStartParseAsyncArrowFromCallExpression();\n  } else if (isFlowEnabled) {\n    flowStartParseAsyncArrowFromCallExpression();\n  }\n  expect(tt.arrow);\n  parseArrowExpression(startTokenIndex);\n}\n\n// Parse a no-call expression (like argument of `new` or `::` operators).\n\nfunction parseNoCallExpr() {\n  const startTokenIndex = state.tokens.length;\n  parseExprAtom();\n  parseSubscripts(startTokenIndex, true);\n}\n\n// Parse an atomic expression \u2014 either a single token that is an\n// expression, an expression started by a keyword like `function` or\n// `new`, or an expression wrapped in punctuation like `()`, `[]`,\n// or `{}`.\n// Returns true if the parsed expression was an arrow function.\nexport function parseExprAtom() {\n  if (eat(tt.modulo)) {\n    // V8 intrinsic expression. Just parse the identifier, and the function invocation is parsed\n    // naturally.\n    parseIdentifier();\n    return false;\n  }\n\n  if (match(tt.jsxText)) {\n    parseLiteral();\n    return false;\n  } else if (match(tt.lessThan) && isJSXEnabled) {\n    state.type = tt.jsxTagStart;\n    jsxParseElement();\n    next();\n    return false;\n  }\n\n  const canBeArrow = state.potentialArrowAt === state.start;\n  switch (state.type) {\n    case tt.slash:\n    case tt.assign:\n      retokenizeSlashAsRegex();\n    // Fall through.\n\n    case tt._super:\n    case tt._this:\n    case tt.regexp:\n    case tt.num:\n    case tt.bigint:\n    case tt.string:\n    case tt._null:\n    case tt._true:\n    case tt._false:\n      next();\n      return false;\n\n    case tt._import:\n      next();\n      if (match(tt.dot)) {\n        // import.meta\n        state.tokens[state.tokens.length - 1].type = tt.name;\n        next();\n        parseIdentifier();\n      }\n      return false;\n\n    case tt.name: {\n      const startTokenIndex = state.tokens.length;\n      const functionStart = state.start;\n      const contextualKeyword = state.contextualKeyword;\n      parseIdentifier();\n      if (contextualKeyword === ContextualKeyword._await) {\n        parseAwait();\n        return false;\n      } else if (\n        contextualKeyword === ContextualKeyword._async &&\n        match(tt._function) &&\n        !canInsertSemicolon()\n      ) {\n        next();\n        parseFunction(functionStart, false);\n        return false;\n      } else if (\n        canBeArrow &&\n        !canInsertSemicolon() &&\n        contextualKeyword === ContextualKeyword._async &&\n        match(tt.name)\n      ) {\n        state.scopeDepth++;\n        parseBindingIdentifier(false);\n        expect(tt.arrow);\n        // let foo = async bar => {};\n        parseArrowExpression(startTokenIndex);\n        return true;\n      }\n\n      if (canBeArrow && !canInsertSemicolon() && match(tt.arrow)) {\n        state.scopeDepth++;\n        markPriorBindingIdentifier(false);\n        expect(tt.arrow);\n        parseArrowExpression(startTokenIndex);\n        return true;\n      }\n\n      state.tokens[state.tokens.length - 1].identifierRole = IdentifierRole.Access;\n      return false;\n    }\n\n    case tt._do: {\n      next();\n      parseBlock(false);\n      return false;\n    }\n\n    case tt.parenL: {\n      const wasArrow = parseParenAndDistinguishExpression(canBeArrow);\n      return wasArrow;\n    }\n\n    case tt.bracketL:\n      next();\n      parseExprList(tt.bracketR, true);\n      return false;\n\n    case tt.braceL:\n      parseObj(false, false);\n      return false;\n\n    case tt._function:\n      parseFunctionExpression();\n      return false;\n\n    case tt.at:\n      parseDecorators();\n    // Fall through.\n\n    case tt._class:\n      parseClass(false);\n      return false;\n\n    case tt._new:\n      parseNew();\n      return false;\n\n    case tt.backQuote:\n      parseTemplate();\n      return false;\n\n    case tt.doubleColon: {\n      next();\n      parseNoCallExpr();\n      return false;\n    }\n\n    case tt.hash: {\n      // Smart pipeline topic reference.\n      next();\n      return false;\n    }\n\n    default:\n      unexpected();\n      return false;\n  }\n}\n\nfunction parseMaybePrivateName() {\n  eat(tt.hash);\n  parseIdentifier();\n}\n\nfunction parseFunctionExpression() {\n  const functionStart = state.start;\n  parseIdentifier();\n  if (eat(tt.dot)) {\n    // function.sent\n    parseIdentifier();\n  }\n  parseFunction(functionStart, false);\n}\n\nexport function parseLiteral() {\n  next();\n}\n\nexport function parseParenExpression() {\n  expect(tt.parenL);\n  parseExpression();\n  expect(tt.parenR);\n}\n\n// Returns true if this was an arrow expression.\nfunction parseParenAndDistinguishExpression(canBeArrow) {\n  // Assume this is a normal parenthesized expression, but if we see an arrow, we'll bail and\n  // start over as a parameter list.\n  const snapshot = state.snapshot();\n\n  const startTokenIndex = state.tokens.length;\n  expect(tt.parenL);\n\n  let first = true;\n\n  while (!match(tt.parenR) && !state.error) {\n    if (first) {\n      first = false;\n    } else {\n      expect(tt.comma);\n      if (match(tt.parenR)) {\n        break;\n      }\n    }\n\n    if (match(tt.ellipsis)) {\n      parseRest(false /* isBlockScope */);\n      parseParenItem();\n      break;\n    } else {\n      parseMaybeAssign(false, true);\n    }\n  }\n\n  expect(tt.parenR);\n\n  if (canBeArrow && shouldParseArrow()) {\n    const wasArrow = parseArrow();\n    if (wasArrow) {\n      // It was an arrow function this whole time, so start over and parse it as params so that we\n      // get proper token annotations.\n      state.restoreFromSnapshot(snapshot);\n      state.scopeDepth++;\n      // Don't specify a context ID because arrow functions don't need a context ID.\n      parseFunctionParams();\n      parseArrow();\n      parseArrowExpression(startTokenIndex);\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction shouldParseArrow() {\n  return match(tt.colon) || !canInsertSemicolon();\n}\n\n// Returns whether there was an arrow token.\nexport function parseArrow() {\n  if (isTypeScriptEnabled) {\n    return tsParseArrow();\n  } else if (isFlowEnabled) {\n    return flowParseArrow();\n  } else {\n    return eat(tt.arrow);\n  }\n}\n\nfunction parseParenItem() {\n  if (isTypeScriptEnabled || isFlowEnabled) {\n    typedParseParenItem();\n  }\n}\n\n// New's precedence is slightly tricky. It must allow its argument to\n// be a `[]` or dot subscript expression, but not a call \u2014 at least,\n// not without wrapping it in parentheses. Thus, it uses the noCalls\n// argument to parseSubscripts to prevent it from consuming the\n// argument list.\nfunction parseNew() {\n  expect(tt._new);\n  if (eat(tt.dot)) {\n    // new.target\n    parseIdentifier();\n    return;\n  }\n  parseNoCallExpr();\n  eat(tt.questionDot);\n  parseNewArguments();\n}\n\nfunction parseNewArguments() {\n  if (isTypeScriptEnabled) {\n    tsStartParseNewArguments();\n  } else if (isFlowEnabled) {\n    flowStartParseNewArguments();\n  }\n  if (eat(tt.parenL)) {\n    parseExprList(tt.parenR);\n  }\n}\n\nexport function parseTemplate() {\n  // Finish `, read quasi\n  nextTemplateToken();\n  // Finish quasi, read ${\n  nextTemplateToken();\n  while (!match(tt.backQuote) && !state.error) {\n    expect(tt.dollarBraceL);\n    parseExpression();\n    // Finish }, read quasi\n    nextTemplateToken();\n    // Finish quasi, read either ${ or `\n    nextTemplateToken();\n  }\n  next();\n}\n\n// Parse an object literal or binding pattern.\nexport function parseObj(isPattern, isBlockScope) {\n  // Attach a context ID to the object open and close brace and each object key.\n  const contextId = getNextContextId();\n  let first = true;\n\n  next();\n  state.tokens[state.tokens.length - 1].contextId = contextId;\n\n  while (!eat(tt.braceR) && !state.error) {\n    if (first) {\n      first = false;\n    } else {\n      expect(tt.comma);\n      if (eat(tt.braceR)) {\n        break;\n      }\n    }\n\n    let isGenerator = false;\n    if (match(tt.ellipsis)) {\n      const previousIndex = state.tokens.length;\n      parseSpread();\n      if (isPattern) {\n        // Mark role when the only thing being spread over is an identifier.\n        if (state.tokens.length === previousIndex + 2) {\n          markPriorBindingIdentifier(isBlockScope);\n        }\n        if (eat(tt.braceR)) {\n          break;\n        }\n      }\n      continue;\n    }\n\n    if (!isPattern) {\n      isGenerator = eat(tt.star);\n    }\n\n    if (!isPattern && isContextual(ContextualKeyword._async)) {\n      if (isGenerator) unexpected();\n\n      parseIdentifier();\n      if (\n        match(tt.colon) ||\n        match(tt.parenL) ||\n        match(tt.braceR) ||\n        match(tt.eq) ||\n        match(tt.comma)\n      ) {\n        // This is a key called \"async\" rather than an async function.\n      } else {\n        if (match(tt.star)) {\n          next();\n          isGenerator = true;\n        }\n        parsePropertyName(contextId);\n      }\n    } else {\n      parsePropertyName(contextId);\n    }\n\n    parseObjPropValue(isPattern, isBlockScope, contextId);\n  }\n\n  state.tokens[state.tokens.length - 1].contextId = contextId;\n}\n\nfunction isGetterOrSetterMethod(isPattern) {\n  // We go off of the next and don't bother checking if the node key is actually \"get\" or \"set\".\n  // This lets us avoid generating a node, and should only make the validation worse.\n  return (\n    !isPattern &&\n    (match(tt.string) || // get \"string\"() {}\n    match(tt.num) || // get 1() {}\n    match(tt.bracketL) || // get [\"string\"]() {}\n    match(tt.name) || // get foo() {}\n      !!(state.type & TokenType.IS_KEYWORD)) // get debugger() {}\n  );\n}\n\n// Returns true if this was a method.\nfunction parseObjectMethod(isPattern, objectContextId) {\n  // We don't need to worry about modifiers because object methods can't have optional bodies, so\n  // the start will never be used.\n  const functionStart = state.start;\n  if (match(tt.parenL)) {\n    if (isPattern) unexpected();\n    parseMethod(functionStart, /* isConstructor */ false);\n    return true;\n  }\n\n  if (isGetterOrSetterMethod(isPattern)) {\n    parsePropertyName(objectContextId);\n    parseMethod(functionStart, /* isConstructor */ false);\n    return true;\n  }\n  return false;\n}\n\nfunction parseObjectProperty(isPattern, isBlockScope) {\n  if (eat(tt.colon)) {\n    if (isPattern) {\n      parseMaybeDefault(isBlockScope);\n    } else {\n      parseMaybeAssign(false);\n    }\n    return;\n  }\n\n  // Since there's no colon, we assume this is an object shorthand.\n\n  // If we're in a destructuring, we've now discovered that the key was actually an assignee, so\n  // we need to tag it as a declaration with the appropriate scope. Otherwise, we might need to\n  // transform it on access, so mark it as a normal object shorthand.\n  if (isPattern) {\n    state.tokens[state.tokens.length - 1].identifierRole = isBlockScope\n      ? IdentifierRole.ObjectShorthandBlockScopedDeclaration\n      : IdentifierRole.ObjectShorthandFunctionScopedDeclaration;\n  } else {\n    state.tokens[state.tokens.length - 1].identifierRole = IdentifierRole.ObjectShorthand;\n  }\n\n  // Regardless of whether we know this to be a pattern or if we're in an ambiguous context, allow\n  // parsing as if there's a default value.\n  parseMaybeDefault(isBlockScope, true);\n}\n\nfunction parseObjPropValue(\n  isPattern,\n  isBlockScope,\n  objectContextId,\n) {\n  if (isTypeScriptEnabled) {\n    tsStartParseObjPropValue();\n  } else if (isFlowEnabled) {\n    flowStartParseObjPropValue();\n  }\n  const wasMethod = parseObjectMethod(isPattern, objectContextId);\n  if (!wasMethod) {\n    parseObjectProperty(isPattern, isBlockScope);\n  }\n}\n\nexport function parsePropertyName(objectContextId) {\n  if (isFlowEnabled) {\n    flowParseVariance();\n  }\n  if (eat(tt.bracketL)) {\n    state.tokens[state.tokens.length - 1].contextId = objectContextId;\n    parseMaybeAssign();\n    expect(tt.bracketR);\n    state.tokens[state.tokens.length - 1].contextId = objectContextId;\n  } else {\n    if (match(tt.num) || match(tt.string) || match(tt.bigint)) {\n      parseExprAtom();\n    } else {\n      parseMaybePrivateName();\n    }\n\n    state.tokens[state.tokens.length - 1].identifierRole = IdentifierRole.ObjectKey;\n    state.tokens[state.tokens.length - 1].contextId = objectContextId;\n  }\n}\n\n// Parse object or class method.\nexport function parseMethod(functionStart, isConstructor) {\n  const funcContextId = getNextContextId();\n\n  state.scopeDepth++;\n  const startTokenIndex = state.tokens.length;\n  const allowModifiers = isConstructor; // For TypeScript parameter properties\n  parseFunctionParams(allowModifiers, funcContextId);\n  parseFunctionBodyAndFinish(functionStart, funcContextId);\n  const endTokenIndex = state.tokens.length;\n  state.scopes.push(new Scope(startTokenIndex, endTokenIndex, true));\n  state.scopeDepth--;\n}\n\n// Parse arrow function expression.\n// If the parameters are provided, they will be converted to an\n// assignable list.\nexport function parseArrowExpression(startTokenIndex) {\n  parseFunctionBody(true);\n  const endTokenIndex = state.tokens.length;\n  state.scopes.push(new Scope(startTokenIndex, endTokenIndex, true));\n  state.scopeDepth--;\n}\n\nexport function parseFunctionBodyAndFinish(functionStart, funcContextId = 0) {\n  if (isTypeScriptEnabled) {\n    tsParseFunctionBodyAndFinish(functionStart, funcContextId);\n  } else if (isFlowEnabled) {\n    flowParseFunctionBodyAndFinish(funcContextId);\n  } else {\n    parseFunctionBody(false, funcContextId);\n  }\n}\n\nexport function parseFunctionBody(allowExpression, funcContextId = 0) {\n  const isExpression = allowExpression && !match(tt.braceL);\n\n  if (isExpression) {\n    parseMaybeAssign();\n  } else {\n    parseBlock(true /* allowDirectives */, true /* isFunctionScope */, funcContextId);\n  }\n}\n\n// Parses a comma-separated list of expressions, and returns them as\n// an array. `close` is the token type that ends the list, and\n// `allowEmpty` can be turned on to allow subsequent commas with\n// nothing in between them to be parsed as `null` (which is needed\n// for array literals).\n\nfunction parseExprList(close, allowEmpty = false) {\n  let first = true;\n  while (!eat(close) && !state.error) {\n    if (first) {\n      first = false;\n    } else {\n      expect(tt.comma);\n      if (eat(close)) break;\n    }\n    parseExprListItem(allowEmpty);\n  }\n}\n\nfunction parseExprListItem(allowEmpty) {\n  if (allowEmpty && match(tt.comma)) {\n    // Empty item; nothing more to parse for this item.\n  } else if (match(tt.ellipsis)) {\n    parseSpread();\n    parseParenItem();\n  } else if (match(tt.question)) {\n    // Partial function application proposal.\n    next();\n  } else {\n    parseMaybeAssign(false, true);\n  }\n}\n\n// Parse the next token as an identifier.\nexport function parseIdentifier() {\n  next();\n  state.tokens[state.tokens.length - 1].type = tt.name;\n}\n\n// Parses await expression inside async function.\nfunction parseAwait() {\n  parseMaybeUnary();\n}\n\n// Parses yield expression inside generator.\nfunction parseYield() {\n  next();\n  if (!match(tt.semi) && !canInsertSemicolon()) {\n    eat(tt.star);\n    parseMaybeAssign();\n  }\n}\n", "/* eslint max-len: 0 */\n\nimport {\n  eat,\n  lookaheadType,\n  lookaheadTypeAndKeyword,\n  match,\n  next,\n  popTypeContext,\n  pushTypeContext,\n\n} from \"../tokenizer/index\";\nimport {ContextualKeyword} from \"../tokenizer/keywords\";\nimport {TokenType, TokenType as tt} from \"../tokenizer/types\";\nimport {input, state} from \"../traverser/base\";\nimport {\n  baseParseMaybeAssign,\n  baseParseSubscript,\n  baseParseSubscripts,\n  parseArrow,\n  parseArrowExpression,\n  parseCallExpressionArguments,\n  parseExprAtom,\n  parseExpression,\n  parseFunctionBody,\n  parseIdentifier,\n  parseLiteral,\n\n} from \"../traverser/expression\";\nimport {\n  baseParseExportStar,\n  parseExport,\n  parseExportFrom,\n  parseExportSpecifiers,\n  parseFunctionParams,\n  parseImport,\n  parseStatement,\n} from \"../traverser/statement\";\nimport {\n  canInsertSemicolon,\n  eatContextual,\n  expect,\n  expectContextual,\n  isContextual,\n  isLookaheadContextual,\n  semicolon,\n  unexpected,\n} from \"../traverser/util\";\n\nfunction isMaybeDefaultImport(lookahead) {\n  return (\n    (lookahead.type === tt.name || !!(lookahead.type & TokenType.IS_KEYWORD)) &&\n    lookahead.contextualKeyword !== ContextualKeyword._from\n  );\n}\n\nfunction flowParseTypeInitialiser(tok) {\n  const oldIsType = pushTypeContext(0);\n  expect(tok || tt.colon);\n  flowParseType();\n  popTypeContext(oldIsType);\n}\n\nfunction flowParsePredicate() {\n  expect(tt.modulo);\n  expectContextual(ContextualKeyword._checks);\n  if (eat(tt.parenL)) {\n    parseExpression();\n    expect(tt.parenR);\n  }\n}\n\nfunction flowParseTypeAndPredicateInitialiser() {\n  const oldIsType = pushTypeContext(0);\n  expect(tt.colon);\n  if (match(tt.modulo)) {\n    flowParsePredicate();\n  } else {\n    flowParseType();\n    if (match(tt.modulo)) {\n      flowParsePredicate();\n    }\n  }\n  popTypeContext(oldIsType);\n}\n\nfunction flowParseDeclareClass() {\n  next();\n  flowParseInterfaceish(/* isClass */ true);\n}\n\nfunction flowParseDeclareFunction() {\n  next();\n  parseIdentifier();\n\n  if (match(tt.lessThan)) {\n    flowParseTypeParameterDeclaration();\n  }\n\n  expect(tt.parenL);\n  flowParseFunctionTypeParams();\n  expect(tt.parenR);\n\n  flowParseTypeAndPredicateInitialiser();\n\n  semicolon();\n}\n\nfunction flowParseDeclare() {\n  if (match(tt._class)) {\n    flowParseDeclareClass();\n  } else if (match(tt._function)) {\n    flowParseDeclareFunction();\n  } else if (match(tt._var)) {\n    flowParseDeclareVariable();\n  } else if (eatContextual(ContextualKeyword._module)) {\n    if (eat(tt.dot)) {\n      flowParseDeclareModuleExports();\n    } else {\n      flowParseDeclareModule();\n    }\n  } else if (isContextual(ContextualKeyword._type)) {\n    flowParseDeclareTypeAlias();\n  } else if (isContextual(ContextualKeyword._opaque)) {\n    flowParseDeclareOpaqueType();\n  } else if (isContextual(ContextualKeyword._interface)) {\n    flowParseDeclareInterface();\n  } else if (match(tt._export)) {\n    flowParseDeclareExportDeclaration();\n  } else {\n    unexpected();\n  }\n}\n\nfunction flowParseDeclareVariable() {\n  next();\n  flowParseTypeAnnotatableIdentifier();\n  semicolon();\n}\n\nfunction flowParseDeclareModule() {\n  if (match(tt.string)) {\n    parseExprAtom();\n  } else {\n    parseIdentifier();\n  }\n\n  expect(tt.braceL);\n  while (!match(tt.braceR) && !state.error) {\n    if (match(tt._import)) {\n      next();\n      parseImport();\n    } else {\n      unexpected();\n    }\n  }\n  expect(tt.braceR);\n}\n\nfunction flowParseDeclareExportDeclaration() {\n  expect(tt._export);\n\n  if (eat(tt._default)) {\n    if (match(tt._function) || match(tt._class)) {\n      // declare export default class ...\n      // declare export default function ...\n      flowParseDeclare();\n    } else {\n      // declare export default [type];\n      flowParseType();\n      semicolon();\n    }\n  } else if (\n    match(tt._var) || // declare export var ...\n    match(tt._function) || // declare export function ...\n    match(tt._class) || // declare export class ...\n    isContextual(ContextualKeyword._opaque) // declare export opaque ..\n  ) {\n    flowParseDeclare();\n  } else if (\n    match(tt.star) || // declare export * from ''\n    match(tt.braceL) || // declare export {} ...\n    isContextual(ContextualKeyword._interface) || // declare export interface ...\n    isContextual(ContextualKeyword._type) || // declare export type ...\n    isContextual(ContextualKeyword._opaque) // declare export opaque type ...\n  ) {\n    parseExport();\n  } else {\n    unexpected();\n  }\n}\n\nfunction flowParseDeclareModuleExports() {\n  expectContextual(ContextualKeyword._exports);\n  flowParseTypeAnnotation();\n  semicolon();\n}\n\nfunction flowParseDeclareTypeAlias() {\n  next();\n  flowParseTypeAlias();\n}\n\nfunction flowParseDeclareOpaqueType() {\n  next();\n  flowParseOpaqueType(true);\n}\n\nfunction flowParseDeclareInterface() {\n  next();\n  flowParseInterfaceish();\n}\n\n// Interfaces\n\nfunction flowParseInterfaceish(isClass = false) {\n  flowParseRestrictedIdentifier();\n\n  if (match(tt.lessThan)) {\n    flowParseTypeParameterDeclaration();\n  }\n\n  if (eat(tt._extends)) {\n    do {\n      flowParseInterfaceExtends();\n    } while (!isClass && eat(tt.comma));\n  }\n\n  if (isContextual(ContextualKeyword._mixins)) {\n    next();\n    do {\n      flowParseInterfaceExtends();\n    } while (eat(tt.comma));\n  }\n\n  if (isContextual(ContextualKeyword._implements)) {\n    next();\n    do {\n      flowParseInterfaceExtends();\n    } while (eat(tt.comma));\n  }\n\n  flowParseObjectType(isClass, false, isClass);\n}\n\nfunction flowParseInterfaceExtends() {\n  flowParseQualifiedTypeIdentifier(false);\n  if (match(tt.lessThan)) {\n    flowParseTypeParameterInstantiation();\n  }\n}\n\nfunction flowParseInterface() {\n  flowParseInterfaceish();\n}\n\nfunction flowParseRestrictedIdentifier() {\n  parseIdentifier();\n}\n\nfunction flowParseTypeAlias() {\n  flowParseRestrictedIdentifier();\n\n  if (match(tt.lessThan)) {\n    flowParseTypeParameterDeclaration();\n  }\n\n  flowParseTypeInitialiser(tt.eq);\n  semicolon();\n}\n\nfunction flowParseOpaqueType(declare) {\n  expectContextual(ContextualKeyword._type);\n  flowParseRestrictedIdentifier();\n\n  if (match(tt.lessThan)) {\n    flowParseTypeParameterDeclaration();\n  }\n\n  // Parse the supertype\n  if (match(tt.colon)) {\n    flowParseTypeInitialiser(tt.colon);\n  }\n\n  if (!declare) {\n    flowParseTypeInitialiser(tt.eq);\n  }\n  semicolon();\n}\n\nfunction flowParseTypeParameter() {\n  flowParseVariance();\n  flowParseTypeAnnotatableIdentifier();\n\n  if (eat(tt.eq)) {\n    flowParseType();\n  }\n}\n\nexport function flowParseTypeParameterDeclaration() {\n  const oldIsType = pushTypeContext(0);\n  // istanbul ignore else: this condition is already checked at all call sites\n  if (match(tt.lessThan) || match(tt.typeParameterStart)) {\n    next();\n  } else {\n    unexpected();\n  }\n\n  do {\n    flowParseTypeParameter();\n    if (!match(tt.greaterThan)) {\n      expect(tt.comma);\n    }\n  } while (!match(tt.greaterThan) && !state.error);\n  expect(tt.greaterThan);\n  popTypeContext(oldIsType);\n}\n\nfunction flowParseTypeParameterInstantiation() {\n  const oldIsType = pushTypeContext(0);\n  expect(tt.lessThan);\n  while (!match(tt.greaterThan) && !state.error) {\n    flowParseType();\n    if (!match(tt.greaterThan)) {\n      expect(tt.comma);\n    }\n  }\n  expect(tt.greaterThan);\n  popTypeContext(oldIsType);\n}\n\nfunction flowParseInterfaceType() {\n  expectContextual(ContextualKeyword._interface);\n  if (eat(tt._extends)) {\n    do {\n      flowParseInterfaceExtends();\n    } while (eat(tt.comma));\n  }\n  flowParseObjectType(false, false, false);\n}\n\nfunction flowParseObjectPropertyKey() {\n  if (match(tt.num) || match(tt.string)) {\n    parseExprAtom();\n  } else {\n    parseIdentifier();\n  }\n}\n\nfunction flowParseObjectTypeIndexer() {\n  // Note: bracketL has already been consumed\n  if (lookaheadType() === tt.colon) {\n    flowParseObjectPropertyKey();\n    flowParseTypeInitialiser();\n  } else {\n    flowParseType();\n  }\n  expect(tt.bracketR);\n  flowParseTypeInitialiser();\n}\n\nfunction flowParseObjectTypeInternalSlot() {\n  // Note: both bracketL have already been consumed\n  flowParseObjectPropertyKey();\n  expect(tt.bracketR);\n  expect(tt.bracketR);\n  if (match(tt.lessThan) || match(tt.parenL)) {\n    flowParseObjectTypeMethodish();\n  } else {\n    eat(tt.question);\n    flowParseTypeInitialiser();\n  }\n}\n\nfunction flowParseObjectTypeMethodish() {\n  if (match(tt.lessThan)) {\n    flowParseTypeParameterDeclaration();\n  }\n\n  expect(tt.parenL);\n  while (!match(tt.parenR) && !match(tt.ellipsis) && !state.error) {\n    flowParseFunctionTypeParam();\n    if (!match(tt.parenR)) {\n      expect(tt.comma);\n    }\n  }\n\n  if (eat(tt.ellipsis)) {\n    flowParseFunctionTypeParam();\n  }\n  expect(tt.parenR);\n  flowParseTypeInitialiser();\n}\n\nfunction flowParseObjectTypeCallProperty() {\n  flowParseObjectTypeMethodish();\n}\n\nfunction flowParseObjectType(allowStatic, allowExact, allowProto) {\n  let endDelim;\n  if (allowExact && match(tt.braceBarL)) {\n    expect(tt.braceBarL);\n    endDelim = tt.braceBarR;\n  } else {\n    expect(tt.braceL);\n    endDelim = tt.braceR;\n  }\n\n  while (!match(endDelim) && !state.error) {\n    if (allowProto && isContextual(ContextualKeyword._proto)) {\n      const lookahead = lookaheadType();\n      if (lookahead !== tt.colon && lookahead !== tt.question) {\n        next();\n        allowStatic = false;\n      }\n    }\n    if (allowStatic && isContextual(ContextualKeyword._static)) {\n      const lookahead = lookaheadType();\n      if (lookahead !== tt.colon && lookahead !== tt.question) {\n        next();\n      }\n    }\n\n    flowParseVariance();\n\n    if (eat(tt.bracketL)) {\n      if (eat(tt.bracketL)) {\n        flowParseObjectTypeInternalSlot();\n      } else {\n        flowParseObjectTypeIndexer();\n      }\n    } else if (match(tt.parenL) || match(tt.lessThan)) {\n      flowParseObjectTypeCallProperty();\n    } else {\n      if (isContextual(ContextualKeyword._get) || isContextual(ContextualKeyword._set)) {\n        const lookahead = lookaheadType();\n        if (lookahead === tt.name || lookahead === tt.string || lookahead === tt.num) {\n          next();\n        }\n      }\n\n      flowParseObjectTypeProperty();\n    }\n\n    flowObjectTypeSemicolon();\n  }\n\n  expect(endDelim);\n}\n\nfunction flowParseObjectTypeProperty() {\n  if (match(tt.ellipsis)) {\n    expect(tt.ellipsis);\n    if (!eat(tt.comma)) {\n      eat(tt.semi);\n    }\n    // Explicit inexact object syntax.\n    if (match(tt.braceR)) {\n      return;\n    }\n    flowParseType();\n  } else {\n    flowParseObjectPropertyKey();\n    if (match(tt.lessThan) || match(tt.parenL)) {\n      // This is a method property\n      flowParseObjectTypeMethodish();\n    } else {\n      eat(tt.question);\n      flowParseTypeInitialiser();\n    }\n  }\n}\n\nfunction flowObjectTypeSemicolon() {\n  if (!eat(tt.semi) && !eat(tt.comma) && !match(tt.braceR) && !match(tt.braceBarR)) {\n    unexpected();\n  }\n}\n\nfunction flowParseQualifiedTypeIdentifier(initialIdAlreadyParsed) {\n  if (!initialIdAlreadyParsed) {\n    parseIdentifier();\n  }\n  while (eat(tt.dot)) {\n    parseIdentifier();\n  }\n}\n\nfunction flowParseGenericType() {\n  flowParseQualifiedTypeIdentifier(true);\n  if (match(tt.lessThan)) {\n    flowParseTypeParameterInstantiation();\n  }\n}\n\nfunction flowParseTypeofType() {\n  expect(tt._typeof);\n  flowParsePrimaryType();\n}\n\nfunction flowParseTupleType() {\n  expect(tt.bracketL);\n  // We allow trailing commas\n  while (state.pos < input.length && !match(tt.bracketR)) {\n    flowParseType();\n    if (match(tt.bracketR)) {\n      break;\n    }\n    expect(tt.comma);\n  }\n  expect(tt.bracketR);\n}\n\nfunction flowParseFunctionTypeParam() {\n  const lookahead = lookaheadType();\n  if (lookahead === tt.colon || lookahead === tt.question) {\n    parseIdentifier();\n    eat(tt.question);\n    flowParseTypeInitialiser();\n  } else {\n    flowParseType();\n  }\n}\n\nfunction flowParseFunctionTypeParams() {\n  while (!match(tt.parenR) && !match(tt.ellipsis) && !state.error) {\n    flowParseFunctionTypeParam();\n    if (!match(tt.parenR)) {\n      expect(tt.comma);\n    }\n  }\n  if (eat(tt.ellipsis)) {\n    flowParseFunctionTypeParam();\n  }\n}\n\n// The parsing of types roughly parallels the parsing of expressions, and\n// primary types are kind of like primary expressions...they're the\n// primitives with which other types are constructed.\nfunction flowParsePrimaryType() {\n  let isGroupedType = false;\n  const oldNoAnonFunctionType = state.noAnonFunctionType;\n\n  switch (state.type) {\n    case tt.name: {\n      if (isContextual(ContextualKeyword._interface)) {\n        flowParseInterfaceType();\n        return;\n      }\n      parseIdentifier();\n      flowParseGenericType();\n      return;\n    }\n\n    case tt.braceL:\n      flowParseObjectType(false, false, false);\n      return;\n\n    case tt.braceBarL:\n      flowParseObjectType(false, true, false);\n      return;\n\n    case tt.bracketL:\n      flowParseTupleType();\n      return;\n\n    case tt.lessThan:\n      flowParseTypeParameterDeclaration();\n      expect(tt.parenL);\n      flowParseFunctionTypeParams();\n      expect(tt.parenR);\n      expect(tt.arrow);\n      flowParseType();\n      return;\n\n    case tt.parenL:\n      next();\n\n      // Check to see if this is actually a grouped type\n      if (!match(tt.parenR) && !match(tt.ellipsis)) {\n        if (match(tt.name)) {\n          const token = lookaheadType();\n          isGroupedType = token !== tt.question && token !== tt.colon;\n        } else {\n          isGroupedType = true;\n        }\n      }\n\n      if (isGroupedType) {\n        state.noAnonFunctionType = false;\n        flowParseType();\n        state.noAnonFunctionType = oldNoAnonFunctionType;\n\n        // A `,` or a `) =>` means this is an anonymous function type\n        if (\n          state.noAnonFunctionType ||\n          !(match(tt.comma) || (match(tt.parenR) && lookaheadType() === tt.arrow))\n        ) {\n          expect(tt.parenR);\n          return;\n        } else {\n          // Eat a comma if there is one\n          eat(tt.comma);\n        }\n      }\n\n      flowParseFunctionTypeParams();\n\n      expect(tt.parenR);\n      expect(tt.arrow);\n      flowParseType();\n      return;\n\n    case tt.minus:\n      next();\n      parseLiteral();\n      return;\n\n    case tt.string:\n    case tt.num:\n    case tt._true:\n    case tt._false:\n    case tt._null:\n    case tt._this:\n    case tt._void:\n    case tt.star:\n      next();\n      return;\n\n    default:\n      if (state.type === tt._typeof) {\n        flowParseTypeofType();\n        return;\n      } else if (state.type & TokenType.IS_KEYWORD) {\n        next();\n        state.tokens[state.tokens.length - 1].type = tt.name;\n        return;\n      }\n  }\n\n  unexpected();\n}\n\nfunction flowParsePostfixType() {\n  flowParsePrimaryType();\n  while (!canInsertSemicolon() && match(tt.bracketL)) {\n    expect(tt.bracketL);\n    expect(tt.bracketR);\n  }\n}\n\nfunction flowParsePrefixType() {\n  if (eat(tt.question)) {\n    flowParsePrefixType();\n  } else {\n    flowParsePostfixType();\n  }\n}\n\nfunction flowParseAnonFunctionWithoutParens() {\n  flowParsePrefixType();\n  if (!state.noAnonFunctionType && eat(tt.arrow)) {\n    flowParseType();\n  }\n}\n\nfunction flowParseIntersectionType() {\n  eat(tt.bitwiseAND);\n  flowParseAnonFunctionWithoutParens();\n  while (eat(tt.bitwiseAND)) {\n    flowParseAnonFunctionWithoutParens();\n  }\n}\n\nfunction flowParseUnionType() {\n  eat(tt.bitwiseOR);\n  flowParseIntersectionType();\n  while (eat(tt.bitwiseOR)) {\n    flowParseIntersectionType();\n  }\n}\n\nfunction flowParseType() {\n  flowParseUnionType();\n}\n\nexport function flowParseTypeAnnotation() {\n  flowParseTypeInitialiser();\n}\n\nfunction flowParseTypeAnnotatableIdentifier() {\n  parseIdentifier();\n  if (match(tt.colon)) {\n    flowParseTypeAnnotation();\n  }\n}\n\nexport function flowParseVariance() {\n  if (match(tt.plus) || match(tt.minus)) {\n    next();\n  }\n}\n\n// ==================================\n// Overrides\n// ==================================\n\nexport function flowParseFunctionBodyAndFinish(funcContextId) {\n  // For arrow functions, `parseArrow` handles the return type itself.\n  if (match(tt.colon)) {\n    flowParseTypeAndPredicateInitialiser();\n  }\n\n  parseFunctionBody(false, funcContextId);\n}\n\nexport function flowParseSubscript(\n  startTokenIndex,\n  noCalls,\n  stopState,\n) {\n  if (match(tt.questionDot) && lookaheadType() === tt.lessThan) {\n    if (noCalls) {\n      stopState.stop = true;\n      return;\n    }\n    next();\n    flowParseTypeParameterInstantiation();\n    expect(tt.parenL);\n    parseCallExpressionArguments();\n    return;\n  } else if (!noCalls && match(tt.lessThan)) {\n    const snapshot = state.snapshot();\n    flowParseTypeParameterInstantiation();\n    expect(tt.parenL);\n    parseCallExpressionArguments();\n    if (state.error) {\n      state.restoreFromSnapshot(snapshot);\n    } else {\n      return;\n    }\n  }\n  baseParseSubscript(startTokenIndex, noCalls, stopState);\n}\n\nexport function flowStartParseNewArguments() {\n  if (match(tt.lessThan)) {\n    const snapshot = state.snapshot();\n    flowParseTypeParameterInstantiation();\n    if (state.error) {\n      state.restoreFromSnapshot(snapshot);\n    }\n  }\n}\n\n// interfaces\nexport function flowTryParseStatement() {\n  if (match(tt.name) && state.contextualKeyword === ContextualKeyword._interface) {\n    const oldIsType = pushTypeContext(0);\n    next();\n    flowParseInterface();\n    popTypeContext(oldIsType);\n    return true;\n  } else {\n    return false;\n  }\n}\n\n// declares, interfaces and type aliases\nexport function flowParseIdentifierStatement(contextualKeyword) {\n  if (contextualKeyword === ContextualKeyword._declare) {\n    if (\n      match(tt._class) ||\n      match(tt.name) ||\n      match(tt._function) ||\n      match(tt._var) ||\n      match(tt._export)\n    ) {\n      const oldIsType = pushTypeContext(1);\n      flowParseDeclare();\n      popTypeContext(oldIsType);\n    }\n  } else if (match(tt.name)) {\n    if (contextualKeyword === ContextualKeyword._interface) {\n      const oldIsType = pushTypeContext(1);\n      flowParseInterface();\n      popTypeContext(oldIsType);\n    } else if (contextualKeyword === ContextualKeyword._type) {\n      const oldIsType = pushTypeContext(1);\n      flowParseTypeAlias();\n      popTypeContext(oldIsType);\n    } else if (contextualKeyword === ContextualKeyword._opaque) {\n      const oldIsType = pushTypeContext(1);\n      flowParseOpaqueType(false);\n      popTypeContext(oldIsType);\n    }\n  }\n  semicolon();\n}\n\n// export type\nexport function flowShouldParseExportDeclaration() {\n  return (\n    isContextual(ContextualKeyword._type) ||\n    isContextual(ContextualKeyword._interface) ||\n    isContextual(ContextualKeyword._opaque)\n  );\n}\n\nexport function flowShouldDisallowExportDefaultSpecifier() {\n  return (\n    match(tt.name) &&\n    (state.contextualKeyword === ContextualKeyword._type ||\n      state.contextualKeyword === ContextualKeyword._interface ||\n      state.contextualKeyword === ContextualKeyword._opaque)\n  );\n}\n\nexport function flowParseExportDeclaration() {\n  if (isContextual(ContextualKeyword._type)) {\n    const oldIsType = pushTypeContext(1);\n    next();\n\n    if (match(tt.braceL)) {\n      // export type { foo, bar };\n      parseExportSpecifiers();\n      parseExportFrom();\n    } else {\n      // export type Foo = Bar;\n      flowParseTypeAlias();\n    }\n    popTypeContext(oldIsType);\n  } else if (isContextual(ContextualKeyword._opaque)) {\n    const oldIsType = pushTypeContext(1);\n    next();\n    // export opaque type Foo = Bar;\n    flowParseOpaqueType(false);\n    popTypeContext(oldIsType);\n  } else if (isContextual(ContextualKeyword._interface)) {\n    const oldIsType = pushTypeContext(1);\n    next();\n    flowParseInterface();\n    popTypeContext(oldIsType);\n  } else {\n    parseStatement(true);\n  }\n}\n\nexport function flowShouldParseExportStar() {\n  return match(tt.star) || (isContextual(ContextualKeyword._type) && lookaheadType() === tt.star);\n}\n\nexport function flowParseExportStar() {\n  if (eatContextual(ContextualKeyword._type)) {\n    const oldIsType = pushTypeContext(2);\n    baseParseExportStar();\n    popTypeContext(oldIsType);\n  } else {\n    baseParseExportStar();\n  }\n}\n\n// parse a the super class type parameters and implements\nexport function flowAfterParseClassSuper(hasSuper) {\n  if (hasSuper && match(tt.lessThan)) {\n    flowParseTypeParameterInstantiation();\n  }\n  if (isContextual(ContextualKeyword._implements)) {\n    const oldIsType = pushTypeContext(0);\n    next();\n    state.tokens[state.tokens.length - 1].type = tt._implements;\n    do {\n      flowParseRestrictedIdentifier();\n      if (match(tt.lessThan)) {\n        flowParseTypeParameterInstantiation();\n      }\n    } while (eat(tt.comma));\n    popTypeContext(oldIsType);\n  }\n}\n\n// parse type parameters for object method shorthand\nexport function flowStartParseObjPropValue() {\n  // method shorthand\n  if (match(tt.lessThan)) {\n    flowParseTypeParameterDeclaration();\n    if (!match(tt.parenL)) unexpected();\n  }\n}\n\nexport function flowParseAssignableListItemTypes() {\n  const oldIsType = pushTypeContext(0);\n  eat(tt.question);\n  if (match(tt.colon)) {\n    flowParseTypeAnnotation();\n  }\n  popTypeContext(oldIsType);\n}\n\n// parse typeof and type imports\nexport function flowStartParseImportSpecifiers() {\n  if (match(tt._typeof) || isContextual(ContextualKeyword._type)) {\n    const lh = lookaheadTypeAndKeyword();\n    if (isMaybeDefaultImport(lh) || lh.type === tt.braceL || lh.type === tt.star) {\n      next();\n    }\n  }\n}\n\n// parse import-type/typeof shorthand\nexport function flowParseImportSpecifier() {\n  const isTypeKeyword =\n    state.contextualKeyword === ContextualKeyword._type || state.type === tt._typeof;\n  if (isTypeKeyword) {\n    next();\n  } else {\n    parseIdentifier();\n  }\n\n  if (isContextual(ContextualKeyword._as) && !isLookaheadContextual(ContextualKeyword._as)) {\n    parseIdentifier();\n    if (isTypeKeyword && !match(tt.name) && !(state.type & TokenType.IS_KEYWORD)) {\n      // `import {type as ,` or `import {type as }`\n    } else {\n      // `import {type as foo`\n      parseIdentifier();\n    }\n  } else if (isTypeKeyword && (match(tt.name) || !!(state.type & TokenType.IS_KEYWORD))) {\n    // `import {type foo`\n    parseIdentifier();\n    if (eatContextual(ContextualKeyword._as)) {\n      parseIdentifier();\n    }\n  }\n}\n\n// parse function type parameters - function foo<T>() {}\nexport function flowStartParseFunctionParams() {\n  // Originally this checked if the method is a getter/setter, but if it was, we'd crash soon\n  // anyway, so don't try to propagate that information.\n  if (match(tt.lessThan)) {\n    const oldIsType = pushTypeContext(0);\n    flowParseTypeParameterDeclaration();\n    popTypeContext(oldIsType);\n  }\n}\n\n// parse flow type annotations on variable declarator heads - let foo: string = bar\nexport function flowAfterParseVarHead() {\n  if (match(tt.colon)) {\n    flowParseTypeAnnotation();\n  }\n}\n\n// parse the return type of an async arrow function - let foo = (async (): number => {});\nexport function flowStartParseAsyncArrowFromCallExpression() {\n  if (match(tt.colon)) {\n    const oldNoAnonFunctionType = state.noAnonFunctionType;\n    state.noAnonFunctionType = true;\n    flowParseTypeAnnotation();\n    state.noAnonFunctionType = oldNoAnonFunctionType;\n  }\n}\n\n// We need to support type parameter declarations for arrow functions. This\n// is tricky. There are three situations we need to handle\n//\n// 1. This is either JSX or an arrow function. We'll try JSX first. If that\n//    fails, we'll try an arrow function. If that fails, we'll throw the JSX\n//    error.\n// 2. This is an arrow function. We'll parse the type parameter declaration,\n//    parse the rest, make sure the rest is an arrow function, and go from\n//    there\n// 3. This is neither. Just call the super method\nexport function flowParseMaybeAssign(noIn, isWithinParens) {\n  if (match(tt.lessThan)) {\n    const snapshot = state.snapshot();\n    let wasArrow = baseParseMaybeAssign(noIn, isWithinParens);\n    if (state.error) {\n      state.restoreFromSnapshot(snapshot);\n      state.type = tt.typeParameterStart;\n    } else {\n      return wasArrow;\n    }\n\n    const oldIsType = pushTypeContext(0);\n    flowParseTypeParameterDeclaration();\n    popTypeContext(oldIsType);\n    wasArrow = baseParseMaybeAssign(noIn, isWithinParens);\n    if (wasArrow) {\n      return true;\n    }\n    unexpected();\n  }\n\n  return baseParseMaybeAssign(noIn, isWithinParens);\n}\n\n// handle return types for arrow functions\nexport function flowParseArrow() {\n  if (match(tt.colon)) {\n    const oldIsType = pushTypeContext(0);\n    const snapshot = state.snapshot();\n\n    const oldNoAnonFunctionType = state.noAnonFunctionType;\n    state.noAnonFunctionType = true;\n    flowParseTypeAndPredicateInitialiser();\n    state.noAnonFunctionType = oldNoAnonFunctionType;\n\n    if (canInsertSemicolon()) unexpected();\n    if (!match(tt.arrow)) unexpected();\n\n    if (state.error) {\n      state.restoreFromSnapshot(snapshot);\n    }\n    popTypeContext(oldIsType);\n  }\n  return eat(tt.arrow);\n}\n\nexport function flowParseSubscripts(startTokenIndex, noCalls = false) {\n  if (\n    state.tokens[state.tokens.length - 1].contextualKeyword === ContextualKeyword._async &&\n    match(tt.lessThan)\n  ) {\n    const snapshot = state.snapshot();\n    const wasArrow = parseAsyncArrowWithTypeParameters();\n    if (wasArrow && !state.error) {\n      return;\n    }\n    state.restoreFromSnapshot(snapshot);\n  }\n\n  baseParseSubscripts(startTokenIndex, noCalls);\n}\n\n// Returns true if there was an arrow function here.\nfunction parseAsyncArrowWithTypeParameters() {\n  state.scopeDepth++;\n  const startTokenIndex = state.tokens.length;\n  parseFunctionParams();\n  if (!parseArrow()) {\n    return false;\n  }\n  parseArrowExpression(startTokenIndex);\n  return true;\n}\n", "/* eslint max-len: 0 */\n\nimport {File} from \"../index\";\nimport {\n  flowAfterParseClassSuper,\n  flowAfterParseVarHead,\n  flowParseExportDeclaration,\n  flowParseExportStar,\n  flowParseIdentifierStatement,\n  flowParseImportSpecifier,\n  flowParseTypeAnnotation,\n  flowParseTypeParameterDeclaration,\n  flowShouldDisallowExportDefaultSpecifier,\n  flowShouldParseExportDeclaration,\n  flowShouldParseExportStar,\n  flowStartParseFunctionParams,\n  flowStartParseImportSpecifiers,\n  flowTryParseStatement,\n} from \"../plugins/flow\";\nimport {\n  tsAfterParseClassSuper,\n  tsAfterParseVarHead,\n  tsIsDeclarationStart,\n  tsParseAccessModifier,\n  tsParseExportDeclaration,\n  tsParseIdentifierStatement,\n  tsParseImportEqualsDeclaration,\n  tsParseMaybeDecoratorArguments,\n  tsStartParseFunctionParams,\n  tsTryParseClassMemberWithIsStatic,\n  tsTryParseExport,\n  tsTryParseExportDefaultExpression,\n  tsTryParseStatementContent,\n  tsTryParseTypeAnnotation,\n  tsTryParseTypeParameters,\n} from \"../plugins/typescript\";\nimport {\n  eat,\n  IdentifierRole,\n  lookaheadType,\n  lookaheadTypeAndKeyword,\n  match,\n  next,\n  popTypeContext,\n  pushTypeContext,\n} from \"../tokenizer\";\nimport {ContextualKeyword} from \"../tokenizer/keywords\";\nimport {Scope} from \"../tokenizer/state\";\nimport { TokenType as tt} from \"../tokenizer/types\";\nimport {getNextContextId, isFlowEnabled, isTypeScriptEnabled, state} from \"./base\";\nimport {\n  parseCallExpressionArguments,\n  parseExprAtom,\n  parseExpression,\n  parseExprSubscripts,\n  parseFunctionBodyAndFinish,\n  parseIdentifier,\n  parseMaybeAssign,\n  parseMethod,\n  parseParenExpression,\n  parsePropertyName,\n} from \"./expression\";\nimport {\n  parseBindingAtom,\n  parseBindingIdentifier,\n  parseBindingList,\n  parseImportedIdentifier,\n} from \"./lval\";\nimport {\n  canInsertSemicolon,\n  eatContextual,\n  expect,\n  expectContextual,\n  isContextual,\n  isLineTerminator,\n  semicolon,\n  unexpected,\n} from \"./util\";\n\nexport function parseTopLevel() {\n  parseBlockBody(tt.eof);\n  state.scopes.push(new Scope(0, state.tokens.length, true));\n  if (state.scopeDepth !== 0) {\n    throw new Error(`Invalid scope depth at end of file: ${state.scopeDepth}`);\n  }\n  return new File(state.tokens, state.scopes);\n}\n\n// Parse a single statement.\n//\n// If expecting a statement and finding a slash operator, parse a\n// regular expression literal. This is to handle cases like\n// `if (foo) /blah/.exec(foo)`, where looking at the previous token\n// does not help.\n\nexport function parseStatement(declaration) {\n  if (isFlowEnabled) {\n    if (flowTryParseStatement()) {\n      return;\n    }\n  }\n  if (match(tt.at)) {\n    parseDecorators();\n  }\n  parseStatementContent(declaration);\n}\n\nfunction parseStatementContent(declaration) {\n  if (isTypeScriptEnabled) {\n    if (tsTryParseStatementContent()) {\n      return;\n    }\n  }\n\n  const starttype = state.type;\n\n  // Most types of statements are recognized by the keyword they\n  // start with. Many are trivial to parse, some require a bit of\n  // complexity.\n\n  switch (starttype) {\n    case tt._break:\n    case tt._continue:\n      parseBreakContinueStatement();\n      return;\n    case tt._debugger:\n      parseDebuggerStatement();\n      return;\n    case tt._do:\n      parseDoStatement();\n      return;\n    case tt._for:\n      parseForStatement();\n      return;\n    case tt._function:\n      if (lookaheadType() === tt.dot) break;\n      if (!declaration) unexpected();\n      parseFunctionStatement();\n      return;\n\n    case tt._class:\n      if (!declaration) unexpected();\n      parseClass(true);\n      return;\n\n    case tt._if:\n      parseIfStatement();\n      return;\n    case tt._return:\n      parseReturnStatement();\n      return;\n    case tt._switch:\n      parseSwitchStatement();\n      return;\n    case tt._throw:\n      parseThrowStatement();\n      return;\n    case tt._try:\n      parseTryStatement();\n      return;\n\n    case tt._let:\n    case tt._const:\n      if (!declaration) unexpected(); // NOTE: falls through to _var\n\n    case tt._var:\n      parseVarStatement(starttype);\n      return;\n\n    case tt._while:\n      parseWhileStatement();\n      return;\n    case tt.braceL:\n      parseBlock();\n      return;\n    case tt.semi:\n      parseEmptyStatement();\n      return;\n    case tt._export:\n    case tt._import: {\n      const nextType = lookaheadType();\n      if (nextType === tt.parenL || nextType === tt.dot) {\n        break;\n      }\n      next();\n      if (starttype === tt._import) {\n        parseImport();\n      } else {\n        parseExport();\n      }\n      return;\n    }\n    case tt.name:\n      if (state.contextualKeyword === ContextualKeyword._async) {\n        const functionStart = state.start;\n        // peek ahead and see if next token is a function\n        const snapshot = state.snapshot();\n        next();\n        if (match(tt._function) && !canInsertSemicolon()) {\n          expect(tt._function);\n          parseFunction(functionStart, true);\n          return;\n        } else {\n          state.restoreFromSnapshot(snapshot);\n        }\n      }\n    default:\n      // Do nothing.\n      break;\n  }\n\n  // If the statement does not start with a statement keyword or a\n  // brace, it's an ExpressionStatement or LabeledStatement. We\n  // simply start parsing an expression, and afterwards, if the\n  // next token is a colon and the expression was a simple\n  // Identifier node, we switch to interpreting it as a label.\n  const initialTokensLength = state.tokens.length;\n  parseExpression();\n  let simpleName = null;\n  if (state.tokens.length === initialTokensLength + 1) {\n    const token = state.tokens[state.tokens.length - 1];\n    if (token.type === tt.name) {\n      simpleName = token.contextualKeyword;\n    }\n  }\n  if (simpleName == null) {\n    semicolon();\n    return;\n  }\n  if (eat(tt.colon)) {\n    parseLabeledStatement();\n  } else {\n    // This was an identifier, so we might want to handle flow/typescript-specific cases.\n    parseIdentifierStatement(simpleName);\n  }\n}\n\nexport function parseDecorators() {\n  while (match(tt.at)) {\n    parseDecorator();\n  }\n}\n\nfunction parseDecorator() {\n  next();\n  if (eat(tt.parenL)) {\n    parseExpression();\n    expect(tt.parenR);\n  } else {\n    parseIdentifier();\n    while (eat(tt.dot)) {\n      parseIdentifier();\n    }\n  }\n  parseMaybeDecoratorArguments();\n}\n\nfunction parseMaybeDecoratorArguments() {\n  if (isTypeScriptEnabled) {\n    tsParseMaybeDecoratorArguments();\n  } else {\n    baseParseMaybeDecoratorArguments();\n  }\n}\n\nexport function baseParseMaybeDecoratorArguments() {\n  if (eat(tt.parenL)) {\n    parseCallExpressionArguments();\n  }\n}\n\nfunction parseBreakContinueStatement() {\n  next();\n  if (!isLineTerminator()) {\n    parseIdentifier();\n    semicolon();\n  }\n}\n\nfunction parseDebuggerStatement() {\n  next();\n  semicolon();\n}\n\nfunction parseDoStatement() {\n  next();\n  parseStatement(false);\n  expect(tt._while);\n  parseParenExpression();\n  eat(tt.semi);\n}\n\nfunction parseForStatement() {\n  state.scopeDepth++;\n  const startTokenIndex = state.tokens.length;\n  parseAmbiguousForStatement();\n  const endTokenIndex = state.tokens.length;\n  state.scopes.push(new Scope(startTokenIndex, endTokenIndex, false));\n  state.scopeDepth--;\n}\n\n// Disambiguating between a `for` and a `for`/`in` or `for`/`of`\n// loop is non-trivial. Basically, we have to parse the init `var`\n// statement or expression, disallowing the `in` operator (see\n// the second parameter to `parseExpression`), and then check\n// whether the next token is `in` or `of`. When there is no init\n// part (semicolon immediately after the opening parenthesis), it\n// is a regular `for` loop.\nfunction parseAmbiguousForStatement() {\n  next();\n\n  let forAwait = false;\n  if (isContextual(ContextualKeyword._await)) {\n    forAwait = true;\n    next();\n  }\n  expect(tt.parenL);\n\n  if (match(tt.semi)) {\n    if (forAwait) {\n      unexpected();\n    }\n    parseFor();\n    return;\n  }\n\n  if (match(tt._var) || match(tt._let) || match(tt._const)) {\n    const varKind = state.type;\n    next();\n    parseVar(true, varKind);\n    if (match(tt._in) || isContextual(ContextualKeyword._of)) {\n      parseForIn(forAwait);\n      return;\n    }\n    parseFor();\n    return;\n  }\n\n  parseExpression(true);\n  if (match(tt._in) || isContextual(ContextualKeyword._of)) {\n    parseForIn(forAwait);\n    return;\n  }\n  if (forAwait) {\n    unexpected();\n  }\n  parseFor();\n}\n\nfunction parseFunctionStatement() {\n  const functionStart = state.start;\n  next();\n  parseFunction(functionStart, true);\n}\n\nfunction parseIfStatement() {\n  next();\n  parseParenExpression();\n  parseStatement(false);\n  if (eat(tt._else)) {\n    parseStatement(false);\n  }\n}\n\nfunction parseReturnStatement() {\n  next();\n\n  // In `return` (and `break`/`continue`), the keywords with\n  // optional arguments, we eagerly look for a semicolon or the\n  // possibility to insert one.\n\n  if (!isLineTerminator()) {\n    parseExpression();\n    semicolon();\n  }\n}\n\nfunction parseSwitchStatement() {\n  next();\n  parseParenExpression();\n  state.scopeDepth++;\n  const startTokenIndex = state.tokens.length;\n  expect(tt.braceL);\n\n  // Don't bother validation; just go through any sequence of cases, defaults, and statements.\n  while (!match(tt.braceR) && !state.error) {\n    if (match(tt._case) || match(tt._default)) {\n      const isCase = match(tt._case);\n      next();\n      if (isCase) {\n        parseExpression();\n      }\n      expect(tt.colon);\n    } else {\n      parseStatement(true);\n    }\n  }\n  next(); // Closing brace\n  const endTokenIndex = state.tokens.length;\n  state.scopes.push(new Scope(startTokenIndex, endTokenIndex, false));\n  state.scopeDepth--;\n}\n\nfunction parseThrowStatement() {\n  next();\n  parseExpression();\n  semicolon();\n}\n\nfunction parseTryStatement() {\n  next();\n\n  parseBlock();\n\n  if (match(tt._catch)) {\n    next();\n    let catchBindingStartTokenIndex = null;\n    if (match(tt.parenL)) {\n      state.scopeDepth++;\n      catchBindingStartTokenIndex = state.tokens.length;\n      expect(tt.parenL);\n      parseBindingAtom(true /* isBlockScope */);\n      expect(tt.parenR);\n    }\n    parseBlock();\n    if (catchBindingStartTokenIndex != null) {\n      // We need a special scope for the catch binding which includes the binding itself and the\n      // catch block.\n      const endTokenIndex = state.tokens.length;\n      state.scopes.push(new Scope(catchBindingStartTokenIndex, endTokenIndex, false));\n      state.scopeDepth--;\n    }\n  }\n  if (eat(tt._finally)) {\n    parseBlock();\n  }\n}\n\nexport function parseVarStatement(kind) {\n  next();\n  parseVar(false, kind);\n  semicolon();\n}\n\nfunction parseWhileStatement() {\n  next();\n  parseParenExpression();\n  parseStatement(false);\n}\n\nfunction parseEmptyStatement() {\n  next();\n}\n\nfunction parseLabeledStatement() {\n  parseStatement(true);\n}\n\n/**\n * Parse a statement starting with an identifier of the given name. Subclasses match on the name\n * to handle statements like \"declare\".\n */\nfunction parseIdentifierStatement(contextualKeyword) {\n  if (isTypeScriptEnabled) {\n    tsParseIdentifierStatement(contextualKeyword);\n  } else if (isFlowEnabled) {\n    flowParseIdentifierStatement(contextualKeyword);\n  } else {\n    semicolon();\n  }\n}\n\n// Parse a semicolon-enclosed block of statements, handling `\"use\n// strict\"` declarations when `allowStrict` is true (used for\n// function bodies).\n\nexport function parseBlock(\n  allowDirectives = false,\n  isFunctionScope = false,\n  contextId = 0,\n) {\n  const startTokenIndex = state.tokens.length;\n  state.scopeDepth++;\n  expect(tt.braceL);\n  if (contextId) {\n    state.tokens[state.tokens.length - 1].contextId = contextId;\n  }\n  parseBlockBody(tt.braceR);\n  if (contextId) {\n    state.tokens[state.tokens.length - 1].contextId = contextId;\n  }\n  const endTokenIndex = state.tokens.length;\n  state.scopes.push(new Scope(startTokenIndex, endTokenIndex, isFunctionScope));\n  state.scopeDepth--;\n}\n\nexport function parseBlockBody(end) {\n  while (!eat(end) && !state.error) {\n    parseStatement(true);\n  }\n}\n\n// Parse a regular `for` loop. The disambiguation code in\n// `parseStatement` will already have parsed the init statement or\n// expression.\n\nfunction parseFor() {\n  expect(tt.semi);\n  if (!match(tt.semi)) {\n    parseExpression();\n  }\n  expect(tt.semi);\n  if (!match(tt.parenR)) {\n    parseExpression();\n  }\n  expect(tt.parenR);\n  parseStatement(false);\n}\n\n// Parse a `for`/`in` and `for`/`of` loop, which are almost\n// same from parser's perspective.\n\nfunction parseForIn(forAwait) {\n  if (forAwait) {\n    eatContextual(ContextualKeyword._of);\n  } else {\n    next();\n  }\n  parseExpression();\n  expect(tt.parenR);\n  parseStatement(false);\n}\n\n// Parse a list of variable declarations.\n\nfunction parseVar(isFor, kind) {\n  while (true) {\n    const isBlockScope = kind === tt._const || kind === tt._let;\n    parseVarHead(isBlockScope);\n    if (eat(tt.eq)) {\n      const eqIndex = state.tokens.length - 1;\n      parseMaybeAssign(isFor);\n      state.tokens[eqIndex].rhsEndIndex = state.tokens.length;\n    }\n    if (!eat(tt.comma)) {\n      break;\n    }\n  }\n}\n\nfunction parseVarHead(isBlockScope) {\n  parseBindingAtom(isBlockScope);\n  if (isTypeScriptEnabled) {\n    tsAfterParseVarHead();\n  } else if (isFlowEnabled) {\n    flowAfterParseVarHead();\n  }\n}\n\n// Parse a function declaration or literal (depending on the\n// `isStatement` parameter).\n\nexport function parseFunction(\n  functionStart,\n  isStatement,\n  optionalId = false,\n) {\n  if (match(tt.star)) {\n    next();\n  }\n\n  if (isStatement && !optionalId && !match(tt.name) && !match(tt._yield)) {\n    unexpected();\n  }\n\n  let nameScopeStartTokenIndex = null;\n\n  if (match(tt.name)) {\n    // Expression-style functions should limit their name's scope to the function body, so we make\n    // a new function scope to enforce that.\n    if (!isStatement) {\n      nameScopeStartTokenIndex = state.tokens.length;\n      state.scopeDepth++;\n    }\n    parseBindingIdentifier(false);\n  }\n\n  const startTokenIndex = state.tokens.length;\n  state.scopeDepth++;\n  parseFunctionParams();\n  parseFunctionBodyAndFinish(functionStart);\n  const endTokenIndex = state.tokens.length;\n  // In addition to the block scope of the function body, we need a separate function-style scope\n  // that includes the params.\n  state.scopes.push(new Scope(startTokenIndex, endTokenIndex, true));\n  state.scopeDepth--;\n  if (nameScopeStartTokenIndex !== null) {\n    state.scopes.push(new Scope(nameScopeStartTokenIndex, endTokenIndex, true));\n    state.scopeDepth--;\n  }\n}\n\nexport function parseFunctionParams(\n  allowModifiers = false,\n  funcContextId = 0,\n) {\n  if (isTypeScriptEnabled) {\n    tsStartParseFunctionParams();\n  } else if (isFlowEnabled) {\n    flowStartParseFunctionParams();\n  }\n\n  expect(tt.parenL);\n  if (funcContextId) {\n    state.tokens[state.tokens.length - 1].contextId = funcContextId;\n  }\n  parseBindingList(\n    tt.parenR,\n    false /* isBlockScope */,\n    false /* allowEmpty */,\n    allowModifiers,\n    funcContextId,\n  );\n  if (funcContextId) {\n    state.tokens[state.tokens.length - 1].contextId = funcContextId;\n  }\n}\n\n// Parse a class declaration or literal (depending on the\n// `isStatement` parameter).\n\nexport function parseClass(isStatement, optionalId = false) {\n  // Put a context ID on the class keyword, the open-brace, and the close-brace, so that later\n  // code can easily navigate to meaningful points on the class.\n  const contextId = getNextContextId();\n\n  next();\n  state.tokens[state.tokens.length - 1].contextId = contextId;\n  state.tokens[state.tokens.length - 1].isExpression = !isStatement;\n  // Like with functions, we declare a special \"name scope\" from the start of the name to the end\n  // of the class, but only with expression-style classes, to represent the fact that the name is\n  // available to the body of the class but not an outer declaration.\n  let nameScopeStartTokenIndex = null;\n  if (!isStatement) {\n    nameScopeStartTokenIndex = state.tokens.length;\n    state.scopeDepth++;\n  }\n  parseClassId(isStatement, optionalId);\n  parseClassSuper();\n  const openBraceIndex = state.tokens.length;\n  parseClassBody(contextId);\n  if (state.error) {\n    return;\n  }\n  state.tokens[openBraceIndex].contextId = contextId;\n  state.tokens[state.tokens.length - 1].contextId = contextId;\n  if (nameScopeStartTokenIndex !== null) {\n    const endTokenIndex = state.tokens.length;\n    state.scopes.push(new Scope(nameScopeStartTokenIndex, endTokenIndex, false));\n    state.scopeDepth--;\n  }\n}\n\nfunction isClassProperty() {\n  return match(tt.eq) || match(tt.semi) || match(tt.braceR) || match(tt.bang) || match(tt.colon);\n}\n\nfunction isClassMethod() {\n  return match(tt.parenL) || match(tt.lessThan);\n}\n\nfunction parseClassBody(classContextId) {\n  expect(tt.braceL);\n\n  while (!eat(tt.braceR) && !state.error) {\n    if (eat(tt.semi)) {\n      continue;\n    }\n\n    if (match(tt.at)) {\n      parseDecorator();\n      continue;\n    }\n    const memberStart = state.start;\n    parseClassMember(memberStart, classContextId);\n  }\n}\n\nfunction parseClassMember(memberStart, classContextId) {\n  if (isTypeScriptEnabled) {\n    eatContextual(ContextualKeyword._declare);\n    tsParseAccessModifier();\n    eatContextual(ContextualKeyword._declare);\n  }\n  let isStatic = false;\n  if (match(tt.name) && state.contextualKeyword === ContextualKeyword._static) {\n    parseIdentifier(); // eats 'static'\n    if (isClassMethod()) {\n      parseClassMethod(memberStart, /* isConstructor */ false);\n      return;\n    } else if (isClassProperty()) {\n      parseClassProperty();\n      return;\n    }\n    // otherwise something static\n    state.tokens[state.tokens.length - 1].type = tt._static;\n    isStatic = true;\n  }\n\n  parseClassMemberWithIsStatic(memberStart, isStatic, classContextId);\n}\n\nfunction parseClassMemberWithIsStatic(\n  memberStart,\n  isStatic,\n  classContextId,\n) {\n  if (isTypeScriptEnabled) {\n    if (tsTryParseClassMemberWithIsStatic(isStatic, classContextId)) {\n      return;\n    }\n  }\n  if (eat(tt.star)) {\n    // a generator\n    parseClassPropertyName(classContextId);\n    parseClassMethod(memberStart, /* isConstructor */ false);\n    return;\n  }\n\n  // Get the identifier name so we can tell if it's actually a keyword like \"async\", \"get\", or\n  // \"set\".\n  parseClassPropertyName(classContextId);\n  let isConstructor = false;\n  const token = state.tokens[state.tokens.length - 1];\n  // We allow \"constructor\" as either an identifier or a string.\n  if (token.contextualKeyword === ContextualKeyword._constructor) {\n    isConstructor = true;\n  }\n  parsePostMemberNameModifiers();\n\n  if (isClassMethod()) {\n    parseClassMethod(memberStart, isConstructor);\n  } else if (isClassProperty()) {\n    parseClassProperty();\n  } else if (token.contextualKeyword === ContextualKeyword._async && !isLineTerminator()) {\n    state.tokens[state.tokens.length - 1].type = tt._async;\n    // an async method\n    const isGenerator = match(tt.star);\n    if (isGenerator) {\n      next();\n    }\n\n    // The so-called parsed name would have been \"async\": get the real name.\n    parseClassPropertyName(classContextId);\n    parsePostMemberNameModifiers();\n    parseClassMethod(memberStart, false /* isConstructor */);\n  } else if (\n    (token.contextualKeyword === ContextualKeyword._get ||\n      token.contextualKeyword === ContextualKeyword._set) &&\n    !(isLineTerminator() && match(tt.star))\n  ) {\n    if (token.contextualKeyword === ContextualKeyword._get) {\n      state.tokens[state.tokens.length - 1].type = tt._get;\n    } else {\n      state.tokens[state.tokens.length - 1].type = tt._set;\n    }\n    // `get\\n*` is an uninitialized property named 'get' followed by a generator.\n    // a getter or setter\n    // The so-called parsed name would have been \"get/set\": get the real name.\n    parseClassPropertyName(classContextId);\n    parseClassMethod(memberStart, /* isConstructor */ false);\n  } else if (isLineTerminator()) {\n    // an uninitialized class property (due to ASI, since we don't otherwise recognize the next token)\n    parseClassProperty();\n  } else {\n    unexpected();\n  }\n}\n\nfunction parseClassMethod(functionStart, isConstructor) {\n  if (isTypeScriptEnabled) {\n    tsTryParseTypeParameters();\n  } else if (isFlowEnabled) {\n    if (match(tt.lessThan)) {\n      flowParseTypeParameterDeclaration();\n    }\n  }\n  parseMethod(functionStart, isConstructor);\n}\n\n// Return the name of the class property, if it is a simple identifier.\nexport function parseClassPropertyName(classContextId) {\n  parsePropertyName(classContextId);\n}\n\nexport function parsePostMemberNameModifiers() {\n  if (isTypeScriptEnabled) {\n    const oldIsType = pushTypeContext(0);\n    eat(tt.question);\n    popTypeContext(oldIsType);\n  }\n}\n\nexport function parseClassProperty() {\n  if (isTypeScriptEnabled) {\n    eat(tt.bang);\n    tsTryParseTypeAnnotation();\n  } else if (isFlowEnabled) {\n    if (match(tt.colon)) {\n      flowParseTypeAnnotation();\n    }\n  }\n\n  if (match(tt.eq)) {\n    const equalsTokenIndex = state.tokens.length;\n    next();\n    parseMaybeAssign();\n    state.tokens[equalsTokenIndex].rhsEndIndex = state.tokens.length;\n  }\n  semicolon();\n}\n\nfunction parseClassId(isStatement, optionalId = false) {\n  if (\n    isTypeScriptEnabled &&\n    (!isStatement || optionalId) &&\n    isContextual(ContextualKeyword._implements)\n  ) {\n    return;\n  }\n\n  if (match(tt.name)) {\n    parseBindingIdentifier(true);\n  }\n\n  if (isTypeScriptEnabled) {\n    tsTryParseTypeParameters();\n  } else if (isFlowEnabled) {\n    if (match(tt.lessThan)) {\n      flowParseTypeParameterDeclaration();\n    }\n  }\n}\n\n// Returns true if there was a superclass.\nfunction parseClassSuper() {\n  let hasSuper = false;\n  if (eat(tt._extends)) {\n    parseExprSubscripts();\n    hasSuper = true;\n  } else {\n    hasSuper = false;\n  }\n  if (isTypeScriptEnabled) {\n    tsAfterParseClassSuper(hasSuper);\n  } else if (isFlowEnabled) {\n    flowAfterParseClassSuper(hasSuper);\n  }\n}\n\n// Parses module export declaration.\n\nexport function parseExport() {\n  const exportIndex = state.tokens.length - 1;\n  if (isTypeScriptEnabled) {\n    if (tsTryParseExport()) {\n      return;\n    }\n  }\n  // export * from '...'\n  if (shouldParseExportStar()) {\n    parseExportStar();\n  } else if (isExportDefaultSpecifier()) {\n    // export default from\n    parseIdentifier();\n    if (match(tt.comma) && lookaheadType() === tt.star) {\n      expect(tt.comma);\n      expect(tt.star);\n      expectContextual(ContextualKeyword._as);\n      parseIdentifier();\n    } else {\n      parseExportSpecifiersMaybe();\n    }\n    parseExportFrom();\n  } else if (eat(tt._default)) {\n    // export default ...\n    parseExportDefaultExpression();\n  } else if (shouldParseExportDeclaration()) {\n    parseExportDeclaration();\n  } else {\n    // export { x, y as z } [from '...']\n    parseExportSpecifiers();\n    parseExportFrom();\n  }\n  state.tokens[exportIndex].rhsEndIndex = state.tokens.length;\n}\n\nfunction parseExportDefaultExpression() {\n  if (isTypeScriptEnabled) {\n    if (tsTryParseExportDefaultExpression()) {\n      return;\n    }\n  }\n  const functionStart = state.start;\n  if (eat(tt._function)) {\n    parseFunction(functionStart, true, true);\n  } else if (isContextual(ContextualKeyword._async) && lookaheadType() === tt._function) {\n    // async function declaration\n    eatContextual(ContextualKeyword._async);\n    eat(tt._function);\n    parseFunction(functionStart, true, true);\n  } else if (match(tt._class)) {\n    parseClass(true, true);\n  } else if (match(tt.at)) {\n    parseDecorators();\n    parseClass(true, true);\n  } else {\n    parseMaybeAssign();\n    semicolon();\n  }\n}\n\nfunction parseExportDeclaration() {\n  if (isTypeScriptEnabled) {\n    tsParseExportDeclaration();\n  } else if (isFlowEnabled) {\n    flowParseExportDeclaration();\n  } else {\n    parseStatement(true);\n  }\n}\n\nfunction isExportDefaultSpecifier() {\n  if (isTypeScriptEnabled && tsIsDeclarationStart()) {\n    return false;\n  } else if (isFlowEnabled && flowShouldDisallowExportDefaultSpecifier()) {\n    return false;\n  }\n  if (match(tt.name)) {\n    return state.contextualKeyword !== ContextualKeyword._async;\n  }\n\n  if (!match(tt._default)) {\n    return false;\n  }\n\n  const lookahead = lookaheadTypeAndKeyword();\n  return (\n    lookahead.type === tt.comma ||\n    (lookahead.type === tt.name && lookahead.contextualKeyword === ContextualKeyword._from)\n  );\n}\n\nfunction parseExportSpecifiersMaybe() {\n  if (eat(tt.comma)) {\n    parseExportSpecifiers();\n  }\n}\n\nexport function parseExportFrom() {\n  if (eatContextual(ContextualKeyword._from)) {\n    parseExprAtom();\n  }\n  semicolon();\n}\n\nfunction shouldParseExportStar() {\n  if (isFlowEnabled) {\n    return flowShouldParseExportStar();\n  } else {\n    return match(tt.star);\n  }\n}\n\nfunction parseExportStar() {\n  if (isFlowEnabled) {\n    flowParseExportStar();\n  } else {\n    baseParseExportStar();\n  }\n}\n\nexport function baseParseExportStar() {\n  expect(tt.star);\n\n  if (isContextual(ContextualKeyword._as)) {\n    parseExportNamespace();\n  } else {\n    parseExportFrom();\n  }\n}\n\nfunction parseExportNamespace() {\n  next();\n  state.tokens[state.tokens.length - 1].type = tt._as;\n  parseIdentifier();\n  parseExportSpecifiersMaybe();\n  parseExportFrom();\n}\n\nfunction shouldParseExportDeclaration() {\n  return (\n    (isTypeScriptEnabled && tsIsDeclarationStart()) ||\n    (isFlowEnabled && flowShouldParseExportDeclaration()) ||\n    state.type === tt._var ||\n    state.type === tt._const ||\n    state.type === tt._let ||\n    state.type === tt._function ||\n    state.type === tt._class ||\n    isContextual(ContextualKeyword._async) ||\n    match(tt.at)\n  );\n}\n\n// Parses a comma-separated list of module exports.\nexport function parseExportSpecifiers() {\n  let first = true;\n\n  // export { x, y as z } [from '...']\n  expect(tt.braceL);\n\n  while (!eat(tt.braceR) && !state.error) {\n    if (first) {\n      first = false;\n    } else {\n      expect(tt.comma);\n      if (eat(tt.braceR)) {\n        break;\n      }\n    }\n\n    parseIdentifier();\n    state.tokens[state.tokens.length - 1].identifierRole = IdentifierRole.ExportAccess;\n    if (eatContextual(ContextualKeyword._as)) {\n      parseIdentifier();\n    }\n  }\n}\n\n// Parses import declaration.\n\nexport function parseImport() {\n  if (isTypeScriptEnabled && match(tt.name) && lookaheadType() === tt.eq) {\n    tsParseImportEqualsDeclaration();\n    return;\n  }\n  if (isTypeScriptEnabled) {\n    eatContextual(ContextualKeyword._type);\n  }\n\n  // import '...'\n  if (match(tt.string)) {\n    parseExprAtom();\n  } else {\n    parseImportSpecifiers();\n    expectContextual(ContextualKeyword._from);\n    parseExprAtom();\n  }\n  semicolon();\n}\n\n// eslint-disable-next-line no-unused-vars\nfunction shouldParseDefaultImport() {\n  return match(tt.name);\n}\n\nfunction parseImportSpecifierLocal() {\n  parseImportedIdentifier();\n}\n\n// Parses a comma-separated list of module imports.\nfunction parseImportSpecifiers() {\n  if (isFlowEnabled) {\n    flowStartParseImportSpecifiers();\n  }\n\n  let first = true;\n  if (shouldParseDefaultImport()) {\n    // import defaultObj, { x, y as z } from '...'\n    parseImportSpecifierLocal();\n\n    if (!eat(tt.comma)) return;\n  }\n\n  if (match(tt.star)) {\n    next();\n    expectContextual(ContextualKeyword._as);\n\n    parseImportSpecifierLocal();\n\n    return;\n  }\n\n  expect(tt.braceL);\n  while (!eat(tt.braceR) && !state.error) {\n    if (first) {\n      first = false;\n    } else {\n      // Detect an attempt to deep destructure\n      if (eat(tt.colon)) {\n        unexpected(\n          \"ES2015 named imports do not destructure. Use another statement for destructuring after the import.\",\n        );\n      }\n\n      expect(tt.comma);\n      if (eat(tt.braceR)) {\n        break;\n      }\n    }\n\n    parseImportSpecifier();\n  }\n}\n\nfunction parseImportSpecifier() {\n  if (isFlowEnabled) {\n    flowParseImportSpecifier();\n    return;\n  }\n  parseImportedIdentifier();\n  if (isContextual(ContextualKeyword._as)) {\n    state.tokens[state.tokens.length - 1].identifierRole = IdentifierRole.ImportAccess;\n    next();\n    parseImportedIdentifier();\n  }\n}\n", "\nimport {nextToken, skipLineComment} from \"../tokenizer/index\";\nimport {charCodes} from \"../util/charcodes\";\nimport {input, state} from \"./base\";\nimport {parseTopLevel} from \"./statement\";\n\nexport function parseFile() {\n  // If enabled, skip leading hashbang line.\n  if (\n    state.pos === 0 &&\n    input.charCodeAt(0) === charCodes.numberSign &&\n    input.charCodeAt(1) === charCodes.exclamationMark\n  ) {\n    skipLineComment(2);\n  }\n  nextToken();\n  return parseTopLevel();\n}\n", "\n\nimport {augmentError, initParser, state} from \"./traverser/base\";\nimport {parseFile} from \"./traverser/index\";\n\nexport class File {\n  \n  \n\n  constructor(tokens, scopes) {\n    this.tokens = tokens;\n    this.scopes = scopes;\n  }\n}\n\nexport function parse(\n  input,\n  isJSXEnabled,\n  isTypeScriptEnabled,\n  isFlowEnabled,\n) {\n  if (isFlowEnabled && isTypeScriptEnabled) {\n    throw new Error(\"Cannot combine flow and typescript plugins.\");\n  }\n  initParser(input, isJSXEnabled, isTypeScriptEnabled, isFlowEnabled);\n  const result = parseFile();\n  if (state.error) {\n    throw augmentError(state.error);\n  }\n  return result;\n}\n", "import {ContextualKeyword} from \"../parser/tokenizer/keywords\";\n\n\n/**\n * Determine whether this optional chain or nullish coalescing operation has any await statements in\n * it. If so, we'll need to transpile to an async operation.\n *\n * We compute this by walking the length of the operation and returning true if we see an await\n * keyword used as a real await (rather than an object key or property access). Nested optional\n * chain/nullish operations need to be tracked but don't silence await, but a nested async function\n * (or any other nested scope) will make the await not count.\n */\nexport default function isAsyncOperation(tokens) {\n  let index = tokens.currentIndex();\n  let depth = 0;\n  const startToken = tokens.currentToken();\n  do {\n    const token = tokens.tokens[index];\n    if (token.isOptionalChainStart) {\n      depth++;\n    }\n    if (token.isOptionalChainEnd) {\n      depth--;\n    }\n    depth += token.numNullishCoalesceStarts;\n    depth -= token.numNullishCoalesceEnds;\n\n    if (\n      token.contextualKeyword === ContextualKeyword._await &&\n      token.identifierRole == null &&\n      token.scopeDepth === startToken.scopeDepth\n    ) {\n      return true;\n    }\n    index += 1;\n  } while (depth > 0 && index < tokens.tokens.length);\n  return false;\n}\n", "\n\n\nimport { TokenType as tt} from \"./parser/tokenizer/types\";\nimport isAsyncOperation from \"./util/isAsyncOperation\";\n\n\n\n\n\n\nexport default class TokenProcessor {\n   __init() {this.resultCode = \"\"}\n   __init2() {this.tokenIndex = 0}\n\n  constructor(\n     code,\n     tokens,\n     isFlowEnabled,\n     helperManager,\n  ) {;this.code = code;this.tokens = tokens;this.isFlowEnabled = isFlowEnabled;this.helperManager = helperManager;TokenProcessor.prototype.__init.call(this);TokenProcessor.prototype.__init2.call(this);}\n\n  /**\n   * Make a new TokenProcessor for things like lookahead.\n   */\n  snapshot() {\n    return {resultCode: this.resultCode, tokenIndex: this.tokenIndex};\n  }\n\n  restoreToSnapshot(snapshot) {\n    this.resultCode = snapshot.resultCode;\n    this.tokenIndex = snapshot.tokenIndex;\n  }\n\n  getResultCodeIndex() {\n    return this.resultCode.length;\n  }\n\n  reset() {\n    this.resultCode = \"\";\n    this.tokenIndex = 0;\n  }\n\n  matchesContextualAtIndex(index, contextualKeyword) {\n    return (\n      this.matches1AtIndex(index, tt.name) &&\n      this.tokens[index].contextualKeyword === contextualKeyword\n    );\n  }\n\n  identifierNameAtIndex(index) {\n    // TODO: We need to process escapes since technically you can have unicode escapes in variable\n    // names.\n    return this.identifierNameForToken(this.tokens[index]);\n  }\n\n  identifierName() {\n    return this.identifierNameForToken(this.currentToken());\n  }\n\n  identifierNameForToken(token) {\n    return this.code.slice(token.start, token.end);\n  }\n\n  rawCodeForToken(token) {\n    return this.code.slice(token.start, token.end);\n  }\n\n  stringValueAtIndex(index) {\n    return this.stringValueForToken(this.tokens[index]);\n  }\n\n  stringValue() {\n    return this.stringValueForToken(this.currentToken());\n  }\n\n  stringValueForToken(token) {\n    // This is used to identify when two imports are the same and to resolve TypeScript enum keys.\n    // Ideally we'd process escapes within the strings, but for now we pretty much take the raw\n    // code.\n    return this.code.slice(token.start + 1, token.end - 1);\n  }\n\n  matches1AtIndex(index, t1) {\n    return this.tokens[index].type === t1;\n  }\n\n  matches2AtIndex(index, t1, t2) {\n    return this.tokens[index].type === t1 && this.tokens[index + 1].type === t2;\n  }\n\n  matches3AtIndex(index, t1, t2, t3) {\n    return (\n      this.tokens[index].type === t1 &&\n      this.tokens[index + 1].type === t2 &&\n      this.tokens[index + 2].type === t3\n    );\n  }\n\n  matches1(t1) {\n    return this.tokens[this.tokenIndex].type === t1;\n  }\n\n  matches2(t1, t2) {\n    return this.tokens[this.tokenIndex].type === t1 && this.tokens[this.tokenIndex + 1].type === t2;\n  }\n\n  matches3(t1, t2, t3) {\n    return (\n      this.tokens[this.tokenIndex].type === t1 &&\n      this.tokens[this.tokenIndex + 1].type === t2 &&\n      this.tokens[this.tokenIndex + 2].type === t3\n    );\n  }\n\n  matches4(t1, t2, t3, t4) {\n    return (\n      this.tokens[this.tokenIndex].type === t1 &&\n      this.tokens[this.tokenIndex + 1].type === t2 &&\n      this.tokens[this.tokenIndex + 2].type === t3 &&\n      this.tokens[this.tokenIndex + 3].type === t4\n    );\n  }\n\n  matches5(t1, t2, t3, t4, t5) {\n    return (\n      this.tokens[this.tokenIndex].type === t1 &&\n      this.tokens[this.tokenIndex + 1].type === t2 &&\n      this.tokens[this.tokenIndex + 2].type === t3 &&\n      this.tokens[this.tokenIndex + 3].type === t4 &&\n      this.tokens[this.tokenIndex + 4].type === t5\n    );\n  }\n\n  matchesContextual(contextualKeyword) {\n    return this.matchesContextualAtIndex(this.tokenIndex, contextualKeyword);\n  }\n\n  matchesContextIdAndLabel(type, contextId) {\n    return this.matches1(type) && this.currentToken().contextId === contextId;\n  }\n\n  previousWhitespaceAndComments() {\n    let whitespaceAndComments = this.code.slice(\n      this.tokenIndex > 0 ? this.tokens[this.tokenIndex - 1].end : 0,\n      this.tokenIndex < this.tokens.length ? this.tokens[this.tokenIndex].start : this.code.length,\n    );\n    if (this.isFlowEnabled) {\n      whitespaceAndComments = whitespaceAndComments.replace(/@flow/g, \"\");\n    }\n    return whitespaceAndComments;\n  }\n\n  replaceToken(newCode) {\n    this.resultCode += this.previousWhitespaceAndComments();\n    this.appendTokenPrefix();\n    this.resultCode += newCode;\n    this.appendTokenSuffix();\n    this.tokenIndex++;\n  }\n\n  replaceTokenTrimmingLeftWhitespace(newCode) {\n    this.resultCode += this.previousWhitespaceAndComments().replace(/[^\\r\\n]/g, \"\");\n    this.appendTokenPrefix();\n    this.resultCode += newCode;\n    this.appendTokenSuffix();\n    this.tokenIndex++;\n  }\n\n  removeInitialToken() {\n    this.replaceToken(\"\");\n  }\n\n  removeToken() {\n    this.replaceTokenTrimmingLeftWhitespace(\"\");\n  }\n\n  copyExpectedToken(tokenType) {\n    if (this.tokens[this.tokenIndex].type !== tokenType) {\n      throw new Error(`Expected token ${tokenType}`);\n    }\n    this.copyToken();\n  }\n\n  copyToken() {\n    this.resultCode += this.previousWhitespaceAndComments();\n    this.appendTokenPrefix();\n    this.resultCode += this.code.slice(\n      this.tokens[this.tokenIndex].start,\n      this.tokens[this.tokenIndex].end,\n    );\n    this.appendTokenSuffix();\n    this.tokenIndex++;\n  }\n\n  copyTokenWithPrefix(prefix) {\n    this.resultCode += this.previousWhitespaceAndComments();\n    this.appendTokenPrefix();\n    this.resultCode += prefix;\n    this.resultCode += this.code.slice(\n      this.tokens[this.tokenIndex].start,\n      this.tokens[this.tokenIndex].end,\n    );\n    this.appendTokenSuffix();\n    this.tokenIndex++;\n  }\n\n   appendTokenPrefix() {\n    const token = this.currentToken();\n    if (token.numNullishCoalesceStarts || token.isOptionalChainStart) {\n      token.isAsyncOperation = isAsyncOperation(this);\n    }\n    if (token.numNullishCoalesceStarts) {\n      for (let i = 0; i < token.numNullishCoalesceStarts; i++) {\n        if (token.isAsyncOperation) {\n          this.resultCode += \"await \";\n          this.resultCode += this.helperManager.getHelperName(\"asyncNullishCoalesce\");\n        } else {\n          this.resultCode += this.helperManager.getHelperName(\"nullishCoalesce\");\n        }\n        this.resultCode += \"(\";\n      }\n    }\n    if (token.isOptionalChainStart) {\n      if (token.isAsyncOperation) {\n        this.resultCode += \"await \";\n      }\n      if (this.tokenIndex > 0 && this.tokenAtRelativeIndex(-1).type === tt._delete) {\n        if (token.isAsyncOperation) {\n          this.resultCode += this.helperManager.getHelperName(\"asyncOptionalChainDelete\");\n        } else {\n          this.resultCode += this.helperManager.getHelperName(\"optionalChainDelete\");\n        }\n      } else if (token.isAsyncOperation) {\n        this.resultCode += this.helperManager.getHelperName(\"asyncOptionalChain\");\n      } else {\n        this.resultCode += this.helperManager.getHelperName(\"optionalChain\");\n      }\n      this.resultCode += \"([\";\n    }\n  }\n\n   appendTokenSuffix() {\n    const token = this.currentToken();\n    if (token.isOptionalChainEnd) {\n      this.resultCode += \"])\";\n    }\n    if (token.numNullishCoalesceEnds) {\n      for (let i = 0; i < token.numNullishCoalesceEnds; i++) {\n        this.resultCode += \"))\";\n      }\n    }\n  }\n\n  appendCode(code) {\n    this.resultCode += code;\n  }\n\n  currentToken() {\n    return this.tokens[this.tokenIndex];\n  }\n\n  currentTokenCode() {\n    const token = this.currentToken();\n    return this.code.slice(token.start, token.end);\n  }\n\n  tokenAtRelativeIndex(relativeIndex) {\n    return this.tokens[this.tokenIndex + relativeIndex];\n  }\n\n  currentIndex() {\n    return this.tokenIndex;\n  }\n\n  /**\n   * Move to the next token. Only suitable in preprocessing steps. When\n   * generating new code, you should use copyToken or removeToken.\n   */\n  nextToken() {\n    if (this.tokenIndex === this.tokens.length) {\n      throw new Error(\"Unexpectedly reached end of input.\");\n    }\n    this.tokenIndex++;\n  }\n\n  previousToken() {\n    this.tokenIndex--;\n  }\n\n  finish() {\n    if (this.tokenIndex !== this.tokens.length) {\n      throw new Error(\"Tried to finish processing tokens before reaching the end.\");\n    }\n    this.resultCode += this.previousWhitespaceAndComments();\n    return this.resultCode;\n  }\n\n  isAtEnd() {\n    return this.tokenIndex === this.tokens.length;\n  }\n}\n", "\n\nimport {ContextualKeyword} from \"../parser/tokenizer/keywords\";\nimport {TokenType as tt} from \"../parser/tokenizer/types\";\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Get information about the class fields for this class, given a token processor pointing to the\n * open-brace at the start of the class.\n */\nexport default function getClassInfo(\n  rootTransformer,\n  tokens,\n  nameManager,\n) {\n  const snapshot = tokens.snapshot();\n\n  const headerInfo = processClassHeader(tokens);\n\n  let constructorInitializerStatements = [];\n  const instanceInitializerNames = [];\n  const staticInitializerNames = [];\n  let constructorInsertPos = null;\n  const fields = [];\n  const rangesToRemove = [];\n\n  const classContextId = tokens.currentToken().contextId;\n  if (classContextId == null) {\n    throw new Error(\"Expected non-null class context ID on class open-brace.\");\n  }\n\n  tokens.nextToken();\n  while (!tokens.matchesContextIdAndLabel(tt.braceR, classContextId)) {\n    if (tokens.matchesContextual(ContextualKeyword._constructor) && !tokens.currentToken().isType) {\n      ({constructorInitializerStatements, constructorInsertPos} = processConstructor(tokens));\n    } else if (tokens.matches1(tt.semi)) {\n      rangesToRemove.push({start: tokens.currentIndex(), end: tokens.currentIndex() + 1});\n      tokens.nextToken();\n    } else if (tokens.currentToken().isType) {\n      tokens.nextToken();\n    } else {\n      // Either a method or a field. Skip to the identifier part.\n      const statementStartIndex = tokens.currentIndex();\n      let isStatic = false;\n      while (isAccessModifier(tokens.currentToken())) {\n        if (tokens.matches1(tt._static)) {\n          isStatic = true;\n        }\n        tokens.nextToken();\n      }\n      if (\n        tokens.matchesContextual(ContextualKeyword._constructor) &&\n        !tokens.currentToken().isType\n      ) {\n        ({constructorInitializerStatements, constructorInsertPos} = processConstructor(tokens));\n        continue;\n      }\n      const nameStartIndex = tokens.currentIndex();\n      skipFieldName(tokens);\n      if (tokens.matches1(tt.lessThan) || tokens.matches1(tt.parenL)) {\n        // This is a method, so just skip to the next method/field. To do that, we seek forward to\n        // the next start of a class name (either an open bracket or an identifier, or the closing\n        // curly brace), then seek backward to include any access modifiers.\n        while (tokens.currentToken().contextId !== classContextId) {\n          tokens.nextToken();\n        }\n        while (isAccessModifier(tokens.tokenAtRelativeIndex(-1))) {\n          tokens.previousToken();\n        }\n        continue;\n      }\n      // There might be a type annotation that we need to skip.\n      while (tokens.currentToken().isType) {\n        tokens.nextToken();\n      }\n      if (tokens.matches1(tt.eq)) {\n        const equalsIndex = tokens.currentIndex();\n        // This is an initializer, so we need to wrap in an initializer method.\n        const valueEnd = tokens.currentToken().rhsEndIndex;\n        if (valueEnd == null) {\n          throw new Error(\"Expected rhsEndIndex on class field assignment.\");\n        }\n        tokens.nextToken();\n        while (tokens.currentIndex() < valueEnd) {\n          rootTransformer.processToken();\n        }\n        let initializerName;\n        if (isStatic) {\n          initializerName = nameManager.claimFreeName(\"__initStatic\");\n          staticInitializerNames.push(initializerName);\n        } else {\n          initializerName = nameManager.claimFreeName(\"__init\");\n          instanceInitializerNames.push(initializerName);\n        }\n        // Fields start at the name, so `static x = 1;` has a field range of `x = 1;`.\n        fields.push({\n          initializerName,\n          equalsIndex,\n          start: nameStartIndex,\n          end: tokens.currentIndex(),\n        });\n      } else {\n        // This is just a declaration, so doesn't need to produce any code in the output.\n        rangesToRemove.push({start: statementStartIndex, end: tokens.currentIndex()});\n      }\n    }\n  }\n\n  tokens.restoreToSnapshot(snapshot);\n  return {\n    headerInfo,\n    constructorInitializerStatements,\n    instanceInitializerNames,\n    staticInitializerNames,\n    constructorInsertPos,\n    fields,\n    rangesToRemove,\n  };\n}\n\nfunction processClassHeader(tokens) {\n  const classToken = tokens.currentToken();\n  const contextId = classToken.contextId;\n  if (contextId == null) {\n    throw new Error(\"Expected context ID on class token.\");\n  }\n  const isExpression = classToken.isExpression;\n  if (isExpression == null) {\n    throw new Error(\"Expected isExpression on class token.\");\n  }\n  let className = null;\n  let hasSuperclass = false;\n  tokens.nextToken();\n  if (tokens.matches1(tt.name)) {\n    className = tokens.identifierName();\n  }\n  while (!tokens.matchesContextIdAndLabel(tt.braceL, contextId)) {\n    // If this has a superclass, there will always be an `extends` token. If it doesn't have a\n    // superclass, only type parameters and `implements` clauses can show up here, all of which\n    // consist only of type tokens. A declaration like `class A<B extends C> {` should *not* count\n    // as having a superclass.\n    if (tokens.matches1(tt._extends) && !tokens.currentToken().isType) {\n      hasSuperclass = true;\n    }\n    tokens.nextToken();\n  }\n  return {isExpression, className, hasSuperclass};\n}\n\n/**\n * Extract useful information out of a constructor, starting at the \"constructor\" name.\n */\nfunction processConstructor(\n  tokens,\n) {\n  const constructorInitializerStatements = [];\n\n  tokens.nextToken();\n  const constructorContextId = tokens.currentToken().contextId;\n  if (constructorContextId == null) {\n    throw new Error(\"Expected context ID on open-paren starting constructor params.\");\n  }\n  // Advance through parameters looking for access modifiers.\n  while (!tokens.matchesContextIdAndLabel(tt.parenR, constructorContextId)) {\n    if (tokens.currentToken().contextId === constructorContextId) {\n      // Current token is an open paren or comma just before a param, so check\n      // that param for access modifiers.\n      tokens.nextToken();\n      if (isAccessModifier(tokens.currentToken())) {\n        tokens.nextToken();\n        while (isAccessModifier(tokens.currentToken())) {\n          tokens.nextToken();\n        }\n        const token = tokens.currentToken();\n        if (token.type !== tt.name) {\n          throw new Error(\"Expected identifier after access modifiers in constructor arg.\");\n        }\n        const name = tokens.identifierNameForToken(token);\n        constructorInitializerStatements.push(`this.${name} = ${name}`);\n      }\n    } else {\n      tokens.nextToken();\n    }\n  }\n  // )\n  tokens.nextToken();\n  let constructorInsertPos = tokens.currentIndex();\n\n  // Advance through body looking for a super call.\n  let foundSuperCall = false;\n  while (!tokens.matchesContextIdAndLabel(tt.braceR, constructorContextId)) {\n    if (!foundSuperCall && tokens.matches2(tt._super, tt.parenL)) {\n      tokens.nextToken();\n      const superCallContextId = tokens.currentToken().contextId;\n      if (superCallContextId == null) {\n        throw new Error(\"Expected a context ID on the super call\");\n      }\n      while (!tokens.matchesContextIdAndLabel(tt.parenR, superCallContextId)) {\n        tokens.nextToken();\n      }\n      constructorInsertPos = tokens.currentIndex();\n      foundSuperCall = true;\n    }\n    tokens.nextToken();\n  }\n  // }\n  tokens.nextToken();\n\n  return {constructorInitializerStatements, constructorInsertPos};\n}\n\n/**\n * Determine if this is any token that can go before the name in a method/field.\n */\nfunction isAccessModifier(token) {\n  return [\n    tt._async,\n    tt._get,\n    tt._set,\n    tt.plus,\n    tt.minus,\n    tt._readonly,\n    tt._static,\n    tt._public,\n    tt._private,\n    tt._protected,\n    tt._abstract,\n    tt.star,\n    tt._declare,\n  ].includes(token.type);\n}\n\n/**\n * The next token or set of tokens is either an identifier or an expression in square brackets, for\n * a method or field name.\n */\nfunction skipFieldName(tokens) {\n  if (tokens.matches1(tt.bracketL)) {\n    const startToken = tokens.currentToken();\n    const classContextId = startToken.contextId;\n    if (classContextId == null) {\n      throw new Error(\"Expected class context ID on computed name open bracket.\");\n    }\n    while (!tokens.matchesContextIdAndLabel(tt.bracketR, classContextId)) {\n      tokens.nextToken();\n    }\n    tokens.nextToken();\n  } else {\n    tokens.nextToken();\n  }\n}\n", "import {TokenType as tt} from \"../parser/tokenizer/types\";\n\n\nexport default function elideImportEquals(tokens) {\n  // import\n  tokens.removeInitialToken();\n  // name\n  tokens.removeToken();\n  // =\n  tokens.removeToken();\n  // name or require\n  tokens.removeToken();\n  // Handle either `import A = require('A')` or `import A = B.C.D`.\n  if (tokens.matches1(tt.parenL)) {\n    // (\n    tokens.removeToken();\n    // path string\n    tokens.removeToken();\n    // )\n    tokens.removeToken();\n  } else {\n    while (tokens.matches1(tt.dot)) {\n      // .\n      tokens.removeToken();\n      // name\n      tokens.removeToken();\n    }\n  }\n}\n", "import {isTopLevelDeclaration} from \"../parser/tokenizer\";\nimport {TokenType as tt} from \"../parser/tokenizer/types\";\n\n\n\n\n\n\n\nexport const EMPTY_DECLARATION_INFO = {\n  typeDeclarations: new Set(),\n  valueDeclarations: new Set(),\n};\n\n/**\n * Get all top-level identifiers that should be preserved when exported in TypeScript.\n *\n * Examples:\n * - If an identifier is declared as `const x`, then `export {x}` should be preserved.\n * - If it's declared as `type x`, then `export {x}` should be removed.\n * - If it's declared as both `const x` and `type x`, then the export should be preserved.\n * - Classes and enums should be preserved (even though they also introduce types).\n * - Imported identifiers should be preserved since we don't have enough information to\n *   rule them out. --isolatedModules disallows re-exports, which catches errors here.\n */\nexport default function getDeclarationInfo(tokens) {\n  const typeDeclarations = new Set();\n  const valueDeclarations = new Set();\n  for (let i = 0; i < tokens.tokens.length; i++) {\n    const token = tokens.tokens[i];\n    if (token.type === tt.name && isTopLevelDeclaration(token)) {\n      if (token.isType) {\n        typeDeclarations.add(tokens.identifierNameForToken(token));\n      } else {\n        valueDeclarations.add(tokens.identifierNameForToken(token));\n      }\n    }\n  }\n  return {typeDeclarations, valueDeclarations};\n}\n", "import {TokenType as tt} from \"../parser/tokenizer/types\";\n\n\n\n/**\n * Common method sharing code between CJS and ESM cases, since they're the same here.\n */\nexport default function shouldElideDefaultExport(\n  isTypeScriptTransformEnabled,\n  tokens,\n  declarationInfo,\n) {\n  if (!isTypeScriptTransformEnabled) {\n    return false;\n  }\n  const exportToken = tokens.currentToken();\n  if (exportToken.rhsEndIndex == null) {\n    throw new Error(\"Expected non-null rhsEndIndex on export token.\");\n  }\n  // The export must be of the form `export default a` or `export default a;`.\n  const numTokens = exportToken.rhsEndIndex - tokens.currentIndex();\n  if (\n    numTokens !== 3 &&\n    !(numTokens === 4 && tokens.matches1AtIndex(exportToken.rhsEndIndex - 1, tt.semi))\n  ) {\n    return false;\n  }\n  const identifierToken = tokens.tokenAtRelativeIndex(2);\n  if (identifierToken.type !== tt.name) {\n    return false;\n  }\n  const exportedName = tokens.identifierNameForToken(identifierToken);\n  return (\n    declarationInfo.typeDeclarations.has(exportedName) &&\n    !declarationInfo.valueDeclarations.has(exportedName)\n  );\n}\n", "\n\nimport {IdentifierRole, isDeclaration, isObjectShorthandDeclaration} from \"../parser/tokenizer\";\nimport {ContextualKeyword} from \"../parser/tokenizer/keywords\";\nimport {TokenType as tt} from \"../parser/tokenizer/types\";\n\nimport elideImportEquals from \"../util/elideImportEquals\";\nimport getDeclarationInfo, {\n\n  EMPTY_DECLARATION_INFO,\n} from \"../util/getDeclarationInfo\";\nimport shouldElideDefaultExport from \"../util/shouldElideDefaultExport\";\n\n\nimport Transformer from \"./Transformer\";\n\n/**\n * Class for editing import statements when we are transforming to commonjs.\n */\nexport default class CJSImportTransformer extends Transformer {\n   __init() {this.hadExport = false}\n   __init2() {this.hadNamedExport = false}\n   __init3() {this.hadDefaultExport = false}\n  \n\n  constructor(\n     rootTransformer,\n     tokens,\n     importProcessor,\n     nameManager,\n     reactHotLoaderTransformer,\n     enableLegacyBabel5ModuleInterop,\n     isTypeScriptTransformEnabled,\n  ) {\n    super();this.rootTransformer = rootTransformer;this.tokens = tokens;this.importProcessor = importProcessor;this.nameManager = nameManager;this.reactHotLoaderTransformer = reactHotLoaderTransformer;this.enableLegacyBabel5ModuleInterop = enableLegacyBabel5ModuleInterop;this.isTypeScriptTransformEnabled = isTypeScriptTransformEnabled;CJSImportTransformer.prototype.__init.call(this);CJSImportTransformer.prototype.__init2.call(this);CJSImportTransformer.prototype.__init3.call(this);;\n    this.declarationInfo = isTypeScriptTransformEnabled\n      ? getDeclarationInfo(tokens)\n      : EMPTY_DECLARATION_INFO;\n  }\n\n  getPrefixCode() {\n    let prefix = \"\";\n    if (this.hadExport) {\n      prefix += 'Object.defineProperty(exports, \"__esModule\", {value: true});';\n    }\n    return prefix;\n  }\n\n  getSuffixCode() {\n    if (this.enableLegacyBabel5ModuleInterop && this.hadDefaultExport && !this.hadNamedExport) {\n      return \"\\nmodule.exports = exports.default;\\n\";\n    }\n    return \"\";\n  }\n\n  process() {\n    // TypeScript `import foo = require('foo');` should always just be translated to plain require.\n    if (this.tokens.matches3(tt._import, tt.name, tt.eq)) {\n      return this.processImportEquals();\n    }\n    if (this.tokens.matches1(tt._import)) {\n      this.processImport();\n      return true;\n    }\n    if (this.tokens.matches2(tt._export, tt.eq)) {\n      this.tokens.replaceToken(\"module.exports\");\n      return true;\n    }\n    if (this.tokens.matches1(tt._export) && !this.tokens.currentToken().isType) {\n      this.hadExport = true;\n      return this.processExport();\n    }\n    if (this.tokens.matches2(tt.name, tt.postIncDec)) {\n      // Fall through to normal identifier matching if this doesn't apply.\n      if (this.processPostIncDec()) {\n        return true;\n      }\n    }\n    if (this.tokens.matches1(tt.name) || this.tokens.matches1(tt.jsxName)) {\n      return this.processIdentifier();\n    }\n    if (this.tokens.matches1(tt.eq)) {\n      return this.processAssignment();\n    }\n    if (this.tokens.matches1(tt.assign)) {\n      return this.processComplexAssignment();\n    }\n    if (this.tokens.matches1(tt.preIncDec)) {\n      return this.processPreIncDec();\n    }\n    return false;\n  }\n\n   processImportEquals() {\n    const importName = this.tokens.identifierNameAtIndex(this.tokens.currentIndex() + 1);\n    if (this.importProcessor.isTypeName(importName)) {\n      // If this name is only used as a type, elide the whole import.\n      elideImportEquals(this.tokens);\n    } else {\n      // Otherwise, switch `import` to `const`.\n      this.tokens.replaceToken(\"const\");\n    }\n    return true;\n  }\n\n  /**\n   * Transform this:\n   * import foo, {bar} from 'baz';\n   * into\n   * var _baz = require('baz'); var _baz2 = _interopRequireDefault(_baz);\n   *\n   * The import code was already generated in the import preprocessing step, so\n   * we just need to look it up.\n   */\n   processImport() {\n    if (this.tokens.matches2(tt._import, tt.parenL)) {\n      this.tokens.replaceToken(\"Promise.resolve().then(() => require\");\n      const contextId = this.tokens.currentToken().contextId;\n      if (contextId == null) {\n        throw new Error(\"Expected context ID on dynamic import invocation.\");\n      }\n      this.tokens.copyToken();\n      while (!this.tokens.matchesContextIdAndLabel(tt.parenR, contextId)) {\n        this.rootTransformer.processToken();\n      }\n      this.tokens.replaceToken(\"))\");\n      return;\n    }\n\n    const wasOnlyTypes = this.removeImportAndDetectIfType();\n\n    if (wasOnlyTypes) {\n      this.tokens.removeToken();\n    } else {\n      const path = this.tokens.stringValue();\n      this.tokens.replaceTokenTrimmingLeftWhitespace(this.importProcessor.claimImportCode(path));\n      this.tokens.appendCode(this.importProcessor.claimImportCode(path));\n    }\n    if (this.tokens.matches1(tt.semi)) {\n      this.tokens.removeToken();\n    }\n  }\n\n  /**\n   * Erase this import, and return true if it was either of the form \"import type\" or contained only\n   * \"type\" named imports. Such imports should not even do a side-effect import.\n   *\n   * The position should end at the import string.\n   */\n   removeImportAndDetectIfType() {\n    this.tokens.removeInitialToken();\n    if (\n      this.tokens.matchesContextual(ContextualKeyword._type) &&\n      !this.tokens.matches1AtIndex(this.tokens.currentIndex() + 1, tt.comma) &&\n      !this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 1, ContextualKeyword._from)\n    ) {\n      // This is an \"import type\" statement, so exit early.\n      this.removeRemainingImport();\n      return true;\n    }\n\n    if (this.tokens.matches1(tt.name) || this.tokens.matches1(tt.star)) {\n      // We have a default import or namespace import, so there must be some\n      // non-type import.\n      this.removeRemainingImport();\n      return false;\n    }\n\n    if (this.tokens.matches1(tt.string)) {\n      // This is a bare import, so we should proceed with the import.\n      return false;\n    }\n\n    let foundNonType = false;\n    while (!this.tokens.matches1(tt.string)) {\n      // Check if any named imports are of the form \"foo\" or \"foo as bar\", with\n      // no leading \"type\".\n      if ((!foundNonType && this.tokens.matches1(tt.braceL)) || this.tokens.matches1(tt.comma)) {\n        this.tokens.removeToken();\n        if (\n          this.tokens.matches2(tt.name, tt.comma) ||\n          this.tokens.matches2(tt.name, tt.braceR) ||\n          this.tokens.matches4(tt.name, tt.name, tt.name, tt.comma) ||\n          this.tokens.matches4(tt.name, tt.name, tt.name, tt.braceR)\n        ) {\n          foundNonType = true;\n        }\n      }\n      this.tokens.removeToken();\n    }\n    return !foundNonType;\n  }\n\n   removeRemainingImport() {\n    while (!this.tokens.matches1(tt.string)) {\n      this.tokens.removeToken();\n    }\n  }\n\n   processIdentifier() {\n    const token = this.tokens.currentToken();\n    if (token.shadowsGlobal) {\n      return false;\n    }\n\n    if (token.identifierRole === IdentifierRole.ObjectShorthand) {\n      return this.processObjectShorthand();\n    }\n\n    if (token.identifierRole !== IdentifierRole.Access) {\n      return false;\n    }\n    const replacement = this.importProcessor.getIdentifierReplacement(\n      this.tokens.identifierNameForToken(token),\n    );\n    if (!replacement) {\n      return false;\n    }\n    // Tolerate any number of closing parens while looking for an opening paren\n    // that indicates a function call.\n    let possibleOpenParenIndex = this.tokens.currentIndex() + 1;\n    while (\n      possibleOpenParenIndex < this.tokens.tokens.length &&\n      this.tokens.tokens[possibleOpenParenIndex].type === tt.parenR\n    ) {\n      possibleOpenParenIndex++;\n    }\n    // Avoid treating imported functions as methods of their `exports` object\n    // by using `(0, f)` when the identifier is in a paren expression. Else\n    // use `Function.prototype.call` when the identifier is a guaranteed\n    // function call. When using `call`, pass undefined as the context.\n    if (this.tokens.tokens[possibleOpenParenIndex].type === tt.parenL) {\n      if (\n        this.tokens.tokenAtRelativeIndex(1).type === tt.parenL &&\n        this.tokens.tokenAtRelativeIndex(-1).type !== tt._new\n      ) {\n        this.tokens.replaceToken(`${replacement}.call(void 0, `);\n        // Remove the old paren.\n        this.tokens.removeToken();\n        // Balance out the new paren.\n        this.rootTransformer.processBalancedCode();\n        this.tokens.copyExpectedToken(tt.parenR);\n      } else {\n        // See here: http://2ality.com/2015/12/references.html\n        this.tokens.replaceToken(`(0, ${replacement})`);\n      }\n    } else {\n      this.tokens.replaceToken(replacement);\n    }\n    return true;\n  }\n\n  processObjectShorthand() {\n    const identifier = this.tokens.identifierName();\n    const replacement = this.importProcessor.getIdentifierReplacement(identifier);\n    if (!replacement) {\n      return false;\n    }\n    this.tokens.replaceToken(`${identifier}: ${replacement}`);\n    return true;\n  }\n\n  processExport() {\n    if (\n      this.tokens.matches2(tt._export, tt._enum) ||\n      this.tokens.matches3(tt._export, tt._const, tt._enum)\n    ) {\n      // Let the TypeScript transform handle it.\n      return false;\n    }\n    if (this.tokens.matches2(tt._export, tt._default)) {\n      this.processExportDefault();\n      this.hadDefaultExport = true;\n      return true;\n    }\n    this.hadNamedExport = true;\n    if (\n      this.tokens.matches2(tt._export, tt._var) ||\n      this.tokens.matches2(tt._export, tt._let) ||\n      this.tokens.matches2(tt._export, tt._const)\n    ) {\n      this.processExportVar();\n      return true;\n    } else if (\n      this.tokens.matches2(tt._export, tt._function) ||\n      // export async function\n      this.tokens.matches3(tt._export, tt.name, tt._function)\n    ) {\n      this.processExportFunction();\n      return true;\n    } else if (\n      this.tokens.matches2(tt._export, tt._class) ||\n      this.tokens.matches3(tt._export, tt._abstract, tt._class)\n    ) {\n      this.processExportClass();\n      return true;\n    } else if (this.tokens.matches2(tt._export, tt.braceL)) {\n      this.processExportBindings();\n      return true;\n    } else if (this.tokens.matches2(tt._export, tt.star)) {\n      this.processExportStar();\n      return true;\n    } else if (\n      this.tokens.matches3(tt._export, tt.name, tt.braceL) &&\n      this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 1, ContextualKeyword._type)\n    ) {\n      // TS `export type {` case: just remove the export entirely.\n      this.tokens.removeInitialToken();\n      while (!this.tokens.matches1(tt.braceR)) {\n        this.tokens.removeToken();\n      }\n      this.tokens.removeToken();\n\n      // Remove type re-export `... } from './T'`\n      if (\n        this.tokens.matchesContextual(ContextualKeyword._from) &&\n        this.tokens.matches1AtIndex(this.tokens.currentIndex() + 1, tt.string)\n      ) {\n        this.tokens.removeToken();\n        this.tokens.removeToken();\n      }\n      return true;\n    } else {\n      throw new Error(\"Unrecognized export syntax.\");\n    }\n  }\n\n   processAssignment() {\n    const index = this.tokens.currentIndex();\n    const identifierToken = this.tokens.tokens[index - 1];\n    // If the LHS is a type identifier, this must be a declaration like `let a: b = c;`,\n    // with `b` as the identifier, so nothing needs to be done in that case.\n    if (identifierToken.isType || identifierToken.type !== tt.name) {\n      return false;\n    }\n    if (identifierToken.shadowsGlobal) {\n      return false;\n    }\n    if (index >= 2 && this.tokens.matches1AtIndex(index - 2, tt.dot)) {\n      return false;\n    }\n    if (index >= 2 && [tt._var, tt._let, tt._const].includes(this.tokens.tokens[index - 2].type)) {\n      // Declarations don't need an extra assignment. This doesn't avoid the\n      // assignment for comma-separated declarations, but it's still correct\n      // since the assignment is just redundant.\n      return false;\n    }\n    const assignmentSnippet = this.importProcessor.resolveExportBinding(\n      this.tokens.identifierNameForToken(identifierToken),\n    );\n    if (!assignmentSnippet) {\n      return false;\n    }\n    this.tokens.copyToken();\n    this.tokens.appendCode(` ${assignmentSnippet} =`);\n    return true;\n  }\n\n  /**\n   * Process something like `a += 3`, where `a` might be an exported value.\n   */\n   processComplexAssignment() {\n    const index = this.tokens.currentIndex();\n    const identifierToken = this.tokens.tokens[index - 1];\n    if (identifierToken.type !== tt.name) {\n      return false;\n    }\n    if (identifierToken.shadowsGlobal) {\n      return false;\n    }\n    if (index >= 2 && this.tokens.matches1AtIndex(index - 2, tt.dot)) {\n      return false;\n    }\n    const assignmentSnippet = this.importProcessor.resolveExportBinding(\n      this.tokens.identifierNameForToken(identifierToken),\n    );\n    if (!assignmentSnippet) {\n      return false;\n    }\n    this.tokens.appendCode(` = ${assignmentSnippet}`);\n    this.tokens.copyToken();\n    return true;\n  }\n\n  /**\n   * Process something like `++a`, where `a` might be an exported value.\n   */\n   processPreIncDec() {\n    const index = this.tokens.currentIndex();\n    const identifierToken = this.tokens.tokens[index + 1];\n    if (identifierToken.type !== tt.name) {\n      return false;\n    }\n    if (identifierToken.shadowsGlobal) {\n      return false;\n    }\n    // Ignore things like ++a.b and ++a[b] and ++a().b.\n    if (\n      index + 2 < this.tokens.tokens.length &&\n      (this.tokens.matches1AtIndex(index + 2, tt.dot) ||\n        this.tokens.matches1AtIndex(index + 2, tt.bracketL) ||\n        this.tokens.matches1AtIndex(index + 2, tt.parenL))\n    ) {\n      return false;\n    }\n    const identifierName = this.tokens.identifierNameForToken(identifierToken);\n    const assignmentSnippet = this.importProcessor.resolveExportBinding(identifierName);\n    if (!assignmentSnippet) {\n      return false;\n    }\n    this.tokens.appendCode(`${assignmentSnippet} = `);\n    this.tokens.copyToken();\n    return true;\n  }\n\n  /**\n   * Process something like `a++`, where `a` might be an exported value.\n   * This starts at the `a`, not at the `++`.\n   */\n   processPostIncDec() {\n    const index = this.tokens.currentIndex();\n    const identifierToken = this.tokens.tokens[index];\n    const operatorToken = this.tokens.tokens[index + 1];\n    if (identifierToken.type !== tt.name) {\n      return false;\n    }\n    if (identifierToken.shadowsGlobal) {\n      return false;\n    }\n    if (index >= 1 && this.tokens.matches1AtIndex(index - 1, tt.dot)) {\n      return false;\n    }\n    const identifierName = this.tokens.identifierNameForToken(identifierToken);\n    const assignmentSnippet = this.importProcessor.resolveExportBinding(identifierName);\n    if (!assignmentSnippet) {\n      return false;\n    }\n    const operatorCode = this.tokens.rawCodeForToken(operatorToken);\n    // We might also replace the identifier with something like exports.x, so\n    // do that replacement here as well.\n    const base = this.importProcessor.getIdentifierReplacement(identifierName) || identifierName;\n    if (operatorCode === \"++\") {\n      this.tokens.replaceToken(`(${base} = ${assignmentSnippet} = ${base} + 1, ${base} - 1)`);\n    } else if (operatorCode === \"--\") {\n      this.tokens.replaceToken(`(${base} = ${assignmentSnippet} = ${base} - 1, ${base} + 1)`);\n    } else {\n      throw new Error(`Unexpected operator: ${operatorCode}`);\n    }\n    this.tokens.removeToken();\n    return true;\n  }\n\n   processExportDefault() {\n    if (\n      this.tokens.matches4(tt._export, tt._default, tt._function, tt.name) ||\n      // export default async function\n      this.tokens.matches5(tt._export, tt._default, tt.name, tt._function, tt.name)\n    ) {\n      this.tokens.removeInitialToken();\n      this.tokens.removeToken();\n      // Named function export case: change it to a top-level function\n      // declaration followed by exports statement.\n      const name = this.processNamedFunction();\n      this.tokens.appendCode(` exports.default = ${name};`);\n    } else if (\n      this.tokens.matches4(tt._export, tt._default, tt._class, tt.name) ||\n      this.tokens.matches5(tt._export, tt._default, tt._abstract, tt._class, tt.name)\n    ) {\n      this.tokens.removeInitialToken();\n      this.tokens.removeToken();\n      if (this.tokens.matches1(tt._abstract)) {\n        this.tokens.removeToken();\n      }\n      const name = this.rootTransformer.processNamedClass();\n      this.tokens.appendCode(` exports.default = ${name};`);\n    } else if (this.tokens.matches3(tt._export, tt._default, tt.at)) {\n      throw new Error(\"Export default statements with decorators are not yet supported.\");\n      // After this point, this is a plain \"export default E\" statement.\n    } else if (\n      shouldElideDefaultExport(this.isTypeScriptTransformEnabled, this.tokens, this.declarationInfo)\n    ) {\n      // If the exported value is just an identifier and should be elided by TypeScript\n      // rules, then remove it entirely. It will always have the form `export default e`,\n      // where `e` is an identifier.\n      this.tokens.removeInitialToken();\n      this.tokens.removeToken();\n      this.tokens.removeToken();\n    } else if (this.reactHotLoaderTransformer) {\n      // We need to assign E to a variable. Change \"export default E\" to\n      // \"let _default; exports.default = _default = E\"\n      const defaultVarName = this.nameManager.claimFreeName(\"_default\");\n      this.tokens.replaceToken(`let ${defaultVarName}; exports.`);\n      this.tokens.copyToken();\n      this.tokens.appendCode(` = ${defaultVarName} =`);\n      this.reactHotLoaderTransformer.setExtractedDefaultExportName(defaultVarName);\n    } else {\n      // Change \"export default E\" to \"exports.default = E\"\n      this.tokens.replaceToken(\"exports.\");\n      this.tokens.copyToken();\n      this.tokens.appendCode(\" =\");\n    }\n  }\n\n  /**\n   * Transform a declaration like `export var`, `export let`, or `export const`.\n   */\n   processExportVar() {\n    if (this.isSimpleExportVar()) {\n      this.processSimpleExportVar();\n    } else {\n      this.processComplexExportVar();\n    }\n  }\n\n  /**\n   * Determine if the export is of the form:\n   * export var/let/const [varName] = [expr];\n   * In other words, determine if function name inference might apply.\n   */\n   isSimpleExportVar() {\n    let tokenIndex = this.tokens.currentIndex();\n    // export\n    tokenIndex++;\n    // var/let/const\n    tokenIndex++;\n    if (!this.tokens.matches1AtIndex(tokenIndex, tt.name)) {\n      return false;\n    }\n    tokenIndex++;\n    while (tokenIndex < this.tokens.tokens.length && this.tokens.tokens[tokenIndex].isType) {\n      tokenIndex++;\n    }\n    if (!this.tokens.matches1AtIndex(tokenIndex, tt.eq)) {\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * Transform an `export var` declaration initializing a single variable.\n   *\n   * For example, this:\n   * export const f = () => {};\n   * becomes this:\n   * const f = () => {}; exports.f = f;\n   *\n   * The variable is unused (e.g. exports.f has the true value of the export).\n   * We need to produce an assignment of this form so that the function will\n   * have an inferred name of \"f\", which wouldn't happen in the more general\n   * case below.\n   */\n   processSimpleExportVar() {\n    // export\n    this.tokens.removeInitialToken();\n    // var/let/const\n    this.tokens.copyToken();\n    const varName = this.tokens.identifierName();\n    // x: number  ->  x\n    while (!this.tokens.matches1(tt.eq)) {\n      this.rootTransformer.processToken();\n    }\n    const endIndex = this.tokens.currentToken().rhsEndIndex;\n    if (endIndex == null) {\n      throw new Error(\"Expected = token with an end index.\");\n    }\n    while (this.tokens.currentIndex() < endIndex) {\n      this.rootTransformer.processToken();\n    }\n    this.tokens.appendCode(`; exports.${varName} = ${varName}`);\n  }\n\n  /**\n   * Transform normal declaration exports, including handling destructuring.\n   * For example, this:\n   * export const {x: [a = 2, b], c} = d;\n   * becomes this:\n   * ({x: [exports.a = 2, exports.b], c: exports.c} = d;)\n   */\n   processComplexExportVar() {\n    this.tokens.removeInitialToken();\n    this.tokens.removeToken();\n    const needsParens = this.tokens.matches1(tt.braceL);\n    if (needsParens) {\n      this.tokens.appendCode(\"(\");\n    }\n\n    let depth = 0;\n    while (true) {\n      if (\n        this.tokens.matches1(tt.braceL) ||\n        this.tokens.matches1(tt.dollarBraceL) ||\n        this.tokens.matches1(tt.bracketL)\n      ) {\n        depth++;\n        this.tokens.copyToken();\n      } else if (this.tokens.matches1(tt.braceR) || this.tokens.matches1(tt.bracketR)) {\n        depth--;\n        this.tokens.copyToken();\n      } else if (\n        depth === 0 &&\n        !this.tokens.matches1(tt.name) &&\n        !this.tokens.currentToken().isType\n      ) {\n        break;\n      } else if (this.tokens.matches1(tt.eq)) {\n        // Default values might have assignments in the RHS that we want to ignore, so skip past\n        // them.\n        const endIndex = this.tokens.currentToken().rhsEndIndex;\n        if (endIndex == null) {\n          throw new Error(\"Expected = token with an end index.\");\n        }\n        while (this.tokens.currentIndex() < endIndex) {\n          this.rootTransformer.processToken();\n        }\n      } else {\n        const token = this.tokens.currentToken();\n        if (isDeclaration(token)) {\n          const name = this.tokens.identifierName();\n          let replacement = this.importProcessor.getIdentifierReplacement(name);\n          if (replacement === null) {\n            throw new Error(`Expected a replacement for ${name} in \\`export var\\` syntax.`);\n          }\n          if (isObjectShorthandDeclaration(token)) {\n            replacement = `${name}: ${replacement}`;\n          }\n          this.tokens.replaceToken(replacement);\n        } else {\n          this.rootTransformer.processToken();\n        }\n      }\n    }\n\n    if (needsParens) {\n      // Seek to the end of the RHS.\n      const endIndex = this.tokens.currentToken().rhsEndIndex;\n      if (endIndex == null) {\n        throw new Error(\"Expected = token with an end index.\");\n      }\n      while (this.tokens.currentIndex() < endIndex) {\n        this.rootTransformer.processToken();\n      }\n      this.tokens.appendCode(\")\");\n    }\n  }\n\n  /**\n   * Transform this:\n   * export function foo() {}\n   * into this:\n   * function foo() {} exports.foo = foo;\n   */\n   processExportFunction() {\n    this.tokens.replaceToken(\"\");\n    const name = this.processNamedFunction();\n    this.tokens.appendCode(` exports.${name} = ${name};`);\n  }\n\n  /**\n   * Skip past a function with a name and return that name.\n   */\n   processNamedFunction() {\n    if (this.tokens.matches1(tt._function)) {\n      this.tokens.copyToken();\n    } else if (this.tokens.matches2(tt.name, tt._function)) {\n      if (!this.tokens.matchesContextual(ContextualKeyword._async)) {\n        throw new Error(\"Expected async keyword in function export.\");\n      }\n      this.tokens.copyToken();\n      this.tokens.copyToken();\n    }\n    if (this.tokens.matches1(tt.star)) {\n      this.tokens.copyToken();\n    }\n    if (!this.tokens.matches1(tt.name)) {\n      throw new Error(\"Expected identifier for exported function name.\");\n    }\n    const name = this.tokens.identifierName();\n    this.tokens.copyToken();\n    if (this.tokens.currentToken().isType) {\n      this.tokens.removeInitialToken();\n      while (this.tokens.currentToken().isType) {\n        this.tokens.removeToken();\n      }\n    }\n    this.tokens.copyExpectedToken(tt.parenL);\n    this.rootTransformer.processBalancedCode();\n    this.tokens.copyExpectedToken(tt.parenR);\n    this.rootTransformer.processPossibleTypeRange();\n    this.tokens.copyExpectedToken(tt.braceL);\n    this.rootTransformer.processBalancedCode();\n    this.tokens.copyExpectedToken(tt.braceR);\n    return name;\n  }\n\n  /**\n   * Transform this:\n   * export class A {}\n   * into this:\n   * class A {} exports.A = A;\n   */\n   processExportClass() {\n    this.tokens.removeInitialToken();\n    if (this.tokens.matches1(tt._abstract)) {\n      this.tokens.removeToken();\n    }\n    const name = this.rootTransformer.processNamedClass();\n    this.tokens.appendCode(` exports.${name} = ${name};`);\n  }\n\n  /**\n   * Transform this:\n   * export {a, b as c};\n   * into this:\n   * exports.a = a; exports.c = b;\n   *\n   * OR\n   *\n   * Transform this:\n   * export {a, b as c} from './foo';\n   * into the pre-generated Object.defineProperty code from the ImportProcessor.\n   *\n   * For the first case, if the TypeScript transform is enabled, we need to skip\n   * exports that are only defined as types.\n   */\n   processExportBindings() {\n    this.tokens.removeInitialToken();\n    this.tokens.removeToken();\n\n    const exportStatements = [];\n    while (true) {\n      if (this.tokens.matches1(tt.braceR)) {\n        this.tokens.removeToken();\n        break;\n      }\n\n      const localName = this.tokens.identifierName();\n      let exportedName;\n      this.tokens.removeToken();\n      if (this.tokens.matchesContextual(ContextualKeyword._as)) {\n        this.tokens.removeToken();\n        exportedName = this.tokens.identifierName();\n        this.tokens.removeToken();\n      } else {\n        exportedName = localName;\n      }\n      if (!this.shouldElideExportedIdentifier(localName)) {\n        const newLocalName = this.importProcessor.getIdentifierReplacement(localName);\n        exportStatements.push(`exports.${exportedName} = ${newLocalName || localName};`);\n      }\n\n      if (this.tokens.matches1(tt.braceR)) {\n        this.tokens.removeToken();\n        break;\n      }\n      if (this.tokens.matches2(tt.comma, tt.braceR)) {\n        this.tokens.removeToken();\n        this.tokens.removeToken();\n        break;\n      } else if (this.tokens.matches1(tt.comma)) {\n        this.tokens.removeToken();\n      } else {\n        throw new Error(`Unexpected token: ${JSON.stringify(this.tokens.currentToken())}`);\n      }\n    }\n\n    if (this.tokens.matchesContextual(ContextualKeyword._from)) {\n      // This is an export...from, so throw away the normal named export code\n      // and use the Object.defineProperty code from ImportProcessor.\n      this.tokens.removeToken();\n      const path = this.tokens.stringValue();\n      this.tokens.replaceTokenTrimmingLeftWhitespace(this.importProcessor.claimImportCode(path));\n    } else {\n      // This is a normal named export, so use that.\n      this.tokens.appendCode(exportStatements.join(\" \"));\n    }\n\n    if (this.tokens.matches1(tt.semi)) {\n      this.tokens.removeToken();\n    }\n  }\n\n   processExportStar() {\n    this.tokens.removeInitialToken();\n    while (!this.tokens.matches1(tt.string)) {\n      this.tokens.removeToken();\n    }\n    const path = this.tokens.stringValue();\n    this.tokens.replaceTokenTrimmingLeftWhitespace(this.importProcessor.claimImportCode(path));\n    if (this.tokens.matches1(tt.semi)) {\n      this.tokens.removeToken();\n    }\n  }\n\n   shouldElideExportedIdentifier(name) {\n    return this.isTypeScriptTransformEnabled && !this.declarationInfo.valueDeclarations.has(name);\n  }\n}\n", "\n\nimport {ContextualKeyword} from \"../parser/tokenizer/keywords\";\nimport {TokenType as tt} from \"../parser/tokenizer/types\";\n\nimport elideImportEquals from \"../util/elideImportEquals\";\nimport getDeclarationInfo, {\n\n  EMPTY_DECLARATION_INFO,\n} from \"../util/getDeclarationInfo\";\nimport {getNonTypeIdentifiers} from \"../util/getNonTypeIdentifiers\";\nimport shouldElideDefaultExport from \"../util/shouldElideDefaultExport\";\n\nimport Transformer from \"./Transformer\";\n\n/**\n * Class for editing import statements when we are keeping the code as ESM. We still need to remove\n * type-only imports in TypeScript and Flow.\n */\nexport default class ESMImportTransformer extends Transformer {\n  \n  \n\n  constructor(\n     tokens,\n     nameManager,\n     reactHotLoaderTransformer,\n     isTypeScriptTransformEnabled,\n    options,\n  ) {\n    super();this.tokens = tokens;this.nameManager = nameManager;this.reactHotLoaderTransformer = reactHotLoaderTransformer;this.isTypeScriptTransformEnabled = isTypeScriptTransformEnabled;;\n    this.nonTypeIdentifiers = isTypeScriptTransformEnabled\n      ? getNonTypeIdentifiers(tokens, options)\n      : new Set();\n    this.declarationInfo = isTypeScriptTransformEnabled\n      ? getDeclarationInfo(tokens)\n      : EMPTY_DECLARATION_INFO;\n  }\n\n  process() {\n    // TypeScript `import foo = require('foo');` should always just be translated to plain require.\n    if (this.tokens.matches3(tt._import, tt.name, tt.eq)) {\n      return this.processImportEquals();\n    }\n    if (this.tokens.matches2(tt._export, tt.eq)) {\n      this.tokens.replaceToken(\"module.exports\");\n      return true;\n    }\n    if (this.tokens.matches1(tt._import)) {\n      return this.processImport();\n    }\n    if (this.tokens.matches2(tt._export, tt._default)) {\n      return this.processExportDefault();\n    }\n    if (this.tokens.matches2(tt._export, tt.braceL)) {\n      return this.processNamedExports();\n    }\n    if (\n      this.tokens.matches3(tt._export, tt.name, tt.braceL) &&\n      this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 1, ContextualKeyword._type)\n    ) {\n      // TS `export type {` case: just remove the export entirely.\n      this.tokens.removeInitialToken();\n      while (!this.tokens.matches1(tt.braceR)) {\n        this.tokens.removeToken();\n      }\n      this.tokens.removeToken();\n\n      // Remove type re-export `... } from './T'`\n      if (\n        this.tokens.matchesContextual(ContextualKeyword._from) &&\n        this.tokens.matches1AtIndex(this.tokens.currentIndex() + 1, tt.string)\n      ) {\n        this.tokens.removeToken();\n        this.tokens.removeToken();\n      }\n      return true;\n    }\n    return false;\n  }\n\n   processImportEquals() {\n    const importName = this.tokens.identifierNameAtIndex(this.tokens.currentIndex() + 1);\n    if (this.isTypeName(importName)) {\n      // If this name is only used as a type, elide the whole import.\n      elideImportEquals(this.tokens);\n    } else {\n      // Otherwise, switch `import` to `const`.\n      this.tokens.replaceToken(\"const\");\n    }\n    return true;\n  }\n\n   processImport() {\n    if (this.tokens.matches2(tt._import, tt.parenL)) {\n      // Dynamic imports don't need to be transformed.\n      return false;\n    }\n\n    const snapshot = this.tokens.snapshot();\n    const allImportsRemoved = this.removeImportTypeBindings();\n    if (allImportsRemoved) {\n      this.tokens.restoreToSnapshot(snapshot);\n      while (!this.tokens.matches1(tt.string)) {\n        this.tokens.removeToken();\n      }\n      this.tokens.removeToken();\n      if (this.tokens.matches1(tt.semi)) {\n        this.tokens.removeToken();\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Remove type bindings from this import, leaving the rest of the import intact.\n   *\n   * Return true if this import was ONLY types, and thus is eligible for removal. This will bail out\n   * of the replacement operation, so we can return early here.\n   */\n   removeImportTypeBindings() {\n    this.tokens.copyExpectedToken(tt._import);\n    if (\n      this.tokens.matchesContextual(ContextualKeyword._type) &&\n      !this.tokens.matches1AtIndex(this.tokens.currentIndex() + 1, tt.comma) &&\n      !this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 1, ContextualKeyword._from)\n    ) {\n      // This is an \"import type\" statement, so exit early.\n      return true;\n    }\n\n    if (this.tokens.matches1(tt.string)) {\n      // This is a bare import, so we should proceed with the import.\n      this.tokens.copyToken();\n      return false;\n    }\n\n    let foundNonTypeImport = false;\n\n    if (this.tokens.matches1(tt.name)) {\n      if (this.isTypeName(this.tokens.identifierName())) {\n        this.tokens.removeToken();\n        if (this.tokens.matches1(tt.comma)) {\n          this.tokens.removeToken();\n        }\n      } else {\n        foundNonTypeImport = true;\n        this.tokens.copyToken();\n        if (this.tokens.matches1(tt.comma)) {\n          this.tokens.copyToken();\n        }\n      }\n    }\n\n    if (this.tokens.matches1(tt.star)) {\n      if (this.isTypeName(this.tokens.identifierNameAtIndex(this.tokens.currentIndex() + 2))) {\n        this.tokens.removeToken();\n        this.tokens.removeToken();\n        this.tokens.removeToken();\n      } else {\n        foundNonTypeImport = true;\n        this.tokens.copyExpectedToken(tt.star);\n        this.tokens.copyExpectedToken(tt.name);\n        this.tokens.copyExpectedToken(tt.name);\n      }\n    } else if (this.tokens.matches1(tt.braceL)) {\n      this.tokens.copyToken();\n      while (!this.tokens.matches1(tt.braceR)) {\n        if (\n          this.tokens.matches3(tt.name, tt.name, tt.comma) ||\n          this.tokens.matches3(tt.name, tt.name, tt.braceR)\n        ) {\n          // type foo\n          this.tokens.removeToken();\n          this.tokens.removeToken();\n          if (this.tokens.matches1(tt.comma)) {\n            this.tokens.removeToken();\n          }\n        } else if (\n          this.tokens.matches5(tt.name, tt.name, tt.name, tt.name, tt.comma) ||\n          this.tokens.matches5(tt.name, tt.name, tt.name, tt.name, tt.braceR)\n        ) {\n          // type foo as bar\n          this.tokens.removeToken();\n          this.tokens.removeToken();\n          this.tokens.removeToken();\n          this.tokens.removeToken();\n          if (this.tokens.matches1(tt.comma)) {\n            this.tokens.removeToken();\n          }\n        } else if (\n          this.tokens.matches2(tt.name, tt.comma) ||\n          this.tokens.matches2(tt.name, tt.braceR)\n        ) {\n          // foo\n          if (this.isTypeName(this.tokens.identifierName())) {\n            this.tokens.removeToken();\n            if (this.tokens.matches1(tt.comma)) {\n              this.tokens.removeToken();\n            }\n          } else {\n            foundNonTypeImport = true;\n            this.tokens.copyToken();\n            if (this.tokens.matches1(tt.comma)) {\n              this.tokens.copyToken();\n            }\n          }\n        } else if (\n          this.tokens.matches4(tt.name, tt.name, tt.name, tt.comma) ||\n          this.tokens.matches4(tt.name, tt.name, tt.name, tt.braceR)\n        ) {\n          // foo as bar\n          if (this.isTypeName(this.tokens.identifierNameAtIndex(this.tokens.currentIndex() + 2))) {\n            this.tokens.removeToken();\n            this.tokens.removeToken();\n            this.tokens.removeToken();\n            if (this.tokens.matches1(tt.comma)) {\n              this.tokens.removeToken();\n            }\n          } else {\n            foundNonTypeImport = true;\n            this.tokens.copyToken();\n            this.tokens.copyToken();\n            this.tokens.copyToken();\n            if (this.tokens.matches1(tt.comma)) {\n              this.tokens.copyToken();\n            }\n          }\n        } else {\n          throw new Error(\"Unexpected import form.\");\n        }\n      }\n      this.tokens.copyExpectedToken(tt.braceR);\n    }\n\n    return !foundNonTypeImport;\n  }\n\n   isTypeName(name) {\n    return this.isTypeScriptTransformEnabled && !this.nonTypeIdentifiers.has(name);\n  }\n\n   processExportDefault() {\n    if (\n      shouldElideDefaultExport(this.isTypeScriptTransformEnabled, this.tokens, this.declarationInfo)\n    ) {\n      // If the exported value is just an identifier and should be elided by TypeScript\n      // rules, then remove it entirely. It will always have the form `export default e`,\n      // where `e` is an identifier.\n      this.tokens.removeInitialToken();\n      this.tokens.removeToken();\n      this.tokens.removeToken();\n      return true;\n    }\n\n    const alreadyHasName =\n      this.tokens.matches4(tt._export, tt._default, tt._function, tt.name) ||\n      // export default async function\n      this.tokens.matches5(tt._export, tt._default, tt.name, tt._function, tt.name) ||\n      this.tokens.matches4(tt._export, tt._default, tt._class, tt.name) ||\n      this.tokens.matches5(tt._export, tt._default, tt._abstract, tt._class, tt.name);\n\n    if (!alreadyHasName && this.reactHotLoaderTransformer) {\n      // This is a plain \"export default E\" statement and we need to assign E to a variable.\n      // Change \"export default E\" to \"let _default; export default _default = E\"\n      const defaultVarName = this.nameManager.claimFreeName(\"_default\");\n      this.tokens.replaceToken(`let ${defaultVarName}; export`);\n      this.tokens.copyToken();\n      this.tokens.appendCode(` ${defaultVarName} =`);\n      this.reactHotLoaderTransformer.setExtractedDefaultExportName(defaultVarName);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * In TypeScript, we need to remove named exports that were never declared or only declared as a\n   * type.\n   */\n   processNamedExports() {\n    if (!this.isTypeScriptTransformEnabled) {\n      return false;\n    }\n    this.tokens.copyExpectedToken(tt._export);\n    this.tokens.copyExpectedToken(tt.braceL);\n\n    while (!this.tokens.matches1(tt.braceR)) {\n      if (!this.tokens.matches1(tt.name)) {\n        throw new Error(\"Expected identifier at the start of named export.\");\n      }\n      if (this.shouldElideExportedName(this.tokens.identifierName())) {\n        while (\n          !this.tokens.matches1(tt.comma) &&\n          !this.tokens.matches1(tt.braceR) &&\n          !this.tokens.isAtEnd()\n        ) {\n          this.tokens.removeToken();\n        }\n        if (this.tokens.matches1(tt.comma)) {\n          this.tokens.removeToken();\n        }\n      } else {\n        while (\n          !this.tokens.matches1(tt.comma) &&\n          !this.tokens.matches1(tt.braceR) &&\n          !this.tokens.isAtEnd()\n        ) {\n          this.tokens.copyToken();\n        }\n        if (this.tokens.matches1(tt.comma)) {\n          this.tokens.copyToken();\n        }\n      }\n    }\n    this.tokens.copyExpectedToken(tt.braceR);\n    return true;\n  }\n\n  /**\n   * ESM elides all imports with the rule that we only elide if we see that it's\n   * a type and never see it as a value. This is in contract to CJS, which\n   * elides imports that are completely unknown.\n   */\n   shouldElideExportedName(name) {\n    return (\n      this.isTypeScriptTransformEnabled &&\n      this.declarationInfo.typeDeclarations.has(name) &&\n      !this.declarationInfo.valueDeclarations.has(name)\n    );\n  }\n}\n", "\n\nimport Transformer from \"./Transformer\";\n\nexport default class FlowTransformer extends Transformer {\n  constructor( rootTransformer,  tokens) {\n    super();this.rootTransformer = rootTransformer;this.tokens = tokens;;\n  }\n\n  process() {\n    return (\n      this.rootTransformer.processPossibleArrowParamEnd() ||\n      this.rootTransformer.processPossibleAsyncArrowWithTypeParams() ||\n      this.rootTransformer.processPossibleTypeRange()\n    );\n  }\n}\n", "import {TokenType as tt} from \"../parser/tokenizer/types\";\n\nimport Transformer from \"./Transformer\";\n\nexport default class NumericSeparatorTransformer extends Transformer {\n  constructor( tokens) {\n    super();this.tokens = tokens;;\n  }\n\n  process() {\n    if (this.tokens.matches1(tt.num)) {\n      const code = this.tokens.currentTokenCode();\n      if (code.includes(\"_\")) {\n        this.tokens.replaceToken(code.replace(/_/g, \"\"));\n        return true;\n      }\n    }\n    return false;\n  }\n}\n", "\nimport {TokenType as tt} from \"../parser/tokenizer/types\";\n\nimport Transformer from \"./Transformer\";\n\nexport default class OptionalCatchBindingTransformer extends Transformer {\n  constructor( tokens,  nameManager) {\n    super();this.tokens = tokens;this.nameManager = nameManager;;\n  }\n\n  process() {\n    if (this.tokens.matches2(tt._catch, tt.braceL)) {\n      this.tokens.copyToken();\n      this.tokens.appendCode(` (${this.nameManager.claimFreeName(\"e\")})`);\n      return true;\n    }\n    return false;\n  }\n}\n", "\nimport {TokenType as tt} from \"../parser/tokenizer/types\";\n\nimport Transformer from \"./Transformer\";\n\n/**\n * Transformer supporting the optional chaining and nullish coalescing operators.\n *\n * Tech plan here:\n * https://github.com/alangpierce/sucrase/wiki/Sucrase-Optional-Chaining-and-Nullish-Coalescing-Technical-Plan\n *\n * The prefix and suffix code snippets are handled by TokenProcessor, and this transformer handles\n * the operators themselves.\n */\nexport default class OptionalChainingNullishTransformer extends Transformer {\n  constructor( tokens,  nameManager) {\n    super();this.tokens = tokens;this.nameManager = nameManager;;\n  }\n\n  process() {\n    if (this.tokens.matches1(tt.nullishCoalescing)) {\n      const token = this.tokens.currentToken();\n      if (this.tokens.tokens[token.nullishStartIndex].isAsyncOperation) {\n        this.tokens.replaceTokenTrimmingLeftWhitespace(\", async () => (\");\n      } else {\n        this.tokens.replaceTokenTrimmingLeftWhitespace(\", () => (\");\n      }\n      return true;\n    }\n    if (this.tokens.matches1(tt._delete)) {\n      const nextToken = this.tokens.tokenAtRelativeIndex(1);\n      if (nextToken.isOptionalChainStart) {\n        this.tokens.removeInitialToken();\n        return true;\n      }\n    }\n    const token = this.tokens.currentToken();\n    const chainStart = token.subscriptStartIndex;\n    if (\n      chainStart != null &&\n      this.tokens.tokens[chainStart].isOptionalChainStart &&\n      // Super subscripts can't be optional (since super is never null/undefined), and the syntax\n      // relies on the subscript being intact, so leave this token alone.\n      this.tokens.tokenAtRelativeIndex(-1).type !== tt._super\n    ) {\n      const param = this.nameManager.claimFreeName(\"_\");\n      let arrowStartSnippet;\n      if (\n        chainStart > 0 &&\n        this.tokens.matches1AtIndex(chainStart - 1, tt._delete) &&\n        this.isLastSubscriptInChain()\n      ) {\n        // Delete operations are special: we already removed the delete keyword, and to still\n        // perform a delete, we need to insert a delete in the very last part of the chain, which\n        // in correct code will always be a property access.\n        arrowStartSnippet = `${param} => delete ${param}`;\n      } else {\n        arrowStartSnippet = `${param} => ${param}`;\n      }\n      if (this.tokens.tokens[chainStart].isAsyncOperation) {\n        arrowStartSnippet = `async ${arrowStartSnippet}`;\n      }\n      if (\n        this.tokens.matches2(tt.questionDot, tt.parenL) ||\n        this.tokens.matches2(tt.questionDot, tt.lessThan)\n      ) {\n        if (this.justSkippedSuper()) {\n          this.tokens.appendCode(\".bind(this)\");\n        }\n        this.tokens.replaceTokenTrimmingLeftWhitespace(`, 'optionalCall', ${arrowStartSnippet}`);\n      } else if (this.tokens.matches2(tt.questionDot, tt.bracketL)) {\n        this.tokens.replaceTokenTrimmingLeftWhitespace(`, 'optionalAccess', ${arrowStartSnippet}`);\n      } else if (this.tokens.matches1(tt.questionDot)) {\n        this.tokens.replaceTokenTrimmingLeftWhitespace(`, 'optionalAccess', ${arrowStartSnippet}.`);\n      } else if (this.tokens.matches1(tt.dot)) {\n        this.tokens.replaceTokenTrimmingLeftWhitespace(`, 'access', ${arrowStartSnippet}.`);\n      } else if (this.tokens.matches1(tt.bracketL)) {\n        this.tokens.replaceTokenTrimmingLeftWhitespace(`, 'access', ${arrowStartSnippet}[`);\n      } else if (this.tokens.matches1(tt.parenL)) {\n        if (this.justSkippedSuper()) {\n          this.tokens.appendCode(\".bind(this)\");\n        }\n        this.tokens.replaceTokenTrimmingLeftWhitespace(`, 'call', ${arrowStartSnippet}(`);\n      } else {\n        throw new Error(\"Unexpected subscript operator in optional chain.\");\n      }\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Determine if the current token is the last of its chain, so that we know whether it's eligible\n   * to have a delete op inserted.\n   *\n   * We can do this by walking forward until we determine one way or another. Each\n   * isOptionalChainStart token must be paired with exactly one isOptionalChainEnd token after it in\n   * a nesting way, so we can track depth and walk to the end of the chain (the point where the\n   * depth goes negative) and see if any other subscript token is after us in the chain.\n   */\n  isLastSubscriptInChain() {\n    let depth = 0;\n    for (let i = this.tokens.currentIndex() + 1; ; i++) {\n      if (i >= this.tokens.tokens.length) {\n        throw new Error(\"Reached the end of the code while finding the end of the access chain.\");\n      }\n      if (this.tokens.tokens[i].isOptionalChainStart) {\n        depth++;\n      } else if (this.tokens.tokens[i].isOptionalChainEnd) {\n        depth--;\n      }\n      if (depth < 0) {\n        return true;\n      }\n\n      // This subscript token is a later one in the same chain.\n      if (depth === 0 && this.tokens.tokens[i].subscriptStartIndex != null) {\n        return false;\n      }\n    }\n  }\n\n  /**\n   * Determine if we are the open-paren in an expression like super.a()?.b.\n   *\n   * We can do this by walking backward to find the previous subscript. If that subscript was\n   * preceded by a super, then we must be the subscript after it, so if this is a call expression,\n   * we'll need to attach the right context.\n   */\n  justSkippedSuper() {\n    let depth = 0;\n    let index = this.tokens.currentIndex() - 1;\n    while (true) {\n      if (index < 0) {\n        throw new Error(\n          \"Reached the start of the code while finding the start of the access chain.\",\n        );\n      }\n      if (this.tokens.tokens[index].isOptionalChainStart) {\n        depth--;\n      } else if (this.tokens.tokens[index].isOptionalChainEnd) {\n        depth++;\n      }\n      if (depth < 0) {\n        return false;\n      }\n\n      // This subscript token is a later one in the same chain.\n      if (depth === 0 && this.tokens.tokens[index].subscriptStartIndex != null) {\n        return this.tokens.tokens[index - 1].type === tt._super;\n      }\n      index--;\n    }\n  }\n}\n", "\n\nimport {IdentifierRole} from \"../parser/tokenizer\";\nimport {TokenType as tt} from \"../parser/tokenizer/types\";\n\n\nimport Transformer from \"./Transformer\";\n\n/**\n * Implementation of babel-plugin-transform-react-display-name, which adds a\n * display name to usages of React.createClass and createReactClass.\n */\nexport default class ReactDisplayNameTransformer extends Transformer {\n  constructor(\n     rootTransformer,\n     tokens,\n     importProcessor,\n     options,\n  ) {\n    super();this.rootTransformer = rootTransformer;this.tokens = tokens;this.importProcessor = importProcessor;this.options = options;;\n  }\n\n  process() {\n    const startIndex = this.tokens.currentIndex();\n    if (this.tokens.identifierName() === \"createReactClass\") {\n      const newName =\n        this.importProcessor && this.importProcessor.getIdentifierReplacement(\"createReactClass\");\n      if (newName) {\n        this.tokens.replaceToken(`(0, ${newName})`);\n      } else {\n        this.tokens.copyToken();\n      }\n      this.tryProcessCreateClassCall(startIndex);\n      return true;\n    }\n    if (\n      this.tokens.matches3(tt.name, tt.dot, tt.name) &&\n      this.tokens.identifierName() === \"React\" &&\n      this.tokens.identifierNameAtIndex(this.tokens.currentIndex() + 2) === \"createClass\"\n    ) {\n      const newName = this.importProcessor\n        ? this.importProcessor.getIdentifierReplacement(\"React\") || \"React\"\n        : \"React\";\n      if (newName) {\n        this.tokens.replaceToken(newName);\n        this.tokens.copyToken();\n        this.tokens.copyToken();\n      } else {\n        this.tokens.copyToken();\n        this.tokens.copyToken();\n        this.tokens.copyToken();\n      }\n      this.tryProcessCreateClassCall(startIndex);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * This is called with the token position at the open-paren.\n   */\n   tryProcessCreateClassCall(startIndex) {\n    const displayName = this.findDisplayName(startIndex);\n    if (!displayName) {\n      return;\n    }\n\n    if (this.classNeedsDisplayName()) {\n      this.tokens.copyExpectedToken(tt.parenL);\n      this.tokens.copyExpectedToken(tt.braceL);\n      this.tokens.appendCode(`displayName: '${displayName}',`);\n      this.rootTransformer.processBalancedCode();\n      this.tokens.copyExpectedToken(tt.braceR);\n      this.tokens.copyExpectedToken(tt.parenR);\n    }\n  }\n\n   findDisplayName(startIndex) {\n    if (startIndex < 2) {\n      return null;\n    }\n    if (this.tokens.matches2AtIndex(startIndex - 2, tt.name, tt.eq)) {\n      // This is an assignment (or declaration) and the LHS is either an identifier or a member\n      // expression ending in an identifier, so use that identifier name.\n      return this.tokens.identifierNameAtIndex(startIndex - 2);\n    }\n    if (\n      startIndex >= 2 &&\n      this.tokens.tokens[startIndex - 2].identifierRole === IdentifierRole.ObjectKey\n    ) {\n      // This is an object literal value.\n      return this.tokens.identifierNameAtIndex(startIndex - 2);\n    }\n    if (this.tokens.matches2AtIndex(startIndex - 2, tt._export, tt._default)) {\n      return this.getDisplayNameFromFilename();\n    }\n    return null;\n  }\n\n   getDisplayNameFromFilename() {\n    const filePath = this.options.filePath || \"unknown\";\n    const pathSegments = filePath.split(\"/\");\n    const filename = pathSegments[pathSegments.length - 1];\n    const dotIndex = filename.lastIndexOf(\".\");\n    const baseFilename = dotIndex === -1 ? filename : filename.slice(0, dotIndex);\n    if (baseFilename === \"index\" && pathSegments[pathSegments.length - 2]) {\n      return pathSegments[pathSegments.length - 2];\n    } else {\n      return baseFilename;\n    }\n  }\n\n  /**\n   * We only want to add a display name when this is a function call containing\n   * one argument, which is an object literal without `displayName` as an\n   * existing key.\n   */\n   classNeedsDisplayName() {\n    let index = this.tokens.currentIndex();\n    if (!this.tokens.matches2(tt.parenL, tt.braceL)) {\n      return false;\n    }\n    // The block starts on the {, and we expect any displayName key to be in\n    // that context. We need to ignore other other contexts to avoid matching\n    // nested displayName keys.\n    const objectStartIndex = index + 1;\n    const objectContextId = this.tokens.tokens[objectStartIndex].contextId;\n    if (objectContextId == null) {\n      throw new Error(\"Expected non-null context ID on object open-brace.\");\n    }\n\n    for (; index < this.tokens.tokens.length; index++) {\n      const token = this.tokens.tokens[index];\n      if (token.type === tt.braceR && token.contextId === objectContextId) {\n        index++;\n        break;\n      }\n\n      if (\n        this.tokens.identifierNameAtIndex(index) === \"displayName\" &&\n        this.tokens.tokens[index].identifierRole === IdentifierRole.ObjectKey &&\n        token.contextId === objectContextId\n      ) {\n        // We found a displayName key, so bail out.\n        return false;\n      }\n    }\n\n    if (index === this.tokens.tokens.length) {\n      throw new Error(\"Unexpected end of input when processing React class.\");\n    }\n\n    // If we got this far, we know we have createClass with an object with no\n    // display name, so we want to proceed as long as that was the only argument.\n    return (\n      this.tokens.matches1AtIndex(index, tt.parenR) ||\n      this.tokens.matches2AtIndex(index, tt.comma, tt.parenR)\n    );\n  }\n}\n", "import {IdentifierRole, isTopLevelDeclaration} from \"../parser/tokenizer\";\n\nimport Transformer from \"./Transformer\";\n\nexport default class ReactHotLoaderTransformer extends Transformer {\n   __init() {this.extractedDefaultExportName = null}\n\n  constructor( tokens,  filePath) {\n    super();this.tokens = tokens;this.filePath = filePath;ReactHotLoaderTransformer.prototype.__init.call(this);;\n  }\n\n  setExtractedDefaultExportName(extractedDefaultExportName) {\n    this.extractedDefaultExportName = extractedDefaultExportName;\n  }\n\n  getPrefixCode() {\n    return `\n      (function () {\n        var enterModule = require('react-hot-loader').enterModule;\n        enterModule && enterModule(module);\n      })();`\n      .replace(/\\s+/g, \" \")\n      .trim();\n  }\n\n  getSuffixCode() {\n    const topLevelNames = new Set();\n    for (const token of this.tokens.tokens) {\n      if (\n        !token.isType &&\n        isTopLevelDeclaration(token) &&\n        token.identifierRole !== IdentifierRole.ImportDeclaration\n      ) {\n        topLevelNames.add(this.tokens.identifierNameForToken(token));\n      }\n    }\n    const namesToRegister = Array.from(topLevelNames).map((name) => ({\n      variableName: name,\n      uniqueLocalName: name,\n    }));\n    if (this.extractedDefaultExportName) {\n      namesToRegister.push({\n        variableName: this.extractedDefaultExportName,\n        uniqueLocalName: \"default\",\n      });\n    }\n    return `\n;(function () {\n  var reactHotLoader = require('react-hot-loader').default;\n  var leaveModule = require('react-hot-loader').leaveModule;\n  if (!reactHotLoader) {\n    return;\n  }\n${namesToRegister\n  .map(\n    ({variableName, uniqueLocalName}) =>\n      `  reactHotLoader.register(${variableName}, \"${uniqueLocalName}\", ${JSON.stringify(\n        this.filePath || \"\",\n      )});`,\n  )\n  .join(\"\\n\")}\n  leaveModule(module);\n})();`;\n  }\n\n  process() {\n    return false;\n  }\n}\n", "import {IS_IDENTIFIER_CHAR, IS_IDENTIFIER_START} from \"../parser/util/identifier\";\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Lexical_grammar\n// Hard-code a list of reserved words rather than trying to use keywords or contextual keywords\n// from the parser, since currently there are various exceptions, like `package` being reserved\n// but unused and various contextual keywords being reserved. Note that we assume that all code\n// compiled by Sucrase is in a module, so strict mode words and await are all considered reserved\n// here.\nconst RESERVED_WORDS = new Set([\n  // Reserved keywords as of ECMAScript 2015\n  \"break\",\n  \"case\",\n  \"catch\",\n  \"class\",\n  \"const\",\n  \"continue\",\n  \"debugger\",\n  \"default\",\n  \"delete\",\n  \"do\",\n  \"else\",\n  \"export\",\n  \"extends\",\n  \"finally\",\n  \"for\",\n  \"function\",\n  \"if\",\n  \"import\",\n  \"in\",\n  \"instanceof\",\n  \"new\",\n  \"return\",\n  \"super\",\n  \"switch\",\n  \"this\",\n  \"throw\",\n  \"try\",\n  \"typeof\",\n  \"var\",\n  \"void\",\n  \"while\",\n  \"with\",\n  \"yield\",\n  // Future reserved keywords\n  \"enum\",\n  \"implements\",\n  \"interface\",\n  \"let\",\n  \"package\",\n  \"private\",\n  \"protected\",\n  \"public\",\n  \"static\",\n  \"await\",\n]);\n\nexport default function isIdentifier(name) {\n  if (name.length === 0) {\n    return false;\n  }\n  if (!IS_IDENTIFIER_START[name.charCodeAt(0)]) {\n    return false;\n  }\n  for (let i = 1; i < name.length; i++) {\n    if (!IS_IDENTIFIER_CHAR[name.charCodeAt(i)]) {\n      return false;\n    }\n  }\n  return !RESERVED_WORDS.has(name);\n}\n", "import {TokenType as tt} from \"../parser/tokenizer/types\";\n\nimport isIdentifier from \"../util/isIdentifier\";\n\nimport Transformer from \"./Transformer\";\n\nexport default class TypeScriptTransformer extends Transformer {\n  constructor(\n     rootTransformer,\n     tokens,\n     isImportsTransformEnabled,\n  ) {\n    super();this.rootTransformer = rootTransformer;this.tokens = tokens;this.isImportsTransformEnabled = isImportsTransformEnabled;;\n  }\n\n  process() {\n    if (\n      this.rootTransformer.processPossibleArrowParamEnd() ||\n      this.rootTransformer.processPossibleAsyncArrowWithTypeParams() ||\n      this.rootTransformer.processPossibleTypeRange()\n    ) {\n      return true;\n    }\n    if (\n      this.tokens.matches1(tt._public) ||\n      this.tokens.matches1(tt._protected) ||\n      this.tokens.matches1(tt._private) ||\n      this.tokens.matches1(tt._abstract) ||\n      this.tokens.matches1(tt._readonly) ||\n      this.tokens.matches1(tt.nonNullAssertion)\n    ) {\n      this.tokens.removeInitialToken();\n      return true;\n    }\n    if (this.tokens.matches1(tt._enum) || this.tokens.matches2(tt._const, tt._enum)) {\n      this.processEnum();\n      return true;\n    }\n    if (\n      this.tokens.matches2(tt._export, tt._enum) ||\n      this.tokens.matches3(tt._export, tt._const, tt._enum)\n    ) {\n      this.processEnum(true);\n      return true;\n    }\n    return false;\n  }\n\n  processEnum(isExport = false) {\n    // We might have \"export const enum\", so just remove all relevant tokens.\n    this.tokens.removeInitialToken();\n    while (this.tokens.matches1(tt._const) || this.tokens.matches1(tt._enum)) {\n      this.tokens.removeToken();\n    }\n    const enumName = this.tokens.identifierName();\n    this.tokens.removeToken();\n    if (isExport && !this.isImportsTransformEnabled) {\n      this.tokens.appendCode(\"export \");\n    }\n    this.tokens.appendCode(`var ${enumName}; (function (${enumName})`);\n    this.tokens.copyExpectedToken(tt.braceL);\n    this.processEnumBody(enumName);\n    this.tokens.copyExpectedToken(tt.braceR);\n    if (isExport && this.isImportsTransformEnabled) {\n      this.tokens.appendCode(`)(${enumName} || (exports.${enumName} = ${enumName} = {}));`);\n    } else {\n      this.tokens.appendCode(`)(${enumName} || (${enumName} = {}));`);\n    }\n  }\n\n  /**\n   * Rather than try to compute the actual enum values at compile time, we just create variables for\n   * each one and let everything evaluate at runtime. There's some additional complexity due to\n   * handling string literal names, including ones that happen to be valid identifiers.\n   */\n  processEnumBody(enumName) {\n    let isPreviousValidIdentifier = false;\n    let lastValueReference = null;\n    while (true) {\n      if (this.tokens.matches1(tt.braceR)) {\n        break;\n      }\n      const nameToken = this.tokens.currentToken();\n      let name;\n      let nameStringCode;\n      if (nameToken.type === tt.name) {\n        name = this.tokens.identifierNameForToken(nameToken);\n        nameStringCode = `\"${name}\"`;\n      } else if (nameToken.type === tt.string) {\n        name = this.tokens.stringValueForToken(nameToken);\n        nameStringCode = this.tokens.code.slice(nameToken.start, nameToken.end);\n      } else {\n        throw new Error(\"Expected name or string at beginning of enum element.\");\n      }\n      const isValidIdentifier = isIdentifier(name);\n      this.tokens.removeInitialToken();\n\n      let valueIsString;\n      let valueCode;\n\n      if (this.tokens.matches1(tt.eq)) {\n        const rhsEndIndex = this.tokens.currentToken().rhsEndIndex;\n        if (rhsEndIndex == null) {\n          throw new Error(\"Expected rhsEndIndex on enum assign.\");\n        }\n        this.tokens.removeToken();\n        if (\n          this.tokens.matches2(tt.string, tt.comma) ||\n          this.tokens.matches2(tt.string, tt.braceR)\n        ) {\n          valueIsString = true;\n        }\n        const startToken = this.tokens.currentToken();\n        while (this.tokens.currentIndex() < rhsEndIndex) {\n          this.tokens.removeToken();\n        }\n        valueCode = this.tokens.code.slice(\n          startToken.start,\n          this.tokens.tokenAtRelativeIndex(-1).end,\n        );\n      } else {\n        valueIsString = false;\n        if (lastValueReference != null) {\n          if (isPreviousValidIdentifier) {\n            valueCode = `${lastValueReference} + 1`;\n          } else {\n            valueCode = `(${lastValueReference}) + 1`;\n          }\n        } else {\n          valueCode = \"0\";\n        }\n      }\n      if (this.tokens.matches1(tt.comma)) {\n        this.tokens.removeToken();\n      }\n\n      let valueReference;\n      if (isValidIdentifier) {\n        this.tokens.appendCode(`const ${name} = ${valueCode}; `);\n        valueReference = name;\n      } else {\n        valueReference = valueCode;\n      }\n\n      if (valueIsString) {\n        this.tokens.appendCode(`${enumName}[${nameStringCode}] = ${valueReference};`);\n      } else {\n        this.tokens.appendCode(\n          `${enumName}[${enumName}[${nameStringCode}] = ${valueReference}] = ${nameStringCode};`,\n        );\n      }\n      lastValueReference = valueReference;\n      isPreviousValidIdentifier = isValidIdentifier;\n    }\n  }\n}\n", "\n\n\nimport {ContextualKeyword} from \"../parser/tokenizer/keywords\";\nimport {TokenType as tt} from \"../parser/tokenizer/types\";\n\nimport getClassInfo, {} from \"../util/getClassInfo\";\nimport CJSImportTransformer from \"./CJSImportTransformer\";\nimport ESMImportTransformer from \"./ESMImportTransformer\";\nimport FlowTransformer from \"./FlowTransformer\";\nimport JSXTransformer from \"./JSXTransformer\";\nimport NumericSeparatorTransformer from \"./NumericSeparatorTransformer\";\nimport OptionalCatchBindingTransformer from \"./OptionalCatchBindingTransformer\";\nimport OptionalChainingNullishTransformer from \"./OptionalChainingNullishTransformer\";\nimport ReactDisplayNameTransformer from \"./ReactDisplayNameTransformer\";\nimport ReactHotLoaderTransformer from \"./ReactHotLoaderTransformer\";\n\nimport TypeScriptTransformer from \"./TypeScriptTransformer\";\n\nexport default class RootTransformer {\n   __init() {this.transformers = []}\n  \n  \n   __init2() {this.generatedVariables = []}\n  \n  \n  \n\n  constructor(\n    sucraseContext,\n    transforms,\n    enableLegacyBabel5ModuleInterop,\n    options,\n  ) {;RootTransformer.prototype.__init.call(this);RootTransformer.prototype.__init2.call(this);\n    this.nameManager = sucraseContext.nameManager;\n    this.helperManager = sucraseContext.helperManager;\n    const {tokenProcessor, importProcessor} = sucraseContext;\n    this.tokens = tokenProcessor;\n    this.isImportsTransformEnabled = transforms.includes(\"imports\");\n    this.isReactHotLoaderTransformEnabled = transforms.includes(\"react-hot-loader\");\n\n    this.transformers.push(\n      new OptionalChainingNullishTransformer(tokenProcessor, this.nameManager),\n    );\n    this.transformers.push(new NumericSeparatorTransformer(tokenProcessor));\n    this.transformers.push(new OptionalCatchBindingTransformer(tokenProcessor, this.nameManager));\n    if (transforms.includes(\"jsx\")) {\n      this.transformers.push(\n        new JSXTransformer(this, tokenProcessor, importProcessor, this.nameManager, options),\n      );\n      this.transformers.push(\n        new ReactDisplayNameTransformer(this, tokenProcessor, importProcessor, options),\n      );\n    }\n\n    let reactHotLoaderTransformer = null;\n    if (transforms.includes(\"react-hot-loader\")) {\n      if (!options.filePath) {\n        throw new Error(\"filePath is required when using the react-hot-loader transform.\");\n      }\n      reactHotLoaderTransformer = new ReactHotLoaderTransformer(tokenProcessor, options.filePath);\n      this.transformers.push(reactHotLoaderTransformer);\n    }\n\n    // Note that we always want to enable the imports transformer, even when the import transform\n    // itself isn't enabled, since we need to do type-only import pruning for both Flow and\n    // TypeScript.\n    if (transforms.includes(\"imports\")) {\n      if (importProcessor === null) {\n        throw new Error(\"Expected non-null importProcessor with imports transform enabled.\");\n      }\n      this.transformers.push(\n        new CJSImportTransformer(\n          this,\n          tokenProcessor,\n          importProcessor,\n          this.nameManager,\n          reactHotLoaderTransformer,\n          enableLegacyBabel5ModuleInterop,\n          transforms.includes(\"typescript\"),\n        ),\n      );\n    } else {\n      this.transformers.push(\n        new ESMImportTransformer(\n          tokenProcessor,\n          this.nameManager,\n          reactHotLoaderTransformer,\n          transforms.includes(\"typescript\"),\n          options,\n        ),\n      );\n    }\n\n    if (transforms.includes(\"flow\")) {\n      this.transformers.push(new FlowTransformer(this, tokenProcessor));\n    }\n    if (transforms.includes(\"typescript\")) {\n      this.transformers.push(\n        new TypeScriptTransformer(this, tokenProcessor, transforms.includes(\"imports\")),\n      );\n    }\n  }\n\n  transform() {\n    this.tokens.reset();\n    this.processBalancedCode();\n    const shouldAddUseStrict = this.isImportsTransformEnabled;\n    // \"use strict\" always needs to be first, so override the normal transformer order.\n    let prefix = shouldAddUseStrict ? '\"use strict\";' : \"\";\n    for (const transformer of this.transformers) {\n      prefix += transformer.getPrefixCode();\n    }\n    prefix += this.helperManager.emitHelpers();\n    prefix += this.generatedVariables.map((v) => ` var ${v};`).join(\"\");\n    let suffix = \"\";\n    for (const transformer of this.transformers) {\n      suffix += transformer.getSuffixCode();\n    }\n    let code = this.tokens.finish();\n    if (code.startsWith(\"#!\")) {\n      let newlineIndex = code.indexOf(\"\\n\");\n      if (newlineIndex === -1) {\n        newlineIndex = code.length;\n        code += \"\\n\";\n      }\n      return code.slice(0, newlineIndex + 1) + prefix + code.slice(newlineIndex + 1) + suffix;\n    } else {\n      return prefix + this.tokens.finish() + suffix;\n    }\n  }\n\n  processBalancedCode() {\n    let braceDepth = 0;\n    let parenDepth = 0;\n    while (!this.tokens.isAtEnd()) {\n      if (this.tokens.matches1(tt.braceL) || this.tokens.matches1(tt.dollarBraceL)) {\n        braceDepth++;\n      } else if (this.tokens.matches1(tt.braceR)) {\n        if (braceDepth === 0) {\n          return;\n        }\n        braceDepth--;\n      }\n      if (this.tokens.matches1(tt.parenL)) {\n        parenDepth++;\n      } else if (this.tokens.matches1(tt.parenR)) {\n        if (parenDepth === 0) {\n          return;\n        }\n        parenDepth--;\n      }\n      this.processToken();\n    }\n  }\n\n  processToken() {\n    if (this.tokens.matches1(tt._class)) {\n      this.processClass();\n      return;\n    }\n    for (const transformer of this.transformers) {\n      const wasProcessed = transformer.process();\n      if (wasProcessed) {\n        return;\n      }\n    }\n    this.tokens.copyToken();\n  }\n\n  /**\n   * Skip past a class with a name and return that name.\n   */\n  processNamedClass() {\n    if (!this.tokens.matches2(tt._class, tt.name)) {\n      throw new Error(\"Expected identifier for exported class name.\");\n    }\n    const name = this.tokens.identifierNameAtIndex(this.tokens.currentIndex() + 1);\n    this.processClass();\n    return name;\n  }\n\n  processClass() {\n    const classInfo = getClassInfo(this, this.tokens, this.nameManager);\n\n    // Both static and instance initializers need a class name to use to invoke the initializer, so\n    // assign to one if necessary.\n    const needsCommaExpression =\n      classInfo.headerInfo.isExpression &&\n      classInfo.staticInitializerNames.length + classInfo.instanceInitializerNames.length > 0;\n\n    let className = classInfo.headerInfo.className;\n    if (needsCommaExpression) {\n      className = this.nameManager.claimFreeName(\"_class\");\n      this.generatedVariables.push(className);\n      this.tokens.appendCode(` (${className} =`);\n    }\n\n    const classToken = this.tokens.currentToken();\n    const contextId = classToken.contextId;\n    if (contextId == null) {\n      throw new Error(\"Expected class to have a context ID.\");\n    }\n    this.tokens.copyExpectedToken(tt._class);\n    while (!this.tokens.matchesContextIdAndLabel(tt.braceL, contextId)) {\n      this.processToken();\n    }\n\n    this.processClassBody(classInfo, className);\n\n    const staticInitializerStatements = classInfo.staticInitializerNames.map(\n      (name) => `${className}.${name}()`,\n    );\n    if (needsCommaExpression) {\n      this.tokens.appendCode(\n        `, ${staticInitializerStatements.map((s) => `${s}, `).join(\"\")}${className})`,\n      );\n    } else if (classInfo.staticInitializerNames.length > 0) {\n      this.tokens.appendCode(` ${staticInitializerStatements.map((s) => `${s};`).join(\" \")}`);\n    }\n  }\n\n  /**\n   * We want to just handle class fields in all contexts, since TypeScript supports them. Later,\n   * when some JS implementations support class fields, this should be made optional.\n   */\n  processClassBody(classInfo, className) {\n    const {\n      headerInfo,\n      constructorInsertPos,\n      constructorInitializerStatements,\n      fields,\n      instanceInitializerNames,\n      rangesToRemove,\n    } = classInfo;\n    let fieldIndex = 0;\n    let rangeToRemoveIndex = 0;\n    const classContextId = this.tokens.currentToken().contextId;\n    if (classContextId == null) {\n      throw new Error(\"Expected non-null context ID on class.\");\n    }\n    this.tokens.copyExpectedToken(tt.braceL);\n    if (this.isReactHotLoaderTransformEnabled) {\n      this.tokens.appendCode(\n        \"__reactstandin__regenerateByEval(key, code) {this[key] = eval(code);}\",\n      );\n    }\n\n    const needsConstructorInit =\n      constructorInitializerStatements.length + instanceInitializerNames.length > 0;\n\n    if (constructorInsertPos === null && needsConstructorInit) {\n      const constructorInitializersCode = this.makeConstructorInitCode(\n        constructorInitializerStatements,\n        instanceInitializerNames,\n        className,\n      );\n      if (headerInfo.hasSuperclass) {\n        const argsName = this.nameManager.claimFreeName(\"args\");\n        this.tokens.appendCode(\n          `constructor(...${argsName}) { super(...${argsName}); ${constructorInitializersCode}; }`,\n        );\n      } else {\n        this.tokens.appendCode(`constructor() { ${constructorInitializersCode}; }`);\n      }\n    }\n\n    while (!this.tokens.matchesContextIdAndLabel(tt.braceR, classContextId)) {\n      if (fieldIndex < fields.length && this.tokens.currentIndex() === fields[fieldIndex].start) {\n        let needsCloseBrace = false;\n        if (this.tokens.matches1(tt.bracketL)) {\n          this.tokens.copyTokenWithPrefix(`${fields[fieldIndex].initializerName}() {this`);\n        } else if (this.tokens.matches1(tt.string) || this.tokens.matches1(tt.num)) {\n          this.tokens.copyTokenWithPrefix(`${fields[fieldIndex].initializerName}() {this[`);\n          needsCloseBrace = true;\n        } else {\n          this.tokens.copyTokenWithPrefix(`${fields[fieldIndex].initializerName}() {this.`);\n        }\n        while (this.tokens.currentIndex() < fields[fieldIndex].end) {\n          if (needsCloseBrace && this.tokens.currentIndex() === fields[fieldIndex].equalsIndex) {\n            this.tokens.appendCode(\"]\");\n          }\n          this.processToken();\n        }\n        this.tokens.appendCode(\"}\");\n        fieldIndex++;\n      } else if (\n        rangeToRemoveIndex < rangesToRemove.length &&\n        this.tokens.currentIndex() === rangesToRemove[rangeToRemoveIndex].start\n      ) {\n        this.tokens.removeInitialToken();\n        while (this.tokens.currentIndex() < rangesToRemove[rangeToRemoveIndex].end) {\n          this.tokens.removeToken();\n        }\n        rangeToRemoveIndex++;\n      } else if (this.tokens.currentIndex() === constructorInsertPos) {\n        this.tokens.copyToken();\n        if (needsConstructorInit) {\n          this.tokens.appendCode(\n            `;${this.makeConstructorInitCode(\n              constructorInitializerStatements,\n              instanceInitializerNames,\n              className,\n            )};`,\n          );\n        }\n        this.processToken();\n      } else {\n        this.processToken();\n      }\n    }\n    this.tokens.copyExpectedToken(tt.braceR);\n  }\n\n  makeConstructorInitCode(\n    constructorInitializerStatements,\n    instanceInitializerNames,\n    className,\n  ) {\n    return [\n      ...constructorInitializerStatements,\n      ...instanceInitializerNames.map((name) => `${className}.prototype.${name}.call(this)`),\n    ].join(\";\");\n  }\n\n  /**\n   * Normally it's ok to simply remove type tokens, but we need to be more careful when dealing with\n   * arrow function return types since they can confuse the parser. In that case, we want to move\n   * the close-paren to the same line as the arrow.\n   *\n   * See https://github.com/alangpierce/sucrase/issues/391 for more details.\n   */\n  processPossibleArrowParamEnd() {\n    if (this.tokens.matches2(tt.parenR, tt.colon) && this.tokens.tokenAtRelativeIndex(1).isType) {\n      let nextNonTypeIndex = this.tokens.currentIndex() + 1;\n      // Look ahead to see if this is an arrow function or something else.\n      while (this.tokens.tokens[nextNonTypeIndex].isType) {\n        nextNonTypeIndex++;\n      }\n      if (this.tokens.matches1AtIndex(nextNonTypeIndex, tt.arrow)) {\n        this.tokens.removeInitialToken();\n        while (this.tokens.currentIndex() < nextNonTypeIndex) {\n          this.tokens.removeToken();\n        }\n        this.tokens.replaceTokenTrimmingLeftWhitespace(\") =>\");\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * An async arrow function might be of the form:\n   *\n   * async <\n   *   T\n   * >() => {}\n   *\n   * in which case, removing the type parameters will cause a syntax error. Detect this case and\n   * move the open-paren earlier.\n   */\n  processPossibleAsyncArrowWithTypeParams() {\n    if (\n      !this.tokens.matchesContextual(ContextualKeyword._async) &&\n      !this.tokens.matches1(tt._async)\n    ) {\n      return false;\n    }\n    const nextToken = this.tokens.tokenAtRelativeIndex(1);\n    if (nextToken.type !== tt.lessThan || !nextToken.isType) {\n      return false;\n    }\n\n    let nextNonTypeIndex = this.tokens.currentIndex() + 1;\n    // Look ahead to see if this is an arrow function or something else.\n    while (this.tokens.tokens[nextNonTypeIndex].isType) {\n      nextNonTypeIndex++;\n    }\n    if (this.tokens.matches1AtIndex(nextNonTypeIndex, tt.parenL)) {\n      this.tokens.replaceToken(\"async (\");\n      this.tokens.removeInitialToken();\n      while (this.tokens.currentIndex() < nextNonTypeIndex) {\n        this.tokens.removeToken();\n      }\n      this.tokens.removeToken();\n      // We ate a ( token, so we need to process the tokens in between and then the ) token so that\n      // we remain balanced.\n      this.processBalancedCode();\n      this.processToken();\n      return true;\n    }\n    return false;\n  }\n\n  processPossibleTypeRange() {\n    if (this.tokens.currentToken().isType) {\n      this.tokens.removeInitialToken();\n      while (this.tokens.currentToken().isType) {\n        this.tokens.removeToken();\n      }\n      return true;\n    }\n    return false;\n  }\n}\n", "var LF = '\\n';\nvar CR = '\\r';\nvar LinesAndColumns = (function () {\n    function LinesAndColumns(string) {\n        this.string = string;\n        var offsets = [0];\n        for (var offset = 0; offset < string.length;) {\n            switch (string[offset]) {\n                case LF:\n                    offset += LF.length;\n                    offsets.push(offset);\n                    break;\n                case CR:\n                    offset += CR.length;\n                    if (string[offset] === LF) {\n                        offset += LF.length;\n                    }\n                    offsets.push(offset);\n                    break;\n                default:\n                    offset++;\n                    break;\n            }\n        }\n        this.offsets = offsets;\n    }\n    LinesAndColumns.prototype.locationForIndex = function (index) {\n        if (index < 0 || index > this.string.length) {\n            return null;\n        }\n        var line = 0;\n        var offsets = this.offsets;\n        while (offsets[line + 1] <= index) {\n            line++;\n        }\n        var column = index - offsets[line];\n        return { line: line, column: column };\n    };\n    LinesAndColumns.prototype.indexForLocation = function (location) {\n        var line = location.line, column = location.column;\n        if (line < 0 || line >= this.offsets.length) {\n            return null;\n        }\n        if (column < 0 || column > this.lengthOfLine(line)) {\n            return null;\n        }\n        return this.offsets[line] + column;\n    };\n    LinesAndColumns.prototype.lengthOfLine = function (line) {\n        var offset = this.offsets[line];\n        var nextOffset = line === this.offsets.length - 1 ? this.string.length : this.offsets[line + 1];\n        return nextOffset - offset;\n    };\n    return LinesAndColumns;\n}());\nexport default LinesAndColumns;\n", "import LinesAndColumns from \"lines-and-columns\";\n\nimport {formatTokenType} from \"../parser/tokenizer/types\";\n\nexport default function formatTokens(code, tokens) {\n  if (tokens.length === 0) {\n    return \"\";\n  }\n\n  const tokenKeys = Object.keys(tokens[0]).filter(\n    (k) => k !== \"type\" && k !== \"value\" && k !== \"start\" && k !== \"end\" && k !== \"loc\",\n  );\n  const typeKeys = Object.keys(tokens[0].type).filter((k) => k !== \"label\" && k !== \"keyword\");\n\n  const headings = [\"Location\", \"Label\", \"Raw\", ...tokenKeys, ...typeKeys];\n\n  const lines = new LinesAndColumns(code);\n  const rows = [headings, ...tokens.map(getTokenComponents)];\n  const padding = headings.map(() => 0);\n  for (const components of rows) {\n    for (let i = 0; i < components.length; i++) {\n      padding[i] = Math.max(padding[i], components[i].length);\n    }\n  }\n  return rows\n    .map((components) => components.map((component, i) => component.padEnd(padding[i])).join(\" \"))\n    .join(\"\\n\");\n\n  function getTokenComponents(token) {\n    const raw = code.slice(token.start, token.end);\n    return [\n      formatRange(token.start, token.end),\n      formatTokenType(token.type),\n      truncate(String(raw), 14),\n      ...tokenKeys.map((key) => formatValue(token[key], key)),\n      ...typeKeys.map((key) => formatValue(token.type[key], key)),\n    ];\n  }\n\n  // tslint:disable-next-line no-any\n  function formatValue(value, key) {\n    if (value === true) {\n      return key;\n    } else if (value === false || value === null) {\n      return \"\";\n    } else {\n      return String(value);\n    }\n  }\n\n  function formatRange(start, end) {\n    return `${formatPos(start)}-${formatPos(end)}`;\n  }\n\n  function formatPos(pos) {\n    const location = lines.locationForIndex(pos);\n    if (!location) {\n      return \"Unknown\";\n    } else {\n      return `${location.line + 1}:${location.column + 1}`;\n    }\n  }\n}\n\nfunction truncate(s, length) {\n  if (s.length > length) {\n    return `${s.slice(0, length - 3)}...`;\n  } else {\n    return s;\n  }\n}\n", "import {ContextualKeyword} from \"../parser/tokenizer/keywords\";\nimport {TokenType as tt} from \"../parser/tokenizer/types\";\n\n\n/**\n * Special case code to scan for imported names in ESM TypeScript. We need to do this so we can\n * properly get globals so we can compute shadowed globals.\n *\n * This is similar to logic in CJSImportProcessor, but trimmed down to avoid logic with CJS\n * replacement and flow type imports.\n */\nexport default function getTSImportedNames(tokens) {\n  const importedNames = new Set();\n  for (let i = 0; i < tokens.tokens.length; i++) {\n    if (\n      tokens.matches1AtIndex(i, tt._import) &&\n      !tokens.matches3AtIndex(i, tt._import, tt.name, tt.eq)\n    ) {\n      collectNamesForImport(tokens, i, importedNames);\n    }\n  }\n  return importedNames;\n}\n\nfunction collectNamesForImport(\n  tokens,\n  index,\n  importedNames,\n) {\n  index++;\n\n  if (tokens.matches1AtIndex(index, tt.parenL)) {\n    // Dynamic import, so nothing to do\n    return;\n  }\n\n  if (tokens.matches1AtIndex(index, tt.name)) {\n    importedNames.add(tokens.identifierNameAtIndex(index));\n    index++;\n    if (tokens.matches1AtIndex(index, tt.comma)) {\n      index++;\n    }\n  }\n\n  if (tokens.matches1AtIndex(index, tt.star)) {\n    // * as\n    index += 2;\n    importedNames.add(tokens.identifierNameAtIndex(index));\n    index++;\n  }\n\n  if (tokens.matches1AtIndex(index, tt.braceL)) {\n    index++;\n    collectNamesForNamedImport(tokens, index, importedNames);\n  }\n}\n\nfunction collectNamesForNamedImport(\n  tokens,\n  index,\n  importedNames,\n) {\n  while (true) {\n    if (tokens.matches1AtIndex(index, tt.braceR)) {\n      return;\n    }\n\n    // We care about the local name, which might be the first token, or if there's an \"as\", is the\n    // one after that.\n    let name = tokens.identifierNameAtIndex(index);\n    index++;\n    if (tokens.matchesContextualAtIndex(index, ContextualKeyword._as)) {\n      index++;\n      name = tokens.identifierNameAtIndex(index);\n      index++;\n    }\n    importedNames.add(name);\n    if (tokens.matches2AtIndex(index, tt.comma, tt.braceR)) {\n      return;\n    } else if (tokens.matches1AtIndex(index, tt.braceR)) {\n      return;\n    } else if (tokens.matches1AtIndex(index, tt.comma)) {\n      index++;\n    } else {\n      throw new Error(`Unexpected token: ${JSON.stringify(tokens.tokens[index])}`);\n    }\n  }\n}\n", "import CJSImportProcessor from \"./CJSImportProcessor\";\nimport computeSourceMap, {} from \"./computeSourceMap\";\nimport {HelperManager} from \"./HelperManager\";\nimport identifyShadowedGlobals from \"./identifyShadowedGlobals\";\nimport NameManager from \"./NameManager\";\nimport {validateOptions} from \"./Options\";\nimport {parse} from \"./parser\";\n\nimport TokenProcessor from \"./TokenProcessor\";\nimport RootTransformer from \"./transformers/RootTransformer\";\nimport formatTokens from \"./util/formatTokens\";\nimport getTSImportedNames from \"./util/getTSImportedNames\";\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nexport function getVersion() {\n  // eslint-disable-next-line\n  return require(\"../package.json\").version;\n}\n\nexport function transform(code, options) {\n  validateOptions(options);\n  try {\n    const sucraseContext = getSucraseContext(code, options);\n    const transformer = new RootTransformer(\n      sucraseContext,\n      options.transforms,\n      Boolean(options.enableLegacyBabel5ModuleInterop),\n      options,\n    );\n    let result = {code: transformer.transform()};\n    if (options.sourceMapOptions) {\n      if (!options.filePath) {\n        throw new Error(\"filePath must be specified when generating a source map.\");\n      }\n      result = {\n        ...result,\n        sourceMap: computeSourceMap(result.code, options.filePath, options.sourceMapOptions),\n      };\n    }\n    return result;\n  } catch (e) {\n    if (options.filePath) {\n      e.message = `Error transforming ${options.filePath}: ${e.message}`;\n    }\n    throw e;\n  }\n}\n\n/**\n * Return a string representation of the sucrase tokens, mostly useful for\n * diagnostic purposes.\n */\nexport function getFormattedTokens(code, options) {\n  const tokens = getSucraseContext(code, options).tokenProcessor.tokens;\n  return formatTokens(code, tokens);\n}\n\n/**\n * Call into the parser/tokenizer and do some further preprocessing:\n * - Come up with a set of used names so that we can assign new names.\n * - Preprocess all import/export statements so we know which globals we are interested in.\n * - Compute situations where any of those globals are shadowed.\n *\n * In the future, some of these preprocessing steps can be skipped based on what actual work is\n * being done.\n */\nfunction getSucraseContext(code, options) {\n  const isJSXEnabled = options.transforms.includes(\"jsx\");\n  const isTypeScriptEnabled = options.transforms.includes(\"typescript\");\n  const isFlowEnabled = options.transforms.includes(\"flow\");\n  const file = parse(code, isJSXEnabled, isTypeScriptEnabled, isFlowEnabled);\n  const tokens = file.tokens;\n  const scopes = file.scopes;\n\n  const nameManager = new NameManager(code, tokens);\n  const helperManager = new HelperManager(nameManager);\n  const tokenProcessor = new TokenProcessor(code, tokens, isFlowEnabled, helperManager);\n  const enableLegacyTypeScriptModuleInterop = Boolean(options.enableLegacyTypeScriptModuleInterop);\n\n  let importProcessor = null;\n  if (options.transforms.includes(\"imports\")) {\n    importProcessor = new CJSImportProcessor(\n      nameManager,\n      tokenProcessor,\n      enableLegacyTypeScriptModuleInterop,\n      options,\n      options.transforms.includes(\"typescript\"),\n      helperManager,\n    );\n    importProcessor.preprocessTokens();\n    // We need to mark shadowed globals after processing imports so we know that the globals are,\n    // but before type-only import pruning, since that relies on shadowing information.\n    identifyShadowedGlobals(tokenProcessor, scopes, importProcessor.getGlobalNames());\n    if (options.transforms.includes(\"typescript\")) {\n      importProcessor.pruneTypeOnlyImports();\n    }\n  } else if (options.transforms.includes(\"typescript\")) {\n    identifyShadowedGlobals(tokenProcessor, scopes, getTSImportedNames(tokenProcessor));\n  }\n  return {tokenProcessor, scopes, nameManager, importProcessor, helperManager};\n}\n", "import type { Plugin } from '@velcro/bundler';\nimport { Options, transform } from 'sucrase';\n\nexport interface SucrasePluginOptions\n  extends Partial<Pick<Options, 'jsxFragmentPragma' | 'jsxPragma' | 'transforms'>> {}\n\nexport function sucrasePlugin(options: SucrasePluginOptions = {}): Plugin {\n  const extensions = ['js'];\n\n  if (options.transforms) {\n    for (const transform of options.transforms) {\n      switch (transform) {\n        case 'jsx':\n          extensions.push('jsx');\n          break;\n        case 'typescript':\n          extensions.push('ts', 'tsx');\n          break;\n      }\n    }\n  }\n\n  const uriTestRx = new RegExp(`\\.(?:${extensions.join('|')})$`, 'i');\n\n  const jsxPragmaRx = /\\/\\*\\*\\s*@jsx\\s+(\\S+)\\s*\\*+\\//;\n  const jsxFragmentPragmaRx = /\\/\\*\\*\\s*@jsxFragment\\s+(\\S+)\\s*\\*+\\//;\n\n  return {\n    name: 'sucrasePlugin',\n    transform(ctx, uri, code) {\n      if (!uriTestRx.test(uri.path)) {\n        return;\n      }\n\n      const sucraseOptions: Options = {\n        transforms: ['imports', ...(options.transforms || [])],\n        filePath: uri.toString(),\n        production: ctx.nodeEnv === 'production',\n        sourceMapOptions: {\n          compiledFilename: uri.toString(),\n        },\n      };\n\n      if (!options.jsxPragma) {\n        // If not specified try to detect the pragma\n        const jsxPragmaMatches = code.match(jsxPragmaRx);\n        if (jsxPragmaMatches) {\n          sucraseOptions.jsxPragma = jsxPragmaMatches[1];\n        }\n      }\n\n      if (!options.jsxFragmentPragma) {\n        // If not specified try to detect the pragma\n        const jsxFragmentPragmaMatches = code.match(jsxFragmentPragmaRx);\n        if (jsxFragmentPragmaMatches) {\n          sucraseOptions.jsxFragmentPragma = jsxFragmentPragmaMatches[1];\n        }\n      }\n\n      const result = transform(code, sucraseOptions);\n\n      return {\n        code: result.code,\n        sourceMap: result.sourceMap,\n      };\n    },\n  };\n}\n", "export const version = '__VERSION__';\nexport * from './sucrase';\n", "const SPEC_RX = /^((@[^/]+\\/[^/@]+|[^./@][^/@]*)(?:@([^/]+))?)(.*)?$/;\n\ntype _BareModuleSpec<T = ReturnType<typeof parseBareModuleSpec>> = T extends null | undefined\n  ? never\n  : T;\nexport type BareModuleSpec = _BareModuleSpec;\n\nexport function parseBareModuleSpec(bareModuleSpec: string) {\n  const matches = bareModuleSpec.match(SPEC_RX);\n\n  if (matches) {\n    const [, nameSpec, name, spec, path = ''] = matches;\n\n    return {\n      nameSpec,\n      name,\n      spec,\n      path,\n    };\n  }\n\n  return null;\n}\n", "import { version as nodeLibsVersion } from '@velcro/node-libs/package.json';\nimport { BareModuleSpec, parseBareModuleSpec } from './bareModules';\n\nexport const NODE_CORE_SHIMS: Record<string, BareModuleSpec | undefined> = Object.assign(\n  Object.create(null),\n  {\n    string_decoder: parseBareModuleSpec('string_decoder@1.2.0'),\n    punycode: parseBareModuleSpec('punycode@2.1.1'),\n  }\n);\n\nfor (const name of [\n  'assert',\n  'buffer',\n  'constants',\n  'crypto',\n  'events',\n  'fs',\n  'http',\n  'https',\n  'net',\n  'os',\n  'path',\n  'process',\n  'querystring',\n  'stream',\n  'tls',\n  'url',\n  'util',\n  'vm',\n  'zlib',\n]) {\n  NODE_CORE_SHIMS[name] = parseBareModuleSpec(\n    `@velcro/node-libs@${nodeLibsVersion}/lib/${name}.js`\n  )!;\n}\n", "import type { Thenable, Uri } from '@velcro/common';\nimport type { ResolverContext } from './context';\nimport type { Resolver } from './resolver';\n\ntype MaybeThenable<T> = T | Thenable<T>;\n\nexport interface ResolverStrategy {\n  /**\n   * Produce a url given the components of a bare module specifier.\n   *\n   * @param ctx A `ResolverContext` that should be used for making calls to other strategy methods\n   * @param name The name of a bare module\n   * @param spec The optional `@version` of a bare module specifier\n   * @param path The optional path at the end of the bare module specifier\n   */\n  getUrlForBareModule?(\n    ctx: ResolverContext,\n    name: string,\n    spec: string,\n    path: string\n  ): MaybeThenable<ResolverStrategy.BareModuleResult>;\n\n  /**\n   * Determine the canonical uri for a given uri.\n   *\n   * For example, you might consider symlink targets their canonicalized path or you might\n   * consider the canonicalized path of https://unpkg.com/react to be\n   * https://unpkg.com/react@16.13.1/index.js.\n   *\n   * Dealing only in canonical uris means that anything produced from those can be cached.\n   *\n   * @param ctx A `ResolverContext` that should be used for making calls to other strategy methods\n   * @param uri The uri to canonicalize\n   */\n  getCanonicalUrl(\n    ctx: ResolverContext,\n    uri: Uri\n  ): MaybeThenable<ResolverStrategy.CanonicalizeResult>;\n\n  /**\n   * Get the logical resolve root for a given uri.\n   *\n   * For example, a filesystem-based strategy might consider the root to be `file:///`. Or,\n   * if it was scoped to /home/filearts, the root might be `file:///home/filearts/`.\n   *\n   * Any uri that is not a 'child' of the resolve root should be considered out of scope for a given\n   * strategy.\n   *\n   * @param ctx A `ResolverContext` that should be used for making calls to other strategy methods\n   * @param uri The uri for which the logical resolve root uri should be found\n   */\n  getResolveRoot(ctx: ResolverContext, uri: Uri): MaybeThenable<ResolverStrategy.ResolveRootResult>;\n\n  /**\n   * Get the settings for a given uri\n   *\n   * This indirection allows resolver strategies to have per-strategy or even per-uri settings.\n   *\n   * @param ctx A `ResolverContext` that should be used for making calls to other strategy methods\n   * @param uri The uri for which to load settings\n   */\n  getSettings(ctx: ResolverContext, uri: Uri): MaybeThenable<ResolverStrategy.SettingsResult>;\n\n  /**\n   * Produce a list of resolved entries that are direct children of the given uri.\n   *\n   * This is the moral equivalent to something like non-recursive `fs.readdir()`. It is only\n   * designed to show files and folders (for now).\n   *\n   * @param ctx A `ResolverContext` that should be used for making calls to other strategy methods\n   * @param uri The uri at which to list entries\n   */\n  listEntries(ctx: ResolverContext, uri: Uri): MaybeThenable<ResolverStrategy.ListEntriesResult>;\n\n  /**\n   * Read the content at the uri as an `ArrayBuffer`\n   *\n   * ArrayBuffers are the lowest-common-denominator across the web and node and can easily be\n   * decoded with standard web apis like `StringDecoder`. In Node.js, `Buffer` objects are also\n   * `ArrayBuffer`s, allowing the tooling to be built on that primitive.\n   *\n   * This is helpful for the understanding that not all uris are expected to produce meaningful\n   * text representations.\n   *\n   * @param ctx A `ResolverContext` that should be used for making calls to other strategy methods\n   * @param uri The uri at which to read the content\n   */\n  readFileContent(\n    ctx: ResolverContext,\n    uri: Uri\n  ): MaybeThenable<ResolverStrategy.ReadFileContentResult>;\n}\n\nexport interface ResolverStrategyWithRoot extends ResolverStrategy {\n  /**\n   * The root uri of the strategy.\n   *\n   * A common parent to all uris that this strategy can handle.\n   *\n   * This may sometimes be the same value as would be returned by `getResolveRoot` but will\n   * sometimes be a parent of that. Take, for example Unpkg; there, we may want to express\n   * that a strategy should 'own' all uris under https://unpkg.com/ even though the resolve\n   * root for https://unpkg.com/react@16.13.1/index.js will actually be\n   * https://unpkg.com/react@16.13.1/.\n   *\n   * Notably, the `CompoundResolverStrategy` requires all child strategies implement the\n   * `ResolverStrategyWithRoot` interface because it dispatches operations on different\n   * uris according to each strategy's `rootUri`.\n   */\n  rootUri: Uri;\n}\n\nexport namespace ResolverStrategy {\n  export enum EntryKind {\n    File = 'file',\n    Directory = 'directory',\n  }\n\n  export interface Entry<TKind extends EntryKind = EntryKind> {\n    uri: Uri;\n    type: TKind;\n  }\n\n  export type BareModuleResult = {\n    found: boolean;\n    uri: Uri | null;\n  };\n\n  export interface CanonicalizeResult {\n    uri: Uri;\n  }\n\n  export interface ResolveRootResult {\n    uri: Uri;\n  }\n\n  export interface SettingsResult {\n    settings: Resolver.Settings;\n  }\n\n  export interface ListEntriesResult {\n    entries: Entry[];\n  }\n\n  export interface ReadFileContentResult {\n    content: ArrayBuffer;\n  }\n}\n\nexport abstract class AbstractResolverStrategy implements ResolverStrategy {\n  getCanonicalUrl(\n    _ctx: ResolverContext,\n    uri: Uri\n  ): ReturnType<ResolverStrategy['getCanonicalUrl']> {\n    return {\n      uri,\n    };\n  }\n\n  getSettings(ctx: ResolverContext, _uri: Uri): ReturnType<ResolverStrategy['getSettings']> {\n    return {\n      settings: ctx.settings,\n    };\n  }\n\n  /**\n   * Create a new ResolverStrategy having one or more methods overridden.\n   *\n   * You might use this if you want to override specific behaviour of another strategy without\n   * wanting to re-implement the whole strategy.\n   *\n   * If you need to invoke an overridden method, the overridden strategy will be available\n   * on `this.parent`.\n   *\n   * @param overrides A map of ResolverStrategy methods that you would like to override\n   */\n  withOverrides(\n    overrides: {\n      [TMethodName in keyof ResolverStrategy]?: ResolverStrategy[TMethodName];\n    }\n  ): ResolverStrategy {\n    const strategy = { ...overrides, parent: this };\n\n    return Object.setPrototypeOf(Object.assign(Object.create(null), strategy), this);\n  }\n\n  abstract getResolveRoot(\n    ctx: ResolverContext,\n    uri: Uri\n  ): ReturnType<ResolverStrategy['getResolveRoot']>;\n  abstract listEntries(ctx: ResolverContext, uri: Uri): ReturnType<ResolverStrategy['listEntries']>;\n  abstract readFileContent(\n    ctx: ResolverContext,\n    uri: Uri\n  ): ReturnType<ResolverStrategy['readFileContent']>;\n}\n\nexport abstract class AbstractResolverStrategyWithRoot extends AbstractResolverStrategy\n  implements ResolverStrategyWithRoot {\n  constructor(readonly rootUri: Uri) {\n    super();\n  }\n}\n", "import {\n  all,\n  Awaited,\n  basename,\n  CanceledError,\n  CancellationToken,\n  CancellationTokenSource,\n  checkCancellation,\n  Decoder,\n  DependencyNotFoundError,\n  dirname,\n  EntryExcludedError,\n  EntryNotFoundError,\n  isThenable,\n  MapSet,\n  PackageJson,\n  parseBufferAsPackageJson,\n  parseBufferAsPartialPackageJson,\n  PartialPackageJson,\n  Thenable,\n  Uri,\n} from '@velcro/common';\nimport { BareModuleSpec, parseBareModuleSpec } from './bareModules';\nimport type { Resolver } from './resolver';\nimport { NODE_CORE_SHIMS } from './shims';\nimport { ResolverStrategy } from './strategy';\n\ntype ReturnTypeWithVisits<\n  T extends (...args: any[]) => any,\n  TReturn = ReturnType<T>\n> = TReturn extends Thenable<infer U>\n  ? Promise<U & { visited: ResolverContext.Visit[] }>\n  : TReturn & { visited: ResolverContext.Visit[] };\n\n// type UncachedReturnType<T> = { [K in keyof T] : K extends typeof CACHE ? never : T[K] };\n// type UncachedReturn<\n//   T extends (...any: any[]) => any,\n//   TReturn = ReturnType<T>\n// > = TReturn extends Thenable<infer U>\n//   ? Thenable<UncachedReturnType<U>>\n//   : UncachedReturnType<TReturn>;\n\nconst CACHE = Symbol('Context.cache');\n\ntype InvalidationRecord = {\n  cacheKey: string;\n  operationCache: Map<string, unknown>;\n};\n\ntype ResolveResult =\n  | {\n      found: false;\n      uri: null;\n      parentPackageJson?: { packageJson: PackageJson; uri: Uri };\n    }\n  | {\n      found: true;\n      uri: null;\n      parentPackageJson?: { packageJson: PackageJson; uri: Uri };\n      rootUri: Uri;\n    }\n  | {\n      found: true;\n      uri: Uri;\n      parentPackageJson?: { packageJson: PackageJson; uri: Uri };\n      rootUri: Uri;\n    };\n\ntype ReadParentPackageJsonResultInternal =\n  | {\n      found: true;\n      packageJson: PackageJson;\n      uri: Uri;\n      visitedDirs: Uri[];\n    }\n  | {\n      found: false;\n      packageJson: null;\n      uri: null;\n    };\n\ntype StrategyResult<T> =\n  | Promise<T & { visited: ResolverContext.Visit[] }>\n  | (T & { visited: ResolverContext.Visit[] });\n\nclass Visits {\n  private readonly parent?: Visits;\n  private readonly visits = [] as ResolverContext.Visit[];\n\n  constructor(readonly uri: { toString(): string }, parent?: Visits) {\n    this.parent = parent;\n  }\n\n  child(uri: { toString(): string }): Visits {\n    return new Visits(uri, this);\n  }\n\n  push(visit: ResolverContext.Visit) {\n    if (!this.visits.find((cmp) => cmp.type == visit.type && Uri.equals(cmp.uri, visit.uri))) {\n      this.visits.push(visit);\n      if (this.parent) {\n        this.parent.push(visit);\n      }\n    }\n  }\n\n  toArray(): ResolverContext.Visit[] {\n    return this.parent ? this.parent.toArray() : this.visits.slice();\n  }\n}\n\nexport class ResolverContext {\n  static create(\n    resolver: Resolver,\n    strategy: ResolverStrategy,\n    settings: Resolver.Settings,\n    token: CancellationToken,\n    options: { debug?: boolean } = {}\n  ) {\n    return new ResolverContext({\n      cache: new Map(),\n      cacheInvalidations: new MapSet(),\n      debug: !!options.debug,\n      decoder: new Decoder(),\n      path: [],\n      resolver,\n      settings,\n      strategy,\n      token,\n      visits: new Visits(Uri.parse('velcro:/root')),\n    });\n  }\n\n  private readonly cache: ResolverContext.Options['cache'];\n  private readonly cacheInvalidations: ResolverContext.Options['cacheInvalidations'];\n  private readonly debugMode: boolean;\n  readonly decoder: ResolverContext.Options['decoder'];\n  private readonly mapResultWithVisits = <T>(result: T) =>\n    Object.assign(result, { visited: this.visits.toArray() });\n  readonly path: ReadonlyArray<string>;\n  private readonly resolver: ResolverContext.Options['resolver'];\n  readonly settings: Readonly<ResolverContext.Options['settings']>;\n  private readonly strategy: ResolverContext.Options['strategy'];\n  private readonly tokenSource: CancellationTokenSource;\n  private readonly visits: Visits;\n\n  protected constructor(options: ResolverContext.Options) {\n    this.cache = options.cache;\n    this.cacheInvalidations = options.cacheInvalidations;\n    this.debugMode = options.debug;\n    this.decoder = options.decoder;\n    this.path = options.path;\n    this.resolver = options.resolver;\n    this.settings = options.settings;\n    this.strategy = options.strategy;\n    this.tokenSource = new CancellationTokenSource(options.token);\n    this.visits = options.visits;\n  }\n\n  get token() {\n    return this.tokenSource.token;\n  }\n\n  get visited() {\n    return this.visits.toArray();\n  }\n\n  dispose() {\n    this.tokenSource.dispose(true);\n  }\n\n  forOperation(\n    operationName: string,\n    uri: { toString(): string },\n    options: { resetPath?: boolean; resetVisits?: boolean } = {}\n  ) {\n    const encodedOperation = encodePathNode(operationName, uri);\n\n    if (this.path.includes(encodedOperation)) {\n      const formattedPath = this.path\n        .map((segment) => {\n          const { operationName, uri } = decodePathNode(segment);\n\n          return `${operationName}(${uri.toString()})`;\n        })\n        .join(' -> ');\n\n      throw this._wrapError(\n        new Error(\n          `Detected a recursive call to the operation '${operationName}' for '${uri.toString()}' at path '${formattedPath}'`\n        )\n      );\n    }\n\n    return new ResolverContext({\n      cache: this.cache,\n      cacheInvalidations: this.cacheInvalidations,\n      debug: this.debugMode,\n      decoder: this.decoder,\n      path: options.resetPath ? [] : this.path.concat(encodedOperation),\n      resolver: this.resolver,\n      settings: this.settings,\n      strategy: this.strategy,\n      token: this.tokenSource.token,\n      visits: options.resetVisits ? new Visits(uri) : this.visits.child(uri),\n    });\n  }\n\n  getCanonicalUrl(uri: Uri): StrategyResult<ResolverStrategy.CanonicalizeResult> {\n    const method = this.strategy.getCanonicalUrl;\n    const receiver = this.strategy;\n    const operationName = 'Strategy.getCanonicalUrl';\n    const href = uri.toString();\n\n    return this.runInChildContext(operationName, uri, (ctx) =>\n      ctx.runWithCache(operationName, href, method, receiver, ctx, uri)\n    );\n  }\n\n  getResolveRoot(uri: Uri): StrategyResult<ResolverStrategy.ResolveRootResult> {\n    const method = this.strategy.getResolveRoot;\n    const receiver = this.strategy;\n    const operationName = 'Strategy.getResolveRoot';\n    const href = uri.toString();\n\n    return this.runInChildContext(operationName, uri, (ctx) =>\n      ctx.runWithCache(operationName, href, method, receiver, ctx, uri)\n    );\n  }\n\n  getSettings(uri: Uri): StrategyResult<ResolverStrategy.SettingsResult> {\n    const method = this.strategy.getSettings;\n    const receiver = this.strategy;\n    const operationName = 'Strategy.getSettings';\n    const href = uri.toString();\n\n    return this.runInChildContext(operationName, uri, (ctx) =>\n      ctx.runWithCache(operationName, href, method, receiver, ctx, uri)\n    );\n  }\n\n  getUrlForBareModule(\n    name: string,\n    spec: string,\n    path: string\n  ): StrategyResult<ResolverStrategy.BareModuleResult> {\n    const method = this.strategy.getUrlForBareModule;\n\n    if (!method) {\n      return Promise.reject(\n        new Error(\n          `Unable to resolve bare module spec '${name}@${spec}${path}' because no strategy was found that supports resolving bare modules`\n        )\n      );\n    }\n\n    const receiver = this.strategy;\n    const operationName = 'Strategy.getUrlForBareModule';\n    const href = `${name}@${spec}${path}`;\n\n    return this.runInChildContext(operationName, href, (ctx) =>\n      ctx.runWithCache(operationName, href, method, receiver, ctx, name, spec, path)\n    );\n  }\n\n  invalidate(uri: Uri) {\n    const href = uri.toString();\n    const invalidations = this.cacheInvalidations.get(href);\n    let invalidated = false;\n\n    if (invalidations) {\n      for (const { cacheKey, operationCache } of invalidations) {\n        invalidated = operationCache.delete(cacheKey) || invalidated;\n      }\n    }\n\n    this.cacheInvalidations.deleteAll(href);\n\n    return invalidated;\n  }\n\n  listEntries(uri: Uri): StrategyResult<ResolverStrategy.ListEntriesResult> {\n    const method = this.strategy.listEntries;\n    const receiver = this.strategy;\n    const operationName = 'Strategy.listEntries';\n    const href = uri.toString();\n\n    return this.runInChildContext(operationName, uri, (ctx) =>\n      ctx.runWithCache(operationName, href, method, receiver, ctx, uri)\n    );\n  }\n\n  readFileContent(uri: Uri): StrategyResult<ResolverStrategy.ReadFileContentResult> {\n    const method = this.strategy.readFileContent;\n    const receiver = this.strategy;\n    const operationName = 'Strategy.readFileContent';\n    const href = uri.toString();\n\n    this.recordVisit(uri, ResolverContext.VisitKind.File);\n\n    return this.runInChildContext(operationName, uri, (ctx) =>\n      ctx.runWithCache(operationName, href, method, receiver, ctx, uri)\n    );\n  }\n\n  readParentPackageJson(uri: Uri): StrategyResult<ReadParentPackageJsonResultInternal> {\n    return this.runWithCache(\n      'readParentPackageJson',\n      uri.toString(),\n      readParentPackageJson,\n      null,\n      this,\n      uri\n    );\n  }\n\n  recordVisit(uri: Uri, type: ResolverContext.VisitKind = ResolverContext.VisitKind.File) {\n    this.visits.push({ type, uri });\n  }\n\n  resolve(spec: string, fromUri: Uri): StrategyResult<ResolveResult> {\n    const method = resolveDependency;\n    const receiver = null;\n    const operationName = 'resolve';\n    const href = `${fromUri}|${spec}`;\n\n    return this.runInChildContext(operationName, href, (ctx) =>\n      ctx.runWithCache(operationName, href, method, receiver, ctx, fromUri, spec)\n    );\n  }\n\n  resolveUri(uri: Uri): StrategyResult<ResolveResult> {\n    const method = resolve;\n    const receiver = null;\n    const operationName = 'resolveUri';\n    const href = uri.toString();\n\n    return this.runInChildContext(operationName, uri, (ctx) =>\n      ctx.runWithCache(operationName, href, method, receiver, ctx, uri)\n    );\n  }\n\n  runInChildContext<T>(\n    operationName: string,\n    uri: { toString(): string },\n    contextFn: (ctx: ResolverContext) => T\n  ): T {\n    return this.runInContext(\n      operationName,\n      uri,\n      { resetPath: false, resetVisits: false },\n      contextFn\n    );\n  }\n\n  runInIsolatedContext<T>(\n    operationName: string,\n    uri: { toString(): string },\n    contextFn: (ctx: ResolverContext) => T\n  ): T {\n    return this.runInContext(operationName, uri, { resetPath: true, resetVisits: true }, contextFn);\n  }\n\n  private runInContext<T>(\n    operationName: string,\n    uri: { toString(): string },\n    options: { resetPath: boolean; resetVisits: boolean },\n    contextFn: (ctx: ResolverContext) => T\n  ) {\n    const ctx = this.forOperation(operationName, uri, options);\n\n    ctx.debug('%s(%s)', operationName, uri.toString());\n\n    return contextFn(ctx);\n  }\n\n  private createStoreResultFn<TMethod extends (...args: any[]) => any>(\n    operationCache: Map<string, ReturnTypeWithVisits<TMethod>>,\n    cacheKey: string\n  ) {\n    return (result: ReturnTypeWithVisits<TMethod>) => {\n      const mappedResult = this.mapResultWithVisits(result);\n      const visited = mappedResult.visited as ResolverContext.Visit[];\n\n      if (mappedResult[CACHE]) {\n        const cacheEntries = mappedResult[CACHE] as [string, ReturnTypeWithVisits<TMethod>][];\n        delete mappedResult[CACHE];\n\n        for (const [cacheKey, value] of cacheEntries) {\n          operationCache.set(cacheKey, value);\n\n          for (const visit of visited) {\n            this.cacheInvalidations.add(visit.uri.toString(), { cacheKey, operationCache });\n          }\n        }\n      }\n\n      // Override the pending value with the resolved value\n      operationCache.set(cacheKey, mappedResult);\n\n      for (const visit of visited) {\n        this.cacheInvalidations.add(visit.uri.toString(), { cacheKey, operationCache });\n      }\n\n      return mappedResult;\n    };\n  }\n\n  private runWithCache<TMethod extends (...args: any[]) => any>(\n    cacheSegment: string,\n    cacheKey: string,\n    fn: TMethod,\n    target: unknown,\n    ...args: Parameters<TMethod>\n  ): ReturnTypeWithVisits<TMethod> {\n    let operationCache = this.cache.get(cacheSegment) as\n      | Map<string, ReturnTypeWithVisits<TMethod>>\n      | undefined;\n\n    if (!operationCache) {\n      operationCache = new Map();\n      this.cache.set(cacheSegment, operationCache);\n    }\n\n    const cached = operationCache.get(cacheKey);\n\n    if (cached) {\n      this.debug('%s(%s) [HIT]', cacheSegment, cacheKey);\n\n      // We either have a cached result or a cached promise for a result. Either way, the value\n      // is suitable as a return.\n      return cached;\n    }\n\n    const cacheResult = this.createStoreResultFn(operationCache, cacheKey);\n\n    this.debug('%s(%s) [MISS]', cacheSegment, cacheKey);\n\n    // Nothing is cached\n    const ret = fn.apply(target, args);\n\n    if (isThenable(ret)) {\n      const promiseRet = ret as Thenable<ReturnTypeWithVisits<TMethod>>;\n\n      // Produce a promise that will only be settled once the cache has been updated accordingly.\n      const wrappedRet = promiseRet.then(cacheResult, (err) => {\n        // Delete the entry from the cache in case it was a transient failure\n        operationCache!.delete(cacheKey);\n\n        return Promise.reject(err);\n      });\n\n      // Set the pending value in the cache for now\n      operationCache.set(cacheKey, wrappedRet as Awaited<Thenable<ReturnTypeWithVisits<TMethod>>>);\n\n      return wrappedRet as Awaited<Thenable<ReturnTypeWithVisits<TMethod>>>;\n    }\n\n    return cacheResult(ret);\n  }\n\n  private _wrapError<T extends Error>(\n    err: T\n  ): T & { path: { operationName: string; uri: Uri | string }[] } {\n    return Object.assign(err, {\n      path: this.path.map(decodePathNode),\n    });\n  }\n\n  debug(...args: Parameters<Console['warn']>) {\n    if (this.debugMode) {\n      if (typeof args[0] === 'string') {\n        args[0] = ' '.repeat(this.path.length) + args[0];\n      }\n      console.warn(...args);\n    }\n  }\n}\n\nfunction encodePathNode(operationName: string, uri: { toString(): string }) {\n  return `${operationName}:${uri.toString()}`;\n}\n\nfunction decodePathNode(node: string) {\n  const parts = node.split(':', 2);\n\n  if (parts.length !== 2) {\n    console.log('WTF', { node, parts });\n    throw new Error(`Invariant violation: Unexpected path node: '${node}'`);\n  }\n\n  return {\n    operationName: parts[0],\n    uri: parts[1].includes(':') ? Uri.parse(parts[1]) : parts[1],\n  };\n}\n\nasync function resolve(ctx: ResolverContext, uri: Uri): Promise<ResolveResult> {\n  const bothResolved = all(\n    [ctx.getCanonicalUrl(uri), ctx.getResolveRoot(uri), ctx.getSettings(uri)],\n    ctx.token\n  );\n\n  const [canonicalizationResult, resolveRootResult, settingsResult] = isThenable(bothResolved)\n    ? await checkCancellation(bothResolved, ctx.token)\n    : bothResolved;\n\n  const rootUri = resolveRootResult.uri;\n  const rootUriWithoutTrailingSlash = Uri.ensureTrailingSlash(rootUri, '');\n\n  if (!Uri.isPrefixOf(rootUriWithoutTrailingSlash, canonicalizationResult.uri)) {\n    throw new Error(\n      `Unable to resolve a module whose path ${canonicalizationResult.uri.toString(\n        true\n      )} is above the host's root ${rootUri.toString()}`\n    );\n  }\n\n  const resolveReturn =\n    Uri.equals(rootUriWithoutTrailingSlash, canonicalizationResult.uri) ||\n    Uri.equals(rootUri, canonicalizationResult.uri)\n      ? ctx.runInChildContext('resolveAsDirectory', canonicalizationResult.uri, (ctx) =>\n          resolveAsDirectory(\n            ctx,\n            Uri.ensureTrailingSlash(canonicalizationResult.uri),\n            resolveRootResult.uri,\n            settingsResult.settings\n          )\n        )\n      : ctx.runInChildContext('resolveAsFile', canonicalizationResult.uri, (ctx) =>\n          resolveAsFile(\n            ctx,\n            canonicalizationResult.uri,\n            resolveRootResult.uri,\n            settingsResult.settings,\n            null\n          )\n        );\n  const readParentPackageJsonReturn = ctx.readParentPackageJson(uri);\n  const resolveAndPackageJson = all([resolveReturn, readParentPackageJsonReturn], ctx.token);\n  const [resolveResult, readParentPackageJsonResult] = isThenable(resolveAndPackageJson)\n    ? await resolveAndPackageJson\n    : resolveAndPackageJson;\n\n  return {\n    ...resolveResult,\n    parentPackageJson: readParentPackageJsonResult.found\n      ? {\n          packageJson: readParentPackageJsonResult.packageJson,\n          uri: readParentPackageJsonResult.uri,\n        }\n      : undefined,\n  };\n}\n\nasync function resolveDependency(ctx: ResolverContext, fromUri: Uri, spec: string) {\n  const parsedSpec = parseBareModuleSpec(spec);\n\n  if (parsedSpec) {\n    return ctx.runInChildContext('resolveBareModule', fromUri, (ctx) =>\n      resolveBareModule(ctx, fromUri, parsedSpec)\n    );\n  }\n\n  const relativeUri = Uri.joinPath(\n    Uri.from({\n      ...fromUri,\n      path: dirname(fromUri.path),\n    }),\n    spec\n  );\n\n  return ctx.runInChildContext('resolveUri', relativeUri, (ctx) => resolve(ctx, relativeUri));\n}\n\nasync function resolveBareModule(ctx: ResolverContext, uri: Uri, parsedSpec: BareModuleSpec) {\n  let locatorName = parsedSpec.name;\n  let locatorSpec = parsedSpec.spec;\n  let locatorPath = parsedSpec.path;\n\n  if (!locatorSpec) {\n    const resolveRootReturn = ctx.getResolveRoot(uri);\n    const resolveRootResult = isThenable(resolveRootReturn)\n      ? await checkCancellation(resolveRootReturn, ctx.token)\n      : resolveRootReturn;\n\n    let nextUri = uri;\n    let maxIterations = 10;\n\n    while (Uri.isPrefixOf(resolveRootResult.uri, nextUri)) {\n      if (--maxIterations <= 0) {\n        throw new Error('Max iterations reached');\n      }\n\n      const parentPackageJsonReturn = ctx.readParentPackageJson(uri);\n      const parentPackageJsonResult = isThenable(parentPackageJsonReturn)\n        ? await checkCancellation(parentPackageJsonReturn, ctx.token)\n        : parentPackageJsonReturn;\n\n      if (!parentPackageJsonResult.found) {\n        throw new DependencyNotFoundError(parsedSpec.nameSpec, uri);\n      }\n      ctx.recordVisit(parentPackageJsonResult.uri, ResolverContext.VisitKind.File);\n\n      if (parentPackageJsonResult.packageJson.name === parsedSpec.name) {\n        // We found a parent directory that *IS* the module we're looking for\n        const directoryUri = Uri.ensureTrailingSlash(\n          Uri.joinPath(parentPackageJsonResult.uri, '../')\n        );\n        return ctx.runInChildContext('resolveAsDirectory', directoryUri, (ctx) =>\n          resolveAsDirectory(ctx, directoryUri, resolveRootResult.uri, ctx.settings)\n        );\n      }\n\n      const dependencies = {\n        ...(parentPackageJsonResult.packageJson.devDependencies || {}),\n        ...(parentPackageJsonResult.packageJson.peerDependencies || {}),\n        ...(parentPackageJsonResult.packageJson.dependencies || {}),\n      };\n\n      locatorSpec = dependencies[parsedSpec.name];\n\n      if (locatorSpec) {\n        break;\n      }\n\n      nextUri = Uri.joinPath(parentPackageJsonResult.uri, '..');\n\n      if (Uri.equals(nextUri, resolveRootResult.uri)) {\n        break;\n      }\n    }\n  }\n\n  if (!locatorSpec) {\n    const builtIn = NODE_CORE_SHIMS[parsedSpec.name];\n\n    if (builtIn) {\n      locatorName = builtIn.name;\n      locatorSpec = builtIn.spec;\n      locatorPath = builtIn.path;\n    }\n  }\n\n  if (!locatorSpec) {\n    throw new DependencyNotFoundError(parsedSpec.nameSpec, uri);\n  }\n\n  const bareModuleUriReturn = ctx.getUrlForBareModule(locatorName, locatorSpec, locatorPath);\n  const bareModuleUriResult = isThenable(bareModuleUriReturn)\n    ? await checkCancellation(bareModuleUriReturn, ctx.token)\n    : bareModuleUriReturn;\n\n  if (!bareModuleUriResult.found) {\n    throw new DependencyNotFoundError(parsedSpec.nameSpec, uri);\n  }\n\n  if (!bareModuleUriResult.uri) {\n    // TODO: Inject empty module\n    throw new EntryExcludedError(parsedSpec.nameSpec);\n  }\n\n  const resolveReturn = ctx.resolveUri(bareModuleUriResult.uri);\n  const resolveResult = isThenable(resolveReturn)\n    ? await checkCancellation(resolveReturn, ctx.token)\n    : resolveReturn;\n\n  return resolveResult;\n}\nexport namespace ResolverContext {\n  export interface Options {\n    cache: Map<string, Map<string, unknown>>;\n    cacheInvalidations: MapSet<string, InvalidationRecord>;\n    debug: boolean;\n    decoder: Decoder;\n    path: string[];\n    resolver: Resolver;\n    settings: Resolver.Settings;\n    strategy: ResolverStrategy;\n    token: CancellationToken;\n    visits: Visits;\n  }\n\n  export enum VisitKind {\n    Directory = 'Directory',\n    File = 'File',\n  }\n\n  export type Visit =\n    | {\n        type: VisitKind.Directory;\n        uri: Uri;\n      }\n    | {\n        type: VisitKind.File;\n        uri: Uri;\n      };\n}\n\nasync function resolveAsDirectory(\n  ctx: ResolverContext,\n  uri: Uri,\n  rootUri: Uri,\n  settings: Resolver.Settings\n): Promise<ResolveResult> {\n  ctx.recordVisit(uri, ResolverContext.VisitKind.Directory);\n\n  const listEntriesReturn = ctx.listEntries(uri);\n  const listEntriesResult = isThenable(listEntriesReturn)\n    ? await checkCancellation(listEntriesReturn, ctx.token)\n    : listEntriesReturn;\n\n  let mainPathname = 'index';\n\n  // Step 1: Look for a package.json with an main field\n  const packageJsonUri = Uri.joinPath(uri, './package.json');\n\n  ctx.recordVisit(packageJsonUri, ResolverContext.VisitKind.File);\n\n  const packageJsonEntry = listEntriesResult.entries.find(\n    (entry) =>\n      entry.type === ResolverStrategy.EntryKind.File && Uri.equals(packageJsonUri, entry.uri)\n  );\n\n  let packageJson: PartialPackageJson | null = null;\n\n  if (packageJsonEntry) {\n    const packageJsonContentReturn = ctx.readFileContent(packageJsonUri);\n    const packageJsonContentResult = isThenable(packageJsonContentReturn)\n      ? await checkCancellation(packageJsonContentReturn, ctx.token)\n      : packageJsonContentReturn;\n\n    packageJson = parseBufferAsPartialPackageJson(\n      ctx.decoder,\n      packageJsonContentResult.content,\n      uri.toString()\n    );\n\n    for (const packageMain of settings.packageMain) {\n      const pathname = packageJson[packageMain];\n      if (typeof pathname === 'string') {\n        mainPathname = pathname;\n        break;\n      }\n    }\n  }\n\n  const fileUri = Uri.joinPath(uri, mainPathname);\n\n  return ctx.runInChildContext('resolveAsFile', uri, (ctx) =>\n    resolveAsFile(ctx, fileUri, rootUri, settings, packageJson)\n  );\n}\n\nasync function resolveAsFile(\n  ctx: ResolverContext,\n  uri: Uri,\n  rootUri: Uri,\n  settings: Resolver.Settings,\n  packageJson: PartialPackageJson | null,\n  ignoreBrowserOverrides = false\n): Promise<ResolveResult> {\n  if (uri.path === '' || uri.path === '/') {\n    throw new TypeError(`Unable to resolve the root as a file: ${uri.toString()}`);\n  }\n\n  ctx.recordVisit(uri, ResolverContext.VisitKind.File);\n\n  const browserOverrides = new Map<string, Uri | false>();\n\n  if (packageJson === null) {\n    // The parent package.json is only interesting if we are going to look at the `browser`\n    // field and then consider browser mapping overrides in there.\n    const parentPackageJsonResult =\n      settings.packageMain.includes('browser') && !ignoreBrowserOverrides\n        ? await checkCancellation(\n            ctx.runInChildContext('readParentPackageJsonInternal', uri, (ctx) =>\n              readParentPackageJsonInternal(ctx, uri, rootUri, { uriIsCanonicalized: true })\n            ),\n            ctx.token\n          )\n        : undefined;\n    if (parentPackageJsonResult && parentPackageJsonResult.found) {\n      ctx.recordVisit(parentPackageJsonResult.uri, ResolverContext.VisitKind.File);\n\n      packageJson = parentPackageJsonResult.packageJson;\n\n      if (\n        parentPackageJsonResult.packageJson.browser &&\n        typeof parentPackageJsonResult.packageJson.browser === 'object'\n      ) {\n        const browserMap = parentPackageJsonResult.packageJson.browser;\n        const packageJsonDir = Uri.joinPath(parentPackageJsonResult.uri, '..');\n\n        for (const entry in browserMap) {\n          const impliedUri = Uri.joinPath(packageJsonDir, entry);\n          const targetSpec = browserMap[entry];\n          const target = targetSpec === false ? false : Uri.joinPath(packageJsonDir, targetSpec);\n\n          if (Uri.equals(impliedUri, uri)) {\n            if (target === false) {\n              return {\n                found: false,\n                uri: null,\n              };\n            }\n\n            // console.warn('REMAPPED %s to %s', url, target);\n\n            // We found an exact match so let's make sure we resolve the re-mapped file but\n            // also that we don't go through the browser overrides rodeo again.\n            return ctx.runInChildContext('resolveAsFile', target, (ctx) =>\n              resolveAsFile(ctx, target, rootUri, settings, packageJson, true)\n            );\n          }\n\n          browserOverrides.set(impliedUri.toString(), target);\n        }\n      }\n    }\n  }\n\n  const containingDirUri = Uri.ensureTrailingSlash(Uri.joinPath(uri, '..'));\n\n  const filename = basename(uri.path);\n  const entriesReturn = ctx.listEntries(containingDirUri);\n  const entriesResult = isThenable(entriesReturn)\n    ? await checkCancellation(entriesReturn, ctx.token)\n    : entriesReturn;\n  const entryDirectoryMap = new Map<string, ResolverStrategy.Entry>();\n  const entryFileMap = new Map<string, ResolverStrategy.Entry<ResolverStrategy.EntryKind.File>>();\n\n  for (const entry of entriesResult.entries) {\n    if (Uri.equals(entry.uri, uri) && entry.type == ResolverStrategy.EntryKind.File) {\n      // Found an exact match\n      return {\n        found: true,\n        rootUri,\n        uri,\n      };\n    }\n\n    if (entry.type === ResolverStrategy.EntryKind.Directory) {\n      const childFilename = Uri.getFirstPathSegmentAfterPrefix(entry.uri, containingDirUri);\n\n      entryDirectoryMap.set(childFilename, entry);\n    } else if (entry.type === ResolverStrategy.EntryKind.File) {\n      const childFilename = basename(entry.uri.path);\n\n      entryFileMap.set(\n        childFilename,\n        entry as ResolverStrategy.Entry<ResolverStrategy.EntryKind.File>\n      );\n    }\n  }\n\n  // Look for browser overrides\n  for (const ext of settings.extensions) {\n    const hrefWithExtensionUri = uri.with({ path: `${uri.path}${ext}` });\n    const hrefWithExtension = hrefWithExtensionUri.toString();\n    const mapping = browserOverrides.get(hrefWithExtension);\n\n    ctx.recordVisit(hrefWithExtensionUri, ResolverContext.VisitKind.File);\n\n    if (mapping === false) {\n      // console.warn('REMAPPED %s to undefined', url);\n      return {\n        found: true,\n        rootUri,\n        uri: null,\n      };\n    } else if (mapping) {\n      // console.warn('REMAPPED %s to %s', url, mapping);\n\n      return ctx.runInChildContext('resolveAsFile', mapping, (ctx) =>\n        resolveAsFile(ctx, mapping, rootUri, settings, packageJson, true)\n      );\n    }\n\n    const match = entryFileMap.get(`${filename}${ext}`);\n    if (match) {\n      if (match.type !== ResolverStrategy.EntryKind.File) {\n        continue;\n      }\n\n      return {\n        found: true,\n        rootUri,\n        uri: match.uri,\n      };\n    }\n  }\n\n  // First, attempt to find a matching file or directory\n  const match = entryDirectoryMap.get(filename);\n  if (match) {\n    if (match.type !== ResolverStrategy.EntryKind.Directory) {\n      throw new Error(`Invariant violation ${match.type} is unexpected`);\n    }\n\n    return ctx.runInChildContext('resolveAsDirectory', match.uri, (ctx) =>\n      resolveAsDirectory(ctx, Uri.ensureTrailingSlash(match.uri), rootUri, settings)\n    );\n  }\n\n  throw new EntryNotFoundError(uri);\n}\n\nasync function readParentPackageJson(ctx: ResolverContext, uri: Uri) {\n  const canonicalizationReturn = ctx.getCanonicalUrl(uri);\n  const resolveRootReturn = ctx.getResolveRoot(uri);\n  const bothResolved = all([canonicalizationReturn, resolveRootReturn], ctx.token);\n  const [canonicalizationResult, resolveRootResult] = isThenable(bothResolved)\n    ? await checkCancellation(bothResolved, ctx.token)\n    : bothResolved;\n  const readReturn = ctx.runInChildContext(\n    'readParentPackageJsonInternal',\n    canonicalizationResult.uri,\n    (ctx) =>\n      readParentPackageJsonInternal(ctx, canonicalizationResult.uri, resolveRootResult.uri, {\n        uriIsCanonicalized: true,\n      })\n  );\n  const readResult = isThenable(readReturn) ? await readReturn : readReturn;\n\n  if (readResult.found && readResult.visitedDirs) {\n    const visitedDirs = readResult.visitedDirs;\n    delete readResult.visitedDirs;\n\n    (readResult as any)[CACHE] = visitedDirs.map((uri) => [uri.toString(), { ...readResult, uri }]);\n  }\n\n  return readResult as ReadParentPackageJsonResultInternal;\n}\n\nasync function readParentPackageJsonInternal(\n  ctx: ResolverContext,\n  uri: Uri,\n  rootUri: Uri,\n  options: { uriIsCanonicalized: boolean }\n): Promise<ReadParentPackageJsonResultInternal> {\n  if (!options.uriIsCanonicalized) {\n    const canonicalizationReturn = ctx.getCanonicalUrl(uri);\n    const canonicalizationResult = isThenable(canonicalizationReturn)\n      ? await checkCancellation(canonicalizationReturn, ctx.token)\n      : canonicalizationReturn;\n\n    uri = canonicalizationResult.uri;\n  }\n\n  const hostRootHref = Uri.ensureTrailingSlash(rootUri);\n  const containingDirUrl = Uri.ensureTrailingSlash(Uri.joinPath(uri, '..'));\n  const visitedDirs = [] as Uri[];\n\n  const readPackageJsonOrRecurse = async (\n    ctx: ResolverContext,\n    dir: Uri\n  ): Promise<ReadParentPackageJsonResultInternal> => {\n    if (!Uri.isPrefixOf(hostRootHref, dir)) {\n      // Terminal condition for recursion\n      return {\n        found: false,\n        packageJson: null,\n        uri: null,\n      };\n    }\n\n    ctx.recordVisit(dir, ResolverContext.VisitKind.Directory);\n\n    const entriesReturn = ctx.listEntries(dir);\n    const entriesResult = isThenable(entriesReturn)\n      ? await checkCancellation(entriesReturn, ctx.token)\n      : entriesReturn;\n    const packageJsonUri = Uri.joinPath(dir, 'package.json');\n    const packageJsonEntry = entriesResult.entries.find(\n      (entry) =>\n        entry.type === ResolverStrategy.EntryKind.File && Uri.equals(entry.uri, packageJsonUri)\n    );\n\n    ctx.recordVisit(packageJsonUri, ResolverContext.VisitKind.File);\n\n    if (packageJsonEntry) {\n      // Found! Let's try to parse\n      try {\n        const parentPackageJsonContentReturn = ctx.readFileContent(packageJsonUri);\n        const parentPackageJsonContentResult = isThenable(parentPackageJsonContentReturn)\n          ? await checkCancellation(parentPackageJsonContentReturn, ctx.token)\n          : parentPackageJsonContentReturn;\n\n        const packageJson = parseBufferAsPackageJson(\n          ctx.decoder,\n          parentPackageJsonContentResult.content,\n          packageJsonUri.toString()\n        );\n\n        return { found: true, packageJson, uri: packageJsonUri, visitedDirs };\n      } catch (err) {\n        if (err instanceof CanceledError || (err && err.name === 'CanceledError')) {\n          throw err;\n        }\n\n        // TODO: Maybe issue some warning?\n      }\n    }\n\n    // Not found here, let's try one up\n    const parentDir = Uri.ensureTrailingSlash(Uri.joinPath(dir, '..'));\n\n    // Skip infinite recursion\n    if (Uri.equals(dir, parentDir) || Uri.isPrefixOf(dir, parentDir)) {\n      return {\n        found: false,\n        packageJson: null,\n        uri: null,\n      };\n    }\n\n    visitedDirs.push(dir);\n\n    return ctx.runInChildContext('readPackageJsonOrRecurse', parentDir, (ctx) =>\n      readPackageJsonOrRecurse(ctx, parentDir)\n    );\n  };\n\n  if (Uri.equals(uri, containingDirUrl) || Uri.isPrefixOf(uri, containingDirUrl)) {\n    return {\n      found: false,\n      packageJson: null,\n      uri: null,\n    };\n  }\n  return ctx.runInChildContext('readPackageJsonOrRecurse', containingDirUrl, (ctx) =>\n    readPackageJsonOrRecurse(ctx, containingDirUrl)\n  );\n}\n", "import { CancellationTokenSource, PackageMainField, Uri } from '@velcro/common';\nimport { ResolverContext } from './context';\nimport type { ResolverStrategy } from './strategy';\n\nexport class Resolver {\n  private disposed = false;\n  readonly rootCtx: ResolverContext;\n  private readonly settings: Resolver.Settings;\n  private readonly strategy: ResolverStrategy;\n  private readonly tokenSource = new CancellationTokenSource();\n\n  constructor(strategy: ResolverStrategy, settings: Resolver.Settings) {\n    this.settings = settings;\n    this.strategy = strategy;\n    this.rootCtx = ResolverContext.create(\n      this,\n      this.strategy,\n      this.settings,\n      this.tokenSource.token,\n      { debug: settings.debug }\n    );\n  }\n\n  decode(buf: BufferSource | string): string {\n    if (typeof buf === 'string') {\n      return buf;\n    }\n\n    return this.rootCtx.decoder.decode(buf);\n  }\n\n  dispose() {\n    this.disposed = true;\n    return this.rootCtx.dispose();\n  }\n\n  getCanonicalUrl(uri: string | Uri) {\n    if (this.disposed) {\n      throw new Error('Resolver has been disposed');\n    }\n\n    return this.rootCtx.runInIsolatedContext('Resolver.getCanonicalUrl', uri, (ctx) =>\n      ctx.getCanonicalUrl(typeof uri === 'string' ? Uri.parse(uri) : uri)\n    );\n  }\n\n  getResolveRoot(uri: string | Uri) {\n    if (this.disposed) {\n      throw new Error('Resolver has been disposed');\n    }\n\n    return this.rootCtx.runInIsolatedContext('Resolver.getResolveRoot', uri, (ctx) =>\n      ctx.getResolveRoot(typeof uri === 'string' ? Uri.parse(uri) : uri)\n    );\n  }\n\n  getSettings(uri: string | Uri) {\n    if (this.disposed) {\n      throw new Error('Resolver has been disposed');\n    }\n\n    return this.rootCtx.runInIsolatedContext('Resolver.getSettings', uri, (ctx) =>\n      ctx.getSettings(typeof uri === 'string' ? Uri.parse(uri) : uri)\n    );\n  }\n\n  getUrlForBareModule(name: string, spec: string, path: string) {\n    if (this.disposed) {\n      throw new Error('Resolver has been disposed');\n    }\n\n    return this.rootCtx.runInIsolatedContext(\n      'Resolver.getUrlForBareModule',\n      `${name}|${spec}|${path}`,\n      (ctx) => ctx.getUrlForBareModule(name, spec, path)\n    );\n  }\n\n  invalidate(uri: string | Uri) {\n    if (this.disposed) {\n      throw new Error('Resolver has been disposed');\n    }\n\n    return this.rootCtx.runInIsolatedContext('Resolver.invalidate', uri, (ctx) =>\n      ctx.invalidate(typeof uri === 'string' ? Uri.parse(uri) : uri)\n    );\n  }\n\n  listEntries(uri: Uri) {\n    if (this.disposed) {\n      throw new Error('Resolver has been disposed');\n    }\n\n    return this.rootCtx.runInIsolatedContext('Resolver.listEntries', uri, (ctx) =>\n      ctx.listEntries(typeof uri === 'string' ? Uri.parse(uri) : uri)\n    );\n  }\n\n  readFileContent(uri: Uri) {\n    if (this.disposed) {\n      throw new Error('Resolver has been disposed');\n    }\n\n    return this.rootCtx.runInIsolatedContext('Resolver.readFileContent', uri, (ctx) =>\n      ctx.readFileContent(typeof uri === 'string' ? Uri.parse(uri) : uri)\n    );\n  }\n\n  readParentPackageJson(uri: Uri) {\n    if (this.disposed) {\n      throw new Error('Resolver has been disposed');\n    }\n\n    return this.rootCtx.runInIsolatedContext('Resolver.readParentPackageJson', uri, (ctx) =>\n      ctx.readParentPackageJson(typeof uri === 'string' ? Uri.parse(uri) : uri)\n    );\n  }\n\n  resolve(spec: Uri): ReturnType<ResolverContext['resolve']>;\n  resolve(spec: string, fromUri: Uri): ReturnType<ResolverContext['resolve']>;\n  resolve(spec: string | Uri, fromUri?: Uri): ReturnType<ResolverContext['resolve']> {\n    if (this.disposed) {\n      throw new Error('Resolver has been disposed');\n    }\n\n    if (Uri.isUri(spec)) {\n      return this.rootCtx.runInIsolatedContext('Resolver.resolveUri', spec, (ctx) =>\n        ctx.resolveUri(spec)\n      );\n    }\n\n    if (!fromUri) {\n      throw new Error(\n        'When calling Resolver.resolve with a string spec, a second \"fromUri\" argument is required'\n      );\n    }\n\n    return this.rootCtx.runInIsolatedContext(\n      'Resolver.resolve',\n      `${fromUri ? fromUri.toString() : ''}|${spec}`,\n      (ctx) => ctx.resolve(spec, fromUri)\n    );\n  }\n}\n\nexport namespace Resolver {\n  export interface Settings {\n    debug?: boolean;\n    extensions: string[];\n    packageMain: PackageMainField[];\n  }\n}\n", "export const version = '__VERSION__';\nexport * from './context';\nexport * from './resolver';\nexport * from './strategy';\n", "import {\n  all,\n  basename,\n  CancellationToken,\n  checkCancellation,\n  EntryNotFoundError,\n  isThenable,\n  PackageJson,\n  parseBufferAsPackageJson,\n  Thenable,\n  Uri,\n} from '@velcro/common';\nimport {\n  AbstractResolverStrategyWithRoot,\n  ResolverContext,\n  ResolverStrategy,\n  ResolverStrategyWithRoot,\n} from '@velcro/resolver';\nimport { satisfies, validRange } from 'semver';\n\ninterface AbstractCdn {\n  name: string;\n\n  isValidUrl(url: Uri): boolean;\n  normalizePackageListing(result: unknown): CdnStrategy.Directory;\n  parseUrl(url: Uri | string): CdnStrategy.Spec;\n  urlForPackageFile(spec: string, pathname: string): Uri;\n  urlForPackageList(spec: string): Uri;\n}\n\nfunction isValidEntry(entry: unknown): entry is CdnStrategy.Entry {\n  if (!entry || typeof entry !== 'object') return false;\n\n  return isValidFile(entry) || isValidDirectory(entry);\n}\n\nfunction isValidDirectory(entry: unknown): entry is CdnStrategy.Directory {\n  return (\n    typeof entry === 'object' &&\n    entry &&\n    (entry as any).type === ResolverStrategy.EntryKind.Directory &&\n    typeof (entry as any).path === 'string' &&\n    (entry as any).path &&\n    (typeof (entry as any).files === 'undefined' ||\n      (Array.isArray((entry as any).files) && (entry as any).files.every(isValidEntry)))\n  );\n}\n\nfunction isValidFile(entry: unknown): entry is File {\n  return (\n    typeof entry === 'object' &&\n    entry &&\n    (entry as any).type === ResolverStrategy.EntryKind.File &&\n    typeof (entry as any).path === 'string' &&\n    (entry as any).path\n  );\n}\n\nfunction specToString(spec: CdnStrategy.Spec) {\n  return `${spec.spec}${spec.pathname}`;\n}\n\nclass JSDelivrCdn implements AbstractCdn {\n  name = 'jsdelivr';\n\n  private readonly specRx = /^\\/((@[^/]+\\/[^/@]+|[^/@]+)(?:@([^/]+))?)(.*)?$/;\n\n  isValidUrl(url: Uri) {\n    return url.scheme === JSDelivrCdn.protocol || url.authority === JSDelivrCdn.host;\n  }\n\n  normalizePackageListing(result: unknown): CdnStrategy.Directory {\n    if (!result || typeof result !== 'object') {\n      throw new Error(`Unexpected package listing contents`);\n    }\n\n    const files = (result as any).files;\n\n    if (!Array.isArray(files)) {\n      throw new Error(`Unexpected package listing contents`);\n    }\n\n    const mapChildEntry = (parent: string, child: unknown): CdnStrategy.Entry => {\n      if (!child || typeof child !== 'object') {\n        throw new Error(`Unexpected entry in package listing contents`);\n      }\n\n      const name = (child as any).name;\n\n      if (typeof name !== 'string') {\n        throw new Error(`Unexpected entry in package listing contents`);\n      }\n\n      const path = `${parent}/${name}`;\n\n      if ((child as any).type === ResolverStrategy.EntryKind.Directory) {\n        const files = (child as any).files;\n\n        if (!Array.isArray(files)) {\n          throw new Error(`Unexpected entry in package listing contents`);\n        }\n        return {\n          type: ResolverStrategy.EntryKind.Directory,\n          path,\n          files: files.map((file) => mapChildEntry(path, file)),\n        };\n      } else if ((child as any).type === ResolverStrategy.EntryKind.File) {\n        return {\n          type: ResolverStrategy.EntryKind.File,\n          path,\n        };\n      }\n\n      throw new Error(`Error mapping child entry in package file listing`);\n    };\n\n    return {\n      type: ResolverStrategy.EntryKind.Directory,\n      path: '/',\n      files: files.map((file) => mapChildEntry('', file)),\n    };\n  }\n\n  parseUrl(url: Uri | string) {\n    if (Uri.isUri(url)) {\n      url = url.path;\n    }\n\n    const prefix = `/npm`;\n\n    if (!url.startsWith(prefix)) {\n      throw new Error(`Unable to parse unexpected ${this.name} url: ${url}`);\n    }\n\n    url = url.slice(prefix.length);\n\n    /**\n     * 1: scope + name + version\n     * 2: scope + name\n     * 3: version?\n     * 4: pathname\n     */\n    const matches = url.match(this.specRx);\n\n    if (!matches) {\n      throw new Error(`Unable to parse unexpected unpkg url: ${url}`);\n    }\n\n    return {\n      spec: matches[1],\n      name: matches[2],\n      version: matches[3] || '',\n      pathname: matches[4] || '',\n    };\n  }\n\n  urlForPackageFile(spec: string, pathname: string): Uri {\n    return Uri.from({\n      scheme: JSDelivrCdn.protocol,\n      authority: JSDelivrCdn.host,\n      path: `/npm/${spec}${pathname}`,\n    });\n  }\n\n  urlForPackageList(spec: string): Uri {\n    return Uri.from({\n      scheme: JSDelivrCdn.protocol,\n      authority: JSDelivrCdn.dataHost,\n      path: `/v1/package/npm/${spec}/tree`,\n    });\n  }\n\n  static readonly protocol = 'https';\n  static readonly host = 'cdn.jsdelivr.net';\n  static readonly dataHost = 'data.jsdelivr.com';\n}\n\nclass UnpkgCdn implements AbstractCdn {\n  name = 'unpkg';\n\n  private readonly UNPKG_SPEC_RX = /^\\/((@[^/]+\\/[^/@]+|[^/@]+)(?:@([^/]+))?)(.*)?$/;\n\n  isValidUrl(url: Uri) {\n    return url.scheme === UnpkgCdn.protocol || url.authority === UnpkgCdn.host;\n  }\n\n  normalizePackageListing(result: unknown) {\n    if (!isValidDirectory(result)) {\n      throw new Error(`Error normalizing directory listing`);\n    }\n\n    return result;\n  }\n\n  parseUrl(url: Uri | string) {\n    if (Uri.isUri(url)) {\n      url = url.path;\n    }\n\n    /**\n     * 1: scope + name + version\n     * 2: scope + name\n     * 3: version?\n     * 4: pathname\n     */\n    const matches = url.match(this.UNPKG_SPEC_RX);\n\n    if (!matches) {\n      throw new Error(`Unable to parse unexpected unpkg url: ${url}`);\n    }\n\n    return {\n      spec: matches[1],\n      name: matches[2],\n      version: matches[3] || '',\n      pathname: matches[4] || '',\n    };\n  }\n\n  urlForPackageFile(spec: string, pathname: string): Uri {\n    return Uri.from({\n      scheme: UnpkgCdn.protocol,\n      authority: UnpkgCdn.host,\n      path: `/${spec}${pathname}`,\n    });\n  }\n\n  urlForPackageList(spec: string) {\n    return Uri.from({\n      scheme: UnpkgCdn.protocol,\n      authority: UnpkgCdn.host,\n      path: `/${spec}/`,\n      query: 'meta',\n    });\n  }\n\n  static readonly protocol = 'https';\n  static readonly host = 'unpkg.com';\n}\n\nexport namespace CdnStrategy {\n  export type Spec = {\n    spec: string;\n    name: string;\n    version: string;\n    pathname: string;\n  };\n\n  export type Directory = {\n    type: ResolverStrategy.EntryKind.Directory;\n    path: string;\n    files?: ReadonlyArray<Entry>;\n  };\n  export type File = {\n    type: ResolverStrategy.EntryKind.File;\n    path: string;\n  };\n  export type Entry = Directory | File;\n\n  export type UrlContentFetcher = (\n    href: string,\n    token: CancellationToken\n  ) => Thenable<ArrayBuffer | null>;\n}\n\nexport class CdnStrategy extends AbstractResolverStrategyWithRoot\n  implements ResolverStrategyWithRoot {\n  private readonly cdn: AbstractCdn;\n  private readonly contentCache = new Map<\n    string,\n    null | { content: ArrayBuffer } | Thenable<{ content: ArrayBuffer }>\n  >();\n  private readonly locks = new Map<string, unknown | Thenable<unknown>>();\n  private readonly packageEntriesCache = new Map<string, Map<string, CdnStrategy.Directory>>();\n  private readonly packageJsonCache = new Map<\n    string,\n    Map<string, { packageJson: PackageJson; visited: ResolverContext.Visit[] }>\n  >();\n  private readonly readUrlFn: CdnStrategy.UrlContentFetcher;\n\n  private constructor(readUrlFn: CdnStrategy.UrlContentFetcher, cdn: AbstractCdn) {\n    super(cdn.urlForPackageFile('', ''));\n\n    this.cdn = cdn;\n    this.readUrlFn = readUrlFn;\n  }\n\n  private _withRootUriCheck<T extends unknown | Thenable<unknown>>(\n    uri: Uri,\n    fn: (rootUri: Uri) => T\n  ): T {\n    if (!Uri.isPrefixOf(this.rootUri, uri)) {\n      throw new Error(\n        `This strategy is only able to handle URIs under '${this.rootUri.toString()}' and is unable to handle '${uri.toString()}'`\n      );\n    }\n\n    return fn(this.rootUri);\n  }\n\n  async getUrlForBareModule(\n    ctx: ResolverContext,\n    name: string,\n    spec: string,\n    path: string\n  ): Promise<ResolverStrategy.BareModuleResult> {\n    const unresolvedUri = this.cdn.urlForPackageFile(`${name}@${spec}`, path);\n    const resolveReturn = await ctx.resolveUri(unresolvedUri);\n\n    return resolveReturn;\n  }\n\n  getCanonicalUrl(ctx: ResolverContext, uri: Uri): Promise<ResolverStrategy.CanonicalizeResult> {\n    return this._withRootUriCheck(uri, async () => {\n      const unresolvedSpec = this.cdn.parseUrl(uri);\n      const packageJsonReturn = ctx.runInChildContext(\n        'CdnStrategy._readPackageJsonWithCache',\n        specToString(unresolvedSpec),\n        (ctx) => this._readPackageJsonWithCache(ctx, unresolvedSpec)\n      );\n      const packageJson = isThenable(packageJsonReturn)\n        ? await packageJsonReturn\n        : packageJsonReturn;\n\n      return {\n        uri: this.cdn.urlForPackageFile(\n          `${packageJson.name}@${packageJson.version}`,\n          unresolvedSpec.pathname\n        ),\n      };\n    });\n    // const results = all([ctx.getRootUrl(uri), ctx.getResolveRoot(uri)], ctx.token);\n    // const [rootUriResult, resolveRootResult] = isThenable(results) ? await results : results;\n  }\n\n  getResolveRoot(ctx: ResolverContext, uri: Uri): Promise<ResolverStrategy.ResolveRootResult> {\n    return this._withRootUriCheck(uri, async () => {\n      const unresolvedSpec = this.cdn.parseUrl(uri);\n      const packageJsonReturn = this._readPackageJsonWithCache(ctx, unresolvedSpec);\n      const packageJson = isThenable(packageJsonReturn)\n        ? await packageJsonReturn\n        : packageJsonReturn;\n\n      return {\n        uri: this.cdn.urlForPackageFile(`${packageJson.name}@${packageJson.version}`, '/'),\n      };\n    });\n  }\n\n  getRootUrl() {\n    return {\n      uri: this.cdn.urlForPackageFile('', ''),\n    };\n  }\n\n  listEntries(ctx: ResolverContext, uri: Uri): Promise<ResolverStrategy.ListEntriesResult> {\n    return this._withRootUriCheck(\n      uri,\n      async (): Promise<ResolverStrategy.ListEntriesResult> => {\n        const unresolvedSpec = this.cdn.parseUrl(uri);\n        const results = all(\n          [\n            ctx.getResolveRoot(uri),\n            this._readPackageJsonWithCache(ctx, unresolvedSpec),\n            this._readPackageEntriesWithCache(ctx, unresolvedSpec),\n          ],\n          ctx.token\n        );\n\n        const [{ uri: resolveRootUri }, packageJson, entriesReturn] = isThenable(results)\n          ? await results\n          : results;\n        const canonicalizedSpec: CdnStrategy.Spec = {\n          name: packageJson.name,\n          pathname: unresolvedSpec.pathname,\n          spec: `${packageJson.name}@${packageJson.version}`,\n          version: packageJson.version,\n        };\n\n        // Proactively cache the canonicalized package entries\n        this.packageEntriesCache.get(packageJson.name)!.set(packageJson.version, entriesReturn);\n\n        const traversalSegments = canonicalizedSpec.pathname.split('/').filter(Boolean);\n\n        let parentEntry: CdnStrategy.Directory | undefined = entriesReturn;\n\n        while (parentEntry && traversalSegments.length) {\n          const segment = traversalSegments.shift() as string;\n\n          if (parentEntry.type !== ResolverStrategy.EntryKind.Directory || !parentEntry.files) {\n            throw new EntryNotFoundError(uri);\n          }\n\n          parentEntry = parentEntry.files.find(\n            (file) =>\n              file.type === ResolverStrategy.EntryKind.Directory && basename(file.path) === segment\n          ) as CdnStrategy.Directory | undefined;\n        }\n\n        if (!parentEntry) {\n          throw new EntryNotFoundError(uri);\n        }\n\n        if (!parentEntry.files) {\n          return {\n            entries: [],\n          };\n        }\n\n        return {\n          entries: parentEntry.files.map((entry) => {\n            return {\n              type: entry.type,\n              uri: Uri.joinPath(resolveRootUri, `.${entry.path}`),\n            };\n          }),\n        };\n      }\n    );\n  }\n\n  readFileContent(ctx: ResolverContext, uri: Uri) {\n    return this._withRootUriCheck(uri, () => {\n      const uriStr = uri.toString();\n      const cached = this.contentCache.get(uriStr);\n\n      if (cached === null) {\n        return Promise.reject(new EntryNotFoundError(uri));\n      }\n\n      if (cached) {\n        return cached;\n      }\n\n      ctx.recordVisit(uri, ResolverContext.VisitKind.File);\n      const readReturn = this.readUrlFn(uriStr, ctx.token);\n\n      if (readReturn === null) {\n        this.contentCache.set(uriStr, null);\n\n        return Promise.reject(new EntryNotFoundError(uri));\n      }\n\n      if (isThenable(readReturn)) {\n        const wrappedReturn = readReturn.then((data) => {\n          if (data === null) {\n            this.contentCache.delete(uriStr);\n\n            return Promise.reject(new EntryNotFoundError(uri));\n          }\n\n          const entry = { content: data };\n\n          this.contentCache.set(uriStr, entry);\n\n          return entry;\n        });\n\n        this.contentCache.set(uriStr, wrappedReturn);\n\n        return wrappedReturn;\n      }\n\n      const entry = { content: readReturn };\n      this.contentCache.set(uriStr, entry);\n\n      return entry;\n    });\n  }\n\n  private _readPackageEntriesWithCache(ctx: ResolverContext, spec: CdnStrategy.Spec) {\n    ctx.debug('%s._readPackageEntriesWithCache(%s)', this.constructor.name, specToString(spec));\n\n    return this._withLock(`packageEntries:${spec.name}`, () => {\n      let packageEntriesCacheForModule = this.packageEntriesCache.get(spec.name);\n\n      if (packageEntriesCacheForModule) {\n        const exactMatch = packageEntriesCacheForModule.get(spec.version);\n\n        if (exactMatch) {\n          // console.log('[HIT-EXACT] readPackageJsonWithCache(%s)', spec.spec);\n          return exactMatch;\n        }\n\n        const range = validRange(spec.version);\n\n        if (range) {\n          for (const [version, entries] of packageEntriesCacheForModule) {\n            if (satisfies(version, range)) {\n              return entries;\n            }\n          }\n        }\n      } else {\n        packageEntriesCacheForModule = new Map();\n        this.packageEntriesCache.set(spec.name, packageEntriesCacheForModule);\n      }\n\n      return this._readPackageEntries(ctx, spec).then((rootDir) => {\n        packageEntriesCacheForModule!.set(spec.version, rootDir);\n\n        return rootDir;\n      });\n    });\n  }\n\n  private async _readPackageEntries(ctx: ResolverContext, spec: CdnStrategy.Spec) {\n    ctx.debug('%s._readPackageEntries(%s)', this.constructor.name, specToString(spec));\n\n    const uri = this.cdn.urlForPackageList(spec.spec);\n    const href = uri.toString();\n    ctx.recordVisit(uri, ResolverContext.VisitKind.Directory);\n    const data = await checkCancellation(this.readUrlFn(href, ctx.token), ctx.token);\n\n    if (data === null) {\n      throw new EntryNotFoundError(spec);\n    }\n\n    const dataStr = ctx.decoder.decode(data);\n\n    return this.cdn.normalizePackageListing(JSON.parse(dataStr));\n  }\n\n  private _readPackageJsonWithCache(ctx: ResolverContext, spec: CdnStrategy.Spec) {\n    return this._withLock(`packageJson:${spec.name}`, () => {\n      let packageJsonCacheForModule = this.packageJsonCache.get(spec.name);\n\n      if (packageJsonCacheForModule) {\n        const exactMatch = packageJsonCacheForModule.get(spec.version);\n\n        if (exactMatch) {\n          // console.log('[HIT-EXACT] readPackageJsonWithCache(%s)', spec.spec);\n          for (const visit of exactMatch.visited) {\n            ctx.recordVisit(visit.uri, visit.type);\n          }\n          return exactMatch.packageJson;\n        }\n\n        const range = validRange(spec.version);\n\n        if (range) {\n          for (const [version, entry] of packageJsonCacheForModule) {\n            if (satisfies(version, range)) {\n              // console.log('[HIT] readPackageJsonWithCache(%s)', spec.spec);\n              for (const visit of entry.visited) {\n                ctx.recordVisit(visit.uri, visit.type);\n              }\n              return entry.packageJson;\n            }\n          }\n        }\n      } else {\n        packageJsonCacheForModule = new Map();\n        this.packageJsonCache.set(spec.name, packageJsonCacheForModule);\n      }\n\n      return this._readPackageJson(spec, ctx).then((packageJson) => {\n        packageJsonCacheForModule!.set(packageJson.version, { packageJson, visited: ctx.visited });\n\n        return packageJson;\n      });\n    });\n  }\n\n  private async _readPackageJson(\n    spec: CdnStrategy.Spec,\n    ctx: ResolverContext\n  ): Promise<PackageJson> {\n    ctx.debug('%s._readPackageJson(%s)', this.constructor.name, specToString(spec));\n    const uri = this.cdn.urlForPackageFile(spec.spec, '/package.json');\n    const contentReturn = ctx.readFileContent(uri);\n    const contentResult = isThenable(contentReturn) ? await contentReturn : contentReturn;\n\n    let manifest: PackageJson;\n\n    try {\n      manifest = parseBufferAsPackageJson(ctx.decoder, contentResult.content, spec.spec);\n    } catch (err) {\n      throw new Error(`Error parsing manifest as json for package ${spec}: ${err.message}`);\n    }\n\n    // Since we know what the canonicalized version is now (we didn't until the promise resolved)\n    // and the package.json was parsed), we can proactively seed the content cache for the\n    // canonical url.\n    const canonicalHref = this.cdn\n      .urlForPackageFile(`${manifest.name}@${manifest.version}`, '/package.json')\n      .toString();\n\n    this.contentCache.set(canonicalHref, contentResult);\n\n    return manifest;\n  }\n\n  private _withLock<T extends unknown | Promise<unknown>>(\n    lockKey: string,\n    fn: (...args: any[]) => T\n  ): T {\n    const lock = this.locks.get(lockKey);\n    const runCriticalSection = (): T => {\n      const ret = fn();\n\n      if (isThenable(ret)) {\n        const locked = ret.then(\n          (result) => {\n            this.locks.delete(lockKey);\n\n            return result;\n          },\n          (err) => {\n            this.locks.delete(lockKey);\n\n            return Promise.reject(err);\n          }\n        );\n\n        this.locks.set(lockKey, locked);\n\n        return ret;\n      }\n\n      // No need to lock in non-promise\n      return ret;\n    };\n\n    if (isThenable(lock)) {\n      return lock.then(runCriticalSection) as T;\n    }\n\n    return runCriticalSection();\n  }\n\n  static forJsDelivr(readUrlFn: CdnStrategy.UrlContentFetcher) {\n    return new CdnStrategy(readUrlFn, new JSDelivrCdn());\n  }\n\n  static forUnpkg(readUrlFn: CdnStrategy.UrlContentFetcher) {\n    return new CdnStrategy(readUrlFn, new UnpkgCdn());\n  }\n}\n", "export const version = '__VERSION__';\nexport * from './cdnStrategy';\n", "import {\n  ResolverContext,\n  AbstractResolverStrategy,\n  ResolverStrategy,\n  ResolverStrategyWithRoot,\n} from '@velcro/resolver';\nimport { Uri } from '@velcro/common';\n\ntype StrategyMethodsNames =\n  | 'getCanonicalUrl'\n  | 'getResolveRoot'\n  | 'getSettings'\n  | 'listEntries'\n  | 'readFileContent';\n\ninterface ResolverHostFsOptions {\n  strategies: ResolverStrategyWithRoot[];\n}\n\nexport class CompoundStrategy extends AbstractResolverStrategy implements ResolverStrategy {\n  private readonly strategies: Set<ResolverStrategyWithRoot>;\n\n  constructor(options: ResolverHostFsOptions) {\n    super();\n\n    this.strategies = new Set(options.strategies);\n  }\n\n  private _delegateToStrategy<\n    TMethodName extends StrategyMethodsNames,\n    TMethod extends (ctx: ResolverContext, uri: Uri) => any = ResolverStrategy[TMethodName]\n  >(method: TMethodName, ctx: ResolverContext, uri: Uri) {\n    for (const strategy of this.strategies) {\n      if (Uri.isPrefixOf(strategy.rootUri, uri)) {\n        return strategy[method](ctx, uri) as ReturnType<TMethod>;\n      }\n    }\n\n    return Promise.reject(\n      new Error(`No strategy found whose root is a prefix of ${uri}`)\n    ) as ReturnType<TMethod>;\n  }\n\n  getCanonicalUrl(ctx: ResolverContext, uri: Uri) {\n    return this._delegateToStrategy('getCanonicalUrl', ctx, uri);\n  }\n\n  getResolveRoot(ctx: ResolverContext, uri: Uri) {\n    return this._delegateToStrategy('getResolveRoot', ctx, uri);\n  }\n\n  getUrlForBareModule(ctx: ResolverContext, name: string, spec: string, path: string) {\n    for (const strategy of this.strategies) {\n      if (strategy.getUrlForBareModule) {\n        return strategy.getUrlForBareModule(ctx, name, spec, path);\n      }\n    }\n    return {\n      found: false,\n      uri: null,\n    };\n  }\n\n  listEntries(ctx: ResolverContext, uri: Uri) {\n    return this._delegateToStrategy('listEntries', ctx, uri);\n  }\n\n  readFileContent(ctx: ResolverContext, uri: Uri) {\n    return this._delegateToStrategy('readFileContent', ctx, uri);\n  }\n}\n", "export const version = '__VERSION__';\n\nexport * from './compoundStrategy';\n", "import { Uri } from '@velcro/common';\nimport {\n  AbstractResolverStrategyWithRoot,\n  ResolverContext,\n  ResolverStrategy,\n} from '@velcro/resolver';\n\ninterface DirectoryEntry {\n  type: ResolverStrategy.EntryKind.Directory;\n  children: Record<string, Entry>;\n}\n\nenum FileEncoding {\n  Base64 = 'base64',\n  UTF8 = 'utf-8',\n}\n\ninterface FileEntry {\n  type: ResolverStrategy.EntryKind.File;\n  content: string;\n  encoding: FileEncoding;\n}\n\ninterface FileInputWithEncoding {\n  encoding: FileEncoding;\n  content: string;\n}\n\ntype Entry = DirectoryEntry | FileEntry;\ntype FileInput = string | FileInputWithEncoding;\n\nconst encodeText =\n  typeof TextEncoder === 'function'\n    ? (function () {\n        const encoder = new TextEncoder();\n\n        return function encodeText(data: string): ArrayBuffer {\n          return encoder.encode(data).buffer;\n        };\n      })()\n    : typeof Buffer === 'function'\n    ? function encodeText(data: string): ArrayBuffer {\n        return Buffer.from(data);\n      }\n    : function encodeText(_data: string): ArrayBuffer {\n        throw new Error(\n          'The environment provides neither TextEncoder nor Buffer. Please consider polyfilling one of these APIs.'\n        );\n      };\n\nexport class MemoryStrategy extends AbstractResolverStrategyWithRoot {\n  private readonly root: DirectoryEntry = {\n    type: ResolverStrategy.EntryKind.Directory,\n    children: {},\n  };\n\n  constructor(files: Record<string, FileInput>, rootUri = Uri.parse('memory:/')) {\n    super(Uri.ensureTrailingSlash(rootUri));\n\n    for (const pathname in files) {\n      const file = files[pathname];\n\n      if (typeof file === 'string') {\n        this.addFile(pathname, file);\n      } else {\n        this.addFile(pathname, file.content, { encoding: file.encoding });\n      }\n    }\n  }\n\n  getEntryAtPath(pathname: string) {\n    const segments = Array.isArray(pathname)\n      ? pathname.slice()\n      : pathname.split('/').filter(Boolean);\n\n    let parent: Entry = this.root;\n\n    for (const segment of segments) {\n      if (!parent || parent.type !== ResolverStrategy.EntryKind.Directory) {\n        throw new Error(`Failed to add ${pathname}`);\n      }\n\n      parent = parent.children[segment];\n    }\n\n    return parent;\n  }\n\n  addFile(\n    pathname: string,\n    content: string,\n    {\n      encoding = FileEncoding.UTF8,\n      overwrite = false,\n    }: { encoding?: FileEncoding; overwrite?: boolean } = {}\n  ) {\n    const segments = pathname.split('/').filter(Boolean);\n    const filename = segments.pop();\n\n    if (!filename) {\n      throw new Error(`Unable to add a file without a filename '${pathname}'`);\n    }\n\n    let parent: Entry = this.root;\n\n    for (const segment of segments) {\n      if (!parent || parent.type !== ResolverStrategy.EntryKind.Directory) {\n        throw new Error(`Failed to add ${pathname}`);\n      }\n\n      let dir: Entry = parent.children[segment];\n\n      if (!dir) {\n        dir = {\n          type: ResolverStrategy.EntryKind.Directory,\n          children: {},\n        };\n\n        parent.children[segment] = dir;\n      }\n\n      parent = dir;\n    }\n\n    if (parent.type !== ResolverStrategy.EntryKind.Directory) {\n      throw new Error(`Cannot add file to a non directory entry ${pathname}`);\n    }\n\n    if (parent.children[filename] && !overwrite) {\n      throw new Error(`Entry already exists at ${pathname}`);\n    }\n\n    const entry: FileEntry = {\n      type: ResolverStrategy.EntryKind.File,\n      content,\n      encoding,\n    };\n\n    parent.children[filename] = entry;\n\n    return entry;\n  }\n\n  removeFile(pathname: string) {\n    const segments = pathname.split('/').filter(Boolean);\n    const filename = segments.pop();\n\n    if (!filename) {\n      return false;\n    }\n\n    let parent: Entry = this.root;\n\n    for (const segment of segments) {\n      if (!parent || parent.type !== ResolverStrategy.EntryKind.Directory) {\n        return false;\n      }\n\n      parent = parent.children[segment];\n    }\n\n    if (!parent || parent.type !== ResolverStrategy.EntryKind.Directory) {\n      return false;\n    }\n\n    return delete parent.children[filename];\n  }\n\n  getResolveRoot() {\n    return {\n      uri: this.rootUri,\n    };\n  }\n\n  listEntries(_ctx: ResolverContext, uri: Uri) {\n    const urlPathname = Uri.ensureTrailingSlash(uri).fsPath;\n    const basePathname = this.rootUri.fsPath;\n    const fsPathname = urlPathname.startsWith(basePathname)\n      ? urlPathname.slice(basePathname.length - 1)\n      : urlPathname;\n    const parent = this.getEntryAtPath(fsPathname);\n\n    if (!parent) {\n      throw new Error(`No such directory ${uri.toString()}`);\n    }\n\n    if (parent.type !== ResolverStrategy.EntryKind.Directory) {\n      throw new Error(`Cannot list entries under a file at ${uri.toString()}`);\n    }\n\n    const entries = Object.keys(parent.children).map((filename) => {\n      const entry = parent.children[filename];\n\n      return {\n        uri: Uri.joinPath(this.rootUri, fsPathname, filename),\n        type: entry.type,\n      };\n    });\n\n    return {\n      entries,\n    };\n  }\n\n  readFileContent(_ctx: ResolverContext, uri: Uri) {\n    const urlPathname = Uri.ensureTrailingSlash(uri).fsPath;\n    const basePathname = this.rootUri.fsPath;\n    const fsPathname = urlPathname.startsWith(basePathname)\n      ? urlPathname.slice(basePathname.length - 1)\n      : urlPathname;\n    const entry = this.getEntryAtPath(fsPathname);\n\n    if (!entry) {\n      throw new Error(`No such file ${uri.toString()}`);\n    }\n\n    if (entry.type !== 'file') {\n      throw new Error(`Cannot read content of a non-file at ${uri.toString()}`);\n    }\n\n    switch (entry.encoding) {\n      case FileEncoding.Base64: {\n        const binSting = atob(entry.content);\n        const binArray = new Uint8Array(binSting.length);\n\n        Array.prototype.forEach.call(binArray, function (_el: any, idx: number, arr: number[]) {\n          arr[idx] = binSting.charCodeAt(idx);\n        });\n\n        return {\n          content: binArray.buffer,\n        };\n      }\n      case FileEncoding.UTF8: {\n        return {\n          content: encodeText(entry.content),\n        };\n      }\n      default:\n        throw new Error(`Unsupported encoding for ${uri.toString()}: ${entry.encoding}`);\n    }\n  }\n\n  uriForPath(pathname: string) {\n    return Uri.joinPath(this.rootUri, pathname);\n  }\n}\n", "export const version = '__VERSION__';\nexport * from './memoryStrategy';\n", "import { DisposableStore, Emitter, Event, IDisposable } from '@velcro/common';\n\nexport type DefineEvent<TEventName extends string, TData = never> = {\n  eventName: TEventName;\n  data: TData;\n};\ntype AnyEvent = DefineEvent<string> | DefineEvent<string, unknown>;\ntype EventWithData<TEvent extends AnyEvent> = TEvent extends AnyEvent\n  ? [TEvent['data']] extends [never]\n    ? never\n    : TEvent\n  : never;\ntype EventWithoutData<TEvent extends AnyEvent> = Exclude<TEvent, EventWithData<TEvent>>;\n\nexport type DefineState<TStateName extends string, TData = never> = TStateName extends string\n  ? [TData] extends [never]\n    ? {\n        stateName: TStateName;\n      }\n    : {\n        stateName: TStateName;\n        data: TData;\n      }\n  : never;\ntype AnyState = DefineState<string> | DefineState<string, unknown>;\n\ntype Chart<TState extends AnyState, TEvent extends AnyEvent> = {\n  [TStateName in TState['stateName']]: {\n    onEnter?(ctx: {\n      event: TEvent;\n      registerDisposable(disposable: IDisposable): void;\n      sendEvent: SendEventFunction<TEvent>;\n      state: Extract<TState, { stateName: TStateName }>;\n      transitionTo: TransitionToFunction<TState, TEvent>;\n    }): void;\n    onEvent?: {\n      [TEventName in TEvent['eventName']]?: (ctx: {\n        event: Extract<TEvent, { eventName: TEventName }>;\n        registerDisposable(disposable: IDisposable): void;\n        sendEvent: SendEventFunction<TEvent>;\n        state: Extract<TState, { stateName: TStateName }>;\n        transitionTo: TransitionToFunction<TState, TEvent>;\n      }) => void;\n    };\n    onExit?(ctx: { event: TEvent; state: Extract<TState, { stateName: TStateName }> }): void;\n  };\n};\n\ninterface SendEventFunction<TEvent extends AnyEvent> {\n  <TSentEvent extends EventWithoutData<TEvent>>(eventName: TSentEvent['eventName']): void;\n  <TSentEvent extends EventWithData<TEvent>>(\n    eventName: TSentEvent['eventName'],\n    data: TSentEvent['data']\n  ): void;\n}\n\ninterface TransitionToFunction<TState extends AnyState, TEvent extends AnyEvent> {\n  <TTargetState extends TState, TTriggeringEvent extends TEvent>(\n    state: TTargetState,\n    event: TTriggeringEvent\n  ): void;\n}\n\nexport class FSM<TState extends AnyState, TEvent extends AnyEvent> {\n  private readonly onStateChangeEmitter = new Emitter<Readonly<TState>>();\n\n  private readonly states: Chart<TState, TEvent>;\n  private handlingEvents = false;\n  private mutableState: TState;\n  private pendingExternalEvents: TEvent[] = [];\n  private pendingInternalEvents: TEvent[] = [];\n  private readonly stateDisposer = new DisposableStore();\n\n  constructor(states: Chart<TState, TEvent>, initialState: TState) {\n    this.states = states;\n    this.mutableState = initialState;\n  }\n\n  get onStateChange(): Event<Readonly<TState>> {\n    return this.onStateChangeEmitter.event;\n  }\n\n  get state(): Readonly<TState> {\n    return this.mutableState;\n  }\n\n  sendEvent<TSentEvent extends EventWithoutData<TEvent>>(event: TSentEvent['eventName']): void;\n  sendEvent<TSentEvent extends EventWithData<TEvent>>(\n    event: TSentEvent['eventName'],\n    data: TSentEvent['data']\n  ): void;\n  sendEvent<TSentEvent extends TEvent>(\n    eventName: TSentEvent['eventName'],\n    data?: TSentEvent['data']\n  ): void {\n    // console.group();\n    // console.log('sendEvent(%s, %s)', this.state.stateName, eventName, data);\n    this.pendingExternalEvents.push({ eventName, data } as TEvent);\n\n    if (!this.handlingEvents) {\n      this.processEvents();\n    }\n  }\n\n  private processEvents() {\n    if (this.handlingEvents) {\n      throw new Error(\n        'Invariant violation: processEvents should never be called while already processing events.'\n      );\n    }\n\n    this.handlingEvents = true;\n\n    while (this.pendingExternalEvents.length || this.pendingInternalEvents.length) {\n      while (this.pendingInternalEvents.length) {\n        const event = this.pendingInternalEvents.shift() as TEvent;\n        const currentStateDef = this.states[this.mutableState.stateName as TState['stateName']];\n\n        if (currentStateDef.onEvent) {\n          const handler = currentStateDef.onEvent[event.eventName as TEvent['eventName']];\n          const state = this.state;\n\n          if (handler) {\n            handler({\n              event: event as any,\n              registerDisposable: this.stateDisposer.add.bind(this.stateDisposer),\n              sendEvent: this.sendEventInternal.bind(this),\n              state: state as any,\n              transitionTo: this.transitionTo.bind(this),\n            });\n          }\n        }\n      }\n\n      while (this.pendingExternalEvents.length) {\n        // Move external events into the internal event queue for the next tick\n        // of the outer loop.\n        this.pendingInternalEvents.push(this.pendingExternalEvents.pop()!);\n      }\n    }\n\n    this.handlingEvents = false;\n  }\n\n  private sendEventInternal<TSentEvent extends EventWithoutData<TEvent>>(\n    event: TSentEvent['eventName']\n  ): void;\n  private sendEventInternal<TSentEvent extends EventWithData<TEvent>>(\n    event: TSentEvent['eventName'],\n    data: TSentEvent['data']\n  ): void;\n  private sendEventInternal<TSentEvent extends TEvent>(\n    eventName: TSentEvent['eventName'],\n    data?: TSentEvent['data']\n  ): void {\n    this.pendingInternalEvents.push({ eventName, data } as TEvent);\n\n    if (!this.handlingEvents) {\n      this.processEvents();\n    }\n  }\n\n  private transitionTo<TTargetState extends TState, TTriggeringEvent extends TEvent>(\n    state: TTargetState,\n    event: TTriggeringEvent\n  ) {\n    const fromStateConfig = this.states[this.mutableState.stateName as TState['stateName']];\n    const nextStateConfig = this.states[state.stateName as TState['stateName']];\n    const fromState = { ...this.mutableState };\n\n    this.mutableState = { ...state };\n    this.onStateChangeEmitter.fire(this.state);\n\n    if (state.stateName !== fromState.stateName) {\n      this.stateDisposer.clear();\n\n      if (fromStateConfig.onExit) {\n        fromStateConfig.onExit({\n          event,\n          state: state as any,\n        });\n      }\n\n      if (nextStateConfig.onEnter) {\n        nextStateConfig.onEnter({\n          event,\n          registerDisposable: this.stateDisposer.add.bind(this.stateDisposer),\n          sendEvent: this.sendEventInternal.bind(this),\n          state: state as any,\n          transitionTo: this.transitionTo.bind(this),\n        });\n      }\n    }\n  }\n}\n", "/* eslint-env worker */\n\n/// <reference lib=\"WebWorker\" />\n\nimport { Graph, GraphBuilder } from '@velcro/bundler';\nimport { CancellationTokenSource, DisposableStore, Event, Uri } from '@velcro/common';\nimport { cssPlugin } from '@velcro/plugin-css';\nimport { sucrasePlugin } from '@velcro/plugin-sucrase';\nimport { Resolver } from '@velcro/resolver';\nimport { CdnStrategy } from '@velcro/strategy-cdn';\nimport { CompoundStrategy } from '@velcro/strategy-compound';\nimport { MemoryStrategy } from '@velcro/strategy-memory';\nimport * as Svelte from 'svelte/compiler';\nimport { DefineEvent, DefineState, FSM } from './fsm';\nimport { BuildingState, BuiltState, EditorEvents, ErrorState } from './types';\n\nconst readUrl = (href: string) => fetch(href).then((res) => res.arrayBuffer());\n\ntype BuilderState =\n  | DefineState<'initial'>\n  | DefineState<'dirty'>\n  | DefineState<'waiting'>\n  | DefineState<'building', { pending: number; completed: number; start: number }>\n  | DefineState<'built', { graph: Graph; start: number; end: number }>\n  | DefineState<'error', { error: Error; start: number; end: number }>;\n\ntype FileCreateEvent = DefineEvent<'file_create', { uri: Uri; content: string }>;\ntype FileRemoveEvent = DefineEvent<'file_remove', { uri: Uri }>;\ntype FileUpdateEvent = DefineEvent<'file_update', { uri: Uri; content: string }>;\ntype BuilderEvent =\n  | DefineEvent<'build'>\n  | FileCreateEvent\n  | FileRemoveEvent\n  | FileUpdateEvent\n  | DefineEvent<'timer_fired'>\n  | DefineEvent<'build_error', { error: Error; start: number }>\n  | DefineEvent<'build_progress', { pending: number; completed: number }>\n  | DefineEvent<'build_complete', { graph: Graph; start: number }>;\n\nexport class VelcroBuilderMachine {\n  private readonly disposer = new DisposableStore();\n  private readonly fsm = new FSM<BuilderState, BuilderEvent>(\n    {\n      initial: {\n        onEvent: {\n          build: ({ event, transitionTo }) =>\n            transitionTo(\n              { stateName: 'building', data: { pending: 0, completed: 0, start: Date.now() } },\n              event\n            ),\n          file_create: ({ event, transitionTo }) => {\n            if (this.onFileCreate(event)) transitionTo({ stateName: 'dirty' }, event);\n          },\n          file_remove: ({ event, transitionTo }) => {\n            if (this.onFileRemove(event)) transitionTo({ stateName: 'dirty' }, event);\n          },\n          file_update: ({ event, transitionTo }) => {\n            if (this.onFileUpdate(event)) transitionTo({ stateName: 'dirty' }, event);\n          },\n        },\n      },\n      dirty: {\n        onEnter: ({ event, transitionTo }) => {\n          if (this.buildConfig.autoBuild) {\n            transitionTo({ stateName: 'waiting' }, event);\n          }\n        },\n        onEvent: {\n          build: ({ event, transitionTo }) =>\n            transitionTo(\n              { stateName: 'building', data: { pending: 0, completed: 0, start: Date.now() } },\n              event\n            ),\n          file_create: ({ event, transitionTo }) => {\n            if (this.onFileCreate(event)) transitionTo({ stateName: 'dirty' }, event);\n          },\n          file_remove: ({ event, transitionTo }) => {\n            if (this.onFileRemove(event)) transitionTo({ stateName: 'dirty' }, event);\n          },\n          file_update: ({ event, transitionTo }) => {\n            if (this.onFileUpdate(event)) transitionTo({ stateName: 'dirty' }, event);\n          },\n        },\n      },\n      waiting: {\n        onEnter: ({ registerDisposable, sendEvent }) => {\n          const timerHandle = setTimeout(() => {\n            sendEvent('timer_fired');\n          }, this.buildConfig.autoBuildWaitTimeout);\n\n          registerDisposable({\n            dispose: () => {\n              clearTimeout(timerHandle);\n            },\n          });\n        },\n        onEvent: {\n          build: ({ event, transitionTo }) =>\n            transitionTo(\n              { stateName: 'building', data: { pending: 0, completed: 0, start: Date.now() } },\n              event\n            ),\n          file_create: ({ event, transitionTo }) => {\n            if (this.onFileCreate(event)) transitionTo({ stateName: 'dirty' }, event);\n          },\n          file_remove: ({ event, transitionTo }) => {\n            if (this.onFileRemove(event)) transitionTo({ stateName: 'dirty' }, event);\n          },\n          file_update: ({ event, transitionTo }) => {\n            if (this.onFileUpdate(event)) transitionTo({ stateName: 'dirty' }, event);\n          },\n          timer_fired: ({ event, transitionTo }) =>\n            transitionTo(\n              { stateName: 'building', data: { pending: 0, completed: 0, start: Date.now() } },\n              event\n            ),\n        },\n      },\n      building: {\n        onEnter: ({ registerDisposable, sendEvent }) => {\n          const tokenSource = new CancellationTokenSource();\n          const start = Date.now();\n          const build = this.graphBuilder.build([this.localStrategy.rootUri], {\n            incremental: false,\n            token: tokenSource.token,\n          });\n\n          registerDisposable({\n            dispose() {\n              tokenSource.dispose(true);\n            },\n          });\n          registerDisposable(\n            build.onCompleted(({ graph }) => sendEvent('build_complete', { graph, start }))\n          );\n          registerDisposable(\n            build.onProgress(({ progress }) => sendEvent('build_progress', progress))\n          );\n          registerDisposable(\n            build.onError(({ error }) => {\n              return sendEvent('build_error', { error, start });\n            })\n          );\n\n          this.graphBuilder.build([this.localStrategy.rootUri], {\n            incremental: false,\n            token: tokenSource.token,\n          });\n        },\n        onEvent: {\n          build_complete: ({ event, transitionTo }) =>\n            transitionTo(\n              {\n                stateName: 'built',\n                data: { graph: event.data.graph, end: Date.now(), start: event.data.start },\n              },\n              event\n            ),\n          build_error: ({ event, transitionTo }) =>\n            transitionTo(\n              {\n                stateName: 'error',\n                data: { error: event.data.error, end: Date.now(), start: event.data.start },\n              },\n              event\n            ),\n          build_progress: ({ event, state, transitionTo }) =>\n            transitionTo(\n              {\n                stateName: 'building',\n                data: {\n                  completed: event.data.completed,\n                  pending: event.data.pending,\n                  start: state.data.start,\n                },\n              },\n              event\n            ),\n          file_create: ({ event, transitionTo }) => {\n            if (this.onFileCreate(event)) transitionTo({ stateName: 'dirty' }, event);\n          },\n          file_remove: ({ event, transitionTo }) => {\n            if (this.onFileRemove(event)) transitionTo({ stateName: 'dirty' }, event);\n          },\n          file_update: ({ event, transitionTo }) => {\n            if (this.onFileUpdate(event)) transitionTo({ stateName: 'dirty' }, event);\n          },\n        },\n      },\n      built: {\n        onEvent: {\n          build: ({ event, transitionTo }) =>\n            transitionTo(\n              { stateName: 'building', data: { pending: 0, completed: 0, start: Date.now() } },\n              event\n            ),\n          file_create: ({ event, transitionTo }) => {\n            if (this.onFileCreate(event)) transitionTo({ stateName: 'dirty' }, event);\n          },\n          file_remove: ({ event, transitionTo }) => {\n            if (this.onFileRemove(event)) transitionTo({ stateName: 'dirty' }, event);\n          },\n          file_update: ({ event, transitionTo }) => {\n            if (this.onFileUpdate(event)) transitionTo({ stateName: 'dirty' }, event);\n          },\n        },\n      },\n      error: {\n        onEvent: {\n          build: ({ event, transitionTo }) =>\n            transitionTo(\n              { stateName: 'building', data: { pending: 0, completed: 0, start: Date.now() } },\n              event\n            ),\n          file_create: ({ event, transitionTo }) => {\n            if (this.onFileCreate(event)) transitionTo({ stateName: 'dirty' }, event);\n          },\n          file_remove: ({ event, transitionTo }) => {\n            if (this.onFileRemove(event)) transitionTo({ stateName: 'dirty' }, event);\n          },\n          file_update: ({ event, transitionTo }) => {\n            if (this.onFileUpdate(event)) transitionTo({ stateName: 'dirty' }, event);\n          },\n        },\n      },\n    },\n    { stateName: 'initial' }\n  );\n\n  private readonly localStrategy = new MemoryStrategy({}, Uri.file('/'));\n  private readonly npmStrategy = CdnStrategy.forJsDelivr(readUrl);\n  private readonly rootStrategy = new CompoundStrategy({\n    strategies: [this.localStrategy, this.npmStrategy],\n  });\n  private readonly resolver: Resolver;\n  private readonly graphBuilder: GraphBuilder;\n\n  public readonly buildConfig = {\n    autoBuild: false,\n    autoBuildWaitTimeout: 500,\n  };\n\n  constructor(options: { autoBuild?: boolean; autoBuildWaitTimeout?: number } = {}) {\n    if (options.autoBuild) {\n      this.buildConfig.autoBuild = options.autoBuild;\n    }\n    if (options.autoBuildWaitTimeout) {\n      this.buildConfig.autoBuildWaitTimeout = options.autoBuildWaitTimeout;\n    }\n\n    this.resolver = new Resolver(this.rootStrategy, {\n      debug: false,\n      extensions: ['.js', '.jsx', '.json', '.ts', '.tsx', '.mjs', '.cjs', '.svelte'],\n      packageMain: ['browser', 'main'],\n    });\n    this.graphBuilder = new GraphBuilder({\n      resolver: this.resolver,\n      nodeEnv: 'development',\n      plugins: [\n        cssPlugin(),\n        {\n          name: 'svelte',\n          transform(_ctx, uri, code) {\n            if (!uri.fsPath.endsWith('.svelte')) return;\n\n            const compiled = Svelte.compile(code, {\n              dev: true,\n              filename: uri.toString(),\n              format: 'cjs',\n              generate: 'dom',\n              css: true,\n              outputFilename: uri.toString(),\n            });\n\n            compiled.js.code +=\n              '\\nObject.defineProperty(module.exports, \"__esModule\", { value: true });\\n';\n\n            console.log(compiled);\n\n            return {\n              code: compiled.js.code,\n              sourceMap: compiled.js.map,\n            };\n          },\n        },\n        sucrasePlugin({ transforms: ['imports', 'jsx', 'typescript'] }),\n      ],\n    });\n\n    this.disposer.add(this.resolver);\n    // this.disposer.add(this.graphBuilder);\n  }\n\n  get onStateChange() {\n    return this.fsm.onStateChange;\n  }\n\n  get sendEvent() {\n    return this.fsm.sendEvent.bind(this.fsm);\n  }\n\n  get state() {\n    return this.fsm.state;\n  }\n\n  dispose() {\n    this.disposer.dispose();\n  }\n\n  startBuild() {\n    this.fsm.sendEvent('build');\n  }\n\n  private onFileCreate(e: FileCreateEvent) {\n    if (!Uri.isPrefixOf(this.localStrategy.rootUri, e.data.uri)) {\n      return false;\n    }\n\n    this.localStrategy.addFile(e.data.uri.fsPath, e.data.content, { overwrite: true });\n    this.graphBuilder.invalidate(e.data.uri);\n    this.graphBuilder.invalidate(Uri.joinPath(e.data.uri, '..'));\n\n    return true;\n  }\n\n  private onFileRemove(e: FileRemoveEvent) {\n    if (!Uri.isPrefixOf(this.localStrategy.rootUri, e.data.uri)) {\n      return false;\n    }\n\n    this.localStrategy.removeFile(e.data.uri.fsPath);\n    this.graphBuilder.invalidate(e.data.uri);\n    this.graphBuilder.invalidate(Uri.joinPath(e.data.uri, '..'));\n\n    return true;\n  }\n\n  private onFileUpdate(e: FileUpdateEvent) {\n    if (!Uri.isPrefixOf(this.localStrategy.rootUri, e.data.uri)) {\n      return false;\n    }\n\n    this.localStrategy.addFile(e.data.uri.fsPath, e.data.content, { overwrite: true });\n    this.graphBuilder.invalidate(e.data.uri);\n\n    return true;\n  }\n}\n\nconst builder = new VelcroBuilderMachine({\n  autoBuild: true,\n  autoBuildWaitTimeout: 500,\n});\n\nglobalThis.addEventListener('message', (e) => {\n  const data = e.data;\n\n  if (EditorEvents.is(data)) {\n    for (const event of data) {\n      switch (event.event) {\n        case 'file_create':\n          builder.sendEvent('file_create', {\n            content: event.content,\n            uri: Uri.parse(event.href),\n          });\n          break;\n        case 'file_remove':\n          builder.sendEvent('file_remove', { uri: Uri.parse(event.href) });\n          break;\n        case 'file_update':\n          builder.sendEvent('file_update', {\n            content: event.content,\n            uri: Uri.parse(event.href),\n          });\n          break;\n      }\n    }\n  }\n});\n\nEvent.debounce(\n  builder.onStateChange,\n  (_, e) => e,\n  16\n)((state) => {\n  switch (state.stateName) {\n    case 'building': {\n      const message: BuildingState = {\n        state: 'building',\n        completed: state.data.completed,\n        pending: state.data.pending,\n      };\n      return globalThis.postMessage(message);\n    }\n    case 'built': {\n      const graph = state.data.graph;\n      const [chunk] = graph.splitChunks();\n      const build = chunk.buildForStaticRuntime({\n        injectRuntime: true,\n      });\n      let code = `${build.code}\\n\\n${[Uri.file('/index.js')]\n        .map((entrypoint) => `Velcro.runtime.require(${JSON.stringify(entrypoint.toString())});`)\n        .join('\\n')}\\n`;\n      // code += `\\n//# sourceMappingURL=${build.sourceMapDataUri}`;\n      const codeBundleFile = new File([code], Uri.file('/index.js').toString(), {\n        type: 'text/javascript',\n      });\n\n      const markup = new File(\n        [\n          `\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\">\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n<meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n<script src=\"https://cdn.jsdelivr.net/npm/panic-overlay/build/panic-overlay.browser.js\"></script>\n<title>Document</title>\n</head>\n<body>\n<div id=\"root\"></div>\n<script src=\"${URL.createObjectURL(codeBundleFile)}\"></script>\n<script>\n  panic.configure ({\n    stackEntryClicked (entry) {\n      if (window.parent) {\n        window.parent.postMessage({\n          event: 'click_error',\n          entry: {\n            column: entry.column,\n            file: entry.file,\n            line: entry.line,\n          }\n        });\n      }\n    }\n  })\n</script>\n</body>\n</html>`.trim(),\n        ],\n        Uri.file('/index.html').toString(),\n        {\n          type: 'text/html',\n        }\n      );\n      const htmlUrl = URL.createObjectURL(markup);\n      const message: BuiltState = {\n        state: 'built',\n        href: htmlUrl,\n        start: state.data.start,\n        end: state.data.end,\n      };\n\n      return globalThis.postMessage(message);\n    }\n    case 'error': {\n      const message: ErrorState = {\n        state: 'error',\n        error: { message: state.data.error.message },\n      };\n\n      return globalThis.postMessage(message);\n    }\n  }\n});\n"],
  "mappings": "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AE,IAAI,GAAG,GAAG,EAAE,GAAG,EAAE,GAAG,GAAG,GAAG,EAAE,EAAE,EAAE,IAAI,GAAG,GAAG,EAAE,GAAG,GAAG,GAAG,EAAE,GAAG,GAAG,GAAG,EAAE,GAAG,GAAG,IAAI,GAAG,IAAI,GAAG,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,GAAG,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,GAAG,GAAG,EAAE,EAAE,EAAE,GAAG,EAAE,GAAG,GAAG,EAAE,EAAE,GAAG,EAAE,GAAG,GAAG,GAAG,EAAE,GAAG,GAAG,IAAI,EAAE,EAAE,GAAG,GAAG,EAAE,GAAG,GAAG,IAAI,EAAE,EAAE,EAAE,EAAE,GAAG,GAAG,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,GAAG,GAAG,EAAE,IAAI,GAAG,IAAI,EAAE,GAAG,IAAI,IAAI,IAAI,GAAG,IAAI,KAAK,KAAK,KAAK,IAAI,KAAK,IAAI,EAAE,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,EAAE,GAAG,GAAG,EAAE,GAAG,IAAI,GAAG,IAAI,GAAG,EAAE,EAAE,GAAG,GAAG,GAAG,EAAE,EAAE,EAAE,GAAG,KAAK,EAAE,KAAK,GAAG,EAAE,KAAK,IAAI,GAAG,EAAE,GAAG,EAAE,EAAE,IAAI,KAAK,IAAI,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,KAAK,GAAG,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,IAAI,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,EAAE,KAAK,GAAG,GAAG,EAAE,GAAG,EAAE,IAAI,GAAG,KAAK,IAAI,GAAG,GAAG,EAAE,EAAE,KAAK,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,KAAK,MAAM,GAAG,KAAK,GAAG,IAAI,EAAE,KAAK,GAAG,KAAK,KAAK,IAAI,KAAK,MAGpyC,EAAwB,CAAC,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,KAAK,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,IAAI,EAAE,IAAI,EAAE,EAAE,EAAE,IAAI,EAAE,IAAI,GAAG,IAAI,EAAE,GAAG,GAAG,GAAG,EAAE,GAAG,EAAE,GAAG,GAAG,GAAG,EAAE,EAAE,EAAE,GAAG,GAAG,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,GAAG,EAAE,EAAE,EAAE,GAAG,GAAG,GAAG,EAAE,EAAE,IAAI,GAAG,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,IAAI,GAAG,GAAG,EAAE,EAAE,EAAE,GAAG,GAAG,GAAG,EAAE,IAAI,EAAE,EAAE,EAAE,GAAG,EAAE,GAAG,GAAG,GAAG,EAAE,GAAG,GAAG,EAAE,EAAE,GAAG,GAAG,EAAE,EAAE,IAAI,GAAG,IAAI,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,IAAI,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,GAAG,GAAG,GAAG,IAAI,EAAE,EAAE,EAAE,GAAG,EAAE,GAAG,GAAG,EAAE,GAAG,IAAI,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE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AgB,MAChB,eAAgB,KAChB,eAAgB,KAChB,eAAgB,KAChB,eAAgB,KAChB,eAAgB,KAChB,eAAgB,KAChB,eAAgB,MAChB,eAAgB,MAChB,eAAgB,MAChB,eAAgB,KAChB,eAAgB,KAChB,eAAgB,KAChB,eAAgB,KAChB,eAAgB,KAChB,eAAgB,KAChB,eAAgB,KAChB,eAAgB,KAChB,eAAgB,MAChB,eAAgB,MAChB,eAAgB,KAChB,eAAgB,KAChB,eAAgB,KAChB,eAAgB,KAChB,eAAgB,KAChB,eAAgB,KAChB,eAAgB,KAChB,eAAgB,KAChB,eAAgB,KAChB,eAAgB,KAChB,eAAgB,KAChB,eAAgB,KAChB,eAAgB,KAChB,eAAgB,MAChB,eAAgB,KAChB,eAAgB,KAChB,eAAgB,KAChB,eAAgB,KAChB,eAAgB,KAChB,eAAgB,KAChB,eAAgB,KAChB,cAAe,KACf,cAAe,KACf,cAAe,MACf,cAAe,KACf,cAAe,MACf,cAAe,MACf,cAAe,KACf,cAAe,MACf,cAAe,MACf,cAAe,KACf,cAAe,KACf,cAAe,KACf,cAAe,MACf,cAAe,KACf,cAAe,KACf,cAAe,KACf,cAAe,KACf,cAAe,KACf,cAAe,MACf,cAAe,KACf,cAAe,KACf,cAAe,MACf,cAAe,KACf,cAAe,KACf,cAAe,KACf,cAAe,KACf,cAAe,KACf,cAAe,KACf,cAAe,KACf,cAAe,KACf,cAAe,KACf,cAAe,MACf,cAAe,KACf,cAAe,KACf,cAAe,KACf,cAAe,KACf,cAAe,KACf,cAAe,KACf,cAAe,KACf,aAAc,MACd,aAAc,KACd,aAAc,KACd,aAAc,KACd,aAAc,KACd,aAAc,KACd,aAAc,KACd,aAAc,KACd,aAAc,KACd,aAAc,KACd,aAAc,KACd,aAAc,KACd,aAAc,KACd,aAAc,KACd,aAAc,KACd,aAAc,KACd,aAAc,KACd,aAAc,MACd,aAAc,KACd,aAAc,KACd,aAAc,KACd,aAAc,IACd,aAAc,MACd,aAAc,KACd,aAAc,KACd,aAAc,KACd,aAAc,KACd,YAAa,KACb,YAAa,KACb,YAAa,KACb,YAAa,KACb,YAAa,KACb,YAAa,KACb,YAAa,KACb,YAAa,KACb,YAAa,KACb,YAAa,KACb,YAAa,KACb,YAAa,KACb,YAAa,MACb,YAAa,KACb,YAAa,KACb,YAAa,KACb,YAAa,KACb,YAAa,KACb,YAAa,KACb,YAAa,KACb,YAAa,KACb,YAAa,KACb,YAAa,KACb,YAAa,KACb,YAAa,KACb,YAAa,KACb,YAAa,MACb,YAAa,KACb,YAAa,KACb,YAAa,KACb,YAAa,KACb,YAAa,MACb,YAAa,KACb,YAAa,IACb,YAAa,KACb,YAAa,MACb,YAAa,KACb,YAAa,KACb,WAAY,KACZ,WAAY,KACZ,WAAY,KACZ,WAAY,KACZ,WAAY,KACZ,WAAY,KACZ,WAAY,KACZ,WAAY,KACZ,WAAY,KACZ,WAAY,KACZ,WAAY,KACZ,WAAY,KACZ,WAAY,KACZ,WAAY,KACZ,WAAY,KACZ,WAAY,KACZ,WAAY,KACZ,WAAY,MACZ,WAAY,KACZ,WAAY,KACZ,WAAY,KACZ,WAAY,KACZ,WAAY,MACZ,WAAY,MACZ,WAAY,MACZ,WAAY,MACZ,WAAY,KACZ,WAAY,MACZ,WAAY,KACZ,WAAY,KACZ,WAAY,KACZ,WAAY,KACZ,WAAY,MACZ,WAAY,KACZ,WAAY,KACZ,WAAY,KACZ,WAAY,KACZ,WAAY,MACZ,WAAY,MACZ,WAAY,MACZ,WAAY,KACZ,WAAY,IACZ,WAAY,KACZ,UAAW,KACX,UAAW,IACX,UAAW,KACX,UAAW,KACX,UAAW,KACX,UAAW,IACX,UAAW,KACX,UAAW,IACX,UAAW,KACX,UAAW,KACX,UAAW,KACX,UAAW,KACX,UAAW,KACX,UAAW,KACX,UAAW,KACX,UAAW,KACX,UAAW,KACX,UAAW,KACX,UAAW,KACX,UAAW,IACX,UAAW,KACX,UAAW,KACX,UAAW,KACX,UAAW,KACX,UAAW,KACX,UAAW,KACX,UAAW,MACX,UAAW,IACX,UAAW,MACX,UAAW,KACX,UAAW,KACX,UAAW,KACX,UAAW,MACX,UAAW,KACX,UAAW,KACX,UAAW,KACX,UAAW,KACX,UAAW,KACX,UAAW,KACX,UAAW,KACX,UAAW,KACX,UAAW,KACX,UAAW,KACX,UAAW,KACX,UAAW,MACX,UAAW,KACX,UAAW,MACX,UAAW,KACX,UAAW,KACX,UAAW,KACX,UAAW,KACX,SAAU,MACV,SAAU,KACV,SAAU,KACV,SAAU,MACV,SAAU,KACV,SAAU,KACV,SAAU,KACV,SAAU,KACV,SAAU,KACV,SAAU,KACV,SAAU,KACV,SAAU,KACV,SAAU,MACV,SAAU,IACV,SAAU,MACV,SAAU,MACV,SAAU,MACV,SAAU,MACV,SAAU,MACV,SAAU,MACV,SAAU,MACV,SAAU,MACV,SAAU,MACV,SAAU,MACV,SAAU,KACV,SAAU,KACV,SAAU,KACV,SAAU,KACV,SAAU,KACV,SAAU,MACV,SAAU,MACV,SAAU,MACV,SAAU,KACV,SAAU,KACV,SAAU,KACV,SAAU,MACV,SAAU,IACV,SAAU,KACV,SAAU,MACV,SAAU,KACV,SAAU,MACV,SAAU,KACV,SAAU,KACV,SAAU,KACV,SAAU,KACV,SAAU,MACV,SAAU,MACV,SAAU,KACV,SAAU,KACV,SAAU,MACV,SAAU,MACV,SAAU,MACV,SAAU,MACV,SAAU,MACV,SAAU,MACV,SAAU,MACV,SAAU,KACV,SAAU,KACV,SAAU,MACV,SAAU,KACV,SAAU,KACV,SAAU,MACV,SAAU,MACV,SAAU,MACV,SAAU,MACV,SAAU,MACV,SAAU,KACV,SAAU,MACV,SAAU,KACV,SAAU,MACV,SAAU,KACV,SAAU,KACV,SAAU,KACV,SAAU,MACV,SAAU,KACV,SAAU,MACV,SAAU,MACV,SAAU,MACV,SAAU,KACV,SAAU,KACV,SAAU,KACV,SAAU,KACV,SAAU,MACV,SAAU,KACV,SAAU,MACV,SAAU,MACV,SAAU,MACV,SAAU,KACV,SAAU,KACV,SAAU,MACV,SAAU,KACV,SAAU,KACV,SAAU,KACV,SAAU,MACV,SAAU,KACV,SAAU,KACV,SAAU,IACV,SAAU,KACV,SAAU,MACV,SAAU,KACV,SAAU,MACV,SAAU,KACV,SAAU,KACV,SAAU,KACV,SAAU,KACV,SAAU,IACV,SAAU,IACV,QAAS,KACT,QAAS,KACT,QAAS,KACT,QAAS,IACT,QAAS,KACT,QAAS,KACT,QAAS,KACT,QAAS,IACT,QAAS,KACT,QAAS,KACT,QAAS,GACT,QAAS,KACT,QAAS,KACT,QAAS,IACT,QAAS,IACT,QAAS,KACT,QAAS,KACT,QAAS,KACT,QAAS,IACT,QAAS,KACT,QAAS,KACT,QAAS,KACT,QAAS,KACT,QAAS,KACT,QAAS,KACT,QAAS,MACT,QAAS,KACT,QAAS,KACT,QAAS,MACT,QAAS,KACT,QAAS,KACT,QAAS,MACT,QAAS,MACT,QAAS,MACT,QAAS,KACT,QAAS,MACT,QAAS,MACT,QAAS,MACT,QAAS,MACT,QAAS,MACT,QAAS,MACT,QAAS,KACT,QAAS,MACT,QAAS,MACT,QAAS,KACT,QAAS,IACT,QAAS,KACT,QAAS,MACT,QAAS,IACT,QAAS,KACT,QAAS,MACT,QAAS,MACT,QAAS,MACT,QAAS,KACT,QAAS,MACT,QAAS,MACT,QAAS,KACT,QAAS,MACT,QAAS,MACT,QAAS,MACT,QAAS,MACT,QAAS,MACT,QAAS,MACT,QAAS,KACT,QAAS,KACT,QAAS,KACT,QAAS,MACT,QAAS,KACT,QAAS,MACT,QAAS,MACT,QAAS,MACT,QAAS,MACT,QAAS,KACT,QAAS,KACT,QAAS,KACT,QAAS,KACT,QAAS,KACT,QAAS,KACT,QAAS,KACT,QAAS,KACT,QAAS,KACT,QAAS,KACT,QAAS,MACT,QAAS,KACT,QAAS,KACT,QAAS,MACT,QAAS,KACT,QAAS,MACT,QAAS,IACT,QAAS,KACT,QAAS,MACT,QAAS,KACT,QAAS,KACT,QAAS,MACT,QAAS,MACT,QAAS,MACT,QAAS,KACT,QAAS,MACT,QAAS,KACT,QAAS,MACT,QAAS,MACT,QAAS,MACT,QAAS,MACT,QAAS,MACT,QAAS,KACT,QAAS,MACT,QAAS,MACT,QAAS,KACT,QAAS,MACT,QAAS,MACT,QAAS,MACT,QAAS,MACT,QAAS,MACT,QAAS,MACT,QAAS,KACT,QAAS,MACT,QAAS,MACT,QAAS,MACT,QAAS,MACT,QAAS,MACT,QAAS,MACT,QAAS,KACT,QAAS,MACT,QAAS,MACT,QAAS,MACT,QAAS,KACT,QAAS,IACT,QAAS,MACT,QAAS,MACT,QAAS,KACT,OAAQ,IACR,OAAQ,IACR,OAAQ,IACR,OAAQ,KACR,OAAQ,IACR,OAAQ,KACR,OAAQ,KACR,OAAQ,IACR,OAAQ,IACR,OAAQ,IACR,OAAQ,MACR,OAAQ,KACR,OAAQ,KACR,OAAQ,KACR,OAAQ,IACR,OAAQ,KACR,OAAQ,IACR,OAAQ,IACR,OAAQ,IACR,OAAQ,IACR,OAAQ,KACR,OAAQ,KACR,OAAQ,IACR,OAAQ,IACR,OAAQ,IACR,OAAQ,KACR,OAAQ,IACR,OAAQ,IACR,OAAQ,IACR,OAAQ,IACR,OAAQ,KACR,OAAQ,IACR,OAAQ,IACR,OAAQ,IACR,OAAQ,IACR,OAAQ,IACR,OAAQ,IACR,OAAQ,IACR,OAAQ,IACR,OAAQ,IACR,OAAQ,IACR,OAAQ,IACR,OAAQ,IACR,OAAQ,IACR,OAAQ,IACR,OAAQ,IACR,OAAQ,IACR,OAAQ,MACR,OAAQ,IACR,OAAQ,MACR,OAAQ,IACR,OAAQ,IACR,OAAQ,KACR,OAAQ,KACR,OAAQ,IACR,OAAQ,IACR,OAAQ,IACR,OAAQ,KACR,OAAQ,KACR,OAAQ,KACR,OAAQ,IACR,OAAQ,IACR,OAAQ,IACR,OAAQ,IACR,OAAQ,IACR,OAAQ,IACR,OAAQ,IACR,OAAQ,IACR,OAAQ,MACR,OAAQ,KACR,OAAQ,KACR,OAAQ,IACR,OAAQ,IACR,OAAQ,IACR,OAAQ,IACR,OAAQ,IACR,OAAQ,IACR,OAAQ,MACR,OAAQ,KACR,OAAQ,KACR,OAAQ,MACR,OAAQ,KACR,OAAQ,IACR,OAAQ,KACR,OAAQ,KACR,OAAQ,KACR,OAAQ,KACR,OAAQ,KACR,OAAQ,KACR,OAAQ,KACR,OAAQ,MACR,OAAQ,KACR,OAAQ,KACR,OAAQ,MACR,OAAQ,KACR,OAAQ,IACR,OAAQ,KACR,OAAQ,KACR,OAAQ,IACR,OAAQ,MACR,OAAQ,MACR,OAAQ,MACR,OAAQ,MACR,OAAQ,IACR,OAAQ,IACR,OAAQ,KACR,OAAQ,MACR,OAAQ,KACR,OAAQ,GACR,OAAQ,KACR,OAAQ,KACR,OAAQ,KACR,OAAQ,KACR,OAAQ,KACR,OAAQ,MACR,OAAQ,MACR,OAAQ,KACR,OAAQ,KACR,OAAQ,IACR,OAAQ,KACR,OAAQ,KACR,OAAQ,KACR,OAAQ,IACR,OAAQ,MACR,OAAQ,IACR,OAAQ,KACR,OAAQ,KACR,OAAQ,KACR,OAAQ,GACR,OAAQ,KACR,OAAQ,KACR,OAAQ,IACR,OAAQ,IACR,OAAQ,MACR,OAAQ,IACR,OAAQ,KACR,OAAQ,IACR,OAAQ,MACR,OAAQ,MACR,OAAQ,KACR,OAAQ,KACR,OAAQ,KACR,OAAQ,MACR,OAAQ,KACR,OAAQ,GACR,OAAQ,KACR,OAAQ,KACR,OAAQ,MACR,OAAQ,MACR,OAAQ,KACR,OAAQ,IACR,OAAQ,KACR,OAAQ,IACR,OAAQ,KACR,OAAQ,KACR,OAAQ,KACR,OAAQ,KACR,OAAQ,KACR,OAAQ,IACR,OAAQ,KACR,OAAQ,KACR,OAAQ,KACR,OAAQ,KACR,OAAQ,KACR,OAAQ,KACR,OAAQ,IACR,OAAQ,IACR,OAAQ,IACR,OAAQ,MACR,OAAQ,MACR,OAAQ,MACR,OAAQ,MACR,OAAQ,KACR,OAAQ,KACR,OAAQ,KACR,OAAQ,KACR,OAAQ,KACR,OAAQ,KACR,OAAQ,KACR,OAAQ,KACR,OAAQ,KACR,OAAQ,KACR,OAAQ,KACR,OAAQ,IACR,OAAQ,KACR,OAAQ,KACR,OAAQ,IACR,OAAQ,IACR,OAAQ,MACR,OAAQ,MACR,OAAQ,KACR,OAAQ,IACR,OAAQ,KACR,OAAQ,IACR,OAAQ,KACR,OAAQ,IACR,OAAQ,KACR,OAAQ,KACR,OAAQ,IACR,OAAQ,IACR,OAAQ,MACR,OAAQ,IACR,OAAQ,KACR,OAAQ,IACR,OAAQ,MACR,OAAQ,MACR,OAAQ,KACR,OAAQ,KACR,OAAQ,MACR,OAAQ,KACR,OAAQ,MACR,OAAQ,IACR,OAAQ,GACR,OAAQ,IACR,OAAQ,IACR,OAAQ,KACR,OAAQ,MACR,OAAQ,MACR,OAAQ,MACR,OAAQ,KACR,OAAQ,MACR,OAAQ,MACR,OAAQ,IACR,OAAQ,KACR,OAAQ,MACR,OAAQ,KACR,OAAQ,GACR,OAAQ,MACR,OAAQ,MACR,OAAQ,KACR,OAAQ,KACR,OAAQ,IACR,OAAQ,KACR,OAAQ,KACR,OAAQ,MACR,OAAQ,MACR,OAAQ,KACR,OAAQ,KACR,OAAQ,MACR,OAAQ,GACR,OAAQ,MACR,OAAQ,IACR,OAAQ,KACR,OAAQ,KACR,OAAQ,KACR,OAAQ,KACR,OAAQ,KACR,OAAQ,KACR,OAAQ,KACR,OAAQ,IACR,OAAQ,IACR,OAAQ,IACR,OAAQ,MACR,OAAQ,KACR,OAAQ,MACR,OAAQ,KACR,OAAQ,KACR,OAAQ,KACR,OAAQ,KACR,OAAQ,KACR,OAAQ,KACR,OAAQ,IACR,OAAQ,KACR,OAAQ,KACR,OAAQ,MACR,OAAQ,KACR,OAAQ,MACR,OAAQ,MACR,OAAQ,MACR,OAAQ,MACR,OAAQ,IACR,OAAQ,IACR,OAAQ,MACR,OAAQ,IACR,OAAQ,KACR,OAAQ,KACR,OAAQ,IACR,OAAQ,IACR,OAAQ,KACR,OAAQ,MACR,OAAQ,GACR,OAAQ,GACR,OAAQ,KACR,OAAQ,KACR,OAAQ,KACR,OAAQ,KACR,OAAQ,KACR,OAAQ,MACR,OAAQ,IACR,OAAQ,MACR,OAAQ,KACR,OAAQ,KACR,OAAQ,KACR,OAAQ,KACR,OAAQ,KACR,OAAQ,KACR,OAAQ,MACR,OAAQ,IACR,OAAQ,MACR,OAAQ,MACR,OAAQ,MACR,OAAQ,KACR,OAAQ,KACR,OAAQ,MACR,OAAQ,KACR,OAAQ,MACR,OAAQ,IACR,OAAQ,GACR,OAAQ,IACR,OAAQ,IACR,OAAQ,KACR,OAAQ,MACR,OAAQ,KACR,OAAQ,MACR,OAAQ,KACR,OAAQ,MACR,OAAQ,MACR,OAAQ,KACR,OAAQ,KACR,OAAQ,KACR,OAAQ,KACR,OAAQ,IACR,OAAQ,IACR,OAAQ,IACR,OAAQ,KACR,OAAQ,MACR,OAAQ,MACR,OAAQ,KACR,OAAQ,KACR,OAAQ,IACR,OAAQ,IACR,OAAQ,MACR,OAAQ,MACR,OAAQ,KACR,OAAQ,KACR,OAAQ,KACR,OAAQ,KACR,OAAQ,KACR,OAAQ,KACR,OAAQ,KACR,OAAQ,KACR,OAAQ,KACR,OAAQ,KACR,OAAQ,MACR,OAAQ,KACR,OAAQ,MACR,OAAQ,MACR,OAAQ,MACR,OAAQ,MACR,OAAQ,MACR,OAAQ,KACR,OAAQ,MACR,OAAQ,MACR,OAAQ,MACR,OAAQ,MACR,OAAQ,MACR,OAAQ,KACR,OAAQ,IACR,OAAQ,IACR,OAAQ,KACR,OAAQ,KACR,OAAQ,IACR,OAAQ,KACR,OAAQ,KACR,OAAQ,KACR,OAAQ,MACR,OAAQ,KACR,OAAQ,MACR,OAAQ,KACR,OAAQ,KACR,OAAQ,IACR,OAAQ,IACR,OAAQ,IACR,OAAQ,IACR,OAAQ,MACR,OAAQ,IACR,OAAQ,KACR,OAAQ,KACR,OAAQ,KACR,OAAQ,KACR,OAAQ,IACR,OAAQ,MACR,OAAQ,IACR,OAAQ,KACR,OAAQ,KACR,OAAQ,KACR,OAAQ,IACR,OAAQ,MACR,OAAQ,KACR,OAAQ,KACR,OAAQ,KACR,OAAQ,MACR,OAAQ,MACR,OAAQ,MACR,OAAQ,MACR,OAAQ,KACR,OAAQ,IACR,OAAQ,IACR,OAAQ,IACR,OAAQ,KACR,MAAO,IACP,MAAO,IACP,MAAO,IACP,MAAO,IACP,MAAO,IACP,MAAO,IACP,MAAO,IACP,MAAO,IACP,MAAO,KACP,MAAO,MACP,MAAO,MACP,MAAO,IACP,MAAO,IACP,MAAO,IACP,MAAO,IACP,MAAO,MACP,MAAO,IACP,MAAO,IACP,MAAO,IACP,MAAO,IACP,MAAO,IACP,MAAO,IACP,MAAO,IACP,MAAO,IACP,MAAO,KACP,MAAO,IACP,MAAO,KACP,MAAO,IACP,MAAO,IACP,MAAO,IACP,MAAO,IACP,MAAO,IACP,MAAO,KACP,MAAO,MACP,MAAO,IACP,MAAO,IACP,MAAO,IACP,MAAO,KACP,MAAO,KACP,MAAO,IACP,MAAO,KACP,MAAO,KACP,MAAO,IACP,MAAO,IACP,MAAO,KACP,MAAO,IACP,MAAO,KACP,MAAO,IACP,MAAO,KACP,MAAO,KACP,MAAO,IACP,MAAO,KACP,MAAO,IACP,MAAO,IACP,MAAO,IACP,MAAO,IACP,MAAO,KACP,MAAO,IACP,MAAO,IACP,MAAO,MACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,IACP,MAAO,IACP,MAAO,KACP,MAAO,MACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,IACP,MAAO,KACP,MAAO,KACP,MAAO,MACP,MAAO,MACP,MAAO,KACP,MAAO,KACP,MAAO,IACP,MAAO,MACP,MAAO,IACP,MAAO,MACP,MAAO,IACP,MAAO,MACP,MAAO,KACP,MAAO,GACP,MAAO,GACP,MAAO,KACP,MAAO,MACP,MAAO,MACP,MAAO,MACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,MACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,IACP,MAAO,KACP,MAAO,IACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,MACP,MAAO,MACP,MAAO,IACP,MAAO,KACP,MAAO,IACP,MAAO,KACP,MAAO,IACP,MAAO,MACP,MAAO,IACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,MACP,MAAO,KACP,MAAO,KACP,MAAO,MACP,MAAO,MACP,MAAO,MACP,MAAO,KACP,MAAO,MACP,MAAO,KACP,MAAO,KACP,MAAO,IACP,MAAO,IACP,MAAO,MACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,GACP,MAAO,MACP,MAAO,MACP,MAAO,MACP,MAAO,KACP,MAAO,KACP,MAAO,IACP,MAAO,KACP,MAAO,IACP,MAAO,IACP,MAAO,KACP,MAAO,KACP,MAAO,IACP,MAAO,IACP,MAAO,KACP,MAAO,IACP,MAAO,IACP,MAAO,KACP,MAAO,IACP,MAAO,MACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,IACP,MAAO,IACP,MAAO,KACP,MAAO,IACP,MAAO,KACP,MAAO,MACP,MAAO,MACP,MAAO,IACP,MAAO,KACP,MAAO,MACP,MAAO,MACP,MAAO,MACP,MAAO,KACP,MAAO,KACP,MAAO,MACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,MACP,MAAO,KACP,MAAO,MACP,MAAO,MACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,MACP,MAAO,MACP,MAAO,KACP,MAAO,MACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,IACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,IACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,MACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,IACP,MAAO,KACP,MAAO,IACP,MAAO,MACP,MAAO,MACP,MAAO,KACP,MAAO,MACP,MAAO,KACP,MAAO,IACP,MAAO,IACP,MAAO,MACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,MACP,MAAO,KACP,MAAO,KACP,MAAO,MACP,MAAO,IACP,MAAO,KACP,MAAO,KACP,MAAO,MACP,MAAO,KACP,MAAO,GACP,MAAO,KACP,MAAO,MACP,MAAO,KACP,MAAO,MACP,MAAO,MACP,MAAO,IACP,MAAO,KACP,MAAO,MACP,MAAO,KACP,MAAO,KACP,MAAO,MACP,MAAO,MACP,MAAO,MACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,MACP,MAAO,MACP,MAAO,KACP,MAAO,MACP,MAAO,MACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,IACP,MAAO,MACP,MAAO,KACP,MAAO,KACP,MAAO,MACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,IACP,MAAO,KACP,MAAO,MACP,MAAO,MACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,IACP,MAAO,MACP,MAAO,KACP,MAAO,MACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,IACP,MAAO,IACP,MAAO,KACP,MAAO,IACP,MAAO,IACP,MAAO,IACP,MAAO,KACP,MAAO,MACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,IACP,MAAO,KACP,MAAO,MACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,IACP,MAAO,IACP,MAAO,KACP,MAAO,IACP,MAAO,IACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,MACP,MAAO,KACP,MAAO,IACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,IACP,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,MACP,MAAO,MACP,MAAO,MACP,MAAO,MACP,MAAO,MACP,MAAO,MACP,MAAO,MACP,MAAO,KACP,MAAO,IACP,KAAM,OACN,KAAM,OACN,KAAM,IACN,KAAM,MACN,KAAM,IACN,KAAM,OACN,KAAM,KACN,KAAM,KACN,KAAM,IACN,KAAM,IACN,KAAM,KACN,KAAM,OACN,KAAM,KACN,KAAM,KACN,KAAM,KACN,KAAM,KACN,KAAM,OACN,KAAM,OACN,KAAM,IACN,KAAM,OACN,KAAM,KACN,KAAM,MACN,KAAM,IACN,KAAM,OACN,KAAM,KACN,KAAM,KACN,KAAM,IACN,KAAM,OACN,KAAM,OACN,KAAM,KACN,KAAM,KACN,KAAM,KACN,KAAM,KACN,KAAM,IACN,KAAM,OACN,KAAM,IACN,KAAM,KACN,KAAM,IACN,KAAM,OACN,KAAM,OACN,KAAM,KACN,KAAM,KACN,KAAM,OACN,KAAM,OACN,KAAM,KACN,KAAM,MACN,KAAM,KACN,KAAM,OACN,KAAM,KACN,KAAM,OACN,KAAM,KACN,KAAM,KACN,KAAM,KACN,KAAM,OACN,KAAM,OACN,KAAM,OACN,KAAM,IACN,KAAM,KACN,KAAM,OACN,KAAM,GACN,KAAM,KACN,KAAM,OACN,KAAM,MACN,KAAM,KACN,KAAM,KACN,KAAM,KACN,KAAM,KACN,KAAM,OACN,KAAM,KACN,KAAM,OACN,KAAM,KACN,KAAM,KACN,KAAM,OACN,KAAM,OACN,KAAM,KACN,KAAM,OACN,KAAM,IACN,KAAM,OACN,KAAM,IACN,KAAM,MACN,KAAM,KACN,KAAM,OACN,KAAM,OACN,KAAM,OACN,KAAM,OACN,KAAM,OACN,KAAM,OACN,KAAM,KACN,KAAM,KACN,KAAM,KACN,KAAM,OACN,KAAM,OACN,KAAM,IACN,KAAM,KACN,KAAM,IACN,KAAM,IACN,KAAM,KACN,KAAM,OACN,KAAM,MACN,KAAM,MACN,KAAM,MACN,KAAM,OACN,KAAM,KACN,KAAM,GACN,KAAM,OACN,KAAM,IACN,KAAM,MACN,KAAM,KACN,KAAM,IACN,KAAM,KACN,KAAM,KACN,KAAM,OACN,KAAM,KACN,KAAM,KACN,KAAM,KACN,KAAM,KACN,KAAM,OACN,KAAM,KACN,KAAM,GACN,KAAM,KACN,KAAM,KACN,KAAM,IACN,KAAM,IACN,KAAM,KACN,KAAM,MACN,KAAM,IACN,KAAM,KACN,KAAM,KACN,KAAM,KACN,KAAM,OACN,KAAM,IACN,KAAM,OACN,KAAM,MACN,KAAM,MACN,KAAM,KACN,KAAM,MACN,KAAM,KACN,KAAM,KACN,KAAM,KACN,KAAM,KACN,KAAM,OACN,KAAM,OACN,KAAM,KACN,KAAM,MACN,KAAM,KACN,KAAM,KACN,KAAM,KACN,KAAM,KACN,KAAM,IACN,KAAM,KACN,KAAM,KACN,KAAM,OACN,KAAM,KACN,KAAM,KACN,KAAM,KACN,KAAM,KACN,KAAM,IACN,KAAM,KACN,KAAM,GACN,KAAM,KACN,KAAM,IACN,KAAM,OACN,KAAM,KACN,KAAM,OACN,KAAM,IACN,KAAM,KACN,KAAM,KACN,KAAM,MACN,KAAM,MACN,KAAM,OACN,KAAM,KACN,KAAM,KACN,KAAM,MACN,KAAM,KACN,KAAM,IACN,KAAM,KACN,KAAM,KACN,KAAM,OACN,KAAM,OACN,KAAM,KACN,KAAM,KACN,KAAM,KACN,KAAM,OACN,KAAM,IACN,KAAM,OACN,KAAM,KACN,KAAM,IACN,KAAM,OACN,KAAM,OACN,KAAM,KACN,KAAM,KACN,KAAM,OACN,KAAM,KACN,KAAM,KACN,KAAM,MACN,KAAM,MACN,KAAM,KACN,KAAM,MACN,KAAM,IACN,KAAM,MACN,KAAM,KACN,KAAM,KACN,KAAM,KACN,KAAM,MACN,KAAM,MACN,KAAM,OACN,KAAM,MACN,KAAM,GACN,KAAM,OACN,KAAM,KACN,KAAM,GACN,KAAM,MACN,KAAM,KACN,KAAM,IACN,KAAM,KACN,KAAM,MACN,KAAM,MACN,KAAM,KACN,KAAM,OACN,KAAM,OACN,KAAM,IACN,KAAM,MACN,KAAM,MACN,KAAM,KACN,KAAM,KACN,KAAM,KACN,KAAM,KACN,KAAM,KACN,KAAM,KACN,KAAM,KACN,KAAM,OACN,KAAM,KACN,KAAM,OACN,KAAM,KACN,KAAM,KACN,KAAM,KACN,KAAM,KACN,KAAM,KACN,KAAM,KACN,KAAM,KACN,KAAM,MACN,KAAM,KACN,KAAM,IACN,KAAM,KACN,KAAM,MACN,KAAM,OACN,KAAM,MACN,KAAM,IACN,KAAM,IACN,KAAM,MACN,KAAM,KACN,KAAM,KACN,KAAM,IACN,KAAM,IACN,KAAM,KACN,KAAM,KACN,KAAM,IACN,KAAM,GACN,KAAM,OACN,KAAM,MACN,KAAM,KACN,KAAM,MACN,KAAM,KACN,KAAM,KACN,KAAM,OACN,KAAM,MACN,KAAM,OACN,KAAM,OACN,KAAM,GACN,KAAM,KACN,KAAM,MACN,KAAM,MACN,KAAM,MACN,KAAM,KACN,KAAM,IACN,KAAM,MACN,KAAM,KACN,KAAM,KACN,KAAM,KACN,KAAM,KACN,KAAM,IACN,KAAM,OACN,KAAM,GACN,KAAM,OACN,KAAM,GACN,KAAM,KACN,KAAM,MACN,KAAM,MACN,KAAM,KACN,KAAM,IACN,KAAM,GACN,KAAM,MACN,KAAM,KACN,KAAM,KACN,KAAM,MACN,KAAM,MACN,KAAM,KACN,KAAM,MACN,KAAM,MACN,KAAM,OACN,KAAM,KACN,KAAM,KACN,KAAM,OACN,KAAM,KACN,KAAM,MACN,KAAM,KACN,KAAM,KACN,KAAM,KACN,KAAM,IACN,KAAM,IACN,KAAM,IACN,KAAM,MACN,KAAM,KACN,KAAM,KACN,KAAM,KACN,KAAM,KACN,KAAM,MACN,KAAM,OACN,KAAM,MACN,KAAM,KACN,KAAM,OACN,KAAM,KACN,KAAM,KACN,KAAM,MACN,KAAM,KACN,KAAM,OACN,KAAM,IACN,KAAM,OACN,KAAM,KACN,KAAM,IACN,KAAM,KACN,KAAM,MACN,KAAM,KACN,KAAM,IACN,KAAM,OACN,KAAM,OACN,KAAM,OACN,KAAM,OACN,KAAM,KACN,KAAM,KACN,KAAM,MACN,KAAM,KACN,KAAM,OACN,KAAM,OACN,KAAM,KACN,KAAM,KACN,KAAM,KACN,KAAM,OACN,KAAM,OACN,KAAM,KACN,KAAM,IACN,KAAM,IACN,KAAM,IACN,KAAM,KACN,KAAM,OACN,KAAM,OACN,KAAM,KACN,IAAK,GACL,IAAK,KACL,IAAK,OACL,IAAK,MACL,IAAK,KACL,IAAK,OACL,IAAK,KACL,IAAK,KACL,IAAK,IACL,IAAK,KACL,IAAK,KACL,IAAK,KACL,IAAK,OACL,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,KACL,IAAK,OACL,IAAK,IACL,IAAK,KACL,IAAK,OACL,IAAK,KACL,IAAK,OACL,IAAK,GACL,IAAK,KACL,IAAK,KACL,IAAK,KACL,IAAK,KACL,IAAK,KACL,IAAK,OACL,IAAK,KACL,IAAK,OACL,IAAK,KACL,IAAK,OACL,IAAK,KACL,IAAK,MACL,IAAK,KACL,IAAK,OACL,IAAK,KACL,IAAK,OACL,IAAK,MACL,IAAK,KACL,IAAK,OACL,IAAK,KACL,IAAK,OACL,IAAK,IACL,IAAK,IACL,IAAK,OACL,IAAK,IACL,IAAK,KACL,IAAK,KACL,IAAK,IACL,IAAK,KACL,IAAK,KACL,IAAK,OACL,IAAK,KACL,IAAK,KACL,IAAK,KACL,IAAK,EACL,IAAK,IACL,IAAK,KACL,IAAK,OACL,IAAK,KACL,IAAK,OACL,IAAK,KACL,IAAK,KACL,IAAK,OACL,IAAK,OACL,IAAK,OACL,IAAK,KACL,IAAK,OACL,IAAK,KACL,IAAK,KACL,IAAK,KACL,IAAK,KACL,IAAK,OACL,IAAK,GACL,IAAK,KACL,IAAK,KACL,IAAK,MACL,IAAK,KACL,IAAK,GACL,IAAK,KACL,IAAK,OACL,IAAK,KACL,IAAK,KACL,IAAK,OACL,IAAK,IACL,IAAK,KACL,IAAK,KACL,IAAK,KACL,IAAK,IACL,IAAK,OACL,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,KACL,IAAK,OACL,IAAK,MACL,IAAK,KACL,IAAK,MACL,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,KACL,IAAK,OACL,IAAK,MACL,IAAK,MACL,IAAK,KACL,IAAK,KACL,IAAK,KACL,IAAK,MACL,IAAK,OACL,IAAK,KACL,IAAK,MACL,IAAK,MACL,IAAK,MACL,IAAK,KACL,IAAK,MACL,IAAK,OACL,IAAK,KACL,IAAK,KACL,IAAK,OACL,IAAK,KACL,IAAK,KACL,IAAK,OACL,IAAK,KACL,IAAK,OACL,IAAK,MACL,IAAK,MACL,IAAK,MACL,IAAK,KACL,IAAK,KACL,IAAK,KACL,IAAK,MACL,IAAK,OACL,IAAK,MACL,IAAK,KACL,IAAK,MACL,IAAK,KACL,IAAK,KACL,IAAK,KACL,IAAK,KACL,IAAK,KACL,IAAK,OACL,IAAK,KACL,IAAK,KACL,IAAK,KACL,IAAK,KACL,IAAK,OACL,IAAK,KACL,IAAK,KACL,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G,GAAG,EAAE,GAAG,GAAG,GAAG,EAAE,GAAG,GAAG,GAAG,EAAE,GAAG,GAAG,IAAI,GAAG,IAAI,GAAG,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,GAAG,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,GAAG,GAAG,EAAE,EAAE,EAAE,GAAG,EAAE,GAAG,GAAG,EAAE,EAAE,GAAG,EAAE,GAAG,GAAG,GAAG,EAAE,GAAG,GAAG,IAAI,EAAE,EAAE,GAAG,GAAG,EAAE,GAAG,GAAG,IAAI,EAAE,EAAE,EAAE,EAAE,GAAG,GAAG,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,GAAG,GAAG,EAAE,IAAI,GAAG,IAAI,EAAE,GAAG,IAAI,IAAI,IAAI,GAAG,IAAI,KAAK,KAAK,KAAK,IAAI,KAAK,IAAI,EAAE,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,EAAE,GAAG,GAAG,EAAE,GAAG,IAAI,GAAG,IAAI,GAAG,EAAE,EAAE,GAAG,GAAG,GAAG,EAAE,EAAE,EAAE,GAAG,KAAK,EAAE,KAAK,GAAG,EAAE,KAAK,IAAI,GAAG,EAAE,GAAG,EAAE,EAAE,IAAI,KAAK,IAAI,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,KAAK,GAAG,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,IAAI,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,EAAE,KAAK,GAAG,GAAG,EAAE,GAAG,EAAE,IAAI,GAAG,KAAK,IAAI,GAAG,GAAG,EAAE,EAAE,KAAK,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,KAAK,MAAM,GAAG,KAAK,GAAG,IAAI,EAAE,KAAK,GAAG,KAAK,KAAK,IAAI,KAAK,MAGpyC,GAAwB,CAAC,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,KAAK,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,IAAI,EAAE,IAAI,EAAE,EAAE,EAAE,IAAI,EAAE,IAAI,GAAG,IAAI,EAAE,GAAG,GAAG,GAAG,EAAE,GAAG,EAAE,GAAG,GAAG,GAAG,EAAE,EAAE,EAAE,GAAG,GAAG,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,GAAG,EAAE,EAAE,EAAE,GAAG,GAAG,GAAG,EAAE,EAAE,IAAI,GAAG,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,IAAI,GAAG,GAAG,EAAE,EAAE,EAAE,GAAG,GAAG,GAAG,EAAE,IAAI,EAAE,EAAE,EAAE,GAAG,EAAE,GAAG,GAAG,GAAG,EAAE,GAAG,GAAG,EAAE,EAAE,GAAG,GAAG,EAAE,EAAE,IAAI,GAAG,IAAI,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,IAAI,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,GAAG,GAAG,GAAG,IAAI,EAAE,EAAE,EAAE,GAAG,EAAE,GAAG,GAAG,EAAE,GAAG,IAAI,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,IAAI,EAAE,MAAM,EAAE,IAAI,EAAE,GAAG,EAAE,GAAG,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GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,IAAK,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAEzG,GAAI,GAAI,GAAI,IAAK,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAEzG,EAAkB,QAAU,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAEnI,GAAI,IAAK,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAEzG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,IAAK,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAEzG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,IAAK,GAAI,GAAI,GAAI,GAAI,GAAI,GAEzG,EAAkB,QAAU,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAEnI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,IAAK,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAEzG,GAAI,GAAI,GAAI,GAAI,GAAI,IAAK,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,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,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,KAAM,KAAM,GAAI,GAAI,GAAI,GAAI,GAAI,GAE7H,GAAI,GAAI,GAAI,GAAI,GAAI,KAAM,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAE1G,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,KAAM,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAE1G,EAAkB,QAAU,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAEnI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,KAAM,GAAI,GAAI,GAAI,GAAI,GAAI,GAE1G,GAAI,KAAM,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAE1G,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,KAAM,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAE1G,GAAI,GAAI,GAAI,KAAM,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAE1G,GAAI,GAAI,GAAI,GAAI,GAAI,KAAM,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAE1G,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,KAAM,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAE1G,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,KAAM,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAEzG,GAAG,aAAe,GAAK,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAE/H,GAAI,GAAI,GAAI,GAAI,GAAI,KAAM,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAE1G,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,KAAM,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAE1G,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,KAAM,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAE1G,GAAI,KAAM,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAE1G,GAAI,GAAI,GAAI,KAAM,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAE1G,GAAI,GAAI,GAAI,GAAI,GAAI,KAAM,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,G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,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,KAAM,GAAI,GAAI,GAAI,GAAI,GAE1G,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,KAAM,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAE1G,GAAI,GAAI,GAAI,GAAI,GAAI,KAAM,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAE1G,EAAkB,SAAW,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAEpI,GAAI,KAAM,GAAI,GAAI,GAAI,KAAM,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,KAAM,GAAI,GAAI,GAAI,GAAI,GAE9G,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,KAAM,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAE1G,GAAI,GAAI,GAAI,GAAI,GAAI,KAAM,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAE1G,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,KAAM,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAE1G,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,KAAM,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAE1G,GAAI,KAAM,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAE1G,GAAI,GAAI,GAAI,KAAM,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAE1G,GAAI,GAAI,GAAI,GAAI,GAAI,KAAM,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAE1G,EAAkB,YAAc,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAEvI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,KAAM,GAAI,GAAI,GAEzG,GAAG,MAAQ,GAAK,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAExH,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,KAAM,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAE1G,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,KAAM,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAEzG,GAAG,OAAS,GAAK,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAEzH,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,KAAM,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,KAAM,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAE5G,EAAkB,KAAO,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAEhI,GAAI,KAAM,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAE1G,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,KAAM,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAE1G,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,KAAM,GAAI,GAAI,GAAI,GAAI,GAE1G,GAAI,GAAI,GAAI,GAAI,GAAI,KAAM,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAE1G,EAAkB,SAAW,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAEpI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,KAAM,GAAI,GAAI,KAAM,GAAI,GAAI,GAAI,GAAI,GAE5G,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,KAAM,GAAI,GAAI,GAAI,GAAI,GAAI,KAAM,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAE5G,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,KAAM,GAAI,GAAI,GAAI,GAE1G,GAAI,KAAM,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAE1G,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,KAAM,GAAI,GAAI,GAAI,GAAI,GAAI,GAE1G,GAAI,GAAI,GAAI,GAAI,GAAI,KAAM,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAE1G,EAAkB,UAAY,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAErI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,KAAM,GAAI,GAAI,GAAI,GAAI,GAAI,GAE1G,GAAI,GAAI,GAAI,GAAI,GAAI,KAAM,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,KAAM,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAE5G,GAAI,GAAI,GAAI,KAAM,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAE1G,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,KAAM,GAAI,GAAI,GAAI,GAAI,GAAI,GAE1G,GAAI,GAAI,GAAI,GAAI,GAAI,KAAM,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAE1G,GAAI,GAAI,GAAI,GAAI,KAAM,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAE1G,EAAkB,YAAc,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAEvI,EAAkB,QAAU,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAEnI,GAAI,GAAI,KAAM,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAE1G,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,KAAM,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAE1G,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,KAAM,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAE1G,GAAI,GAAI,GAAI,KAAM,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAE1G,EAAkB,SAAW,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAEpI,GAAI,GAAI,GAAI,GAAI,GAAI,KAAM,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAE1G,GAAI,KAAM,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,KAAM,GAAI,GAAI,KAAM,GAAI,GAAI,GAAI,GAAI,GAAI,GAE9G,GAAI,GAAI,GAAI,GAAI,KAAM,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAE1G,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,KAAM,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAE1G,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,KAAM,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAE1G,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,KAAM,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAE1G,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,KAAM,GAE1G,EAAkB,WAAa,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAEtI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,KAAM,GAAI,GAAI,GAAI,GAAI,GAE1G,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,KAAM,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAE1G,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,KAAM,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAE1G,GAAI,GAAI,GAAI,GAAI,GAAI,KAAM,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAE1G,EAAkB,UAAY,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAErI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,KAAM,GAAI,GAAI,GAAI,GAAI,GAE1G,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,KAAM,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAE1G,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,KAAM,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI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",
  "names": []
}
